{"sha": "fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZDU5ZDY2OWM1Y2EzYzBlOWMzOWRjYjFmNjUxMGI1ODc2ZWRlNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T09:59:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-01T09:59:54Z"}, "message": "Auto merge of #84786 - JohnTitor:rollup-j5omx6f, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #84601 (rustdoc: Only store locations in Cache::extern_locations and calculate the other info on-demand)\n - #84704 (platform-support.md: Update for consistency with Target Tier Policy)\n - #84724 (Replace llvm::sys::fs::F_None with llvm::sys::fs::OF_None)\n - #84740 (Reset the docs' copy path button after 1 second)\n - #84749 (Sync `rustc_codegen_cranelift`)\n - #84756 (Add a ToC to the Target Tier Policy documentation)\n - #84765 (Update cargo)\n - #84774 (Fix misspelling)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "71be961123cb9718153613d9a53c138f2a409075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71be961123cb9718153613d9a53c138f2a409075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "html_url": "https://github.com/rust-lang/rust/commit/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "html_url": "https://github.com/rust-lang/rust/commit/1c2c6b670023efda0fea8e1837f9542d3ed12f5d"}, {"sha": "6af045f00a3bf7d34a2dcd84d1f89e2b5fef0f36", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af045f00a3bf7d34a2dcd84d1f89e2b5fef0f36", "html_url": "https://github.com/rust-lang/rust/commit/6af045f00a3bf7d34a2dcd84d1f89e2b5fef0f36"}], "stats": {"total": 2639, "additions": 1105, "deletions": 1534}, "files": [{"sha": "4d45e36c956c908f5ee1f0f295a00b0dc6c95ec7", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -80,3 +80,10 @@ jobs:\n       with:\n         name: cg_clif-${{ runner.os }}\n         path: cg_clif.tar.xz\n+\n+    - name: Upload prebuilt cg_clif (cross compile)\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      uses: actions/upload-artifact@v2\n+      with:\n+        name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n+        path: cg_clif.tar.xz"}, {"sha": "9009a532c54dcc91ac5ea9943a48ba63f0803bc9", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,6 +1,6 @@\n {\n     // source for rustc_* is not included in the rust-src component; disable the errors about this\n-    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"macro-error\"],\n+    \"rust-analyzer.diagnostics.disabled\": [\"unresolved-extern-crate\", \"unresolved-macro-call\"],\n     \"rust-analyzer.assist.importMergeBehavior\": \"last\",\n     \"rust-analyzer.cargo.runBuildScripts\": true,\n     \"rust-analyzer.linkedProjects\": ["}, {"sha": "e6792def56796c2cc1ba0e328c73bb251a3404be", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -39,16 +39,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -65,27 +65,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -95,8 +95,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -113,8 +113,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -125,17 +125,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.72.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#8e43e96410a14143d368273cf1e708f8094bb8e0\"\n+version = \"0.73.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#45bee40f338c631bff4a799288101ba328c7ad36\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -306,6 +306,7 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n+ \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -334,9 +335,9 @@ dependencies = [\n \n [[package]]\n name = \"target-lexicon\"\n-version = \"0.11.2\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"422045212ea98508ae3d28025bc5aaa2bd4a9cdaecd442a08da2ee620ee9ea95\"\n+checksum = \"64ae3b39281e4b14b8123bdbaddd472b7dfe215e444181f2f9d2443c2444f834\"\n \n [[package]]\n name = \"thiserror\""}, {"sha": "2789207c65581ab380463f0ff114ddeb7a601159", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -9,12 +9,13 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n+cranelift-native = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n cranelift-object = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n-target-lexicon = \"0.11.0\"\n+target-lexicon = \"0.12.0\"\n gimli = { version = \"0.23.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.23.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n@@ -28,6 +29,7 @@ smallvec = \"1.6.1\"\n #cranelift-codegen = { path = \"../wasmtime/cranelift/codegen\" }\n #cranelift-frontend = { path = \"../wasmtime/cranelift/frontend\" }\n #cranelift-module = { path = \"../wasmtime/cranelift/module\" }\n+#cranelift-native = { path = ../wasmtime/cranelift/native\" }\n #cranelift-jit = { path = \"../wasmtime/cranelift/jit\" }\n #cranelift-object = { path = \"../wasmtime/cranelift/object\" }\n "}, {"sha": "08f9373be6262ba35226ceb02fb0a3f5aba22be8", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -44,9 +44,10 @@ This will build your project with rustc_codegen_cranelift instead of the usual L\n \n For additional ways to use rustc_codegen_cranelift like the JIT mode see [usage.md](docs/usage.md).\n \n-## Env vars\n+## Configuration\n \n-See [env_vars.md](docs/env_vars.md) for all env vars used by rustc_codegen_cranelift.\n+See the documentation on the `BackendConfig` struct in [config.rs](src/config.rs) for all\n+configuration options.\n \n ## Not yet supported\n "}, {"sha": "e058a972ead3c184c382937d3f5afd19afcfa95b", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -56,7 +56,7 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.39\"\n+version = \"0.1.40\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -132,9 +132,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.91\"\n+version = \"0.2.94\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8916b1f6ca17130ec6568feccee27c156ad12037880833a3b842a823236502e7\"\n+checksum = \"18794a8ad5b29321f790b55d93dfba91e125cb1a9edbd4f8e3150acc771c1a5e\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -167,6 +167,7 @@ dependencies = [\n name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n+ \"alloc\",\n  \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -242,10 +243,22 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"rustc-demangle\",\n+ \"std_detect\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"std_detect\"\n+version = \"0.1.5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"compiler_builtins\",\n+ \"libc\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"sysroot\"\n version = \"0.0.0\""}, {"sha": "f7fcef10774102706c7a5169a3882eec5930bee1", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2Fprepare_sysroot_src.sh?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -32,7 +32,7 @@ popd\n git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/compiler-builtins has already been cloned\"\n pushd compiler-builtins\n git checkout -- .\n-git checkout 0.1.39\n+git checkout 0.1.40\n git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n "}, {"sha": "b4acc4f5b73659923b329cc9fae53339f8335fa0", "filename": "compiler/rustc_codegen_cranelift/crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fcrate_patches%2F0001-compiler-builtins-Remove-rotate_left-from-Int.patch?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -17,8 +17,8 @@ index 06054c8..3bea17b 100644\n      fn wrapping_shr(self, other: u32) -> Self;\n -    fn rotate_left(self, other: u32) -> Self;\n      fn overflowing_add(self, other: Self) -> (Self, bool);\n-     fn aborting_div(self, other: Self) -> Self;\n-     fn aborting_rem(self, other: Self) -> Self;\n+     fn leading_zeros(self) -> u32;\n+ }\n @@ -209,10 +208,6 @@ macro_rules! int_impl_common {\n              <Self>::wrapping_shr(self, other)\n          }"}, {"sha": "f7fde1b4f3a873bbfc694a4bdaeb8cd5fe03fdb3", "filename": "compiler/rustc_codegen_cranelift/docs/env_vars.md", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fdocs%2Fenv_vars.md?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -1,15 +0,0 @@\n-# List of env vars recognized by cg_clif\n-\n-<dl>\n-    <dt>CG_CLIF_JIT_ARGS</dt>\n-    <dd>When JIT mode is enable pass these arguments to the program.</dd>\n-    <dt>CG_CLIF_INCR_CACHE_DISABLED</dt>\n-    <dd>Don't cache object files in the incremental cache. Useful during development of cg_clif\n-    to make it possible to use incremental mode for all analyses performed by rustc without caching\n-    object files when their content should have been changed by a change to cg_clif.</dd>\n-    <dt>CG_CLIF_DISPLAY_CG_TIME</dt>\n-    <dd>If \"1\", display the time it took to perform codegen for a crate.</dd>\n-    <dt>CG_CLIF_ENABLE_VERIFIER</dt>\n-    <dd>Enable the Cranelift ir verifier for all compilation passes. If not set it will only run once\n-    before passing the clif ir to Cranelift for compilation.</dt>\n-</dl>"}, {"sha": "6570f2bf9f297fbccf66a4681d639a91f266a18f", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -11,6 +11,22 @@ unsafe extern \"C\" fn my_puts(s: *const i8) {\n     puts(s);\n }\n \n+macro_rules! assert {\n+    ($e:expr) => {\n+        if !$e {\n+            panic(stringify!(! $e));\n+        }\n+    };\n+}\n+\n+macro_rules! assert_eq {\n+    ($l:expr, $r: expr) => {\n+        if $l != $r {\n+            panic(stringify!($l != $r));\n+        }\n+    }\n+}\n+\n #[lang = \"termination\"]\n trait Termination {\n     fn report(self) -> i32;\n@@ -20,8 +36,9 @@ impl Termination for () {\n     fn report(self) -> i32 {\n         unsafe {\n             NUM = 6 * 7 + 1 + (1u8 == 1u8) as u8; // 44\n-            *NUM_REF as i32\n+            assert_eq!(*NUM_REF as i32, 44);\n         }\n+        0\n     }\n }\n \n@@ -82,29 +99,12 @@ fn start<T: Termination + 'static>(\n         unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n     }\n \n-    main().report();\n-    0\n+    main().report() as isize\n }\n \n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-macro_rules! assert {\n-    ($e:expr) => {\n-        if !$e {\n-            panic(stringify!(! $e));\n-        }\n-    };\n-}\n-\n-macro_rules! assert_eq {\n-    ($l:expr, $r: expr) => {\n-        if $l != $r {\n-            panic(stringify!($l != $r));\n-        }\n-    }\n-}\n-\n struct Unique<T: ?Sized> {\n     pointer: *const T,\n     _marker: PhantomData<T>,\n@@ -296,6 +296,11 @@ fn main() {\n     unsafe {\n         global_asm_test();\n     }\n+\n+    // Both statics have a reference that points to the same anonymous allocation.\n+    static REF1: &u8 = &42;\n+    static REF2: &u8 = REF1;\n+    assert_eq!(*REF1, *REF2);\n }\n \n #[cfg(all(not(jit), target_os = \"linux\"))]"}, {"sha": "77ba72df8ef371ddbc1163c7b0f6f0aca38b0d7e", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -48,6 +48,8 @@ fn main() {\n     assert_eq!(2.3f32.copysign(-1.0), -2.3f32);\n     println!(\"{}\", 2.3f32.powf(2.0));\n \n+    assert_eq!(i64::MAX.checked_mul(2), None);\n+\n     assert_eq!(-128i8, (-128i8).saturating_sub(1));\n     assert_eq!(127i8, 127i8.saturating_sub(-128));\n     assert_eq!(-128i8, (-128i8).saturating_add(-128));\n@@ -84,6 +86,7 @@ fn main() {\n     assert_eq!(houndred_i128 as f64, 100.0);\n     assert_eq!(houndred_f32 as i128, 100);\n     assert_eq!(houndred_f64 as i128, 100);\n+    assert_eq!(1u128.rotate_left(2), 4);\n \n     // Test signed 128bit comparing\n     let max = usize::MAX as i128;"}, {"sha": "5442e3345aa913899488cf757816c1ebe01df325", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-03-29\"\n+channel = \"nightly-2021-04-28\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "3f98d77d76cad82fe2d7546f64f7b0407b576de4", "filename": "compiler/rustc_codegen_cranelift/scripts/ext_config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fext_config.sh?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -5,7 +5,7 @@\n set -e\n \n export CG_CLIF_DISPLAY_CG_TIME=1\n-export CG_CLIF_INCR_CACHE_DISABLED=1\n+export CG_CLIF_DISABLE_INCR_CACHE=1\n \n export HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n export TARGET_TRIPLE=${TARGET_TRIPLE:-$HOST_TRIPLE}"}, {"sha": "4821a07ac5d5de473b0efcc6c6a23811a908ad28", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -45,7 +45,7 @@ index d95b5b7f17f..00b6f0e3635 100644\n  [dependencies]\n  core = { path = \"../core\" }\n -compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std'] }\n-+compiler_builtins = { version = \"0.1.39\", features = ['rustc-dep-of-std', 'no-asm'] }\n++compiler_builtins = { version = \"0.1.40\", features = ['rustc-dep-of-std', 'no-asm'] }\n \n  [dev-dependencies]\n  rand = \"0.7\""}, {"sha": "347fb40e6f9e7bbf0999157ba046d052e6ab8f75", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -38,6 +38,7 @@ rm src/test/ui/threads-sendsync/task-stderr.rs\n rm src/test/ui/numbers-arithmetic/int-abs-overflow.rs\n rm src/test/ui/drop/drop-trait-enum.rs\n rm src/test/ui/numbers-arithmetic/issue-8460.rs\n+rm src/test/incremental/change_crate_dep_kind.rs # requires -Cpanic=unwind\n \n rm src/test/ui/issues/issue-28950.rs # depends on stack size optimizations\n rm src/test/ui/init-large-type.rs # same\n@@ -47,6 +48,7 @@ rm src/test/ui/issues/issue-51947.rs # same\n rm src/test/ui/numbers-arithmetic/saturating-float-casts.rs # intrinsic gives different but valid result\n rm src/test/ui/mir/mir_misc_casts.rs # depends on deduplication of constants\n rm src/test/ui/mir/mir_raw_fat_ptr.rs # same\n+rm src/test/ui/consts/issue-33537.rs # same\n rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n rm src/test/ui/generator/size-moved-locals.rs # same\n@@ -56,18 +58,21 @@ rm src/test/ui/intrinsics/intrinsic-nearby.rs # unimplemented nearbyintf32 and n\n \n rm src/test/incremental/hashes/inline_asm.rs # inline asm\n rm src/test/incremental/issue-72386.rs # same\n-rm src/test/incremental/change_crate_dep_kind.rs # requires -Cpanic=unwind\n rm src/test/incremental/issue-49482.rs # same\n rm src/test/incremental/issue-54059.rs # same\n rm src/test/incremental/lto.rs # requires lto\n \n+rm -r src/test/run-make/emit-shared-files # requires the rustdoc executable in build/bin/\n+rm -r src/test/run-make/unstable-flag-required # same\n+\n rm src/test/pretty/asm.rs # inline asm\n rm src/test/pretty/raw-str-nonexpr.rs # same\n \n rm -r src/test/run-pass-valgrind/unsized-locals\n \n rm src/test/ui/json-bom-plus-crlf-multifile.rs # differing warning\n rm src/test/ui/json-bom-plus-crlf.rs # same\n+rm src/test/ui/match/issue-82392.rs # differing error\n rm src/test/ui/type-alias-impl-trait/cross_crate_ice*.rs # requires removed aux dep\n \n rm src/test/ui/allocator/no_std-alloc-error-handler-default.rs # missing rust_oom definition"}, {"sha": "54c8fb0e7b80be401a13d87c8de39e46bd9ebc99", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -63,16 +63,16 @@ pub(crate) fn import_function<'tcx>(\n     module: &mut dyn Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n-    let name = tcx.symbol_name(inst).name.to_string();\n+    let name = tcx.symbol_name(inst).name;\n     let sig = get_function_sig(tcx, module.isa().triple(), inst);\n-    module.declare_function(&name, Linkage::Import, &sig).unwrap()\n+    module.declare_function(name, Linkage::Import, &sig).unwrap()\n }\n \n impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     /// Instance must be monomorphized\n     pub(crate) fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n-        let func_id = import_function(self.tcx, self.cx.module, inst);\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = import_function(self.tcx, self.module, inst);\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n         if self.clif_comments.enabled() {\n             self.add_comment(func_ref, format!(\"{:?}\", inst));\n@@ -89,8 +89,8 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature { params, returns, call_conv: CallConv::triple_default(self.triple()) };\n-        let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n-        let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n+        let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n+        let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n@@ -295,7 +295,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n pub(crate) fn codegen_terminator_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     span: Span,\n-    current_block: Block,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n     destination: Option<(Place<'tcx>, BasicBlock)>,\n@@ -357,7 +356,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         .map(|inst| fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD))\n         .unwrap_or(false);\n     if is_cold {\n-        fx.cold_blocks.insert(current_block);\n+        // FIXME Mark current_block block as cold once Cranelift supports it\n     }\n \n     // Unpack arguments tuple for closures"}, {"sha": "a09e32577869e7452c6ad1bb007e5c80c5629630", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::sym;\n pub(crate) fn codegen(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n ) -> bool {\n     let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE).iter().any(|(_, list)| {\n         use rustc_middle::middle::dependency_format::Linkage;\n@@ -29,7 +29,7 @@ pub(crate) fn codegen(\n \n fn codegen_inner(\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n ) {\n     let usize_ty = module.target_config().pointer_type();"}, {"sha": "05c06bac27db47d653f3cea67422290b9f7fe517", "filename": "compiler/rustc_codegen_cranelift/src/backend.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbackend.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -5,23 +5,23 @@ use std::convert::{TryFrom, TryInto};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_module::FuncId;\n+use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n use object::write::*;\n use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n-use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n-\n use gimli::SectionId;\n \n use crate::debuginfo::{DebugReloc, DebugRelocName};\n \n pub(crate) trait WriteMetadata {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, is_like_osx: bool);\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>);\n }\n \n impl WriteMetadata for object::write::Object {\n-    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>, _is_like_osx: bool) {\n+    fn add_rustc_section(&mut self, symbol_name: String, data: Vec<u8>) {\n         let segment = self.segment_name(object::write::StandardSegment::Data).to_vec();\n         let section_id = self.add_section(segment, b\".rustc\".to_vec(), object::SectionKind::Data);\n         let offset = self.append_section_data(section_id, &data, 1);\n@@ -113,7 +113,7 @@ impl WriteDebugInfo for ObjectProduct {\n }\n \n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n-    let triple = crate::build_isa(sess).triple().clone();\n+    let triple = crate::target_triple(sess);\n \n     let binary_format = match triple.binary_format {\n         target_lexicon::BinaryFormat::Elf => object::BinaryFormat::Elf,\n@@ -141,13 +141,9 @@ pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object\n     metadata_object.write().unwrap()\n }\n \n-pub(crate) fn make_module(sess: &Session, name: String) -> ObjectModule {\n-    let mut builder = ObjectBuilder::new(\n-        crate::build_isa(sess),\n-        name + \".o\",\n-        cranelift_module::default_libcall_names(),\n-    )\n-    .unwrap();\n+pub(crate) fn make_module(sess: &Session, isa: Box<dyn TargetIsa>, name: String) -> ObjectModule {\n+    let mut builder =\n+        ObjectBuilder::new(isa, name + \".o\", cranelift_module::default_libcall_names()).unwrap();\n     // Unlike cg_llvm, cg_clif defaults to disabling -Zfunction-sections. For cg_llvm binary size\n     // is important, while cg_clif cares more about compilation times. Enabling -Zfunction-sections\n     // can easily double the amount of time necessary to perform linking."}, {"sha": "3ec5c14ff17a2d8308657936aa5c21f15cfc6160", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 35, "deletions": 111, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -6,9 +6,14 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiExt;\n use rustc_target::abi::call::FnAbi;\n \n+use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n-pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: Instance<'tcx>) {\n+pub(crate) fn codegen_fn<'tcx>(\n+    cx: &mut crate::CodegenCx<'tcx>,\n+    module: &mut dyn Module,\n+    instance: Instance<'tcx>,\n+) {\n     let tcx = cx.tcx;\n \n     let _inst_guard =\n@@ -18,9 +23,9 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let name = tcx.symbol_name(instance).name.to_string();\n-    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n-    let func_id = cx.module.declare_function(&name, Linkage::Local, &sig).unwrap();\n+    let symbol_name = tcx.symbol_name(instance);\n+    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n+    let func_id = module.declare_function(symbol_name.name, Linkage::Local, &sig).unwrap();\n \n     cx.cached_context.clear();\n \n@@ -39,23 +44,26 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n         (0..mir.basic_blocks().len()).map(|_| bcx.create_block()).collect();\n \n     // Make FunctionCx\n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n     let mut fx = FunctionCx {\n         cx,\n+        module,\n         tcx,\n         pointer_type,\n+        vtables: FxHashMap::default(),\n+        constants_cx: ConstantCx::new(),\n \n         instance,\n+        symbol_name,\n         mir,\n         fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,\n         local_map: IndexVec::with_capacity(mir.local_decls.len()),\n         caller_location: None, // set by `codegen_fn_prelude`\n-        cold_blocks: EntitySet::new(),\n \n         clif_comments,\n         source_info_set: indexmap::IndexSet::new(),\n@@ -90,7 +98,8 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     let mut clif_comments = fx.clif_comments;\n     let source_info_set = fx.source_info_set;\n     let local_map = fx.local_map;\n-    let cold_blocks = fx.cold_blocks;\n+\n+    fx.constants_cx.finalize(fx.tcx, &mut *fx.module);\n \n     // Store function in context\n     let context = &mut cx.cached_context;\n@@ -103,29 +112,22 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n \n     // Perform rust specific optimizations\n     tcx.sess.time(\"optimize clif ir\", || {\n-        crate::optimize::optimize_function(\n-            tcx,\n-            instance,\n-            context,\n-            &cold_blocks,\n-            &mut clif_comments,\n-        );\n+        crate::optimize::optimize_function(tcx, instance, context, &mut clif_comments);\n     });\n \n     // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n     // instruction, which doesn't have an encoding.\n     context.compute_cfg();\n     context.compute_domtree();\n-    context.eliminate_unreachable_code(cx.module.isa()).unwrap();\n-    context.dce(cx.module.isa()).unwrap();\n+    context.eliminate_unreachable_code(module.isa()).unwrap();\n+    context.dce(module.isa()).unwrap();\n     // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n     // invalidate it when it would change.\n     context.domtree.clear();\n \n     context.want_disasm = crate::pretty_clif::should_write_ir(tcx);\n \n     // Define function\n-    let module = &mut cx.module;\n     tcx.sess.time(\"define function\", || {\n         module\n             .define_function(func_id, context, &mut NullTrapSink {}, &mut NullStackMapSink {})\n@@ -136,7 +138,7 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     crate::pretty_clif::write_clif_file(\n         tcx,\n         \"opt\",\n-        Some(cx.module.isa()),\n+        Some(module.isa()),\n         instance,\n         &context,\n         &clif_comments,\n@@ -145,21 +147,21 @@ pub(crate) fn codegen_fn<'tcx>(cx: &mut crate::CodegenCx<'_, 'tcx>, instance: In\n     if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n         crate::pretty_clif::write_ir_file(\n             tcx,\n-            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            || format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n             |file| file.write_all(disasm.as_bytes()),\n         )\n     }\n \n     // Define debuginfo for function\n-    let isa = cx.module.isa();\n+    let isa = module.isa();\n     let debug_context = &mut cx.debug_context;\n     let unwind_context = &mut cx.unwind_context;\n     tcx.sess.time(\"generate debug info\", || {\n         if let Some(debug_context) = debug_context {\n             debug_context.define_function(\n                 instance,\n                 func_id,\n-                &name,\n+                symbol_name.name,\n                 isa,\n                 context,\n                 &source_info_set,\n@@ -205,9 +207,8 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             // Unwinding after panicking is not supported\n             continue;\n \n-            // FIXME once unwinding is supported uncomment next lines\n-            // // Unwinding is unlikely to happen, so mark cleanup block's as cold.\n-            // fx.cold_blocks.insert(block);\n+            // FIXME Once unwinding is supported and Cranelift supports marking blocks as cold, do\n+            // so for cleanup blocks.\n         }\n \n         fx.bcx.ins().nop();\n@@ -262,7 +263,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n \n                 let target = fx.get_block(*target);\n                 let failure = fx.bcx.create_block();\n-                fx.cold_blocks.insert(failure);\n+                // FIXME Mark failure block as cold once Cranelift supports it\n \n                 if *expected {\n                     fx.bcx.ins().brz(cond, failure, &[]);\n@@ -355,14 +356,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                 from_hir_call: _,\n             } => {\n                 fx.tcx.sess.time(\"codegen call\", || {\n-                    crate::abi::codegen_terminator_call(\n-                        fx,\n-                        *fn_span,\n-                        block,\n-                        func,\n-                        args,\n-                        *destination,\n-                    )\n+                    crate::abi::codegen_terminator_call(fx, *fn_span, func, args, *destination)\n                 });\n             }\n             TerminatorKind::InlineAsm {\n@@ -664,7 +658,7 @@ fn codegen_stmt<'tcx>(\n                         // FIXME use emit_small_memset where possible\n                         let addr = lval.to_ptr().get_addr(fx);\n                         let val = operand.load_scalar(fx);\n-                        fx.bcx.call_memset(fx.cx.module.target_config(), addr, val, times);\n+                        fx.bcx.call_memset(fx.module.target_config(), addr, val, times);\n                     } else {\n                         let loop_block = fx.bcx.create_block();\n                         let loop_block2 = fx.bcx.create_block();\n@@ -750,85 +744,15 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::LlvmInlineAsm(asm) => {\n-            use rustc_span::symbol::Symbol;\n-            let LlvmInlineAsm { asm, outputs, inputs } = &**asm;\n-            let rustc_hir::LlvmInlineAsmInner {\n-                asm: asm_code,         // Name\n-                outputs: output_names, // Vec<LlvmInlineAsmOutput>\n-                inputs: input_names,   // Vec<Name>\n-                clobbers,              // Vec<Name>\n-                volatile,              // bool\n-                alignstack,            // bool\n-                dialect: _,\n-                asm_str_style: _,\n-            } = asm;\n-            match asm_code.as_str().trim() {\n+            match asm.asm.asm.as_str().trim() {\n                 \"\" => {\n                     // Black box\n                 }\n-                \"mov %rbx, %rsi\\n                  cpuid\\n                  xchg %rbx, %rsi\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{eax}\"), Symbol::intern(\"{ecx}\")]);\n-                    assert_eq!(output_names.len(), 4);\n-                    for (i, c) in (&[\"={eax}\", \"={esi}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    assert_eq!(inputs.len(), 2);\n-                    let leaf = codegen_operand(fx, &inputs[0].1).load_scalar(fx); // %eax\n-                    let subleaf = codegen_operand(fx, &inputs[1].1).load_scalar(fx); // %ecx\n-\n-                    let (eax, ebx, ecx, edx) =\n-                        crate::intrinsics::codegen_cpuid_call(fx, leaf, subleaf);\n-\n-                    assert_eq!(outputs.len(), 4);\n-                    codegen_place(fx, outputs[0])\n-                        .write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[1])\n-                        .write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[2])\n-                        .write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n-                    codegen_place(fx, outputs[3])\n-                        .write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n-                }\n-                \"xgetbv\" => {\n-                    assert_eq!(input_names, &[Symbol::intern(\"{ecx}\")]);\n-\n-                    assert_eq!(output_names.len(), 2);\n-                    for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n-                        assert_eq!(&output_names[i].constraint.as_str(), c);\n-                        assert!(!output_names[i].is_rw);\n-                        assert!(!output_names[i].is_indirect);\n-                    }\n-\n-                    assert_eq!(clobbers, &[]);\n-\n-                    assert!(!volatile);\n-                    assert!(!alignstack);\n-\n-                    crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n-                }\n-                // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n-                _ if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") => {\n-                    crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n-                }\n-                _ if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n-                }\n-                // Used in sys::windows::abort_internal\n-                \"int $$0x29\" => {\n-                    crate::trap::trap_unimplemented(fx, \"Windows abort\");\n-                }\n-                _ => fx\n-                    .tcx\n-                    .sess\n-                    .span_fatal(stmt.source_info.span, \"Inline assembly is not supported\"),\n+                _ => fx.tcx.sess.span_fatal(\n+                    stmt.source_info.span,\n+                    \"Legacy `llvm_asm!` inline assembly is not supported. \\\n+                    Try using the new `asm!` instead.\",\n+                ),\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n@@ -844,7 +768,7 @@ fn codegen_stmt<'tcx>(\n             let elem_size: u64 = pointee.size.bytes();\n             let bytes =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n-            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+            fx.bcx.call_memcpy(fx.module.target_config(), dst, src, bytes);\n         }\n     }\n }"}, {"sha": "92e4435565ee7575d0e77e8756f1f8040b7de0ce", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,8 +1,10 @@\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::SymbolName;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n+use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n pub(crate) fn pointer_ty(tcx: TyCtxt<'_>) -> types::Type {\n@@ -226,12 +228,16 @@ pub(crate) fn type_sign(ty: Ty<'_>) -> bool {\n     }\n }\n \n-pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n-    pub(crate) cx: &'clif mut crate::CodegenCx<'m, 'tcx>,\n+pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n+    pub(crate) cx: &'clif mut crate::CodegenCx<'tcx>,\n+    pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n+    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    pub(crate) constants_cx: ConstantCx,\n \n     pub(crate) instance: Instance<'tcx>,\n+    pub(crate) symbol_name: SymbolName<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n     pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n@@ -242,9 +248,6 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx> {\n     /// When `#[track_caller]` is used, the implicit caller location is stored in this variable.\n     pub(crate) caller_location: Option<CValue<'tcx>>,\n \n-    /// See [`crate::optimize::code_layout`] for more information.\n-    pub(crate) cold_blocks: EntitySet<Block>,\n-\n     pub(crate) clif_comments: crate::pretty_clif::CommentWriter,\n     pub(crate) source_info_set: indexmap::IndexSet<SourceInfo>,\n \n@@ -339,7 +342,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n     }\n \n     pub(crate) fn triple(&self) -> &target_lexicon::Triple {\n-        self.cx.module.isa().triple()\n+        self.module.isa().triple()\n     }\n \n     pub(crate) fn anonymous_str(&mut self, prefix: &str, msg: &str) -> Value {\n@@ -352,15 +355,14 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let mut data_ctx = DataContext::new();\n         data_ctx.define(msg.as_bytes().to_vec().into_boxed_slice());\n         let msg_id = self\n-            .cx\n             .module\n             .declare_data(&format!(\"__{}_{:08x}\", prefix, msg_hash), Linkage::Local, false, false)\n             .unwrap();\n \n         // Ignore DuplicateDefinition error, as the data will be the same\n-        let _ = self.cx.module.define_data(msg_id, &data_ctx);\n+        let _ = self.module.define_data(msg_id, &data_ctx);\n \n-        let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n+        let local_msg_id = self.module.declare_data_in_func(msg_id, self.bcx.func);\n         if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }"}, {"sha": "e59a0cb0a23237bfe0b4fd0164909db4d8a98e49", "filename": "compiler/rustc_codegen_cranelift/src/config.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconfig.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -0,0 +1,107 @@\n+use std::env;\n+use std::str::FromStr;\n+\n+fn bool_env_var(key: &str) -> bool {\n+    env::var(key).as_ref().map(|val| &**val) == Ok(\"1\")\n+}\n+\n+/// The mode to use for compilation.\n+#[derive(Copy, Clone, Debug)]\n+pub enum CodegenMode {\n+    /// AOT compile the crate. This is the default.\n+    Aot,\n+    /// JIT compile and execute the crate.\n+    Jit,\n+    /// JIT compile and execute the crate, but only compile functions the first time they are used.\n+    JitLazy,\n+}\n+\n+impl FromStr for CodegenMode {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"aot\" => Ok(CodegenMode::Aot),\n+            \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n+            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n+        }\n+    }\n+}\n+\n+/// Configuration of cg_clif as passed in through `-Cllvm-args` and various env vars.\n+#[derive(Clone, Debug)]\n+pub struct BackendConfig {\n+    /// Should the crate be AOT compiled or JIT executed.\n+    ///\n+    /// Defaults to AOT compilation. Can be set using `-Cllvm-args=mode=...`.\n+    pub codegen_mode: CodegenMode,\n+\n+    /// When JIT mode is enable pass these arguments to the program.\n+    ///\n+    /// Defaults to the value of `CG_CLIF_JIT_ARGS`.\n+    pub jit_args: Vec<String>,\n+\n+    /// Display the time it took to perform codegen for a crate.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_DISPLAY_CG_TIME` env var is set to 1 or false otherwise.\n+    /// Can be set using `-Cllvm-args=display_cg_time=...`.\n+    pub display_cg_time: bool,\n+\n+    /// Enable the Cranelift ir verifier for all compilation passes. If not set it will only run\n+    /// once before passing the clif ir to Cranelift for compilation.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_ENABLE_VERIFIER` env var is set to 1 or when cg_clif is\n+    /// compiled with debug assertions enabled or false otherwise. Can be set using\n+    /// `-Cllvm-args=enable_verifier=...`.\n+    pub enable_verifier: bool,\n+\n+    /// Don't cache object files in the incremental cache. Useful during development of cg_clif\n+    /// to make it possible to use incremental mode for all analyses performed by rustc without\n+    /// caching object files when their content should have been changed by a change to cg_clif.\n+    ///\n+    /// Defaults to true when the `CG_CLIF_DISABLE_INCR_CACHE` env var is set to 1 or false\n+    /// otherwise. Can be set using `-Cllvm-args=disable_incr_cache=...`.\n+    pub disable_incr_cache: bool,\n+}\n+\n+impl Default for BackendConfig {\n+    fn default() -> Self {\n+        BackendConfig {\n+            codegen_mode: CodegenMode::Aot,\n+            jit_args: {\n+                let args = std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n+                args.split(' ').map(|arg| arg.to_string()).collect()\n+            },\n+            display_cg_time: bool_env_var(\"CG_CLIF_DISPLAY_CG_TIME\"),\n+            enable_verifier: cfg!(debug_assertions) || bool_env_var(\"CG_CLIF_ENABLE_VERIFIER\"),\n+            disable_incr_cache: bool_env_var(\"CG_CLIF_DISABLE_INCR_CACHE\"),\n+        }\n+    }\n+}\n+\n+impl BackendConfig {\n+    /// Parse the configuration passed in using `-Cllvm-args`.\n+    pub fn from_opts(opts: &[String]) -> Result<Self, String> {\n+        fn parse_bool(name: &str, value: &str) -> Result<bool, String> {\n+            value.parse().map_err(|_| format!(\"failed to parse value `{}` for {}\", value, name))\n+        }\n+\n+        let mut config = BackendConfig::default();\n+        for opt in opts {\n+            if let Some((name, value)) = opt.split_once('=') {\n+                match name {\n+                    \"mode\" => config.codegen_mode = value.parse()?,\n+                    \"display_cg_time\" => config.display_cg_time = parse_bool(name, value)?,\n+                    \"enable_verifier\" => config.enable_verifier = parse_bool(name, value)?,\n+                    \"disable_incr_cache\" => config.disable_incr_cache = parse_bool(name, value)?,\n+                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n+                }\n+            } else {\n+                return Err(format!(\"Invalid option `{}`\", opt));\n+            }\n+        }\n+\n+        Ok(config)\n+    }\n+}"}, {"sha": "0a0e02d26394e7fee322ae991fe41e915a9e34b9", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_span::DUMMY_SP;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::ErrorReported;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n@@ -15,10 +15,10 @@ use cranelift_module::*;\n \n use crate::prelude::*;\n \n-#[derive(Default)]\n pub(crate) struct ConstantCx {\n     todo: Vec<TodoItem>,\n     done: FxHashSet<DataId>,\n+    anon_allocs: FxHashMap<AllocId, DataId>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -28,6 +28,10 @@ enum TodoItem {\n }\n \n impl ConstantCx {\n+    pub(crate) fn new() -> Self {\n+        ConstantCx { todo: vec![], done: FxHashSet::default(), anon_allocs: FxHashMap::default() }\n+    }\n+\n     pub(crate) fn finalize(mut self, tcx: TyCtxt<'_>, module: &mut dyn Module) {\n         //println!(\"todo {:?}\", self.todo);\n         define_all_allocs(tcx, module, &mut self);\n@@ -74,17 +78,19 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     all_constants_ok\n }\n \n-pub(crate) fn codegen_static(constants_cx: &mut ConstantCx, def_id: DefId) {\n+pub(crate) fn codegen_static(tcx: TyCtxt<'_>, module: &mut dyn Module, def_id: DefId) {\n+    let mut constants_cx = ConstantCx::new();\n     constants_cx.todo.push(TodoItem::Static(def_id));\n+    constants_cx.finalize(tcx, module);\n }\n \n pub(crate) fn codegen_tls_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n     }\n@@ -97,8 +103,8 @@ fn codegen_static_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n     }\n@@ -182,28 +188,31 @@ pub(crate) fn codegen_const_value<'tcx>(\n                     let alloc_kind = fx.tcx.get_global_alloc(ptr.alloc_id);\n                     let base_addr = match alloc_kind {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n-                            fx.cx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n-                            let data_id =\n-                                data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n+                            fx.constants_cx.todo.push(TodoItem::Alloc(ptr.alloc_id));\n+                            let data_id = data_id_for_alloc_id(\n+                                &mut fx.constants_cx,\n+                                fx.module,\n+                                ptr.alloc_id,\n+                                alloc.mutability,\n+                            );\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n                             }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n-                            let func_id =\n-                                crate::abi::import_function(fx.tcx, fx.cx.module, instance);\n+                            let func_id = crate::abi::import_function(fx.tcx, fx.module, instance);\n                             let local_func_id =\n-                                fx.cx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n+                                fx.module.declare_func_in_func(func_id, &mut fx.bcx.func);\n                             fx.bcx.ins().func_addr(fx.pointer_type, local_func_id)\n                         }\n                         Some(GlobalAlloc::Static(def_id)) => {\n                             assert!(fx.tcx.is_static(def_id));\n-                            let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n+                            let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n                             let local_data_id =\n-                                fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+                                fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n                             if fx.clif_comments.enabled() {\n                                 fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n                             }\n@@ -243,10 +252,11 @@ fn pointer_for_allocation<'tcx>(\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.create_memory_alloc(alloc);\n-    fx.cx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-    let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n+    fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n+    let data_id =\n+        data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, alloc.mutability);\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n     }\n@@ -255,18 +265,14 @@ fn pointer_for_allocation<'tcx>(\n }\n \n fn data_id_for_alloc_id(\n+    cx: &mut ConstantCx,\n     module: &mut dyn Module,\n     alloc_id: AllocId,\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n-    module\n-        .declare_data(\n-            &format!(\".L__alloc_{:x}\", alloc_id.0),\n-            Linkage::Local,\n-            mutability == rustc_hir::Mutability::Mut,\n-            false,\n-        )\n-        .unwrap()\n+    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n+        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n+    })\n }\n \n fn data_id_for_static(\n@@ -344,7 +350,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     GlobalAlloc::Memory(alloc) => alloc,\n                     GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n                 };\n-                let data_id = data_id_for_alloc_id(module, alloc_id, alloc.mutability);\n+                let data_id = data_id_for_alloc_id(cx, module, alloc_id, alloc.mutability);\n                 (data_id, alloc, None)\n             }\n             TodoItem::Static(def_id) => {\n@@ -397,7 +403,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                 }\n                 GlobalAlloc::Memory(target_alloc) => {\n                     cx.todo.push(TodoItem::Alloc(reloc));\n-                    data_id_for_alloc_id(module, reloc, target_alloc.mutability)\n+                    data_id_for_alloc_id(cx, module, reloc, target_alloc.mutability)\n                 }\n                 GlobalAlloc::Static(def_id) => {\n                     if tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n@@ -419,8 +425,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        // FIXME don't duplicate definitions in lazy jit mode\n-        let _ = module.define_data(data_id, &data_ctx);\n+        module.define_data(data_id, &data_ctx).unwrap();\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "d1251e749f31fe90687312a9ff7837d7a0149d9b", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/unwind.rs", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Funwind.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -5,17 +5,19 @@ use crate::prelude::*;\n use cranelift_codegen::isa::{unwind::UnwindInfo, TargetIsa};\n \n use gimli::write::{Address, CieId, EhFrame, FrameTable, Section};\n+use gimli::RunTimeEndian;\n \n use crate::backend::WriteDebugInfo;\n \n-pub(crate) struct UnwindContext<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n+pub(crate) struct UnwindContext {\n+    endian: RunTimeEndian,\n     frame_table: FrameTable,\n     cie_id: Option<CieId>,\n }\n \n-impl<'tcx> UnwindContext<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+impl UnwindContext {\n+    pub(crate) fn new(tcx: TyCtxt<'_>, isa: &dyn TargetIsa, pic_eh_frame: bool) -> Self {\n+        let endian = super::target_endian(tcx);\n         let mut frame_table = FrameTable::default();\n \n         let cie_id = if let Some(mut cie) = isa.create_systemv_cie() {\n@@ -28,7 +30,7 @@ impl<'tcx> UnwindContext<'tcx> {\n             None\n         };\n \n-        UnwindContext { tcx, frame_table, cie_id }\n+        UnwindContext { endian, frame_table, cie_id }\n     }\n \n     pub(crate) fn add_function(&mut self, func_id: FuncId, context: &Context, isa: &dyn TargetIsa) {\n@@ -54,8 +56,7 @@ impl<'tcx> UnwindContext<'tcx> {\n     }\n \n     pub(crate) fn emit<P: WriteDebugInfo>(self, product: &mut P) {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if !eh_frame.0.writer.slice().is_empty() {\n@@ -70,34 +71,36 @@ impl<'tcx> UnwindContext<'tcx> {\n         }\n     }\n \n-    #[cfg(feature = \"jit\")]\n-    pub(crate) unsafe fn register_jit(\n-        self,\n-        jit_module: &cranelift_jit::JITModule,\n-    ) -> Option<UnwindRegistry> {\n-        let mut eh_frame =\n-            EhFrame::from(super::emit::WriterRelocate::new(super::target_endian(self.tcx)));\n+    #[cfg(all(feature = \"jit\", windows))]\n+    pub(crate) unsafe fn register_jit(self, _jit_module: &cranelift_jit::JITModule) {}\n+\n+    #[cfg(all(feature = \"jit\", not(windows)))]\n+    pub(crate) unsafe fn register_jit(self, jit_module: &cranelift_jit::JITModule) {\n+        let mut eh_frame = EhFrame::from(super::emit::WriterRelocate::new(self.endian));\n         self.frame_table.write_eh_frame(&mut eh_frame).unwrap();\n \n         if eh_frame.0.writer.slice().is_empty() {\n-            return None;\n+            return;\n         }\n \n         let mut eh_frame = eh_frame.0.relocate_for_jit(jit_module);\n \n         // GCC expects a terminating \"empty\" length, so write a 0 length at the end of the table.\n         eh_frame.extend(&[0, 0, 0, 0]);\n \n-        let mut registrations = Vec::new();\n+        // FIXME support unregistering unwind tables once cranelift-jit supports deallocating\n+        // individual functions\n+        #[allow(unused_variables)]\n+        let (eh_frame, eh_frame_len, _) = Vec::into_raw_parts(eh_frame);\n \n         // =======================================================================\n         // Everything after this line up to the end of the file is loosly based on\n         // https://github.com/bytecodealliance/wasmtime/blob/4471a82b0c540ff48960eca6757ccce5b1b5c3e4/crates/jit/src/unwind/systemv.rs\n         #[cfg(target_os = \"macos\")]\n         {\n             // On macOS, `__register_frame` takes a pointer to a single FDE\n-            let start = eh_frame.as_ptr();\n-            let end = start.add(eh_frame.len());\n+            let start = eh_frame;\n+            let end = start.add(eh_frame_len);\n             let mut current = start;\n \n             // Walk all of the entries in the frame table and register them\n@@ -107,7 +110,6 @@ impl<'tcx> UnwindContext<'tcx> {\n                 // Skip over the CIE\n                 if current != start {\n                     __register_frame(current);\n-                    registrations.push(current as usize);\n                 }\n \n                 // Move to the next table entry (+4 because the length itself is not inclusive)\n@@ -117,41 +119,12 @@ impl<'tcx> UnwindContext<'tcx> {\n         #[cfg(not(target_os = \"macos\"))]\n         {\n             // On other platforms, `__register_frame` will walk the FDEs until an entry of length 0\n-            let ptr = eh_frame.as_ptr();\n-            __register_frame(ptr);\n-            registrations.push(ptr as usize);\n+            __register_frame(eh_frame);\n         }\n-\n-        Some(UnwindRegistry { _frame_table: eh_frame, registrations })\n     }\n }\n \n-/// Represents a registry of function unwind information for System V ABI.\n-pub(crate) struct UnwindRegistry {\n-    _frame_table: Vec<u8>,\n-    registrations: Vec<usize>,\n-}\n-\n extern \"C\" {\n     // libunwind import\n     fn __register_frame(fde: *const u8);\n-    fn __deregister_frame(fde: *const u8);\n-}\n-\n-impl Drop for UnwindRegistry {\n-    fn drop(&mut self) {\n-        unsafe {\n-            // libgcc stores the frame entries as a linked list in decreasing sort order\n-            // based on the PC value of the registered entry.\n-            //\n-            // As we store the registrations in increasing order, it would be O(N^2) to\n-            // deregister in that order.\n-            //\n-            // To ensure that we just pop off the first element in the list upon every\n-            // deregistration, walk our list of registrations backwards.\n-            for fde in self.registrations.iter().rev() {\n-                __deregister_frame(*fde as *const _);\n-            }\n-        }\n-    }\n }"}, {"sha": "9c5cd53d8669d3a2c48457de36422c3ecd2d1625", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -16,12 +16,6 @@ use cranelift_object::ObjectModule;\n \n use crate::{prelude::*, BackendConfig};\n \n-fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n-    let module = crate::backend::make_module(tcx.sess, name);\n-    assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n-    module\n-}\n-\n struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n \n impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n@@ -32,11 +26,12 @@ impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n \n fn emit_module(\n     tcx: TyCtxt<'_>,\n+    backend_config: &BackendConfig,\n     name: String,\n     kind: ModuleKind,\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n-    unwind_context: UnwindContext<'_>,\n+    unwind_context: UnwindContext,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -52,7 +47,7 @@ fn emit_module(\n         tcx.sess.fatal(&format!(\"error writing object file: {}\", err));\n     }\n \n-    let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() {\n+    let work_product = if backend_config.disable_incr_cache {\n         None\n     } else {\n         rustc_incremental::copy_cgu_workproduct_to_incr_comp_cache_dir(\n@@ -110,23 +105,24 @@ fn module_codegen(\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+    let isa = crate::build_isa(tcx.sess, &backend_config);\n+    let mut module = crate::backend::make_module(tcx.sess, isa, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n-        backend_config,\n-        &mut module,\n+        backend_config.clone(),\n+        module.isa(),\n         tcx.sess.opts.debuginfo != DebugInfo::None,\n     );\n-    super::predefine_mono_items(&mut cx, &mono_items);\n+    super::predefine_mono_items(tcx, &mut module, &mono_items);\n     for (mono_item, _) in mono_items {\n         match mono_item {\n             MonoItem::Fn(inst) => {\n-                cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n-            }\n-            MonoItem::Static(def_id) => {\n-                crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+                cx.tcx\n+                    .sess\n+                    .time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, &mut module, inst));\n             }\n+            MonoItem::Static(def_id) => crate::constant::codegen_static(tcx, &mut module, def_id),\n             MonoItem::GlobalAsm(item_id) => {\n                 let item = cx.tcx.hir().item(item_id);\n                 if let rustc_hir::ItemKind::GlobalAsm(rustc_hir::GlobalAsm { asm }) = item.kind {\n@@ -138,25 +134,28 @@ fn module_codegen(\n             }\n         }\n     }\n-    let (global_asm, debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut cx.unwind_context, false);\n \n-    let codegen_result = emit_module(\n-        tcx,\n-        cgu.name().as_str().to_string(),\n-        ModuleKind::Regular,\n-        module,\n-        debug,\n-        unwind_context,\n-    );\n+    let debug_context = cx.debug_context;\n+    let unwind_context = cx.unwind_context;\n+    let codegen_result = tcx.sess.time(\"write object file\", || {\n+        emit_module(\n+            tcx,\n+            &backend_config,\n+            cgu.name().as_str().to_string(),\n+            ModuleKind::Regular,\n+            module,\n+            debug_context,\n+            unwind_context,\n+        )\n+    });\n \n-    codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n+    codegen_global_asm(tcx, &cgu.name().as_str(), &cx.global_asm);\n \n     codegen_result\n }\n \n-pub(super) fn run_aot(\n+pub(crate) fn run_aot(\n     tcx: TyCtxt<'_>,\n     backend_config: BackendConfig,\n     metadata: EncodedMetadata,\n@@ -193,14 +192,14 @@ pub(super) fn run_aot(\n         }\n     }\n \n-    let modules = super::time(tcx, \"codegen mono items\", || {\n+    let modules = super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n         cgus.iter()\n             .map(|cgu| {\n                 let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n                 tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n                 match cgu_reuse {\n-                    _ if std::env::var(\"CG_CLIF_INCR_CACHE_DISABLED\").is_ok() => {}\n+                    _ if backend_config.disable_incr_cache => {}\n                     CguReuse::No => {}\n                     CguReuse::PreLto => {\n                         return reuse_workproduct_for_cgu(tcx, &*cgu, &mut work_products);\n@@ -212,7 +211,7 @@ pub(super) fn run_aot(\n                 let (ModuleCodegenResult(module, work_product), _) = tcx.dep_graph.with_task(\n                     dep_node,\n                     tcx,\n-                    (backend_config, cgu.name()),\n+                    (backend_config.clone(), cgu.name()),\n                     module_codegen,\n                     rustc_middle::dep_graph::hash_result,\n                 );\n@@ -228,14 +227,18 @@ pub(super) fn run_aot(\n \n     tcx.sess.abort_if_errors();\n \n-    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n+    let isa = crate::build_isa(tcx.sess, &backend_config);\n+    let mut allocator_module =\n+        crate::backend::make_module(tcx.sess, isa, \"allocator_shim\".to_string());\n+    assert_eq!(pointer_ty(tcx), allocator_module.target_config().pointer_type());\n     let mut allocator_unwind_context = UnwindContext::new(tcx, allocator_module.isa(), true);\n     let created_alloc_shim =\n         crate::allocator::codegen(tcx, &mut allocator_module, &mut allocator_unwind_context);\n \n     let allocator_module = if created_alloc_shim {\n         let ModuleCodegenResult(module, work_product) = emit_module(\n             tcx,\n+            &backend_config,\n             \"allocator_shim\".to_string(),\n             ModuleKind::Allocator,\n             allocator_module,"}, {"sha": "53c93f6a9ddca82bbc39e246f253759ca373539a", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 99, "deletions": 108, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,4 +1,4 @@\n-//! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n+//! The JIT driver uses [`cranelift_jit`] to JIT execute programs without writing any object\n //! files.\n \n use std::cell::RefCell;\n@@ -15,25 +15,56 @@ use cranelift_jit::{JITBuilder, JITModule};\n use crate::{prelude::*, BackendConfig};\n use crate::{CodegenCx, CodegenMode};\n \n-thread_local! {\n-    pub static BACKEND_CONFIG: RefCell<Option<BackendConfig>> = RefCell::new(None);\n-    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+struct JitState {\n+    backend_config: BackendConfig,\n+    jit_module: JITModule,\n }\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n-    if !tcx.sess.opts.output_types.should_codegen() {\n-        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n-    }\n+thread_local! {\n+    static LAZY_JIT_STATE: RefCell<Option<JitState>> = RefCell::new(None);\n+}\n \n+fn create_jit_module<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    backend_config: &BackendConfig,\n+    hotswap: bool,\n+) -> (JITModule, CodegenCx<'tcx>) {\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n-    let mut jit_builder =\n-        JITBuilder::with_isa(crate::build_isa(tcx.sess), cranelift_module::default_libcall_names());\n-    jit_builder.hotswap(matches!(backend_config.codegen_mode, CodegenMode::JitLazy));\n+    let isa = crate::build_isa(tcx.sess, backend_config);\n+    let mut jit_builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());\n+    jit_builder.hotswap(hotswap);\n     crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n-    assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n+\n+    let mut cx = crate::CodegenCx::new(tcx, backend_config.clone(), jit_module.isa(), false);\n+\n+    crate::allocator::codegen(tcx, &mut jit_module, &mut cx.unwind_context);\n+    crate::main_shim::maybe_create_entry_wrapper(\n+        tcx,\n+        &mut jit_module,\n+        &mut cx.unwind_context,\n+        true,\n+    );\n+\n+    (jit_module, cx)\n+}\n+\n+pub(crate) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n+    if !tcx.sess.opts.output_types.should_codegen() {\n+        tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`\");\n+    }\n+\n+    if !tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable) {\n+        tcx.sess.fatal(\"can't jit non-executable crate\");\n+    }\n+\n+    let (mut jit_module, mut cx) = create_jit_module(\n+        tcx,\n+        &backend_config,\n+        matches!(backend_config.codegen_mode, CodegenMode::JitLazy),\n+    );\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     let mono_items = cgus\n@@ -44,52 +75,45 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         .into_iter()\n         .collect::<Vec<(_, (_, _))>>();\n \n-    let mut cx = crate::CodegenCx::new(tcx, backend_config, &mut jit_module, false);\n-\n-    super::time(tcx, \"codegen mono items\", || {\n-        super::predefine_mono_items(&mut cx, &mono_items);\n+    super::time(tcx, backend_config.display_cg_time, \"codegen mono items\", || {\n+        super::predefine_mono_items(tcx, &mut jit_module, &mono_items);\n         for (mono_item, _) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(inst) => match backend_config.codegen_mode {\n                     CodegenMode::Aot => unreachable!(),\n                     CodegenMode::Jit => {\n-                        cx.tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, inst));\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, &mut jit_module, inst)\n+                        });\n                     }\n-                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, &mut jit_module, inst),\n                 },\n                 MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n+                    crate::constant::codegen_static(tcx, &mut jit_module, def_id);\n                 }\n                 MonoItem::GlobalAsm(item_id) => {\n-                    let item = cx.tcx.hir().item(item_id);\n+                    let item = tcx.hir().item(item_id);\n                     tcx.sess.span_fatal(item.span, \"Global asm is not supported in JIT mode\");\n                 }\n             }\n         }\n     });\n \n-    let (global_asm, _debug, mut unwind_context) =\n-        tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    jit_module.finalize_definitions();\n-\n-    if !global_asm.is_empty() {\n+    if !cx.global_asm.is_empty() {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n-\n     tcx.sess.abort_if_errors();\n \n     jit_module.finalize_definitions();\n-    let _unwind_register_guard = unsafe { unwind_context.register_jit(&jit_module) };\n+    unsafe { cx.unwind_context.register_jit(&jit_module) };\n \n     println!(\n         \"Rustc codegen cranelift will JIT run the executable, because -Cllvm-args=mode=jit was passed\"\n     );\n \n-    let args = ::std::env::var(\"CG_CLIF_JIT_ARGS\").unwrap_or_else(|_| String::new());\n     let args = std::iter::once(&*tcx.crate_name(LOCAL_CRATE).as_str().to_string())\n-        .chain(args.split(' '))\n+        .chain(backend_config.jit_args.iter().map(|arg| &**arg))\n         .map(|arg| CString::new(arg).unwrap())\n         .collect::<Vec<_>>();\n     let mut argv = args.iter().map(|arg| arg.as_ptr()).collect::<Vec<_>>();\n@@ -98,61 +122,27 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n-    BACKEND_CONFIG.with(|tls_backend_config| {\n-        assert!(tls_backend_config.borrow_mut().replace(backend_config).is_none())\n+    let start_sig = Signature {\n+        params: vec![\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+            AbiParam::new(jit_module.target_config().pointer_type()),\n+        ],\n+        returns: vec![AbiParam::new(jit_module.target_config().pointer_type() /*isize*/)],\n+        call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n+    };\n+    let start_func_id = jit_module.declare_function(\"main\", Linkage::Import, &start_sig).unwrap();\n+    let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n+\n+    LAZY_JIT_STATE.with(|lazy_jit_state| {\n+        let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+        assert!(lazy_jit_state.is_none());\n+        *lazy_jit_state = Some(JitState { backend_config, jit_module });\n     });\n \n-    let (main_def_id, entry_ty) = tcx.entry_fn(LOCAL_CRATE).unwrap();\n-    let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-\n-    match entry_ty {\n-        EntryFnType::Main => {\n-            // FIXME set program arguments somehow\n-\n-            let main_sig = Signature {\n-                params: vec![],\n-                returns: vec![],\n-                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-            };\n-            let main_func_id = jit_module\n-                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &main_sig)\n-                .unwrap();\n-            let finalized_main: *const u8 = jit_module.get_finalized_function(main_func_id);\n-\n-            CURRENT_MODULE.with(|current_module| {\n-                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n-            });\n-\n-            let f: extern \"C\" fn() = unsafe { ::std::mem::transmute(finalized_main) };\n-            f();\n-            std::process::exit(0);\n-        }\n-        EntryFnType::Start => {\n-            let start_sig = Signature {\n-                params: vec![\n-                    AbiParam::new(jit_module.target_config().pointer_type()),\n-                    AbiParam::new(jit_module.target_config().pointer_type()),\n-                ],\n-                returns: vec![AbiParam::new(\n-                    jit_module.target_config().pointer_type(), /*isize*/\n-                )],\n-                call_conv: CallConv::triple_default(&crate::target_triple(tcx.sess)),\n-            };\n-            let start_func_id = jit_module\n-                .declare_function(tcx.symbol_name(instance).name, Linkage::Import, &start_sig)\n-                .unwrap();\n-            let finalized_start: *const u8 = jit_module.get_finalized_function(start_func_id);\n-\n-            CURRENT_MODULE.with(|current_module| {\n-                assert!(current_module.borrow_mut().replace(jit_module).is_none())\n-            });\n-\n-            let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n-                unsafe { ::std::mem::transmute(finalized_start) };\n-            let ret = f(args.len() as c_int, argv.as_ptr());\n-            std::process::exit(ret);\n-        }\n-    }\n+    let f: extern \"C\" fn(c_int, *const *const c_char) -> c_int =\n+        unsafe { ::std::mem::transmute(finalized_start) };\n+    let ret = f(args.len() as c_int, argv.as_ptr());\n+    std::process::exit(ret);\n }\n \n #[no_mangle]\n@@ -161,24 +151,23 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n         // lift is used to ensure the correct lifetime for instance.\n         let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n \n-        CURRENT_MODULE.with(|jit_module| {\n-            let mut jit_module = jit_module.borrow_mut();\n-            let jit_module = jit_module.as_mut().unwrap();\n-            let backend_config =\n-                BACKEND_CONFIG.with(|backend_config| backend_config.borrow().clone().unwrap());\n+        LAZY_JIT_STATE.with(|lazy_jit_state| {\n+            let mut lazy_jit_state = lazy_jit_state.borrow_mut();\n+            let lazy_jit_state = lazy_jit_state.as_mut().unwrap();\n+            let jit_module = &mut lazy_jit_state.jit_module;\n+            let backend_config = lazy_jit_state.backend_config.clone();\n \n-            let name = tcx.symbol_name(instance).name.to_string();\n+            let name = tcx.symbol_name(instance).name;\n             let sig = crate::abi::get_function_sig(tcx, jit_module.isa().triple(), instance);\n-            let func_id = jit_module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+            let func_id = jit_module.declare_function(name, Linkage::Export, &sig).unwrap();\n             jit_module.prepare_for_function_redefine(func_id).unwrap();\n \n-            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module, false);\n-            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, instance));\n+            let mut cx = crate::CodegenCx::new(tcx, backend_config, jit_module.isa(), false);\n+            tcx.sess.time(\"codegen fn\", || crate::base::codegen_fn(&mut cx, jit_module, instance));\n \n-            let (global_asm, _debug_context, unwind_context) = cx.finalize();\n-            assert!(global_asm.is_empty());\n+            assert!(cx.global_asm.is_empty());\n             jit_module.finalize_definitions();\n-            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            unsafe { cx.unwind_context.register_jit(&jit_module) };\n             jit_module.get_finalized_function(func_id)\n         })\n     })\n@@ -248,35 +237,37 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     imported_symbols\n }\n \n-fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n+fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx>, module: &mut JITModule, inst: Instance<'tcx>) {\n     let tcx = cx.tcx;\n \n-    let pointer_type = cx.module.target_config().pointer_type();\n+    let pointer_type = module.target_config().pointer_type();\n \n-    let name = tcx.symbol_name(inst).name.to_string();\n-    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n-    let func_id = cx.module.declare_function(&name, Linkage::Export, &sig).unwrap();\n+    let name = tcx.symbol_name(inst).name;\n+    let sig = crate::abi::get_function_sig(tcx, module.isa().triple(), inst);\n+    let func_id = module.declare_function(name, Linkage::Export, &sig).unwrap();\n \n     let instance_ptr = Box::into_raw(Box::new(inst));\n \n-    let jit_fn = cx\n-        .module\n+    let jit_fn = module\n         .declare_function(\n             \"__clif_jit_fn\",\n             Linkage::Import,\n             &Signature {\n-                call_conv: cx.module.target_config().default_call_conv,\n+                call_conv: module.target_config().default_call_conv,\n                 params: vec![AbiParam::new(pointer_type)],\n                 returns: vec![AbiParam::new(pointer_type)],\n             },\n         )\n         .unwrap();\n \n-    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    cx.cached_context.clear();\n+    let trampoline = &mut cx.cached_context.func;\n+    trampoline.signature = sig.clone();\n+\n     let mut builder_ctx = FunctionBuilderContext::new();\n-    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+    let mut trampoline_builder = FunctionBuilder::new(trampoline, &mut builder_ctx);\n \n-    let jit_fn = cx.module.declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let jit_fn = module.declare_func_in_func(jit_fn, trampoline_builder.func);\n     let sig_ref = trampoline_builder.func.import_signature(sig);\n \n     let entry_block = trampoline_builder.create_block();\n@@ -291,10 +282,10 @@ fn codegen_shim<'tcx>(cx: &mut CodegenCx<'_, 'tcx>, inst: Instance<'tcx>) {\n     let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n     trampoline_builder.ins().return_(&ret_vals);\n \n-    cx.module\n+    module\n         .define_function(\n             func_id,\n-            &mut Context::for_function(trampoline),\n+            &mut cx.cached_context,\n             &mut NullTrapSink {},\n             &mut NullStackMapSink {},\n         )"}, {"sha": "8f5714ecb417704e446edda114f65b4966facb66", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,72 +1,46 @@\n-//! Drivers are responsible for calling [`codegen_mono_item`] and performing any further actions\n-//! like JIT executing or writing object files.\n+//! Drivers are responsible for calling [`codegen_fn`] or [`codegen_static`] for each mono item and\n+//! performing any further actions like JIT executing or writing object files.\n+//!\n+//! [`codegen_fn`]: crate::base::codegen_fn\n+//! [`codegen_static`]: crate::constant::codegen_static\n \n-use std::any::Any;\n-\n-use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n-use crate::CodegenMode;\n \n-mod aot;\n+pub(crate) mod aot;\n #[cfg(feature = \"jit\")]\n-mod jit;\n-\n-pub(crate) fn codegen_crate(\n-    tcx: TyCtxt<'_>,\n-    metadata: EncodedMetadata,\n-    need_metadata_module: bool,\n-    backend_config: crate::BackendConfig,\n-) -> Box<dyn Any> {\n-    tcx.sess.abort_if_errors();\n-\n-    match backend_config.codegen_mode {\n-        CodegenMode::Aot => aot::run_aot(tcx, backend_config, metadata, need_metadata_module),\n-        CodegenMode::Jit | CodegenMode::JitLazy => {\n-            let is_executable =\n-                tcx.sess.crate_types().contains(&rustc_session::config::CrateType::Executable);\n-            if !is_executable {\n-                tcx.sess.fatal(\"can't jit non-executable crate\");\n-            }\n-\n-            #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx, backend_config);\n-\n-            #[cfg(not(feature = \"jit\"))]\n-            tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n-        }\n-    }\n-}\n+pub(crate) mod jit;\n \n fn predefine_mono_items<'tcx>(\n-    cx: &mut crate::CodegenCx<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    module: &mut dyn Module,\n     mono_items: &[(MonoItem<'tcx>, (RLinkage, Visibility))],\n ) {\n-    cx.tcx.sess.time(\"predefine functions\", || {\n-        let is_compiler_builtins = cx.tcx.is_compiler_builtins(LOCAL_CRATE);\n+    tcx.sess.time(\"predefine functions\", || {\n+        let is_compiler_builtins = tcx.is_compiler_builtins(LOCAL_CRATE);\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let name = tcx.symbol_name(instance).name;\n                     let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n-                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n+                    let sig = get_function_sig(tcx, module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(\n                         mono_item,\n                         linkage,\n                         visibility,\n                         is_compiler_builtins,\n                     );\n-                    cx.module.declare_function(&name, linkage, &sig).unwrap();\n+                    module.declare_function(name, linkage, &sig).unwrap();\n                 }\n                 MonoItem::Static(_) | MonoItem::GlobalAsm(_) => {}\n             }\n         }\n     });\n }\n \n-fn time<R>(tcx: TyCtxt<'_>, name: &'static str, f: impl FnOnce() -> R) -> R {\n-    if std::env::var(\"CG_CLIF_DISPLAY_CG_TIME\").as_ref().map(|val| &**val) == Ok(\"1\") {\n+fn time<R>(tcx: TyCtxt<'_>, display: bool, name: &'static str, f: impl FnOnce() -> R) -> R {\n+    if display {\n         println!(\"[{:<30}: {}] start\", tcx.crate_name(LOCAL_CRATE), name);\n         let before = std::time::Instant::now();\n         let res = tcx.sess.time(name, f);"}, {"sha": "4ab4c2957ca4e3f29fa06902f9332d26712e9b86", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -24,6 +24,64 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         let true_ = fx.bcx.ins().iconst(types::I32, 1);\n         fx.bcx.ins().trapnz(true_, TrapCode::User(1));\n         return;\n+    } else if template[0] == InlineAsmTemplatePiece::String(\"mov rsi, rbx\".to_string())\n+        && template[1] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[2] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+        && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+        && template[4] == InlineAsmTemplatePiece::String(\"xchg rsi, rbx\".to_string())\n+    {\n+        assert_eq!(operands.len(), 4);\n+        let (leaf, eax_place) = match operands[0] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::ax));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let ebx_place = match operands[1] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::si));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+        let (sub_leaf, ecx_place) = match operands[2] {\n+            InlineAsmOperand::InOut { reg, late: true, ref in_value, out_place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::cx));\n+                (\n+                    crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n+                    crate::base::codegen_place(fx, out_place.unwrap()),\n+                )\n+            }\n+            _ => unreachable!(),\n+        };\n+        let edx_place = match operands[3] {\n+            InlineAsmOperand::Out { reg, late: true, place } => {\n+                let reg = expect_reg(reg);\n+                assert_eq!(reg, InlineAsmReg::X86(X86InlineAsmReg::dx));\n+                crate::base::codegen_place(fx, place.unwrap())\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let (eax, ebx, ecx, edx) = crate::intrinsics::codegen_cpuid_call(fx, leaf, sub_leaf);\n+\n+        eax_place.write_cvalue(fx, CValue::by_val(eax, fx.layout_of(fx.tcx.types.u32)));\n+        ebx_place.write_cvalue(fx, CValue::by_val(ebx, fx.layout_of(fx.tcx.types.u32)));\n+        ecx_place.write_cvalue(fx, CValue::by_val(ecx, fx.layout_of(fx.tcx.types.u32)));\n+        edx_place.write_cvalue(fx, CValue::by_val(edx, fx.layout_of(fx.tcx.types.u32)));\n+        return;\n+    } else if fx.tcx.symbol_name(fx.instance).name.starts_with(\"___chkstk\") {\n+        // ___chkstk, ___chkstk_ms and __alloca are only used on Windows\n+        crate::trap::trap_unimplemented(fx, \"Stack probes are not supported\");\n+    } else if fx.tcx.symbol_name(fx.instance).name == \"__alloca\" {\n+        crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n     let mut slot_size = Size::from_bytes(0);\n@@ -92,8 +150,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n \n     let inline_asm_index = fx.inline_asm_index;\n     fx.inline_asm_index += 1;\n-    let asm_name =\n-        format!(\"{}__inline_asm_{}\", fx.tcx.symbol_name(fx.instance).name, inline_asm_index);\n+    let asm_name = format!(\"{}__inline_asm_{}\", fx.symbol_name, inline_asm_index);\n \n     let generated_asm = generate_asm_wrapper(\n         &asm_name,\n@@ -202,7 +259,6 @@ fn call_inline_asm<'tcx>(\n     }\n \n     let inline_asm_func = fx\n-        .cx\n         .module\n         .declare_function(\n             asm_name,\n@@ -214,7 +270,7 @@ fn call_inline_asm<'tcx>(\n             },\n         )\n         .unwrap();\n-    let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n+    let inline_asm_func = fx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(inline_asm_func, asm_name);\n     }"}, {"sha": "9de12e759bcc8826d8dca15c789cccc5c37f80e7", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/cpuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fcpuid.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -8,7 +8,7 @@ use crate::prelude::*;\n pub(crate) fn codegen_cpuid_call<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     leaf: Value,\n-    _subleaf: Value,\n+    _sub_leaf: Value,\n ) -> (Value, Value, Value, Value) {\n     let leaf_0 = fx.bcx.create_block();\n     let leaf_1 = fx.bcx.create_block();"}, {"sha": "ba4ed2162cd5d1397c38fa210e1c36445a0226a3", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n \n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n-        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+        \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\", (c a) {\n             let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n             let lane_ty = fx.clif_type(lane_ty).unwrap();\n             assert!(lane_count <= 32);\n@@ -51,7 +51,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n             ret.write_cvalue(fx, res);\n         };\n-        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+        \"llvm.x86.sse2.cmp.ps\" | \"llvm.x86.sse2.cmp.pd\", (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n             let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n@@ -81,7 +81,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n             });\n         };\n-        llvm.x86.sse2.psrli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.psrli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -91,7 +91,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.pslli.d, (c a, o imm8) {\n+        \"llvm.x86.sse2.pslli.d\", (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n                 let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n@@ -101,7 +101,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n                 CValue::by_val(res_lane, res_lane_layout)\n             });\n         };\n-        llvm.x86.sse2.storeu.dq, (v mem_addr, c a) {\n+        \"llvm.x86.sse2.storeu.dq\", (v mem_addr, c a) {\n             // FIXME correctly handle the unalignment\n             let dest = CPlace::for_ptr(Pointer::new(mem_addr), a.layout());\n             dest.write_cvalue(fx, a);"}, {"sha": "435737f3a513b511c1788db6cc663994fd6b7886", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -8,23 +8,25 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n+use rustc_span::symbol::{sym, kw};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+\n use crate::prelude::*;\n use cranelift_codegen::ir::AtomicRmwOp;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n     (_) => {\n         _\n     },\n     ($name:ident) => {\n-        stringify!($name)\n+        sym::$name\n+    },\n+    (kw.$name:ident) => {\n+        kw::$name\n     },\n     ($name:literal) => {\n-        stringify!($name)\n+        $name\n     },\n-    ($x:ident . $($xs:tt).*) => {\n-        concat!(stringify!($x), \".\", intrinsic_pat!($($xs).*))\n-    }\n }\n \n macro intrinsic_arg {\n@@ -87,7 +89,7 @@ macro call_intrinsic_match {\n     )*) => {\n         match $intrinsic {\n             $(\n-                stringify!($name) => {\n+                sym::$name => {\n                     assert!($substs.is_noop());\n                     if let [$(ref $arg),*] = *$args {\n                         let ($($arg,)*) = (\n@@ -400,18 +402,17 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     let ret = match destination {\n         Some((place, _)) => place,\n         None => {\n             // Insert non returning intrinsics here\n             match intrinsic {\n-                \"abort\" => {\n+                sym::abort => {\n                     trap_abort(fx, \"Called intrinsic::abort.\");\n                 }\n-                \"transmute\" => {\n+                sym::transmute => {\n                     crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", span);\n                 }\n                 _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n@@ -420,7 +421,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         }\n     };\n \n-    if intrinsic.starts_with(\"simd_\") {\n+    if intrinsic.as_str().starts_with(\"simd_\") {\n         self::simd::codegen_simd_intrinsic_call(fx, instance, args, ret, span);\n         let ret_block = fx.get_block(destination.expect(\"SIMD intrinsics don't diverge\").1);\n         fx.bcx.ins().jump(ret_block, &[]);\n@@ -470,8 +471,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         sinf64(flt) -> f64 => sin,\n         cosf32(flt) -> f32 => cosf,\n         cosf64(flt) -> f64 => cos,\n-        tanf32(flt) -> f32 => tanf,\n-        tanf64(flt) -> f64 => tan,\n     }\n \n     intrinsic_match! {\n@@ -496,12 +495,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 count\n             };\n \n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::copy_nonoverlapping {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         // NOTE: the volatile variants have src and dst swapped\n@@ -515,12 +514,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             };\n \n             // FIXME make the copy actually volatile when using emit_small_mem{cpy,move}\n-            if intrinsic.contains(\"nonoverlapping\") {\n+            if intrinsic == sym::volatile_copy_nonoverlapping_memory {\n                 // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memcpy(fx.module.target_config(), dst, src, byte_amount);\n             } else {\n                 // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.cx.module.target_config(), dst, src, byte_amount);\n+                fx.bcx.call_memmove(fx.module.target_config(), dst, src, byte_amount);\n             }\n         };\n         size_of_val, <T> (c ptr) {\n@@ -552,27 +551,28 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, CValue::by_val(align, usize_layout));\n         };\n \n-        _ if intrinsic.starts_with(\"unchecked_\") || intrinsic == \"exact_div\", (c x, c y) {\n+        unchecked_add | unchecked_sub | unchecked_div | exact_div | unchecked_rem\n+        | unchecked_shl | unchecked_shr, (c x, c y) {\n             // FIXME trap on overflow\n             let bin_op = match intrinsic {\n-                \"unchecked_add\" => BinOp::Add,\n-                \"unchecked_sub\" => BinOp::Sub,\n-                \"unchecked_div\" | \"exact_div\" => BinOp::Div,\n-                \"unchecked_rem\" => BinOp::Rem,\n-                \"unchecked_shl\" => BinOp::Shl,\n-                \"unchecked_shr\" => BinOp::Shr,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::unchecked_add => BinOp::Add,\n+                sym::unchecked_sub => BinOp::Sub,\n+                sym::unchecked_div | sym::exact_div => BinOp::Div,\n+                sym::unchecked_rem => BinOp::Rem,\n+                sym::unchecked_shl => BinOp::Shl,\n+                sym::unchecked_shr => BinOp::Shr,\n+                _ => unreachable!(),\n             };\n             let res = crate::num::codegen_int_binop(fx, bin_op, x, y);\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.ends_with(\"_with_overflow\"), (c x, c y) {\n+        add_with_overflow | sub_with_overflow | mul_with_overflow, (c x, c y) {\n             assert_eq!(x.layout().ty, y.layout().ty);\n             let bin_op = match intrinsic {\n-                \"add_with_overflow\" => BinOp::Add,\n-                \"sub_with_overflow\" => BinOp::Sub,\n-                \"mul_with_overflow\" => BinOp::Mul,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::add_with_overflow => BinOp::Add,\n+                sym::sub_with_overflow => BinOp::Sub,\n+                sym::mul_with_overflow => BinOp::Mul,\n+                _ => unreachable!(),\n             };\n \n             let res = crate::num::codegen_checked_int_binop(\n@@ -583,12 +583,12 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             );\n             ret.write_cvalue(fx, res);\n         };\n-        _ if intrinsic.starts_with(\"saturating_\"), <T> (c lhs, c rhs) {\n+        saturating_add | saturating_sub, <T> (c lhs, c rhs) {\n             assert_eq!(lhs.layout().ty, rhs.layout().ty);\n             let bin_op = match intrinsic {\n-                \"saturating_add\" => BinOp::Add,\n-                \"saturating_sub\" => BinOp::Sub,\n-                _ => unreachable!(\"intrinsic {}\", intrinsic),\n+                sym::saturating_add => BinOp::Add,\n+                sym::saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n             };\n \n             let signed = type_sign(T);\n@@ -609,15 +609,15 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n             let val = match (intrinsic, signed) {\n-                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (\"saturating_add\", true) => {\n+                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+                (sym::saturating_add, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n                     fx.bcx.ins().select(has_overflow, sat_val, val)\n                 }\n-                (\"saturating_sub\", true) => {\n+                (sym::saturating_sub, true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n                     let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n@@ -632,11 +632,21 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         rotate_left, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n+            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n+                fx.bcx.ins().ireduce(types::I64, y)\n+            } else {\n+                y\n+            };\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n         rotate_right, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n+            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n+                fx.bcx.ins().ireduce(types::I64, y)\n+            } else {\n+                y\n+            };\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -670,7 +680,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let dst_ptr = dst.load_scalar(fx);\n             // FIXME make the memset actually volatile when switching to emit_small_memset\n             // FIXME use emit_small_memset\n-            fx.bcx.call_memset(fx.cx.module.target_config(), dst_ptr, val, count);\n+            fx.bcx.call_memset(fx.module.target_config(), dst_ptr, val, count);\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n@@ -806,7 +816,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_zero_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n+            if intrinsic == sym::assert_zero_valid && !layout.might_permit_raw_init(fx, /*zero:*/ true).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to zero-initialize type `{}`, which is invalid\", T),\n@@ -815,7 +825,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n                 return;\n             }\n \n-            if intrinsic == \"assert_uninit_valid\" && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n+            if intrinsic == sym::assert_uninit_valid && !layout.might_permit_raw_init(fx, /*zero:*/ false).unwrap() {\n                 with_no_trimmed_paths(|| crate::base::codegen_panic(\n                     fx,\n                     &format!(\"attempted to leave type `{}` uninitialized, which is invalid\", T),\n@@ -827,7 +837,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         volatile_load | unaligned_volatile_load, (c ptr) {\n             // Cranelift treats loads as volatile by default\n-            // FIXME ignore during stack2reg optimization\n             // FIXME correctly handle unaligned_volatile_load\n             let inner_layout =\n                 fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n@@ -836,7 +845,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         volatile_store | unaligned_volatile_store, (v ptr, c val) {\n             // Cranelift treats stores as volatile by default\n-            // FIXME ignore during stack2reg optimization\n             // FIXME correctly handle unaligned_volatile_store\n             let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n             dest.write_cvalue(fx, val);\n@@ -878,14 +886,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, caller_location);\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_fence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_fence\"), () {\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n+        _ if intrinsic.as_str().starts_with(\"atomic_singlethreadfence\"), () {\n             // FIXME use a compiler fence once Cranelift supports it\n             fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_load\"), <T> (v ptr) {\n             validate_atomic_type!(fx, intrinsic, span, T);\n             let ty = fx.clif_type(T).unwrap();\n \n@@ -894,14 +902,14 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let val = CValue::by_val(val, fx.layout_of(T));\n             ret.write_cvalue(fx, val);\n         };\n-        _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n             let val = val.load_scalar(fx);\n \n             fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xchg\"), (v ptr, c new) {\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -913,7 +921,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+        _ if intrinsic.as_str().starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n             let layout = new.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n@@ -927,7 +935,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -939,7 +947,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n             let layout = amount.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -951,7 +959,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_and\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -963,7 +971,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_or\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -975,7 +983,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_xor\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -989,7 +997,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n-        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_nand\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1001,7 +1009,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_max\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1013,7 +1021,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umax\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1025,7 +1033,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_min\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1037,7 +1045,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let old = CValue::by_val(old, layout);\n             ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+        _ if intrinsic.as_str().starts_with(\"atomic_umin\"), (v ptr, c src) {\n             let layout = src.layout();\n             validate_atomic_type!(fx, intrinsic, span, layout.ty);\n             let ty = fx.clif_type(layout.ty).unwrap();\n@@ -1071,7 +1079,7 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         };\n \n-        try, (v f, v data, v _catch_fn) {\n+        kw.Try, (v f, v data, v _catch_fn) {\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n                 call_conv: CallConv::triple_default(fx.triple()),\n@@ -1088,11 +1096,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n \n         fadd_fast | fsub_fast | fmul_fast | fdiv_fast | frem_fast, (c x, c y) {\n             let res = crate::num::codegen_float_binop(fx, match intrinsic {\n-                \"fadd_fast\" => BinOp::Add,\n-                \"fsub_fast\" => BinOp::Sub,\n-                \"fmul_fast\" => BinOp::Mul,\n-                \"fdiv_fast\" => BinOp::Div,\n-                \"frem_fast\" => BinOp::Rem,\n+                sym::fadd_fast => BinOp::Add,\n+                sym::fsub_fast => BinOp::Sub,\n+                sym::fmul_fast => BinOp::Mul,\n+                sym::fdiv_fast => BinOp::Div,\n+                sym::frem_fast => BinOp::Rem,\n                 _ => unreachable!(),\n             }, x, y);\n             ret.write_cvalue(fx, res);"}, {"sha": "940d2514f7446a6e8dd9f197074af67ce64e8c31", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -13,8 +13,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n-    let intrinsic = fx.tcx.item_name(def_id).as_str();\n-    let intrinsic = &intrinsic[..];\n+    let intrinsic = fx.tcx.item_name(def_id);\n \n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n@@ -65,10 +64,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n         };\n \n         // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n-        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+        _ if intrinsic.as_str().starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n             validate_simd_type!(fx, intrinsic, span, x.layout().ty);\n \n-            let n: u16 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+            let n: u16 = intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap();\n \n             assert_eq!(x.layout(), y.layout());\n             let layout = x.layout();"}, {"sha": "32f403957025a649b8b87763ce0ae0a4377bd6c3", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 52, "deletions": 84, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private, decl_macro, never_type, hash_drain_filter)]\n+#![feature(rustc_private, decl_macro, never_type, hash_drain_filter, vec_into_raw_parts)]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n@@ -23,7 +23,6 @@ extern crate rustc_target;\n extern crate rustc_driver;\n \n use std::any::Any;\n-use std::str::FromStr;\n \n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n@@ -34,9 +33,10 @@ use rustc_middle::ty::query::Providers;\n use rustc_session::config::OutputFilenames;\n use rustc_session::Session;\n \n+use cranelift_codegen::isa::TargetIsa;\n use cranelift_codegen::settings::{self, Configurable};\n \n-use crate::constant::ConstantCx;\n+pub use crate::config::*;\n use crate::prelude::*;\n \n mod abi;\n@@ -49,6 +49,7 @@ mod cast;\n mod codegen_i128;\n mod common;\n mod compiler_builtins;\n+mod config;\n mod constant;\n mod debuginfo;\n mod discriminant;\n@@ -87,7 +88,6 @@ mod prelude {\n \n     pub(crate) use rustc_index::vec::Idx;\n \n-    pub(crate) use cranelift_codegen::entity::EntitySet;\n     pub(crate) use cranelift_codegen::ir::condcodes::{FloatCC, IntCC};\n     pub(crate) use cranelift_codegen::ir::function::Function;\n     pub(crate) use cranelift_codegen::ir::types;\n@@ -119,95 +119,36 @@ impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n     }\n }\n \n-struct CodegenCx<'m, 'tcx: 'm> {\n+/// The codegen context holds any information shared between the codegen of individual functions\n+/// inside a single codegen unit with the exception of the Cranelift [`Module`](cranelift_module::Module).\n+struct CodegenCx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    module: &'m mut dyn Module,\n     global_asm: String,\n-    constants_cx: ConstantCx,\n     cached_context: Context,\n-    vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n     debug_context: Option<DebugContext<'tcx>>,\n-    unwind_context: UnwindContext<'tcx>,\n+    unwind_context: UnwindContext,\n }\n \n-impl<'m, 'tcx> CodegenCx<'m, 'tcx> {\n+impl<'tcx> CodegenCx<'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n         backend_config: BackendConfig,\n-        module: &'m mut dyn Module,\n+        isa: &dyn TargetIsa,\n         debug_info: bool,\n     ) -> Self {\n-        let unwind_context = UnwindContext::new(\n-            tcx,\n-            module.isa(),\n-            matches!(backend_config.codegen_mode, CodegenMode::Aot),\n-        );\n-        let debug_context =\n-            if debug_info { Some(DebugContext::new(tcx, module.isa())) } else { None };\n+        assert_eq!(pointer_ty(tcx), isa.pointer_type());\n+\n+        let unwind_context =\n+            UnwindContext::new(tcx, isa, matches!(backend_config.codegen_mode, CodegenMode::Aot));\n+        let debug_context = if debug_info { Some(DebugContext::new(tcx, isa)) } else { None };\n         CodegenCx {\n             tcx,\n-            module,\n             global_asm: String::new(),\n-            constants_cx: ConstantCx::default(),\n             cached_context: Context::new(),\n-            vtables: FxHashMap::default(),\n             debug_context,\n             unwind_context,\n         }\n     }\n-\n-    fn finalize(self) -> (String, Option<DebugContext<'tcx>>, UnwindContext<'tcx>) {\n-        self.constants_cx.finalize(self.tcx, self.module);\n-        (self.global_asm, self.debug_context, self.unwind_context)\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum CodegenMode {\n-    Aot,\n-    Jit,\n-    JitLazy,\n-}\n-\n-impl Default for CodegenMode {\n-    fn default() -> Self {\n-        CodegenMode::Aot\n-    }\n-}\n-\n-impl FromStr for CodegenMode {\n-    type Err = String;\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"aot\" => Ok(CodegenMode::Aot),\n-            \"jit\" => Ok(CodegenMode::Jit),\n-            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n-            _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, Default)]\n-pub struct BackendConfig {\n-    pub codegen_mode: CodegenMode,\n-}\n-\n-impl BackendConfig {\n-    fn from_opts(opts: &[String]) -> Result<Self, String> {\n-        let mut config = BackendConfig::default();\n-        for opt in opts {\n-            if let Some((name, value)) = opt.split_once('=') {\n-                match name {\n-                    \"mode\" => config.codegen_mode = value.parse()?,\n-                    _ => return Err(format!(\"Unknown option `{}`\", name)),\n-                }\n-            } else {\n-                return Err(format!(\"Invalid option `{}`\", opt));\n-            }\n-        }\n-        Ok(config)\n-    }\n }\n \n pub struct CraneliftCodegenBackend {\n@@ -240,13 +181,23 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         metadata: EncodedMetadata,\n         need_metadata_module: bool,\n     ) -> Box<dyn Any> {\n-        let config = if let Some(config) = self.config {\n+        tcx.sess.abort_if_errors();\n+        let config = if let Some(config) = self.config.clone() {\n             config\n         } else {\n             BackendConfig::from_opts(&tcx.sess.opts.cg.llvm_args)\n                 .unwrap_or_else(|err| tcx.sess.fatal(&err))\n         };\n-        driver::codegen_crate(tcx, metadata, need_metadata_module, config)\n+        match config.codegen_mode {\n+            CodegenMode::Aot => driver::aot::run_aot(tcx, config, metadata, need_metadata_module),\n+            CodegenMode::Jit | CodegenMode::JitLazy => {\n+                #[cfg(feature = \"jit\")]\n+                let _: ! = driver::jit::run_jit(tcx, config);\n+\n+                #[cfg(not(feature = \"jit\"))]\n+                tcx.sess.fatal(\"jit support was disabled when compiling rustc_codegen_cranelift\");\n+            }\n+        }\n     }\n \n     fn join_codegen(\n@@ -284,17 +235,16 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     sess.target.llvm_target.parse().unwrap()\n }\n \n-fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n \n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n     flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n-    let enable_verifier =\n-        cfg!(debug_assertions) || std::env::var(\"CG_CLIF_ENABLE_VERIFIER\").is_ok();\n-    flags_builder.set(\"enable_verifier\", if enable_verifier { \"true\" } else { \"false\" }).unwrap();\n+    let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n+    flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n \n     let tls_model = match target_triple.binary_format {\n         BinaryFormat::Elf => \"elf_gd\",\n@@ -322,10 +272,28 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n     let flags = settings::Flags::new(flags_builder);\n \n     let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n-    let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n-    // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n-    // is interpreted as `bsr`.\n-    isa_builder.enable(\"nehalem\").unwrap();\n+\n+    let isa_builder = match sess.opts.cg.target_cpu.as_deref() {\n+        Some(\"native\") => {\n+            let builder = cranelift_native::builder_with_options(variant, true).unwrap();\n+            builder\n+        }\n+        Some(value) => {\n+            let mut builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n+            if let Err(_) = builder.enable(value) {\n+                sess.fatal(\"The specified target cpu isn't currently supported by Cranelift.\");\n+            }\n+            builder\n+        }\n+        None => {\n+            let mut builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n+            // Don't use \"haswell\" as the default, as it implies `has_lzcnt`.\n+            // macOS CI is still at Ivy Bridge EP, so `lzcnt` is interpreted as `bsr`.\n+            builder.enable(\"nehalem\").unwrap();\n+            builder\n+        }\n+    };\n+    \n     isa_builder.finish(flags)\n }\n "}, {"sha": "ca853aac15892285208581ed6884e4835babf864", "filename": "compiler/rustc_codegen_cranelift/src/linkage.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flinkage.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -13,6 +13,7 @@ pub(crate) fn get_clif_linkage(\n         (RLinkage::External, Visibility::Default) => Linkage::Export,\n         (RLinkage::Internal, Visibility::Default) => Linkage::Local,\n         (RLinkage::External, Visibility::Hidden) => Linkage::Hidden,\n+        (RLinkage::WeakAny, Visibility::Default) => Linkage::Preemptible,\n         _ => panic!(\"{:?} = {:?} {:?}\", mono_item, linkage, visibility),\n     }\n }"}, {"sha": "d504024a3358e100b75ab74af262620967a1e274", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 58, "deletions": 12, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,6 +1,9 @@\n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_hir::LangItem;\n+use rustc_middle::ty::subst::GenericArg;\n+use rustc_middle::ty::AssocKind;\n use rustc_session::config::EntryFnType;\n+use rustc_span::symbol::Ident;\n \n use crate::prelude::*;\n \n@@ -9,9 +12,10 @@ use crate::prelude::*;\n pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n-    unwind_context: &mut UnwindContext<'_>,\n+    unwind_context: &mut UnwindContext,\n+    is_jit: bool,\n ) {\n-    let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n+    let (main_def_id, is_main_fn) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n             def_id,\n             match entry_ty {\n@@ -23,18 +27,19 @@ pub(crate) fn maybe_create_entry_wrapper(\n     };\n \n     let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-    if module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+    if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n         return;\n     }\n \n-    create_entry_fn(tcx, module, unwind_context, main_def_id, use_start_lang_item);\n+    create_entry_fn(tcx, module, unwind_context, main_def_id, is_jit, is_main_fn);\n \n     fn create_entry_fn(\n         tcx: TyCtxt<'_>,\n         m: &mut impl Module,\n-        unwind_context: &mut UnwindContext<'_>,\n+        unwind_context: &mut UnwindContext,\n         rust_main_def_id: DefId,\n-        use_start_lang_item: bool,\n+        ignore_lang_start_wrapper: bool,\n+        is_main_fn: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -57,9 +62,9 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n-        let main_name = tcx.symbol_name(instance).name.to_string();\n+        let main_name = tcx.symbol_name(instance).name;\n         let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n-        let main_func_id = m.declare_function(&main_name, Linkage::Import, &main_sig).unwrap();\n+        let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n         ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n@@ -74,7 +79,47 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n-            let call_inst = if use_start_lang_item {\n+            let result = if is_main_fn && ignore_lang_start_wrapper {\n+                // regular main fn, but ignoring #[lang = \"start\"] as we are running in the jit\n+                // FIXME set program arguments somehow\n+                let call_inst = bcx.ins().call(main_func_ref, &[]);\n+                let call_results = bcx.func.dfg.inst_results(call_inst).to_owned();\n+\n+                let termination_trait = tcx.require_lang_item(LangItem::Termination, None);\n+                let report = tcx\n+                    .associated_items(termination_trait)\n+                    .find_by_name_and_kind(\n+                        tcx,\n+                        Ident::from_str(\"report\"),\n+                        AssocKind::Fn,\n+                        termination_trait,\n+                    )\n+                    .unwrap();\n+                let report = Instance::resolve(\n+                    tcx,\n+                    ParamEnv::reveal_all(),\n+                    report.def_id,\n+                    tcx.mk_substs([GenericArg::from(main_ret_ty)].iter()),\n+                )\n+                .unwrap()\n+                .unwrap();\n+\n+                let report_name = tcx.symbol_name(report).name;\n+                let report_sig = get_function_sig(tcx, m.isa().triple(), report);\n+                let report_func_id =\n+                    m.declare_function(report_name, Linkage::Import, &report_sig).unwrap();\n+                let report_func_ref = m.declare_func_in_func(report_func_id, &mut bcx.func);\n+\n+                // FIXME do proper abi handling instead of expecting the pass mode to be identical\n+                // for returns and arguments.\n+                let report_call_inst = bcx.ins().call(report_func_ref, &call_results);\n+                let res = bcx.func.dfg.inst_results(report_call_inst)[0];\n+                match m.target_config().pointer_type() {\n+                    types::I32 => res,\n+                    types::I64 => bcx.ins().sextend(types::I64, res),\n+                    _ => unimplemented!(\"16bit systems are not yet supported\"),\n+                }\n+            } else if is_main_fn {\n                 let start_def_id = tcx.require_lang_item(LangItem::Start, None);\n                 let start_instance = Instance::resolve(\n                     tcx,\n@@ -90,13 +135,14 @@ pub(crate) fn maybe_create_entry_wrapper(\n                 let main_val = bcx.ins().func_addr(m.target_config().pointer_type(), main_func_ref);\n \n                 let func_ref = m.declare_func_in_func(start_func_id, &mut bcx.func);\n-                bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(func_ref, &[main_val, arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             } else {\n                 // using user-defined start fn\n-                bcx.ins().call(main_func_ref, &[arg_argc, arg_argv])\n+                let call_inst = bcx.ins().call(main_func_ref, &[arg_argc, arg_argv]);\n+                bcx.inst_results(call_inst)[0]\n             };\n \n-            let result = bcx.inst_results(call_inst)[0];\n             bcx.ins().return_(&[result]);\n             bcx.seal_all_blocks();\n             bcx.finalize();"}, {"sha": "882232fde09d2bcd10aeb05f7e23c47f8fa5433d", "filename": "compiler/rustc_codegen_cranelift/src/metadata.rs", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmetadata.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -8,13 +8,24 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owning_ref::OwningRef;\n use rustc_data_structures::rustc_erase_owner;\n use rustc_data_structures::sync::MetadataRef;\n-use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoader};\n+use rustc_middle::middle::cstore::MetadataLoader;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n use rustc_target::spec::Target;\n \n use crate::backend::WriteMetadata;\n \n+/// The metadata loader used by cg_clif.\n+///\n+/// The metadata is stored in the same format as cg_llvm.\n+///\n+/// # Metadata location\n+///\n+/// <dl>\n+/// <dt>rlib</dt>\n+/// <dd>The metadata can be found in the `lib.rmeta` file inside of the ar archive.</dd>\n+/// <dt>dylib</dt>\n+/// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n+/// </dl>\n pub(crate) struct CraneliftMetadataLoader;\n \n fn load_metadata_with(\n@@ -58,54 +69,16 @@ impl MetadataLoader for CraneliftMetadataLoader {\n }\n \n // Adapted from https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src/librustc_codegen_llvm/base.rs#L47-L112\n-pub(crate) fn write_metadata<P: WriteMetadata>(\n-    tcx: TyCtxt<'_>,\n-    product: &mut P,\n-) -> EncodedMetadata {\n+pub(crate) fn write_metadata<O: WriteMetadata>(tcx: TyCtxt<'_>, object: &mut O) {\n     use snap::write::FrameEncoder;\n     use std::io::Write;\n \n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            config::CrateType::Executable\n-            | config::CrateType::Staticlib\n-            | config::CrateType::Cdylib => MetadataKind::None,\n-\n-            config::CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            config::CrateType::Dylib | config::CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n-    if kind == MetadataKind::None {\n-        return EncodedMetadata::new();\n-    }\n-\n     let metadata = tcx.encode_metadata();\n-    if kind == MetadataKind::Uncompressed {\n-        return metadata;\n-    }\n-\n-    assert!(kind == MetadataKind::Compressed);\n     let mut compressed = tcx.metadata_encoding_version();\n     FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n \n-    product.add_rustc_section(\n+    object.add_rustc_section(\n         rustc_middle::middle::exported_symbols::metadata_symbol_name(tcx),\n         compressed,\n-        tcx.sess.target.is_like_osx,\n     );\n-\n-    metadata\n }"}, {"sha": "b6d378a5fe10ae59b53ca8c4656923902250fc05", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -271,14 +271,17 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                         let val_hi = fx.bcx.ins().umulhi(lhs, rhs);\n                         fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0)\n                     } else {\n+                        // Based on LLVM's instruction sequence for compiling\n+                        // a.checked_mul(b).is_some() to riscv64gc:\n+                        // mulh    a2, a0, a1\n+                        // mul     a0, a0, a1\n+                        // srai    a0, a0, 63\n+                        // xor     a0, a0, a2\n+                        // snez    a0, a0\n                         let val_hi = fx.bcx.ins().smulhi(lhs, rhs);\n-                        let not_all_zero = fx.bcx.ins().icmp_imm(IntCC::NotEqual, val_hi, 0);\n-                        let not_all_ones = fx.bcx.ins().icmp_imm(\n-                            IntCC::NotEqual,\n-                            val_hi,\n-                            u64::try_from((1u128 << ty.bits()) - 1).unwrap() as i64,\n-                        );\n-                        fx.bcx.ins().band(not_all_zero, not_all_ones)\n+                        let val_sign = fx.bcx.ins().sshr_imm(val, i64::from(ty.bits() - 1));\n+                        let xor = fx.bcx.ins().bxor(val_hi, val_sign);\n+                        fx.bcx.ins().icmp_imm(IntCC::NotEqual, xor, 0)\n                     };\n                     (val, has_overflow)\n                 }"}, {"sha": "ca9ff15ec10ffee9967d95ccf086ab0e345ba1fe", "filename": "compiler/rustc_codegen_cranelift/src/optimize/code_layout.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fcode_layout.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -1,34 +0,0 @@\n-//! This optimization moves cold code to the end of the function.\n-//!\n-//! Some code is executed much less often than other code. For example panicking or the\n-//! landingpads for unwinding. By moving this cold code to the end of the function the average\n-//! amount of jumps is reduced and the code locality is improved.\n-//!\n-//! # Undefined behaviour\n-//!\n-//! This optimization doesn't assume anything that isn't already assumed by Cranelift itself.\n-\n-use crate::prelude::*;\n-\n-pub(super) fn optimize_function(ctx: &mut Context, cold_blocks: &EntitySet<Block>) {\n-    // FIXME Move the block in place instead of remove and append once\n-    // bytecodealliance/cranelift#1339 is implemented.\n-\n-    let mut block_insts = FxHashMap::default();\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n-        let insts = ctx.func.layout.block_insts(block).collect::<Vec<_>>();\n-        for &inst in &insts {\n-            ctx.func.layout.remove_inst(inst);\n-        }\n-        block_insts.insert(block, insts);\n-        ctx.func.layout.remove_block(block);\n-    }\n-\n-    // And then append them at the back again.\n-    for block in cold_blocks.keys().filter(|&block| cold_blocks.contains(block)) {\n-        ctx.func.layout.append_block(block);\n-        for inst in block_insts.remove(&block).unwrap() {\n-            ctx.func.layout.append_inst(inst, block);\n-        }\n-    }\n-}"}, {"sha": "137fb5f77313cbae7d39c54291a383fa9e7e2357", "filename": "compiler/rustc_codegen_cranelift/src/optimize/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fmod.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -2,29 +2,16 @@\n \n use crate::prelude::*;\n \n-mod code_layout;\n pub(crate) mod peephole;\n-mod stack2reg;\n \n pub(crate) fn optimize_function<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     ctx: &mut Context,\n-    cold_blocks: &EntitySet<Block>,\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n-    // The code_layout optimization is very cheap.\n-    self::code_layout::optimize_function(ctx, cold_blocks);\n+    // FIXME classify optimizations over opt levels once we have more\n \n-    if tcx.sess.opts.optimize == rustc_session::config::OptLevel::No {\n-        return; // FIXME classify optimizations over opt levels\n-    }\n-\n-    // FIXME(#1142) stack2reg miscompiles lewton\n-    if false {\n-        self::stack2reg::optimize_function(ctx, clif_comments);\n-    }\n-\n-    crate::pretty_clif::write_clif_file(tcx, \"stack2reg\", None, instance, &ctx, &*clif_comments);\n+    crate::pretty_clif::write_clif_file(tcx, \"preopt\", None, instance, &ctx, &*clif_comments);\n     crate::base::verify_func(tcx, &*clif_comments, &ctx.func);\n }"}, {"sha": "8bb02a3e5585482b4e88a0135524f494a74ff184", "filename": "compiler/rustc_codegen_cranelift/src/optimize/stack2reg.rs", "status": "removed", "additions": 0, "deletions": 486, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c2c6b670023efda0fea8e1837f9542d3ed12f5d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Foptimize%2Fstack2reg.rs?ref=1c2c6b670023efda0fea8e1837f9542d3ed12f5d", "patch": "@@ -1,486 +0,0 @@\n-//! This optimization replaces stack accesses with SSA variables and removes dead stores when possible.\n-//!\n-//! # Undefined behaviour\n-//!\n-//! This optimization is based on the assumption that stack slots which don't have their address\n-//! leaked through `stack_addr` are only accessed using `stack_load` and `stack_store` in the\n-//! function which has the stack slots. This optimization also assumes that stack slot accesses\n-//! are never out of bounds. If these assumptions are not correct, then this optimization may remove\n-//! `stack_store` instruction incorrectly, or incorrectly use a previously stored value as the value\n-//! being loaded by a `stack_load`.\n-\n-use std::collections::BTreeMap;\n-use std::fmt;\n-use std::ops::Not;\n-\n-use rustc_data_structures::fx::FxHashSet;\n-\n-use cranelift_codegen::cursor::{Cursor, FuncCursor};\n-use cranelift_codegen::ir::immediates::Offset32;\n-use cranelift_codegen::ir::{InstructionData, Opcode, ValueDef};\n-\n-use crate::prelude::*;\n-\n-/// Workaround for `StackSlot` not implementing `Ord`.\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-struct OrdStackSlot(StackSlot);\n-\n-impl fmt::Debug for OrdStackSlot {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.0)\n-    }\n-}\n-\n-impl PartialOrd for OrdStackSlot {\n-    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n-        self.0.as_u32().partial_cmp(&rhs.0.as_u32())\n-    }\n-}\n-\n-impl Ord for OrdStackSlot {\n-    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n-        self.0.as_u32().cmp(&rhs.0.as_u32())\n-    }\n-}\n-\n-#[derive(Debug, Default)]\n-struct StackSlotUsage {\n-    stack_addr: FxHashSet<Inst>,\n-    stack_load: FxHashSet<Inst>,\n-    stack_store: FxHashSet<Inst>,\n-}\n-\n-impl StackSlotUsage {\n-    fn potential_stores_for_load(&self, ctx: &Context, load: Inst) -> Vec<Inst> {\n-        self.stack_store\n-            .iter()\n-            .cloned()\n-            .filter(|&store| {\n-                match spatial_overlap(&ctx.func, store, load) {\n-                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-                }\n-            })\n-            .filter(|&store| {\n-                match temporal_order(ctx, store, load) {\n-                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-                }\n-            })\n-            .collect::<Vec<Inst>>()\n-    }\n-\n-    fn potential_loads_of_store(&self, ctx: &Context, store: Inst) -> Vec<Inst> {\n-        self.stack_load\n-            .iter()\n-            .cloned()\n-            .filter(|&load| {\n-                match spatial_overlap(&ctx.func, store, load) {\n-                    SpatialOverlap::No => false, // Can never be the source of the loaded value.\n-                    SpatialOverlap::Partial | SpatialOverlap::Full => true,\n-                }\n-            })\n-            .filter(|&load| {\n-                match temporal_order(ctx, store, load) {\n-                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n-                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n-                }\n-            })\n-            .collect::<Vec<Inst>>()\n-    }\n-\n-    fn remove_unused_stack_addr(func: &mut Function, inst: Inst) {\n-        func.dfg.detach_results(inst);\n-        func.dfg.replace(inst).nop();\n-    }\n-\n-    fn remove_unused_load(func: &mut Function, load: Inst) {\n-        func.dfg.detach_results(load);\n-        func.dfg.replace(load).nop();\n-    }\n-\n-    fn remove_dead_store(&mut self, func: &mut Function, store: Inst) {\n-        func.dfg.replace(store).nop();\n-        self.stack_store.remove(&store);\n-    }\n-\n-    fn change_load_to_alias(&mut self, func: &mut Function, load: Inst, value: Value) {\n-        let loaded_value = func.dfg.inst_results(load)[0];\n-        let loaded_type = func.dfg.value_type(loaded_value);\n-\n-        if func.dfg.value_type(value) == loaded_type {\n-            func.dfg.detach_results(load);\n-            func.dfg.replace(load).nop();\n-            func.dfg.change_to_alias(loaded_value, value);\n-        } else {\n-            func.dfg.replace(load).bitcast(loaded_type, value);\n-        }\n-\n-        self.stack_load.remove(&load);\n-    }\n-}\n-\n-struct OptimizeContext<'a> {\n-    ctx: &'a mut Context,\n-    stack_slot_usage_map: BTreeMap<OrdStackSlot, StackSlotUsage>,\n-}\n-\n-impl<'a> OptimizeContext<'a> {\n-    fn for_context(ctx: &'a mut Context) -> Self {\n-        ctx.flowgraph(); // Compute cfg and domtree.\n-\n-        // Record all stack_addr, stack_load and stack_store instructions.\n-        let mut stack_slot_usage_map = BTreeMap::<OrdStackSlot, StackSlotUsage>::new();\n-\n-        let mut cursor = FuncCursor::new(&mut ctx.func);\n-        while let Some(_block) = cursor.next_block() {\n-            while let Some(inst) = cursor.next_inst() {\n-                match cursor.func.dfg[inst] {\n-                    InstructionData::StackLoad {\n-                        opcode: Opcode::StackAddr,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_addr\n-                            .insert(inst);\n-                    }\n-                    InstructionData::StackLoad {\n-                        opcode: Opcode::StackLoad,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_load\n-                            .insert(inst);\n-                    }\n-                    InstructionData::StackStore {\n-                        opcode: Opcode::StackStore,\n-                        arg: _,\n-                        stack_slot,\n-                        offset: _,\n-                    } => {\n-                        stack_slot_usage_map\n-                            .entry(OrdStackSlot(stack_slot))\n-                            .or_insert_with(StackSlotUsage::default)\n-                            .stack_store\n-                            .insert(inst);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        OptimizeContext { ctx, stack_slot_usage_map }\n-    }\n-}\n-\n-pub(super) fn optimize_function(\n-    ctx: &mut Context,\n-    clif_comments: &mut crate::pretty_clif::CommentWriter,\n-) {\n-    combine_stack_addr_with_load_store(&mut ctx.func);\n-\n-    let mut opt_ctx = OptimizeContext::for_context(ctx);\n-\n-    // FIXME Repeat following instructions until fixpoint.\n-\n-    remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n-\n-    if clif_comments.enabled() {\n-        for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n-            clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n-        }\n-    }\n-\n-    for (stack_slot, users) in opt_ctx.stack_slot_usage_map.iter_mut() {\n-        if users.stack_addr.is_empty().not() {\n-            // Stack addr leaked; there may be unknown loads and stores.\n-            // FIXME use stacked borrows to optimize\n-            continue;\n-        }\n-\n-        for load in users.stack_load.clone().into_iter() {\n-            let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n-\n-            if clif_comments.enabled() {\n-                for &store in &potential_stores {\n-                    clif_comments.add_comment(\n-                        load,\n-                        format!(\n-                            \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                            temporal_order(&opt_ctx.ctx, store, load),\n-                        ),\n-                    );\n-                }\n-            }\n-\n-            match *potential_stores {\n-                [] => {\n-                    if clif_comments.enabled() {\n-                        clif_comments\n-                            .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n-                    }\n-                }\n-                [store]\n-                    if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n-                        && temporal_order(&opt_ctx.ctx, store, load)\n-                            == TemporalOrder::DefinitivelyBefore =>\n-                {\n-                    // Only one store could have been the origin of the value.\n-                    let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n-\n-                    if clif_comments.enabled() {\n-                        clif_comments.add_comment(\n-                            load,\n-                            format!(\"Store to load forward {} -> {}\", store, load),\n-                        );\n-                    }\n-\n-                    users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n-                }\n-                _ => {} // FIXME implement this\n-            }\n-        }\n-\n-        for store in users.stack_store.clone().into_iter() {\n-            let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n-\n-            if clif_comments.enabled() {\n-                for &load in &potential_loads {\n-                    clif_comments.add_comment(\n-                        store,\n-                        format!(\n-                            \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                            temporal_order(&opt_ctx.ctx, store, load),\n-                        ),\n-                    );\n-                }\n-            }\n-\n-            if potential_loads.is_empty() {\n-                // Never loaded; can safely remove all stores and the stack slot.\n-                // FIXME also remove stores when there is always a next store before a load.\n-\n-                if clif_comments.enabled() {\n-                    clif_comments.add_comment(\n-                        store,\n-                        format!(\n-                            \"Remove dead stack store {} of {}\",\n-                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                            stack_slot.0\n-                        ),\n-                    );\n-                }\n-\n-                users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n-            }\n-        }\n-\n-        if users.stack_store.is_empty() && users.stack_load.is_empty() {\n-            opt_ctx.ctx.func.stack_slots[stack_slot.0].size = 0;\n-        }\n-    }\n-}\n-\n-fn combine_stack_addr_with_load_store(func: &mut Function) {\n-    // Turn load and store into stack_load and stack_store when possible.\n-    let mut cursor = FuncCursor::new(func);\n-    while let Some(_block) = cursor.next_block() {\n-        while let Some(inst) = cursor.next_inst() {\n-            match cursor.func.dfg[inst] {\n-                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n-                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n-                    {\n-                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) =\n-                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n-                    {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n-                        {\n-                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n-                            cursor.func.dfg.replace(inst).stack_load(\n-                                ty,\n-                                stack_slot,\n-                                combined_offset,\n-                            );\n-                        }\n-                    }\n-                }\n-                InstructionData::Store {\n-                    opcode: Opcode::Store,\n-                    args: [value, addr],\n-                    flags: _,\n-                    offset,\n-                } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128\n-                        || cursor.func.dfg.ctrl_typevar(inst).is_vector()\n-                    {\n-                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) =\n-                        try_get_stack_slot_and_offset_for_addr(cursor.func, addr)\n-                    {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into())\n-                        {\n-                            cursor.func.dfg.replace(inst).stack_store(\n-                                value,\n-                                stack_slot,\n-                                combined_offset,\n-                            );\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn remove_unused_stack_addr_and_stack_load(opt_ctx: &mut OptimizeContext<'_>) {\n-    // FIXME incrementally rebuild on each call?\n-    let mut stack_addr_load_insts_users = FxHashMap::<Inst, FxHashSet<Inst>>::default();\n-\n-    let mut cursor = FuncCursor::new(&mut opt_ctx.ctx.func);\n-    while let Some(_block) = cursor.next_block() {\n-        while let Some(inst) = cursor.next_inst() {\n-            for &arg in cursor.func.dfg.inst_args(inst) {\n-                if let ValueDef::Result(arg_origin, 0) = cursor.func.dfg.value_def(arg) {\n-                    match cursor.func.dfg[arg_origin].opcode() {\n-                        Opcode::StackAddr | Opcode::StackLoad => {\n-                            stack_addr_load_insts_users\n-                                .entry(arg_origin)\n-                                .or_insert_with(FxHashSet::default)\n-                                .insert(inst);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(debug_assertions)]\n-    for inst in stack_addr_load_insts_users.keys() {\n-        let mut is_recorded_stack_addr_or_stack_load = false;\n-        for stack_slot_users in opt_ctx.stack_slot_usage_map.values() {\n-            is_recorded_stack_addr_or_stack_load |= stack_slot_users.stack_addr.contains(inst)\n-                || stack_slot_users.stack_load.contains(inst);\n-        }\n-        assert!(is_recorded_stack_addr_or_stack_load);\n-    }\n-\n-    // Replace all unused stack_addr and stack_load instructions with nop.\n-    let mut func = &mut opt_ctx.ctx.func;\n-\n-    for stack_slot_users in opt_ctx.stack_slot_usage_map.values_mut() {\n-        stack_slot_users\n-            .stack_addr\n-            .drain_filter(|inst| {\n-                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n-            })\n-            .for_each(|inst| StackSlotUsage::remove_unused_stack_addr(&mut func, inst));\n-\n-        stack_slot_users\n-            .stack_load\n-            .drain_filter(|inst| {\n-                stack_addr_load_insts_users.get(inst).map(|users| users.is_empty()).unwrap_or(true)\n-            })\n-            .for_each(|inst| StackSlotUsage::remove_unused_load(&mut func, inst));\n-    }\n-}\n-\n-fn try_get_stack_slot_and_offset_for_addr(\n-    func: &Function,\n-    addr: Value,\n-) -> Option<(StackSlot, Offset32)> {\n-    if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n-        if let InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset } =\n-            func.dfg[addr_inst]\n-        {\n-            return Some((stack_slot, offset));\n-        }\n-    }\n-    None\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum SpatialOverlap {\n-    No,\n-    Partial,\n-    Full,\n-}\n-\n-fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n-    fn inst_info(func: &Function, inst: Inst) -> (StackSlot, Offset32, u32) {\n-        match func.dfg[inst] {\n-            InstructionData::StackLoad { opcode: Opcode::StackAddr, stack_slot, offset }\n-            | InstructionData::StackLoad { opcode: Opcode::StackLoad, stack_slot, offset }\n-            | InstructionData::StackStore {\n-                opcode: Opcode::StackStore,\n-                stack_slot,\n-                offset,\n-                arg: _,\n-            } => (stack_slot, offset, func.dfg.ctrl_typevar(inst).bytes()),\n-            _ => unreachable!(\"{:?}\", func.dfg[inst]),\n-        }\n-    }\n-\n-    debug_assert_ne!(src, dest);\n-\n-    let (src_ss, src_offset, src_size) = inst_info(func, src);\n-    let (dest_ss, dest_offset, dest_size) = inst_info(func, dest);\n-\n-    if src_ss != dest_ss {\n-        return SpatialOverlap::No;\n-    }\n-\n-    if src_offset == dest_offset && src_size == dest_size {\n-        return SpatialOverlap::Full;\n-    }\n-\n-    let src_end: i64 = src_offset.try_add_i64(i64::from(src_size)).unwrap().into();\n-    let dest_end: i64 = dest_offset.try_add_i64(i64::from(dest_size)).unwrap().into();\n-    if src_end <= dest_offset.into() || dest_end <= src_offset.into() {\n-        return SpatialOverlap::No;\n-    }\n-\n-    SpatialOverlap::Partial\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum TemporalOrder {\n-    /// `src` will never be executed before `dest`.\n-    NeverBefore,\n-\n-    /// `src` may be executed before `dest`.\n-    MaybeBefore,\n-\n-    /// `src` will always be executed before `dest`.\n-    /// There may still be other instructions in between.\n-    DefinitivelyBefore,\n-}\n-\n-fn temporal_order(ctx: &Context, src: Inst, dest: Inst) -> TemporalOrder {\n-    debug_assert_ne!(src, dest);\n-\n-    if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n-        TemporalOrder::DefinitivelyBefore\n-    } else if ctx.domtree.dominates(src, dest, &ctx.func.layout) {\n-        TemporalOrder::NeverBefore\n-    } else {\n-        TemporalOrder::MaybeBefore\n-    }\n-}"}, {"sha": "158811c5eaf4903cadf13709c9abba67cf8f8b1c", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -207,7 +207,7 @@ pub(crate) fn should_write_ir(tcx: TyCtxt<'_>) -> bool {\n \n pub(crate) fn write_ir_file(\n     tcx: TyCtxt<'_>,\n-    name: &str,\n+    name: impl FnOnce() -> String,\n     write: impl FnOnce(&mut dyn Write) -> std::io::Result<()>,\n ) {\n     if !should_write_ir(tcx) {\n@@ -222,7 +222,7 @@ pub(crate) fn write_ir_file(\n         res @ Err(_) => res.unwrap(),\n     }\n \n-    let clif_file_name = clif_output_dir.join(name);\n+    let clif_file_name = clif_output_dir.join(name());\n \n     let res = std::fs::File::create(clif_file_name).and_then(|mut file| write(&mut file));\n     if let Err(err) = res {\n@@ -238,30 +238,31 @@ pub(crate) fn write_clif_file<'tcx>(\n     context: &cranelift_codegen::Context,\n     mut clif_comments: &CommentWriter,\n ) {\n-    write_ir_file(tcx, &format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix), |file| {\n-        let value_ranges =\n-            isa.map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n+    write_ir_file(\n+        tcx,\n+        || format!(\"{}.{}.clif\", tcx.symbol_name(instance).name, postfix),\n+        |file| {\n+            let value_ranges = isa\n+                .map(|isa| context.build_value_labels_ranges(isa).expect(\"value location ranges\"));\n \n-        let mut clif = String::new();\n-        cranelift_codegen::write::decorate_function(\n-            &mut clif_comments,\n-            &mut clif,\n-            &context.func,\n-            &DisplayFunctionAnnotations {\n-                isa: Some(&*crate::build_isa(tcx.sess)),\n-                value_ranges: value_ranges.as_ref(),\n-            },\n-        )\n-        .unwrap();\n+            let mut clif = String::new();\n+            cranelift_codegen::write::decorate_function(\n+                &mut clif_comments,\n+                &mut clif,\n+                &context.func,\n+                &DisplayFunctionAnnotations { isa, value_ranges: value_ranges.as_ref() },\n+            )\n+            .unwrap();\n \n-        writeln!(file, \"test compile\")?;\n-        writeln!(file, \"set is_pic\")?;\n-        writeln!(file, \"set enable_simd\")?;\n-        writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n-        writeln!(file)?;\n-        file.write_all(clif.as_bytes())?;\n-        Ok(())\n-    });\n+            writeln!(file, \"test compile\")?;\n+            writeln!(file, \"set is_pic\")?;\n+            writeln!(file, \"set enable_simd\")?;\n+            writeln!(file, \"target {} haswell\", crate::target_triple(tcx.sess))?;\n+            writeln!(file)?;\n+            file.write_all(clif.as_bytes())?;\n+            Ok(())\n+        },\n+    );\n }\n \n impl fmt::Debug for FunctionCx<'_, '_, '_> {"}, {"sha": "819c8b51558a051321ef9f1670c2771f6937b301", "filename": "compiler/rustc_codegen_cranelift/src/trap.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Ftrap.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -4,7 +4,6 @@ use crate::prelude::*;\n \n fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n     let puts = fx\n-        .cx\n         .module\n         .declare_function(\n             \"puts\",\n@@ -16,13 +15,12 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n             },\n         )\n         .unwrap();\n-    let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n+    let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n     if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }\n \n-    let symbol_name = fx.tcx.symbol_name(fx.instance);\n-    let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n+    let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, fx.symbol_name, msg);\n     let msg_ptr = fx.anonymous_str(\"trap\", &real_msg);\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }"}, {"sha": "9a572c3501f925b7adc726c64e30755e9ade2fef", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -554,7 +554,7 @@ impl<'tcx> CPlace<'tcx> {\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memory_copy(\n-                    fx.cx.module.target_config(),\n+                    fx.module.target_config(),\n                     to_addr,\n                     from_addr,\n                     size,"}, {"sha": "bbf07ffc85dbdb7c2a6bd970a735ea69f180eb2b", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -72,15 +72,15 @@ pub(crate) fn get_vtable<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.cx.vtables.get(&(layout.ty, trait_ref)) {\n+    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n         *data_id\n     } else {\n         let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.cx.vtables.insert((layout.ty, trait_ref), data_id);\n+        fx.vtables.insert((layout.ty, trait_ref), data_id);\n         data_id\n     };\n \n-    let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n }\n \n@@ -94,7 +94,7 @@ fn build_vtable<'tcx>(\n \n     let drop_in_place_fn = import_function(\n         tcx,\n-        fx.cx.module,\n+        fx.module,\n         Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n     );\n \n@@ -111,7 +111,7 @@ fn build_vtable<'tcx>(\n         opt_mth.map(|(def_id, substs)| {\n             import_function(\n                 tcx,\n-                fx.cx.module,\n+                fx.module,\n                 Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), def_id, substs)\n                     .unwrap()\n                     .polymorphize(fx.tcx),\n@@ -132,34 +132,16 @@ fn build_vtable<'tcx>(\n \n     for (i, component) in components.into_iter().enumerate() {\n         if let Some(func_id) = component {\n-            let func_ref = fx.cx.module.declare_func_in_data(func_id, &mut data_ctx);\n+            let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n             data_ctx.write_function_addr((i * usize_size) as u32, func_ref);\n         }\n     }\n \n     data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n \n-    let data_id = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            &format!(\n-                \"__vtable.{}.for.{:?}.{}\",\n-                trait_ref\n-                    .as_ref()\n-                    .map(|trait_ref| format!(\"{:?}\", trait_ref.skip_binder()).into())\n-                    .unwrap_or(std::borrow::Cow::Borrowed(\"???\")),\n-                layout.ty,\n-                fx.cx.vtables.len(),\n-            ),\n-            Linkage::Local,\n-            false,\n-            false,\n-        )\n-        .unwrap();\n-\n-    // FIXME don't duplicate definitions in lazy jit mode\n-    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n+    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n+\n+    fx.module.define_data(data_id, &data_ctx).unwrap();\n \n     data_id\n }"}, {"sha": "65a988629c3b2646127e953561dd709dfb3f2470", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -609,7 +609,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n \n   std::string ErrorInfo;\n   std::error_code EC;\n-  raw_fd_ostream OS(Path, EC, sys::fs::F_None);\n+  raw_fd_ostream OS(Path, EC, sys::fs::OF_None);\n   if (EC)\n     ErrorInfo = EC.message();\n   if (ErrorInfo != \"\") {\n@@ -619,7 +619,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n \n   buffer_ostream BOS(OS);\n   if (DwoPath) {\n-    raw_fd_ostream DOS(DwoPath, EC, sys::fs::F_None);\n+    raw_fd_ostream DOS(DwoPath, EC, sys::fs::OF_None);\n     EC.clear();\n     if (EC)\n         ErrorInfo = EC.message();\n@@ -1146,7 +1146,7 @@ extern \"C\" LLVMRustResult\n LLVMRustPrintModule(LLVMModuleRef M, const char *Path, DemangleFn Demangle) {\n   std::string ErrorInfo;\n   std::error_code EC;\n-  raw_fd_ostream OS(Path, EC, sys::fs::F_None);\n+  raw_fd_ostream OS(Path, EC, sys::fs::OF_None);\n   if (EC)\n     ErrorInfo = EC.message();\n   if (ErrorInfo != \"\") {"}, {"sha": "b3c67b84da6172a6f7e92ceb56c8e9998a5de869", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 174, "deletions": 131, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -6,149 +6,192 @@\n     }\n </style>\n \n-Support for different platforms are organized into three tiers, each with a\n-different set of guarantees. For more information on the policies for targets\n-at each tier, see the [Target Tier Policy](target-tier-policy.md).\n+Support for different platforms (\"targets\") are organized into three tiers,\n+each with a different set of guarantees. For more information on the policies\n+for targets at each tier, see the [Target Tier Policy](target-tier-policy.md).\n \n-Platforms are identified by their \"target triple\" which is the string to\n-inform the compiler what kind of output should be produced. The columns in the\n-tables below have the following meanings:\n+Targets are identified by their \"target triple\" which is the string to inform\n+the compiler what kind of output should be produced.\n \n-* std:\n-    * \u2713 indicates the full standard library is available.\n-    * \\* indicates the target only supports [`no_std`] development.\n-    * ? indicates the standard library support is unknown or a work-in-progress.\n-* host: A \u2713 indicates that `rustc` and `cargo` can run on the host platform.\n+## Tier 1 with Host Tools\n \n-[`no_std`]: https://rust-embedded.github.io/book/intro/no-std.html\n-\n-## Tier 1\n+Tier 1 targets can be thought of as \"guaranteed to work\". The Rust project\n+builds official binary releases for each tier 1 target, and automated testing\n+ensures that each tier 1 target builds and passes tests after each change.\n \n-Tier 1 platforms can be thought of as \"guaranteed to work\".\n-Specifically they will each satisfy the following requirements:\n+Tier 1 targets with host tools additionally support running tools like `rustc`\n+and `cargo` natively on the target, and automated testing ensures that tests\n+pass for the host tools as well. This allows the target to be used as a\n+development platform, not just a compilation target. For the full requirements,\n+see [Tier 1 with Host Tools](target-tier-policy.md#tier-1-with-host-tools) in\n+the Target Tier Policy.\n \n-* Official binary releases are provided for the platform.\n-* Automated testing is set up to run tests for the platform.\n-* Landing changes to the `rust-lang/rust` repository's master branch is gated\n-  on tests passing.\n-* Documentation for how to use and how to build the platform is available.\n+All tier 1 targets with host tools support the full standard library.\n \n-target | std | host | notes\n--------|-----|------|-------\n-`aarch64-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (kernel 4.2, glibc 2.17+) [^missing-stack-probes]\n-`i686-pc-windows-gnu` | \u2713 | \u2713 | 32-bit MinGW (Windows 7+)\n-`i686-pc-windows-msvc` | \u2713 | \u2713 | 32-bit MSVC (Windows 7+)\n-`i686-unknown-linux-gnu` | \u2713 | \u2713 | 32-bit Linux (kernel 2.6.32+, glibc 2.11+)\n-`x86_64-apple-darwin` | \u2713 | \u2713 | 64-bit macOS (10.7+, Lion+)\n-`x86_64-pc-windows-gnu` | \u2713 | \u2713 | 64-bit MinGW (Windows 7+)\n-`x86_64-pc-windows-msvc` | \u2713 | \u2713 | 64-bit MSVC (Windows 7+)\n-`x86_64-unknown-linux-gnu` | \u2713 | \u2713 | 64-bit Linux (kernel 2.6.32+, glibc 2.11+)\n+target | notes\n+-------|-------\n+`aarch64-unknown-linux-gnu` | ARM64 Linux (kernel 4.2, glibc 2.17+) [^missing-stack-probes]\n+`i686-pc-windows-gnu` | 32-bit MinGW (Windows 7+)\n+`i686-pc-windows-msvc` | 32-bit MSVC (Windows 7+)\n+`i686-unknown-linux-gnu` | 32-bit Linux (kernel 2.6.32+, glibc 2.11+)\n+`x86_64-apple-darwin` | 64-bit macOS (10.7+, Lion+)\n+`x86_64-pc-windows-gnu` | 64-bit MinGW (Windows 7+)\n+`x86_64-pc-windows-msvc` | 64-bit MSVC (Windows 7+)\n+`x86_64-unknown-linux-gnu` | 64-bit Linux (kernel 2.6.32+, glibc 2.11+)\n \n [^missing-stack-probes]: Stack probes support is missing on\n   `aarch64-unknown-linux-gnu`, but it's planned to be implemented in the near\n   future. The implementation is tracked on [issue #77071][77071].\n \n [77071]: https://github.com/rust-lang/rust/issues/77071\n \n+## Tier 1\n+\n+Tier 1 targets can be thought of as \"guaranteed to work\". The Rust project\n+builds official binary releases for each tier 1 target, and automated testing\n+ensures that each tier 1 target builds and passes tests after each change. For\n+the full requirements, see [Tier 1 target\n+policy](target-tier-policy.md#tier-1-target-policy) in the Target Tier Policy.\n+\n+At this time, all Tier 1 targets are [Tier 1 with Host\n+Tools](#tier-1-with-host-tools).\n+\n+## Tier 2 with Host Tools\n+\n+Tier 2 targets can be thought of as \"guaranteed to build\". The Rust project\n+builds official binary releases for each tier 2 target, and automated builds\n+ensure that each tier 2 target builds after each change. Automated tests are\n+not always run so it's not guaranteed to produce a working build, but tier 2\n+targets often work to quite a good degree and patches are always welcome!\n+\n+Tier 2 targets with host tools additionally support running tools like `rustc`\n+and `cargo` natively on the target, and automated builds ensure that the host\n+tools build as well. This allows the target to be used as a development\n+platform, not just a compilation target. For the full requirements, see [Tier 2\n+with Host Tools](target-tier-policy.md#tier-2-with-host-tools) in the Target\n+Tier Policy.\n+\n+All tier 2 targets with host tools support the full standard library.\n+\n+target | notes\n+-------|-------\n+`aarch64-apple-darwin` | ARM64 macOS (11.0+, Big Sur+)\n+`aarch64-pc-windows-msvc` | ARM64 Windows MSVC\n+`aarch64-unknown-linux-musl` | ARM64 Linux with MUSL\n+`arm-unknown-linux-gnueabi` | ARMv6 Linux (kernel 3.2, glibc 2.17)\n+`arm-unknown-linux-gnueabihf` | ARMv6 Linux, hardfloat (kernel 3.2, glibc 2.17)\n+`armv7-unknown-linux-gnueabihf` | ARMv7 Linux, hardfloat (kernel 3.2, glibc 2.17)\n+`mips-unknown-linux-gnu` | MIPS Linux (kernel 4.4, glibc 2.23)\n+`mips64-unknown-linux-gnuabi64` | MIPS64 Linux, n64 ABI (kernel 4.4, glibc 2.23)\n+`mips64el-unknown-linux-gnuabi64` | MIPS64 (LE) Linux, n64 ABI (kernel 4.4, glibc 2.23)\n+`mipsel-unknown-linux-gnu` | MIPS (LE) Linux (kernel 4.4, glibc 2.23)\n+`powerpc-unknown-linux-gnu` | PowerPC Linux (kernel 2.6.32, glibc 2.11)\n+`powerpc64-unknown-linux-gnu` | PPC64 Linux (kernel 2.6.32, glibc 2.11)\n+`powerpc64le-unknown-linux-gnu` | PPC64LE Linux (kernel 3.10, glibc 2.17)\n+`riscv64gc-unknown-linux-gnu` | RISC-V Linux (kernel 4.20, glibc 2.29)\n+`s390x-unknown-linux-gnu` | S390x Linux (kernel 2.6.32, glibc 2.11)\n+`x86_64-unknown-freebsd` | 64-bit FreeBSD\n+`x86_64-unknown-illumos` | illumos\n+`x86_64-unknown-linux-musl` | 64-bit Linux with MUSL\n+`x86_64-unknown-netbsd` | NetBSD/amd64\n+\n ## Tier 2\n \n-Tier 2 platforms can be thought of as \"guaranteed to build\". Automated tests\n-are not run so it's not guaranteed to produce a working build, but platforms\n-often work to quite a good degree and patches are always welcome!\n-Specifically, these platforms are required to have each of the following:\n+Tier 2 targets can be thought of as \"guaranteed to build\". The Rust project\n+builds official binary releases for each tier 2 target, and automated builds\n+ensure that each tier 2 target builds after each change. Automated tests are\n+not always run so it's not guaranteed to produce a working build, but tier 2\n+targets often work to quite a good degree and patches are always welcome! For\n+the full requirements, see [Tier 2 target\n+policy](target-tier-policy.md#tier-2-target-policy) in the Target Tier Policy.\n \n-* Official binary releases are provided for the platform.\n-* Automated building is set up, but may not be running tests.\n-* Landing changes to the `rust-lang/rust` repository's master branch is gated on\n-    platforms **building**. For some platforms only the standard library is\n-    compiled, but for others `rustc` and `cargo` are too.\n+The `std` column in the table below has the following meanings:\n \n-target | std | host | notes\n--------|-----|------|-------\n-`aarch64-apple-darwin` | \u2713 | \u2713 | ARM64 macOS (11.0+, Big Sur+)\n-`aarch64-apple-ios` | \u2713 |  | ARM64 iOS\n-`aarch64-fuchsia` | \u2713 |  | ARM64 Fuchsia\n-`aarch64-linux-android` | \u2713 |  | ARM64 Android\n-`aarch64-pc-windows-msvc` | \u2713 | \u2713 | ARM64 Windows MSVC\n-`aarch64-unknown-linux-musl` | \u2713 | \u2713 | ARM64 Linux with MUSL\n-`aarch64-unknown-none` | * |  | Bare ARM64, hardfloat\n-`aarch64-unknown-none-softfloat` | * |  | Bare ARM64, softfloat\n-`arm-linux-androideabi` | \u2713 |  | ARMv7 Android\n-`arm-unknown-linux-gnueabi` | \u2713 | \u2713 | ARMv6 Linux (kernel 3.2, glibc 2.17)\n-`arm-unknown-linux-gnueabihf` | \u2713 | \u2713 | ARMv6 Linux, hardfloat (kernel 3.2, glibc 2.17)\n-`arm-unknown-linux-musleabi` | \u2713 |  | ARMv6 Linux with MUSL\n-`arm-unknown-linux-musleabihf` | \u2713 |  | ARMv6 Linux with MUSL, hardfloat\n-`armebv7r-none-eabi` | * |  | Bare ARMv7-R, Big Endian\n-`armebv7r-none-eabihf` | * |  | Bare ARMv7-R, Big Endian, hardfloat\n-`armv5te-unknown-linux-gnueabi` | \u2713 |  | ARMv5TE Linux (kernel 4.4, glibc 2.23)\n-`armv5te-unknown-linux-musleabi` | \u2713 |  | ARMv5TE Linux with MUSL\n-`armv7-linux-androideabi` | \u2713 |  | ARMv7a Android\n-`armv7a-none-eabi` | * |  | Bare ARMv7-A\n-`armv7r-none-eabi` | * |  | Bare ARMv7-R\n-`armv7r-none-eabihf` | * |  | Bare ARMv7-R, hardfloat\n-`armv7-unknown-linux-gnueabi` | \u2713 |   | ARMv7 Linux (kernel 4.15, glibc 2.27)\n-`armv7-unknown-linux-gnueabihf` | \u2713 | \u2713 | ARMv7 Linux, hardfloat (kernel 3.2, glibc 2.17)\n-`armv7-unknown-linux-musleabi` | \u2713 |   | ARMv7 Linux, MUSL\n-`armv7-unknown-linux-musleabihf` | \u2713 |  | ARMv7 Linux with MUSL\n-`asmjs-unknown-emscripten` | \u2713 |  | asm.js via Emscripten\n-`i586-pc-windows-msvc` | \u2713 |  | 32-bit Windows w/o SSE\n-`i586-unknown-linux-gnu` | \u2713 |  | 32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)\n-`i586-unknown-linux-musl` | \u2713 |  | 32-bit Linux w/o SSE, MUSL\n-`i686-linux-android` | \u2713 |  | 32-bit x86 Android\n-`i686-unknown-freebsd` | \u2713 |  | 32-bit FreeBSD\n-`i686-unknown-linux-musl` | \u2713 |  | 32-bit Linux with MUSL\n-`mips-unknown-linux-gnu` | \u2713 | \u2713 | MIPS Linux (kernel 4.4, glibc 2.23)\n-`mips-unknown-linux-musl` | \u2713 |  | MIPS Linux with MUSL\n-`mips64-unknown-linux-gnuabi64` | \u2713 | \u2713 | MIPS64 Linux, n64 ABI (kernel 4.4, glibc 2.23)\n-`mips64-unknown-linux-muslabi64` | \u2713 |  | MIPS64 Linux, n64 ABI, MUSL\n-`mips64el-unknown-linux-gnuabi64` | \u2713 | \u2713 | MIPS64 (LE) Linux, n64 ABI (kernel 4.4, glibc 2.23)\n-`mips64el-unknown-linux-muslabi64` | \u2713 |  | MIPS64 (LE) Linux, n64 ABI, MUSL\n-`mipsel-unknown-linux-gnu` | \u2713 | \u2713 | MIPS (LE) Linux (kernel 4.4, glibc 2.23)\n-`mipsel-unknown-linux-musl` | \u2713 |  | MIPS (LE) Linux with MUSL\n-`nvptx64-nvidia-cuda` | \u2713 |  | --emit=asm generates PTX code that [runs on NVIDIA GPUs]\n-`powerpc-unknown-linux-gnu` | \u2713 | \u2713 | PowerPC Linux (kernel 2.6.32, glibc 2.11)\n-`powerpc64-unknown-linux-gnu` | \u2713 | \u2713 | PPC64 Linux (kernel 2.6.32, glibc 2.11)\n-`powerpc64le-unknown-linux-gnu` | \u2713 | \u2713 | PPC64LE Linux (kernel 3.10, glibc 2.17)\n-`riscv32i-unknown-none-elf` | * |  | Bare RISC-V (RV32I ISA)\n-`riscv32imac-unknown-none-elf` | * |  | Bare RISC-V (RV32IMAC ISA)\n-`riscv32imc-unknown-none-elf` | * |  | Bare RISC-V (RV32IMC ISA)\n-`riscv64gc-unknown-linux-gnu` | \u2713 | \u2713 | RISC-V Linux (kernel 4.20, glibc 2.29)\n-`riscv64gc-unknown-none-elf` | * |  | Bare RISC-V (RV64IMAFDC ISA)\n-`riscv64imac-unknown-none-elf` | * |  | Bare RISC-V (RV64IMAC ISA)\n-`s390x-unknown-linux-gnu` | \u2713 | \u2713 | S390x Linux (kernel 2.6.32, glibc 2.11)\n-`sparc64-unknown-linux-gnu` | \u2713 |  | SPARC Linux (kernel 4.4, glibc 2.23)\n-`sparcv9-sun-solaris` | \u2713 |  | SPARC Solaris 10/11, illumos\n-`thumbv6m-none-eabi` | * |  | Bare Cortex-M0, M0+, M1\n-`thumbv7em-none-eabi` | * |  | Bare Cortex-M4, M7\n-`thumbv7em-none-eabihf` | * |  | Bare Cortex-M4F, M7F, FPU, hardfloat\n-`thumbv7m-none-eabi` | * |  | Bare Cortex-M3\n-`thumbv7neon-linux-androideabi` | \u2713 |  | Thumb2-mode ARMv7a Android with NEON\n-`thumbv7neon-unknown-linux-gnueabihf` | \u2713 |  | Thumb2-mode ARMv7a Linux with NEON (kernel 4.4, glibc 2.23)\n-`thumbv8m.base-none-eabi` | * |  | ARMv8-M Baseline\n-`thumbv8m.main-none-eabi` | * |  | ARMv8-M Mainline\n-`thumbv8m.main-none-eabihf` | * |  | ARMv8-M Mainline, hardfloat\n-`wasm32-unknown-emscripten` | \u2713 |  | WebAssembly via Emscripten\n-`wasm32-unknown-unknown` | \u2713 |  | WebAssembly\n-`wasm32-wasi` | \u2713 |  | WebAssembly with WASI\n-`x86_64-apple-ios` | \u2713 |  | 64-bit x86 iOS\n-`x86_64-fortanix-unknown-sgx` | \u2713 |  | [Fortanix ABI] for 64-bit Intel SGX\n-`x86_64-fuchsia` | \u2713 |  | 64-bit Fuchsia\n-`x86_64-linux-android` | \u2713 |  | 64-bit x86 Android\n-`x86_64-pc-solaris` | \u2713 |  | 64-bit Solaris 10/11, illumos\n-`x86_64-unknown-freebsd` | \u2713 | \u2713 | 64-bit FreeBSD\n-`x86_64-unknown-illumos` | \u2713 | \u2713 | illumos\n-`x86_64-unknown-linux-gnux32` | \u2713 |  | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n-`x86_64-unknown-linux-musl` | \u2713 | \u2713 | 64-bit Linux with MUSL\n-`x86_64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/amd64\n-`x86_64-unknown-redox` | \u2713 |  | Redox OS\n+* \u2713 indicates the full standard library is available.\n+* \\* indicates the target only supports [`no_std`] development.\n+\n+[`no_std`]: https://rust-embedded.github.io/book/intro/no-std.html\n+\n+target | std | notes\n+-------|-----|-------\n+`aarch64-apple-ios` | \u2713 | ARM64 iOS\n+`aarch64-fuchsia` | \u2713 | ARM64 Fuchsia\n+`aarch64-linux-android` | \u2713 | ARM64 Android\n+`aarch64-unknown-none-softfloat` | * | Bare ARM64, softfloat\n+`aarch64-unknown-none` | * | Bare ARM64, hardfloat\n+`arm-linux-androideabi` | \u2713 | ARMv7 Android\n+`arm-unknown-linux-musleabi` | \u2713 | ARMv6 Linux with MUSL\n+`arm-unknown-linux-musleabihf` | \u2713 | ARMv6 Linux with MUSL, hardfloat\n+`armebv7r-none-eabi` | * | Bare ARMv7-R, Big Endian\n+`armebv7r-none-eabihf` | * | Bare ARMv7-R, Big Endian, hardfloat\n+`armv5te-unknown-linux-gnueabi` | \u2713 | ARMv5TE Linux (kernel 4.4, glibc 2.23)\n+`armv5te-unknown-linux-musleabi` | \u2713 | ARMv5TE Linux with MUSL\n+`armv7-linux-androideabi` | \u2713 | ARMv7a Android\n+`armv7-unknown-linux-gnueabi` | \u2713 |ARMv7 Linux (kernel 4.15, glibc 2.27)\n+`armv7-unknown-linux-musleabi` | \u2713 |ARMv7 Linux, MUSL\n+`armv7-unknown-linux-musleabihf` | \u2713 | ARMv7 Linux with MUSL\n+`armv7a-none-eabi` | * | Bare ARMv7-A\n+`armv7r-none-eabi` | * | Bare ARMv7-R\n+`armv7r-none-eabihf` | * | Bare ARMv7-R, hardfloat\n+`asmjs-unknown-emscripten` | \u2713 | asm.js via Emscripten\n+`i586-pc-windows-msvc` | \u2713 | 32-bit Windows w/o SSE\n+`i586-unknown-linux-gnu` | \u2713 | 32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)\n+`i586-unknown-linux-musl` | \u2713 | 32-bit Linux w/o SSE, MUSL\n+`i686-linux-android` | \u2713 | 32-bit x86 Android\n+`i686-unknown-freebsd` | \u2713 | 32-bit FreeBSD\n+`i686-unknown-linux-musl` | \u2713 | 32-bit Linux with MUSL\n+`mips-unknown-linux-musl` | \u2713 | MIPS Linux with MUSL\n+`mips64-unknown-linux-muslabi64` | \u2713 | MIPS64 Linux, n64 ABI, MUSL\n+`mips64el-unknown-linux-muslabi64` | \u2713 | MIPS64 (LE) Linux, n64 ABI, MUSL\n+`mipsel-unknown-linux-musl` | \u2713 | MIPS (LE) Linux with MUSL\n+`nvptx64-nvidia-cuda` | \u2713 | --emit=asm generates PTX code that [runs on NVIDIA GPUs]\n+`riscv32i-unknown-none-elf` | * | Bare RISC-V (RV32I ISA)\n+`riscv32imac-unknown-none-elf` | * | Bare RISC-V (RV32IMAC ISA)\n+`riscv32imc-unknown-none-elf` | * | Bare RISC-V (RV32IMC ISA)\n+`riscv64gc-unknown-none-elf` | * | Bare RISC-V (RV64IMAFDC ISA)\n+`riscv64imac-unknown-none-elf` | * | Bare RISC-V (RV64IMAC ISA)\n+`sparc64-unknown-linux-gnu` | \u2713 | SPARC Linux (kernel 4.4, glibc 2.23)\n+`sparcv9-sun-solaris` | \u2713 | SPARC Solaris 10/11, illumos\n+`thumbv6m-none-eabi` | * | Bare Cortex-M0, M0+, M1\n+`thumbv7em-none-eabi` | * | Bare Cortex-M4, M7\n+`thumbv7em-none-eabihf` | * | Bare Cortex-M4F, M7F, FPU, hardfloat\n+`thumbv7m-none-eabi` | * | Bare Cortex-M3\n+`thumbv7neon-linux-androideabi` | \u2713 | Thumb2-mode ARMv7a Android with NEON\n+`thumbv7neon-unknown-linux-gnueabihf` | \u2713 | Thumb2-mode ARMv7a Linux with NEON (kernel 4.4, glibc 2.23)\n+`thumbv8m.base-none-eabi` | * | ARMv8-M Baseline\n+`thumbv8m.main-none-eabi` | * | ARMv8-M Mainline\n+`thumbv8m.main-none-eabihf` | * | ARMv8-M Mainline, hardfloat\n+`wasm32-unknown-emscripten` | \u2713 | WebAssembly via Emscripten\n+`wasm32-unknown-unknown` | \u2713 | WebAssembly\n+`wasm32-wasi` | \u2713 | WebAssembly with WASI\n+`x86_64-apple-ios` | \u2713 | 64-bit x86 iOS\n+`x86_64-fortanix-unknown-sgx` | \u2713 | [Fortanix ABI] for 64-bit Intel SGX\n+`x86_64-fuchsia` | \u2713 | 64-bit Fuchsia\n+`x86_64-linux-android` | \u2713 | 64-bit x86 Android\n+`x86_64-pc-solaris` | \u2713 | 64-bit Solaris 10/11, illumos\n+`x86_64-unknown-linux-gnux32` | \u2713 | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n+`x86_64-unknown-redox` | \u2713 | Redox OS\n \n [Fortanix ABI]: https://edp.fortanix.com/\n \n ## Tier 3\n \n-Tier 3 platforms are those which the Rust codebase has support for, but which\n-are not built or tested automatically, and may not work. Official builds are\n-not available.\n+Tier 3 targets are those which the Rust codebase has support for, but which the\n+Rust project does not build or test automatically, so they may or may not work.\n+Official builds are not available. For the full requirements, see [Tier 3\n+target policy](target-tier-policy.md#tier-3-target-policy) in the Target Tier\n+Policy.\n+\n+The `std` column in the table below has the following meanings:\n+\n+* \u2713 indicates the full standard library is available.\n+* \\* indicates the target only supports [`no_std`] development.\n+* ? indicates the standard library support is unknown or a work-in-progress.\n+\n+[`no_std`]: https://rust-embedded.github.io/book/intro/no-std.html\n+\n+The `host` column indicates whether the codebase includes support for building\n+host tools.\n \n target | std | host | notes\n -------|-----|------|-------\n@@ -163,8 +206,8 @@ target | std | host | notes\n `aarch64-unknown-redox` | ? |  | ARM64 Redox OS\n `aarch64-uwp-windows-msvc` | ? |  |\n `aarch64-wrs-vxworks` | ? |  |\n-`aarch64_be-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (big-endian)\n `aarch64_be-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (big-endian, ILP32 ABI)\n+`aarch64_be-unknown-linux-gnu` | \u2713 | \u2713 | ARM64 Linux (big-endian)\n `armv4t-unknown-linux-gnueabi` | ? |  |\n `armv5te-unknown-linux-uclibceabi` | ? |  | ARMv5TE Linux with uClibc\n `armv6-unknown-freebsd` | \u2713 | \u2713 | ARMv6 FreeBSD\n@@ -175,22 +218,22 @@ target | std | host | notes\n `armv7-wrs-vxworks-eabihf` | ? |  |\n `armv7a-none-eabihf` | * | | ARM Cortex-A, hardfloat\n `armv7s-apple-ios` | \u2713 |  |\n-`avr-unknown-gnu-atmega328` | \u2717 |  | AVR. Requires `-Z build-std=core`\n+`avr-unknown-gnu-atmega328` | * |  | AVR. Requires `-Z build-std=core`\n `hexagon-unknown-linux-musl` | ? |  |\n `i386-apple-ios` | \u2713 |  | 32-bit x86 iOS\n `i686-apple-darwin` | \u2713 | \u2713 | 32-bit macOS (10.7+, Lion+)\n `i686-pc-windows-msvc` | \u2713 |  | 32-bit Windows XP support\n-`i686-unknown-uefi` | * |  | 32-bit UEFI\n `i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n `i686-unknown-netbsd` | \u2713 | \u2713 | NetBSD/i386 with SSE2\n `i686-unknown-openbsd` | \u2713 | \u2713 | 32-bit OpenBSD\n+`i686-unknown-uefi` | * |  | 32-bit UEFI\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n `i686-wrs-vxworks` | ? |  |\n `mips-unknown-linux-uclibc` | \u2713 |  | MIPS Linux with uClibc\n+`mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n `mipsel-unknown-linux-uclibc` | \u2713 |  | MIPS (LE) Linux with uClibc\n `mipsel-unknown-none` | * |  | Bare MIPS (LE) softfloat\n-`mipsel-sony-psp` | * |  | MIPS (LE) Sony PlayStation Portable (PSP)\n `mipsisa32r6-unknown-linux-gnu` | ? |  |\n `mipsisa32r6el-unknown-linux-gnu` | ? |  |\n `mipsisa64r6-unknown-linux-gnuabi64` | ? |  |\n@@ -200,34 +243,34 @@ target | std | host | notes\n `powerpc-unknown-linux-musl` | ? |  |\n `powerpc-unknown-netbsd` | \u2713 | \u2713 |\n `powerpc-unknown-openbsd` | ? |  |\n-`powerpc-wrs-vxworks` | ? |  |\n `powerpc-wrs-vxworks-spe` | ? |  |\n+`powerpc-wrs-vxworks` | ? |  |\n `powerpc64-unknown-freebsd` | \u2713 | \u2713 | PPC64 FreeBSD (ELFv1 and ELFv2)\n `powerpc64-unknown-linux-musl` | ? |  |\n `powerpc64-wrs-vxworks` | ? |  |\n `powerpc64le-unknown-linux-musl` | ? |  |\n-`riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n `riscv32gc-unknown-linux-gnu` |   |   | RISC-V Linux (kernel 5.4, glibc 2.33)\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n+`riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 2.6.32, MUSL)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux\n `sparc64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/sparc64\n `sparc64-unknown-openbsd` | ? |  |\n+`thumbv4t-none-eabi` | * |  | ARMv4T T32\n `thumbv7a-pc-windows-msvc` | ? |  |\n `thumbv7a-uwp-windows-msvc` | \u2713 |  |\n `thumbv7neon-unknown-linux-musleabihf` | ? |  | Thumb2-mode ARMv7a Linux with NEON, MUSL\n-`thumbv4t-none-eabi` | * |  | ARMv4T T32\n `wasm64-unknown-unknown` | * |  | WebAssembly\n `x86_64-apple-ios-macabi` | \u2713 |  | Apple Catalyst on x86_64\n `x86_64-apple-tvos` | * | | x86 64-bit tvOS\n-`x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n-`x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos\n `x86_64-pc-windows-msvc` | \u2713 |  | 64-bit Windows XP support\n+`x86_64-sun-solaris` | ? |  | Deprecated target for 64-bit Solaris 10/11, illumos\n `x86_64-unknown-dragonfly` | \u2713 | \u2713 | 64-bit DragonFlyBSD\n `x86_64-unknown-haiku` | \u2713 | \u2713 | 64-bit Haiku\n `x86_64-unknown-hermit` | ? |  |\n-`x86_64-unknown-none-hermitkernel` | ? |  | HermitCore kernel\n `x86_64-unknown-l4re-uclibc` | ? |  |\n+`x86_64-unknown-none-hermitkernel` | ? |  | HermitCore kernel\n+`x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n `x86_64-unknown-openbsd` | \u2713 | \u2713 | 64-bit OpenBSD\n `x86_64-unknown-uefi` | * |  | 64-bit UEFI\n `x86_64-uwp-windows-gnu` | \u2713 |  |"}, {"sha": "a2cb03519160e4d532b601ce867a4ac96fbc49c5", "filename": "src/doc/rustc/src/target-tier-policy.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftarget-tier-policy.md?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,5 +1,16 @@\n # Target Tier Policy\n \n+## Table of Contents\n+\n+* [General](#general)\n+* [Tier 3 target policy](#tier-3-target-policy)\n+* [Tier 2 target policy](#tier-2-target-policy)\n+  * [Tier 2 with host tools](#tier-2-with-host-tools)\n+* [Tier 1 target policy](#tier-1-target-policy)\n+  * [Tier 1 with host tools](#tier-1-with-host-tools)\n+\n+## General\n+\n Rust provides three tiers of target support:\n \n - Rust provides no guarantees about tier 3 targets; they exist in the codebase,"}, {"sha": "f0ecb6871b1b5696308920637b0ab674590f5a4f", "filename": "src/doc/unstable-book/src/compiler-flags/source-based-code-coverage.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsource-based-code-coverage.md?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -200,7 +200,7 @@ running 31 tests\n test result: ok. 31 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n ```\n \n-You should have one ore more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n+You should have one or more `.profraw` files now, one for each test binary. Run the `profdata` tool to merge them:\n \n ```shell\n $ cargo profdata -- merge \\"}, {"sha": "33cb11e539bf2d89f8d8e63633d89b697723bca0", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -4,6 +4,7 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::lazy::SyncOnceCell as OnceCell;\n+use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n use std::{slice, vec};\n@@ -90,6 +91,58 @@ impl ExternalCrate {\n         tcx.crate_name(self.crate_num)\n     }\n \n+    crate fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n+        match self.src(tcx) {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        }\n+    }\n+\n+    /// Attempts to find where an external crate is located, given that we're\n+    /// rendering in to the specified source destination.\n+    crate fn location(\n+        &self,\n+        extern_url: Option<&str>,\n+        dst: &std::path::Path,\n+        tcx: TyCtxt<'_>,\n+    ) -> ExternalLocation {\n+        use ExternalLocation::*;\n+\n+        fn to_remote(url: impl ToString) -> ExternalLocation {\n+            let mut url = url.to_string();\n+            if !url.ends_with('/') {\n+                url.push('/');\n+            }\n+            Remote(url)\n+        }\n+\n+        // See if there's documentation generated into the local directory\n+        // WARNING: since rustdoc creates these directories as it generates documentation, this check is only accurate before rendering starts.\n+        // Make sure to call `location()` by that time.\n+        let local_location = dst.join(&*self.name(tcx).as_str());\n+        if local_location.is_dir() {\n+            return Local;\n+        }\n+\n+        if let Some(url) = extern_url {\n+            return to_remote(url);\n+        }\n+\n+        // Failing that, see if there's an attribute specifying where to find this\n+        // external crate\n+        let did = DefId { krate: self.crate_num, index: CRATE_DEF_INDEX };\n+        tcx.get_attrs(did)\n+            .lists(sym::doc)\n+            .filter(|a| a.has_name(sym::html_root_url))\n+            .filter_map(|a| a.value_str())\n+            .map(to_remote)\n+            .next()\n+            .unwrap_or(Unknown) // Well, at least we tried.\n+    }\n+\n     crate fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n         let root = self.def_id();\n \n@@ -381,7 +434,7 @@ impl Item {\n                         let relative_to = &cx.current;\n                         if let Some(ref fragment) = *fragment {\n                             let url = match cx.cache().extern_locations.get(&self.def_id.krate) {\n-                                Some(&(_, _, ExternalLocation::Local)) => {\n+                                Some(ExternalLocation::Local) => {\n                                     if relative_to[0] == \"std\" {\n                                         let depth = relative_to.len() - 1;\n                                         \"../\".repeat(depth)\n@@ -390,10 +443,10 @@ impl Item {\n                                         format!(\"{}std/\", \"../\".repeat(depth))\n                                     }\n                                 }\n-                                Some(&(_, _, ExternalLocation::Remote(ref s))) => {\n+                                Some(ExternalLocation::Remote(ref s)) => {\n                                     format!(\"{}/std/\", s.trim_end_matches('/'))\n                                 }\n-                                Some(&(_, _, ExternalLocation::Unknown)) | None => format!(\n+                                Some(ExternalLocation::Unknown) | None => format!(\n                                     \"https://doc.rust-lang.org/{}/std/\",\n                                     crate::doc_rust_lang_org_channel(),\n                                 ),"}, {"sha": "8723e47586ee4600e4ece32f573410dcbf7320c4", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,21 +1,19 @@\n use std::collections::BTreeMap;\n use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::source_map::FileName;\n use rustc_span::symbol::sym;\n-use rustc_span::Symbol;\n \n use crate::clean::{self, GetDefId};\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n use crate::html::markdown::short_markdown_summary;\n-use crate::html::render::cache::{extern_location, get_index_search_type, ExternalLocation};\n+use crate::html::render::cache::{get_index_search_type, ExternalLocation};\n use crate::html::render::IndexItem;\n \n /// This cache is used to store information about the [`clean::Crate`] being\n@@ -72,7 +70,7 @@ crate struct Cache {\n     crate implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n-    crate extern_locations: FxHashMap<CrateNum, (Symbol, PathBuf, ExternalLocation)>,\n+    crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n \n     /// Cache of where documentation for primitives can be found.\n     crate primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n@@ -155,21 +153,10 @@ impl Cache {\n         // Cache where all our extern crates are located\n         // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n         for &(n, ref e) in &krate.externs {\n-            let src_root = match e.src(tcx) {\n-                FileName::Real(ref p) => match p.local_path().parent() {\n-                    Some(p) => p.to_path_buf(),\n-                    None => PathBuf::new(),\n-                },\n-                _ => PathBuf::new(),\n-            };\n             let name = e.name(tcx);\n             let extern_url = extern_html_root_urls.get(&*name.as_str()).map(|u| &**u);\n             let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-            self.extern_locations.insert(\n-                n,\n-                (name, src_root, extern_location(e, extern_url, tcx.get_attrs(did), &dst, tcx)),\n-            );\n-\n+            self.extern_locations.insert(n, e.location(extern_url, &dst, tcx));\n             self.external_paths.insert(did, (vec![name.to_string()], ItemType::Module));\n         }\n "}, {"sha": "f211a5acf5ea58793aba2d9ea465d0d8394c5caf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, PrimitiveType};\n+use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, PrimitiveType};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n use crate::html::render::cache::ExternalLocation;\n@@ -465,14 +465,14 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Option<(String, ItemType, Vec<Str\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., ExternalLocation::Remote(ref s)) => {\n+                    ExternalLocation::Remote(ref s) => {\n                         let s = s.trim_end_matches('/');\n                         let mut s = vec![&s[..]];\n                         s.extend(module_fqp[..].iter().map(String::as_str));\n                         s\n                     }\n-                    (.., ExternalLocation::Local) => href_relative_parts(module_fqp, relative_to),\n-                    (.., ExternalLocation::Unknown) => return None,\n+                    ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n+                    ExternalLocation::Unknown => return None,\n                 },\n             )\n         }\n@@ -578,20 +578,22 @@ fn primitive_link(\n             Some(&def_id) => {\n                 let cname_str;\n                 let loc = match m.extern_locations[&def_id.krate] {\n-                    (ref cname, _, ExternalLocation::Remote(ref s)) => {\n-                        cname_str = cname.as_str();\n+                    ExternalLocation::Remote(ref s) => {\n+                        cname_str =\n+                            ExternalCrate { crate_num: def_id.krate }.name(cx.tcx()).as_str();\n                         Some(vec![s.trim_end_matches('/'), &cname_str[..]])\n                     }\n-                    (ref cname, _, ExternalLocation::Local) => {\n-                        cname_str = cname.as_str();\n+                    ExternalLocation::Local => {\n+                        cname_str =\n+                            ExternalCrate { crate_num: def_id.krate }.name(cx.tcx()).as_str();\n                         Some(if cx.current.first().map(|x| &x[..]) == Some(&cname_str[..]) {\n                             iter::repeat(\"..\").take(cx.current.len() - 1).collect()\n                         } else {\n                             let cname = iter::once(&cname_str[..]);\n                             iter::repeat(\"..\").take(cx.current.len()).chain(cname).collect()\n                         })\n                     }\n-                    (.., ExternalLocation::Unknown) => None,\n+                    ExternalLocation::Unknown => None,\n                 };\n                 if let Some(loc) = loc {\n                     write!("}, {"sha": "27a8065afb6d2e1c1c2961f26c945a4af98b463d", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 45, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1,15 +1,13 @@\n use std::collections::BTreeMap;\n-use std::path::Path;\n \n-use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{\n-    AttributesExt, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n+    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -26,47 +24,6 @@ crate enum ExternalLocation {\n     Unknown,\n }\n \n-/// Attempts to find where an external crate is located, given that we're\n-/// rendering in to the specified source destination.\n-crate fn extern_location(\n-    e: &clean::ExternalCrate,\n-    extern_url: Option<&str>,\n-    ast_attrs: &[ast::Attribute],\n-    dst: &Path,\n-    tcx: TyCtxt<'_>,\n-) -> ExternalLocation {\n-    use ExternalLocation::*;\n-    // See if there's documentation generated into the local directory\n-    let local_location = dst.join(&*e.name(tcx).as_str());\n-    if local_location.is_dir() {\n-        return Local;\n-    }\n-\n-    if let Some(url) = extern_url {\n-        let mut url = url.to_string();\n-        if !url.ends_with('/') {\n-            url.push('/');\n-        }\n-        return Remote(url);\n-    }\n-\n-    // Failing that, see if there's an attribute specifying where to find this\n-    // external crate\n-    ast_attrs\n-        .lists(sym::doc)\n-        .filter(|a| a.has_name(sym::html_root_url))\n-        .filter_map(|a| a.value_str())\n-        .map(|url| {\n-            let mut url = url.to_string();\n-            if !url.ends_with('/') {\n-                url.push('/')\n-            }\n-            Remote(url)\n-        })\n-        .next()\n-        .unwrap_or(Unknown) // Well, at least we tried.\n-}\n-\n /// Builds the search index from the collected metadata\n crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n     let mut defid_to_pathid = FxHashMap::default();"}, {"sha": "293c0a40fa79966712e3563d7f5c216905f14c5b", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -18,7 +18,7 @@ use super::print_item::{full_path, item_path, print_item};\n use super::write_shared::write_shared;\n use super::{print_sidebar, settings, AllTypes, NameDoc, StylePath, BASIC_KEYWORDS};\n \n-use crate::clean;\n+use crate::clean::{self, ExternalCrate};\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;\n@@ -304,12 +304,16 @@ impl<'tcx> Context<'tcx> {\n             }\n         } else {\n             let (krate, src_root) = match *self.cache.extern_locations.get(&cnum)? {\n-                (name, ref src, ExternalLocation::Local) => (name, src),\n-                (name, ref src, ExternalLocation::Remote(ref s)) => {\n+                ExternalLocation::Local => {\n+                    let e = ExternalCrate { crate_num: cnum };\n+                    (e.name(self.tcx()), e.src_root(self.tcx()))\n+                }\n+                ExternalLocation::Remote(ref s) => {\n                     root = s.to_string();\n-                    (name, src)\n+                    let e = ExternalCrate { crate_num: cnum };\n+                    (e.name(self.tcx()), e.src_root(self.tcx()))\n                 }\n-                (_, _, ExternalLocation::Unknown) => return None,\n+                ExternalLocation::Unknown => return None,\n             };\n \n             sources::clean_path(&src_root, file, false, |component| {"}, {"sha": "e81eaca8f0e40ae4027c882b0eda19e45bfc918c", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1490,27 +1490,42 @@ function hideThemeButtonState() {\n     searchState.setup();\n }());\n \n-function copy_path(but) {\n-    var parent = but.parentElement;\n-    var path = [];\n+(function () {\n+    var reset_button_timeout = null;\n \n-    onEach(parent.childNodes, function(child) {\n-        if (child.tagName === 'A') {\n-            path.push(child.textContent);\n-        }\n-    });\n+    window.copy_path = function(but) {\n+        var parent = but.parentElement;\n+        var path = [];\n \n-    var el = document.createElement('textarea');\n-    el.value = 'use ' + path.join('::') + ';';\n-    el.setAttribute('readonly', '');\n-    // To not make it appear on the screen.\n-    el.style.position = 'absolute';\n-    el.style.left = '-9999px';\n+        onEach(parent.childNodes, function(child) {\n+            if (child.tagName === 'A') {\n+                path.push(child.textContent);\n+            }\n+        });\n \n-    document.body.appendChild(el);\n-    el.select();\n-    document.execCommand('copy');\n-    document.body.removeChild(el);\n+        var el = document.createElement('textarea');\n+        el.value = 'use ' + path.join('::') + ';';\n+        el.setAttribute('readonly', '');\n+        // To not make it appear on the screen.\n+        el.style.position = 'absolute';\n+        el.style.left = '-9999px';\n \n-    but.textContent = '\u2713';\n-}\n+        document.body.appendChild(el);\n+        el.select();\n+        document.execCommand('copy');\n+        document.body.removeChild(el);\n+\n+        but.textContent = '\u2713';\n+\n+        if (reset_button_timeout !== null) {\n+            window.clearTimeout(reset_button_timeout);\n+        }\n+\n+        function reset_button() {\n+            but.textContent = '\u2398';\n+            reset_button_timeout = null;\n+        }\n+\n+        reset_button_timeout = window.setTimeout(reset_button, 1000);\n+    };\n+}());"}, {"sha": "ae4d1be3ec2b8a96c16cc97817c2c23f9fe5af06", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed59d669c5ca3c0e9c39dcb1f6510b5876ede64/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -17,7 +17,7 @@ use rustc_session::Session;\n \n use rustdoc_json_types as types;\n \n-use crate::clean;\n+use crate::clean::{self, ExternalCrate};\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -218,12 +218,13 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .cache\n                 .extern_locations\n                 .iter()\n-                .map(|(k, v)| {\n+                .map(|(crate_num, external_location)| {\n+                    let e = ExternalCrate { crate_num: *crate_num };\n                     (\n-                        k.as_u32(),\n+                        crate_num.as_u32(),\n                         types::ExternalCrate {\n-                            name: v.0.to_string(),\n-                            html_root_url: match &v.2 {\n+                            name: e.name(self.tcx).to_string(),\n+                            html_root_url: match external_location {\n                                 ExternalLocation::Remote(s) => Some(s.clone()),\n                                 _ => None,\n                             },"}, {"sha": "f3e13226d6d17a2bc5f325303494b43a45f53b7f", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=fed59d669c5ca3c0e9c39dcb1f6510b5876ede64", "patch": "@@ -1 +1 @@\n-Subproject commit 4369396ce7d270972955d876eaa4954bea56bcd9\n+Subproject commit f3e13226d6d17a2bc5f325303494b43a45f53b7f"}]}