{"sha": "3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNzBkMGYzMDgwMjQ3MmVlNDBjOWZjMzdiOGVhZDY5ZTEzN2ExYTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-30T12:10:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-30T12:10:21Z"}, "message": "Merge #5136\n\n5136: Split namespace maps in `ItemScope` r=jonas-schievink a=jonas-schievink\n\nReduces memory usage of the CrateDefMap query by ~130 MB (50%) on r-a.\r\n\r\nI was also looking into handling glob imports more efficiently (storing scope chains instead of always duplicating everything into the glob-importing module's scope), but it seems that this already gives the most significant wins.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "f64b342534df07401f86435ddfd578f7ceca0c72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f64b342534df07401f86435ddfd578f7ceca0c72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe+yutCRBK7hj4Ov3rIwAAdHIIAHhvrbg8iGT5XwOyJJoRdJeY\n384bmA5z73iY0xfK47DyRwFT3f46xNnWdZEKSjnKI6nTEzlho+UtOfD6oDs6K/D6\nNM4GDl0ZReh020Jaa8t6FrSuwkq/ZrZnDvwgtnQnNgbJX7fGnRtRIddCq2kvTVCf\nS6nFXV+lKcBbTucWyhv+VOQoPvsEoU+CTeE+sX6Blk09V9Du5vE+j2uYSGj+oDhS\nhG+Fi1O1yFV+K9jzH4fTF0Jz3b8lKDpWMHdVMRJglAkBD0t74rraCGPQuuwl/9Pf\nPc82Z8gcxzkksARLj9nWhdx8iGoKfyt2wK8ecdYuZytIKOoC44tkUxpEnU9rNZc=\n=8JXo\n-----END PGP SIGNATURE-----\n", "payload": "tree f64b342534df07401f86435ddfd578f7ceca0c72\nparent 6a73d544f4117b942b300afb8bda98216fc92356\nparent 7c9b3d154c4d826d4623891c69a60d1a69031e5b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593519021 +0000\ncommitter GitHub <noreply@github.com> 1593519021 +0000\n\nMerge #5136\n\n5136: Split namespace maps in `ItemScope` r=jonas-schievink a=jonas-schievink\n\nReduces memory usage of the CrateDefMap query by ~130 MB (50%) on r-a.\r\n\r\nI was also looking into handling glob imports more efficiently (storing scope chains instead of always duplicating everything into the glob-importing module's scope), but it seems that this already gives the most significant wins.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "html_url": "https://github.com/rust-lang/rust/commit/3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e70d0f30802472ee40c9fc37b8ead69e137a1a1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a73d544f4117b942b300afb8bda98216fc92356", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a73d544f4117b942b300afb8bda98216fc92356", "html_url": "https://github.com/rust-lang/rust/commit/6a73d544f4117b942b300afb8bda98216fc92356"}, {"sha": "7c9b3d154c4d826d4623891c69a60d1a69031e5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9b3d154c4d826d4623891c69a60d1a69031e5b", "html_url": "https://github.com/rust-lang/rust/commit/7c9b3d154c4d826d4623891c69a60d1a69031e5b"}], "stats": {"total": 117, "additions": 73, "deletions": 44}, "files": [{"sha": "beeb9855954c28bc69d8dd62fc74a3f89896932f", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 70, "deletions": 39, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3e70d0f30802472ee40c9fc37b8ead69e137a1a1/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e70d0f30802472ee40c9fc37b8ead69e137a1a1/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "patch": "@@ -1,6 +1,8 @@\n //! Describes items defined or visible (ie, imported) in a certain scope.\n //! This is shared between modules and blocks.\n \n+use std::collections::hash_map::Entry;\n+\n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n use ra_db::CrateId;\n@@ -27,7 +29,11 @@ pub struct PerNsGlobImports {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ItemScope {\n-    visible: FxHashMap<Name, PerNs>,\n+    types: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    values: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    macros: FxHashMap<Name, (MacroDefId, Visibility)>,\n+    unresolved: FxHashSet<Name>,\n+\n     defs: Vec<ModuleDefId>,\n     impls: Vec<ImplId>,\n     /// Macros visible in current module in legacy textual scope\n@@ -65,14 +71,16 @@ pub(crate) enum BuiltinShadowMode {\n /// Other methods will only resolve values, types and module scoped macros only.\n impl ItemScope {\n     pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        //FIXME: shadowing\n-        self.visible.iter().map(|(n, def)| (n, *def))\n-    }\n-\n-    pub fn entries_without_primitives<'a>(\n-        &'a self,\n-    ) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(n, def)| (n, *def))\n+        // FIXME: shadowing\n+        let keys: FxHashSet<_> = self\n+            .types\n+            .keys()\n+            .chain(self.values.keys())\n+            .chain(self.macros.keys())\n+            .chain(self.unresolved.iter())\n+            .collect();\n+\n+        keys.into_iter().map(move |name| (name, self.get(name)))\n     }\n \n     pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n@@ -91,7 +99,7 @@ impl ItemScope {\n \n     /// Iterate over all module scoped macros\n     pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.visible.iter().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n+        self.entries().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n     }\n \n     /// Iterate over all legacy textual scoped macros visible at the end of the module\n@@ -101,21 +109,25 @@ impl ItemScope {\n \n     /// Get a name from current module scope, legacy macros are not included\n     pub(crate) fn get(&self, name: &Name) -> PerNs {\n-        self.visible.get(name).copied().unwrap_or_else(PerNs::none)\n+        PerNs {\n+            types: self.types.get(name).copied(),\n+            values: self.values.get(name).copied(),\n+            macros: self.macros.get(name).copied(),\n+        }\n     }\n \n     pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n-        for (name, per_ns) in &self.visible {\n-            if let Some(vis) = item.match_with(*per_ns) {\n+        for (name, per_ns) in self.entries() {\n+            if let Some(vis) = item.match_with(per_ns) {\n                 return Some((name, vis));\n             }\n         }\n         None\n     }\n \n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.visible.values().filter_map(|def| match def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n+        self.types.values().filter_map(|(def, _)| match def {\n+            ModuleDefId::TraitId(t) => Some(*t),\n             _ => None,\n         })\n     }\n@@ -138,21 +150,30 @@ impl ItemScope {\n \n     pub(crate) fn push_res(&mut self, name: Name, def: PerNs) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(name).or_default();\n \n-        if existing.types.is_none() && def.types.is_some() {\n-            existing.types = def.types;\n-            changed = true;\n+        if let Some(types) = def.types {\n+            self.types.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                types\n+            });\n         }\n-\n-        if existing.values.is_none() && def.values.is_some() {\n-            existing.values = def.values;\n-            changed = true;\n+        if let Some(values) = def.values {\n+            self.values.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                values\n+            });\n+        }\n+        if let Some(macros) = def.macros {\n+            self.macros.entry(name.clone()).or_insert_with(|| {\n+                changed = true;\n+                macros\n+            });\n         }\n \n-        if existing.macros.is_none() && def.macros.is_some() {\n-            existing.macros = def.macros;\n-            changed = true;\n+        if def.is_none() {\n+            if self.unresolved.insert(name) {\n+                changed = true;\n+            }\n         }\n \n         changed\n@@ -166,17 +187,17 @@ impl ItemScope {\n         def_import_type: ImportType,\n     ) -> bool {\n         let mut changed = false;\n-        let existing = self.visible.entry(lookup.1.clone()).or_default();\n \n         macro_rules! check_changed {\n             (\n                 $changed:ident,\n-                ( $existing:ident / $def:ident ) . $field:ident,\n+                ( $this:ident / $def:ident ) . $field:ident,\n                 $glob_imports:ident [ $lookup:ident ],\n                 $def_import_type:ident\n-            ) => {\n-                match ($existing.$field, $def.$field) {\n-                    (None, Some(_)) => {\n+            ) => {{\n+                let existing = $this.$field.entry($lookup.1.clone());\n+                match (existing, $def.$field) {\n+                    (Entry::Vacant(entry), Some(_)) => {\n                         match $def_import_type {\n                             ImportType::Glob => {\n                                 $glob_imports.$field.insert($lookup.clone());\n@@ -186,32 +207,42 @@ impl ItemScope {\n                             }\n                         }\n \n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n-                    (Some(_), Some(_))\n+                    (Entry::Occupied(mut entry), Some(_))\n                         if $glob_imports.$field.contains(&$lookup)\n                             && matches!($def_import_type, ImportType::Named) =>\n                     {\n                         mark::hit!(import_shadowed);\n                         $glob_imports.$field.remove(&$lookup);\n-                        $existing.$field = $def.$field;\n+                        if let Some(fld) = $def.$field {\n+                            entry.insert(fld);\n+                        }\n                         $changed = true;\n                     }\n                     _ => {}\n                 }\n-            };\n+            }};\n         }\n \n-        check_changed!(changed, (existing / def).types, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).values, glob_imports[lookup], def_import_type);\n-        check_changed!(changed, (existing / def).macros, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).types, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).values, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).macros, glob_imports[lookup], def_import_type);\n+\n+        if def.is_none() {\n+            if self.unresolved.insert(lookup.1) {\n+                changed = true;\n+            }\n+        }\n \n         changed\n     }\n \n     pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Name, PerNs)> + 'a {\n-        self.visible.iter().map(|(name, res)| (name.clone(), *res))\n+        self.entries().map(|(name, res)| (name.clone(), res))\n     }\n \n     pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {"}, {"sha": "0bf51eb7b839b6f9929c71b7e595d96cb2dfbc8a", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e70d0f30802472ee40c9fc37b8ead69e137a1a1/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e70d0f30802472ee40c9fc37b8ead69e137a1a1/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=3e70d0f30802472ee40c9fc37b8ead69e137a1a1", "patch": "@@ -511,11 +511,9 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::LocalItemsScope(body) => {\n-                body.item_scope.entries_without_primitives().for_each(|(name, def)| {\n-                    f(name.clone(), ScopeDef::PerNs(def));\n-                })\n-            }\n+            Scope::LocalItemsScope(body) => body.item_scope.entries().for_each(|(name, def)| {\n+                f(name.clone(), ScopeDef::PerNs(def));\n+            }),\n             Scope::GenericParams { params, def } => {\n                 for (local_id, param) in params.types.iter() {\n                     if let Some(name) = &param.name {"}]}