{"sha": "f3333d5e1058e6e36c3754ae29ce6c708b35f082", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzMzZDVlMTA1OGU2ZTM2YzM3NTRhZTI5Y2U2YzcwOGIzNWYwODI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-02T03:38:05Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-03T14:34:04Z"}, "message": "regex: fix fallout", "tree": {"sha": "ba3e6f9dc1984a5fbe4bce1bc200be40e5c2145b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3e6f9dc1984a5fbe4bce1bc200be40e5c2145b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3333d5e1058e6e36c3754ae29ce6c708b35f082", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3333d5e1058e6e36c3754ae29ce6c708b35f082", "html_url": "https://github.com/rust-lang/rust/commit/f3333d5e1058e6e36c3754ae29ce6c708b35f082", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3333d5e1058e6e36c3754ae29ce6c708b35f082/comments", "author": null, "committer": null, "parents": [{"sha": "17cf5e8104691cc6c15e4ea2e284c52a7b6760da", "url": "https://api.github.com/repos/rust-lang/rust/commits/17cf5e8104691cc6c15e4ea2e284c52a7b6760da", "html_url": "https://github.com/rust-lang/rust/commit/17cf5e8104691cc6c15e4ea2e284c52a7b6760da"}], "stats": {"total": 29, "additions": 22, "deletions": 7}, "files": [{"sha": "c546477ee0152f1a9002d5941e58b1e9de161bdd", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3333d5e1058e6e36c3754ae29ce6c708b35f082/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3333d5e1058e6e36c3754ae29ce6c708b35f082/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=f3333d5e1058e6e36c3754ae29ce6c708b35f082", "patch": "@@ -373,6 +373,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "69c58eebd56d05ea5023e2bf69576d6f247ad90b", "filename": "src/libregex/re.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f3333d5e1058e6e36c3754ae29ce6c708b35f082/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3333d5e1058e6e36c3754ae29ce6c708b35f082/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=f3333d5e1058e6e36c3754ae29ce6c708b35f082", "patch": "@@ -546,7 +546,9 @@ pub enum NamesIter<'a> {\n     NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n }\n \n-impl<'a> Iterator<Option<String>> for NamesIter<'a> {\n+impl<'a> Iterator for NamesIter<'a> {\n+    type Item = Option<String>;\n+\n     fn next(&mut self) -> Option<Option<String>> {\n         match *self {\n             NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_string())),\n@@ -603,7 +605,9 @@ pub struct RegexSplits<'r, 't> {\n     last: uint,\n }\n \n-impl<'r, 't> Iterator<&'t str> for RegexSplits<'r, 't> {\n+impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         let text = self.finder.search;\n         match self.finder.next() {\n@@ -638,7 +642,9 @@ pub struct RegexSplitsN<'r, 't> {\n     limit: uint,\n }\n \n-impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n+impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         let text = self.splits.finder.search;\n         if self.cur >= self.limit {\n@@ -801,7 +807,9 @@ pub struct SubCaptures<'t> {\n     caps: &'t Captures<'t>,\n }\n \n-impl<'t> Iterator<&'t str> for SubCaptures<'t> {\n+impl<'t> Iterator for SubCaptures<'t> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         if self.idx < self.caps.len() {\n             self.idx += 1;\n@@ -824,7 +832,9 @@ pub struct SubCapturesPos<'t> {\n     caps: &'t Captures<'t>,\n }\n \n-impl<'t> Iterator<Option<(uint, uint)>> for SubCapturesPos<'t> {\n+impl<'t> Iterator for SubCapturesPos<'t> {\n+    type Item = Option<(uint, uint)>;\n+\n     fn next(&mut self) -> Option<Option<(uint, uint)>> {\n         if self.idx < self.caps.len() {\n             self.idx += 1;\n@@ -850,7 +860,9 @@ pub struct FindCaptures<'r, 't> {\n     last_end: uint,\n }\n \n-impl<'r, 't> Iterator<Captures<'t>> for FindCaptures<'r, 't> {\n+impl<'r, 't> Iterator for FindCaptures<'r, 't> {\n+    type Item = Captures<'t>;\n+\n     fn next(&mut self) -> Option<Captures<'t>> {\n         if self.last_end > self.search.len() {\n             return None\n@@ -893,7 +905,9 @@ pub struct FindMatches<'r, 't> {\n     last_end: uint,\n }\n \n-impl<'r, 't> Iterator<(uint, uint)> for FindMatches<'r, 't> {\n+impl<'r, 't> Iterator for FindMatches<'r, 't> {\n+    type Item = (uint, uint);\n+\n     fn next(&mut self) -> Option<(uint, uint)> {\n         if self.last_end > self.search.len() {\n             return None"}]}