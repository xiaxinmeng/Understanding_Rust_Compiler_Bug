{"sha": "e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNDcxY2Y0MWY2Yjg4ZjZkZGM5MTI3OGY1YTBhOTc1YTI3YjNkZTA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-29T21:52:36Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:33:04Z"}, "message": "Introduce another way to compute the length, to fix position codegen regression", "tree": {"sha": "f8b717bbd84a55fd403b0f4a2753d5e126e2fc39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8b717bbd84a55fd403b0f4a2753d5e126e2fc39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "html_url": "https://github.com/rust-lang/rust/commit/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0a82d9314083cad0c985c8f5f752749c9ae96ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0a82d9314083cad0c985c8f5f752749c9ae96ca", "html_url": "https://github.com/rust-lang/rust/commit/b0a82d9314083cad0c985c8f5f752749c9ae96ca"}], "stats": {"total": 29, "additions": 21, "deletions": 8}, "files": [{"sha": "32d1eafae7dcd85d13bbb096b79d604c846f477d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1471cf41f6b88f6ddc91278f5a0a975a27b3de0/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=e1471cf41f6b88f6ddc91278f5a0a975a27b3de0", "patch": "@@ -2359,6 +2359,22 @@ macro_rules! len {\n         }\n     }}\n }\n+// To get rid of some bounds checks (see `position`), for some reason it\n+// makes a difference to compute the length in this way.\n+// (Tested by `codegen/slice-position-bounds-check`.)\n+macro_rules! len2 {\n+    ($self: ident) => {{\n+        let start = $self.ptr;\n+        let diff = ($self.end as usize).wrapping_sub(start as usize);\n+        let size = size_from_ptr(start);\n+        if size == 0 {\n+            diff\n+        } else {\n+            // Using division instead of `offset_from` helps LLVM remove bounds checks\n+            diff / size\n+        }\n+    }}\n+}\n \n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n@@ -2367,7 +2383,7 @@ macro_rules! iterator {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, len!(self)) }\n+                unsafe { from_raw_parts(self.ptr, len2!(self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -2510,9 +2526,8 @@ macro_rules! iterator {\n                 Self: Sized,\n                 P: FnMut(Self::Item) -> bool,\n             {\n-                // The addition might panic on overflow\n-                // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = self.make_slice().len();\n+                // The addition might panic on overflow.\n+                let n = len2!(self);\n                 self.try_fold(0, move |i, x| {\n                     if predicate(x) { Err(i) }\n                     else { Ok(i + 1) }\n@@ -2529,9 +2544,7 @@ macro_rules! iterator {\n                 Self: Sized + ExactSizeIterator + DoubleEndedIterator\n             {\n                 // No need for an overflow check here, because `ExactSizeIterator`\n-                // implies that the number of elements fits into a `usize`.\n-                // Use the len of the slice to hint optimizer to remove result index bounds check.\n-                let n = self.make_slice().len();\n+                let n = len2!(self);\n                 self.try_rfold(n, move |i, x| {\n                     let i = i - 1;\n                     if predicate(x) { Err(i) }\n@@ -2776,7 +2789,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, len!(self)) }\n+        unsafe { from_raw_parts_mut(self.ptr, len2!(self)) }\n     }\n }\n "}]}