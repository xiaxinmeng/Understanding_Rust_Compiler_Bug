{"sha": "e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMGMxYzNmYmY4ZjcwMzM2ZDk4NWIyYjczZTViMGY0NWYzYjk1ZjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-07T22:39:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-08T20:47:35Z"}, "message": "Simplify highlighting infra\n\nThis also fixes the killer whale bug", "tree": {"sha": "a3cdc2d2f667ab5a122758152eb338a654d387cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3cdc2d2f667ab5a122758152eb338a654d387cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "html_url": "https://github.com/rust-lang/rust/commit/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "981a0d708ec352969f9ca075a3e0e50c6da48197", "url": "https://api.github.com/repos/rust-lang/rust/commits/981a0d708ec352969f9ca075a3e0e50c6da48197", "html_url": "https://github.com/rust-lang/rust/commit/981a0d708ec352969f9ca075a3e0e50c6da48197"}], "stats": {"total": 563, "additions": 287, "deletions": 276}, "files": [{"sha": "2eb63a0b7df08f3d5ae1922a68640efeb63226bd", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 8, "deletions": 186, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -1,3 +1,6 @@\n+mod highlights;\n+mod injector;\n+\n mod format;\n mod html;\n mod injection;\n@@ -69,9 +72,7 @@ pub(crate) fn highlight(\n     };\n \n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n-    // We use a stack for the DFS traversal below.\n-    // When we leave a node, the we use it to flatten the highlighted ranges.\n-    let mut stack = HighlightedRangeStack::new();\n+    let mut stack = highlights::Highlights::new(range_to_highlight);\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n     let mut current_macro_rules: Option<ast::MacroRules> = None;\n@@ -82,14 +83,8 @@ pub(crate) fn highlight(\n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n     for event in root.preorder_with_tokens() {\n-        match &event {\n-            WalkEvent::Enter(_) => stack.push(),\n-            WalkEvent::Leave(_) => stack.pop(),\n-        };\n-\n         let event_range = match &event {\n-            WalkEvent::Enter(it) => it.text_range(),\n-            WalkEvent::Leave(it) => it.text_range(),\n+            WalkEvent::Enter(it) | WalkEvent::Leave(it) => it.text_range(),\n         };\n \n         // Element outside of the viewport, no need to highlight\n@@ -138,15 +133,8 @@ pub(crate) fn highlight(\n                 if ast::Attr::can_cast(node.kind()) {\n                     inside_attribute = false\n                 }\n-                if let Some((doctest, range_mapping, new_comments)) =\n-                    injection::extract_doc_comments(node)\n-                {\n-                    injection::highlight_doc_comment(\n-                        doctest,\n-                        range_mapping,\n-                        new_comments,\n-                        &mut stack,\n-                    );\n+                if let Some((new_comments, inj)) = injection::extract_doc_comments(node) {\n+                    injection::highlight_doc_comment(new_comments, inj, &mut stack);\n                 }\n             }\n             WalkEvent::Enter(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n@@ -217,7 +205,6 @@ pub(crate) fn highlight(\n                 format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n                 // Highlight escape sequences\n                 if let Some(char_ranges) = string.char_ranges() {\n-                    stack.push();\n                     for (piece_range, _) in char_ranges.iter().filter(|(_, char)| char.is_ok()) {\n                         if string.text()[piece_range.start().into()..].starts_with('\\\\') {\n                             stack.add(HighlightedRange {\n@@ -227,177 +214,12 @@ pub(crate) fn highlight(\n                             });\n                         }\n                     }\n-                    stack.pop_and_inject(None);\n-                }\n-            }\n-        }\n-    }\n-\n-    stack.flattened()\n-}\n-\n-#[derive(Debug)]\n-struct HighlightedRangeStack {\n-    stack: Vec<Vec<HighlightedRange>>,\n-}\n-\n-/// We use a stack to implement the flattening logic for the highlighted\n-/// syntax ranges.\n-impl HighlightedRangeStack {\n-    fn new() -> Self {\n-        Self { stack: vec![Vec::new()] }\n-    }\n-\n-    fn push(&mut self) {\n-        self.stack.push(Vec::new());\n-    }\n-\n-    /// Flattens the highlighted ranges.\n-    ///\n-    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-    /// 1) parent-range: Attribute [0, 23)\n-    /// 2) child-range: String [16, 21)\n-    ///\n-    /// The following code implements the flattening, for our example this results to:\n-    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-    fn pop(&mut self) {\n-        let children = self.stack.pop().unwrap();\n-        let prev = self.stack.last_mut().unwrap();\n-        let needs_flattening = !children.is_empty()\n-            && !prev.is_empty()\n-            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n-        if !needs_flattening {\n-            prev.extend(children);\n-        } else {\n-            let mut parent = prev.pop().unwrap();\n-            for ele in children {\n-                assert!(parent.range.contains_range(ele.range));\n-\n-                let cloned = Self::intersect(&mut parent, &ele);\n-                if !parent.range.is_empty() {\n-                    prev.push(parent);\n-                }\n-                prev.push(ele);\n-                parent = cloned;\n-            }\n-            if !parent.range.is_empty() {\n-                prev.push(parent);\n-            }\n-        }\n-    }\n-\n-    /// Intersects the `HighlightedRange` `parent` with `child`.\n-    /// `parent` is mutated in place, becoming the range before `child`.\n-    /// Returns the range (of the same type as `parent`) *after* `child`.\n-    fn intersect(parent: &mut HighlightedRange, child: &HighlightedRange) -> HighlightedRange {\n-        assert!(parent.range.contains_range(child.range));\n-\n-        let mut cloned = parent.clone();\n-        parent.range = TextRange::new(parent.range.start(), child.range.start());\n-        cloned.range = TextRange::new(child.range.end(), cloned.range.end());\n-\n-        cloned\n-    }\n-\n-    /// Remove the `HighlightRange` of `parent` that's currently covered by `child`.\n-    fn intersect_partial(parent: &mut HighlightedRange, child: &HighlightedRange) {\n-        assert!(\n-            parent.range.start() <= child.range.start()\n-                && parent.range.end() >= child.range.start()\n-                && child.range.end() > parent.range.end()\n-        );\n-\n-        parent.range = TextRange::new(parent.range.start(), child.range.start());\n-    }\n-\n-    /// Similar to `pop`, but can modify arbitrary prior ranges (where `pop`)\n-    /// can only modify the last range currently on the stack.\n-    /// Can be used to do injections that span multiple ranges, like the\n-    /// doctest injection below.\n-    /// If `overwrite_parent` is non-optional, the highlighting of the parent range\n-    /// is overwritten with the argument.\n-    ///\n-    /// Note that `pop` can be simulated by `pop_and_inject(false)` but the\n-    /// latter is computationally more expensive.\n-    fn pop_and_inject(&mut self, overwrite_parent: Option<Highlight>) {\n-        let mut children = self.stack.pop().unwrap();\n-        let prev = self.stack.last_mut().unwrap();\n-        children.sort_by_key(|range| range.range.start());\n-        prev.sort_by_key(|range| range.range.start());\n-\n-        for child in children {\n-            if let Some(idx) =\n-                prev.iter().position(|parent| parent.range.contains_range(child.range))\n-            {\n-                if let Some(tag) = overwrite_parent {\n-                    prev[idx].highlight = tag;\n-                }\n-\n-                let cloned = Self::intersect(&mut prev[idx], &child);\n-                let insert_idx = if prev[idx].range.is_empty() {\n-                    prev.remove(idx);\n-                    idx\n-                } else {\n-                    idx + 1\n-                };\n-                prev.insert(insert_idx, child);\n-                if !cloned.range.is_empty() {\n-                    prev.insert(insert_idx + 1, cloned);\n-                }\n-            } else {\n-                let maybe_idx =\n-                    prev.iter().position(|parent| parent.range.contains(child.range.start()));\n-                match (overwrite_parent, maybe_idx) {\n-                    (Some(_), Some(idx)) => {\n-                        Self::intersect_partial(&mut prev[idx], &child);\n-                        let insert_idx = if prev[idx].range.is_empty() {\n-                            prev.remove(idx);\n-                            idx\n-                        } else {\n-                            idx + 1\n-                        };\n-                        prev.insert(insert_idx, child);\n-                    }\n-                    (_, None) => {\n-                        let idx = prev\n-                            .binary_search_by_key(&child.range.start(), |range| range.range.start())\n-                            .unwrap_or_else(|x| x);\n-                        prev.insert(idx, child);\n-                    }\n-                    _ => {\n-                        unreachable!(\"child range should be completely contained in parent range\");\n-                    }\n                 }\n             }\n         }\n     }\n \n-    fn add(&mut self, range: HighlightedRange) {\n-        self.stack\n-            .last_mut()\n-            .expect(\"during DFS traversal, the stack must not be empty\")\n-            .push(range)\n-    }\n-\n-    fn flattened(mut self) -> Vec<HighlightedRange> {\n-        assert_eq!(\n-            self.stack.len(),\n-            1,\n-            \"after DFS traversal, the stack should only contain a single element\"\n-        );\n-        let mut res = self.stack.pop().unwrap();\n-        res.sort_by_key(|range| range.range.start());\n-        // Check that ranges are sorted and disjoint\n-        for (left, right) in res.iter().zip(res.iter().skip(1)) {\n-            assert!(\n-                left.range.end() <= right.range.start(),\n-                \"left: {:#?}, right: {:#?}\",\n-                left,\n-                right\n-            );\n-        }\n-        res\n-    }\n+    stack.to_vec()\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {"}, {"sha": "ab66b406c85a6a72e5e2bfd6a8e7725467f3cb80", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -4,9 +4,9 @@ use syntax::{\n     AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n \n-use crate::{\n-    syntax_highlighting::HighlightedRangeStack, HighlightTag, HighlightedRange, SymbolKind,\n-};\n+use crate::{HighlightTag, HighlightedRange, SymbolKind};\n+\n+use super::highlights::Highlights;\n \n #[derive(Default)]\n pub(super) struct FormatStringHighlighter {\n@@ -39,22 +39,20 @@ impl FormatStringHighlighter {\n     }\n     pub(super) fn highlight_format_string(\n         &self,\n-        range_stack: &mut HighlightedRangeStack,\n+        stack: &mut Highlights,\n         string: &impl HasFormatSpecifier,\n         range: TextRange,\n     ) {\n         if self.format_string.as_ref() == Some(&SyntaxElement::from(string.syntax().clone())) {\n-            range_stack.push();\n             string.lex_format_specifier(|piece_range, kind| {\n                 if let Some(highlight) = highlight_format_specifier(kind) {\n-                    range_stack.add(HighlightedRange {\n+                    stack.add(HighlightedRange {\n                         range: piece_range + range.start(),\n                         highlight: highlight.into(),\n                         binding_hash: None,\n                     });\n                 }\n             });\n-            range_stack.pop();\n         }\n     }\n }"}, {"sha": "3e733c87c6c98f390bd9cbb6d94a7a16f3ef114a", "filename": "crates/ide/src/syntax_highlighting/highlights.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlights.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -0,0 +1,109 @@\n+//! Collects a tree of highlighted ranges and flattens it.\n+use std::{cmp::Ordering, iter};\n+\n+use stdx::equal_range_by;\n+use syntax::TextRange;\n+\n+use crate::{HighlightTag, HighlightedRange};\n+\n+pub(super) struct Highlights {\n+    root: Node,\n+}\n+\n+struct Node {\n+    highlighted_range: HighlightedRange,\n+    nested: Vec<Node>,\n+}\n+\n+impl Highlights {\n+    pub(super) fn new(range: TextRange) -> Highlights {\n+        Highlights {\n+            root: Node::new(HighlightedRange {\n+                range,\n+                highlight: HighlightTag::Dummy.into(),\n+                binding_hash: None,\n+            }),\n+        }\n+    }\n+\n+    pub(super) fn add(&mut self, highlighted_range: HighlightedRange) {\n+        self.root.add(highlighted_range);\n+    }\n+\n+    pub(super) fn to_vec(self) -> Vec<HighlightedRange> {\n+        let mut res = Vec::new();\n+        self.root.flatten(&mut res);\n+        res\n+    }\n+}\n+\n+impl Node {\n+    fn new(highlighted_range: HighlightedRange) -> Node {\n+        Node { highlighted_range, nested: Vec::new() }\n+    }\n+\n+    fn add(&mut self, highlighted_range: HighlightedRange) {\n+        assert!(self.highlighted_range.range.contains_range(highlighted_range.range));\n+\n+        // Fast path\n+        if let Some(last) = self.nested.last_mut() {\n+            if last.highlighted_range.range.contains_range(highlighted_range.range) {\n+                return last.add(highlighted_range);\n+            }\n+            if last.highlighted_range.range.end() <= highlighted_range.range.start() {\n+                return self.nested.push(Node::new(highlighted_range));\n+            }\n+        }\n+\n+        let (start, len) = equal_range_by(&self.nested, |n| {\n+            ordering(n.highlighted_range.range, highlighted_range.range)\n+        });\n+\n+        if len == 1\n+            && self.nested[start].highlighted_range.range.contains_range(highlighted_range.range)\n+        {\n+            return self.nested[start].add(highlighted_range);\n+        }\n+\n+        let nested = self\n+            .nested\n+            .splice(start..start + len, iter::once(Node::new(highlighted_range)))\n+            .collect::<Vec<_>>();\n+        self.nested[start].nested = nested;\n+    }\n+\n+    fn flatten(&self, acc: &mut Vec<HighlightedRange>) {\n+        let mut start = self.highlighted_range.range.start();\n+        let mut nested = self.nested.iter();\n+        loop {\n+            let next = nested.next();\n+            let end = next.map_or(self.highlighted_range.range.end(), |it| {\n+                it.highlighted_range.range.start()\n+            });\n+            if start < end {\n+                acc.push(HighlightedRange {\n+                    range: TextRange::new(start, end),\n+                    highlight: self.highlighted_range.highlight,\n+                    binding_hash: self.highlighted_range.binding_hash,\n+                });\n+            }\n+            start = match next {\n+                Some(child) => {\n+                    child.flatten(acc);\n+                    child.highlighted_range.range.end()\n+                }\n+                None => break,\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn ordering(r1: TextRange, r2: TextRange) -> Ordering {\n+    if r1.end() <= r2.start() {\n+        Ordering::Less\n+    } else if r2.end() <= r1.start() {\n+        Ordering::Greater\n+    } else {\n+        Ordering::Equal\n+    }\n+}"}, {"sha": "44f611b25d1af383c01bf3156c368275c3aadc51", "filename": "crates/ide/src/syntax_highlighting/html.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -3,7 +3,7 @@\n use ide_db::base_db::SourceDatabase;\n use oorandom::Rand32;\n use stdx::format_to;\n-use syntax::{AstNode, TextRange, TextSize};\n+use syntax::AstNode;\n \n use crate::{syntax_highlighting::highlight, FileId, RootDatabase};\n \n@@ -22,17 +22,15 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n \n     let ranges = highlight(db, file_id, None, false);\n     let text = parse.tree().syntax().to_string();\n-    let mut prev_pos = TextSize::from(0);\n     let mut buf = String::new();\n     buf.push_str(&STYLE);\n     buf.push_str(\"<pre><code>\");\n     for range in &ranges {\n-        if range.range.start() > prev_pos {\n-            let curr = &text[TextRange::new(prev_pos, range.range.start())];\n-            let text = html_escape(curr);\n-            buf.push_str(&text);\n+        let curr = &text[range.range];\n+        if range.highlight.is_empty() {\n+            format_to!(buf, \"{}\", html_escape(curr));\n+            continue;\n         }\n-        let curr = &text[TextRange::new(range.range.start(), range.range.end())];\n \n         let class = range.highlight.to_string().replace('.', \" \");\n         let color = match (rainbow, range.binding_hash) {\n@@ -42,13 +40,7 @@ pub(crate) fn highlight_as_html(db: &RootDatabase, file_id: FileId, rainbow: boo\n             _ => \"\".into(),\n         };\n         format_to!(buf, \"<span class=\\\"{}\\\"{}>{}</span>\", class, color, html_escape(curr));\n-\n-        prev_pos = range.range.end();\n     }\n-    // Add the remaining (non-highlighted) text\n-    let curr = &text[TextRange::new(prev_pos, TextSize::of(&text))];\n-    let text = html_escape(curr);\n-    buf.push_str(&text);\n     buf.push_str(\"</code></pre>\");\n     buf\n }"}, {"sha": "98ee03e0d90201063f75872b050340b5cc4cfd97", "filename": "crates/ide/src/syntax_highlighting/injection.rs", "status": "modified", "additions": 31, "deletions": 54, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -1,18 +1,18 @@\n //! Syntax highlighting injections such as highlighting of documentation tests.\n \n-use std::{collections::BTreeMap, convert::TryFrom};\n+use std::convert::TryFrom;\n \n use hir::Semantics;\n use ide_db::call_info::ActiveParameter;\n use itertools::Itertools;\n use syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n \n-use crate::{Analysis, Highlight, HighlightModifier, HighlightTag, HighlightedRange, RootDatabase};\n+use crate::{Analysis, HighlightModifier, HighlightTag, HighlightedRange, RootDatabase};\n \n-use super::HighlightedRangeStack;\n+use super::{highlights::Highlights, injector::Injector};\n \n pub(super) fn highlight_injection(\n-    acc: &mut HighlightedRangeStack,\n+    acc: &mut Highlights,\n     sema: &Semantics<RootDatabase>,\n     literal: ast::String,\n     expanded: SyntaxToken,\n@@ -98,9 +98,6 @@ impl MarkerInfo {\n     }\n }\n \n-/// Mapping from extracted documentation code to original code\n-type RangesMap = BTreeMap<TextSize, TextSize>;\n-\n const RUSTDOC_FENCE: &'static str = \"```\";\n const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n     \"\",\n@@ -119,20 +116,20 @@ const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n /// Lastly, a vector of new comment highlight ranges (spanning only the\n /// comment prefix) is returned which is used in the syntax highlighting\n /// injection to replace the previous (line-spanning) comment ranges.\n-pub(super) fn extract_doc_comments(\n-    node: &SyntaxNode,\n-) -> Option<(String, RangesMap, Vec<HighlightedRange>)> {\n+pub(super) fn extract_doc_comments(node: &SyntaxNode) -> Option<(Vec<HighlightedRange>, Injector)> {\n+    let mut inj = Injector::default();\n     // wrap the doctest into function body to get correct syntax highlighting\n     let prefix = \"fn doctest() {\\n\";\n     let suffix = \"}\\n\";\n-    // Mapping from extracted documentation code to original code\n-    let mut range_mapping: RangesMap = BTreeMap::new();\n-    let mut line_start = TextSize::try_from(prefix.len()).unwrap();\n+\n+    let mut line_start = TextSize::of(prefix);\n     let mut is_codeblock = false;\n     let mut is_doctest = false;\n     // Replace the original, line-spanning comment ranges by new, only comment-prefix\n     // spanning comment ranges.\n     let mut new_comments = Vec::new();\n+\n+    inj.add_unmapped(prefix);\n     let doctest = node\n         .children_with_tokens()\n         .filter_map(|el| el.into_token().and_then(ast::Comment::cast))\n@@ -169,7 +166,6 @@ pub(super) fn extract_doc_comments(\n                 pos\n             };\n \n-            range_mapping.insert(line_start, range.start() + TextSize::try_from(pos).unwrap());\n             new_comments.push(HighlightedRange {\n                 range: TextRange::new(\n                     range.start(),\n@@ -179,62 +175,43 @@ pub(super) fn extract_doc_comments(\n                 binding_hash: None,\n             });\n             line_start += range.len() - TextSize::try_from(pos).unwrap();\n-            line_start += TextSize::try_from('\\n'.len_utf8()).unwrap();\n+            line_start += TextSize::of(\"\\n\");\n \n+            inj.add(\n+                &line[pos..],\n+                TextRange::new(range.start() + TextSize::try_from(pos).unwrap(), range.end()),\n+            );\n+            inj.add_unmapped(\"\\n\");\n             line[pos..].to_owned()\n         })\n         .join(\"\\n\");\n+    inj.add_unmapped(suffix);\n \n     if doctest.is_empty() {\n         return None;\n     }\n \n-    let doctest = format!(\"{}{}{}\", prefix, doctest, suffix);\n-    Some((doctest, range_mapping, new_comments))\n+    Some((new_comments, inj))\n }\n \n /// Injection of syntax highlighting of doctests.\n pub(super) fn highlight_doc_comment(\n-    text: String,\n-    range_mapping: RangesMap,\n     new_comments: Vec<HighlightedRange>,\n-    stack: &mut HighlightedRangeStack,\n+    inj: Injector,\n+    stack: &mut Highlights,\n ) {\n-    let (analysis, tmp_file_id) = Analysis::from_single_file(text);\n-\n-    stack.push();\n-    for mut h in analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)).unwrap() {\n-        // Determine start offset and end offset in case of multi-line ranges\n-        let mut start_offset = None;\n-        let mut end_offset = None;\n-        for (line_start, orig_line_start) in range_mapping.range(..h.range.end()).rev() {\n-            // It's possible for orig_line_start - line_start to be negative. Add h.range.start()\n-            // here and remove it from the end range after the loop below so that the values are\n-            // always non-negative.\n-            let offset = h.range.start() + orig_line_start - line_start;\n-            if line_start <= &h.range.start() {\n-                start_offset.get_or_insert(offset);\n-                break;\n-            } else {\n-                end_offset.get_or_insert(offset);\n-            }\n-        }\n-        if let Some(start_offset) = start_offset {\n-            h.range = TextRange::new(\n-                start_offset,\n-                h.range.end() + end_offset.unwrap_or(start_offset) - h.range.start(),\n-            );\n-\n-            h.highlight |= HighlightModifier::Injected;\n-            stack.add(h);\n-        }\n-    }\n-\n-    // Inject the comment prefix highlight ranges\n-    stack.push();\n+    let (analysis, tmp_file_id) = Analysis::from_single_file(inj.text().to_string());\n     for comment in new_comments {\n         stack.add(comment);\n     }\n-    stack.pop_and_inject(None);\n-    stack.pop_and_inject(Some(Highlight::from(HighlightTag::Dummy) | HighlightModifier::Injected));\n+\n+    for h in analysis.with_db(|db| super::highlight(db, tmp_file_id, None, true)).unwrap() {\n+        for r in inj.map_range_up(h.range) {\n+            stack.add(HighlightedRange {\n+                range: r,\n+                highlight: h.highlight | HighlightModifier::Injected,\n+                binding_hash: h.binding_hash,\n+            });\n+        }\n+    }\n }"}, {"sha": "0513a9fd636a7b1387fada8287ac036e7f022b08", "filename": "crates/ide/src/syntax_highlighting/injector.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjector.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -0,0 +1,83 @@\n+//! Extracts a subsequence of a text document, remembering the mapping of ranges\n+//! between original and extracted texts.\n+use std::ops::{self, Sub};\n+\n+use stdx::equal_range_by;\n+use syntax::{TextRange, TextSize};\n+\n+use super::highlights::ordering;\n+\n+#[derive(Default)]\n+pub(super) struct Injector {\n+    buf: String,\n+    ranges: Vec<(TextRange, Option<Delta<TextSize>>)>,\n+}\n+\n+impl Injector {\n+    pub(super) fn add(&mut self, text: &str, source_range: TextRange) {\n+        let len = TextSize::of(text);\n+        assert_eq!(len, source_range.len());\n+\n+        let target_range = TextRange::at(TextSize::of(&self.buf), len);\n+        self.ranges\n+            .push((target_range, Some(Delta::new(target_range.start(), source_range.start()))));\n+        self.buf.push_str(text);\n+    }\n+    pub(super) fn add_unmapped(&mut self, text: &str) {\n+        let len = TextSize::of(text);\n+\n+        let target_range = TextRange::at(TextSize::of(&self.buf), len);\n+        self.ranges.push((target_range, None));\n+        self.buf.push_str(text);\n+    }\n+\n+    pub(super) fn text(&self) -> &str {\n+        &self.buf\n+    }\n+    pub(super) fn map_range_up(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {\n+        let (start, len) = equal_range_by(&self.ranges, |&(r, _)| ordering(r, range));\n+        (start..start + len).filter_map(move |i| {\n+            let (target_range, delta) = self.ranges[i];\n+            let intersection = target_range.intersect(range).unwrap();\n+            Some(intersection + delta?)\n+        })\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum Delta<T> {\n+    Add(T),\n+    Sub(T),\n+}\n+\n+impl<T> Delta<T> {\n+    fn new(from: T, to: T) -> Delta<T>\n+    where\n+        T: Ord + Sub<Output = T>,\n+    {\n+        if to >= from {\n+            Delta::Add(to - from)\n+        } else {\n+            Delta::Sub(from - to)\n+        }\n+    }\n+}\n+\n+impl ops::Add<Delta<TextSize>> for TextSize {\n+    type Output = TextSize;\n+\n+    fn add(self, rhs: Delta<TextSize>) -> TextSize {\n+        match rhs {\n+            Delta::Add(it) => self + it,\n+            Delta::Sub(it) => self - it,\n+        }\n+    }\n+}\n+\n+impl ops::Add<Delta<TextSize>> for TextRange {\n+    type Output = TextRange;\n+\n+    fn add(self, rhs: Delta<TextSize>) -> TextRange {\n+        TextRange::at(self.start() + rhs, self.len())\n+    }\n+}"}, {"sha": "a0286b72d949d6f35e0720f82170ccde98b99e37", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -94,13 +94,13 @@ impl HighlightTag {\n             HighlightTag::Comment => \"comment\",\n             HighlightTag::EscapeSequence => \"escape_sequence\",\n             HighlightTag::FormatSpecifier => \"format_specifier\",\n-            HighlightTag::Dummy => \"dummy\",\n             HighlightTag::Keyword => \"keyword\",\n             HighlightTag::Punctuation => \"punctuation\",\n             HighlightTag::NumericLiteral => \"numeric_literal\",\n             HighlightTag::Operator => \"operator\",\n             HighlightTag::StringLiteral => \"string_literal\",\n             HighlightTag::UnresolvedReference => \"unresolved_reference\",\n+            HighlightTag::Dummy => \"dummy\",\n         }\n     }\n }\n@@ -173,6 +173,9 @@ impl Highlight {\n     pub(crate) fn new(tag: HighlightTag) -> Highlight {\n         Highlight { tag, modifiers: HighlightModifiers::default() }\n     }\n+    pub fn is_empty(&self) -> bool {\n+        self.tag == HighlightTag::Dummy && self.modifiers == HighlightModifiers::default()\n+    }\n }\n \n impl ops::BitOr<HighlightModifier> for HighlightTag {"}, {"sha": "9d42b11c1e34b648859e0a532e40acabc18cdefc", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_doctest.html", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_doctest.html?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -37,13 +37,18 @@\n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n <pre><code><span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"punctuation injected\">;</span><span class=\"punctuation injected\">\n-</span><span class=\"comment documentation\">/// ```</span>\n+<span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"early doctests should not go boom\"</span><span class=\"punctuation injected\">;</span>\n+<span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"field declaration\">bar</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">bool</span><span class=\"punctuation\">,</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">impl</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n+    <span class=\"comment documentation\">/// ```</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"punctuation injected\">_</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"Call me</span>\n+    <span class=\"comment\">//    KILLER WHALE</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">    Ishmael.\"</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// ```</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"constant declaration associated\">bar</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">bool</span> <span class=\"operator\">=</span> <span class=\"bool_literal\">true</span><span class=\"punctuation\">;</span>\n \n     <span class=\"comment documentation\">/// Constructs a new `Foo`.</span>\n@@ -52,8 +57,8 @@\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">/// #</span><span class=\"dummy injected\"> </span><span class=\"attribute attribute injected\">#</span><span class=\"attribute attribute injected\">!</span><span class=\"attribute attribute injected\">[</span><span class=\"function attribute injected\">allow</span><span class=\"punctuation attribute injected\">(</span><span class=\"attribute attribute injected\">unused_mut</span><span class=\"punctuation attribute injected\">)</span><span class=\"attribute attribute injected\">]</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"punctuation injected\">:</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span><span class=\"punctuation injected\">\n-</span>    <span class=\"comment documentation\">/// ```</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"keyword injected\">mut</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected mutable\">foo</span><span class=\"punctuation injected\">:</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// ```</span>\n     <span class=\"keyword\">pub</span> <span class=\"keyword\">const</span> <span class=\"keyword\">fn</span> <span class=\"function declaration static associated\">new</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span>\n         <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">bar</span><span class=\"punctuation\">:</span> <span class=\"bool_literal\">true</span> <span class=\"punctuation\">}</span>\n     <span class=\"punctuation\">}</span>\n@@ -72,18 +77,18 @@\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">bar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"variable injected\">foo</span><span class=\"operator injected\">.</span><span class=\"field injected\">bar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">||</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"constant injected\">bar</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">/* multi-line\n-    </span><span class=\"comment documentation\">/// </span><span class=\"comment injected\">       comment */</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">/* multi-line</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"comment injected\">       comment */</span>\n     <span class=\"comment documentation\">///</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">multi_line_string</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"Foo\n-    </span><span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">  bar\n-    </span><span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">         \"</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">multi_line_string</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"string_literal injected\">\"Foo</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">  bar</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"string_literal injected\">         \"</span><span class=\"punctuation injected\">;</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```rust,no_run</span>\n-    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span><span class=\"punctuation injected\">\n-</span>    <span class=\"comment documentation\">/// ```</span>\n+    <span class=\"comment documentation\">/// </span><span class=\"keyword injected\">let</span><span class=\"dummy injected\"> </span><span class=\"variable declaration injected\">foobar</span><span class=\"dummy injected\"> </span><span class=\"operator injected\">=</span><span class=\"dummy injected\"> </span><span class=\"struct injected\">Foo</span><span class=\"operator injected\">::</span><span class=\"function injected\">new</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"operator injected\">.</span><span class=\"function injected\">bar</span><span class=\"punctuation injected\">(</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+    <span class=\"comment documentation\">/// ```</span>\n     <span class=\"comment documentation\">///</span>\n     <span class=\"comment documentation\">/// ```sh</span>\n     <span class=\"comment documentation\">/// echo 1</span>\n@@ -94,8 +99,8 @@\n <span class=\"punctuation\">}</span>\n \n <span class=\"comment documentation\">/// ```</span>\n-<span class=\"comment documentation\">/// </span><span class=\"macro injected\">noop!</span><span class=\"punctuation injected\">(</span><span class=\"numeric_literal injected\">1</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span><span class=\"punctuation injected\">\n-</span><span class=\"comment documentation\">/// ```</span>\n+<span class=\"comment documentation\">/// </span><span class=\"macro injected\">noop!</span><span class=\"punctuation injected\">(</span><span class=\"numeric_literal injected\">1</span><span class=\"punctuation injected\">)</span><span class=\"punctuation injected\">;</span>\n+<span class=\"comment documentation\">/// ```</span>\n <span class=\"keyword\">macro_rules</span><span class=\"punctuation\">!</span> <span class=\"macro declaration\">noop</span> <span class=\"punctuation\">{</span>\n     <span class=\"punctuation\">(</span><span class=\"punctuation\">$</span>expr<span class=\"punctuation\">:</span>expr<span class=\"punctuation\">)</span> <span class=\"operator\">=</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>\n         <span class=\"punctuation\">$</span>expr"}, {"sha": "a62704c39e739a041363a09afce174baacadea09", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -446,6 +446,11 @@ struct Foo {\n }\n \n impl Foo {\n+    /// ```\n+    /// let _ = \"Call me\n+    //    KILLER WHALE\n+    ///     Ishmael.\";\n+    /// ```\n     pub const bar: bool = true;\n \n     /// Constructs a new `Foo`."}, {"sha": "204cae2654f34bc22daa00a3cb67e67ff748d4dd", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -343,6 +343,9 @@ pub(crate) fn semantic_tokens(\n     let mut builder = semantic_tokens::SemanticTokensBuilder::new(id);\n \n     for highlight_range in highlights {\n+        if highlight_range.highlight.is_empty() {\n+            continue;\n+        }\n         let (type_, mods) = semantic_token_type_and_modifiers(highlight_range.highlight);\n         let token_index = semantic_tokens::type_index(type_);\n         let modifier_bitset = mods.0;"}, {"sha": "5aacdb16edb6365c14e86b521d07be497bd845c0", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=e30c1c3fbf8f70336d985b2b73e5b0f45f3b95f5", "patch": "@@ -1,5 +1,5 @@\n //! Missing batteries for standard libraries.\n-use std::{ops, process, time::Instant};\n+use std::{cmp::Ordering, ops, process, time::Instant};\n \n mod macros;\n pub mod panic_context;\n@@ -117,7 +117,12 @@ impl<'a> Iterator for LinesWithEnds<'a> {\n     }\n }\n \n-// https://github.com/rust-lang/rust/issues/73831\n+/// Returns `idx` such that:\n+///\n+///     \u2200 x in slice[..idx]:  pred(x)\n+///  && \u2200 x in slice[idx..]: !pred(x)\n+///\n+/// https://github.com/rust-lang/rust/issues/73831\n pub fn partition_point<T, P>(slice: &[T], mut pred: P) -> usize\n where\n     P: FnMut(&T) -> bool,\n@@ -147,6 +152,15 @@ where\n     left\n }\n \n+pub fn equal_range_by<T, F>(slice: &[T], mut key: F) -> (usize, usize)\n+where\n+    F: FnMut(&T) -> Ordering,\n+{\n+    let start = partition_point(slice, |it| key(it) == Ordering::Less);\n+    let len = partition_point(&slice[start..], |it| key(it) == Ordering::Equal);\n+    (start, len)\n+}\n+\n pub struct JodChild(pub process::Child);\n \n impl ops::Deref for JodChild {"}]}