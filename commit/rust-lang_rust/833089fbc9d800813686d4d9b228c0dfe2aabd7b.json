{"sha": "833089fbc9d800813686d4d9b228c0dfe2aabd7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMzA4OWZiYzlkODAwODEzNjg2ZDRkOWIyMjhjMGRmZTJhYWJkN2I=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-22T11:02:17Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:32Z"}, "message": "Unify the two kinds of specialization by adding a Wildcard ctor", "tree": {"sha": "e83de6d3532f526a96b6161315fa42ad5bf7d85c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e83de6d3532f526a96b6161315fa42ad5bf7d85c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/833089fbc9d800813686d4d9b228c0dfe2aabd7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/833089fbc9d800813686d4d9b228c0dfe2aabd7b", "html_url": "https://github.com/rust-lang/rust/commit/833089fbc9d800813686d4d9b228c0dfe2aabd7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/833089fbc9d800813686d4d9b228c0dfe2aabd7b/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41e7ca499d51913131a5afa5fa76db914cb672cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/41e7ca499d51913131a5afa5fa76db914cb672cd", "html_url": "https://github.com/rust-lang/rust/commit/41e7ca499d51913131a5afa5fa76db914cb672cd"}], "stats": {"total": 177, "additions": 80, "deletions": 97}, "files": [{"sha": "c2b0d8f52e34f39cf17b685c587f85718df89128", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 80, "deletions": 97, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/833089fbc9d800813686d4d9b228c0dfe2aabd7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/833089fbc9d800813686d4d9b228c0dfe2aabd7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=833089fbc9d800813686d4d9b228c0dfe2aabd7b", "patch": "@@ -137,8 +137,8 @@\n //!                 S(c, (r_1, p_2, .., p_n))\n //!                 S(c, (r_2, p_2, .., p_n))\n //!\n-//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!    a pattern-stack.\n+//! 2. We can pop a wildcard off the top of the stack. This is called `S(_, p)`, where `p` is\n+//!    a pattern-stack. Note: the paper calls this `D(p)`.\n //!    This is used when we know there are missing constructor cases, but there might be\n //!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n //!    all its *other* components.\n@@ -150,8 +150,8 @@\n //!                 p_2, .., p_n\n //!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!           stack.\n-//!                 D((r_1, p_2, .., p_n))\n-//!                 D((r_2, p_2, .., p_n))\n+//!                 S(_, (r_1, p_2, .., p_n))\n+//!                 S(_, (r_2, p_2, .., p_n))\n //!\n //! Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n //! exhaustive integer matching rules, so they're written here for posterity.\n@@ -205,7 +205,7 @@\n //! That's almost correct, but only works if there were no wildcards in those first\n //! components. So we need to check that `p` is useful with respect to the rows that\n //! start with a wildcard, if there are any. This is where `D` comes in:\n-//! `U(P, p) := U(D(P), D(p))`\n+//! `U(P, p) := U(S(_, P), S(_, p))`\n //!\n //! For example, if `P` is:\n //!\n@@ -358,10 +358,6 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         PatStack(vec)\n     }\n \n-    fn from_slice(s: &[&'p Pat<'tcx>]) -> Self {\n-        PatStack(SmallVec::from_slice(s))\n-    }\n-\n     fn is_empty(&self) -> bool {\n         self.0.is_empty()\n     }\n@@ -374,10 +370,6 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         self.0[0]\n     }\n \n-    fn to_tail(&self) -> Self {\n-        PatStack::from_slice(&self.0[1..])\n-    }\n-\n     fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {\n         self.0.iter().copied()\n     }\n@@ -401,11 +393,6 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         }\n     }\n \n-    /// This computes `D(self)`. See top of the file for explanations.\n-    fn specialize_wildcard(&self) -> Option<Self> {\n-        if self.head().is_wildcard() { Some(self.to_tail()) } else { None }\n-    }\n-\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     ///\n     /// This is the main specialization step. It expands the pattern\n@@ -427,15 +414,13 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n         // We return `None` if `ctor` is not covered by `self.head()`. If `ctor` is known to be\n-        // derived from `self.head()`, or if `self.head()` is a wildcard, then we don't need to\n-        // check; otherwise, we compute the constructor of `self.head()` and check for constructor\n-        // inclusion.\n+        // derived from `self.head()`, then we don't need to check; otherwise, we compute the\n+        // constructor of `self.head()` and check for constructor inclusion.\n         // Note that this shortcut is also necessary for correctness: a pattern should always be\n         // specializable with its own constructor, even in cases where we refuse to inspect values like\n         // opaque constants.\n-        if !self.head().is_wildcard() && !is_my_head_ctor {\n-            // `unwrap` is safe because `pat` is not a wildcard.\n-            let head_ctor = pat_constructor(cx.tcx, cx.param_env, self.head()).unwrap();\n+        if !is_my_head_ctor {\n+            let head_ctor = pat_constructor(cx.tcx, cx.param_env, self.head());\n             if !ctor.is_covered_by(cx, &head_ctor, self.head().ty) {\n                 return None;\n             }\n@@ -480,8 +465,8 @@ enum SpecializationCache {\n     /// so it is possible to precompute the result of `Matrix::specialize_constructor` at a\n     /// lower computational complexity.\n     /// `lookup` is responsible for holding the precomputed result of\n-    /// `Matrix::specialize_constructor`, while `wilds` is used for two purposes: the first one is\n-    /// the precomputed result of `Matrix::specialize_wildcard`, and the second is to be used as a\n+    /// specialization, while `wilds` is used for two purposes: the first one is\n+    /// the precomputed result of specialization with a wildcard, and the second is to be used as a\n     /// fallback for `Matrix::specialize_constructor` when it tries to apply a constructor that\n     /// has not been seen in the `Matrix`. See `update_cache` for further explanations.\n     Variants { lookup: FxHashMap<DefId, SmallVec<[usize; 1]>>, wilds: SmallVec<[usize; 1]> },\n@@ -553,9 +538,9 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                             v.push(idx);\n                         }\n                         // Per rule 2.1 and 2.2 in the top-level comments, only wildcard patterns\n-                        // are included in the result of `specialize_wildcard`.\n+                        // are included in the result of specialization with a wildcard.\n                         // What we do here is to track the wildcards we have seen; so in addition to\n-                        // acting as the precomputed result of `specialize_wildcard`, `wilds` also\n+                        // acting as the precomputed result of specialization with a wildcard, `wilds` also\n                         // serves as the default value of `specialize_constructor` for constructors\n                         // that are not in `lookup`.\n                         wilds.push(idx);\n@@ -585,30 +570,6 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         self.patterns.iter().map(|r| r.head())\n     }\n \n-    /// This computes `D(self)`. See top of the file for explanations.\n-    fn specialize_wildcard(&self) -> Self {\n-        match &self.cache {\n-            SpecializationCache::Variants { wilds, .. } => {\n-                let result =\n-                    wilds.iter().filter_map(|&i| self.patterns[i].specialize_wildcard()).collect();\n-                // When debug assertions are enabled, check the results against the \"slow path\"\n-                // result.\n-                debug_assert_eq!(\n-                    result,\n-                    Self {\n-                        patterns: self.patterns.clone(),\n-                        cache: SpecializationCache::Incompatible\n-                    }\n-                    .specialize_wildcard()\n-                );\n-                result\n-            }\n-            SpecializationCache::Incompatible => {\n-                self.patterns.iter().filter_map(|r| r.specialize_wildcard()).collect()\n-            }\n-        }\n-    }\n-\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n@@ -618,24 +579,30 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     ) -> Matrix<'p, 'tcx> {\n         match &self.cache {\n             SpecializationCache::Variants { lookup, wilds } => {\n-                let result: Self = if let Constructor::Variant(id) = constructor {\n+                let cached = if let Constructor::Variant(id) = constructor {\n                     lookup\n                         .get(id)\n                         // Default to `wilds` for absent keys. See `update_cache` for an explanation.\n                         .unwrap_or(&wilds)\n-                        .iter()\n-                        .filter_map(|&i| {\n-                            self.patterns[i].specialize_constructor(\n-                                cx,\n-                                constructor,\n-                                ctor_wild_subpatterns,\n-                                false,\n-                            )\n-                        })\n-                        .collect()\n+                } else if let Wildcard = constructor {\n+                    &wilds\n                 } else {\n-                    unreachable!()\n+                    bug!(\n+                        \"unexpected constructor encountered while dealing with matrix cache: {:?}\",\n+                        constructor\n+                    );\n                 };\n+                let result: Self = cached\n+                    .iter()\n+                    .filter_map(|&i| {\n+                        self.patterns[i].specialize_constructor(\n+                            cx,\n+                            constructor,\n+                            ctor_wild_subpatterns,\n+                            false,\n+                        )\n+                    })\n+                    .collect();\n                 // When debug assertions are enabled, check the results against the \"slow path\"\n                 // result.\n                 debug_assert_eq!(\n@@ -939,8 +906,10 @@ impl Slice {\n             _ => return smallvec![Slice(self)],\n         };\n \n-        let head_ctors =\n-            matrix.heads().filter_map(|pat| pat_constructor(cx.tcx, cx.param_env, pat));\n+        let head_ctors = matrix\n+            .heads()\n+            .map(|p| pat_constructor(cx.tcx, cx.param_env, p))\n+            .filter(|c| !c.is_wildcard());\n \n         let mut max_prefix_len = self_prefix;\n         let mut max_suffix_len = self_suffix;\n@@ -1026,9 +995,18 @@ enum Constructor<'tcx> {\n     Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n+    /// Wildcard pattern.\n+    Wildcard,\n }\n \n impl<'tcx> Constructor<'tcx> {\n+    fn is_wildcard(&self) -> bool {\n+        match self {\n+            Wildcard => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n@@ -1120,7 +1098,8 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n-            Opaque => bug!(\"unexpected opaque ctor {:?} found in all_ctors\", self),\n+            Opaque => bug!(\"found unexpected opaque ctor in all_ctors\"),\n+            Wildcard => bug!(\"found unexpected wildcard ctor in all_ctors\"),\n         }\n     }\n \n@@ -1173,6 +1152,11 @@ impl<'tcx> Constructor<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> bool {\n         match (self, other) {\n+            // Wildcards cover anything\n+            (_, Wildcard) => true,\n+            // Wildcards are only covered by wildcards\n+            (Wildcard, _) => false,\n+\n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n \n@@ -1302,7 +1286,8 @@ impl<'tcx> Constructor<'tcx> {\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n-            Opaque => bug!(\"we should not try to apply an opaque constructor {:?}\", self),\n+            Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n+            Wildcard => bug!(\"we should not try to apply a wildcard constructor\"),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1454,7 +1439,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque => Fields::empty(),\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Wildcard => {\n+                Fields::empty()\n+            }\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -2011,19 +1998,7 @@ impl<'tcx> IntRange<'tcx> {\n     ) -> Option<IntRange<'tcx>> {\n         // This MUST be kept in sync with `pat_constructor`.\n         match *pat.kind {\n-            PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-            PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n-\n-            PatKind::Binding { .. }\n-            | PatKind::Wild\n-            | PatKind::Leaf { .. }\n-            | PatKind::Deref { .. }\n-            | PatKind::Variant { .. }\n-            | PatKind::Array { .. }\n-            | PatKind::Slice { .. } => None,\n-\n             PatKind::Constant { value } => Self::from_const(tcx, param_env, value, pat.span),\n-\n             PatKind::Range(PatRange { lo, hi, end }) => {\n                 let ty = lo.ty;\n                 Self::from_range(\n@@ -2035,6 +2010,7 @@ impl<'tcx> IntRange<'tcx> {\n                     pat.span,\n                 )\n             }\n+            _ => None,\n         }\n     }\n \n@@ -2436,7 +2412,8 @@ crate fn is_useful<'p, 'tcx>(\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n \n-    let ret = if let Some(constructor) = pat_constructor(cx.tcx, cx.param_env, v.head()) {\n+    let constructor = pat_constructor(cx.tcx, cx.param_env, v.head());\n+    let ret = if !constructor.is_wildcard() {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         constructor\n             .split(cx, pcx, matrix, Some(hir_id))\n@@ -2458,8 +2435,11 @@ crate fn is_useful<'p, 'tcx>(\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> =\n-            matrix.heads().filter_map(|p| pat_constructor(cx.tcx, cx.param_env, p)).collect();\n+        let used_ctors: Vec<Constructor<'_>> = matrix\n+            .heads()\n+            .map(|p| pat_constructor(cx.tcx, cx.param_env, p))\n+            .filter(|c| !c.is_wildcard())\n+            .collect();\n         debug!(\"is_useful_used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -2501,8 +2481,11 @@ crate fn is_useful<'p, 'tcx>(\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n-            let matrix = matrix.specialize_wildcard();\n-            let v = v.to_tail();\n+            let ctor_wild_subpatterns = Fields::empty();\n+            let matrix = matrix.specialize_constructor(cx, &constructor, &ctor_wild_subpatterns);\n+            // Unwrap is ok: v can always be specialized with its own constructor.\n+            let v =\n+                v.specialize_constructor(cx, &constructor, &ctor_wild_subpatterns, true).unwrap();\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n \n@@ -2584,26 +2567,26 @@ fn pat_constructor<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     pat: &Pat<'tcx>,\n-) -> Option<Constructor<'tcx>> {\n+) -> Constructor<'tcx> {\n     // This MUST be kept in sync with `IntRange::from_pat`.\n     match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-        PatKind::Binding { .. } | PatKind::Wild => None,\n-        PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(Single),\n+        PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n+        PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n         PatKind::Variant { adt_def, variant_index, .. } => {\n-            Some(Variant(adt_def.variants[variant_index].def_id))\n+            Variant(adt_def.variants[variant_index].def_id)\n         }\n         PatKind::Constant { value } => {\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n-                Some(IntRange(int_range))\n+                IntRange(int_range)\n             } else {\n                 match value.ty.kind() {\n-                    ty::Float(_) => Some(FloatRange(value, value, RangeEnd::Included)),\n-                    ty::Ref(_, t, _) if t.is_str() => Some(Str(value)),\n+                    ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n+                    ty::Ref(_, t, _) if t.is_str() => Str(value),\n                     // All constants that can be structurally matched have already been expanded\n                     // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n                     // opaque.\n-                    _ => Some(Opaque),\n+                    _ => Opaque,\n                 }\n             }\n         }\n@@ -2617,9 +2600,9 @@ fn pat_constructor<'tcx>(\n                 &end,\n                 pat.span,\n             ) {\n-                Some(IntRange(int_range))\n+                IntRange(int_range)\n             } else {\n-                Some(FloatRange(lo, hi, end))\n+                FloatRange(lo, hi, end)\n             }\n         }\n         PatKind::Array { ref prefix, ref slice, ref suffix }\n@@ -2633,7 +2616,7 @@ fn pat_constructor<'tcx>(\n             let suffix = suffix.len() as u64;\n             let kind =\n                 if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n-            Some(Slice(Slice { array_len, kind }))\n+            Slice(Slice { array_len, kind })\n         }\n         PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n     }"}]}