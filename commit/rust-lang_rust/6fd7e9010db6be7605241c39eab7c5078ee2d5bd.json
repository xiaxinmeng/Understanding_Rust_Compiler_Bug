{"sha": "6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "node_id": "C_kwDOAAsO6NoAKDZmZDdlOTAxMGRiNmJlNzYwNTI0MWMzOWVhYjdjNTA3OGVlMmQ1YmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-18T12:15:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-18T12:15:39Z"}, "message": "Auto merge of #96042 - m-ou-se:one-reentrant-mutex, r=Amanieu\n\nUse a single ReentrantMutex implementation on all platforms.\n\nThis replaces all platform specific ReentrantMutex implementations by the one I added in #95727 for Linux, since that one does not depend on any platform specific details.\n\nr? `@Amanieu`", "tree": {"sha": "802ffb78d54b686a029e0f9a17e1acdf32031e1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/802ffb78d54b686a029e0f9a17e1acdf32031e1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "html_url": "https://github.com/rust-lang/rust/commit/6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "491f619f564a4ff9ae4cc837e27bb919d04c31be", "url": "https://api.github.com/repos/rust-lang/rust/commits/491f619f564a4ff9ae4cc837e27bb919d04c31be", "html_url": "https://github.com/rust-lang/rust/commit/491f619f564a4ff9ae4cc837e27bb919d04c31be"}, {"sha": "94f00e396acbaf8dc2ed41f92dcb475b89b12685", "url": "https://api.github.com/repos/rust-lang/rust/commits/94f00e396acbaf8dc2ed41f92dcb475b89b12685", "html_url": "https://github.com/rust-lang/rust/commit/94f00e396acbaf8dc2ed41f92dcb475b89b12685"}], "stats": {"total": 633, "additions": 92, "deletions": 541}, "files": [{"sha": "97b4c49896f63f1aaa783071d44004019a4c2c44", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -1,6 +1,5 @@\n use crate::cell::UnsafeCell;\n use crate::collections::VecDeque;\n-use crate::ffi::c_void;\n use crate::hint;\n use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n@@ -220,38 +219,3 @@ impl Mutex {\n     #[inline]\n     pub unsafe fn destroy(&self) {}\n }\n-\n-pub struct ReentrantMutex {\n-    inner: *const c_void,\n-}\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: ptr::null() }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&self) {\n-        let _ = abi::recmutex_init(&self.inner as *const *const c_void as *mut _);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let _ = abi::recmutex_lock(self.inner);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        true\n-    }\n-\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let _ = abi::recmutex_unlock(self.inner);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let _ = abi::recmutex_destroy(self.inner);\n-    }\n-}"}, {"sha": "5ee231882bb589e8faf273d9ddab311e8b239045", "filename": "library/std/src/sys/itron/mutex.rs", "status": "modified", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -5,7 +5,6 @@ use super::{\n     error::{expect_success, expect_success_aborting, fail, ItronError},\n     spin::SpinIdOnceCell,\n };\n-use crate::cell::UnsafeCell;\n \n pub struct Mutex {\n     /// The ID of the underlying mutex object\n@@ -89,95 +88,3 @@ impl Drop for MutexGuard<'_> {\n         unsafe { self.0.unlock() };\n     }\n }\n-\n-// All empty stubs because this platform does not yet support threads, so lock\n-// acquisition always succeeds.\n-pub struct ReentrantMutex {\n-    /// The ID of the underlying mutex object\n-    mtx: abi::ID,\n-    /// The lock count.\n-    count: UnsafeCell<usize>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { mtx: 0, count: UnsafeCell::new(0) }\n-    }\n-\n-    pub unsafe fn init(&mut self) {\n-        self.mtx = expect_success(\n-            unsafe {\n-                abi::acre_mtx(&abi::T_CMTX {\n-                    // Priority inheritance mutex\n-                    mtxatr: abi::TA_INHERIT,\n-                    // Unused\n-                    ceilpri: 0,\n-                })\n-            },\n-            &\"acre_mtx\",\n-        );\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        match unsafe { abi::loc_mtx(self.mtx) } {\n-            abi::E_OBJ => {\n-                // Recursive lock\n-                unsafe {\n-                    let count = &mut *self.count.get();\n-                    if let Some(new_count) = count.checked_add(1) {\n-                        *count = new_count;\n-                    } else {\n-                        // counter overflow\n-                        rtabort!(\"lock count overflow\");\n-                    }\n-                }\n-            }\n-            er => {\n-                expect_success(er, &\"loc_mtx\");\n-            }\n-        }\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        unsafe {\n-            let count = &mut *self.count.get();\n-            if *count > 0 {\n-                *count -= 1;\n-                return;\n-            }\n-        }\n-\n-        expect_success_aborting(unsafe { abi::unl_mtx(self.mtx) }, &\"unl_mtx\");\n-    }\n-\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let er = unsafe { abi::ploc_mtx(self.mtx) };\n-        if er == abi::E_OBJ {\n-            // Recursive lock\n-            unsafe {\n-                let count = &mut *self.count.get();\n-                if let Some(new_count) = count.checked_add(1) {\n-                    *count = new_count;\n-                } else {\n-                    // counter overflow\n-                    rtabort!(\"lock count overflow\");\n-                }\n-            }\n-            true\n-        } else if er == abi::E_TMOUT {\n-            // Locked by another thread\n-            false\n-        } else {\n-            expect_success(er, &\"ploc_mtx\");\n-            // Top-level lock by the current thread\n-            true\n-        }\n-    }\n-\n-    pub unsafe fn destroy(&self) {\n-        expect_success_aborting(unsafe { abi::del_mtx(self.mtx) }, &\"del_mtx\");\n-    }\n-}"}, {"sha": "98a390c4c2bcabe06cae174626f442ecb4324ee3", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -1,8 +1,4 @@\n-use fortanix_sgx_abi::Tcs;\n-\n-use super::abi::thread;\n-\n-use super::waitqueue::{try_lock_or_false, NotifiedTcs, SpinMutex, WaitQueue, WaitVariable};\n+use super::waitqueue::{try_lock_or_false, SpinMutex, WaitQueue, WaitVariable};\n \n pub struct Mutex {\n     inner: SpinMutex<WaitVariable<bool>>,\n@@ -60,84 +56,3 @@ impl Mutex {\n     #[inline]\n     pub unsafe fn destroy(&self) {}\n }\n-\n-struct ReentrantLock {\n-    owner: Option<Tcs>,\n-    count: usize,\n-}\n-\n-pub struct ReentrantMutex {\n-    inner: SpinMutex<WaitVariable<ReentrantLock>>,\n-}\n-\n-impl ReentrantMutex {\n-    pub const fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex {\n-            inner: SpinMutex::new(WaitVariable::new(ReentrantLock { owner: None, count: 0 })),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&self) {}\n-\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let mut guard = self.inner.lock();\n-        match guard.lock_var().owner {\n-            Some(tcs) if tcs != thread::current() => {\n-                // Another thread has the lock, wait\n-                WaitQueue::wait(guard, || {});\n-                // Another thread has passed the lock to us\n-            }\n-            _ => {\n-                // We are just now obtaining the lock\n-                guard.lock_var_mut().owner = Some(thread::current());\n-                guard.lock_var_mut().count += 1;\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let mut guard = self.inner.lock();\n-        if guard.lock_var().count > 1 {\n-            guard.lock_var_mut().count -= 1;\n-        } else {\n-            match WaitQueue::notify_one(guard) {\n-                Err(mut guard) => {\n-                    // No other waiters, unlock\n-                    guard.lock_var_mut().count = 0;\n-                    guard.lock_var_mut().owner = None;\n-                }\n-                Ok(mut guard) => {\n-                    // There was a thread waiting, just pass the lock\n-                    if let NotifiedTcs::Single(tcs) = guard.notified_tcs() {\n-                        guard.lock_var_mut().owner = Some(tcs)\n-                    } else {\n-                        unreachable!() // called notify_one\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let mut guard = try_lock_or_false!(self.inner);\n-        match guard.lock_var().owner {\n-            Some(tcs) if tcs != thread::current() => {\n-                // Another thread has the lock\n-                false\n-            }\n-            _ => {\n-                // We are just now obtaining the lock\n-                guard.lock_var_mut().owner = Some(thread::current());\n-                guard.lock_var_mut().count += 1;\n-                true\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {}\n-}"}, {"sha": "7a63af1ad7cf7dfa45bc95efbd20ae62545f78f0", "filename": "library/std/src/sys/unix/locks/futex.rs", "status": "modified", "additions": 1, "deletions": 97, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -1,6 +1,5 @@\n-use crate::cell::UnsafeCell;\n use crate::sync::atomic::{\n-    AtomicU32, AtomicUsize,\n+    AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -163,98 +162,3 @@ impl Condvar {\n         r\n     }\n }\n-\n-/// A reentrant mutex. Used by stdout().lock() and friends.\n-///\n-/// The 'owner' field tracks which thread has locked the mutex.\n-///\n-/// We use current_thread_unique_ptr() as the thread identifier,\n-/// which is just the address of a thread local variable.\n-///\n-/// If `owner` is set to the identifier of the current thread,\n-/// we assume the mutex is already locked and instead of locking it again,\n-/// we increment `lock_count`.\n-///\n-/// When unlocking, we decrement `lock_count`, and only unlock the mutex when\n-/// it reaches zero.\n-///\n-/// `lock_count` is protected by the mutex and only accessed by the thread that has\n-/// locked the mutex, so needs no synchronization.\n-///\n-/// `owner` can be checked by other threads that want to see if they already\n-/// hold the lock, so needs to be atomic. If it compares equal, we're on the\n-/// same thread that holds the mutex and memory access can use relaxed ordering\n-/// since we're not dealing with multiple threads. If it compares unequal,\n-/// synchronization is left to the mutex, making relaxed memory ordering for\n-/// the `owner` field fine in all cases.\n-pub struct ReentrantMutex {\n-    mutex: Mutex,\n-    owner: AtomicUsize,\n-    lock_count: UnsafeCell<u32>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    #[inline]\n-    pub const unsafe fn uninitialized() -> Self {\n-        Self { mutex: Mutex::new(), owner: AtomicUsize::new(0), lock_count: UnsafeCell::new(0) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&self) {}\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {}\n-\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let this_thread = current_thread_unique_ptr();\n-        if self.owner.load(Relaxed) == this_thread {\n-            self.increment_lock_count();\n-            true\n-        } else if self.mutex.try_lock() {\n-            self.owner.store(this_thread, Relaxed);\n-            debug_assert_eq!(*self.lock_count.get(), 0);\n-            *self.lock_count.get() = 1;\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        let this_thread = current_thread_unique_ptr();\n-        if self.owner.load(Relaxed) == this_thread {\n-            self.increment_lock_count();\n-        } else {\n-            self.mutex.lock();\n-            self.owner.store(this_thread, Relaxed);\n-            debug_assert_eq!(*self.lock_count.get(), 0);\n-            *self.lock_count.get() = 1;\n-        }\n-    }\n-\n-    unsafe fn increment_lock_count(&self) {\n-        *self.lock_count.get() = (*self.lock_count.get())\n-            .checked_add(1)\n-            .expect(\"lock count overflow in reentrant mutex\");\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        *self.lock_count.get() -= 1;\n-        if *self.lock_count.get() == 0 {\n-            self.owner.store(0, Relaxed);\n-            self.mutex.unlock();\n-        }\n-    }\n-}\n-\n-/// Get an address that is unique per running thread.\n-///\n-/// This can be used as a non-null usize-sized ID.\n-pub fn current_thread_unique_ptr() -> usize {\n-    // Use a non-drop type to make sure it's still available during thread destruction.\n-    thread_local! { static X: u8 = const { 0 } }\n-    X.with(|x| <*const _>::addr(x))\n-}"}, {"sha": "17796f8894b5d049ad3a1478ab47d67fd70c79a2", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -5,15 +5,13 @@ cfg_if::cfg_if! {\n     ))] {\n         mod futex;\n         mod futex_rwlock;\n-        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar, ReentrantMutex};\n+        pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n         pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;\n-        mod pthread_remutex;\n         mod pthread_rwlock;\n         mod pthread_condvar;\n         pub use pthread_mutex::{Mutex, MovableMutex};\n-        pub use pthread_remutex::ReentrantMutex;\n         pub use pthread_rwlock::{RwLock, MovableRwLock};\n         pub use pthread_condvar::{Condvar, MovableCondvar};\n     }"}, {"sha": "b006181ee3a0d4b483d1e82af794662eb7b09dee", "filename": "library/std/src/sys/unix/locks/pthread_remutex.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/491f619f564a4ff9ae4cc837e27bb919d04c31be/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_remutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/491f619f564a4ff9ae4cc837e27bb919d04c31be/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_remutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_remutex.rs?ref=491f619f564a4ff9ae4cc837e27bb919d04c31be", "patch": "@@ -1,46 +0,0 @@\n-use super::pthread_mutex::PthreadMutexAttr;\n-use crate::cell::UnsafeCell;\n-use crate::mem::MaybeUninit;\n-use crate::sys::cvt_nz;\n-\n-pub struct ReentrantMutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n-    }\n-\n-    pub unsafe fn init(&self) {\n-        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n-        let attr = PthreadMutexAttr(&mut attr);\n-        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))\n-            .unwrap();\n-        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        let result = libc::pthread_mutex_lock(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        libc::pthread_mutex_trylock(self.inner.get()) == 0\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        let result = libc::pthread_mutex_unlock(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-\n-    pub unsafe fn destroy(&self) {\n-        let result = libc::pthread_mutex_destroy(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-}"}, {"sha": "d412ff152a047daa4a56475300d0eb164631f92a", "filename": "library/std/src/sys/unsupported/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmod.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -2,5 +2,5 @@ mod condvar;\n mod mutex;\n mod rwlock;\n pub use condvar::{Condvar, MovableCondvar};\n-pub use mutex::{MovableMutex, Mutex, ReentrantMutex};\n+pub use mutex::{MovableMutex, Mutex};\n pub use rwlock::{MovableRwLock, RwLock};"}, {"sha": "cad991aae5e961257ef56edccf0e06b36ba5fb8f", "filename": "library/std/src/sys/unsupported/locks/mutex.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Flocks%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -36,26 +36,3 @@ impl Mutex {\n     #[inline]\n     pub unsafe fn destroy(&self) {}\n }\n-\n-// All empty stubs because this platform does not yet support threads, so lock\n-// acquisition always succeeds.\n-pub struct ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex {}\n-    }\n-\n-    pub unsafe fn init(&self) {}\n-\n-    pub unsafe fn lock(&self) {}\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        true\n-    }\n-\n-    pub unsafe fn unlock(&self) {}\n-\n-    pub unsafe fn destroy(&self) {}\n-}"}, {"sha": "1acc8392444c181e7768dd95a5ca22066ce62632", "filename": "library/std/src/sys/wasm/atomics/mutex.rs", "status": "modified", "additions": 1, "deletions": 93, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -1,8 +1,6 @@\n use crate::arch::wasm32;\n-use crate::cell::UnsafeCell;\n use crate::mem;\n-use crate::sync::atomic::{AtomicU32, AtomicUsize, Ordering::SeqCst};\n-use crate::sys::thread;\n+use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n \n pub struct Mutex {\n     locked: AtomicUsize,\n@@ -64,93 +62,3 @@ impl Mutex {\n         self.locked.as_mut_ptr() as *mut i32\n     }\n }\n-\n-pub struct ReentrantMutex {\n-    owner: AtomicU32,\n-    recursions: UnsafeCell<u32>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-// Reentrant mutexes are similarly implemented to mutexes above except that\n-// instead of \"1\" meaning unlocked we use the id of a thread to represent\n-// whether it has locked a mutex. That way we have an atomic counter which\n-// always holds the id of the thread that currently holds the lock (or 0 if the\n-// lock is unlocked).\n-//\n-// Once a thread acquires a lock recursively, which it detects by looking at\n-// the value that's already there, it will update a local `recursions` counter\n-// in a nonatomic fashion (as we hold the lock). The lock is then fully\n-// released when this recursion counter reaches 0.\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { owner: AtomicU32::new(0), recursions: UnsafeCell::new(0) }\n-    }\n-\n-    pub unsafe fn init(&self) {\n-        // nothing to do...\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        let me = thread::my_id();\n-        while let Err(owner) = self._try_lock(me) {\n-            // SAFETY: the caller must guarantee that `self.ptr()` and `owner` are valid i32.\n-            let val = unsafe { wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1) };\n-            debug_assert!(val == 0 || val == 1);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        unsafe { self._try_lock(thread::my_id()).is_ok() }\n-    }\n-\n-    #[inline]\n-    unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n-        let id = id.checked_add(1).unwrap();\n-        match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n-            // we transitioned from unlocked to locked\n-            Ok(_) => {\n-                debug_assert_eq!(*self.recursions.get(), 0);\n-                Ok(())\n-            }\n-\n-            // we currently own this lock, so let's update our count and return\n-            // true.\n-            Err(n) if n == id => {\n-                *self.recursions.get() += 1;\n-                Ok(())\n-            }\n-\n-            // Someone else owns the lock, let our caller take care of it\n-            Err(other) => Err(other),\n-        }\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        // If we didn't ever recursively lock the lock then we fully unlock the\n-        // mutex and wake up a waiter, if any. Otherwise we decrement our\n-        // recursive counter and let some one else take care of the zero.\n-        match *self.recursions.get() {\n-            0 => {\n-                self.owner.swap(0, SeqCst);\n-                // SAFETY: the caller must guarantee that `self.ptr()` is valid i32.\n-                unsafe {\n-                    wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1);\n-                } // wake up one waiter, if any\n-            }\n-            ref mut n => *n -= 1,\n-        }\n-    }\n-\n-    pub unsafe fn destroy(&self) {\n-        // nothing to do...\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut i32 {\n-        self.owner.as_mut_ptr() as *mut i32\n-    }\n-}"}, {"sha": "5f14edaf067c096f66039e7502d4626440373a6d", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -536,15 +536,6 @@ pub struct CONDITION_VARIABLE {\n pub struct SRWLOCK {\n     pub ptr: LPVOID,\n }\n-#[repr(C)]\n-pub struct CRITICAL_SECTION {\n-    CriticalSectionDebug: LPVOID,\n-    LockCount: LONG,\n-    RecursionCount: LONG,\n-    OwningThread: HANDLE,\n-    LockSemaphore: HANDLE,\n-    SpinCount: ULONG_PTR,\n-}\n \n #[repr(C)]\n pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n@@ -875,11 +866,6 @@ if #[cfg(target_vendor = \"uwp\")] {\n #[link(name = \"kernel32\")]\n extern \"system\" {\n     pub fn GetCurrentProcessId() -> DWORD;\n-    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOL;\n-    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n     pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;"}, {"sha": "d412ff152a047daa4a56475300d0eb164631f92a", "filename": "library/std/src/sys/windows/locks/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmod.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -2,5 +2,5 @@ mod condvar;\n mod mutex;\n mod rwlock;\n pub use condvar::{Condvar, MovableCondvar};\n-pub use mutex::{MovableMutex, Mutex, ReentrantMutex};\n+pub use mutex::{MovableMutex, Mutex};\n pub use rwlock::{MovableRwLock, RwLock};"}, {"sha": "9fa280b8b765994fdb096a1317f4130f5198004c", "filename": "library/std/src/sys/windows/locks/mutex.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Flocks%2Fmutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -15,7 +15,6 @@\n //!    is that there are no guarantees of fairness.\n \n use crate::cell::UnsafeCell;\n-use crate::mem::MaybeUninit;\n use crate::sys::c;\n \n pub struct Mutex {\n@@ -60,37 +59,3 @@ impl Mutex {\n         // SRWLock does not need to be destroyed.\n     }\n }\n-\n-pub struct ReentrantMutex {\n-    inner: MaybeUninit<UnsafeCell<c::CRITICAL_SECTION>>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    pub const fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: MaybeUninit::uninit() }\n-    }\n-\n-    pub unsafe fn init(&self) {\n-        c::InitializeCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        c::EnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        c::TryEnterCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr())) != 0\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        c::LeaveCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n-    }\n-\n-    pub unsafe fn destroy(&self) {\n-        c::DeleteCriticalSection(UnsafeCell::raw_get(self.inner.as_ptr()));\n-    }\n-}"}, {"sha": "8f252308de760e8515212aaf4209ecfa9089b032", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 86, "deletions": 13, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fd7e9010db6be7605241c39eab7c5078ee2d5bd/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=6fd7e9010db6be7605241c39eab7c5078ee2d5bd", "patch": "@@ -1,19 +1,49 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n+use crate::cell::UnsafeCell;\n use crate::marker::PhantomPinned;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::pin::Pin;\n+use crate::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n use crate::sys::locks as sys;\n \n /// A re-entrant mutual exclusion\n ///\n /// This mutex will block *other* threads waiting for the lock to become\n /// available. The thread which has already locked the mutex can lock it\n /// multiple times without blocking, preventing a common source of deadlocks.\n+///\n+/// This is used by stdout().lock() and friends.\n+///\n+/// ## Implementation details\n+///\n+/// The 'owner' field tracks which thread has locked the mutex.\n+///\n+/// We use current_thread_unique_ptr() as the thread identifier,\n+/// which is just the address of a thread local variable.\n+///\n+/// If `owner` is set to the identifier of the current thread,\n+/// we assume the mutex is already locked and instead of locking it again,\n+/// we increment `lock_count`.\n+///\n+/// When unlocking, we decrement `lock_count`, and only unlock the mutex when\n+/// it reaches zero.\n+///\n+/// `lock_count` is protected by the mutex and only accessed by the thread that has\n+/// locked the mutex, so needs no synchronization.\n+///\n+/// `owner` can be checked by other threads that want to see if they already\n+/// hold the lock, so needs to be atomic. If it compares equal, we're on the\n+/// same thread that holds the mutex and memory access can use relaxed ordering\n+/// since we're not dealing with multiple threads. If it compares unequal,\n+/// synchronization is left to the mutex, making relaxed memory ordering for\n+/// the `owner` field fine in all cases.\n pub struct ReentrantMutex<T> {\n-    inner: sys::ReentrantMutex,\n+    mutex: sys::Mutex,\n+    owner: AtomicUsize,\n+    lock_count: UnsafeCell<u32>,\n     data: T,\n     _pinned: PhantomPinned,\n }\n@@ -53,7 +83,9 @@ impl<T> ReentrantMutex<T> {\n     /// lock/unlock methods safe.\n     pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n         ReentrantMutex {\n-            inner: sys::ReentrantMutex::uninitialized(),\n+            mutex: sys::Mutex::new(),\n+            owner: AtomicUsize::new(0),\n+            lock_count: UnsafeCell::new(0),\n             data: t,\n             _pinned: PhantomPinned,\n         }\n@@ -66,7 +98,7 @@ impl<T> ReentrantMutex<T> {\n     /// Unsafe to call more than once, and must be called after this will no\n     /// longer move in memory.\n     pub unsafe fn init(self: Pin<&mut Self>) {\n-        self.get_unchecked_mut().inner.init()\n+        self.get_unchecked_mut().mutex.init()\n     }\n \n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n@@ -82,7 +114,19 @@ impl<T> ReentrantMutex<T> {\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n     pub fn lock(self: Pin<&Self>) -> ReentrantMutexGuard<'_, T> {\n-        unsafe { self.inner.lock() }\n+        let this_thread = current_thread_unique_ptr();\n+        // Safety: We only touch lock_count when we own the lock,\n+        // and since self is pinned we can safely call the lock() on the mutex.\n+        unsafe {\n+            if self.owner.load(Relaxed) == this_thread {\n+                self.increment_lock_count();\n+            } else {\n+                self.mutex.lock();\n+                self.owner.store(this_thread, Relaxed);\n+                debug_assert_eq!(*self.lock_count.get(), 0);\n+                *self.lock_count.get() = 1;\n+            }\n+        }\n         ReentrantMutexGuard { lock: self }\n     }\n \n@@ -99,20 +143,35 @@ impl<T> ReentrantMutex<T> {\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n     pub fn try_lock(self: Pin<&Self>) -> Option<ReentrantMutexGuard<'_, T>> {\n-        if unsafe { self.inner.try_lock() } {\n-            Some(ReentrantMutexGuard { lock: self })\n-        } else {\n-            None\n+        let this_thread = current_thread_unique_ptr();\n+        // Safety: We only touch lock_count when we own the lock,\n+        // and since self is pinned we can safely call the try_lock on the mutex.\n+        unsafe {\n+            if self.owner.load(Relaxed) == this_thread {\n+                self.increment_lock_count();\n+                Some(ReentrantMutexGuard { lock: self })\n+            } else if self.mutex.try_lock() {\n+                self.owner.store(this_thread, Relaxed);\n+                debug_assert_eq!(*self.lock_count.get(), 0);\n+                *self.lock_count.get() = 1;\n+                Some(ReentrantMutexGuard { lock: self })\n+            } else {\n+                None\n+            }\n         }\n     }\n+\n+    unsafe fn increment_lock_count(&self) {\n+        *self.lock_count.get() = (*self.lock_count.get())\n+            .checked_add(1)\n+            .expect(\"lock count overflow in reentrant mutex\");\n+    }\n }\n \n impl<T> Drop for ReentrantMutex<T> {\n     fn drop(&mut self) {\n-        // This is actually safe b/c we know that there is no further usage of\n-        // this mutex (it's up to the user to arrange for a mutex to get\n-        // dropped, that's not our job)\n-        unsafe { self.inner.destroy() }\n+        // Safety: We're the unique owner of this mutex and not going to use it afterwards.\n+        unsafe { self.mutex.destroy() }\n     }\n }\n \n@@ -127,8 +186,22 @@ impl<T> Deref for ReentrantMutexGuard<'_, T> {\n impl<T> Drop for ReentrantMutexGuard<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n+        // Safety: We own the lock, and the lock is pinned.\n         unsafe {\n-            self.lock.inner.unlock();\n+            *self.lock.lock_count.get() -= 1;\n+            if *self.lock.lock_count.get() == 0 {\n+                self.lock.owner.store(0, Relaxed);\n+                self.lock.mutex.unlock();\n+            }\n         }\n     }\n }\n+\n+/// Get an address that is unique per running thread.\n+///\n+/// This can be used as a non-null usize-sized ID.\n+pub fn current_thread_unique_ptr() -> usize {\n+    // Use a non-drop type to make sure it's still available during thread destruction.\n+    thread_local! { static X: u8 = const { 0 } }\n+    X.with(|x| <*const _>::addr(x))\n+}"}]}