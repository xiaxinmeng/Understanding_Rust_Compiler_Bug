{"sha": "045916603ed55c95169770ed4423d5da18411335", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NTkxNjYwM2VkNTVjOTUxNjk3NzBlZDQ0MjNkNWRhMTg0MTEzMzU=", "commit": {"author": {"name": "Geoffry Song", "email": "goffrie@gmail.com", "date": "2017-10-15T19:00:22Z"}, "committer": {"name": "Geoffry Song", "email": "goffrie@gmail.com", "date": "2017-10-15T19:58:05Z"}, "message": "Add test for #40003.", "tree": {"sha": "effc7e7ac0aad2bcc3d725769e72ff1edcdb26ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/effc7e7ac0aad2bcc3d725769e72ff1edcdb26ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/045916603ed55c95169770ed4423d5da18411335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/045916603ed55c95169770ed4423d5da18411335", "html_url": "https://github.com/rust-lang/rust/commit/045916603ed55c95169770ed4423d5da18411335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/045916603ed55c95169770ed4423d5da18411335/comments", "author": {"login": "goffrie", "id": 1240398, "node_id": "MDQ6VXNlcjEyNDAzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1240398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goffrie", "html_url": "https://github.com/goffrie", "followers_url": "https://api.github.com/users/goffrie/followers", "following_url": "https://api.github.com/users/goffrie/following{/other_user}", "gists_url": "https://api.github.com/users/goffrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/goffrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goffrie/subscriptions", "organizations_url": "https://api.github.com/users/goffrie/orgs", "repos_url": "https://api.github.com/users/goffrie/repos", "events_url": "https://api.github.com/users/goffrie/events{/privacy}", "received_events_url": "https://api.github.com/users/goffrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "goffrie", "id": 1240398, "node_id": "MDQ6VXNlcjEyNDAzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/1240398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/goffrie", "html_url": "https://github.com/goffrie", "followers_url": "https://api.github.com/users/goffrie/followers", "following_url": "https://api.github.com/users/goffrie/following{/other_user}", "gists_url": "https://api.github.com/users/goffrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/goffrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/goffrie/subscriptions", "organizations_url": "https://api.github.com/users/goffrie/orgs", "repos_url": "https://api.github.com/users/goffrie/repos", "events_url": "https://api.github.com/users/goffrie/events{/privacy}", "received_events_url": "https://api.github.com/users/goffrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2689fd2402590961dae32f35369a8685c89022fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2689fd2402590961dae32f35369a8685c89022fb", "html_url": "https://github.com/rust-lang/rust/commit/2689fd2402590961dae32f35369a8685c89022fb"}], "stats": {"total": 186, "additions": 186, "deletions": 0}, "files": [{"sha": "103a365af0eb3cf0dfa8d2af37cbe2ec2cfed6d8", "filename": "src/test/run-pass/issue-40003.rs", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/045916603ed55c95169770ed4423d5da18411335/src%2Ftest%2Frun-pass%2Fissue-40003.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045916603ed55c95169770ed4423d5da18411335/src%2Ftest%2Frun-pass%2Fissue-40003.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-40003.rs?ref=045916603ed55c95169770ed4423d5da18411335", "patch": "@@ -0,0 +1,186 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    if false { test(); }\n+}\n+\n+fn test() {\n+    let rx = Err::<Vec<usize>, u32>(1).into_future();\n+\n+    rx.map(|l: Vec<usize>| stream::iter(l.into_iter().map(|i| Ok(i))))\n+      .flatten_stream()\n+      .chunks(50)\n+      .buffer_unordered(5);\n+}\n+\n+use future::{Future, IntoFuture};\n+mod future {\n+    use std::result;\n+\n+    use {stream, Stream};\n+\n+    pub trait Future {\n+        type Item;\n+        type Error;\n+\n+        fn map<F, U>(self, _: F) -> Map<Self, F>\n+            where F: FnOnce(Self::Item) -> U,\n+                  Self: Sized,\n+        {\n+            panic!()\n+        }\n+\n+        fn flatten_stream(self) -> FlattenStream<Self>\n+            where <Self as Future>::Item: stream::Stream<Error=Self::Error>,\n+                  Self: Sized\n+        {\n+            panic!()\n+        }\n+    }\n+\n+    pub trait IntoFuture {\n+        type Future: Future<Item=Self::Item, Error=Self::Error>;\n+        type Item;\n+        type Error;\n+        fn into_future(self) -> Self::Future;\n+    }\n+\n+    impl<F: Future> IntoFuture for F {\n+        type Future = F;\n+        type Item = F::Item;\n+        type Error = F::Error;\n+\n+        fn into_future(self) -> F {\n+            panic!()\n+        }\n+    }\n+\n+    impl<T, E> IntoFuture for result::Result<T, E> {\n+        type Future = FutureResult<T, E>;\n+        type Item = T;\n+        type Error = E;\n+\n+        fn into_future(self) -> FutureResult<T, E> {\n+            panic!()\n+        }\n+    }\n+\n+    pub struct Map<A, F> {\n+        _a: (A, F),\n+    }\n+\n+    impl<U, A, F> Future for Map<A, F>\n+        where A: Future,\n+              F: FnOnce(A::Item) -> U,\n+    {\n+        type Item = U;\n+        type Error = A::Error;\n+    }\n+\n+    pub struct FlattenStream<F> {\n+        _f: F,\n+    }\n+\n+    impl<F> Stream for FlattenStream<F>\n+        where F: Future,\n+              <F as Future>::Item: Stream<Error=F::Error>,\n+    {\n+        type Item = <F::Item as Stream>::Item;\n+        type Error = <F::Item as Stream>::Error;\n+    }\n+\n+    pub struct FutureResult<T, E> {\n+        _inner: (T, E),\n+    }\n+\n+    impl<T, E> Future for FutureResult<T, E> {\n+        type Item = T;\n+        type Error = E;\n+    }\n+}\n+\n+mod stream {\n+    use IntoFuture;\n+\n+    pub trait Stream {\n+        type Item;\n+        type Error;\n+\n+        fn buffer_unordered(self, amt: usize) -> BufferUnordered<Self>\n+            where Self::Item: IntoFuture<Error = <Self as Stream>::Error>,\n+                  Self: Sized\n+        {\n+            new(self, amt)\n+        }\n+\n+        fn chunks(self, _capacity: usize) -> Chunks<Self>\n+            where Self: Sized\n+        {\n+            panic!()\n+        }\n+    }\n+\n+    pub struct IterStream<I> {\n+        _iter: I,\n+    }\n+\n+    pub fn iter<J, T, E>(_: J) -> IterStream<J::IntoIter>\n+        where J: IntoIterator<Item=Result<T, E>>,\n+    {\n+        panic!()\n+    }\n+\n+    impl<I, T, E> Stream for IterStream<I>\n+        where I: Iterator<Item=Result<T, E>>,\n+    {\n+        type Item = T;\n+        type Error = E;\n+    }\n+\n+    pub struct Chunks<S> {\n+        _stream: S\n+    }\n+\n+    impl<S> Stream for Chunks<S>\n+        where S: Stream\n+    {\n+        type Item = Result<Vec<<S as Stream>::Item>, u32>;\n+        type Error = <S as Stream>::Error;\n+    }\n+\n+    pub struct BufferUnordered<S> {\n+        _stream: S,\n+    }\n+\n+    enum Slot<T> {\n+        Next(usize),\n+        _Data { _a: T },\n+    }\n+\n+    fn new<S>(_s: S, _amt: usize) -> BufferUnordered<S>\n+        where S: Stream,\n+              S::Item: IntoFuture<Error=<S as Stream>::Error>,\n+    {\n+        (0..0).map(|_| {\n+            Slot::Next::<<S::Item as IntoFuture>::Future>(1)\n+        }).collect::<Vec<_>>();\n+        panic!()\n+    }\n+\n+    impl<S> Stream for BufferUnordered<S>\n+        where S: Stream,\n+              S::Item: IntoFuture<Error=<S as Stream>::Error>,\n+    {\n+        type Item = <S::Item as IntoFuture>::Item;\n+        type Error = <S as Stream>::Error;\n+    }\n+}\n+use stream::Stream;"}]}