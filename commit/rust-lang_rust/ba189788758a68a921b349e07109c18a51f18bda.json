{"sha": "ba189788758a68a921b349e07109c18a51f18bda", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTg5Nzg4NzU4YTY4YTkyMWIzNDllMDcxMDljMThhNTFmMThiZGE=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-08-06T05:53:11Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-08-14T09:24:35Z"}, "message": "LLVM IR coverage encoding aligns closer to Clang's\n\nI found some areas for improvement while attempting to debug the\nSegFault issue when running rust programs compiled using MSVC, with\ncoverage instrumentation.\n\nI discovered that LLVM's coverage writer was generating incomplete\nfunction name variable names (that's not a typo: the name of the\nvariable that holds a function name).\n\nThe existing implementation used one-up numbers to distinguish\nvariables, and correcting the names did not fix the MSVC coverage bug,\nbut the fix in this PR makes the names and resulting LLVM IR easier to\nfollow and more consistent with Clang's implementation.\n\nI also changed the way the `-Zinstrument-coverage` option is supported\nin symbol_export.rs. The original implementation was incorrect, and the\ncorrected version matches the handling for `-Zprofile-generate`, as it\nturns out.\n\n(An argument could be made that maybe `-Zinstrument-coverage` should\nautomatically enable `-Cprofile-generate`. In fact, if\n`-Cprofile-generate` is analagous to Clang's `-fprofile-generate`, as\nsome documentation implies, Clang always requires this flag for its\nimplementation of source-based code coverage. This would require a\nlittle more validation, and if implemented, would probably require\nupdating some of the user-facing messages related to\n`-Cprofile-generate` to not be so specific to the PGO use case.)\n\nNone of these changes fixed the MSVC coverage problems, but they should\nstill be welcome improvements.\n\nLastly, I added some additional FIXME comments in instrument_coverage.rs\ndescribing issues I found with the generated LLVM IR that would be\nresolved if the coverage instrumentation is injected with a `Statement`\ninstead of as a new `BasicBlock`. I describe seven advantages of this\nchange, but it requires some discussion before making a change like\nthis.", "tree": {"sha": "7b44011480a266b05777fbcc1aee0597edfb7270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b44011480a266b05777fbcc1aee0597edfb7270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba189788758a68a921b349e07109c18a51f18bda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba189788758a68a921b349e07109c18a51f18bda", "html_url": "https://github.com/rust-lang/rust/commit/ba189788758a68a921b349e07109c18a51f18bda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba189788758a68a921b349e07109c18a51f18bda/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cfc7fe78eccc754b16981704a098d7bd520e2fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cfc7fe78eccc754b16981704a098d7bd520e2fd", "html_url": "https://github.com/rust-lang/rust/commit/3cfc7fe78eccc754b16981704a098d7bd520e2fd"}], "stats": {"total": 200, "additions": 161, "deletions": 39}, "files": [{"sha": "431acbb1f7e1606dbdfeb52deb2a6b8decb4c8e2", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -8,7 +8,7 @@ use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage, Region};\n use rustc_codegen_ssa::traits::{\n-    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n+    BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, MiscMethods, StaticMethods,\n };\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n@@ -44,6 +44,16 @@ impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n }\n \n impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    /// Calls llvm::createPGOFuncNameVar() with the given function instance's mangled function name.\n+    /// The LLVM API returns an llvm::GlobalVariable containing the function name, with the specific\n+    /// variable name and linkage required by LLVM InstrProf source-based coverage instrumentation.\n+    fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value {\n+        let llfn = self.cx.get_fn(instance);\n+        let mangled_fn_name = CString::new(self.tcx.symbol_name(instance).name)\n+            .expect(\"error converting function name to C string\");\n+        unsafe { llvm::LLVMRustCoverageCreatePGOFuncNameVar(llfn, mangled_fn_name.as_ptr()) }\n+    }\n+\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,"}, {"sha": "14aec1ff5e19e66e633f8e1115692ecc75fa3023", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -215,19 +215,19 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             sym::count_code_region => {\n-                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n-                let mangled_fn = tcx.symbol_name(caller_instance);\n-                let (mangled_fn_name, _len_val) = self.const_str(Symbol::intern(mangled_fn.name));\n-                let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n+                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n+\n+                let fn_name = self.create_pgo_func_name_var(caller_instance);\n                 let hash = args[FUNCTION_SOURCE_HASH].immediate();\n+                let num_counters = self.const_u32(coverageinfo.num_counters);\n                 let index = args[COUNTER_ID].immediate();\n                 debug!(\n                     \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n-                    instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    mangled_fn.name, hash, num_counters, index,\n+                    instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    fn_name, hash, num_counters, index,\n                 );\n-                self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n+                self.instrprof_increment(fn_name, hash, num_counters, index)\n             }\n             sym::va_start => self.va_start(args[0].immediate()),\n             sym::va_end => self.va_end(args[0].immediate()),"}, {"sha": "a1c1ed9856d678680466765433dd50d1d7b97710", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -1802,6 +1802,8 @@ extern \"C\" {\n         BufferOut: &RustString,\n     );\n \n+    pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n+    -> &'a Value;\n     pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n \n     #[allow(improper_ctypes)]"}, {"sha": "e7c789ad210267e5fb9c7a9a3f5bb4603dd5d314", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -190,7 +190,9 @@ fn exported_symbols_provider_local(\n         }\n     }\n \n-    if tcx.sess.opts.cg.profile_generate.enabled() {\n+    if tcx.sess.opts.debugging_opts.instrument_coverage\n+        || tcx.sess.opts.cg.profile_generate.enabled()\n+    {\n         // These are weak symbols that point to the profile version and the\n         // profile name, which need to be treated as exported so LTO doesn't nix\n         // them.\n@@ -203,17 +205,6 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.opts.debugging_opts.instrument_coverage {\n-        // Similar to PGO profiling, preserve symbols used by LLVM InstrProf coverage profiling.\n-        const COVERAGE_WEAK_SYMBOLS: [&str; 3] =\n-            [\"__llvm_profile_filename\", \"__llvm_coverage_mapping\", \"__llvm_covmap\"];\n-\n-        symbols.extend(COVERAGE_WEAK_SYMBOLS.iter().map(|sym| {\n-            let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, sym));\n-            (exported_symbol, SymbolExportLevel::C)\n-        }));\n-    }\n-\n     if tcx.sess.opts.debugging_opts.sanitizer.contains(SanitizerSet::MEMORY) {\n         // Similar to profiling, preserve weak msan symbol during LTO.\n         const MSAN_WEAK_SYMBOLS: [&str; 2] = [\"__msan_track_origins\", \"__msan_keep_going\"];"}, {"sha": "5602599b0c25b579aaaef4fb560344444dd7504f", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -7,6 +7,8 @@ pub trait CoverageInfoMethods: BackendTypes {\n }\n \n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n+    fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n+\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,"}, {"sha": "500d66ece0676312e08461c17b9e24e11f515446", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -295,6 +295,21 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n \n         let (file_name, start_line, start_col, end_line, end_col) = self.code_region(&span);\n \n+        // FIXME(richkadel): Note that `const_str()` results in the creation of an `Allocation` to\n+        // hold one copy of each unique filename. It looks like that `Allocation` may translate into\n+        // the creation of an `@alloc` in LLVM IR that is never actually used by runtime code.\n+        //\n+        // Example LLVM IR:\n+        //\n+        // @alloc4 = private unnamed_addr constant <{ [43 x i8] }> \\\n+        //   <{ [43 x i8] c\"C:\\\\msys64\\\\home\\\\richkadel\\\\rust\\\\rust_basic.rs\" }>, align 1\n+        //\n+        // Can I flag the alloc as something not to be added to codegen? Or somehow remove it before\n+        // it gets added to the LLVM IR? Do we need some kind of reference counting to know it's\n+        // not used by any runtime code?\n+        //\n+        // This question is moot if I convert the Call Terminators to Statements, I believe:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20LLVM-compatible.20source-based.20cod.20compiler-team.23278/near/206731748\n         args.push(self.const_str(&file_name, inject_at));\n         args.push(self.const_u32(start_line, inject_at));\n         args.push(self.const_u32(start_col, inject_at));"}, {"sha": "4d15e31df15a3edbe90d443e8833e47b2e1bb65f", "filename": "src/rustllvm/CoverageMappingWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Frustllvm%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FCoverageMappingWrapper.cpp?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -38,6 +38,11 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   CoverageMappingWriter.write(OS);\n }\n \n+extern \"C\" LLVMValueRef LLVMRustCoverageCreatePGOFuncNameVar(LLVMValueRef F, const char *FuncName) {\n+  StringRef FuncNameRef(FuncName);\n+  return wrap(createPGOFuncNameVar(*cast<Function>(unwrap(F)), FuncNameRef));\n+}\n+\n extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n   StringRef NameRef(Name);\n   return IndexedInstrProf::ComputeHash(NameRef);"}, {"sha": "4392cfec080dcb0fdcef38d0de01feb6d3ccc6df", "filename": "src/test/run-make-fulldeps/instrument-coverage/Makefile", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2FMakefile?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -3,55 +3,101 @@\n \n # FIXME(richkadel): Debug the following problem, and reenable on Windows (by\n # removing the `# ignore-msvc` directive above). The current implementation\n-# generates a segfault when running the instrumented `main` executable,\n-# after the `main` program code executes, but before the process terminates.\n-# This most likely points to a problem generating the LLVM \"main.profraw\"\n+# generates a segfault when running the instrumented `testprog` executable,\n+# after the `main()` function completes, but before the process terminates.\n+# This most likely points to a problem generating the LLVM \"testprog.profraw\"\n # file.\n \n -include ../tools.mk\n \n+UNAME = $(shell uname)\n+\n+ifeq ($(UNAME),Darwin)\n+\tINSTR_PROF_DATA_SUFFIX=,regular,live_support\n+\tDATA_SECTION_PREFIX=__DATA,\n+\tLLVM_COV_SECTION_PREFIX=__LLVM_COV,\n+else\n+\tINSTR_PROF_DATA_SUFFIX=\n+\tDATA_SECTION_PREFIX=\n+\tLLVM_COV_SECTION_PREFIX=\n+endif\n+\n # This test makes sure that LLVM coverage maps are genereated in LLVM IR.\n \n COMMON_FLAGS=-Zinstrument-coverage\n \n all:\n \t# Compile the test program with instrumentation, and also generate LLVM IR\n-\t$(RUSTC) $(COMMON_FLAGS) main.rs\n+\t$(RUSTC) $(COMMON_FLAGS) testprog.rs \\\n+\t\t\t--emit=link,llvm-ir\n+\n+\t# check the LLVM IR\n+ifdef IS_WIN32\n+\tcat \"$(TMPDIR)\"/testprog.ll | \"$(LLVM_FILECHECK)\" filecheck-patterns.txt \\\n+\t\t\t-check-prefixes=CHECK,WIN32 \\\n+\t\t\t-DPRIVATE_GLOBAL=\"internal global\" \\\n+\t\t\t-DINSTR_PROF_DATA=\".lprfd$$M\" \\\n+\t\t\t-DINSTR_PROF_NAME=\".lprfn$$M\" \\\n+\t\t\t-DINSTR_PROF_CNTS=\".lprfc$$M\" \\\n+\t\t\t-DINSTR_PROF_VALS=\".lprfv$$M\" \\\n+\t\t\t-DINSTR_PROF_VNODES=\".lprfnd$$M\" \\\n+\t\t\t-DINSTR_PROF_COVMAP=\".lcovmap$$M\" \\\n+\t\t\t-DINSTR_PROF_ORDERFILE=\".lorderfile$$M\"\n+else\n+\tcat \"$(TMPDIR)\"/testprog.ll | \"$(LLVM_FILECHECK)\" filecheck-patterns.txt \\\n+\t\t\t-check-prefixes=CHECK \\\n+\t\t\t-DPRIVATE_GLOBAL=\"private global\" \\\n+\t\t\t-DINSTR_PROF_DATA=\"$(DATA_SECTION_PREFIX)__llvm_prf_data$(INSTR_PROF_DATA_SUFFIX)\" \\\n+\t\t\t-DINSTR_PROF_NAME=\"$(DATA_SECTION_PREFIX)__llvm_prf_names\" \\\n+\t\t\t-DINSTR_PROF_CNTS=\"$(DATA_SECTION_PREFIX)__llvm_prf_cnts\" \\\n+\t\t\t-DINSTR_PROF_VALS=\"$(DATA_SECTION_PREFIX)__llvm_prf_vals\" \\\n+\t\t\t-DINSTR_PROF_VNODES=\"$(DATA_SECTION_PREFIX)__llvm_prf_vnds\" \\\n+\t\t\t-DINSTR_PROF_COVMAP=\"$(LLVM_COV_SECTION_PREFIX)__llvm_covmap\" \\\n+\t\t\t-DINSTR_PROF_ORDERFILE=\"$(DATA_SECTION_PREFIX)__llvm_orderfile\"\n+endif\n \n \t# Run it in order to generate some profiling data,\n \t# with `LLVM_PROFILE_FILE=<profdata_file>` environment variable set to\n \t# output the coverage stats for this run.\n-\tLLVM_PROFILE_FILE=\"$(TMPDIR)\"/main.profraw \\\n-\t  $(call RUN,main)\n+\tLLVM_PROFILE_FILE=\"$(TMPDIR)\"/testprog.profraw \\\n+\t\t\t$(call RUN,testprog)\n \n \t# Postprocess the profiling data so it can be used by the llvm-cov tool\n \t\"$(LLVM_BIN_DIR)\"/llvm-profdata merge --sparse \\\n-\t  \"$(TMPDIR)\"/main.profraw \\\n-\t\t-o \"$(TMPDIR)\"/main.profdata\n+\t\t\t\"$(TMPDIR)\"/testprog.profraw \\\n+\t\t\t-o \"$(TMPDIR)\"/testprog.profdata\n \n \t# Generate a coverage report using `llvm-cov show`. The output ordering\n \t# can be non-deterministic, so ignore the return status. If the test fails\n \t# when comparing the JSON `export`, the `show` output may be useful when\n \t# debugging.\n \t\"$(LLVM_BIN_DIR)\"/llvm-cov show \\\n-\t  --Xdemangler=\"$(RUST_DEMANGLER)\" \\\n-\t  --show-line-counts-or-regions \\\n-\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n-\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t\t--Xdemangler=\"$(RUST_DEMANGLER)\" \\\n+\t\t\t--show-line-counts-or-regions \\\n+\t\t\t--instr-profile=\"$(TMPDIR)\"/testprog.profdata \\\n+\t\t\t$(call BIN,\"$(TMPDIR)\"/testprog) \\\n \t\t> \"$(TMPDIR)\"/actual_show_coverage.txt\n \n+ifdef RUSTC_BLESS_TEST\n+\tcp \"$(TMPDIR)\"/actual_show_coverage.txt typical_show_coverage.txt\n+else\n \t# Compare the show coverage output\n \t$(DIFF) typical_show_coverage.txt \"$(TMPDIR)\"/actual_show_coverage.txt || \\\n-\t  >&2 echo 'diff failed for `llvm-cov show` (might not be an error)'\n+\t\t>&2 echo 'diff failed for `llvm-cov show` (might not be an error)'\n+endif\n \n \t# Generate a coverage report in JSON, using `llvm-cov export`, and fail if\n \t# there are differences from the expected output.\n \t\"$(LLVM_BIN_DIR)\"/llvm-cov export \\\n-\t  --summary-only \\\n-\t  --instr-profile=\"$(TMPDIR)\"/main.profdata \\\n-\t\t$(call BIN,\"$(TMPDIR)\"/main) \\\n+\t\t\t--summary-only \\\n+\t\t\t--instr-profile=\"$(TMPDIR)\"/testprog.profdata \\\n+\t\t\t$(call BIN,\"$(TMPDIR)\"/testprog) \\\n \t\t| \"$(PYTHON)\" prettify_json.py \\\n \t\t> \"$(TMPDIR)\"/actual_export_coverage.json\n \n+ifdef RUSTC_BLESS_TEST\n+\tcp \"$(TMPDIR)\"/actual_export_coverage.json expected_export_coverage.json\n+else\n \t# Check that the exported JSON coverage data matches what we expect\n \t$(DIFF) expected_export_coverage.json \"$(TMPDIR)\"/actual_export_coverage.json\n+endif"}, {"sha": "5881cf4b7dbbc6eefa64b4f83e9a26b17e1bb830", "filename": "src/test/run-make-fulldeps/instrument-coverage/expected_export_coverage.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Fexpected_export_coverage.json?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -3,7 +3,7 @@\n     {\n       \"files\": [\n         {\n-          \"filename\": \"main.rs\",\n+          \"filename\": \"testprog.rs\",\n           \"summary\": {\n             \"functions\": {\n               \"count\": 7,"}, {"sha": "5a7cc9a188202a338c15e7d27d4914cba4b850a7", "filename": "src/test/run-make-fulldeps/instrument-coverage/filecheck-patterns.txt", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ffilecheck-patterns.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ffilecheck-patterns.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ffilecheck-patterns.txt?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -0,0 +1,51 @@\n+# Check for metadata, variables, declarations, and function definitions injected\n+# into LLVM IR when compiling with -Zinstrument-coverage.\n+\n+WIN32:      $__llvm_profile_runtime_user = comdat any\n+\n+CHECK:      @__llvm_coverage_mapping = internal constant\n+CHECK-SAME: section \"[[INSTR_PROF_COVMAP]]\", align 8\n+\n+WIN32:      @__llvm_profile_runtime = external global i32\n+\n+CHECK:      @__profc__R{{[a-zA-Z0-9_]+}}testprog14will_be_called = [[PRIVATE_GLOBAL]]\n+CHECK-SAME: section \"[[INSTR_PROF_CNTS]]\", align 8\n+\n+CHECK:      @__profd__R{{[a-zA-Z0-9_]+}}testprog14will_be_called = [[PRIVATE_GLOBAL]]\n+CHECK-SAME: @__profc__R{{[a-zA-Z0-9_]+}}testprog14will_be_called,\n+CHECK-SAME: ()* @_R{{[a-zA-Z0-9_]+}}testprog14will_be_called to i8*),\n+CHECK-SAME: section \"[[INSTR_PROF_DATA]]\", align 8\n+\n+CHECK:      @__profc__R{{[a-zA-Z0-9_]+}}testprog4main = [[PRIVATE_GLOBAL]]\n+CHECK-SAME: section \"[[INSTR_PROF_CNTS]]\", align 8\n+\n+CHECK:      @__profd__R{{[a-zA-Z0-9_]+}}testprog4main = [[PRIVATE_GLOBAL]]\n+CHECK-SAME: @__profc__R{{[a-zA-Z0-9_]+}}testprog4main,\n+CHECK-SAME: ()* @_R{{[a-zA-Z0-9_]+}}testprog4main to i8*),\n+CHECK-SAME: section \"[[INSTR_PROF_DATA]]\", align 8\n+\n+CHECK:      @__llvm_prf_nm = private constant\n+CHECK-SAME: section \"[[INSTR_PROF_NAME]]\", align 1\n+\n+CHECK:      @llvm.used = appending global\n+CHECK-SAME: i8* bitcast ({ {{.*}} }* @__llvm_coverage_mapping to i8*)\n+WIN32-SAME: i8* bitcast (i32 ()* @__llvm_profile_runtime_user to i8*)\n+CHECK-SAME: i8* bitcast ({ {{.*}} }* @__profd__R{{[a-zA-Z0-9_]*}}testprog4main to i8*)\n+CHECK-SAME: i8* getelementptr inbounds ({{.*}}* @__llvm_prf_nm, i32 0, i32 0)\n+CHECK-SAME: section \"llvm.metadata\"\n+\n+CHECK:      define hidden { {{.*}} } @_R{{[a-zA-Z0-9_]+}}testprog14will_be_called() unnamed_addr #{{[0-9]+}} {\n+CHECK-NEXT: start:\n+CHECK-NOT:  bb{{[0-9]+}}:\n+CHECK:      %pgocount = load i64, i64* getelementptr inbounds\n+CHECK-SAME: * @__profc__R{{[a-zA-Z0-9_]+}}testprog14will_be_called,\n+\n+CHECK:      declare void @llvm.instrprof.increment(i8*, i64, i32, i32) #[[LLVM_INSTRPROF_INCREMENT_ATTR:[0-9]+]]\n+\n+WIN32:      define linkonce_odr hidden i32 @__llvm_profile_runtime_user() #[[LLVM_PROFILE_RUNTIME_USER_ATTR:[0-9]+]] comdat {\n+WIN32-NEXT: %1 = load i32, i32* @__llvm_profile_runtime\n+WIN32-NEXT: ret i32 %1\n+WIN32-NEXT: }\n+\n+CHECK:      attributes #[[LLVM_INSTRPROF_INCREMENT_ATTR]] = { nounwind }\n+WIN32:      attributes #[[LLVM_PROFILE_RUNTIME_USER_ATTR]] = { noinline }\n\\ No newline at end of file"}, {"sha": "358c25677ae1d1561f528d395e563852e898f17f", "filename": "src/test/run-make-fulldeps/instrument-coverage/testprog.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftestprog.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftestprog.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftestprog.rs?ref=ba189788758a68a921b349e07109c18a51f18bda", "previous_filename": "src/test/run-make-fulldeps/instrument-coverage/main.rs"}, {"sha": "ae123afff04000652fa3feee1e539d007bf267a4", "filename": "src/test/run-make-fulldeps/instrument-coverage/typical_show_coverage.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "raw_url": "https://github.com/rust-lang/rust/raw/ba189788758a68a921b349e07109c18a51f18bda/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Finstrument-coverage%2Ftypical_show_coverage.txt?ref=ba189788758a68a921b349e07109c18a51f18bda", "patch": "@@ -25,14 +25,14 @@\n    25|      2|    }\n    26|      2|}\n   ------------------\n-  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#0}, &str>:\n+  | testprog[317d481089b8c8fe]::wrap_with::<testprog[317d481089b8c8fe]::main::{closure#0}, &str>:\n   |   22|      1|{\n   |   23|      1|    if should_wrap {\n   |   24|      1|        wrapper(&inner)\n   |   25|      1|    }\n   |   26|      1|}\n   ------------------\n-  | main[317d481089b8c8fe]::wrap_with::<main[317d481089b8c8fe]::main::{closure#1}, &str>:\n+  | testprog[317d481089b8c8fe]::wrap_with::<testprog[317d481089b8c8fe]::main::{closure#1}, &str>:\n   |   22|      1|{\n   |   23|      1|    if should_wrap {\n   |   24|      1|        wrapper(&inner)"}]}