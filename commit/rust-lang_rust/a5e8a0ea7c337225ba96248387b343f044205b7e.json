{"sha": "a5e8a0ea7c337225ba96248387b343f044205b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZThhMGVhN2MzMzcyMjViYTk2MjQ4Mzg3YjM0M2YwNDQyMDViN2U=", "commit": {"author": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-10-10T01:12:11Z"}, "committer": {"name": "Christopher Vittal", "email": "christopher.vittal@gmail.com", "date": "2017-10-10T03:22:28Z"}, "message": "Modify MIR testing to require continuous lines\n\nMir testing now requires that lines be continuous. To achive this,\ninstead of collecting the expected mir as a string, it is now wrapped in\nan `ExpectedLine` enum, that is either `Elision` or `Text(T)` where `T:\nAsRef<str>`. `Text` lines must be matched in order, unless separated by\n`Elision` lines. Matches occur greedily, that is, an Elision will skip\nas few lines as possible.\n\nTo add a new elision marker. Put a comment containing only \"...\" and\nwhitespace in any MIR testing block. Like so:\n\n```\n// fn write_42(_1: *mut i32) -> bool {\n//     ...\n//     bb0: {\n//         Validate(Acquire, [_1: *mut i32]);\n//         Validate(Release, [_1: *mut i32]);\n//         ...\n//         return;\n//     }\n// }\n```\n\nRight now, all input before the line right after `// START` is elided,\nand all input after the line right before `// END` is also not tested.\n\nMany tests need to be updated. That will follow in the next commit.\n\ncc #45153", "tree": {"sha": "00bbb69aa5ee49884778727a37705bb988786463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00bbb69aa5ee49884778727a37705bb988786463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5e8a0ea7c337225ba96248387b343f044205b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e8a0ea7c337225ba96248387b343f044205b7e", "html_url": "https://github.com/rust-lang/rust/commit/a5e8a0ea7c337225ba96248387b343f044205b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5e8a0ea7c337225ba96248387b343f044205b7e/comments", "author": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chrisvittal", "id": 15916123, "node_id": "MDQ6VXNlcjE1OTE2MTIz", "avatar_url": "https://avatars.githubusercontent.com/u/15916123?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chrisvittal", "html_url": "https://github.com/chrisvittal", "followers_url": "https://api.github.com/users/chrisvittal/followers", "following_url": "https://api.github.com/users/chrisvittal/following{/other_user}", "gists_url": "https://api.github.com/users/chrisvittal/gists{/gist_id}", "starred_url": "https://api.github.com/users/chrisvittal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chrisvittal/subscriptions", "organizations_url": "https://api.github.com/users/chrisvittal/orgs", "repos_url": "https://api.github.com/users/chrisvittal/repos", "events_url": "https://api.github.com/users/chrisvittal/events{/privacy}", "received_events_url": "https://api.github.com/users/chrisvittal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "692b94ae25e0ae7d74cf15a5800e10a16239dab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/692b94ae25e0ae7d74cf15a5800e10a16239dab1", "html_url": "https://github.com/rust-lang/rust/commit/692b94ae25e0ae7d74cf15a5800e10a16239dab1"}], "stats": {"total": 126, "additions": 94, "deletions": 32}, "files": [{"sha": "400599923ffeaa5683dd2f6b1c128aeaf293e5ef", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 94, "deletions": 32, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a5e8a0ea7c337225ba96248387b343f044205b7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5e8a0ea7c337225ba96248387b343f044205b7e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a5e8a0ea7c337225ba96248387b343f044205b7e", "patch": "@@ -25,6 +25,7 @@ use std::collections::HashSet;\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File, create_dir_all};\n+use std::fmt;\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n@@ -2237,7 +2238,7 @@ actual:\\n\\\n             let (_, tests_text) = test_file_contents.split_at(idx + \"// END_RUST SOURCE\".len());\n             let tests_text_str = String::from(tests_text);\n             let mut curr_test : Option<&str> = None;\n-            let mut curr_test_contents = Vec::new();\n+            let mut curr_test_contents = vec![ExpectedLine::Elision];\n             for l in tests_text_str.lines() {\n                 debug!(\"line: {:?}\", l);\n                 if l.starts_with(\"// START \") {\n@@ -2251,11 +2252,14 @@ actual:\\n\\\n                     self.compare_mir_test_output(curr_test.unwrap(), &curr_test_contents);\n                     curr_test = None;\n                     curr_test_contents.clear();\n+                    curr_test_contents.push(ExpectedLine::Elision);\n                 } else if l.is_empty() {\n                     // ignore\n+                } else if l.starts_with(\"//\") && l.split_at(\"//\".len()).1.trim() == \"...\" {\n+                    curr_test_contents.push(ExpectedLine::Elision)\n                 } else if l.starts_with(\"// \") {\n                     let (_, test_content) = l.split_at(\"// \".len());\n-                    curr_test_contents.push(test_content);\n+                    curr_test_contents.push(ExpectedLine::Text(test_content));\n                 }\n             }\n         }\n@@ -2273,7 +2277,7 @@ actual:\\n\\\n         }\n     }\n \n-    fn compare_mir_test_output(&self, test_name: &str, expected_content: &[&str]) {\n+    fn compare_mir_test_output(&self, test_name: &str, expected_content: &[ExpectedLine<&str>]) {\n         let mut output_file = PathBuf::new();\n         output_file.push(self.get_mir_dump_dir());\n         output_file.push(test_name);\n@@ -2285,38 +2289,77 @@ actual:\\n\\\n         let mut dumped_string = String::new();\n         dumped_file.read_to_string(&mut dumped_string).unwrap();\n         let mut dumped_lines = dumped_string.lines().filter(|l| !l.is_empty());\n-        let mut expected_lines = expected_content.iter().filter(|l| !l.is_empty());\n+        let mut expected_lines = expected_content.iter().filter(|&l| {\n+            if let &ExpectedLine::Text(l) = l {\n+                !l.is_empty()\n+            } else {\n+                true\n+            }\n+        }).peekable();\n \n-        // We expect each non-empty line from expected_content to appear\n-        // in the dump in order, but there may be extra lines interleaved\n-        while let Some(expected_line) = expected_lines.next() {\n+        let compare = |expected_line, dumped_line| {\n             let e_norm = normalize_mir_line(expected_line);\n-            if e_norm.is_empty() {\n-                continue;\n+            let d_norm = normalize_mir_line(dumped_line);\n+            debug!(\"found: {:?}\", d_norm);\n+            debug!(\"expected: {:?}\", e_norm);\n+            e_norm == d_norm\n+        };\n+\n+        let error = |expected_line, extra_msg| {\n+            let normalize_all = dumped_string.lines()\n+                                             .map(nocomment_mir_line)\n+                                             .filter(|l| !l.is_empty())\n+                                             .collect::<Vec<_>>()\n+                                             .join(\"\\n\");\n+            let f = |l: &ExpectedLine<_>| match l {\n+                &ExpectedLine::Elision => \"... (elided)\".into(),\n+                &ExpectedLine::Text(t) => t\n             };\n-            let mut found = false;\n-            while let Some(dumped_line) = dumped_lines.next() {\n-                let d_norm = normalize_mir_line(dumped_line);\n-                debug!(\"found: {:?}\", d_norm);\n-                debug!(\"expected: {:?}\", e_norm);\n-                if e_norm == d_norm {\n-                    found = true;\n-                    break;\n-                };\n-            }\n-            if !found {\n-                let normalize_all = dumped_string.lines()\n-                                                 .map(nocomment_mir_line)\n-                                                 .filter(|l| !l.is_empty())\n-                                                 .collect::<Vec<_>>()\n-                                                 .join(\"\\n\");\n-                panic!(\"ran out of mir dump output to match against.\\n\\\n-                        Did not find expected line: {:?}\\n\\\n-                        Expected:\\n{}\\n\\\n-                        Actual:\\n{}\",\n-                        expected_line,\n-                        expected_content.join(\"\\n\"),\n-                        normalize_all);\n+            let expected_content = expected_content.iter()\n+                                                   .map(|l| f(l))\n+                                                   .collect::<Vec<_>>()\n+                                                   .join(\"\\n\");\n+            panic!(\"Did not find expected line, error: {}\\n\\\n+                   Actual Line: {:?}\\n\\\n+                   Expected:\\n{}\\n\\\n+                   Actual:\\n{}\",\n+                   extra_msg,\n+                   expected_line,\n+                   expected_content,\n+                   normalize_all);\n+        };\n+\n+        // We expect each non-empty line to appear consecutively, non-consecutive lines\n+        // must be separated by at least one Elision\n+        while let Some(dumped_line) = dumped_lines.next() {\n+            match expected_lines.next() {\n+                Some(&ExpectedLine::Text(expected_line)) =>\n+                    if !compare(expected_line, dumped_line) {\n+                        error(expected_line,\n+                              format!(\"Mismatch in lines\\nExpected Line: {:?}\", dumped_line));\n+                    },\n+                Some(&ExpectedLine::Elision) => {\n+                    // skip any number of elisions in a row.\n+                    while let Some(&&ExpectedLine::Elision) = expected_lines.peek() {\n+                        expected_lines.next();\n+                    }\n+                    if let Some(&ExpectedLine::Text(expected_line)) = expected_lines.next() {\n+                        let mut found = compare(expected_line, dumped_line);\n+                        if found {\n+                            continue;\n+                        }\n+                        while let Some(dumped_line) = dumped_lines.next() {\n+                            found = compare(expected_line, dumped_line);\n+                            if found {\n+                                break;\n+                            }\n+                        }\n+                        if !found {\n+                            error(expected_line, \"ran out of mir dump to match against\".into());\n+                        }\n+                    }\n+                },\n+                None => {},\n             }\n         }\n     }\n@@ -2439,6 +2482,25 @@ enum TargetLocation {\n     ThisDirectory(PathBuf),\n }\n \n+#[derive(Clone, PartialEq, Eq)]\n+enum ExpectedLine<T: AsRef<str>> {\n+    Elision,\n+    Text(T)\n+}\n+\n+impl<T> fmt::Debug for ExpectedLine<T>\n+where\n+    T: AsRef<str> + fmt::Debug\n+{\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        if let &ExpectedLine::Text(ref t) = self {\n+            write!(formatter, \"{:?}\", t)\n+        } else {\n+            write!(formatter, \"\\\"...\\\" (Elision)\")\n+        }\n+    }\n+}\n+\n fn normalize_mir_line(line: &str) -> String {\n     nocomment_mir_line(line).replace(char::is_whitespace, \"\")\n }"}]}