{"sha": "8b012ed142f03c9082773f5091c58c82d47cae79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDEyZWQxNDJmMDNjOTA4Mjc3M2Y1MDkxYzU4YzgyZDQ3Y2FlNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-28T00:46:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-28T00:46:14Z"}, "message": "Auto merge of #33706 - jseyfried:refactor_cfg, r=nrc\n\nPerform `cfg` attribute processing during macro expansion and fix bugs\n\nThis PR refactors `cfg` attribute processing and fixes bugs. More specifically:\n - It merges gated feature checking for stmt/expr attributes, `cfg_attr` processing, and `cfg` processing into a single fold.\n  - This allows feature gated `cfg` variables to be used in `cfg_attr` on unconfigured items. All other feature gated attributes can already be used on unconfigured items.\n - It performs `cfg` attribute processing during macro expansion instead of after expansion so that macro-expanded items are configured the same as ordinary items. In particular, to match their non-expanded counterparts,\n  - macro-expanded unconfigured macro invocations are no longer expanded,\n  - macro-expanded unconfigured macro definitions are no longer usable, and\n  - feature gated `cfg` variables on macro-expanded macro definitions/invocations are now errors.\n\nThis is a [breaking-change]. For example, the following would break:\n```rust\nmacro_rules! m {\n    () => {\n        #[cfg(attr)]\n        macro_rules! foo { () => {} }\n        foo!(); // This will be an error\n\n        macro_rules! bar { () => { fn f() {} } }\n        #[cfg(attr)] bar!(); // This will no longer be expanded ...\n        fn g() { f(); } // ... so that `f` will be unresolved.\n\n        #[cfg(target_thread_local)] // This will be a gated feature error\n        macro_rules! baz { () => {} }\n    }\n}\n\nm!();\n```\n\nr? @nrc", "tree": {"sha": "c475df9a0f4f8c46167dc60916e0b60dffaebe7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c475df9a0f4f8c46167dc60916e0b60dffaebe7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b012ed142f03c9082773f5091c58c82d47cae79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b012ed142f03c9082773f5091c58c82d47cae79", "html_url": "https://github.com/rust-lang/rust/commit/8b012ed142f03c9082773f5091c58c82d47cae79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b012ed142f03c9082773f5091c58c82d47cae79/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bddce693cec4ae4eb6970ed91289815b316cff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bddce693cec4ae4eb6970ed91289815b316cff3", "html_url": "https://github.com/rust-lang/rust/commit/7bddce693cec4ae4eb6970ed91289815b316cff3"}, {"sha": "53ab1378419d48a96e3ae923462f4ba8b921ad53", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ab1378419d48a96e3ae923462f4ba8b921ad53", "html_url": "https://github.com/rust-lang/rust/commit/53ab1378419d48a96e3ae923462f4ba8b921ad53"}], "stats": {"total": 968, "additions": 355, "deletions": 613}, "files": [{"sha": "48b86d862f5757ae24cf02286037ebcd65b8ba35", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -720,16 +720,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         ret\n     });\n \n-    // JBC: make CFG processing part of expansion to avoid this problem:\n-\n-    // strip again, in case expansion added anything with a #[cfg].\n     krate = sess.track_errors(|| {\n-        let krate = time(time_passes, \"configuration 2\", || {\n-            syntax::config::strip_unconfigured_items(sess.diagnostic(),\n-                                                     krate,\n-                                                     &mut feature_gated_cfgs)\n-        });\n-\n         time(time_passes, \"gated configuration checking\", || {\n             let features = sess.features.borrow();\n             feature_gated_cfgs.sort();"}, {"sha": "c8ded115db8644394e0693940f76e5c16bade49c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -15,7 +15,7 @@ pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n \n-use attr::ThinAttributes;\n+use attr::{ThinAttributes, HasAttrs};\n use codemap::{mk_sp, respan, Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use errors;\n@@ -831,13 +831,7 @@ impl StmtKind {\n     }\n \n     pub fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Decl(ref d, _) => d.attrs(),\n-            StmtKind::Expr(ref e, _) |\n-            StmtKind::Semi(ref e, _) => e.attrs(),\n-            StmtKind::Mac(_, _, Some(ref b)) => b,\n-            StmtKind::Mac(_, _, None) => &[],\n-        }\n+        HasAttrs::attrs(self)\n     }\n }\n \n@@ -870,10 +864,7 @@ pub struct Local {\n \n impl Local {\n     pub fn attrs(&self) -> &[Attribute] {\n-        match self.attrs {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n+        HasAttrs::attrs(self)\n     }\n }\n \n@@ -889,10 +880,7 @@ pub enum DeclKind {\n \n impl Decl {\n     pub fn attrs(&self) -> &[Attribute] {\n-        match self.node {\n-            DeclKind::Local(ref l) => l.attrs(),\n-            DeclKind::Item(ref i) => i.attrs(),\n-        }\n+        HasAttrs::attrs(self)\n     }\n }\n \n@@ -937,10 +925,7 @@ pub struct Expr {\n \n impl Expr {\n     pub fn attrs(&self) -> &[Attribute] {\n-        match self.attrs {\n-            Some(ref b) => b,\n-            None => &[],\n-        }\n+        HasAttrs::attrs(self)\n     }\n }\n "}, {"sha": "c3c3deea1877fa1a00fc69fd6c413e55bdd6f813", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 84, "deletions": 57, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -884,82 +884,109 @@ impl AttributesExt for Vec<Attribute> {\n     }\n }\n \n+pub trait HasAttrs: Sized {\n+    fn attrs(&self) -> &[ast::Attribute];\n+    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self;\n+}\n+\n /// A cheap way to add Attributes to an AST node.\n pub trait WithAttrs {\n     // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n     fn with_attrs(self, attrs: ThinAttributes) -> Self;\n }\n \n-impl WithAttrs for P<Expr> {\n+impl<T: HasAttrs> WithAttrs for T {\n     fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map(|mut e| {\n-            e.attrs.update(|a| a.append(attrs));\n-            e\n+        self.map_attrs(|mut orig_attrs| {\n+            orig_attrs.extend(attrs.into_attr_vec());\n+            orig_attrs\n         })\n     }\n }\n \n-impl WithAttrs for P<Item> {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map(|Item { ident, attrs: mut ats, id, node, vis, span }| {\n-            ats.extend(attrs.into_attr_vec());\n-            Item {\n-                ident: ident,\n-                attrs: ats,\n-                id: id,\n-                node: node,\n-                vis: vis,\n-                span: span,\n-            }\n-        })\n+impl HasAttrs for Vec<Attribute> {\n+    fn attrs(&self) -> &[Attribute] {\n+        &self\n+    }\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+        f(self)\n     }\n }\n \n-impl WithAttrs for P<Local> {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map(|Local { pat, ty, init, id, span, attrs: mut ats }| {\n-            ats.update(|a| a.append(attrs));\n-            Local {\n-                pat: pat,\n-                ty: ty,\n-                init: init,\n-                id: id,\n-                span: span,\n-                attrs: ats,\n-            }\n-        })\n+impl HasAttrs for ThinAttributes {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.as_attr_slice()\n+    }\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+        self.map_thin_attrs(f)\n     }\n }\n \n-impl WithAttrs for P<Decl> {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map(|Spanned { span, node }| {\n-            Spanned {\n-                span: span,\n-                node: match node {\n-                    DeclKind::Local(local) => DeclKind::Local(local.with_attrs(attrs)),\n-                    DeclKind::Item(item) => DeclKind::Item(item.with_attrs(attrs)),\n-                }\n-            }\n-        })\n+impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        (**self).attrs()\n+    }\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+        self.map(|t| t.map_attrs(f))\n     }\n }\n \n-impl WithAttrs for P<Stmt> {\n-    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n-        self.map(|Spanned { span, node }| {\n-            Spanned {\n-                span: span,\n-                node: match node {\n-                    StmtKind::Decl(decl, id) => StmtKind::Decl(decl.with_attrs(attrs), id),\n-                    StmtKind::Expr(expr, id) => StmtKind::Expr(expr.with_attrs(attrs), id),\n-                    StmtKind::Semi(expr, id) => StmtKind::Semi(expr.with_attrs(attrs), id),\n-                    StmtKind::Mac(mac, style, mut ats) => {\n-                        ats.update(|a| a.append(attrs));\n-                        StmtKind::Mac(mac, style, ats)\n-                    }\n-                },\n-            }\n-        })\n+impl HasAttrs for DeclKind {\n+    fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            DeclKind::Local(ref local) => local.attrs(),\n+            DeclKind::Item(ref item) => item.attrs(),\n+        }\n+    }\n+\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+        match self {\n+            DeclKind::Local(local) => DeclKind::Local(local.map_attrs(f)),\n+            DeclKind::Item(item) => DeclKind::Item(item.map_attrs(f)),\n+        }\n     }\n }\n+\n+impl HasAttrs for StmtKind {\n+    fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtKind::Decl(ref decl, _) => decl.attrs(),\n+            StmtKind::Expr(ref expr, _) | StmtKind::Semi(ref expr, _) => expr.attrs(),\n+            StmtKind::Mac(_, _, ref attrs) => attrs.attrs(),\n+        }\n+    }\n+\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n+        match self {\n+            StmtKind::Decl(decl, id) => StmtKind::Decl(decl.map_attrs(f), id),\n+            StmtKind::Expr(expr, id) => StmtKind::Expr(expr.map_attrs(f), id),\n+            StmtKind::Semi(expr, id) => StmtKind::Semi(expr.map_attrs(f), id),\n+            StmtKind::Mac(mac, style, attrs) =>\n+                StmtKind::Mac(mac, style, attrs.map_attrs(f)),\n+        }\n+    }\n+}\n+\n+macro_rules! derive_has_attrs_from_field {\n+    ($($ty:path),*) => { derive_has_attrs_from_field!($($ty: .attrs),*); };\n+    ($($ty:path : $(.$field:ident)*),*) => { $(\n+        impl HasAttrs for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                self $(.$field)* .attrs()\n+            }\n+\n+            fn map_attrs<F>(mut self, f: F) -> Self\n+                where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>,\n+            {\n+                self $(.$field)* = self $(.$field)* .map_attrs(f);\n+                self\n+            }\n+        }\n+    )* }\n+}\n+\n+derive_has_attrs_from_field! {\n+    Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm\n+}\n+\n+derive_has_attrs_from_field! { Decl: .node, Stmt: .node, ast::Variant: .node.attrs }"}, {"sha": "d391cd0be7b12c71cc66889ec945816eca01fcee", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -1258,31 +1258,6 @@ impl CodeMap {\n         return a;\n     }\n \n-    /// Check if the backtrace `subtrace` contains `suptrace` as a prefix.\n-    pub fn more_specific_trace(&self,\n-                              mut subtrace: ExpnId,\n-                              suptrace: ExpnId)\n-                              -> bool {\n-        loop {\n-            if subtrace == suptrace {\n-                return true;\n-            }\n-\n-            let stop = self.with_expn_info(subtrace, |opt_expn_info| {\n-                if let Some(expn_info) = opt_expn_info {\n-                    subtrace = expn_info.call_site.expn_id;\n-                    false\n-                } else {\n-                    true\n-                }\n-            });\n-\n-            if stop {\n-                return false;\n-            }\n-        }\n-    }\n-\n     pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n         let mut expansions = self.expansions.borrow_mut();\n         expansions.push(expn_info);"}, {"sha": "14035d8d116a3b2502be7f718c8d277467210851", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 184, "deletions": 412, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -8,326 +8,76 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use attr::AttrMetaMethods;\n+use attr::{AttrMetaMethods, HasAttrs};\n use errors::Handler;\n use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n-use visit;\n use codemap::{Spanned, respan};\n use ptr::P;\n \n use util::small_vector::SmallVector;\n \n-/// A folder that strips out items that do not belong in the current\n-/// configuration.\n-struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n-    in_cfg: F,\n-    diagnostic: &'a Handler,\n-}\n+pub trait CfgFolder: fold::Folder {\n+    // Check if a node with the given attributes is in this configuration.\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool;\n \n-// Support conditional compilation by transforming the AST, stripping out\n-// any items that do not belong in the current configuration\n-pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n-                                feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n-                                -> ast::Crate\n-{\n-    // Need to do this check here because cfg runs before feature_gates\n-    check_for_gated_stmt_expr_attributes(&krate, feature_gated_cfgs);\n-\n-    let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n-    let config = krate.config.clone();\n-    strip_items(diagnostic,\n-                krate,\n-                |attrs| {\n-                    let mut diag = CfgDiagReal {\n-                        diag: diagnostic,\n-                        feature_gated_cfgs: feature_gated_cfgs,\n-                    };\n-                    in_cfg(&config, attrs, &mut diag)\n-                })\n-}\n+    // Update a node before checking if it is in this configuration (used to implement `cfg_attr`).\n+    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T { node }\n \n-impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n-    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n-        fold_foreign_mod(self, foreign_mod)\n-    }\n-    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        fold_item_kind(self, item)\n-    }\n-    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        // If an expr is valid to cfg away it will have been removed by the\n-        // outer stmt or expression folder before descending in here.\n-        // Anything else is always required, and thus has to error out\n-        // in case of a cfg attr.\n-        //\n-        // NB: This is intentionally not part of the fold_expr() function\n-        //     in order for fold_opt_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n-            self.diagnostic.span_err(attr.span,\n-                \"removing an expression is not supported in this position\");\n-        }\n-        fold_expr(self, expr)\n-    }\n-    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        fold_opt_expr(self, expr)\n-    }\n-    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n-        fold_stmt(self, stmt)\n-    }\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n-    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        fold_item(self, item)\n-    }\n-}\n+    // Visit attributes on expression and statements (but not attributes on items in blocks).\n+    fn visit_stmt_or_expr_attrs(&mut self, _attrs: &[ast::Attribute]) {}\n \n-pub fn strip_items<'a, F>(diagnostic: &'a Handler,\n-                          krate: ast::Crate, in_cfg: F) -> ast::Crate where\n-    F: FnMut(&[ast::Attribute]) -> bool,\n-{\n-    let mut ctxt = Context {\n-        in_cfg: in_cfg,\n-        diagnostic: diagnostic,\n-    };\n-    ctxt.fold_crate(krate)\n-}\n+    // Visit unremovable (non-optional) expressions -- c.f. `fold_expr` vs `fold_opt_expr`.\n+    fn visit_unremovable_expr(&mut self, _expr: &ast::Expr) {}\n \n-fn filter_foreign_item<F>(cx: &mut Context<F>,\n-                          item: ast::ForeignItem)\n-                          -> Option<ast::ForeignItem> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if foreign_item_in_cfg(cx, &item) {\n-        Some(item)\n-    } else {\n-        None\n+    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+        let node = self.process_attrs(node);\n+        if self.in_cfg(node.attrs()) { Some(node) } else { None }\n     }\n }\n \n-fn fold_foreign_mod<F>(cx: &mut Context<F>,\n-                       ast::ForeignMod {abi, items}: ast::ForeignMod)\n-                       -> ast::ForeignMod where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    ast::ForeignMod {\n-        abi: abi,\n-        items: items.into_iter()\n-                    .filter_map(|a| filter_foreign_item(cx, a))\n-                    .collect()\n-    }\n-}\n-\n-fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if item_in_cfg(cx, &item) {\n-        SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n-    } else {\n-        SmallVector::zero()\n-    }\n-}\n-\n-fn fold_item_kind<F>(cx: &mut Context<F>, item: ast::ItemKind) -> ast::ItemKind where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    let item = match item {\n-        ast::ItemKind::Impl(u, o, a, b, c, impl_items) => {\n-            let impl_items = impl_items.into_iter()\n-                                       .filter(|ii| (cx.in_cfg)(&ii.attrs))\n-                                       .collect();\n-            ast::ItemKind::Impl(u, o, a, b, c, impl_items)\n-        }\n-        ast::ItemKind::Trait(u, a, b, methods) => {\n-            let methods = methods.into_iter()\n-                                 .filter(|ti| (cx.in_cfg)(&ti.attrs))\n-                                 .collect();\n-            ast::ItemKind::Trait(u, a, b, methods)\n-        }\n-        ast::ItemKind::Struct(def, generics) => {\n-            ast::ItemKind::Struct(fold_struct(cx, def), generics)\n-        }\n-        ast::ItemKind::Enum(def, generics) => {\n-            let variants = def.variants.into_iter().filter_map(|v| {\n-                if !(cx.in_cfg)(&v.node.attrs) {\n-                    None\n-                } else {\n-                    Some(Spanned {\n-                        node: ast::Variant_ {\n-                            name: v.node.name,\n-                            attrs: v.node.attrs,\n-                            data: fold_struct(cx, v.node.data),\n-                            disr_expr: v.node.disr_expr,\n-                        },\n-                        span: v.span\n-                    })\n-                }\n-            });\n-            ast::ItemKind::Enum(ast::EnumDef {\n-                variants: variants.collect(),\n-            }, generics)\n-        }\n-        item => item,\n-    };\n-\n-    fold::noop_fold_item_kind(item, cx)\n+/// A folder that strips out items that do not belong in the current\n+/// configuration.\n+pub struct StripUnconfigured<'a> {\n+    diag: CfgDiagReal<'a, 'a>,\n+    config: &'a ast::CrateConfig,\n }\n \n-fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantData where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    match vdata {\n-        ast::VariantData::Struct(fields, id) => {\n-            ast::VariantData::Struct(fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.attrs)\n-            }).collect(), id)\n-        }\n-        ast::VariantData::Tuple(fields, id) => {\n-            ast::VariantData::Tuple(fields.into_iter().filter(|m| {\n-                (cx.in_cfg)(&m.attrs)\n-            }).collect(), id)\n+impl<'a> StripUnconfigured<'a> {\n+    pub fn new(config: &'a ast::CrateConfig,\n+               diagnostic: &'a Handler,\n+               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>)\n+               -> Self {\n+        StripUnconfigured {\n+            config: config,\n+            diag: CfgDiagReal { diag: diagnostic, feature_gated_cfgs: feature_gated_cfgs },\n         }\n-        ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n-    }\n-}\n-\n-fn fold_opt_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> Option<P<ast::Expr>>\n-    where F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if expr_in_cfg(cx, &expr) {\n-        Some(fold_expr(cx, expr))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    expr.map(|ast::Expr {id, span, node, attrs}| {\n-        fold::noop_fold_expr(ast::Expr {\n-            id: id,\n-            node: match node {\n-                ast::ExprKind::Match(m, arms) => {\n-                    ast::ExprKind::Match(m, arms.into_iter()\n-                                        .filter(|a| (cx.in_cfg)(&a.attrs))\n-                                        .collect())\n-                }\n-                _ => node\n-            },\n-            span: span,\n-            attrs: attrs,\n-        }, cx)\n-    })\n-}\n-\n-fn fold_stmt<F>(cx: &mut Context<F>, stmt: ast::Stmt) -> SmallVector<ast::Stmt>\n-    where F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if stmt_in_cfg(cx, &stmt) {\n-        fold::noop_fold_stmt(stmt, cx)\n-    } else {\n-        SmallVector::zero()\n     }\n-}\n-\n-fn stmt_in_cfg<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    (cx.in_cfg)(stmt.node.attrs())\n-}\n-\n-fn expr_in_cfg<F>(cx: &mut Context<F>, expr: &ast::Expr) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    (cx.in_cfg)(expr.attrs())\n-}\n-\n-fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(&item.attrs);\n-}\n-\n-fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(&item.attrs);\n-}\n-\n-fn is_cfg(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"cfg\")\n-}\n-\n-// Determine if an item should be translated in the current crate\n-// configuration based on the item's attributes\n-fn in_cfg<T: CfgDiag>(cfg: &[P<ast::MetaItem>],\n-                      attrs: &[ast::Attribute],\n-                      diag: &mut T) -> bool {\n-    attrs.iter().all(|attr| {\n-        let mis = match attr.node.value.node {\n-            ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n-            _ => return true\n-        };\n-\n-        if mis.len() != 1 {\n-            diag.emit_error(|diagnostic| {\n-                diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n-            });\n-            return true;\n-        }\n-\n-        attr::cfg_matches(cfg, &mis[0], diag)\n-    })\n-}\n \n-struct CfgAttrFolder<'a, T> {\n-    diag: T,\n-    config: &'a ast::CrateConfig,\n-}\n-\n-// Process `#[cfg_attr]`.\n-fn process_cfg_attr(diagnostic: &Handler, krate: ast::Crate,\n-                    feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n-    let mut fld = CfgAttrFolder {\n-        diag: CfgDiagReal {\n-            diag: diagnostic,\n-            feature_gated_cfgs: feature_gated_cfgs,\n-        },\n-        config: &krate.config.clone(),\n-    };\n-    fld.fold_crate(krate)\n-}\n-\n-impl<'a, T: CfgDiag> fold::Folder for CfgAttrFolder<'a, T> {\n-    fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n+    fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n-            return fold::noop_fold_attribute(attr, self);\n+            return Some(attr);\n         }\n \n         let attr_list = match attr.meta_item_list() {\n             Some(attr_list) => attr_list,\n             None => {\n-                self.diag.emit_error(|diag| {\n-                    diag.span_err(attr.span,\n-                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n-                });\n+                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.diag.diag.span_err(attr.span, msg);\n                 return None;\n             }\n         };\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n-                self.diag.emit_error(|diag| {\n-                    diag.span_err(attr.span,\n-                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n-                });\n+                let msg = \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\";\n+                self.diag.diag.span_err(attr.span, msg);\n                 return None;\n             }\n         };\n \n-        if attr::cfg_matches(&self.config[..], &cfg, &mut self.diag) {\n+        if attr::cfg_matches(self.config, &cfg, &mut self.diag) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,\n@@ -338,127 +88,187 @@ impl<'a, T: CfgDiag> fold::Folder for CfgAttrFolder<'a, T> {\n             None\n         }\n     }\n-\n-    // Need the ability to run pre-expansion.\n-    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(mac, self)\n-    }\n }\n \n-fn check_for_gated_stmt_expr_attributes(krate: &ast::Crate,\n-                                        discovered: &mut Vec<GatedCfgAttr>) {\n-    let mut v = StmtExprAttrFeatureVisitor {\n-        config: &krate.config,\n-        discovered: discovered,\n-    };\n-    visit::walk_crate(&mut v, krate);\n-}\n-\n-/// To cover this feature, we need to discover all attributes\n-/// so we need to run before cfg.\n-struct StmtExprAttrFeatureVisitor<'a, 'b> {\n-    config: &'a ast::CrateConfig,\n-    discovered: &'b mut Vec<GatedCfgAttr>,\n-}\n-\n-// Runs the cfg_attr and cfg folders locally in \"silent\" mode\n-// to discover attribute use on stmts or expressions ahead of time\n-impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n-    fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n-        // check if there even are any attributes on this node\n-        let stmt_attrs = s.node.attrs();\n-        if stmt_attrs.len() > 0 {\n-            // attributes on items are fine\n-            if let ast::StmtKind::Decl(ref decl, _) = s.node {\n-                if let ast::DeclKind::Item(_) = decl.node {\n-                    visit::walk_stmt(self, s);\n-                    return;\n-                }\n-            }\n-\n-            // flag the offending attributes\n-            for attr in stmt_attrs {\n-                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n+impl<'a> CfgFolder for StripUnconfigured<'a> {\n+    // Determine if an item should be translated in the current crate\n+    // configuration based on the item's attributes\n+    fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        attrs.iter().all(|attr| {\n+            let mis = match attr.node.value.node {\n+                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n+                _ => return true\n+            };\n+\n+            if mis.len() != 1 {\n+                self.diag.emit_error(|diagnostic| {\n+                    diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+                });\n+                return true;\n             }\n \n-            // if the node does not end up being cfg-d away, walk down\n-            if node_survives_cfg(stmt_attrs, self.config) {\n-                visit::walk_stmt(self, s);\n-            }\n-        } else {\n-            visit::walk_stmt(self, s);\n-        }\n+            attr::cfg_matches(self.config, &mis[0], &mut self.diag)\n+        })\n     }\n \n-    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n-        // check if there even are any attributes on this node\n-        let expr_attrs = ex.attrs();\n-        if expr_attrs.len() > 0 {\n-\n-            // flag the offending attributes\n-            for attr in expr_attrs {\n-                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n-            }\n+    fn process_attrs<T: HasAttrs>(&mut self, node: T) -> T {\n+        node.map_attrs(|attrs| {\n+            attrs.into_iter().filter_map(|attr| self.process_cfg_attr(attr)).collect()\n+        })\n+    }\n \n-            // if the node does not end up being cfg-d away, walk down\n-            if node_survives_cfg(expr_attrs, self.config) {\n-                visit::walk_expr(self, ex);\n-            }\n-        } else {\n-            visit::walk_expr(self, ex);\n+    fn visit_stmt_or_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n+        // flag the offending attributes\n+        for attr in attrs.iter() {\n+            self.diag.feature_gated_cfgs.push(GatedCfgAttr::GatedAttr(attr.span));\n         }\n     }\n \n-    fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n-        if node_survives_cfg(&i.attrs, self.config) {\n-            visit::walk_foreign_item(self, i);\n+    fn visit_unremovable_expr(&mut self, expr: &ast::Expr) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+            let msg = \"removing an expression is not supported in this position\";\n+            self.diag.diag.span_err(attr.span, msg);\n         }\n     }\n+}\n+\n+// Support conditional compilation by transforming the AST, stripping out\n+// any items that do not belong in the current configuration\n+pub fn strip_unconfigured_items(diagnostic: &Handler, krate: ast::Crate,\n+                                feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n+                                -> ast::Crate\n+{\n+    let config = &krate.config.clone();\n+    StripUnconfigured::new(config, diagnostic, feature_gated_cfgs).fold_crate(krate)\n+}\n \n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        if node_survives_cfg(&i.attrs, self.config) {\n-            visit::walk_item(self, i);\n+impl<T: CfgFolder> fold::Folder for T {\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n+        ast::ForeignMod {\n+            abi: foreign_mod.abi,\n+            items: foreign_mod.items.into_iter().filter_map(|item| {\n+                self.configure(item).map(|item| fold::noop_fold_foreign_item(item, self))\n+            }).collect(),\n         }\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n-        if node_survives_cfg(&ii.attrs, self.config) {\n-            visit::walk_impl_item(self, ii);\n-        }\n+    fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n+        let fold_struct = |this: &mut Self, vdata| match vdata {\n+            ast::VariantData::Struct(fields, id) => {\n+                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                ast::VariantData::Struct(fields.collect(), id)\n+            }\n+            ast::VariantData::Tuple(fields, id) => {\n+                let fields = fields.into_iter().filter_map(|field| this.configure(field));\n+                ast::VariantData::Tuple(fields.collect(), id)\n+            }\n+            ast::VariantData::Unit(id) => ast::VariantData::Unit(id)\n+        };\n+\n+        let item = match item {\n+            ast::ItemKind::Impl(u, o, a, b, c, items) => {\n+                let items = items.into_iter().filter_map(|item| self.configure(item)).collect();\n+                ast::ItemKind::Impl(u, o, a, b, c, items)\n+            }\n+            ast::ItemKind::Trait(u, a, b, items) => {\n+                let items = items.into_iter().filter_map(|item| self.configure(item)).collect();\n+                ast::ItemKind::Trait(u, a, b, items)\n+            }\n+            ast::ItemKind::Struct(def, generics) => {\n+                ast::ItemKind::Struct(fold_struct(self, def), generics)\n+            }\n+            ast::ItemKind::Enum(def, generics) => {\n+                let variants = def.variants.into_iter().filter_map(|v| {\n+                    self.configure(v).map(|v| {\n+                        Spanned {\n+                            node: ast::Variant_ {\n+                                name: v.node.name,\n+                                attrs: v.node.attrs,\n+                                data: fold_struct(self, v.node.data),\n+                                disr_expr: v.node.disr_expr,\n+                            },\n+                            span: v.span\n+                        }\n+                    })\n+                });\n+                ast::ItemKind::Enum(ast::EnumDef {\n+                    variants: variants.collect(),\n+                }, generics)\n+            }\n+            item => item,\n+        };\n+\n+        fold::noop_fold_item_kind(item, self)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n-        if node_survives_cfg(&ti.attrs, self.config) {\n-            visit::walk_trait_item(self, ti);\n-        }\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        self.visit_stmt_or_expr_attrs(expr.attrs());\n+        // If an expr is valid to cfg away it will have been removed by the\n+        // outer stmt or expression folder before descending in here.\n+        // Anything else is always required, and thus has to error out\n+        // in case of a cfg attr.\n+        //\n+        // NB: This is intentionally not part of the fold_expr() function\n+        //     in order for fold_opt_expr() to be able to avoid this check\n+        self.visit_unremovable_expr(&expr);\n+        let expr = self.process_attrs(expr);\n+        fold_expr(self, expr)\n     }\n \n-    fn visit_struct_field(&mut self, s: &'v ast::StructField) {\n-        if node_survives_cfg(&s.attrs, self.config) {\n-            visit::walk_struct_field(self, s);\n-        }\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        self.configure(expr).map(|expr| fold_expr(self, expr))\n     }\n \n-    fn visit_variant(&mut self, v: &'v ast::Variant,\n-                     g: &'v ast::Generics, item_id: ast::NodeId) {\n-        if node_survives_cfg(&v.node.attrs, self.config) {\n-            visit::walk_variant(self, v, g, item_id);\n+    fn fold_stmt(&mut self, stmt: ast::Stmt) -> SmallVector<ast::Stmt> {\n+        let is_item = match stmt.node {\n+            ast::StmtKind::Decl(ref decl, _) => match decl.node {\n+                ast::DeclKind::Item(_) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        };\n+\n+        // avoid calling `visit_stmt_or_expr_attrs` on items\n+        if !is_item {\n+            self.visit_stmt_or_expr_attrs(stmt.attrs());\n         }\n+\n+        self.configure(stmt).map(|stmt| fold::noop_fold_stmt(stmt, self))\n+                            .unwrap_or(SmallVector::zero())\n     }\n \n-    fn visit_arm(&mut self, a: &'v ast::Arm) {\n-        if node_survives_cfg(&a.attrs, self.config) {\n-            visit::walk_arm(self, a);\n-        }\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n \n-    // This visitor runs pre expansion, so we need to prevent\n-    // the default panic here\n-    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n-        visit::walk_mac(self, mac)\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        self.configure(item).map(|item| SmallVector::one(item.map(|i| self.fold_item_simple(i))))\n+                            .unwrap_or(SmallVector::zero())\n     }\n }\n \n+fn fold_expr<F: CfgFolder>(folder: &mut F, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    expr.map(|ast::Expr {id, span, node, attrs}| {\n+        fold::noop_fold_expr(ast::Expr {\n+            id: id,\n+            node: match node {\n+                ast::ExprKind::Match(m, arms) => {\n+                    ast::ExprKind::Match(m, arms.into_iter()\n+                                        .filter_map(|a| folder.configure(a))\n+                                        .collect())\n+                }\n+                _ => node\n+            },\n+            span: span,\n+            attrs: attrs,\n+        }, folder)\n+    })\n+}\n+\n+fn is_cfg(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"cfg\")\n+}\n+\n pub trait CfgDiag {\n     fn emit_error<F>(&mut self, f: F) where F: FnMut(&Handler);\n     fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n@@ -477,41 +287,3 @@ impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n         f(self.feature_gated_cfgs)\n     }\n }\n-\n-struct CfgDiagSilent {\n-    error: bool,\n-}\n-\n-impl CfgDiag for CfgDiagSilent {\n-    fn emit_error<F>(&mut self, _: F) where F: FnMut(&Handler) {\n-        self.error = true;\n-    }\n-    fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}\n-}\n-\n-fn node_survives_cfg(attrs: &[ast::Attribute],\n-                     config: &ast::CrateConfig) -> bool {\n-    let mut survives_cfg = true;\n-\n-    for attr in attrs {\n-        let mut fld = CfgAttrFolder {\n-            diag: CfgDiagSilent { error: false },\n-            config: config,\n-        };\n-        let attr = fld.fold_attribute(attr.clone());\n-\n-        // In case of error we can just return true,\n-        // since the actual cfg folders will end compilation anyway.\n-\n-        if fld.diag.error { return true; }\n-\n-        survives_cfg &= attr.map(|attr| {\n-            let mut diag = CfgDiagSilent { error: false };\n-            let r = in_cfg(config, &[attr], &mut diag);\n-            if diag.error { return true; }\n-            r\n-        }).unwrap_or(true)\n-    }\n-\n-    survives_cfg\n-}"}, {"sha": "c3202dbdbb49e149d589a247ec415210b15326b7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 65, "deletions": 82, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -18,7 +18,8 @@ use ext::build::AstBuilder;\n use attr;\n use attr::{AttrMetaMethods, WithAttrs, ThinAttributesExt};\n use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{Span, Spanned, ExpnInfo, ExpnId, NameAndSpan, MacroBang, MacroAttribute};\n+use config::StripUnconfigured;\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n@@ -33,7 +34,6 @@ use visit::Visitor;\n use std_inject;\n \n use std::collections::HashSet;\n-use std::env;\n \n // A trait for AST nodes and AST node lists into which macro invocations may expand.\n trait MacroGenerable: Sized {\n@@ -77,25 +77,35 @@ impl_macro_generable! {\n         \"statement\", .make_stmts,      lift .fold_stmt,      |_span| SmallVector::zero();\n }\n \n-pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n+impl MacroGenerable for Option<P<ast::Expr>> {\n+    fn kind_name() -> &'static str { \"expression\" }\n+    fn dummy(_span: Span) -> Self { None }\n+    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> {\n+        result.make_expr().map(Some)\n+    }\n+    fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n+        self.and_then(|expr| folder.fold_opt_expr(expr))\n+    }\n+}\n \n+pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+    match expr.node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, attrs.into_attr_vec(), span, fld)\n+            expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, fld)\n         }\n \n         ast::ExprKind::While(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprKind::While(cond, body, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            fld.cx.expr(expr.span, ast::ExprKind::While(cond, body, opt_ident))\n+                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n         }\n \n-        ast::ExprKind::WhileLet(pat, expr, body, opt_ident) => {\n+        ast::ExprKind::WhileLet(pat, cond, body, opt_ident) => {\n             let pat = fld.fold_pat(pat);\n-            let expr = fld.fold_expr(expr);\n+            let cond = fld.fold_expr(cond);\n \n             // Hygienic renaming of the body.\n             let ((body, opt_ident), mut rewritten_pats) =\n@@ -107,14 +117,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             });\n             assert!(rewritten_pats.len() == 1);\n \n-            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), expr, body, opt_ident);\n-            fld.cx.expr(span, wl).with_attrs(fold_thin_attrs(attrs, fld))\n+            let wl = ast::ExprKind::WhileLet(rewritten_pats.remove(0), cond, body, opt_ident);\n+            fld.cx.expr(expr.span, wl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n         }\n \n         ast::ExprKind::Loop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprKind::Loop(loop_block, opt_ident))\n-                .with_attrs(fold_thin_attrs(attrs, fld))\n+            fld.cx.expr(expr.span, ast::ExprKind::Loop(loop_block, opt_ident))\n+                .with_attrs(fold_thin_attrs(expr.attrs, fld))\n         }\n \n         ast::ExprKind::ForLoop(pat, head, body, opt_ident) => {\n@@ -132,7 +142,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let head = fld.fold_expr(head);\n             let fl = ast::ExprKind::ForLoop(rewritten_pats.remove(0), head, body, opt_ident);\n-            fld.cx.expr(span, fl).with_attrs(fold_thin_attrs(attrs, fld))\n+            fld.cx.expr(expr.span, fl).with_attrs(fold_thin_attrs(expr.attrs, fld))\n         }\n \n         ast::ExprKind::IfLet(pat, sub_expr, body, else_opt) => {\n@@ -151,7 +161,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n             let il = ast::ExprKind::IfLet(rewritten_pats.remove(0), sub_expr, body, else_opt);\n-            fld.cx.expr(span, il).with_attrs(fold_thin_attrs(attrs, fld))\n+            fld.cx.expr(expr.span, il).with_attrs(fold_thin_attrs(expr.attrs, fld))\n         }\n \n         ast::ExprKind::Closure(capture_clause, fn_decl, block, fn_decl_span) => {\n@@ -160,22 +170,15 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let new_node = ast::ExprKind::Closure(capture_clause,\n                                                   rewritten_fn_decl,\n                                                   rewritten_block,\n-                                                  fld.new_span(fn_decl_span));\n-            P(ast::Expr{ id:id,\n+                                                  fn_decl_span);\n+            P(ast::Expr{ id: expr.id,\n                          node: new_node,\n-                         span: fld.new_span(span),\n-                         attrs: fold_thin_attrs(attrs, fld) })\n+                         span: expr.span,\n+                         attrs: fold_thin_attrs(expr.attrs, fld) })\n         }\n \n-        _ => {\n-            P(noop_fold_expr(ast::Expr {\n-                id: id,\n-                node: node,\n-                span: span,\n-                attrs: attrs\n-            }, fld))\n-        }\n-    });\n+        _ => P(noop_fold_expr(expr, fld)),\n+    }\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n@@ -322,8 +325,9 @@ fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attr\n         return T::dummy(span);\n     };\n \n-    let marked = expanded.fold_with(&mut Marker { mark: mark });\n-    let fully_expanded = marked.fold_with(fld);\n+    let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n+    let configured = marked.fold_with(&mut fld.strip_unconfigured());\n+    let fully_expanded = configured.fold_with(fld);\n     fld.cx.bt_pop();\n     fully_expanded\n }\n@@ -699,12 +703,12 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n                                            mtwt::apply_renames(self.renames, ident.ctxt));\n                 let new_node =\n                     PatKind::Ident(binding_mode,\n-                                  Spanned{span: self.new_span(sp), node: new_ident},\n+                                  Spanned{span: sp, node: new_ident},\n                                   sub.map(|p| self.fold_pat(p)));\n                 ast::Pat {\n                     id: id,\n                     node: new_node,\n-                    span: self.new_span(span)\n+                    span: span,\n                 }\n             },\n             _ => unreachable!()\n@@ -774,7 +778,7 @@ fn expand_annotatable(a: Annotatable,\n                         }\n                         _ => unreachable!()\n                     },\n-                    span: fld.new_span(ti.span)\n+                    span: ti.span,\n                 })\n             }\n             _ => fold::noop_fold_trait_item(it.unwrap(), fld)\n@@ -914,7 +918,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                 }\n                 _ => unreachable!()\n             },\n-            span: fld.new_span(ii.span)\n+            span: ii.span,\n         }),\n         ast::ImplItemKind::Macro(mac) => {\n             expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n@@ -987,6 +991,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn new(cx: &'a mut ExtCtxt<'b>) -> MacroExpander<'a, 'b> {\n         MacroExpander { cx: cx }\n     }\n+\n+    fn strip_unconfigured(&mut self) -> StripUnconfigured {\n+        StripUnconfigured::new(&self.cx.cfg,\n+                               &self.cx.parse_sess.span_diagnostic,\n+                               self.cx.feature_gated_cfgs)\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -996,7 +1006,15 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        expand_expr(expr, self)\n+        expr.and_then(|expr| expand_expr(expr, self))\n+    }\n+\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        expr.and_then(|expr| match expr.node {\n+            ast::ExprKind::Mac(mac) =>\n+                expand_mac_invoc(mac, None, expr.attrs.into_attr_vec(), expr.span, self),\n+            _ => Some(expand_expr(expr, self)),\n+        })\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n@@ -1059,10 +1077,6 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_ty(&mut self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         expand_type(ty, self)\n     }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        new_span(self.cx, span)\n-    }\n }\n \n impl<'a, 'b> MacroExpander<'a, 'b> {\n@@ -1080,45 +1094,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n }\n \n-fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n-    debug!(\"new_span(sp={:?})\", sp);\n-\n-    if cx.codemap().more_specific_trace(sp.expn_id, cx.backtrace()) {\n-        // If the span we are looking at has a backtrace that has more\n-        // detail than our current backtrace, then we keep that\n-        // backtrace.  Honestly, I have no idea if this makes sense,\n-        // because I have no idea why we are stripping the backtrace\n-        // below. But the reason I made this change is because, in\n-        // deriving, we were generating attributes with a specific\n-        // backtrace, which was essential for `#[structural_match]` to\n-        // be properly supported, but these backtraces were being\n-        // stripped and replaced with a null backtrace. Sort of\n-        // unclear why this is the case. --nmatsakis\n-        debug!(\"new_span: keeping trace from {:?} because it is more specific\",\n-               sp.expn_id);\n-        sp\n-    } else {\n-        // This discards information in the case of macro-defining macros.\n-        //\n-        // The comment above was originally added in\n-        // b7ec2488ff2f29681fe28691d20fd2c260a9e454 in Feb 2012. I\n-        // *THINK* the reason we are doing this is because we want to\n-        // replace the backtrace of the macro contents with the\n-        // backtrace that contains the macro use. But it's pretty\n-        // unclear to me. --nmatsakis\n-        let sp1 = Span {\n-            lo: sp.lo,\n-            hi: sp.hi,\n-            expn_id: cx.backtrace(),\n-        };\n-        debug!(\"new_span({:?}) = {:?}\", sp, sp1);\n-        if sp.expn_id.into_u32() == 0 && env::var_os(\"NDM\").is_some() {\n-            panic!(\"NDM\");\n-        }\n-        sp1\n-    }\n-}\n-\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,\n@@ -1205,8 +1180,9 @@ pub fn expand_crate(mut cx: ExtCtxt,\n // the ones defined here include:\n // Marker - add a mark to a context\n \n-// A Marker adds the given mark to the syntax context\n-struct Marker { mark: Mrk }\n+// A Marker adds the given mark to the syntax context and\n+// sets spans' `expn_id` to the given expn_id (unless it is `None`).\n+struct Marker { mark: Mrk, expn_id: Option<ExpnId> }\n \n impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n@@ -1219,14 +1195,21 @@ impl Folder for Marker {\n                 tts: self.fold_tts(&node.tts),\n                 ctxt: mtwt::apply_mark(self.mark, node.ctxt),\n             },\n-            span: span,\n+            span: self.new_span(span),\n+        }\n+    }\n+\n+    fn new_span(&mut self, mut span: Span) -> Span {\n+        if let Some(expn_id) = self.expn_id {\n+            span.expn_id = expn_id;\n         }\n+        span\n     }\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n fn mark_tts(tts: &[TokenTree], m: Mrk) -> Vec<TokenTree> {\n-    noop_fold_tts(tts, &mut Marker{mark:m})\n+    noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n }\n \n /// Check that there are no macro invocations left in the AST:"}, {"sha": "45f349eff31eabbda6a6708bea47575bef7d3ec3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -87,7 +87,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     if should_test {\n         generate_test_harness(sess, reexport_test_harness_main, krate, cfg, span_diagnostic)\n     } else {\n-        strip_test_functions(span_diagnostic, krate)\n+        strip_test_functions(krate)\n     }\n }\n \n@@ -312,14 +312,17 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(diagnostic: &errors::Handler, krate: ast::Crate)\n-                        -> ast::Crate {\n+fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    config::strip_items(diagnostic, krate, |attrs| {\n-        !attr::contains_name(&attrs[..], \"test\") &&\n-        !attr::contains_name(&attrs[..], \"bench\")\n-    })\n+    struct StripTests;\n+    impl config::CfgFolder for StripTests {\n+        fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n+            !attr::contains_name(attrs, \"test\") && !attr::contains_name(attrs, \"bench\")\n+        }\n+    }\n+\n+    StripTests.fold_crate(krate)\n }\n \n /// Craft a span that will be ignored by the stability lint's"}, {"sha": "77351f6e4f171f4dc40c33ce067700078e2e8d3f", "filename": "src/test/compile-fail/expanded-cfg.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Ftest%2Fcompile-fail%2Fexpanded-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b012ed142f03c9082773f5091c58c82d47cae79/src%2Ftest%2Fcompile-fail%2Fexpanded-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexpanded-cfg.rs?ref=8b012ed142f03c9082773f5091c58c82d47cae79", "patch": "@@ -8,15 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n+#![feature(custom_attribute, rustc_attrs)]\n \n macro_rules! mac {\n     {} => {\n         #[cfg(attr)]\n         mod m {\n             #[lang_item]\n             fn f() {}\n+\n+            #[cfg_attr(target_thread_local, custom)]\n+            fn g() {}\n         }\n+\n+        #[cfg(attr)]\n+        unconfigured_invocation!();\n     }\n }\n "}]}