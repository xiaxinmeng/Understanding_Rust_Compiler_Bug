{"sha": "9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDNlZTdiNTZiOTk2M2U2Yjk1YTU4ZmI0Mzk4NWEzZDlhNjM3ZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-06T12:50:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-06T12:50:47Z"}, "message": "Auto merge of #65089 - nnethercote:optimize-integral-pattern-matching, r=Mark-Simulacrum\n\nOptimize integral pattern matching\n\nVarious improvements to integral pattern matching. Together they reduce instruction counts for `unicode_normalization-check-clean` by about 16%.\n\nr? @Mark-Simulacrum", "tree": {"sha": "27a7ecad20d0e803a2f2970f5df93262ed039c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27a7ecad20d0e803a2f2970f5df93262ed039c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "html_url": "https://github.com/rust-lang/rust/commit/9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0358617e3f77e033c86139104c5c48a777824b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/0358617e3f77e033c86139104c5c48a777824b08", "html_url": "https://github.com/rust-lang/rust/commit/0358617e3f77e033c86139104c5c48a777824b08"}, {"sha": "2a3a5447418cc8e7a8b36ae4c9bdf8798a20b873", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3a5447418cc8e7a8b36ae4c9bdf8798a20b873", "html_url": "https://github.com/rust-lang/rust/commit/2a3a5447418cc8e7a8b36ae4c9bdf8798a20b873"}], "stats": {"total": 364, "additions": 199, "deletions": 165}, "files": [{"sha": "bbf00cc23ae8835008e18b6fc596fdf440afe47a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "patch": "@@ -343,14 +343,19 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn check_raw(data: u128, size: u8, target_size: Size) {\n+        assert_eq!(target_size.bytes(), size as u64);\n+        assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+        Scalar::check_data(data, size);\n+    }\n+\n     /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         match self {\n             Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n-                Scalar::check_data(data, size);\n+                Self::check_raw(data, size, target_size);\n                 Ok(data)\n             }\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),"}, {"sha": "41224ba40f33c771fb5a37e2eab08b440c0d2cc1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "patch": "@@ -13,7 +13,7 @@ use rustc_macros::HashStable;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef, GenericArg, GenericArgKind};\n use crate::ty::{self, AdtDef, Discr, DefIdTree, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{List, TyS, ParamEnvAnd, ParamEnv};\n-use crate::ty::layout::{Size, Integer, IntegerExt, VariantIdx};\n+use crate::ty::layout::VariantIdx;\n use crate::util::captures::Captures;\n use crate::mir::interpret::{Scalar, GlobalId};\n \n@@ -24,7 +24,6 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Ident};\n-use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n use self::InferTy::*;\n@@ -2300,20 +2299,7 @@ impl<'tcx> Const<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n         assert_eq!(self.ty, ty);\n-        // This is purely an optimization -- layout_of is a pretty expensive operation,\n-        // but if we can determine the size without calling it, we don't need all that complexity\n-        // (hashing, caching, etc.). As such, try to skip it.\n-        let size = match ty.kind {\n-            ty::Bool => Size::from_bytes(1),\n-            ty::Char => Size::from_bytes(4),\n-            ty::Int(ity) => {\n-                Integer::from_attr(&tcx, SignedInt(ity)).size()\n-            }\n-            ty::Uint(uty) => {\n-                Integer::from_attr(&tcx, UnsignedInt(uty)).size()\n-            }\n-            _ => tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size,\n-        };\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         self.eval(tcx, param_env).val.try_to_bits(size)\n     }"}, {"sha": "3ea58052877244bb2923f73ed4a77c0a6967f01f", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 189, "deletions": 146, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9203ee7b56b9963e6b95a58fb43985a3d9a637f6/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9203ee7b56b9963e6b95a58fb43985a3d9a637f6", "patch": "@@ -434,6 +434,13 @@ enum Constructor<'tcx> {\n }\n \n impl<'tcx> Constructor<'tcx> {\n+    fn is_slice(&self) -> bool {\n+        match self {\n+            Slice { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n     fn variant_index_for_adt<'a>(\n         &self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n@@ -827,44 +834,90 @@ struct IntRange<'tcx> {\n }\n \n impl<'tcx> IntRange<'tcx> {\n+    #[inline]\n+    fn is_integral(ty: Ty<'_>) -> bool {\n+        match ty.kind {\n+            ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline]\n+    fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n+        match ty.kind {\n+            ty::Char => Some((Size::from_bytes(4), 0)),\n+            ty::Int(ity) => {\n+                let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n+                Some((size, 1u128 << (size.bits() as u128 - 1)))\n+            }\n+            ty::Uint(uty) => Some((Integer::from_attr(&tcx, UnsignedInt(uty)).size(), 0)),\n+            _ => None,\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &Const<'tcx>,\n+    ) -> Option<IntRange<'tcx>> {\n+        if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n+            let ty = value.ty;\n+            let val = if let ConstValue::Scalar(Scalar::Raw { data, size }) = value.val {\n+                // For this specific pattern we can skip a lot of effort and go\n+                // straight to the result, after doing a bit of checking. (We\n+                // could remove this branch and just use the next branch, which\n+                // is more general but much slower.)\n+                Scalar::<()>::check_raw(data, size, target_size);\n+                data\n+            } else if let Some(val) = value.try_eval_bits(tcx, param_env, ty) {\n+                // This is a more general form of the previous branch.\n+                val\n+            } else {\n+                return None\n+            };\n+            let val = val ^ bias;\n+            Some(IntRange { range: val..=val, ty })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn from_range(\n+        tcx: TyCtxt<'tcx>,\n+        lo: u128,\n+        hi: u128,\n+        ty: Ty<'tcx>,\n+        end: &RangeEnd,\n+    ) -> Option<IntRange<'tcx>> {\n+        if Self::is_integral(ty) {\n+            // Perform a shift if the underlying types are signed,\n+            // which makes the interval arithmetic simpler.\n+            let bias = IntRange::signed_bias(tcx, ty);\n+            let (lo, hi) = (lo ^ bias, hi ^ bias);\n+            // Make sure the interval is well-formed.\n+            if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                None\n+            } else {\n+                let offset = (*end == RangeEnd::Excluded) as u128;\n+                Some(IntRange { range: lo..=(hi - offset), ty })\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn from_ctor(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n-        fn is_integral(ty: Ty<'_>) -> bool {\n-            match ty.kind {\n-                ty::Char | ty::Int(_) | ty::Uint(_) => true,\n-                _ => false,\n-            }\n-        }\n-\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) if is_integral(ty) => {\n-                // Perform a shift if the underlying types are signed,\n-                // which makes the interval arithmetic simpler.\n-                let bias = IntRange::signed_bias(tcx, ty);\n-                let (lo, hi) = (lo ^ bias, hi ^ bias);\n-                // Make sure the interval is well-formed.\n-                if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n-                    None\n-                } else {\n-                    let offset = (*end == RangeEnd::Excluded) as u128;\n-                    Some(IntRange { range: lo..=(hi - offset), ty })\n-                }\n-            }\n-            ConstantValue(val) if is_integral(val.ty) => {\n-                let ty = val.ty;\n-                if let Some(val) = val.try_eval_bits(tcx, param_env, ty) {\n-                    let bias = IntRange::signed_bias(tcx, ty);\n-                    let val = val ^ bias;\n-                    Some(IntRange { range: val..=val, ty })\n-                } else {\n-                    None\n-                }\n-            }\n+            ConstantRange(lo, hi, ty, end) => Self::from_range(tcx, *lo, *hi, ty, end),\n+            ConstantValue(val) => Self::from_const(tcx, param_env, val),\n             _ => None,\n         }\n     }\n@@ -874,22 +927,26 @@ impl<'tcx> IntRange<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         mut pat: &Pat<'tcx>,\n     ) -> Option<IntRange<'tcx>> {\n-        let range = loop {\n+        loop {\n             match pat.kind {\n-                box PatKind::Constant { value } => break ConstantValue(value),\n-                box PatKind::Range(PatRange { lo, hi, end }) => break ConstantRange(\n-                    lo.eval_bits(tcx, param_env, lo.ty),\n-                    hi.eval_bits(tcx, param_env, hi.ty),\n-                    lo.ty,\n-                    end,\n-                ),\n+                box PatKind::Constant { value } => {\n+                    return Self::from_const(tcx, param_env, value);\n+                }\n+                box PatKind::Range(PatRange { lo, hi, end }) => {\n+                    return Self::from_range(\n+                        tcx,\n+                        lo.eval_bits(tcx, param_env, lo.ty),\n+                        hi.eval_bits(tcx, param_env, hi.ty),\n+                        &lo.ty,\n+                        &end,\n+                    );\n+                }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n                 },\n                 _ => return None,\n             }\n-        };\n-        Self::from_ctor(tcx, param_env, &range)\n+        }\n     }\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n@@ -1298,9 +1355,11 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n         }\n     }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n-    let matrix = Matrix(m.iter().flat_map(|r| {\n-        specialize(cx, &r, &ctor, &wild_patterns)\n-    }).collect());\n+    let matrix = Matrix(\n+        m.iter()\n+            .filter_map(|r| specialize(cx, &r, &ctor, &wild_patterns))\n+            .collect()\n+    );\n     match specialize(cx, v, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v, witness) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n@@ -1618,36 +1677,6 @@ fn split_grouped_constructors<'p, 'tcx>(\n     split_ctors\n }\n \n-/// Checks whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n-fn constructor_intersects_pattern<'p, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    pat: &'p Pat<'tcx>,\n-) -> Option<SmallVec<[&'p Pat<'tcx>; 2]>> {\n-    if should_treat_range_exhaustively(tcx, ctor) {\n-        match (IntRange::from_ctor(tcx, param_env, ctor), IntRange::from_pat(tcx, param_env, pat)) {\n-            (Some(ctor), Some(pat)) => {\n-                ctor.intersection(&pat).map(|_| {\n-                    let (pat_lo, pat_hi) = pat.range.into_inner();\n-                    let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n-                    assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n-                    smallvec![]\n-                })\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        // Fallback for non-ranges and ranges that involve floating-point numbers, which are not\n-        // conveniently handled by `IntRange`. For these cases, the constructor may not be a range\n-        // so intersection actually devolves into being covered by the pattern.\n-        match constructor_covered_by_range(tcx, param_env, ctor, pat) {\n-            Ok(true) => Some(smallvec![]),\n-            Ok(false) | Err(ErrorReported) => None,\n-        }\n-    }\n-}\n-\n fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -1766,90 +1795,104 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             Some(smallvec![subpattern])\n         }\n \n-        PatKind::Constant { value } => {\n-            match *constructor {\n-                Slice(..) => {\n-                    // we extract an `Option` for the pointer because slices of zero elements don't\n-                    // necessarily point to memory, they are usually just integers. The only time\n-                    // they should be pointing to memory is when they are subslices of nonzero\n-                    // slices\n-                    let (alloc, offset, n, ty) = match value.ty.kind {\n-                        ty::Array(t, n) => {\n-                            match value.val {\n-                                ConstValue::ByRef { offset, alloc, .. } => (\n-                                    alloc,\n-                                    offset,\n-                                    n.eval_usize(cx.tcx, cx.param_env),\n-                                    t,\n-                                ),\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"array pattern is {:?}\", value,\n-                                ),\n-                            }\n-                        },\n-                        ty::Slice(t) => {\n-                            match value.val {\n-                                ConstValue::Slice { data, start, end } => (\n-                                    data,\n-                                    Size::from_bytes(start as u64),\n-                                    (end - start) as u64,\n-                                    t,\n-                                ),\n-                                ConstValue::ByRef { .. } => {\n-                                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                                    return None;\n-                                },\n-                                _ => span_bug!(\n-                                    pat.span,\n-                                    \"slice pattern constant must be scalar pair but is {:?}\",\n-                                    value,\n-                                ),\n-                            }\n+        PatKind::Constant { value } if constructor.is_slice() => {\n+            // We extract an `Option` for the pointer because slices of zero\n+            // elements don't necessarily point to memory, they are usually\n+            // just integers. The only time they should be pointing to memory\n+            // is when they are subslices of nonzero slices.\n+            let (alloc, offset, n, ty) = match value.ty.kind {\n+                ty::Array(t, n) => {\n+                    match value.val {\n+                        ConstValue::ByRef { offset, alloc, .. } => (\n+                            alloc,\n+                            offset,\n+                            n.eval_usize(cx.tcx, cx.param_env),\n+                            t,\n+                        ),\n+                        _ => span_bug!(\n+                            pat.span,\n+                            \"array pattern is {:?}\", value,\n+                        ),\n+                    }\n+                },\n+                ty::Slice(t) => {\n+                    match value.val {\n+                        ConstValue::Slice { data, start, end } => (\n+                            data,\n+                            Size::from_bytes(start as u64),\n+                            (end - start) as u64,\n+                            t,\n+                        ),\n+                        ConstValue::ByRef { .. } => {\n+                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n+                            return None;\n                         },\n                         _ => span_bug!(\n                             pat.span,\n-                            \"unexpected const-val {:?} with ctor {:?}\",\n+                            \"slice pattern constant must be scalar pair but is {:?}\",\n                             value,\n-                            constructor,\n                         ),\n-                    };\n-                    if wild_patterns.len() as u64 == n {\n-                        // convert a constant slice/array pattern to a list of patterns.\n-                        let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                        let ptr = Pointer::new(AllocId(0), offset);\n-                        (0..n).map(|i| {\n-                            let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                            let scalar = alloc.read_scalar(\n-                                &cx.tcx, ptr, layout.size,\n-                            ).ok()?;\n-                            let scalar = scalar.not_undef().ok()?;\n-                            let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                            let pattern = Pat {\n-                                ty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant { value },\n-                            };\n-                            Some(&*cx.pattern_arena.alloc(pattern))\n-                        }).collect()\n-                    } else {\n-                        None\n                     }\n-                }\n-                _ => {\n-                    // If the constructor is a:\n-                    //      Single value: add a row if the constructor equals the pattern.\n-                    //      Range: add a row if the constructor contains the pattern.\n-                    constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n-                }\n+                },\n+                _ => span_bug!(\n+                    pat.span,\n+                    \"unexpected const-val {:?} with ctor {:?}\",\n+                    value,\n+                    constructor,\n+                ),\n+            };\n+            if wild_patterns.len() as u64 == n {\n+                // convert a constant slice/array pattern to a list of patterns.\n+                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+                let ptr = Pointer::new(AllocId(0), offset);\n+                (0..n).map(|i| {\n+                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                    let scalar = alloc.read_scalar(\n+                        &cx.tcx, ptr, layout.size,\n+                    ).ok()?;\n+                    let scalar = scalar.not_undef().ok()?;\n+                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                    let pattern = Pat {\n+                        ty,\n+                        span: pat.span,\n+                        kind: box PatKind::Constant { value },\n+                    };\n+                    Some(&*cx.pattern_arena.alloc(pattern))\n+                }).collect()\n+            } else {\n+                None\n             }\n         }\n \n+        PatKind::Constant { .. } |\n         PatKind::Range { .. } => {\n             // If the constructor is a:\n-            //      Single value: add a row if the pattern contains the constructor.\n-            //      Range: add a row if the constructor intersects the pattern.\n-            constructor_intersects_pattern(cx.tcx, cx.param_env, constructor, pat)\n+            // - Single value: add a row if the pattern contains the constructor.\n+            // - Range: add a row if the constructor intersects the pattern.\n+            if should_treat_range_exhaustively(cx.tcx, constructor) {\n+                match (IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n+                       IntRange::from_pat(cx.tcx, cx.param_env, pat)) {\n+                    (Some(ctor), Some(pat)) => {\n+                        ctor.intersection(&pat).map(|_| {\n+                            let (pat_lo, pat_hi) = pat.range.into_inner();\n+                            let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n+                            assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n+                            smallvec![]\n+                        })\n+                    }\n+                    _ => None,\n+                }\n+            } else {\n+                // Fallback for non-ranges and ranges that involve\n+                // floating-point numbers, which are not conveniently handled\n+                // by `IntRange`. For these cases, the constructor may not be a\n+                // range so intersection actually devolves into being covered\n+                // by the pattern.\n+                match constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat) {\n+                    Ok(true) => Some(smallvec![]),\n+                    Ok(false) | Err(ErrorReported) => None,\n+                }\n+            }\n         }\n \n         PatKind::Array { ref prefix, ref slice, ref suffix } |"}]}