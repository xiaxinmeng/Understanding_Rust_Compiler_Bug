{"sha": "5315934d888797432d62ec4a55303aeacb8cd286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMTU5MzRkODg4Nzk3NDMyZDYyZWM0YTU1MzAzYWVhY2I4Y2QyODY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-03T16:22:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-03T16:26:50Z"}, "message": "Don't store generated docs in the repo", "tree": {"sha": "9cd37b2ad18029c098529d91ef89443ac8e13b22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd37b2ad18029c098529d91ef89443ac8e13b22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5315934d888797432d62ec4a55303aeacb8cd286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5315934d888797432d62ec4a55303aeacb8cd286", "html_url": "https://github.com/rust-lang/rust/commit/5315934d888797432d62ec4a55303aeacb8cd286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5315934d888797432d62ec4a55303aeacb8cd286/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "636f597a86cbb72194dd9c867563a77ddcf50c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/636f597a86cbb72194dd9c867563a77ddcf50c44", "html_url": "https://github.com/rust-lang/rust/commit/636f597a86cbb72194dd9c867563a77ddcf50c44"}], "stats": {"total": 1344, "additions": 16, "deletions": 1328}, "files": [{"sha": "aef0fac3397fdf8b3549df237953e0b69522d0ab", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -8,3 +8,5 @@ crates/*/target\n *.iml\n .vscode/settings.json\n *.html\n+generated_assists.adoc\n+generated_features.adoc"}, {"sha": "4d2fb31d4840fe50f9a86ffeb8ebd9a62500bb7f", "filename": "docs/user/generated_assists.adoc", "status": "removed", "additions": 0, "deletions": 1015, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/636f597a86cbb72194dd9c867563a77ddcf50c44/docs%2Fuser%2Fgenerated_assists.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/636f597a86cbb72194dd9c867563a77ddcf50c44/docs%2Fuser%2Fgenerated_assists.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_assists.adoc?ref=636f597a86cbb72194dd9c867563a77ddcf50c44", "patch": "@@ -1,1015 +0,0 @@\n-[discrete]\n-=== `add_custom_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_custom_impl.rs#L14[add_custom_impl.rs]\n-\n-Adds impl block for derived trait.\n-\n-.Before\n-```rust\n-#[derive(Deb\u2503ug, Display)]\n-struct S;\n-```\n-\n-.After\n-```rust\n-#[derive(Display)]\n-struct S;\n-\n-impl Debug for S {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_derive`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_derive.rs#L9[add_derive.rs]\n-\n-Adds a new `#[derive()]` clause to a struct or enum.\n-\n-.Before\n-```rust\n-struct Point {\n-    x: u32,\n-    y: u32,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-#[derive($0)]\n-struct Point {\n-    x: u32,\n-    y: u32,\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_explicit_type`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_explicit_type.rs#L9[add_explicit_type.rs]\n-\n-Specify type for a let binding.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 92;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let x: i32 = 92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_from_impl_for_enum`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_from_impl_for_enum.rs#L7[add_from_impl_for_enum.rs]\n-\n-Adds a From impl for an enum variant with one tuple field.\n-\n-.Before\n-```rust\n-enum A { \u2503One(u32) }\n-```\n-\n-.After\n-```rust\n-enum A { One(u32) }\n-\n-impl From<u32> for A {\n-    fn from(v: u32) -> Self {\n-        A::One(v)\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_function`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_function.rs#L19[add_function.rs]\n-\n-Adds a stub function with a signature matching the function under the cursor.\n-\n-.Before\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar\u2503(\"\", baz());\n-}\n-\n-```\n-\n-.After\n-```rust\n-struct Baz;\n-fn baz() -> Baz { Baz }\n-fn foo() {\n-    bar(\"\", baz());\n-}\n-\n-fn bar(arg: &str, baz: Baz) {\n-    ${0:todo!()}\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L65[raw_string.rs]\n-\n-Adds a hash to a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r##\"Hello, World!\"##;\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_impl.rs#L6[add_impl.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-    data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    $0\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_default_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L64[add_missing_impl_members.rs]\n-\n-Adds scaffold for overriding default impl members.\n-\n-.Before\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait {\n-    Type X;\n-    fn foo(&self);\n-    fn bar(&self) {}\n-}\n-\n-impl Trait for () {\n-    Type X = ();\n-    fn foo(&self) {}\n-    $0fn bar(&self) {}\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_impl_missing_members`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_missing_impl_members.rs#L24[add_missing_impl_members.rs]\n-\n-Adds scaffold for required impl members.\n-\n-.Before\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\u2503\n-\n-}\n-```\n-\n-.After\n-```rust\n-trait Trait<T> {\n-    Type X;\n-    fn foo(&self) -> T;\n-    fn bar(&self) {}\n-}\n-\n-impl Trait<u32> for () {\n-    fn foo(&self) -> u32 {\n-        ${0:todo!()}\n-    }\n-\n-}\n-```\n-\n-\n-[discrete]\n-=== `add_new`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_new.rs#L12[add_new.rs]\n-\n-Adds a new inherent impl for a type.\n-\n-.Before\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\u2503\n-}\n-```\n-\n-.After\n-```rust\n-struct Ctx<T: Clone> {\n-     data: T,\n-}\n-\n-impl<T: Clone> Ctx<T> {\n-    fn $0new(data: T) -> Self { Self { data } }\n-}\n-\n-```\n-\n-\n-[discrete]\n-=== `add_turbo_fish`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/add_turbo_fish.rs#L10[add_turbo_fish.rs]\n-\n-Adds `::<_>` to a call of a generic method or function.\n-\n-.Before\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make\u2503();\n-}\n-```\n-\n-.After\n-```rust\n-fn make<T>() -> T { todo!() }\n-fn main() {\n-    let x = make::<${0:_}>();\n-}\n-```\n-\n-\n-[discrete]\n-=== `apply_demorgan`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/apply_demorgan.rs#L5[apply_demorgan.rs]\n-\n-Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n-This transforms expressions of the form `!l || !r` into `!(l && r)`.\n-This also works with `&&`. This assist can only be applied with the cursor\n-on either `||` or `&&`, with both operands being a negation of some kind.\n-This means something of the form `!x` or `x != y`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if x != 4 ||\u2503 !y {}\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !(x == 4 && y) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `auto_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/auto_import.rs#L18[auto_import.rs]\n-\n-If the name is unresolved, provides all possible imports for it.\n-\n-.Before\n-```rust\n-fn main() {\n-    let map = HashMap\u2503::new();\n-}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn main() {\n-    let map = HashMap::new();\n-}\n-```\n-\n-\n-[discrete]\n-=== `change_return_type_to_result`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_return_type_to_result.rs#L8[change_return_type_to_result.rs]\n-\n-Change the function's return type to Result.\n-\n-.Before\n-```rust\n-fn foo() -> i32\u2503 { 42i32 }\n-```\n-\n-.After\n-```rust\n-fn foo() -> Result<i32, ${0:_}> { Ok(42i32) }\n-```\n-\n-\n-[discrete]\n-=== `change_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/change_visibility.rs#L14[change_visibility.rs]\n-\n-Adds or changes existing visibility specifier.\n-\n-.Before\n-```rust\n-\u2503fn frobnicate() {}\n-```\n-\n-.After\n-```rust\n-pub(crate) fn frobnicate() {}\n-```\n-\n-\n-[discrete]\n-=== `convert_to_guarded_return`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/early_return.rs#L21[early_return.rs]\n-\n-Replace a large conditional with a guarded return.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503if cond {\n-        foo();\n-        bar();\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if !cond {\n-        return;\n-    }\n-    foo();\n-    bar();\n-}\n-```\n-\n-\n-[discrete]\n-=== `fill_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fill_match_arms.rs#L14[fill_match_arms.rs]\n-\n-Adds missing clauses to a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        $0Action::Move { distance } => {}\n-        Action::Stop => {}\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `fix_visibility`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/fix_visibility.rs#L13[fix_visibility.rs]\n-\n-Makes inaccessible item public.\n-\n-.Before\n-```rust\n-mod m {\n-    fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate\u2503() {}\n-}\n-```\n-\n-.After\n-```rust\n-mod m {\n-    $0pub(crate) fn frobnicate() {}\n-}\n-fn main() {\n-    m::frobnicate() {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_binexpr`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_binexpr.rs#L5[flip_binexpr.rs]\n-\n-Flips operands of a binary expression.\n-\n-.Before\n-```rust\n-fn main() {\n-    let _ = 90 +\u2503 2;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let _ = 2 + 90;\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_comma`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_comma.rs#L5[flip_comma.rs]\n-\n-Flips two comma-separated items.\n-\n-.Before\n-```rust\n-fn main() {\n-    ((1, 2),\u2503 (3, 4));\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    ((3, 4), (1, 2));\n-}\n-```\n-\n-\n-[discrete]\n-=== `flip_trait_bound`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/flip_trait_bound.rs#L9[flip_trait_bound.rs]\n-\n-Flips two trait bounds.\n-\n-.Before\n-```rust\n-fn foo<T: Clone +\u2503 Copy>() { }\n-```\n-\n-.After\n-```rust\n-fn foo<T: Copy + Clone>() { }\n-```\n-\n-\n-[discrete]\n-=== `inline_local_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/inline_local_variable.rs#L13[inline_local_variable.rs]\n-\n-Inlines local variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    let x\u2503 = 1 + 2;\n-    x * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    (1 + 2) * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_named_lifetime`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_named_lifetime.rs#L12[introduce_named_lifetime.rs]\n-\n-Change an anonymous lifetime to a named lifetime.\n-\n-.Before\n-```rust\n-impl Cursor<'_\u2503> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-impl<'a> Cursor<'a> {\n-    fn node(self) -> &SyntaxNode {\n-        match self {\n-            Cursor::Replace(node) | Cursor::Before(node) => node,\n-        }\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `introduce_variable`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/introduce_variable.rs#L14[introduce_variable.rs]\n-\n-Extracts subexpression into a variable.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503(1 + 2)\u2503 * 4;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    let $0var_name = (1 + 2);\n-    var_name * 4;\n-}\n-```\n-\n-\n-[discrete]\n-=== `invert_if`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/invert_if.rs#L12[invert_if.rs]\n-\n-Apply invert_if\n-This transforms if expressions of the form `if !x {A} else {B}` into `if x {B} else {A}`\n-This also works with `!=`. This assist can only be applied with the cursor\n-on `if`.\n-\n-.Before\n-```rust\n-fn main() {\n-    if\u2503 !y { A } else { B }\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    if y { B } else { A }\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_raw_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L10[raw_string.rs]\n-\n-Adds `r#` to a plain string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    \"Hello,\u2503 World!\";\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r#\"Hello, World!\"#;\n-}\n-```\n-\n-\n-[discrete]\n-=== `make_usual_string`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L39[raw_string.rs]\n-\n-Turns a raw string into a plain string.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 \"World!\"\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    \"Hello, \\\"World!\\\"\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `merge_imports`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_imports.rs#L14[merge_imports.rs]\n-\n-Merges two imports with a common prefix.\n-\n-.Before\n-```rust\n-use std::\u2503fmt::Formatter;\n-use std::io;\n-```\n-\n-.After\n-```rust\n-use std::{fmt::Formatter, io};\n-```\n-\n-\n-[discrete]\n-=== `merge_match_arms`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/merge_match_arms.rs#L11[merge_match_arms.rs]\n-\n-Merges identical match arms.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        \u2503Action::Move(..) => foo(),\n-        Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move(..) | Action::Stop => foo(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_arm_cond_to_match_guard`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L56[move_guard.rs]\n-\n-Moves if expression from match arm body into a guard.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => \u2503if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_bounds_to_where_clause`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_bounds.rs#L10[move_bounds.rs]\n-\n-Moves inline type bounds to a where clause.\n-\n-.Before\n-```rust\n-fn apply<T, U, \u2503F: FnOnce(T) -> U>(f: F, x: T) -> U {\n-    f(x)\n-}\n-```\n-\n-.After\n-```rust\n-fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n-    f(x)\n-}\n-```\n-\n-\n-[discrete]\n-=== `move_guard_to_arm_body`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/move_guard.rs#L8[move_guard.rs]\n-\n-Moves match guard into match arm body.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } \u2503if distance > 10 => foo(),\n-        _ => (),\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => if distance > 10 { foo() },\n-        _ => (),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_dbg`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_dbg.rs#L8[remove_dbg.rs]\n-\n-Removes `dbg!()` macro call.\n-\n-.Before\n-```rust\n-fn main() {\n-    \u2503dbg!(92);\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    92;\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_hash`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/raw_string.rs#L89[raw_string.rs]\n-\n-Removes a hash from a raw string literal.\n-\n-.Before\n-```rust\n-fn main() {\n-    r#\"Hello,\u2503 World!\"#;\n-}\n-```\n-\n-.After\n-```rust\n-fn main() {\n-    r\"Hello, World!\";\n-}\n-```\n-\n-\n-[discrete]\n-=== `remove_mut`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/remove_mut.rs#L5[remove_mut.rs]\n-\n-Removes the `mut` keyword.\n-\n-.Before\n-```rust\n-impl Walrus {\n-    fn feed(&mut\u2503 self, amount: u32) {}\n-}\n-```\n-\n-.After\n-```rust\n-impl Walrus {\n-    fn feed(&self, amount: u32) {}\n-}\n-```\n-\n-\n-[discrete]\n-=== `reorder_fields`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/reorder_fields.rs#L10[reorder_fields.rs]\n-\n-Reorder the fields of record literals and record patterns in the same order as in\n-the definition.\n-\n-.Before\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = \u2503Foo {bar: 0, foo: 1}\n-```\n-\n-.After\n-```rust\n-struct Foo {foo: i32, bar: i32};\n-const test: Foo = Foo {foo: 1, bar: 0}\n-```\n-\n-\n-[discrete]\n-=== `replace_if_let_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_if_let_with_match.rs#L13[replace_if_let_with_match.rs]\n-\n-Replaces `if let` with an else branch with a `match` expression.\n-\n-.Before\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    \u2503if let Action::Move { distance } = action {\n-        foo(distance)\n-    } else {\n-        bar()\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-enum Action { Move { distance: u32 }, Stop }\n-\n-fn handle(action: Action) {\n-    match action {\n-        Action::Move { distance } => foo(distance),\n-        _ => bar(),\n-    }\n-}\n-```\n-\n-\n-[discrete]\n-=== `replace_let_with_if_let`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_let_with_if_let.rs#L14[replace_let_with_if_let.rs]\n-\n-Replaces `let` with an `if-let`.\n-\n-.Before\n-```rust\n-\n-fn main(action: Action) {\n-    \u2503let x = compute();\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-.After\n-```rust\n-\n-fn main(action: Action) {\n-    if let Some(x) = compute() {\n-    }\n-}\n-\n-fn compute() -> Option<i32> { None }\n-```\n-\n-\n-[discrete]\n-=== `replace_qualified_name_with_use`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs#L6[replace_qualified_name_with_use.rs]\n-\n-Adds a use statement for a given fully-qualified name.\n-\n-.Before\n-```rust\n-fn process(map: std::collections::\u2503HashMap<String, String>) {}\n-```\n-\n-.After\n-```rust\n-use std::collections::HashMap;\n-\n-fn process(map: HashMap<String, String>) {}\n-```\n-\n-\n-[discrete]\n-=== `replace_unwrap_with_match`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/replace_unwrap_with_match.rs#L17[replace_unwrap_with_match.rs]\n-\n-Replaces `unwrap` a `match` expression. Works for Result and Option.\n-\n-.Before\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = x.\u2503unwrap();\n-}\n-```\n-\n-.After\n-```rust\n-enum Result<T, E> { Ok(T), Err(E) }\n-fn main() {\n-    let x: Result<i32, i32> = Result::Ok(92);\n-    let y = match x {\n-        Ok(a) => a,\n-        $0_ => unreachable!(),\n-    };\n-}\n-```\n-\n-\n-[discrete]\n-=== `split_import`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/split_import.rs#L7[split_import.rs]\n-\n-Wraps the tail of import into braces.\n-\n-.Before\n-```rust\n-use std::\u2503collections::HashMap;\n-```\n-\n-.After\n-```rust\n-use std::{collections::HashMap};\n-```\n-\n-\n-[discrete]\n-=== `unwrap_block`\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_assists/src/handlers/unwrap_block.rs#L9[unwrap_block.rs]\n-\n-This assist removes if...else, for, while and loop control statements to just keep the body.\n-\n-.Before\n-```rust\n-fn foo() {\n-    if true {\u2503\n-        println!(\"foo\");\n-    }\n-}\n-```\n-\n-.After\n-```rust\n-fn foo() {\n-    println!(\"foo\");\n-}\n-```"}, {"sha": "4b93b759fa424389acbf57624ef50b8b04314b96", "filename": "docs/user/generated_features.adoc", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/636f597a86cbb72194dd9c867563a77ddcf50c44/docs%2Fuser%2Fgenerated_features.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/636f597a86cbb72194dd9c867563a77ddcf50c44/docs%2Fuser%2Fgenerated_features.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_features.adoc?ref=636f597a86cbb72194dd9c867563a77ddcf50c44", "patch": "@@ -1,298 +0,0 @@\n-=== Expand Macro Recursively\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/expand_macro.rs#L15[expand_macro.rs]\n-\n-Shows the full macro expansion of the macro at current cursor.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Expand macro recursively**\n-|===\n-\n-\n-=== Extend Selection\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/extend_selection.rs#L15[extend_selection.rs]\n-\n-Extends the current selection to the encompassing syntactic construct\n-(expression, statement, item, module, etc). It works with multiple cursors.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+Shift+\u2192]\n-|===\n-\n-\n-=== File Structure\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/display/structure.rs#L17[structure.rs]\n-\n-Provides a tree of the symbols defined in the file. Can be used to\n-\n-* fuzzy search symbol in a file (super useful)\n-* draw breadcrumbs to describe the context around the cursor\n-* draw outline of the file\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+Shift+O]\n-|===\n-\n-\n-=== Go to Definition\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_definition.rs#L18[goto_definition.rs]\n-\n-Navigates to the definition of an identifier.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[F12]\n-|===\n-\n-\n-=== Go to Implementation\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_implementation.rs#L7[goto_implementation.rs]\n-\n-Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+F12]\n-|===\n-\n-\n-=== Go to Type Definition\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_type_definition.rs#L6[goto_type_definition.rs]\n-\n-Navigates to the type of an identifier.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Go to Type Definition*\n-|===\n-\n-\n-=== Hover\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs#L58[hover.rs]\n-\n-Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n-Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n-\n-\n-=== Inlay Hints\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/inlay_hints.rs#L40[inlay_hints.rs]\n-\n-rust-analyzer shows additional information inline with the source code.\n-Editors usually render this using read-only virtual text snippets interspersed with code.\n-\n-rust-analyzer shows hits for\n-\n-* types of local variables\n-* names of function arguments\n-* types of chained expressions\n-\n-**Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n-This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n-https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Toggle inlay hints*\n-|===\n-\n-\n-=== Join Lines\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/join_lines.rs#L12[join_lines.rs]\n-\n-Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Join lines**\n-|===\n-\n-\n-=== Magic Completions\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/completion.rs#L38[completion.rs]\n-\n-In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n-completions as well:\n-\n-Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n-is placed at the appropriate position. Even though `if` is easy to type, you\n-still want to complete it, to get ` { }` for free! `return` is inserted with a\n-space or `;` depending on the return type of the function.\n-\n-When completing a function call, `()` are automatically inserted. If a function\n-takes arguments, the cursor is positioned inside the parenthesis.\n-\n-There are postfix completions, which can be triggered by typing something like\n-`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n-\n-- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n-- `expr.match` -> `match expr {}`\n-- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n-- `expr.ref` -> `&expr`\n-- `expr.refm` -> `&mut expr`\n-- `expr.not` -> `!expr`\n-- `expr.dbg` -> `dbg!(expr)`\n-\n-There also snippet completions:\n-\n-.Expressions\n-- `pd` -> `println!(\"{:?}\")`\n-- `ppd` -> `println!(\"{:#?}\")`\n-\n-.Items\n-- `tfn` -> `#[test] fn f(){}`\n-- `tmod` ->\n-```rust\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_fn() {}\n-}\n-```\n-\n-\n-=== Matching Brace\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/matching_brace.rs#L3[matching_brace.rs]\n-\n-If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n-moves cursor to the matching brace. It uses the actual parser to determine\n-braces, so it won't confuse generics with comparisons.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Find matching brace**\n-|===\n-\n-\n-=== On Typing Assists\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs#L35[typing.rs]\n-\n-Some features trigger on typing certain characters:\n-\n-- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n-- Enter inside comments automatically inserts `///`\n-- typing `.` in a chain method call auto-indents\n-\n-\n-=== Parent Module\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/parent_module.rs#L12[parent_module.rs]\n-\n-Navigates to the parent module of the current module.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Locate parent module**\n-|===\n-\n-\n-=== Run\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/runnables.rs#L45[runnables.rs]\n-\n-Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n-location**. Super useful for repeatedly running just a single test. Do bind this\n-to a shortcut!\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Run**\n-|===\n-\n-\n-=== Semantic Syntax Highlighting\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs#L33[syntax_highlighting.rs]\n-\n-rust-analyzer highlights the code semantically.\n-For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n-rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n-It's up to the client to map those to specific colors.\n-\n-The general rule is that a reference to an entity gets colored the same way as the entity itself.\n-We also give special modifier for `mut` and `&mut` local variables.\n-\n-\n-=== Show Syntax Tree\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_tree.rs#L9[syntax_tree.rs]\n-\n-Shows the parse tree of the current file. It exists mostly for debugging\n-rust-analyzer itself.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Show Syntax Tree**\n-|===\n-\n-\n-=== Status\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/status.rs#L27[status.rs]\n-\n-Shows internal statistic about memory usage of rust-analyzer.\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Status**\n-|===\n-\n-\n-=== Structural Seach and Replace\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/ssr.rs#L26[ssr.rs]\n-\n-Search and replace with named wildcards that will match any expression.\n-The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n-A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n-Available via the command `rust-analyzer.ssr`.\n-\n-```rust\n-// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n-\n-// BEFORE\n-String::from(foo(y + 5, z))\n-\n-// AFTER\n-String::from((y + 5).foo(z))\n-```\n-\n-|===\n-| Editor  | Action Name\n-\n-| VS Code | **Rust Analyzer: Structural Search Replace**\n-|===\n-\n-\n-=== Workspace Symbol\n-**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs#L113[symbol_index.rs]\n-\n-Uses fuzzy-search to find types, modules and functions by name across your\n-project and dependencies. This is **the** most useful feature, which improves code\n-navigation tremendously. It mostly works on top of the built-in LSP\n-functionality, however `#` and `*` symbols can be used to narrow down the\n-search. Specifically,\n-\n-- `Foo` searches for `Foo` type in the current workspace\n-- `foo#` searches for `foo` function in the current workspace\n-- `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n-- `foo#*` searches for `foo` function among dependencies\n-\n-That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n-workspace to dependencies.\n-\n-|===\n-| Editor  | Shortcut\n-\n-| VS Code | kbd:[Ctrl+T]\n-|==="}, {"sha": "f5f4b964a4c1a2a16c05b6b25821965ead780807", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -18,8 +18,10 @@ use std::{\n use crate::{not_bash::fs2, project_root, Result};\n \n pub use self::{\n-    gen_assists_docs::generate_assists_docs, gen_feature_docs::generate_feature_docs,\n-    gen_parser_tests::generate_parser_tests, gen_syntax::generate_syntax,\n+    gen_assists_docs::{generate_assists_docs, generate_assists_tests},\n+    gen_feature_docs::generate_feature_docs,\n+    gen_parser_tests::generate_parser_tests,\n+    gen_syntax::generate_syntax,\n };\n \n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";"}, {"sha": "526941f73aceb05338fe7dc7d0b234796ce0e8de", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -7,16 +7,17 @@ use crate::{\n     project_root, rust_files, Result,\n };\n \n-pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+pub fn generate_assists_tests(mode: Mode) -> Result<()> {\n     let assists = Assist::collect()?;\n-    generate_tests(&assists, mode)?;\n+    generate_tests(&assists, mode)\n+}\n \n+pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n+    let assists = Assist::collect()?;\n     let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n     let contents = contents.trim().to_string() + \"\\n\";\n     let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n-    codegen::update(&dst, &contents, mode)?;\n-\n-    Ok(())\n+    codegen::update(&dst, &contents, mode)\n }\n \n #[derive(Debug)]"}, {"sha": "739f49f7be8183dde593fafa619b0e248c218938", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -160,6 +160,8 @@ pub fn run_release(dry_run: bool) -> Result<()> {\n         run!(\"git reset --hard tags/nightly\")?;\n         run!(\"git push\")?;\n     }\n+    codegen::generate_assists_docs(Mode::Overwrite)?;\n+    codegen::generate_feature_docs(Mode::Overwrite)?;\n \n     let website_root = project_root().join(\"../rust-analyzer.github.io\");\n     let changelog_dir = website_root.join(\"./thisweek/_posts\");"}, {"sha": "81bb3a33f29e5118a10a817c181c62504793006c", "filename": "xtask/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -74,6 +74,7 @@ FLAGS:\n             args.finish()?;\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n+            codegen::generate_assists_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n             codegen::generate_feature_docs(Mode::Overwrite)?;\n             Ok(())"}, {"sha": "d38ac7f17e78e818069db71dd0e3b07a6dd22f22", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5315934d888797432d62ec4a55303aeacb8cd286/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=5315934d888797432d62ec4a55303aeacb8cd286", "patch": "@@ -25,18 +25,11 @@ fn generated_tests_are_fresh() {\n \n #[test]\n fn generated_assists_are_fresh() {\n-    if let Err(error) = codegen::generate_assists_docs(Mode::Verify) {\n+    if let Err(error) = codegen::generate_assists_tests(Mode::Verify) {\n         panic!(\"{}. Please update assists by running `cargo xtask codegen`\", error);\n     }\n }\n \n-#[test]\n-fn generated_features_are_fresh() {\n-    if let Err(error) = codegen::generate_feature_docs(Mode::Verify) {\n-        panic!(\"{}. Please update features by running `cargo xtask codegen`\", error);\n-    }\n-}\n-\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Mode::Verify) {"}]}