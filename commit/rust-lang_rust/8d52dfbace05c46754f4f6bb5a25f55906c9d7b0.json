{"sha": "8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTJkZmJhY2UwNWM0Njc1NGY0ZjZiYjVhMjVmNTU5MDZjOWQ3YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-15T14:56:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-15T14:56:27Z"}, "message": "auto merge of #10984 : huonw/rust/clean-raw, r=cmr\n\nSee commits for details.", "tree": {"sha": "2fe29e4faba8034176fe5c1f14bd2659ca0c7235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fe29e4faba8034176fe5c1f14bd2659ca0c7235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "html_url": "https://github.com/rust-lang/rust/commit/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef7969e86f0b53e4236ca627b31ac09413c07b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef7969e86f0b53e4236ca627b31ac09413c07b82", "html_url": "https://github.com/rust-lang/rust/commit/ef7969e86f0b53e4236ca627b31ac09413c07b82"}, {"sha": "164f7a290ef98377e4c8c158eca2fbed098a2842", "url": "https://api.github.com/repos/rust-lang/rust/commits/164f7a290ef98377e4c8c158eca2fbed098a2842", "html_url": "https://github.com/rust-lang/rust/commit/164f7a290ef98377e4c8c158eca2fbed098a2842"}], "stats": {"total": 533, "additions": 231, "deletions": 302}, "files": [{"sha": "088970bf00d2829c5fb6c44f173d1aeca7ac87f7", "filename": "doc/po/ja/tutorial-ffi.md.po", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial-ffi.md.po?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -168,7 +168,7 @@ msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"pub fn validate_compressed_buffer(src: &[u8]) -> bool {\\n\"\n \"    unsafe {\\n\"\n-\"        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\\n\"\n+\"        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\\n\"\n \"    }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -207,7 +207,7 @@ msgid \"\"\n \"pub fn compress(src: &[u8]) -> ~[u8] {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -216,15 +216,15 @@ msgstr \"\"\n msgid \"\"\n \"        let mut dstlen = snappy_max_compressed_length(srclen);\\n\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-ffi.md:113\n #, no-wrap\n msgid \"\"\n \"        snappy_compress(psrc, srclen, pdst, &mut dstlen);\\n\"\n-\"        vec::raw::set_len(&mut dst, dstlen as uint);\\n\"\n+\"        dst.set_len(dstlen as uint);\\n\"\n \"        dst\\n\"\n \"    }\\n\"\n \"}\\n\"\n@@ -247,7 +247,7 @@ msgid \"\"\n \"pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -263,15 +263,15 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-ffi.md:138\n #, no-wrap\n msgid \"\"\n \"        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\\n\"\n-\"            vec::raw::set_len(&mut dst, dstlen as uint);\\n\"\n+\"            dst.set_len(dstlen as uint);\\n\"\n \"            Some(dst)\\n\"\n \"        } else {\\n\"\n \"            None // SNAPPY_INVALID_INPUT\\n\""}, {"sha": "670e9f32fe65fc988f3f2c750cd0234c91349ad0", "filename": "doc/po/tutorial-ffi.md.pot", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Fpo%2Ftutorial-ffi.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Fpo%2Ftutorial-ffi.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-ffi.md.pot?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -168,7 +168,7 @@ msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n \"pub fn validate_compressed_buffer(src: &[u8]) -> bool {\\n\"\n \"    unsafe {\\n\"\n-\"        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\\n\"\n+\"        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\\n\"\n \"    }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n@@ -207,7 +207,7 @@ msgid \"\"\n \"pub fn compress(src: &[u8]) -> ~[u8] {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -216,15 +216,15 @@ msgstr \"\"\n msgid \"\"\n \"        let mut dstlen = snappy_max_compressed_length(srclen);\\n\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-ffi.md:113\n #, no-wrap\n msgid \"\"\n \"        snappy_compress(psrc, srclen, pdst, &mut dstlen);\\n\"\n-\"        vec::raw::set_len(&mut dst, dstlen as uint);\\n\"\n+\"        dst.set_len(dstlen as uint);\\n\"\n \"        dst\\n\"\n \"    }\\n\"\n \"}\\n\"\n@@ -247,7 +247,7 @@ msgid \"\"\n \"pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\\n\"\n \"    unsafe {\\n\"\n \"        let srclen = src.len() as size_t;\\n\"\n-\"        let psrc = vec::raw::to_ptr(src);\\n\"\n+\"        let psrc = src.as_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -263,15 +263,15 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"        let mut dst = vec::with_capacity(dstlen as uint);\\n\"\n-\"        let pdst = vec::raw::to_mut_ptr(dst);\\n\"\n+\"        let pdst = dst.as_mut_ptr();\\n\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial-ffi.md:138\n #, no-wrap\n msgid \"\"\n \"        if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\\n\"\n-\"            vec::raw::set_len(&mut dst, dstlen as uint);\\n\"\n+\"            dst.set_len(dstlen as uint);\\n\"\n \"            Some(dst)\\n\"\n \"        } else {\\n\"\n \"            None // SNAPPY_INVALID_INPUT\\n\""}, {"sha": "39eff68afd1f6ee76f7a1c7383510a3e38c597be", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -79,7 +79,7 @@ the allocated memory. The length is less than or equal to the capacity.\n ~~~~ {.xfail-test}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n-        snappy_validate_compressed_buffer(vec::raw::to_ptr(src), src.len() as size_t) == 0\n+        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n     }\n }\n ~~~~\n@@ -100,14 +100,14 @@ the true length after compression for setting the length.\n pub fn compress(src: &[u8]) -> ~[u8] {\n     unsafe {\n         let srclen = src.len() as size_t;\n-        let psrc = vec::raw::to_ptr(src);\n+        let psrc = src.as_ptr();\n \n         let mut dstlen = snappy_max_compressed_length(srclen);\n         let mut dst = vec::with_capacity(dstlen as uint);\n-        let pdst = vec::raw::to_mut_ptr(dst);\n+        let pdst = dst.as_mut_ptr();\n \n         snappy_compress(psrc, srclen, pdst, &mut dstlen);\n-        vec::raw::set_len(&mut dst, dstlen as uint);\n+        dst.set_len(dstlen as uint);\n         dst\n     }\n }\n@@ -120,16 +120,16 @@ format and `snappy_uncompressed_length` will retrieve the exact buffer size requ\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n     unsafe {\n         let srclen = src.len() as size_t;\n-        let psrc = vec::raw::to_ptr(src);\n+        let psrc = src.as_ptr();\n \n         let mut dstlen: size_t = 0;\n         snappy_uncompressed_length(psrc, srclen, &mut dstlen);\n \n         let mut dst = vec::with_capacity(dstlen as uint);\n-        let pdst = vec::raw::to_mut_ptr(dst);\n+        let pdst = dst.as_mut_ptr();\n \n         if snappy_uncompress(psrc, srclen, pdst, &mut dstlen) == 0 {\n-            vec::raw::set_len(&mut dst, dstlen as uint);\n+            dst.set_len(dstlen as uint);\n             Some(dst)\n         } else {\n             None // SNAPPY_INVALID_INPUT"}, {"sha": "dc5f3b5d3cfd4b884950f9e24f87c57a13a2833c", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -44,7 +44,6 @@ use std::num;\n use std::ptr;\n use std::mem;\n use std::uint;\n-use std::vec;\n use std::unstable::intrinsics;\n use std::unstable::intrinsics::{TyDesc, get_tydesc};\n \n@@ -115,7 +114,7 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = vec::raw::to_ptr(chunk.data);\n+    let buf = chunk.data.as_ptr();\n     let fill = chunk.fill;\n \n     while idx < fill {\n@@ -179,7 +178,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n+            ptr::offset(this.pod_head.data.as_ptr(), start as int)\n         }\n     }\n \n@@ -235,7 +234,7 @@ impl Arena {\n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = vec::raw::to_ptr(self.head.data);\n+            let buf = self.head.data.as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }"}, {"sha": "10c4b8a3e2f4b6f052a06b2e9a2c7e38029dc67f", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -175,7 +175,7 @@ impl Uuid {\n     pub fn new_v4() -> Uuid {\n         let ub = rand::task_rng().gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(uuid.bytes, ub, 16);\n+        vec::bytes::copy_memory(uuid.bytes, ub);\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid\n@@ -202,7 +202,7 @@ impl Uuid {\n         fields.data1 = to_be32(d1 as i32) as u32;\n         fields.data2 = to_be16(d2 as i16) as u16;\n         fields.data3 = to_be16(d3 as i16) as u16;\n-        vec::bytes::copy_memory(fields.data4, d4, 8);\n+        vec::bytes::copy_memory(fields.data4, d4);\n \n         unsafe {\n             transmute(fields)\n@@ -220,7 +220,7 @@ impl Uuid {\n \n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n         unsafe {\n-            vec::raw::copy_memory(uuid.bytes, b, 16);\n+            vec::raw::copy_memory(uuid.bytes, b);\n         }\n         Some(uuid)\n     }\n@@ -442,11 +442,7 @@ impl Zero for Uuid {\n \n impl Clone for Uuid {\n     /// Returns a copy of the UUID\n-    fn clone(&self) -> Uuid {\n-        let mut clone = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(clone.bytes, self.bytes, 16);\n-        clone\n-    }\n+    fn clone(&self) -> Uuid { *self }\n }\n \n impl FromStr for Uuid {\n@@ -509,7 +505,7 @@ impl rand::Rand for Uuid {\n     fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n         let ub = rng.gen_vec(16);\n         let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        vec::bytes::copy_memory(uuid.bytes, ub, 16);\n+        vec::bytes::copy_memory(uuid.bytes, ub);\n         uuid.set_variant(VariantRFC4122);\n         uuid.set_version(Version4Random);\n         uuid"}, {"sha": "65ff67975a2f533d5141051e7864670d90b4df0e", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -16,7 +16,6 @@ use metadata::cstore;\n use util::common::time;\n \n use std::libc;\n-use std::vec;\n \n pub fn run(sess: session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[~str]) {\n@@ -48,7 +47,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n         debug!(\"reading {}\", name);\n         let bc = time(sess.time_passes(), format!(\"read {}.bc\", name), (), |_|\n                       archive.read(format!(\"{}.bc\", name)));\n-        let ptr = vec::raw::to_ptr(bc);\n+        let ptr = bc.as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(), format!(\"ll link {}\", name), (), |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n@@ -62,7 +61,7 @@ pub fn run(sess: session::Session, llmod: ModuleRef,\n     // Internalize everything but the reachable symbols of the current module\n     let cstrs = reachable.map(|s| s.to_c_str());\n     let arr = cstrs.map(|c| c.with_ref(|p| p));\n-    let ptr = vec::raw::to_ptr(arr);\n+    let ptr = arr.as_ptr();\n     unsafe {\n         llvm::LLVMRustRunRestrictionPass(llmod, ptr as **libc::c_char,\n                                          arr.len() as libc::size_t);"}, {"sha": "863c567a21651e4ed5b36f0b32e1249dac08cbf6", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -20,7 +20,6 @@ use middle::trans::type_::Type;\n use std::cast;\n use std::hashmap::HashMap;\n use std::libc::{c_uint, c_ulonglong, c_char};\n-use std::vec;\n use syntax::codemap::Span;\n use std::ptr::is_not_null;\n \n@@ -118,7 +117,7 @@ impl Builder {\n     pub fn aggregate_ret(&self, ret_vals: &[ValueRef]) {\n         unsafe {\n             llvm::LLVMBuildAggregateRet(self.llbuilder,\n-                                        vec::raw::to_ptr(ret_vals),\n+                                        ret_vals.as_ptr(),\n                                         ret_vals.len() as c_uint);\n         }\n     }\n@@ -161,7 +160,7 @@ impl Builder {\n         unsafe {\n             let v = llvm::LLVMBuildInvoke(self.llbuilder,\n                                           llfn,\n-                                          vec::raw::to_ptr(args),\n+                                          args.as_ptr(),\n                                           args.len() as c_uint,\n                                           then,\n                                           catch,\n@@ -500,7 +499,7 @@ impl Builder {\n     pub fn gep(&self, ptr: ValueRef, indices: &[ValueRef]) -> ValueRef {\n         self.count_insn(\"gep\");\n         unsafe {\n-            llvm::LLVMBuildGEP(self.llbuilder, ptr, vec::raw::to_ptr(indices),\n+            llvm::LLVMBuildGEP(self.llbuilder, ptr, indices.as_ptr(),\n                                indices.len() as c_uint, noname())\n         }\n     }\n@@ -528,7 +527,7 @@ impl Builder {\n         self.count_insn(\"inboundsgep\");\n         unsafe {\n             llvm::LLVMBuildInBoundsGEP(\n-                self.llbuilder, ptr, vec::raw::to_ptr(indices), indices.len() as c_uint, noname())\n+                self.llbuilder, ptr, indices.as_ptr(), indices.len() as c_uint, noname())\n         }\n     }\n \n@@ -716,8 +715,8 @@ impl Builder {\n         let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n         unsafe {\n-            llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n-                                  vec::raw::to_ptr(bbs),\n+            llvm::LLVMAddIncoming(phi, vals.as_ptr(),\n+                                  bbs.as_ptr(),\n                                   vals.len() as c_uint);\n             phi\n         }\n@@ -775,7 +774,7 @@ impl Builder {\n                 attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n         self.count_insn(\"call\");\n         unsafe {\n-            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, vec::raw::to_ptr(args),\n+            let v = llvm::LLVMBuildCall(self.llbuilder, llfn, args.as_ptr(),\n                                         args.len() as c_uint, noname());\n             for &(idx, attr) in attributes.iter() {\n                 llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n@@ -885,7 +884,7 @@ impl Builder {\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n-                self.llbuilder, T, vec::raw::to_ptr(args), args.len() as c_uint, noname());\n+                self.llbuilder, T, args.as_ptr(), args.len() as c_uint, noname());\n         }\n     }\n "}, {"sha": "55617067db43733f0cc34c5d1904b64f1e822cf3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -946,7 +946,7 @@ pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n         let mut elts: ~[ValueRef] = ~[];\n         while i < size { elts.push(C_u8(0u)); i += 1u; }\n         return llvm::LLVMConstArray(Type::i8().to_ref(),\n-                                    vec::raw::to_ptr(elts), elts.len() as c_uint);\n+                                    elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n@@ -968,13 +968,13 @@ pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n \n pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        return llvm::LLVMConstArray(ty.to_ref(), vec::raw::to_ptr(elts), elts.len() as c_uint);\n+        return llvm::LLVMConstArray(ty.to_ref(), elts.as_ptr(), elts.len() as c_uint);\n     }\n }\n \n pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n-        let ptr = cast::transmute(vec::raw::to_ptr(bytes));\n+        let ptr = cast::transmute(bytes.as_ptr());\n         return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n     }\n }"}, {"sha": "167b17ba95c6c26291136bd001a0a2a30026f28f", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -31,7 +31,6 @@ use util::sha2::Sha256;\n use std::c_str::ToCStr;\n use std::hashmap::{HashMap, HashSet};\n use std::local_data;\n-use std::vec;\n use std::libc::c_uint;\n use syntax::ast;\n \n@@ -261,7 +260,7 @@ impl CrateContext {\n             indices.iter().map(|i| C_i32(*i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,\n-                                       vec::raw::to_ptr(v),\n+                                       v.as_ptr(),\n                                        indices.len() as c_uint)\n         }\n     }"}, {"sha": "0f83e51cac8bc525758d5efa0a3b8da959aad1b7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -860,7 +860,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n-        llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n+        llvm::LLVMDIBuilderGetOrCreateArray(builder, arr.as_ptr(), arr.len() as u32)\n     };\n }\n \n@@ -949,7 +949,7 @@ fn declare_local(bcx: @mut Block,\n                         file_metadata,\n                         loc.line as c_uint,\n                         type_metadata,\n-                        vec::raw::to_ptr(address_operations),\n+                        address_operations.as_ptr(),\n                         address_operations.len() as c_uint,\n                         argument_index)\n                 }\n@@ -2133,7 +2133,7 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n             let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n-                                                          vec::raw::to_ptr(elements),\n+                                                          elements.as_ptr(),\n                                                           elements.len() as c_uint);\n             }\n         }"}, {"sha": "8c5b55b73cda520b8f4574311fa308711b57d316", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -150,13 +150,13 @@ impl Type {\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, False))\n     }\n \n     pub fn variadic_func(args: &[Type], ret: &Type) -> Type {\n         let vec : &[TypeRef] = unsafe { cast::transmute(args) };\n-        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec::raw::to_ptr(vec),\n+        ty!(llvm::LLVMFunctionType(ret.to_ref(), vec.as_ptr(),\n                                    args.len() as c_uint, True))\n     }\n \n@@ -170,7 +170,7 @@ impl Type {\n \n     pub fn struct_(els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), vec::raw::to_ptr(els),\n+        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), els.as_ptr(),\n                                           els.len() as c_uint, packed as Bool))\n     }\n \n@@ -297,7 +297,7 @@ impl Type {\n     pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n         unsafe {\n             let vec : &[TypeRef] = cast::transmute(els);\n-            llvm::LLVMStructSetBody(self.to_ref(), vec::raw::to_ptr(vec),\n+            llvm::LLVMStructSetBody(self.to_ref(), vec.as_ptr(),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n@@ -311,7 +311,7 @@ impl Type {\n             let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n             let mut elems = vec::from_elem(num_fields, 0 as TypeRef);\n \n-            llvm::LLVMGetStructElementTypes(self.to_ref(), vec::raw::to_mut_ptr(elems));\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), elems.as_mut_ptr());\n \n             Type::from_ref(elems[idx])\n         }\n@@ -355,7 +355,7 @@ impl Type {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n             let args = vec::from_elem(n_args, 0 as TypeRef);\n-            llvm::LLVMGetParamTypes(self.to_ref(), vec::raw::to_ptr(args));\n+            llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n             cast::transmute(args)\n         }\n     }"}, {"sha": "b3c4fbf110563ebf61b2b0583522c114dcd9bc88", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -136,16 +136,14 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.mut_slice(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining),\n-                        buffer_remaining);\n+                        input.slice_to(buffer_remaining));\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n                     self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                    input,\n-                    input.len());\n+                    input);\n                 self.buffer_idx += input.len();\n                 return;\n             }\n@@ -164,8 +162,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.mut_slice(0, input_remaining),\n-            input.slice_from(i),\n-            input.len() - i);\n+            input.slice_from(i));\n         self.buffer_idx += input_remaining;\n     }\n "}, {"sha": "06970561fac4f1652f3198c86ed16fa20dfedd51", "filename": "src/librustpkg/sha1.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustpkg%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustpkg%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsha1.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -149,16 +149,14 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.mut_slice(self.buffer_idx, size),\n-                        input.slice_to(buffer_remaining),\n-                        buffer_remaining);\n+                        input.slice_to(buffer_remaining));\n                 self.buffer_idx = 0;\n                 func(self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n                     self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n-                    input,\n-                    input.len());\n+                    input);\n                 self.buffer_idx += input.len();\n                 return;\n             }\n@@ -177,8 +175,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.mut_slice(0, input_remaining),\n-            input.slice_from(i),\n-            input.len() - i);\n+            input.slice_from(i));\n         self.buffer_idx += input_remaining;\n     }\n "}, {"sha": "3a8af71e019ef7b8d70b1a640d00be6f73b1ba28", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -20,7 +20,6 @@ use std::io;\n use std::rt::local::Local;\n use std::rt::rtio;\n use std::rt::sched::{Scheduler, SchedHandle};\n-use std::vec;\n \n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after};\n use uvio::HomingIO;\n@@ -78,7 +77,7 @@ impl FsRequest {\n     {\n         execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_write(loop_.handle, req,\n-                              fd, vec::raw::to_ptr(buf) as *c_void,\n+                              fd, buf.as_ptr() as *c_void,\n                               buf.len() as size_t, offset, cb)\n         })\n     }\n@@ -88,7 +87,7 @@ impl FsRequest {\n     {\n         execute(|req, cb| unsafe {\n             uvll::uv_fs_read(loop_.handle, req,\n-                             fd, vec::raw::to_ptr(buf) as *c_void,\n+                             fd, buf.as_ptr() as *c_void,\n                              buf.len() as size_t, offset, cb)\n         }).map(|req| {\n             req.get_result() as int"}, {"sha": "d8bf356a099b4470019b121fb81194aa6f12725d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -60,7 +60,6 @@ use std::str::raw::from_c_str;\n use std::str;\n use std::task;\n use std::unstable::finally::Finally;\n-use std::vec;\n \n use std::io::IoError;\n \n@@ -388,7 +387,7 @@ pub fn empty_buf() -> Buf {\n \n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n-    let data = vec::raw::to_ptr(v);\n+    let data = v.as_ptr();\n     uvll::uv_buf_t { base: data, len: v.len() as uvll::uv_buf_len_t }\n }\n "}, {"sha": "6f1930bc7fe3143650a009d621da078f4d11c718", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -62,7 +62,7 @@ pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n             // apparently there's an off-by-one in libuv?\n             let ip_size = ip_size + 1;\n             let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n-            let buf_ptr = vec::raw::to_ptr(buf);\n+            let buf_ptr = buf.as_ptr();\n             let ret = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n                 uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t)\n             } else {"}, {"sha": "0410d58bd8b3886b781a20ab72a80b70daa3afe7", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -49,7 +49,7 @@ impl Process {\n         let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n         let mut ret_io = vec::with_capacity(io.len());\n         unsafe {\n-            vec::raw::set_len(&mut stdio, io.len());\n+            stdio.set_len(io.len());\n             for (slot, other) in stdio.iter().zip(io.iter()) {\n                 let io = set_stdio(slot as *uvll::uv_stdio_container_t, other,\n                                    loop_);"}, {"sha": "91be656334392effa4fe7ca370a3c9b609c3aa54", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -33,7 +33,6 @@ use std::libc::{size_t, c_int, c_uint, c_void, c_char, c_double};\n use std::libc::ssize_t;\n use std::libc::{malloc, free};\n use std::libc;\n-use std::vec;\n \n #[cfg(test)]\n use std::libc::uintptr_t;\n@@ -419,7 +418,7 @@ pub unsafe fn uv_write(req: *uv_write_t,\n                     cb: uv_write_cb) -> c_int;\n     }\n \n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_ptr = buf_in.as_ptr();\n     let buf_cnt = buf_in.len() as i32;\n     return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n@@ -435,7 +434,7 @@ pub unsafe fn uv_udp_send(req: *uv_udp_send_t,\n                        cb: uv_udp_send_cb) -> c_int;\n     }\n \n-    let buf_ptr = vec::raw::to_ptr(buf_in);\n+    let buf_ptr = buf_in.as_ptr();\n     let buf_cnt = buf_in.len() as i32;\n     return uv_udp_send(req, handle, buf_ptr, buf_cnt, addr, cb);\n }"}, {"sha": "1ba6b7b50cabfcc71efe3f1a1c22181762c17afb", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -293,7 +293,7 @@ impl<'a> ToCStr for &'a [u8] {\n unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n     if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = intrinsics::uninit();\n-        vec::bytes::copy_memory(buf, v, v.len());\n+        vec::bytes::copy_memory(buf, v);\n         buf[v.len()] = 0;\n \n         buf.as_mut_buf(|buf, _| {\n@@ -385,7 +385,7 @@ mod tests {\n     fn test_str_multistring_parsing() {\n         unsafe {\n             let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n-            let ptr = vec::raw::to_ptr(input);\n+            let ptr = input.as_ptr();\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n             let result = from_c_multistring(ptr as *libc::c_char, None, |c| {"}, {"sha": "95c313dd282b54baf329d6bd2e002bb1a3eead0d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -79,7 +79,7 @@ impl<R: Reader> BufferedReader<R> {\n         // to be very cheap (large mallocs are not nearly as expensive as large\n         // callocs).\n         let mut buf = vec::with_capacity(cap);\n-        unsafe { vec::raw::set_len(&mut buf, cap); }\n+        unsafe { buf.set_len(cap); }\n         BufferedReader {\n             inner: inner,\n             buf: buf,\n@@ -122,7 +122,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n                 return None;\n             }\n             let nread = num::min(available.len(), buf.len());\n-            vec::bytes::copy_memory(buf, available, nread);\n+            vec::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n         };\n         self.pos += nread;\n@@ -154,7 +154,7 @@ impl<W: Writer> BufferedWriter<W> {\n     pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n         // See comments in BufferedReader for why this uses unsafe code.\n         let mut buf = vec::with_capacity(cap);\n-        unsafe { vec::raw::set_len(&mut buf, cap); }\n+        unsafe { buf.set_len(cap); }\n         BufferedWriter {\n             inner: inner,\n             buf: buf,\n@@ -185,7 +185,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n             self.inner.write(buf);\n         } else {\n             let dst = self.buf.mut_slice_from(self.pos);\n-            vec::bytes::copy_memory(dst, buf, buf.len());\n+            vec::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n         }\n     }"}, {"sha": "b3e5a9a0c86f156bfdba3b993b470ba752496927", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -57,7 +57,7 @@ impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n                     let dst = buf.mut_slice_from(num_read);\n                     let src = prev.slice_from(self.pos);\n                     let count = cmp::min(dst.len(), src.len());\n-                    bytes::copy_memory(dst, src, count);\n+                    bytes::copy_memory(dst, src.slice_to(count));\n                     num_read += count;\n                     self.pos += count;\n                 },"}, {"sha": "efb55a436eaf41277ba4b2d2018a6b96e564ebb0", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -58,8 +58,7 @@ impl Writer for MemWriter {\n \n         // Do the necessary writes\n         if left.len() > 0 {\n-            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n-                                    left, left.len());\n+            vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), left);\n         }\n         if right.len() > 0 {\n             self.buf.push_all(right);\n@@ -116,7 +115,7 @@ impl Reader for MemReader {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n             let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input, write_len);\n+            vec::bytes::copy_memory(output, input);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n@@ -175,8 +174,7 @@ impl<'a> Writer for BufWriter<'a> {\n             return;\n         }\n \n-        vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos),\n-                                buf, buf.len());\n+        vec::bytes::copy_memory(self.buf.mut_slice_from(self.pos), buf);\n         self.pos += buf.len();\n     }\n }\n@@ -222,7 +220,7 @@ impl<'a> Reader for BufReader<'a> {\n             let input = self.buf.slice(self.pos, self.pos + write_len);\n             let output = buf.mut_slice(0, write_len);\n             assert_eq!(input.len(), output.len());\n-            vec::bytes::copy_memory(output, input, write_len);\n+            vec::bytes::copy_memory(output, input);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());"}, {"sha": "c0bdc2a2014353e6d70f9e3c2946336797d80669", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -523,7 +523,7 @@ pub trait Reader {\n             let mut total_read = 0;\n \n             buf.reserve_additional(len);\n-            vec::raw::set_len(buf, start_len + len);\n+            buf.set_len(start_len + len);\n \n             (|| {\n                 while total_read < len {\n@@ -539,7 +539,7 @@ pub trait Reader {\n                         }\n                     }\n                 }\n-            }).finally(|| vec::raw::set_len(buf, start_len + total_read))\n+            }).finally(|| buf.set_len(start_len + total_read))\n         }\n     }\n "}, {"sha": "bd618dd6f0f4af897a04bbec21a13684d740f1c1", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -133,7 +133,7 @@ impl rtio::RtioFileStream for FileDesc {\n         self.inner_write(buf)\n     }\n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+        return os_pread(self.fd, buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n@@ -165,7 +165,7 @@ impl rtio::RtioFileStream for FileDesc {\n         }\n     }\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd, vec::raw::to_ptr(buf), buf.len(), offset);\n+        return os_pwrite(self.fd, buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n@@ -700,13 +700,13 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n         }\n         let mut buf = vec::with_capacity::<u8>(len as uint);\n         match unsafe {\n-            libc::readlink(p, vec::raw::to_ptr(buf) as *mut libc::c_char,\n+            libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                            len as libc::size_t)\n         } {\n             -1 => Err(super::last_error()),\n             n => {\n                 assert!(n > 0);\n-                unsafe { vec::raw::set_len(&mut buf, n as uint); }\n+                unsafe { buf.set_len(n as uint); }\n                 Ok(Path::new(buf))\n             }\n         }"}, {"sha": "7abeb34a010a1c695f81d68aed46a77959b8daf8", "filename": "src/libstd/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -358,18 +358,18 @@ pub fn self_exe_path() -> Option<Path> {\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n             let mut sz: size_t = 0;\n-            let err = sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n+            let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n                              ptr::mut_null(), &mut sz, ptr::null(), 0u as size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n             let err = v.as_mut_buf(|buf,_| {\n-                sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n+                sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n                        buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n             });\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n-            vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n+            v.set_len(sz as uint - 1); // chop off trailing NUL\n             Some(v)\n         }\n     }\n@@ -398,7 +398,7 @@ pub fn self_exe_path() -> Option<Path> {\n                 _NSGetExecutablePath(buf as *mut i8, &mut sz)\n             });\n             if err != 0 { return None; }\n-            vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n+            v.set_len(sz as uint - 1); // chop off trailing NUL\n             Some(v)\n         }\n     }"}, {"sha": "e2dda8267658914d0855471b9a23fc3fb74fe382", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -449,7 +449,7 @@ pub mod ptr_tests {\n     use cast;\n     use libc;\n     use str;\n-    use vec;\n+    use vec::{ImmutableVector, MutableVector};\n \n     #[test]\n     fn test() {\n@@ -474,15 +474,15 @@ pub mod ptr_tests {\n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n \n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1),\n-                        offset(vec::raw::to_ptr(v0), 1), 1);\n+            copy_memory(mut_offset(v1.as_mut_ptr(), 1),\n+                        offset(v0.as_ptr(), 1), 1);\n             assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n-            copy_memory(vec::raw::to_mut_ptr(v1),\n-                        offset(vec::raw::to_ptr(v0), 2), 1);\n+            copy_memory(v1.as_mut_ptr(),\n+                        offset(v0.as_ptr(), 2), 1);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 0u16));\n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2),\n-                        vec::raw::to_ptr(v0), 1u);\n+            copy_memory(mut_offset(v1.as_mut_ptr(), 2),\n+                        v0.as_ptr(), 1u);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 32000u16));\n         }\n@@ -558,7 +558,7 @@ pub mod ptr_tests {\n \n         unsafe {\n             let xs = ~[5, ..16];\n-            let mut ptr = to_ptr(xs);\n+            let mut ptr = xs.as_ptr();\n             let end = ptr.offset(16);\n \n             while ptr < end {\n@@ -567,7 +567,7 @@ pub mod ptr_tests {\n             }\n \n             let mut xs_mut = xs.clone();\n-            let mut m_ptr = to_mut_ptr(xs_mut);\n+            let mut m_ptr = xs_mut.as_mut_ptr();\n             let m_end = m_ptr.offset(16);\n \n             while m_ptr < m_end {\n@@ -581,20 +581,18 @@ pub mod ptr_tests {\n \n     #[test]\n     fn test_ptr_subtraction() {\n-        use vec::raw::*;\n-\n         unsafe {\n             let xs = ~[0,1,2,3,4,5,6,7,8,9];\n             let mut idx = 9i8;\n-            let ptr = to_ptr(xs);\n+            let ptr = xs.as_ptr();\n \n             while idx >= 0i8 {\n                 assert_eq!(*(ptr.offset(idx as int)), idx as int);\n                 idx = idx - 1i8;\n             }\n \n             let mut xs_mut = xs.clone();\n-            let m_start = to_mut_ptr(xs_mut);\n+            let m_start = xs_mut.as_mut_ptr();\n             let mut m_ptr = m_start.offset(9);\n \n             while m_ptr >= m_start {\n@@ -700,7 +698,7 @@ pub mod ptr_tests {\n     #[test]\n     fn test_set_memory() {\n         let mut xs = [0u8, ..20];\n-        let ptr = vec::raw::to_mut_ptr(xs);\n+        let ptr = xs.as_mut_ptr();\n         unsafe { set_memory(ptr, 5u8, xs.len()); }\n         assert_eq!(xs, [5u8, ..20]);\n     }"}, {"sha": "38d7a683a702fc1537a10af814878eaf78ac8fcd", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -49,7 +49,7 @@ impl IsaacRng {\n         let mut rng = EMPTY;\n \n         unsafe {\n-            let ptr = raw::to_mut_ptr(rng.rsl);\n+            let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n@@ -254,7 +254,7 @@ impl Isaac64Rng {\n         let mut rng = EMPTY_64;\n \n         unsafe {\n-            let ptr = raw::to_mut_ptr(rng.rsl);\n+            let ptr = rng.rsl.as_mut_ptr();\n \n             raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n@@ -341,7 +341,7 @@ impl Isaac64Rng {\n         static MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n-                self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.unsafe_ref(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n         macro_rules! rngstep(\n@@ -355,8 +355,8 @@ impl Isaac64Rng {\n                 let mix = if $j == 0 {!mix} else {mix};\n \n                 unsafe {\n-                    let x = self.mem.unsafe_get(base + mr_offset);\n-                    a = mix + self.mem.unsafe_get(base + m2_offset);\n+                    let x = *self.mem.unsafe_ref(base + mr_offset);\n+                    a = mix + *self.mem.unsafe_ref(base + m2_offset);\n                     let y = ind!(x) + a + b;\n                     self.mem.unsafe_set(base + mr_offset, y);\n \n@@ -395,7 +395,7 @@ impl Rng for Isaac64Rng {\n             self.isaac64();\n         }\n         self.cnt -= 1;\n-        unsafe { self.rsl.unsafe_get(self.cnt) }\n+        unsafe { *self.rsl.unsafe_ref(self.cnt) }\n     }\n }\n "}, {"sha": "44b60e955d2178043925d9a0c16a6348231be1e8", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -24,7 +24,7 @@ impl StackSegment {\n         unsafe {\n             // Crate a block of uninitialized values\n             let mut stack = vec::with_capacity(size);\n-            vec::raw::set_len(&mut stack, size);\n+            stack.set_len(size);\n \n             let mut stk = StackSegment {\n                 buf: stack,\n@@ -39,13 +39,13 @@ impl StackSegment {\n \n     /// Point to the low end of the allocated stack\n     pub fn start(&self) -> *uint {\n-        vec::raw::to_ptr(self.buf) as *uint\n+        self.buf.as_ptr() as *uint\n     }\n \n     /// Point one word beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n         unsafe {\n-            vec::raw::to_ptr(self.buf).offset(self.buf.len() as int) as *uint\n+            self.buf.as_ptr().offset(self.buf.len() as int) as *uint\n         }\n     }\n }"}, {"sha": "f13107651305836b35ec0bbf244f41569c8dd164", "filename": "src/libstd/str.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -992,7 +992,7 @@ pub mod raw {\n     use cast;\n     use libc;\n     use ptr;\n-    use str::is_utf8;\n+    use str::{is_utf8, OwnedStr};\n     use vec;\n     use vec::MutableVector;\n     use unstable::raw::Slice;\n@@ -1001,7 +1001,7 @@ pub mod raw {\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n         v.as_mut_buf(|vbuf, _len| ptr::copy_memory(vbuf, buf as *u8, len));\n-        vec::raw::set_len(&mut v, len);\n+        v.set_len(len);\n \n         assert!(is_utf8(v));\n         ::cast::transmute(v)\n@@ -1108,7 +1108,7 @@ pub mod raw {\n         let len = s.len();\n         assert!((len > 0u));\n         let b = s[len - 1u];\n-        set_len(s, len - 1u);\n+        s.set_len(len - 1);\n         return b;\n     }\n \n@@ -1129,16 +1129,6 @@ pub mod raw {\n         cast::transmute(s)\n     }\n \n-    /// Sets the length of a string\n-    ///\n-    /// This will explicitly set the size of the string, without actually\n-    /// modifying its buffers, so it is up to the caller to ensure that\n-    /// the string is actually the specified size.\n-    #[inline]\n-    pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n-        vec::raw::set_len(as_owned_vec(s), new_len)\n-    }\n-\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n@@ -1148,7 +1138,7 @@ pub mod raw {\n     fn test_from_buf_len() {\n         unsafe {\n             let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n-            let b = vec::raw::to_ptr(a);\n+            let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n             assert_eq!(c, ~\"AAA\");\n         }\n@@ -1338,7 +1328,7 @@ impl Mutable for ~str {\n     #[inline]\n     fn clear(&mut self) {\n         unsafe {\n-            raw::set_len(self, 0)\n+            self.set_len(0)\n         }\n     }\n }\n@@ -2293,7 +2283,7 @@ impl<'a> StrSlice<'a> for &'a str {\n                 let mut v = vec::with_capacity(len);\n \n                 v.as_mut_buf(|dst, _| ptr::copy_memory(dst, src, len));\n-                vec::raw::set_len(&mut v, len);\n+                v.set_len(len);\n                 ::cast::transmute(v)\n             }\n         })\n@@ -2598,6 +2588,13 @@ pub trait OwnedStr {\n     /// The caller must make sure any mutations to this buffer keep the string\n     /// valid UTF-8!\n     fn as_mut_buf<T>(&mut self, f: |*mut u8, uint| -> T) -> T;\n+\n+    /// Sets the length of a string\n+    ///\n+    /// This will explicitly set the size of the string, without actually\n+    /// modifying its buffers, so it is up to the caller to ensure that\n+    /// the string is actually the specified size.\n+    unsafe fn set_len(&mut self, new_len: uint);\n }\n \n impl OwnedStr for ~str {\n@@ -2629,7 +2626,7 @@ impl OwnedStr for ~str {\n                     c.encode_utf8(slc)\n                 })\n             });\n-            raw::set_len(self, cur_len + used);\n+            self.set_len(cur_len + used);\n         }\n     }\n \n@@ -2638,7 +2635,7 @@ impl OwnedStr for ~str {\n         let end = self.len();\n         assert!(end > 0u);\n         let CharRange {ch, next} = self.char_range_at_reverse(end);\n-        unsafe { raw::set_len(self, next); }\n+        unsafe { self.set_len(next); }\n         return ch;\n     }\n \n@@ -2689,7 +2686,7 @@ impl OwnedStr for ~str {\n     fn truncate(&mut self, len: uint) {\n         assert!(len <= self.len());\n         assert!(self.is_char_boundary(len));\n-        unsafe { raw::set_len(self, len); }\n+        unsafe { self.set_len(len); }\n     }\n \n     #[inline]\n@@ -2703,6 +2700,11 @@ impl OwnedStr for ~str {\n             raw::as_owned_vec(self).as_mut_buf(f)\n         }\n     }\n+\n+    #[inline]\n+    unsafe fn set_len(&mut self, new_len: uint) {\n+        raw::as_owned_vec(self).set_len(new_len)\n+    }\n }\n \n impl Clone for ~str {\n@@ -3358,7 +3360,7 @@ mod tests {\n     fn test_raw_from_c_str() {\n         unsafe {\n             let a = ~[65, 65, 65, 65, 65, 65, 65, 0];\n-            let b = vec::raw::to_ptr(a);\n+            let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n             assert_eq!(c, ~\"AAAAAAA\");\n         }"}, {"sha": "1b238ede0496ea1db7c4aace4d496c43227137cc", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 94, "deletions": 145, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -123,7 +123,6 @@ use unstable::finally::Finally;\n use unstable::intrinsics;\n use unstable::intrinsics::{get_tydesc, owns_managed};\n use unstable::raw::{Box, Repr, Slice, Vec};\n-use vec;\n use util;\n \n /**\n@@ -135,15 +134,15 @@ use util;\n pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        let p = raw::to_mut_ptr(v);\n+        let p = v.as_mut_ptr();\n         let mut i: uint = 0u;\n         (|| {\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), op(i));\n                 i += 1u;\n             }\n         }).finally(|| {\n-            raw::set_len(&mut v, i);\n+            v.set_len(i);\n         });\n         v\n     }\n@@ -162,15 +161,15 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n     // vec::with_capacity/ptr::set_memory for primitive types.\n     unsafe {\n         let mut v = with_capacity(n_elts);\n-        let p = raw::to_mut_ptr(v);\n+        let p = v.as_mut_ptr();\n         let mut i = 0u;\n         (|| {\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n                 i += 1u;\n             }\n         }).finally(|| {\n-            raw::set_len(&mut v, i);\n+            v.set_len(i);\n         });\n         v\n     }\n@@ -955,6 +954,17 @@ pub trait ImmutableVector<'a, T> {\n     /// bounds checking.\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n \n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *T;\n+\n     /**\n      * Binary search a sorted vector with a comparator function.\n      *\n@@ -1044,7 +1054,7 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     #[inline]\n     fn iter(self) -> VecIterator<'a, T> {\n         unsafe {\n-            let p = vec::raw::to_ptr(self);\n+            let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 VecIterator{ptr: p,\n                             end: (p as uint + self.len()) as *T,\n@@ -1157,6 +1167,12 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n         self.repr().data.offset(index as int)\n     }\n \n+    #[inline]\n+    fn as_ptr(&self) -> *T {\n+        self.repr().data\n+    }\n+\n+\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n@@ -1271,8 +1287,6 @@ pub trait ImmutableCopyableVector<T> {\n      * those that do not.\n      */\n     fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n-    /// Returns the element at the given index, without doing bounds checking.\n-    unsafe fn unsafe_get(&self, elem: uint) -> T;\n \n     /// Create an iterator that yields every possible permutation of the\n     /// vector in succession.\n@@ -1296,11 +1310,6 @@ impl<'a,T:Clone> ImmutableCopyableVector<T> for &'a [T] {\n         (lefts, rights)\n     }\n \n-    #[inline]\n-    unsafe fn unsafe_get(&self, index: uint) -> T {\n-        (*self.unsafe_ref(index)).clone()\n-    }\n-\n     fn permutations(self) -> Permutations<T> {\n         Permutations{\n             swaps: ElementSwaps::new(self.len()),\n@@ -1448,6 +1457,15 @@ pub trait OwnedVector<T> {\n      *             value\n      */\n     fn grow_fn(&mut self, n: uint, op: |uint| -> T);\n+\n+    /**\n+     * Sets the length of a vector\n+     *\n+     * This will explicitly set the size of the vector, without actually\n+     * modifying its buffers, so it is up to the caller to ensure that\n+     * the vector is actually the specified size.\n+     */\n+    unsafe fn set_len(&mut self, new_len: uint);\n }\n \n impl<T> OwnedVector<T> for ~[T] {\n@@ -1570,11 +1588,11 @@ impl<T> OwnedVector<T> for ~[T] {\n         let new_len = self_len + rhs_len;\n         self.reserve_additional(rhs.len());\n         unsafe { // Note: infallible.\n-            let self_p = vec::raw::to_mut_ptr(*self);\n-            let rhs_p = vec::raw::to_ptr(rhs);\n+            let self_p = self.as_mut_ptr();\n+            let rhs_p = rhs.as_ptr();\n             ptr::copy_memory(ptr::mut_offset(self_p, self_len as int), rhs_p, rhs_len);\n-            raw::set_len(self, new_len);\n-            raw::set_len(&mut rhs, 0);\n+            self.set_len(new_len);\n+            rhs.set_len(0);\n         }\n     }\n \n@@ -1584,7 +1602,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             ln => {\n                 let valptr = ptr::to_mut_unsafe_ptr(&mut self[ln - 1u]);\n                 unsafe {\n-                    raw::set_len(self, ln - 1u);\n+                    self.set_len(ln - 1u);\n                     Some(ptr::read_ptr(&*valptr))\n                 }\n             }\n@@ -1624,31 +1642,30 @@ impl<T> OwnedVector<T> for ~[T] {\n             assert!(self.capacity() >= ln);\n             // Pretend like we have the original length so we can use\n             // the vector copy_memory to overwrite the hole we just made\n-            raw::set_len(self, ln);\n+            self.set_len(ln);\n \n             // Memcopy the head element (the one we want) to the location we just\n             // popped. For the moment it unsafely exists at both the head and last\n             // positions\n             {\n                 let first_slice = self.slice(0, 1);\n                 let last_slice = self.slice(next_ln, ln);\n-                raw::copy_memory(cast::transmute(last_slice), first_slice, 1);\n+                raw::copy_memory(cast::transmute(last_slice), first_slice);\n             }\n \n             // Memcopy everything to the left one element\n             {\n                 let init_slice = self.slice(0, next_ln);\n                 let tail_slice = self.slice(1, ln);\n                 raw::copy_memory(cast::transmute(init_slice),\n-                                 tail_slice,\n-                                 next_ln);\n+                                 tail_slice);\n             }\n \n             // Set the new length. Now the vector is back to normal\n-            raw::set_len(self, next_ln);\n+            self.set_len(next_ln);\n \n             // Swap out the element we want from the end\n-            let vp = raw::to_mut_ptr(*self);\n+            let vp = self.as_mut_ptr();\n             let vp = ptr::mut_offset(vp, (next_ln - 1) as int);\n \n             Some(ptr::replace_ptr(vp, work_elt))\n@@ -1701,7 +1718,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 }\n             }\n         });\n-        unsafe { raw::set_len(self, newlen); }\n+        unsafe { self.set_len(newlen); }\n     }\n \n     fn retain(&mut self, f: |t: &T| -> bool) {\n@@ -1745,6 +1762,16 @@ impl<T> OwnedVector<T> for ~[T] {\n             i += 1u;\n         }\n     }\n+    #[inline]\n+    unsafe fn set_len(&mut self, new_len: uint) {\n+        if owns_managed::<T>() {\n+            let repr: **mut Box<Vec<()>> = cast::transmute(self);\n+            (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n+        } else {\n+            let repr: **mut Vec<()> = cast::transmute(self);\n+            (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n+        }\n+    }\n }\n \n impl<T> Mutable for ~[T] {\n@@ -1890,7 +1917,7 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             if ln < 1 { return; }\n \n             // Avoid bounds checks by using unsafe pointers.\n-            let p = vec::raw::to_mut_ptr(*self);\n+            let p = self.as_mut_ptr();\n             let mut r = 1;\n             let mut w = 1;\n \n@@ -2028,6 +2055,17 @@ pub trait MutableVector<'a, T> {\n \n     /// Returns an unsafe mutable pointer to the element in index\n     unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T;\n+\n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T;\n+\n     /// Unsafely sets the element in index to the value\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n@@ -2073,7 +2111,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n     fn mut_iter(self) -> VecMutIterator<'a, T> {\n         unsafe {\n-            let p = vec::raw::to_mut_ptr(self);\n+            let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n                 VecMutIterator{ptr: p,\n                                end: (p as uint + self.len()) as *mut T,\n@@ -2149,6 +2187,11 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         ptr::mut_offset(self.repr().data as *mut T, index as int)\n     }\n \n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n+    }\n+\n     #[inline]\n     unsafe fn unsafe_set(self, index: uint, val: T) {\n         *self.unsafe_mut_ref(index) = val;\n@@ -2194,52 +2237,11 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n /// Unsafe operations\n pub mod raw {\n     use cast;\n-    use clone::Clone;\n     use option::Some;\n     use ptr;\n-    use mem;\n     use unstable::intrinsics;\n     use vec::{with_capacity, ImmutableVector, MutableVector};\n-    use unstable::raw::{Box, Vec, Slice};\n-    use unstable::intrinsics::owns_managed;\n-\n-    /**\n-     * Sets the length of a vector\n-     *\n-     * This will explicitly set the size of the vector, without actually\n-     * modifying its buffers, so it is up to the caller to ensure that\n-     * the vector is actually the specified size.\n-     */\n-    #[inline]\n-    pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        if owns_managed::<T>() {\n-            let repr: **mut Box<Vec<()>> = cast::transmute(v);\n-            (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n-        } else {\n-            let repr: **mut Vec<()> = cast::transmute(v);\n-            (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n-        }\n-    }\n-\n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n-    #[inline]\n-    pub fn to_ptr<T>(v: &[T]) -> *T {\n-        v.repr().data\n-    }\n-\n-    /** see `to_ptr()` */\n-    #[inline]\n-    pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n-        v.repr().data as *mut T\n-    }\n+    use unstable::raw::Slice;\n \n     /**\n      * Form a slice from a pointer and length (as a number of units,\n@@ -2271,14 +2273,6 @@ pub mod raw {\n         }))\n     }\n \n-    /**\n-     * Unchecked vector indexing.\n-     */\n-    #[inline]\n-    pub unsafe fn get<T:Clone>(v: &[T], i: uint) -> T {\n-        v.as_imm_buf(|p, _len| (*ptr::offset(p, i as int)).clone())\n-    }\n-\n     /**\n      * Unchecked vector index assignment.  Does not drop the\n      * old value and hence is only suitable when the vector\n@@ -2305,26 +2299,22 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn from_buf_raw<T>(ptr: *T, elts: uint) -> ~[T] {\n         let mut dst = with_capacity(elts);\n-        set_len(&mut dst, elts);\n+        dst.set_len(elts);\n         dst.as_mut_buf(|p_dst, _len_dst| ptr::copy_memory(p_dst, ptr, elts));\n         dst\n     }\n \n     /**\n       * Copies data from one vector to another.\n       *\n-      * Copies `count` bytes from `src` to `dst`. The source and destination\n-      * may overlap.\n+      * Copies `src` to `dst`. The source and destination may overlap.\n       */\n     #[inline]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[T],\n-                                 count: uint) {\n-        assert!(dst.len() >= count);\n-        assert!(src.len() >= count);\n-\n-        dst.as_mut_buf(|p_dst, _len_dst| {\n-            src.as_imm_buf(|p_src, _len_src| {\n-                ptr::copy_memory(p_dst, p_src, count)\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[T]) {\n+        dst.as_mut_buf(|p_dst, len_dst| {\n+            src.as_imm_buf(|p_src, len_src| {\n+                assert!(len_dst >= len_src)\n+                ptr::copy_memory(p_dst, p_src, len_src)\n             })\n         })\n     }\n@@ -2355,15 +2345,12 @@ pub mod raw {\n     }\n }\n \n-/// Operations on `[u8]`\n+/// Operations on `[u8]`.\n pub mod bytes {\n-    use libc;\n-    use num;\n     use vec::raw;\n-    use vec;\n     use ptr;\n \n-    /// A trait for operations on mutable operations on `[u8]`\n+    /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n         /// Sets all bytes of the receiver to the given value.\n         fn set_memory(self, value: u8);\n@@ -2378,59 +2365,21 @@ pub mod bytes {\n         }\n     }\n \n-    /// Bytewise string comparison\n-    pub fn memcmp(a: &~[u8], b: &~[u8]) -> int {\n-        let a_len = a.len();\n-        let b_len = b.len();\n-        let n = num::min(a_len, b_len) as libc::size_t;\n-        let r = unsafe {\n-            libc::memcmp(raw::to_ptr(*a) as *libc::c_void,\n-                         raw::to_ptr(*b) as *libc::c_void, n) as int\n-        };\n-\n-        if r != 0 { r } else {\n-            if a_len == b_len {\n-                0\n-            } else if a_len < b_len {\n-                -1\n-            } else {\n-                1\n-            }\n-        }\n-    }\n-\n-    /// Bytewise less than or equal\n-    pub fn lt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) < 0 }\n-\n-    /// Bytewise less than or equal\n-    pub fn le(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) <= 0 }\n-\n-    /// Bytewise equality\n-    pub fn eq(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) == 0 }\n-\n-    /// Bytewise inequality\n-    pub fn ne(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) != 0 }\n-\n-    /// Bytewise greater than or equal\n-    pub fn ge(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) >= 0 }\n-\n-    /// Bytewise greater than\n-    pub fn gt(a: &~[u8], b: &~[u8]) -> bool { memcmp(a, b) > 0 }\n-\n     /**\n       * Copies data from one vector to another.\n       *\n-      * Copies `count` bytes from `src` to `dst`. The source and destination\n-      * may overlap.\n+      * Copies `src` to `dst`. The source and destination may\n+      * overlap. Fails if the length of `dst` is less than the length\n+      * of `src`.\n       */\n     #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &[u8], count: uint) {\n+    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n         // Bound checks are done at vec::raw::copy_memory.\n-        unsafe { vec::raw::copy_memory(dst, src, count) }\n+        unsafe { raw::copy_memory(dst, src) }\n     }\n \n     /**\n-     * Allocate space in `dst` and append the data in `src`.\n+     * Allocate space in `dst` and append the data to `src`.\n      */\n     #[inline]\n     pub fn push_bytes(dst: &mut ~[u8], src: &[u8]) {\n@@ -2442,7 +2391,7 @@ pub mod bytes {\n                     ptr::copy_memory(p_dst.offset(len_dst as int), p_src, len_src)\n                 })\n             });\n-            vec::raw::set_len(dst, old_len + src.len());\n+            dst.set_len(old_len + src.len());\n         }\n     }\n }\n@@ -2818,7 +2767,7 @@ mod tests {\n         unsafe {\n             // Test on-stack copy-from-buf.\n             let a = ~[1, 2, 3];\n-            let mut ptr = raw::to_ptr(a);\n+            let mut ptr = a.as_ptr();\n             let b = from_buf(ptr, 3u);\n             assert_eq!(b.len(), 3u);\n             assert_eq!(b[0], 1);\n@@ -2827,7 +2776,7 @@ mod tests {\n \n             // Test on-heap copy-from-buf.\n             let c = ~[1, 2, 3, 4, 5];\n-            ptr = raw::to_ptr(c);\n+            ptr = c.as_ptr();\n             let d = from_buf(ptr, 5u);\n             assert_eq!(d.len(), 5u);\n             assert_eq!(d[0], 1);\n@@ -3652,7 +3601,7 @@ mod tests {\n         unsafe {\n             let mut a = [1, 2, 3, 4];\n             let b = [1, 2, 3, 4, 5];\n-            raw::copy_memory(a, b, 5);\n+            raw::copy_memory(a, b);\n         }\n     }\n \n@@ -4354,9 +4303,9 @@ mod bench {\n         bh.iter(|| {\n             let mut v: ~[u8] = vec::with_capacity(1024);\n             unsafe {\n-                let vp = vec::raw::to_mut_ptr(v);\n+                let vp = v.as_mut_ptr();\n                 ptr::set_memory(vp, 0, 1024);\n-                vec::raw::set_len(&mut v, 1024);\n+                v.set_len(1024);\n             }\n         });\n     }\n@@ -4375,7 +4324,7 @@ mod bench {\n         bh.iter(|| {\n             let mut v: ~[u8] = vec::with_capacity(1024);\n             unsafe {\n-                vec::raw::set_len(&mut v, 1024);\n+                v.set_len(1024);\n             }\n             for i in range(0, 1024) {\n                 v[i] = 0;\n@@ -4388,7 +4337,7 @@ mod bench {\n         bh.iter(|| {\n             let mut v: ~[u8] = vec::with_capacity(1024);\n             unsafe {\n-                vec::raw::set_len(&mut v, 1024);\n+                v.set_len(1024);\n             }\n             for x in v.mut_iter() {\n                 *x = 0;"}, {"sha": "ea57eae22b8e3d7dc561afb1cd2f8507d3c91f80", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -37,16 +37,16 @@ fn fannkuch_redux(n: i32) -> i32 {\n             let mut flips_count: i32 = 0;\n             let mut k: i32;\n             loop {\n-                k = perm.unsafe_get(0);\n+                k = *perm.unsafe_ref(0);\n                 if k == 0 {\n                     break;\n                 }\n \n                 let k2 = (k+1) >> 1;\n                 for i in range(0i32, k2) {\n                     let (perm_i, perm_k_i) = {\n-                        (perm.unsafe_get(i as uint),\n-                            perm.unsafe_get((k-i) as uint))\n+                        (*perm.unsafe_ref(i as uint),\n+                            *perm.unsafe_ref((k-i) as uint))\n                     };\n                     perm.unsafe_set(i as uint, perm_k_i);\n                     perm.unsafe_set((k-i) as uint, perm_i);\n@@ -72,15 +72,15 @@ fn fannkuch_redux(n: i32) -> i32 {\n                 let mut i: i32 = 0;\n                 while i < r {\n                     let j = i + 1;\n-                    let perm1_j = { perm1.unsafe_get(j as uint) };\n+                    let perm1_j = { *perm1.unsafe_ref(j as uint) };\n                     perm1.unsafe_set(i as uint, perm1_j);\n                     i = j;\n                 }\n                 perm1.unsafe_set(r as uint, perm0);\n \n-                let count_r = { count.unsafe_get(r as uint) };\n+                let count_r = { *count.unsafe_ref(r as uint) };\n                 count.unsafe_set(r as uint, count_r - 1);\n-                if count.unsafe_get(r as uint) > 0 {\n+                if *count.unsafe_ref(r as uint) > 0 {\n                     break;\n                 }\n                 r += 1;"}, {"sha": "d0f91a358a70cc7c3e11c7ec000d315cad08030a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d52dfbace05c46754f4f6bb5a25f55906c9d7b0/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=8d52dfbace05c46754f4f6bb5a25f55906c9d7b0", "patch": "@@ -95,11 +95,10 @@ impl RepeatFasta {\n             let mut buf = vec::from_elem(alu_len + LINE_LEN, 0u8);\n             let alu: &[u8] = self.alu.as_bytes();\n \n-            copy_memory(buf, alu, alu_len);\n+            copy_memory(buf, alu);\n             let buf_len = buf.len();\n             copy_memory(buf.mut_slice(alu_len, buf_len),\n-                        alu,\n-                        LINE_LEN);\n+                        alu.slice_to(LINE_LEN));\n \n             let mut pos = 0;\n             let mut bytes;"}]}