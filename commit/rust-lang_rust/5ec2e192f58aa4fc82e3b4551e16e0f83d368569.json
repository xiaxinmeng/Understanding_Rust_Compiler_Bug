{"sha": "5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "node_id": "C_kwDOAAsO6NoAKDVlYzJlMTkyZjU4YWE0ZmM4MmUzYjQ1NTFlMTZlMGY4M2QzNjg1Njk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T00:29:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-11T00:29:21Z"}, "message": "Auto merge of #10614 - bluthej:clear-with-drain, r=Manishearth\n\nClear with drain\n\nFixes #10572: both the original intent of the issue (extending `clear_with_drain`) and the false negative for `collection_is_never_read` I found in the process are fixed by this PR.\n\nchangelog: [`clear_with_drain`]: extend to 5 other types of containers. [`collection_is_never_read`]: fix false negative for `String`s.", "tree": {"sha": "60a43de044c44d95f3bea91bbb3b108bdc7bf975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60a43de044c44d95f3bea91bbb3b108bdc7bf975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "html_url": "https://github.com/rust-lang/rust/commit/5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e22019d0b78778a8a3ae1067082d2481690d4210", "url": "https://api.github.com/repos/rust-lang/rust/commits/e22019d0b78778a8a3ae1067082d2481690d4210", "html_url": "https://github.com/rust-lang/rust/commit/e22019d0b78778a8a3ae1067082d2481690d4210"}, {"sha": "d8f0a96ba23d6d7f348a2538c223b61254c64031", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8f0a96ba23d6d7f348a2538c223b61254c64031", "html_url": "https://github.com/rust-lang/rust/commit/d8f0a96ba23d6d7f348a2538c223b61254c64031"}], "stats": {"total": 876, "additions": 787, "deletions": 89}, "files": [{"sha": "15a5b7dd274851ea911c2f1d413b98b24e5f396f", "filename": "clippy_lints/src/collection_is_never_read.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollection_is_never_read.rs?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::visitors::for_each_expr_with_closures;\n use clippy_utils::{get_enclosing_block, get_parent_node, path_to_local_id};\n use core::ops::ControlFlow;\n-use rustc_hir::{Block, ExprKind, HirId, Local, Node, PatKind};\n+use rustc_hir::{Block, ExprKind, HirId, LangItem, Local, Node, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -44,24 +44,23 @@ declare_clippy_lint! {\n }\n declare_lint_pass!(CollectionIsNeverRead => [COLLECTION_IS_NEVER_READ]);\n \n-static COLLECTIONS: [Symbol; 10] = [\n+// Add `String` here when it is added to diagnostic items\n+static COLLECTIONS: [Symbol; 9] = [\n     sym::BTreeMap,\n     sym::BTreeSet,\n     sym::BinaryHeap,\n     sym::HashMap,\n     sym::HashSet,\n     sym::LinkedList,\n     sym::Option,\n-    sym::String,\n     sym::Vec,\n     sym::VecDeque,\n ];\n \n impl<'tcx> LateLintPass<'tcx> for CollectionIsNeverRead {\n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         // Look for local variables whose type is a container. Search surrounding bock for read access.\n-        let ty = cx.typeck_results().pat_ty(local.pat);\n-        if COLLECTIONS.iter().any(|&sym| is_type_diagnostic_item(cx, ty, sym))\n+        if match_acceptable_type(cx, local, &COLLECTIONS)\n             && let PatKind::Binding(_, local_id, _, _) = local.pat.kind\n             && let Some(enclosing_block) = get_enclosing_block(cx, local.hir_id)\n             && has_no_read_access(cx, local_id, enclosing_block)\n@@ -71,6 +70,13 @@ impl<'tcx> LateLintPass<'tcx> for CollectionIsNeverRead {\n     }\n }\n \n+fn match_acceptable_type(cx: &LateContext<'_>, local: &Local<'_>, collections: &[rustc_span::Symbol]) -> bool {\n+    let ty = cx.typeck_results().pat_ty(local.pat);\n+    collections.iter().any(|&sym| is_type_diagnostic_item(cx, ty, sym))\n+    // String type is a lang item but not a diagnostic item for now so we need a separate check\n+        || is_type_lang_item(cx, ty, LangItem::String)\n+}\n+\n fn has_no_read_access<'tcx>(cx: &LateContext<'tcx>, id: HirId, block: &'tcx Block<'tcx>) -> bool {\n     let mut has_access = false;\n     let mut has_read_access = false;"}, {"sha": "67ad58d5a8c646b2d23bfcfdd6f97caf4c0aa226", "filename": "clippy_lints/src/methods/clear_with_drain.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclear_with_drain.rs?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -1,25 +1,50 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::is_range_full;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, QPath};\n+use rustc_hir as hir;\n+use rustc_hir::{Expr, ExprKind, LangItem, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use super::CLEAR_WITH_DRAIN;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n-    let ty = cx.typeck_results().expr_ty(recv);\n-    if is_type_diagnostic_item(cx, ty, sym::Vec)\n-        && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n-        && is_range_full(cx, arg, Some(container_path))\n+// Add `String` here when it is added to diagnostic items\n+const ACCEPTABLE_TYPES_WITH_ARG: [rustc_span::Symbol; 2] = [sym::Vec, sym::VecDeque];\n+\n+const ACCEPTABLE_TYPES_WITHOUT_ARG: [rustc_span::Symbol; 3] = [sym::BinaryHeap, sym::HashMap, sym::HashSet];\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: Option<&Expr<'_>>) {\n+    if let Some(arg) = arg {\n+        if match_acceptable_type(cx, recv, &ACCEPTABLE_TYPES_WITH_ARG)\n+            && let ExprKind::Path(QPath::Resolved(None, container_path)) = recv.kind\n+            && is_range_full(cx, arg, Some(container_path))\n+        {\n+            suggest(cx, expr, recv, span);\n+        }\n+    } else if match_acceptable_type(cx, recv, &ACCEPTABLE_TYPES_WITHOUT_ARG) {\n+        suggest(cx, expr, recv, span);\n+    }\n+}\n+\n+fn match_acceptable_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>, types: &[rustc_span::Symbol]) -> bool {\n+    let expr_ty = cx.typeck_results().expr_ty(expr).peel_refs();\n+    types.iter().any(|&ty| is_type_diagnostic_item(cx, expr_ty, ty))\n+    // String type is a lang item but not a diagnostic item for now so we need a separate check\n+        || is_type_lang_item(cx, expr_ty, LangItem::String)\n+}\n+\n+fn suggest(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span) {\n+    if let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n+    // Use `opt_item_name` while `String` is not a diagnostic item\n+        && let Some(ty_name) = cx.tcx.opt_item_name(adt.did())\n     {\n         span_lint_and_sugg(\n             cx,\n             CLEAR_WITH_DRAIN,\n             span.with_hi(expr.span.hi()),\n-            \"`drain` used to clear a `Vec`\",\n+            &format!(\"`drain` used to clear a `{ty_name}`\"),\n             \"try\",\n             \"clear()\".to_string(),\n             Applicability::MachineApplicable,"}, {"sha": "64bf55ba24c9814378c902ec1a98eeb529980bc1", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -3193,7 +3193,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for usage of `.drain(..)` for the sole purpose of clearing a `Vec`.\n+    /// Checks for usage of `.drain(..)` for the sole purpose of clearing a container.\n     ///\n     /// ### Why is this bad?\n     /// This creates an unnecessary iterator that is dropped immediately.\n@@ -3213,7 +3213,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.69.0\"]\n     pub CLEAR_WITH_DRAIN,\n     nursery,\n-    \"calling `drain` in order to `clear` a `Vec`\"\n+    \"calling `drain` in order to `clear` a container\"\n }\n \n pub struct Methods {\n@@ -3589,12 +3589,13 @@ impl Methods {\n                     Some((\"bytes\", recv2, [], _, _)) => bytes_count_to_len::check(cx, expr, recv, recv2),\n                     _ => {},\n                 },\n-                (\"drain\", [arg]) => {\n-                if let Node::Stmt(Stmt { hir_id: _, kind, .. }) = cx.tcx.hir().get_parent(expr.hir_id)\n-                    && matches!(kind, StmtKind::Semi(_))\n+                (\"drain\", ..) => {\n+                    if let Node::Stmt(Stmt { hir_id: _, kind, .. }) = cx.tcx.hir().get_parent(expr.hir_id)\n+                        && matches!(kind, StmtKind::Semi(_))\n+                        && args.len() <= 1\n                     {\n-                        clear_with_drain::check(cx, expr, recv, span, arg);\n-                    } else {\n+                        clear_with_drain::check(cx, expr, recv, span, args.first());\n+                    } else if let [arg] = args {\n                         iter_with_drain::check(cx, expr, recv, span, arg);\n                     }\n                 },"}, {"sha": "2d9545eeed1972186b3a8b36b1a0ea14be266958", "filename": "tests/ui/clear_with_drain.fixed", "status": "modified", "additions": 299, "deletions": 27, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.fixed?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -2,85 +2,357 @@\n #![allow(unused)]\n #![warn(clippy::clear_with_drain)]\n \n-fn range() {\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..v.len()); // Yay\n+    let iter = v.drain(0..v.len());\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let n = v.drain(0..v.len()).count(); // Yay\n+    let n = v.drain(0..v.len()).count();\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let iter = v.drain(usize::MIN..v.len());\n     let n = iter.count();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_from() {\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..); // Yay\n+    let iter = v.drain(0..);\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let mut iter = v.drain(0..); // Yay\n+    let mut iter = v.drain(0..);\n     let next = iter.next();\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let next = v.drain(usize::MIN..).next(); // Yay\n+    let next = v.drain(usize::MIN..).next();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_full() {\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..); // Yay\n+    let iter = v.drain(..);\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    // Yay\n     for x in v.drain(..) {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn range_to() {\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n     for x in iter {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.clear(); // Nay\n+    v.clear();\n }\n \n-fn partial_drains() {\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..); // Yay\n+    v.drain(1..);\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..).max(); // Yay\n+    v.drain(1..).max();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1); // Yay\n+    v.drain(..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1).min(); // Yay\n+    v.drain(..v.len() - 1).min();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(1..v.len() - 1); // Yay\n+    v.drain(1..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.clear();\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.clear();\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n+    let mut set = HashSet::from([1, 2, 3]);\n+    set.clear();\n+}\n+\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n+\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.clear();\n+}\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.clear();\n }\n \n fn main() {}"}, {"sha": "4d60ee46e1865bb12ab1b58cc04491d301052ff5", "filename": "tests/ui/clear_with_drain.rs", "status": "modified", "additions": 299, "deletions": 27, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.rs?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -2,85 +2,357 @@\n #![allow(unused)]\n #![warn(clippy::clear_with_drain)]\n \n-fn range() {\n+use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};\n+\n+fn vec_range() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..v.len()); // Yay\n+    let iter = v.drain(0..v.len());\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let n = v.drain(0..v.len()).count(); // Yay\n+    let n = v.drain(0..v.len()).count();\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(usize::MIN..v.len()); // Yay\n+    let iter = v.drain(usize::MIN..v.len());\n     let n = iter.count();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(0..v.len()); // Nay\n+    v.drain(0..v.len());\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(usize::MIN..v.len()); // Nay\n+    v.drain(usize::MIN..v.len());\n }\n \n-fn range_from() {\n+fn vec_range_from() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(0..); // Yay\n+    let iter = v.drain(0..);\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let mut iter = v.drain(0..); // Yay\n+    let mut iter = v.drain(0..);\n     let next = iter.next();\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    let next = v.drain(usize::MIN..).next(); // Yay\n+    let next = v.drain(usize::MIN..).next();\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(0..); // Nay\n+    v.drain(0..);\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(usize::MIN..); // Nay\n+    v.drain(usize::MIN..);\n }\n \n-fn range_full() {\n+fn vec_range_full() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..); // Yay\n+    let iter = v.drain(..);\n \n+    // Do not lint because iterator is used\n     let mut v = vec![1, 2, 3];\n-    // Yay\n     for x in v.drain(..) {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(..); // Nay\n+    v.drain(..);\n }\n \n-fn range_to() {\n+fn vec_range_to() {\n+    // Do not lint because iterator is assigned\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n \n+    // Do not lint because iterator is assigned and used\n     let mut v = vec![1, 2, 3];\n-    let iter = v.drain(..v.len()); // Yay\n+    let iter = v.drain(..v.len());\n     for x in iter {\n         let y = format!(\"x = {x}\");\n     }\n \n+    // Do lint\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len()); // Nay\n+    v.drain(..v.len());\n }\n \n-fn partial_drains() {\n+fn vec_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..); // Yay\n+    v.drain(1..);\n     let mut v = vec![1, 2, 3];\n-    v.drain(1..).max(); // Yay\n+    v.drain(1..).max();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1); // Yay\n+    v.drain(..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    v.drain(..v.len() - 1).min(); // Yay\n+    v.drain(..v.len() - 1).min();\n \n     let mut v = vec![1, 2, 3];\n-    v.drain(1..v.len() - 1); // Yay\n+    v.drain(1..v.len() - 1);\n     let mut v = vec![1, 2, 3];\n-    let w: Vec<i8> = v.drain(1..v.len() - 1).collect(); // Yay\n+    let w: Vec<i8> = v.drain(1..v.len() - 1).collect();\n+}\n+\n+fn vec_deque_range() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..deque.len());\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let n = deque.drain(0..deque.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(usize::MIN..deque.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..deque.len());\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..deque.len());\n+}\n+\n+fn vec_deque_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let mut iter = deque.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let next = deque.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(0..);\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(usize::MIN..);\n+}\n+\n+fn vec_deque_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    for x in deque.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..);\n+}\n+\n+fn vec_deque_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let iter = deque.drain(..deque.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len());\n+}\n+\n+fn vec_deque_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..).max();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(..deque.len() - 1).min();\n+\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    deque.drain(1..deque.len() - 1);\n+    let mut deque = VecDeque::from([1, 2, 3]);\n+    let w: Vec<i8> = deque.drain(1..deque.len() - 1).collect();\n+}\n+\n+fn string_range() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..s.len());\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let n = s.drain(0..s.len()).count();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(usize::MIN..s.len());\n+    let n = iter.count();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..s.len());\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..s.len());\n+}\n+\n+fn string_range_from() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(0..);\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let mut iter = s.drain(0..);\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    let next = s.drain(usize::MIN..).next();\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(0..);\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(usize::MIN..);\n+}\n+\n+fn string_range_full() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..);\n+\n+    // Do not lint because iterator is used\n+    let mut s = String::from(\"Hello, world!\");\n+    for x in s.drain(..) {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..);\n+}\n+\n+fn string_range_to() {\n+    // Do not lint because iterator is assigned\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut s = String::from(\"Hello, world!\");\n+    let iter = s.drain(..s.len());\n+    for x in iter {\n+        let y = format!(\"x = {x}\");\n+    }\n+\n+    // Do lint\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len());\n+}\n+\n+fn string_partial_drains() {\n+    // Do not lint any of these because the ranges are not full\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..).max();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(..s.len() - 1).min();\n+\n+    let mut s = String::from(\"Hello, world!\");\n+    s.drain(1..s.len() - 1);\n+    let mut s = String::from(\"Hello, world!\");\n+    let w: String = s.drain(1..s.len() - 1).collect();\n+}\n+\n+fn hash_set() {\n+    // Do not lint because iterator is assigned\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let iter = set.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let mut iter = set.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut set = HashSet::from([1, 2, 3]);\n+    let next = set.drain().next();\n+\n+    // Do lint\n+    let mut set = HashSet::from([1, 2, 3]);\n+    set.drain();\n+}\n+\n+fn hash_map() {\n+    // Do not lint because iterator is assigned\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let iter = map.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let mut iter = map.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    let next = map.drain().next();\n+\n+    // Do lint\n+    let mut map = HashMap::from([(1, \"a\"), (2, \"b\")]);\n+    map.drain();\n+}\n+\n+fn binary_heap() {\n+    // Do not lint because iterator is assigned\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let iter = heap.drain();\n+\n+    // Do not lint because iterator is assigned and used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let mut iter = heap.drain();\n+    let next = iter.next();\n+\n+    // Do not lint because iterator is used\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    let next = heap.drain().next();\n+\n+    // Do lint\n+    let mut heap = BinaryHeap::from([1, 2]);\n+    heap.drain();\n }\n \n fn main() {}"}, {"sha": "20158da1121b78ac54aed8973cd0be2dbeae2404", "filename": "tests/ui/clear_with_drain.stderr", "status": "modified", "additions": 103, "deletions": 13, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fclear_with_drain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclear_with_drain.stderr?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -1,40 +1,130 @@\n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:17:7\n+  --> $DIR/clear_with_drain.rs:23:7\n    |\n-LL |     v.drain(0..v.len()); // Nay\n+LL |     v.drain(0..v.len());\n    |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n    |\n    = note: `-D clippy::clear-with-drain` implied by `-D warnings`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:20:7\n+  --> $DIR/clear_with_drain.rs:27:7\n    |\n-LL |     v.drain(usize::MIN..v.len()); // Nay\n+LL |     v.drain(usize::MIN..v.len());\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:35:7\n+  --> $DIR/clear_with_drain.rs:46:7\n    |\n-LL |     v.drain(0..); // Nay\n+LL |     v.drain(0..);\n    |       ^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:38:7\n+  --> $DIR/clear_with_drain.rs:50:7\n    |\n-LL |     v.drain(usize::MIN..); // Nay\n+LL |     v.drain(usize::MIN..);\n    |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:52:7\n+  --> $DIR/clear_with_drain.rs:66:7\n    |\n-LL |     v.drain(..); // Nay\n+LL |     v.drain(..);\n    |       ^^^^^^^^^ help: try: `clear()`\n \n error: `drain` used to clear a `Vec`\n-  --> $DIR/clear_with_drain.rs:66:7\n+  --> $DIR/clear_with_drain.rs:83:7\n+   |\n+LL |     v.drain(..v.len());\n+   |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:121:11\n+   |\n+LL |     deque.drain(0..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:125:11\n+   |\n+LL |     deque.drain(usize::MIN..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:144:11\n+   |\n+LL |     deque.drain(0..);\n+   |           ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:148:11\n+   |\n+LL |     deque.drain(usize::MIN..);\n+   |           ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:164:11\n+   |\n+LL |     deque.drain(..);\n+   |           ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `VecDeque`\n+  --> $DIR/clear_with_drain.rs:181:11\n+   |\n+LL |     deque.drain(..deque.len());\n+   |           ^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:219:7\n+   |\n+LL |     s.drain(0..s.len());\n+   |       ^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:223:7\n+   |\n+LL |     s.drain(usize::MIN..s.len());\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:242:7\n+   |\n+LL |     s.drain(0..);\n+   |       ^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:246:7\n+   |\n+LL |     s.drain(usize::MIN..);\n+   |       ^^^^^^^^^^^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:262:7\n    |\n-LL |     v.drain(..v.len()); // Nay\n+LL |     s.drain(..);\n+   |       ^^^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `String`\n+  --> $DIR/clear_with_drain.rs:279:7\n+   |\n+LL |     s.drain(..s.len());\n    |       ^^^^^^^^^^^^^^^^ help: try: `clear()`\n \n-error: aborting due to 6 previous errors\n+error: `drain` used to clear a `HashSet`\n+  --> $DIR/clear_with_drain.rs:317:9\n+   |\n+LL |     set.drain();\n+   |         ^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `HashMap`\n+  --> $DIR/clear_with_drain.rs:336:9\n+   |\n+LL |     map.drain();\n+   |         ^^^^^^^ help: try: `clear()`\n+\n+error: `drain` used to clear a `BinaryHeap`\n+  --> $DIR/clear_with_drain.rs:355:10\n+   |\n+LL |     heap.drain();\n+   |          ^^^^^^^ help: try: `clear()`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "ca20031bfbefa3b3f496888f52fd5123ccb588f7", "filename": "tests/ui/collection_is_never_read.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fcollection_is_never_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fcollection_is_never_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.rs?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -163,3 +163,23 @@ fn function_argument() {\n     let x = vec![1, 2, 3]; // Ok\n     foo(&x);\n }\n+\n+fn string() {\n+    // Do lint (write without read)\n+    let mut s = String::new();\n+    s.push_str(\"Hello, World!\");\n+\n+    // Do not lint (read without write)\n+    let mut s = String::from(\"Hello, World!\");\n+    let _ = s.len();\n+\n+    // Do not lint (write and read)\n+    let mut s = String::from(\"Hello, World!\");\n+    s.push_str(\"foo, bar\");\n+    let _ = s.len();\n+\n+    // Do lint the first line, but not the second\n+    let mut s = String::from(\"Hello, World!\");\n+    let t = String::from(\"foo, bar\");\n+    s = t;\n+}"}, {"sha": "f5dea96116f84f23b328368e0832b28d11ef2d73", "filename": "tests/ui/collection_is_never_read.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fcollection_is_never_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2e192f58aa4fc82e3b4551e16e0f83d368569/tests%2Fui%2Fcollection_is_never_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollection_is_never_read.stderr?ref=5ec2e192f58aa4fc82e3b4551e16e0f83d368569", "patch": "@@ -48,5 +48,17 @@ error: collection is never read\n LL |     let x = vec![1, 2, 3]; // WARNING\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:169:5\n+   |\n+LL |     let mut s = String::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: collection is never read\n+  --> $DIR/collection_is_never_read.rs:182:5\n+   |\n+LL |     let mut s = String::from(\"Hello, World!\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 10 previous errors\n "}]}