{"sha": "5a1e6df07ca2c664ec2333032961989dd68faf03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMWU2ZGYwN2NhMmM2NjRlYzIzMzMwMzI5NjE5ODlkZDY4ZmFmMDM=", "commit": {"author": {"name": "Michael Macias", "email": "zaeleus@gmail.com", "date": "2015-05-15T23:00:45Z"}, "committer": {"name": "Michael Macias", "email": "zaeleus@gmail.com", "date": "2015-05-18T18:09:21Z"}, "message": "trpl: Proofread \"Rust Inside Other Languages\"", "tree": {"sha": "a629e6d78893749021fd1296cfdf6739c54390b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a629e6d78893749021fd1296cfdf6739c54390b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a1e6df07ca2c664ec2333032961989dd68faf03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a1e6df07ca2c664ec2333032961989dd68faf03", "html_url": "https://github.com/rust-lang/rust/commit/5a1e6df07ca2c664ec2333032961989dd68faf03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a1e6df07ca2c664ec2333032961989dd68faf03/comments", "author": {"login": "zaeleus", "id": 191331, "node_id": "MDQ6VXNlcjE5MTMzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/191331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaeleus", "html_url": "https://github.com/zaeleus", "followers_url": "https://api.github.com/users/zaeleus/followers", "following_url": "https://api.github.com/users/zaeleus/following{/other_user}", "gists_url": "https://api.github.com/users/zaeleus/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaeleus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaeleus/subscriptions", "organizations_url": "https://api.github.com/users/zaeleus/orgs", "repos_url": "https://api.github.com/users/zaeleus/repos", "events_url": "https://api.github.com/users/zaeleus/events{/privacy}", "received_events_url": "https://api.github.com/users/zaeleus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zaeleus", "id": 191331, "node_id": "MDQ6VXNlcjE5MTMzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/191331?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zaeleus", "html_url": "https://github.com/zaeleus", "followers_url": "https://api.github.com/users/zaeleus/followers", "following_url": "https://api.github.com/users/zaeleus/following{/other_user}", "gists_url": "https://api.github.com/users/zaeleus/gists{/gist_id}", "starred_url": "https://api.github.com/users/zaeleus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zaeleus/subscriptions", "organizations_url": "https://api.github.com/users/zaeleus/orgs", "repos_url": "https://api.github.com/users/zaeleus/repos", "events_url": "https://api.github.com/users/zaeleus/events{/privacy}", "received_events_url": "https://api.github.com/users/zaeleus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b1e084862c08c19c36f0cf1f3698343c8ba7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b1e084862c08c19c36f0cf1f3698343c8ba7fa", "html_url": "https://github.com/rust-lang/rust/commit/84b1e084862c08c19c36f0cf1f3698343c8ba7fa"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "ca3381ffba465d61a0da1f6742f4b2ce2ee7fdf4", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a1e6df07ca2c664ec2333032961989dd68faf03/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a1e6df07ca2c664ec2333032961989dd68faf03/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=5a1e6df07ca2c664ec2333032961989dd68faf03", "patch": "@@ -7,7 +7,7 @@\n * [Learn Rust](learn-rust.md)\n     * [Guessing Game](guessing-game.md)\n     * [Dining Philosophers](dining-philosophers.md)\n-    * [Rust inside other languages](rust-inside-other-languages.md)\n+    * [Rust Inside Other Languages](rust-inside-other-languages.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)"}, {"sha": "0a1860769d231716991d56517e06f90af5028ef8", "filename": "src/doc/trpl/rust-inside-other-languages.md", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5a1e6df07ca2c664ec2333032961989dd68faf03/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a1e6df07ca2c664ec2333032961989dd68faf03/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Frust-inside-other-languages.md?ref=5a1e6df07ca2c664ec2333032961989dd68faf03", "patch": "@@ -6,24 +6,24 @@ Rust\u2019s greatest strengths: a lack of a substantial runtime.\n As organizations grow, they increasingly rely on a multitude of programming\n languages. Different programming languages have different strengths and\n weaknesses, and a polyglot stack lets you use a particular language where\n-its strengths make sense, and use a different language where it\u2019s weak.\n+its strengths make sense and a different one where it\u2019s weak.\n \n A very common area where many programming languages are weak is in runtime\n performance of programs. Often, using a language that is slower, but offers\n-greater programmer productivity is a worthwhile trade-off. To help mitigate\n-this, they provide a way to write some of your system in C, and then call\n-the C code as though it were written in the higher-level language. This is\n+greater programmer productivity, is a worthwhile trade-off. To help mitigate\n+this, they provide a way to write some of your system in C and then call\n+that C code as though it were written in the higher-level language. This is\n called a \u2018foreign function interface\u2019, often shortened to \u2018FFI\u2019.\n \n Rust has support for FFI in both directions: it can call into C code easily,\n but crucially, it can also be called _into_ as easily as C. Combined with\n Rust\u2019s lack of a garbage collector and low runtime requirements, this makes\n Rust a great candidate to embed inside of other languages when you need\n-some extra oomph.\n+that extra oomph.\n \n There is a whole [chapter devoted to FFI][ffi] and its specifics elsewhere in\n the book, but in this chapter, we\u2019ll examine this particular use-case of FFI,\n-with three examples, in Ruby, Python, and JavaScript.\n+with examples in Ruby, Python, and JavaScript.\n \n [ffi]: ffi.html\n \n@@ -40,18 +40,18 @@ optimizations can stack allocate particular numbers, but rather than relying\n on an optimizer to do its job, we may want to ensure that we\u2019re always using\n primitive number types rather than some sort of object type.\n \n-Second, many languages have a \u2018global interpreter lock\u2019, which limits\n+Second, many languages have a \u2018global interpreter lock\u2019 (GIL), which limits\n concurrency in many situations. This is done in the name of safety, which is\n a positive effect, but it limits the amount of work that can be done at the\n same time, which is a big negative.\n \n To emphasize these two aspects, we\u2019re going to create a little project that\n-uses these two aspects heavily. Since the focus of the example is the embedding\n-of Rust into the languages, rather than the problem itself, we\u2019ll just use a\n+uses these two aspects heavily. Since the focus of the example is to embed\n+Rust into other languages, rather than the problem itself, we\u2019ll just use a\n toy example:\n \n > Start ten threads. Inside each thread, count from one to five million. After\n-> All ten threads are finished, print out \u2018done!\u2019.\n+> all ten threads are finished, print out \u2018done!\u2019.\n \n I chose five million based on my particular computer. Here\u2019s an example of this\n code in Ruby:\n@@ -69,7 +69,7 @@ threads = []\n   end\n end\n \n-threads.each {|t| t.join }\n+threads.each { |t| t.join }\n puts \"done!\"\n ```\n \n@@ -82,12 +82,12 @@ sort of process monitoring tool, like `top`, I can see that it only uses one\n core on my machine. That\u2019s the GIL kicking in.\n \n While it\u2019s true that this is a synthetic program, one can imagine many problems\n-that are similar to this in the real world. For our purposes, spinning up some\n+that are similar to this in the real world. For our purposes, spinning up a few\n busy threads represents some sort of parallel, expensive computation.\n \n # A Rust library\n \n-Let\u2019s re-write this problem in Rust. First, let\u2019s make a new project with\n+Let\u2019s rewrite this problem in Rust. First, let\u2019s make a new project with\n Cargo:\n \n ```bash\n@@ -129,7 +129,7 @@ src/lib.rs:3 fn process() {\n src/lib.rs:4     let handles: Vec<_> = (0..10).map(|_| {\n src/lib.rs:5         thread::spawn(|| {\n src/lib.rs:6             let mut x = 0;\n-src/lib.rs:7             for _ in (0..5_000_001) {\n+src/lib.rs:7             for _ in (0..5_000_000) {\n src/lib.rs:8                 x += 1\n              ...\n src/lib.rs:6:17: 6:22 warning: variable `x` is assigned to, but never used, #[warn(unused_variables)] on by default\n@@ -151,7 +151,7 @@ Finally, we join on each thread.\n Right now, however, this is a Rust library, and it doesn\u2019t expose anything\n that\u2019s callable from C. If we tried to hook this up to another language right\n now, it wouldn\u2019t work. We only need to make two small changes to fix this,\n-though. The first is modify the beginning of our code:\n+though. The first is to modify the beginning of our code:\n \n ```rust,ignore\n #[no_mangle]\n@@ -161,7 +161,7 @@ pub extern fn process() {\n We have to add a new attribute, `no_mangle`. When you create a Rust library, it\n changes the name of the function in the compiled output. The reasons for this\n are outside the scope of this tutorial, but in order for other languages to\n-know how to call the function, we need to not do that. This attribute turns\n+know how to call the function, we can\u2019t do that. This attribute turns\n that behavior off.\n \n The other change is the `pub extern`. The `pub` means that this function should\n@@ -178,7 +178,7 @@ crate-type = [\"dylib\"]\n ```\n \n This tells Rust that we want to compile our library into a standard dynamic\n-library. By default, Rust compiles into an \u2018rlib\u2019, a Rust-specific format.\n+library. By default, Rust compiles an \u2018rlib\u2019, a Rust-specific format.\n \n Let\u2019s build the project now:\n \n@@ -204,7 +204,7 @@ Now that we\u2019ve got our Rust library built, let\u2019s use it from our Ruby.\n \n # Ruby\n \n-Open up a `embed.rb` file inside of our project, and do this:\n+Open up an `embed.rb` file inside of our project, and do this:\n \n ```ruby\n require 'ffi'\n@@ -217,7 +217,7 @@ end\n \n Hello.process\n \n-puts \"done!\"\n+puts 'done!'\n ```\n \n Before we can run this, we need to install the `ffi` gem:\n@@ -241,7 +241,7 @@ done!\n $\n ```\n \n-Whoah, that was fast! On my system, this took `0.086` seconds, rather than\n+Whoa, that was fast! On my system, this took `0.086` seconds, rather than\n the two seconds the pure Ruby version took. Let\u2019s break down this Ruby\n code:\n \n@@ -258,11 +258,11 @@ module Hello\n   ffi_lib 'target/release/libembed.so'\n ```\n \n-The `ffi` gem\u2019s authors recommend using a module to scope the functions\n-we\u2019ll import from the shared library. Inside, we `extend` the necessary\n-`FFI::Library` module, and then call `ffi_lib` to load up our shared\n-object library. We just pass it the path that our library is stored,\n-which as we saw before, is `target/release/libembed.so`.\n+The `Hello` module is used to attach the native functions from the shared\n+library. Inside, we `extend` the necessary `FFI::Library` module and then call\n+`ffi_lib` to load up our shared object library. We just pass it the path that\n+our library is stored, which, as we saw before, is\n+`target/release/libembed.so`.\n \n ```ruby\n attach_function :process, [], :void\n@@ -280,10 +280,10 @@ Hello.process\n \n This is the actual call into Rust. The combination of our `module`\n and the call to `attach_function` sets this all up. It looks like\n-a Ruby function, but is actually Rust!\n+a Ruby function but is actually Rust!\n \n ```ruby\n-puts \"done!\"\n+puts 'done!'\n ```\n \n Finally, as per our project\u2019s requirements, we print out `done!`.\n@@ -329,7 +329,7 @@ After that installs, we can use it:\n var ffi = require('ffi');\n \n var lib = ffi.Library('target/release/libembed', {\n-  'process': [ 'void', []  ]\n+  'process': ['void', []]\n });\n \n lib.process();\n@@ -340,7 +340,7 @@ console.log(\"done!\");\n It looks more like the Ruby example than the Python example. We use\n the `ffi` module to get access to `ffi.Library()`, which loads up\n our shared object. We need to annotate the return type and argument\n-types of the function, which are 'void' for return, and an empty\n+types of the function, which are `void` for return and an empty\n array to signify no arguments. From there, we just call it and\n print the result.\n "}]}