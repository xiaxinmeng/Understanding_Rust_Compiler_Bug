{"sha": "7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MzVhZmMwZmE5Y2VjMzhmMGZkZDNhOWRlYWZiNDRmYjNlNWZjZjE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-06-11T04:43:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-11T04:43:41Z"}, "message": "Merge pull request #1823 from eddyb/nightly-magic\n\nUpdate for rustc 1.19.0-nightly (4bf5c99af 2017-06-10) and some cleanups.", "tree": {"sha": "5c431ccae0b0dd85e8530eec92107d1dd7bdd45e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c431ccae0b0dd85e8530eec92107d1dd7bdd45e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "html_url": "https://github.com/rust-lang/rust/commit/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ed74adfbdf0583525e7d16013a80c00e04b2e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed74adfbdf0583525e7d16013a80c00e04b2e4", "html_url": "https://github.com/rust-lang/rust/commit/72ed74adfbdf0583525e7d16013a80c00e04b2e4"}, {"sha": "50b3d7ee9d1968ee0f6ef8d2f7815b5afdcdc782", "url": "https://api.github.com/repos/rust-lang/rust/commits/50b3d7ee9d1968ee0f6ef8d2f7815b5afdcdc782", "html_url": "https://github.com/rust-lang/rust/commit/50b3d7ee9d1968ee0f6ef8d2f7815b5afdcdc782"}], "stats": {"total": 420, "additions": 198, "deletions": 222}, "files": [{"sha": "07d838bef2ede9eb9899882cb9c5a83c3ccca73a", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -82,14 +82,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                 if let hir::ExprBinary(binop, ref l, ref r) = rhs.node {\n                     if op.node == binop.node {\n                         let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n-                            let ty = cx.tables.expr_ty(assignee);\n-                            if ty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n-                            let rty = cx.tables.expr_ty(rhs);\n-                            if rty.walk_shallow().next().is_some() {\n-                                return; // implements_trait does not work with generics\n-                            }\n                             span_lint_and_then(cx,\n                                                MISREFACTORED_ASSIGN_OP,\n                                                expr.span,\n@@ -120,13 +112,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                     #[allow(cyclomatic_complexity)]\n                     let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n                         let ty = cx.tables.expr_ty(assignee);\n-                        if ty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         let rty = cx.tables.expr_ty(rhs);\n-                        if rty.walk_shallow().next().is_some() {\n-                            return; // implements_trait does not work with generics\n-                        }\n                         macro_rules! ops {\n                             ($op:expr,\n                              $cx:expr,\n@@ -152,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                             let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node,\n                                             trait_ref.path.def.def_id() == trait_id\n                                         ], { return; }}\n-                                        implements_trait($cx, $ty, trait_id, &[$rty], None)\n+                                        implements_trait($cx, $ty, trait_id, &[$rty])\n                                     },)*\n                                     _ => false,\n                                 }"}, {"sha": "1cca82d9795446a2ea18d71a671a15aac1011f60", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -3,7 +3,7 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n@@ -158,22 +158,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: ty::TyCtxt, item: &Item) -> bool {\n+fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(tcx: ty::TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -183,7 +183,7 @@ fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n@@ -196,7 +196,7 @@ fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block)\n     block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n }\n \n-fn is_relevant_expr(tcx: ty::TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(tcx, tables, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),"}, {"sha": "c68642da3b6217dc15dd09d81c5b4401695a4795", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::subst::{Substs, Subst};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n@@ -161,7 +161,7 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     use rustc::ty::util::IntTypeExt;"}, {"sha": "8764bbfa11bd9f985afc29d9989c2d5150063182", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::Ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n@@ -251,11 +251,11 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n }\n \n /// Return the list of bindings in a pattern.\n-fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n         pat: &Pat,\n-        map: &mut HashMap<InternedString, ty::Ty<'tcx>>\n+        map: &mut HashMap<InternedString, Ty<'tcx>>\n     ) {\n         match pat.node {\n             PatKind::Box(ref pat) |"}, {"sha": "f6642db8fec2e33a64ad93ecbf2cc80527eea144", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -89,7 +88,7 @@ fn check_hash_peq<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     span: Span,\n     trait_ref: &TraitRef,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     hash_is_automatically_derived: bool\n ) {\n     if_let_chain! {[\n@@ -134,28 +133,27 @@ fn check_hash_peq<'a, 'tcx>(\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n-fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: Ty<'tcx>) {\n     if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n-        let def_id = cx.tcx.hir.local_def_id(item.id);\n-        if !is_copy(cx, ty, def_id) {\n+        if !is_copy(cx, ty) {\n             return;\n         }\n \n         match ty.sty {\n-            TypeVariants::TyAdt(def, _) if def.is_union() => return,\n+            ty::TyAdt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            TypeVariants::TyAdt(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n                         match field.ty(cx.tcx, substs).sty {\n-                            TypeVariants::TyArray(_, size) if size > 32 => {\n+                            ty::TyArray(_, size) if size > 32 => {\n                                 return;\n                             },\n-                            TypeVariants::TyFnPtr(..) => {\n+                            ty::TyFnPtr(..) => {\n                                 return;\n                             },\n-                            TypeVariants::TyTuple(tys, _) if tys.len() > 12 => {\n+                            ty::TyTuple(tys, _) if tys.len() > 12 => {\n                                 return;\n                             },\n                             _ => (),"}, {"sha": "6112aec7cb6ad2a6d902a7b1402a147b937e8489", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -135,8 +135,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                    expr.span,\n                                    &msg,\n                                    arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty.sty));\n-            } else if is_copy(cx, arg_ty, cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(arg.id))) {\n+                                   &format!(\"argument has type {}\", arg_ty));\n+            } else if is_copy(cx, arg_ty) {\n                 if match_def_path(cx.tcx, def_id, &paths::DROP) {\n                     lint = DROP_COPY;\n                     msg = DROP_COPY_SUMMARY.to_string();\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                    expr.span,\n                                    &msg,\n                                    arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty.sty));\n+                                   &format!(\"argument has type {}\", arg_ty));\n             }\n         }}\n     }"}, {"sha": "12b588967f8a66e7a47de052ebd15ea6aaa6abc7", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n     fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n-            self.lint_item(cx, cx.krate.item(item.id));\n+            self.lint_item(cx, cx.tcx.hir.expect_item(item.id));\n         }\n     }\n }"}, {"sha": "9eab6352cc2e319e91fbfaa27e83554ea2a3b1c4", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -75,8 +75,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                 BiNe | BiEq => (cx.tcx.lang_items.eq_trait(), true),\n                 BiLt | BiLe | BiGe | BiGt => (cx.tcx.lang_items.ord_trait(), true),\n             };\n-            let parent = cx.tcx.hir.get_parent(e.id);\n-            let parent = cx.tcx.hir.local_def_id(parent);\n             if let Some(trait_id) = trait_id {\n                 #[allow(match_same_arms)]\n                 match (&left.node, &right.node) {\n@@ -87,10 +85,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let rty = cx.tables.expr_ty(r);\n-                        let lcpy = is_copy(cx, lty, parent);\n-                        let rcpy = is_copy(cx, rty, parent);\n+                        let lcpy = is_copy(cx, lty);\n+                        let rcpy = is_copy(cx, rty);\n                         // either operator autorefs or both args are copyable\n-                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty], None) {\n+                        if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -104,13 +102,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                                                     (right.span, rsnip)]);\n                             })\n                         } else if lcpy && !rcpy &&\n-                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n                         } else if !lcpy && rcpy &&\n-                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx,\n                                                OP_REF,\n                                                e.span,\n@@ -124,9 +122,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // &foo == bar\n                     (&ExprAddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n-                        let lcpy = is_copy(cx, lty, parent);\n+                        let lcpy = is_copy(cx, lty);\n                         if (requires_ref || lcpy) &&\n-                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n@@ -136,9 +134,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     // foo == &bar\n                     (_, &ExprAddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n-                        let rcpy = is_copy(cx, rty, parent);\n+                        let rcpy = is_copy(cx, rty);\n                         if (requires_ref || rcpy) &&\n-                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty]) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);"}, {"sha": "9f32204c437915d3e132e99cea95f726f93f2005", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -4,11 +4,11 @@ use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::util::nodemap::NodeSet;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n-use utils::span_lint;\n+use utils::{span_lint, type_size};\n \n pub struct Pass {\n     pub too_large_for_stack: u64,\n@@ -37,14 +37,13 @@ declare_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: ty::Ty) -> bool {\n+fn is_non_trait_box(ty: Ty) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     set: NodeSet,\n-    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     too_large_for_stack: u64,\n }\n \n@@ -65,19 +64,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         node_id: NodeId\n     ) {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n-        let param_env = cx.tcx.param_env(fn_def_id).reveal_all();\n         let mut v = EscapeDelegate {\n+            cx: cx,\n             set: NodeSet(),\n-            tcx: cx.tcx,\n-            param_env: param_env,\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n-            let region_maps = &cx.tcx.region_maps(fn_def_id);\n-            let mut vis = ExprUseVisitor::new(&mut v, region_maps, &infcx, param_env);\n-            vis.consume_body(body);\n-        });\n+        let region_maps = &cx.tcx.region_maps(fn_def_id);\n+        ExprUseVisitor::new(&mut v, cx.tcx, cx.param_env, region_maps, cx.tables)\n+            .consume_body(body);\n \n         for node in v.set {\n             span_lint(cx,\n@@ -88,7 +83,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n             if let Move(DirectRefMove) = mode {\n@@ -99,7 +94,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n     }\n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, _: ConsumeMode) {\n-        let map = &self.tcx.hir;\n+        let map = &self.cx.tcx.hir;\n         if map.is_argument(consume_pat.id) {\n             // Skip closure arguments\n             if let Some(NodeExpr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n@@ -172,18 +167,14 @@ impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n     fn mutate(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: MutateMode) {}\n }\n \n-impl<'a, 'tcx: 'a> EscapeDelegate<'a, 'tcx> {\n-    fn is_large_box(&self, ty: ty::Ty) -> bool {\n+impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n+    fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         if ty.is_box() {\n-            if let Some(inner) = self.tcx.lift(&ty.boxed_ty()) {\n-                if let Ok(layout) = inner.layout(self.tcx, self.param_env) {\n-                    return layout.size(self.tcx).bytes() > self.too_large_for_stack;\n-                }\n-            }\n+            type_size(self.cx, ty.boxed_ty()).unwrap_or(0) > self.too_large_for_stack\n+        } else {\n+            false\n         }\n-\n-        false\n     }\n }"}, {"sha": "e7dbc3250f78f75afc2ab5fd772fcf09076d5395", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n+use rustc::ty;\n use syntax::ast::LitKind;\n use syntax::symbol::InternedString;\n use utils::paths;\n@@ -132,7 +132,7 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n     ], {\n         let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n \n-        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n+        return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n     }}\n \n     false"}, {"sha": "eb4708498b6bdcb5851a49b32180ee7f33b4557d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n@@ -985,7 +985,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: ty::Ty) -> bool {\n+fn is_iterable_array(ty: Ty) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, 0...32) => true,"}, {"sha": "4ff1b5d0615e6ba3908d26c5112415b382626975", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n@@ -231,7 +231,7 @@ fn check_single_match_opt_like(\n     ex: &Expr,\n     arms: &[Arm],\n     expr: &Expr,\n-    ty: ty::Ty,\n+    ty: Ty,\n     els: Option<&Expr>\n ) {\n     // list of candidate Enums we know will never get any more members"}, {"sha": "9f662d57379f0df508f6adc19bf5c2723f920773", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // check conventions w.r.t. conversion method names and predicates\n             let def_id = cx.tcx.hir.local_def_id(item.id);\n             let ty = cx.tcx.type_of(def_id);\n-            let is_copy = is_copy(cx, ty, def_id);\n+            let is_copy = is_copy(cx, ty);\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n@@ -684,9 +684,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             }\n \n             let ret_ty = return_ty(cx, implitem.id);\n-            let implitem_defid = cx.tcx.hir.local_def_id(implitem.id);\n             if name == \"new\" &&\n-               !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem_defid)) {\n+               !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n                           implitem.span,\n@@ -725,7 +724,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n                         return false;\n                     };\n \n-                    if implements_trait(cx, arg_ty, default_trait_id, &[], None) {\n+                    if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n                         span_lint_and_then(cx,\n                                            OR_FUN_CALL,\n                                            span,\n@@ -820,9 +819,8 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n+fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n     let ty = cx.tables.expr_ty(expr);\n-    let parent = cx.tcx.hir.get_parent(expr.id);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             span_lint_and_then(cx,\n@@ -839,7 +837,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_t\n         }\n     }\n \n-    if is_copy(cx, ty, cx.tcx.hir.local_def_id(parent)) {\n+    if is_copy(cx, ty) {\n         span_lint_and_then(cx,\n                            CLONE_ON_COPY,\n                            expr.span,\n@@ -979,8 +977,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: ty::Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1253,7 +1251,7 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -1266,9 +1264,9 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n }\n \n /// This checks whether a given type is known to implement Debug.\n-fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+fn has_debug_impl<'a, 'b>(ty: Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n-        Some(debug) => implements_trait(cx, ty, debug, &[], None),\n+        Some(debug) => implements_trait(cx, ty, debug, &[]),\n         None => false,\n     }\n }"}, {"sha": "fe19a82a12d74975d2b8c7f142a2d3194731e90e", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -455,13 +455,13 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     // *arg impls PartialEq<other>\n     if !arg_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty], None))\n+        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty]))\n         // arg impls PartialEq<*other>\n         && !other_ty\n         .builtin_deref(true, ty::LvaluePreference::NoPreference)\n-        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty], None))\n+        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty]))\n         // arg impls PartialEq<other>\n-        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty], None) {\n+        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty]) {\n         return;\n     }\n \n@@ -514,13 +514,11 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(id) |\n-        def::Def::Upvar(id, _, _) => {\n-            if let Some(span) = cx.tcx.hir.span_if_local(id) {\n-                !in_macro(span)\n-            } else {\n-                true\n-            }\n+        def::Def::Local(def_id) |\n+        def::Def::Upvar(def_id, _, _) => {\n+            let id = cx.tcx.hir.as_local_node_id(def_id)\n+                .expect(\"local variables should be found in the same crate\");\n+            !in_macro(cx.tcx.hir.span(id))\n         },\n         _ => false,\n     }"}, {"sha": "fc3107c3068d8cee621786a4be06734591e428e2", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TyRef};\n+use rustc::ty;\n use utils::{higher, in_external_macro, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                           MUT_MUT,\n                           expr.span,\n                           \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n+            } else if let ty::TyRef(_, ty::TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n                           expr.span,"}, {"sha": "034e49a016c09a1ed08da904bf36d984ac2b6357", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TypeVariants, TyS};\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc::hir::*;\n use utils::span_lint;\n@@ -55,15 +55,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     }\n }\n \n-fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS, name: &str) {\n+fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: Ty, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, fn_type) |\n-        TypeVariants::TyFnPtr(fn_type) => {\n+        ty::TyFnDef(_, _, fn_type) |\n+        ty::TyFnPtr(fn_type) => {\n             let parameters = fn_type.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n-                    TypeVariants::TyRawPtr(TypeAndMut { mutbl: MutImmutable, .. }) => {\n+                    ty::TyRef(_, ty::TypeAndMut { mutbl: MutImmutable, .. }) |\n+                    ty::TyRawPtr(ty::TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,"}, {"sha": "085067935a09d3df4daee209d3bfcf555a77d391", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n use utils::{match_type, paths, span_lint};\n@@ -59,12 +59,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n         let ty = cx.tables.expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n-                let mutex_param = &subst.type_at(0).sty;\n+                let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n                                        behaviour and not the internal type, consider using Mutex<()>.\",\n                                       atomic_name);\n-                    match *mutex_param {\n+                    match mutex_param.sty {\n                         ty::TyUint(t) if t != ast::UintTy::Us => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::TyInt(t) if t != ast::IntTy::Is => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -75,8 +75,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: &ty::TypeVariants) -> Option<(&'static str)> {\n-    match *ty {\n+fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+    match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),\n         ty::TyInt(_) => Some(\"AtomicIsize\"),"}, {"sha": "fda67f3202d5ff144e25f5a302fa0084891959f1", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -82,21 +82,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n \n         let preds: Vec<ty::Predicate> = {\n-            let parameter_env = cx.tcx.param_env(fn_def_id);\n-            traits::elaborate_predicates(cx.tcx, parameter_env.caller_bounds.to_vec())\n+            traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n                 .filter(|p| !p.is_global())\n                 .collect()\n         };\n \n         // Collect moved variables and spans which will need dereferencings from the function body.\n         let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n-            cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n-                let param_env = cx.tcx.param_env(fn_def_id);\n-                let region_maps = &cx.tcx.region_maps(fn_def_id);\n-                euv::ExprUseVisitor::new(&mut ctx, region_maps, &infcx, param_env)\n-                    .consume_body(body);\n-            });\n+            let region_maps = &cx.tcx.region_maps(fn_def_id);\n+            euv::ExprUseVisitor::new(&mut ctx, cx.tcx, cx.param_env, region_maps, cx.tables)\n+                .consume_body(body);\n             ctx\n         };\n \n@@ -119,9 +115,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             if_let_chain! {[\n                 !is_self(arg),\n                 !ty.is_mutable_pointer(),\n-                !is_copy(cx, ty, fn_def_id),\n-                !implements_trait(cx, ty, fn_trait, &[], Some(node_id)),\n-                !implements_trait(cx, ty, asref_trait, &[], Some(node_id)),\n+                !is_copy(cx, ty),\n+                !implements_trait(cx, ty, fn_trait, &[]),\n+                !implements_trait(cx, ty, asref_trait, &[]),\n                 !implements_borrow_trait,\n \n                 let PatKind::Binding(mode, defid, ..) = arg.pat.node,\n@@ -190,7 +186,7 @@ struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     spans_need_deref: HashMap<DefId, HashSet<Span>>,\n }\n \n-impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n         MovedVariablesCtxt {\n             cx: cx,\n@@ -199,7 +195,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt) {\n+    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -210,7 +206,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }}\n     }\n \n-    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt) {\n+    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -262,7 +258,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'gcx> {\n+impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n     fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);"}, {"sha": "da6f635e34ef74408a23945e0d3ffed0c2775773", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty::TyAdt;\n+use rustc::ty;\n use rustc::hir::{Expr, ExprStruct};\n use utils::span_lint;\n \n@@ -34,7 +34,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TyAdt(def, _) = ty.sty {\n+            if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,\n                               NEEDLESS_UPDATE,"}, {"sha": "34f467184f3b9ed4cd865bdba2eee9db28bc16a0", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::intravisit::FnKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -108,15 +108,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                 // can't be implemented by default\n                 return;\n             }\n-            let def_id = cx.tcx.hir.local_def_id(id);\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n                 if_let_chain!{[\n-                    self_ty.walk_shallow().next().is_none(), // implements_trait does not work with generics\n-                    same_tys(cx, self_ty, return_ty(cx, id), def_id),\n+                    same_tys(cx, self_ty, return_ty(cx, id)),\n                     let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n-                    !implements_trait(cx, self_ty, default_trait_id, &[], None)\n+                    !implements_trait(cx, self_ty, default_trait_id, &[])\n                 ], {\n                     if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n                         span_lint_and_then(cx,\n@@ -152,16 +150,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n+fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n     match ty.sty {\n         ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n-                if !implements_trait(cx, f_ty, default_trait_id, &[], None) {\n+                if !implements_trait(cx, f_ty, default_trait_id, &[]) {\n                     return None;\n                 }\n             }\n-            cx.tcx.hir.span_if_local(adt_def.did)\n+            Some(cx.tcx.def_span(adt_def.did))\n         },\n         _ => None,\n     }"}, {"sha": "ea79a77877a0ecb61a7ffac19a59f9a5a1c8110b", "filename": "clippy_lints/src/should_assert_eq.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fshould_assert_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshould_assert_eq.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -49,10 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ShouldAssertEq {\n             let ty1 = cx.tables.expr_ty(expr1);\n             let ty2 = cx.tables.expr_ty(expr2);\n \n-            let parent = cx.tcx.hir.get_parent(e.id);\n-\n-            if implements_trait(cx, ty1, debug_trait, &[], Some(parent)) &&\n-                implements_trait(cx, ty2, debug_trait, &[], Some(parent)) {\n+            if implements_trait(cx, ty1, debug_trait, &[]) &&\n+                implements_trait(cx, ty2, debug_trait, &[]) {\n                 span_lint(cx, SHOULD_ASSERT_EQ, e.span, &format!(\"use `{}{}` for better reporting\", debug, sugg));\n             }\n         }}"}, {"sha": "1d67e06f811828d4386fbb99a40e5cb24d494292", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n@@ -101,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n                         },\n-                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => {\n+                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -116,8 +115,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                                })\n                         },\n-                        (&ty::TyInt(_), &TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &TyRawPtr(_)) => {\n+                        (&ty::TyInt(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -128,32 +127,32 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                                       arg.as_ty(&to_ty.to_string()).to_string());\n                                                })\n                         },\n-                        (&ty::TyFloat(_), &TyRef(..)) |\n-                        (&ty::TyFloat(_), &TyRawPtr(_)) |\n-                        (&ty::TyChar, &TyRef(..)) |\n-                        (&ty::TyChar, &TyRawPtr(_)) => {\n+                        (&ty::TyFloat(_), &ty::TyRef(..)) |\n+                        (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyChar, &ty::TyRef(..)) |\n+                        (&ty::TyChar, &ty::TyRawPtr(_)) => {\n                             span_lint(cx,\n                                       WRONG_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a `{}` to a pointer\", from_ty))\n                         },\n-                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => {\n+                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => {\n                             span_lint_and_then(cx,\n                                                TRANSMUTE_PTR_TO_REF,\n                                                e.span,\n@@ -189,7 +188,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_let_chain!{[\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,"}, {"sha": "ce8b8c40555a8e50f4790a3c27acf9ac2a7773ce", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,8 +1,9 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n@@ -106,7 +107,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     }\n }\n \n-fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n+fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n@@ -196,8 +197,7 @@ declare_lint! {\n \n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n-        let bindtype = &cx.tables.pat_ty(&local.pat).sty;\n-        match *bindtype {\n+        match cx.tables.pat_ty(&local.pat).sty {\n             ty::TyTuple(slice, _) if slice.is_empty() => {\n                 if in_external_macro(cx, decl.span) || in_macro(local.pat.span) {\n                     return;\n@@ -267,8 +267,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                let sty = &cx.tables.expr_ty(left).sty;\n-                match *sty {\n+                match cx.tables.expr_ty(left).sty {\n                     ty::TyTuple(slice, _) if slice.is_empty() => {\n                         let result = match op {\n                             BiEq | BiLe | BiGe => \"true\",\n@@ -398,7 +397,7 @@ declare_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n+fn int_ty_to_nbits(typ: Ty) -> usize {\n     let n = match typ.sty {\n         ty::TyInt(i) => 4 << (i as usize),\n         ty::TyUint(u) => 4 << (u as usize),\n@@ -412,15 +411,15 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n     }\n }\n \n-fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n+fn is_isize_or_usize(typ: Ty) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Is) |\n         ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -453,7 +452,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -693,7 +692,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -724,7 +723,7 @@ struct TypeComplexityVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n@@ -909,9 +908,9 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n-    let ty = &cx.tables.expr_ty(expr).sty;\n+    let ty = cx.tables.expr_ty(expr);\n \n-    match *ty {\n+    match ty.sty {\n         ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n         _ => return None,\n     };\n@@ -921,7 +920,7 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         Err(_) => return None,\n     };\n \n-    let which = match (ty, cv) {\n+    let which = match (&ty.sty, cv) {\n         (&ty::TyBool, Bool(false)) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MIN)))) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is64(::std::i64::MIN)))) |\n@@ -1070,7 +1069,6 @@ impl Ord for FullInt {\n \n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n-    use rustc::ty::TypeVariants::{TyInt, TyUint};\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n@@ -1082,7 +1080,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n             return None;\n         }\n         match pre_cast_ty.sty {\n-            TyInt(int_ty) => {\n+            ty::TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n                     IntTy::I16 => (FullInt::S(i16::min_value() as i128), FullInt::S(i16::max_value() as i128)),\n@@ -1092,7 +1090,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n                 })\n             },\n-            TyUint(uint_ty) => {\n+            ty::TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u8::min_value() as u128), FullInt::U(u8::max_value() as u128)),\n                     UintTy::U16 => (FullInt::U(u16::min_value() as u128), FullInt::U(u16::max_value() as u128)),"}, {"sha": "5820f600434883a74962746d2d596cad202be9ca", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "previous_filename": "clippy_lints/src/utils/hir.rs"}, {"sha": "34c514360b68036d1eea2abd827e52b18c9e9875", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 25, "deletions": 39, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,14 +1,13 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n-use rustc::traits::Reveal;\n use rustc::traits;\n-use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n@@ -25,12 +24,12 @@ use syntax::symbol::keywords;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n-mod hir;\n+mod hir_utils;\n pub mod paths;\n pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n-pub use self::hir::{SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -148,7 +147,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -174,7 +173,7 @@ pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n@@ -310,22 +309,14 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[ty::Ty<'tcx>],\n-    parent_node_id: Option<NodeId>\n+    ty_params: &[Ty<'tcx>]\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let param_env = if let Some(id) = parent_node_id {\n-        let def_id = cx.tcx.hir.body_owner_def_id(BodyId { node_id: id });\n-        cx.tcx.param_env(def_id).reveal_all()\n-    } else {\n-        ty::ParamEnv::empty(Reveal::All)\n-    };\n-    cx.tcx.infer_ctxt(()).enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(\n-            param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n-\n+    let obligation = cx.tcx.predicate_for_trait_def(\n+        cx.param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n }\n@@ -591,16 +582,16 @@ pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(S\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n+pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n \n /// Return the base type for references and raw pointers, and count reference depth.\n-pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n-    fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n+    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n         match ty.sty {\n             ty::TyRef(_, ref tm) => inner(tm.ty, depth + 1),\n             _ => (ty, depth),\n@@ -764,7 +755,7 @@ pub fn camel_case_from(s: &str) -> usize {\n }\n \n /// Convenience function to get the return type of a function\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::Ty<'tcx> {\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n     let ret_ty = cx.tcx.type_of(fn_def_id).fn_sig().output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n@@ -775,29 +766,25 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n // not for type parameters.\n pub fn same_tys<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    a: ty::Ty<'tcx>,\n-    b: ty::Ty<'tcx>,\n-    parameter_item: DefId\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>\n ) -> bool {\n-    let param_env = cx.tcx.param_env(parameter_item).reveal_all();\n-    cx.tcx.infer_ctxt(()).enter(|infcx| {\n-        infcx.can_eq(param_env, a, b).is_ok()\n+    cx.tcx.infer_ctxt().enter(|infcx| {\n+        infcx.can_eq(cx.param_env, a, b).is_ok()\n     })\n }\n \n /// Return whether the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n+pub fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyFnDef(_, _, f) |\n         ty::TyFnPtr(f) => f.unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n \n-pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: DefId) -> bool {\n-    let substs = Substs::identity_for_item(cx.tcx, env);\n-    let env = cx.tcx.param_env(env);\n-    !ty.subst(cx.tcx, substs).moves_by_default(cx.tcx.global_tcx(), env, DUMMY_SP)\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+    !ty.moves_by_default(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n /// Return whether a pattern is refutable.\n@@ -899,7 +886,7 @@ pub fn is_self(slf: &Arg) -> bool {\n     }\n }\n \n-pub fn is_self_ty(slf: &Ty) -> bool {\n+pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_let_chain! {[\n         let TyPath(ref qp) = slf.node,\n         let QPath::Resolved(None, ref path) = *qp,\n@@ -958,7 +945,6 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     None\n }\n \n-pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n-    ty.layout(cx.tcx, ty::ParamEnv::empty(Reveal::All))\n-      .ok().map(|layout| layout.size(cx.tcx).bytes())\n+pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u64> {\n+    ty.layout(cx.tcx, cx.param_env).ok().map(|layout| layout.size(cx.tcx).bytes())\n }"}, {"sha": "3c672b22ee606b6011def88d1b84c743d908ed65", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n@@ -35,8 +35,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let ty::TypeVariants::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n-            let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n+            let ty::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n+            let ty::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n             let Some(vec_args) = higher::vec_macro(cx, addressee),\n         ], {\n@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain!{[\n             let Some((_, arg, _)) = higher::for_loop(expr),\n             let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)), cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(expr.id))),\n+            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg))),\n         ], {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = arg.span.ctxt.outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n@@ -88,7 +88,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: ty::Ty) -> ty::Ty {\n+fn vec_type(ty: Ty) -> Ty {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}, {"sha": "8e399b90d9d2244a4775a70387e3d5c590a38b25", "filename": "clippy_tests/examples/assign_ops.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_tests%2Fexamples%2Fassign_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_tests%2Fexamples%2Fassign_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fassign_ops.stderr?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -166,6 +166,14 @@ error: manual implementation of an assign operation\n    |\n    = note: `-D assign-op-pattern` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> assign_ops.rs:40:5\n+   |\n+40 |     s = s + \"bla\";\n+   |     ^^^^^^^^^^^^^ help: replace it with `s += \"bla\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: aborting due to previous error(s)\n \n error: Could not compile `clippy_tests`."}, {"sha": "2b0e4dcdf1b34ffd951de509b7735579d6db9504", "filename": "clippy_tests/examples/strings.stderr", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_tests%2Fexamples%2Fstrings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1/clippy_tests%2Fexamples%2Fstrings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fstrings.stderr?ref=7535afc0fa9cec38f0fdd3a9deafb44fb3e5fcf1", "patch": "@@ -1,3 +1,11 @@\n+error: manual implementation of an assign operation\n+  --> strings.rs:10:9\n+   |\n+10 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:10:13\n    |\n@@ -22,6 +30,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:24:9\n+   |\n+24 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you assigned the result of adding something to this string. Consider using `String::push_str()` instead\n   --> strings.rs:38:9\n    |\n@@ -30,6 +46,14 @@ error: you assigned the result of adding something to this string. Consider usin\n    |\n    = note: `-D string-add-assign` implied by `-D warnings`\n \n+error: manual implementation of an assign operation\n+  --> strings.rs:38:9\n+   |\n+38 |         x = x + \".\";\n+   |         ^^^^^^^^^^^ help: replace it with `x += \".\"`\n+   |\n+   = note: `-D assign-op-pattern` implied by `-D warnings`\n+\n error: you added something to a string. Consider using `String::push_str()` instead\n   --> strings.rs:42:13\n    |"}]}