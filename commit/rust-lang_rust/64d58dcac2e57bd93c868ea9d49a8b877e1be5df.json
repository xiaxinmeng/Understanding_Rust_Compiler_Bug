{"sha": "64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZDU4ZGNhYzJlNTdiZDkzYzg2OGVhOWQ0OWE4Yjg3N2UxYmU1ZGY=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:02Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:07:02Z"}, "message": "rollup merge of #19454: nodakai/libstd-reap-failed-child\n\nAfter the library successfully called `fork(2)`, the child does several\nsetup works such as setting UID, GID and current directory before it\ncalls `exec(2)`.  When those setup works failed, the child exits but the\nparent didn't call `waitpid(2)` and left it as a zombie.\n\nThis patch also add several sanity checks.  They shouldn't make any\nnoticeable impact to runtime performance.\n\nThe new test case in `libstd/io/process.rs` calls the ps command to check\nif the new code can really reap a zombie.\nThe output of `ps -A -o pid,sid,command` should look like this:\n\n```\n  PID   SID COMMAND\n    1     1 /sbin/init\n    2     0 [kthreadd]\n    3     0 [ksoftirqd/0]\n...\n12562  9237 ./spawn-failure\n12563  9237 [spawn-failure] <defunct>\n12564  9237 [spawn-failure] <defunct>\n...\n12592  9237 [spawn-failure] <defunct>\n12593  9237 ps -A -o pid,sid,command\n12884 12884 /bin/zsh\n12922 12922 /bin/zsh\n...\n```\n\nwhere `./spawn-failure` is my test program which intentionally leaves many\nzombies.  Filtering the output with the \"SID\" (session ID) column is\na quick way to tell if a process (zombie) was spawned by my own test\nprogram.  Then the number of \"defunct\" lines is the number of zombie\nchildren.", "tree": {"sha": "d25b9a9ee5e18c50136274b5046459d6251cdf91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d25b9a9ee5e18c50136274b5046459d6251cdf91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "html_url": "https://github.com/rust-lang/rust/commit/64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64d58dcac2e57bd93c868ea9d49a8b877e1be5df/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea8bb5d18d6bfff644631a1692eea1e429566298", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea8bb5d18d6bfff644631a1692eea1e429566298", "html_url": "https://github.com/rust-lang/rust/commit/ea8bb5d18d6bfff644631a1692eea1e429566298"}, {"sha": "74fb798a200dc82cf5b4a18065e3ea565229adc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fb798a200dc82cf5b4a18065e3ea565229adc3", "html_url": "https://github.com/rust-lang/rust/commit/74fb798a200dc82cf5b4a18065e3ea565229adc3"}], "stats": {"total": 122, "additions": 112, "deletions": 10}, "files": [{"sha": "7dde19a64762ab37dac09a8591d113ce2553a62b", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/64d58dcac2e57bd93c868ea9d49a8b877e1be5df/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d58dcac2e57bd93c868ea9d49a8b877e1be5df/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "patch": "@@ -11,7 +11,7 @@ use self::Req::*;\n \n use libc::{mod, pid_t, c_void, c_int};\n use c_str::CString;\n-use io::{mod, IoResult, IoError};\n+use io::{mod, IoResult, IoError, EndOfFile};\n use mem;\n use os;\n use ptr;\n@@ -39,6 +39,8 @@ enum Req {\n     NewChild(libc::pid_t, Sender<ProcessExit>, u64),\n }\n \n+const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n impl Process {\n     pub fn id(&self) -> pid_t {\n         self.pid\n@@ -106,18 +108,36 @@ impl Process {\n                 if pid < 0 {\n                     return Err(super::last_error())\n                 } else if pid > 0 {\n+                    #[inline]\n+                    fn combine(arr: &[u8]) -> i32 {\n+                        let a = arr[0] as u32;\n+                        let b = arr[1] as u32;\n+                        let c = arr[2] as u32;\n+                        let d = arr[3] as u32;\n+\n+                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+                    }\n+\n+                    let p = Process{ pid: pid };\n                     drop(output);\n-                    let mut bytes = [0, ..4];\n+                    let mut bytes = [0, ..8];\n                     return match input.read(&mut bytes) {\n-                        Ok(4) => {\n-                            let errno = (bytes[0] as i32 << 24) |\n-                                        (bytes[1] as i32 << 16) |\n-                                        (bytes[2] as i32 <<  8) |\n-                                        (bytes[3] as i32 <<  0);\n+                        Ok(8) => {\n+                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(bytes.slice(4, 8)),\n+                                \"Validation on the CLOEXEC pipe failed: {}\", bytes);\n+                            let errno = combine(bytes.slice(0, 4));\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n                             Err(super::decode_error(errno))\n                         }\n-                        Err(..) => Ok(Process { pid: pid }),\n-                        Ok(..) => panic!(\"short read on the cloexec pipe\"),\n+                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n+                        Err(e) => {\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"the CLOEXEC pipe failed: {}\", e)\n+                        },\n+                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"short read on the CLOEXEC pipe\")\n+                        }\n                     };\n                 }\n \n@@ -154,13 +174,16 @@ impl Process {\n                 let _ = libc::close(input.fd());\n \n                 fn fail(output: &mut FileDesc) -> ! {\n-                    let errno = sys::os::errno();\n+                    let errno = sys::os::errno() as u32;\n                     let bytes = [\n                         (errno >> 24) as u8,\n                         (errno >> 16) as u8,\n                         (errno >>  8) as u8,\n                         (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n                     ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic\n                     assert!(output.write(&bytes).is_ok());\n                     unsafe { libc::_exit(1) }\n                 }"}, {"sha": "17dfb9e331945ef0c93009334c9f5f73dbc46e93", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/64d58dcac2e57bd93c868ea9d49a8b877e1be5df/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64d58dcac2e57bd93c868ea9d49a8b877e1be5df/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=64d58dcac2e57bd93c868ea9d49a8b877e1be5df", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+extern crate libc;\n+\n+use std::io::process::Command;\n+use std::iter::IteratorExt;\n+\n+use libc::funcs::posix88::unistd;\n+\n+\n+// \"ps -A -o pid,sid,command\" with GNU ps should output something like this:\n+//   PID   SID COMMAND\n+//     1     1 /sbin/init\n+//     2     0 [kthreadd]\n+//     3     0 [ksoftirqd/0]\n+// ...\n+// 12562  9237 ./spawn-failure\n+// 12563  9237 [spawn-failure] <defunct>\n+// 12564  9237 [spawn-failure] <defunct>\n+// ...\n+// 12592  9237 [spawn-failure] <defunct>\n+// 12593  9237 ps -A -o pid,sid,command\n+// 12884 12884 /bin/zsh\n+// 12922 12922 /bin/zsh\n+// ...\n+\n+#[cfg(unix)]\n+fn find_zombies() {\n+    // http://man.freebsd.org/ps(1)\n+    // http://man7.org/linux/man-pages/man1/ps.1.html\n+    #[cfg(not(target_os = \"macos\"))]\n+    const FIELDS: &'static str = \"pid,sid,command\";\n+\n+    // https://developer.apple.com/library/mac/documentation/Darwin/\n+    // Reference/ManPages/man1/ps.1.html\n+    #[cfg(target_os = \"macos\")]\n+    const FIELDS: &'static str = \"pid,sess,command\";\n+\n+    let my_sid = unsafe { unistd::getsid(0) };\n+\n+    let ps_cmd_output = Command::new(\"ps\").args(&[\"-A\", \"-o\", FIELDS]).output().unwrap();\n+    let ps_output = String::from_utf8_lossy(ps_cmd_output.output.as_slice());\n+\n+    let found = ps_output.split('\\n').enumerate().any(|(line_no, line)|\n+        0 < line_no && 0 < line.len() &&\n+        my_sid == from_str(line.split(' ').filter(|w| 0 < w.len()).nth(1)\n+            .expect(\"1st column should be Session ID\")\n+            ).expect(\"Session ID string into integer\") &&\n+        line.contains(\"defunct\") && {\n+            println!(\"Zombie child {}\", line);\n+            true\n+        }\n+    );\n+\n+    assert!( ! found, \"Found at least one zombie child\");\n+}\n+\n+#[cfg(windows)]\n+fn find_zombies() { }\n+\n+fn main() {\n+    let too_long = format!(\"/NoSuchCommand{:0300}\", 0u8);\n+\n+    for _ in range(0u32, 100) {\n+        let invalid = Command::new(too_long.as_slice()).spawn();\n+        assert!(invalid.is_err());\n+    }\n+\n+    find_zombies();\n+}"}]}