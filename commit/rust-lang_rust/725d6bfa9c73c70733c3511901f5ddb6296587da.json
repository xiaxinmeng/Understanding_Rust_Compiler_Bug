{"sha": "725d6bfa9c73c70733c3511901f5ddb6296587da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNWQ2YmZhOWM3M2M3MDczM2MzNTExOTAxZjVkZGI2Mjk2NTg3ZGE=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-16T19:39:06Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-23T21:39:50Z"}, "message": "Move error up, early return", "tree": {"sha": "0e11aa4b944e3b3a3e81224ae9f6619b36212361", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e11aa4b944e3b3a3e81224ae9f6619b36212361"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/725d6bfa9c73c70733c3511901f5ddb6296587da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/725d6bfa9c73c70733c3511901f5ddb6296587da", "html_url": "https://github.com/rust-lang/rust/commit/725d6bfa9c73c70733c3511901f5ddb6296587da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/725d6bfa9c73c70733c3511901f5ddb6296587da/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6da4ab4b8c7295ad44869ff31784619086c6642", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6da4ab4b8c7295ad44869ff31784619086c6642", "html_url": "https://github.com/rust-lang/rust/commit/d6da4ab4b8c7295ad44869ff31784619086c6642"}], "stats": {"total": 193, "additions": 98, "deletions": 95}, "files": [{"sha": "7ae378192a219fd97c8e08482fcba7aaa091f4ed", "filename": "src/shims/fs.rs", "status": "modified", "additions": 98, "deletions": 95, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/725d6bfa9c73c70733c3511901f5ddb6296587da/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/725d6bfa9c73c70733c3511901f5ddb6296587da/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=725d6bfa9c73c70733c3511901f5ddb6296587da", "patch": "@@ -871,60 +871,62 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let entry_ptr = this.force_ptr(this.read_scalar(entry_op)?.not_undef()?)?;\n         let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n \n-        if let Some(dir_iter) = this.machine.dir_handler.streams.get_mut(&dirp) {\n-            match dir_iter.next() {\n-                Some(Ok(dir_entry)) => {\n-                    // Write into entry, write pointer to result, return 0 on success.\n-                    // The name is written with write_os_str_to_c_str, while the rest of the\n-                    // dirent64 struct is written using write_packed_immediates.\n-\n-                    let name_offset = dirent64_layout.details.fields.offset(4);\n-                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n-\n-                    let name_fits = this.write_os_str_to_c_str(&dir_entry.file_name(), Scalar::Ptr(name_ptr), 256)?;\n-                    if !name_fits {\n-                        panic!(\"A directory entry had a name too large to fit in libc::dirent64\");\n-                    }\n+        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"The DIR pointer passed to readdir64_r did not come from opendir\")\n+        })?;\n+        match dir_iter.next() {\n+            Some(Ok(dir_entry)) => {\n+                // Write into entry, write pointer to result, return 0 on success.\n+                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // dirent64 struct is written using write_packed_immediates.\n+\n+                let name_offset = dirent64_layout.details.fields.offset(4);\n+                let name_ptr = entry_ptr.offset(name_offset, this)?;\n+\n+                let file_name = dir_entry.file_name();\n+                let name_fits = this.write_os_str_to_c_str(&file_name, Scalar::Ptr(name_ptr), 256)?;\n+                if !name_fits {\n+                    panic!(\"A directory entry had a name too large to fit in libc::dirent64\");\n+                }\n \n-                    let entry_place = this.deref_operand(entry_op)?;\n-                    let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n-                    let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n-                    let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n-                    let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n+                let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n+                let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n+                let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n \n-                    #[cfg(unix)]\n-                    let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n-                    #[cfg(not(unix))]\n-                    let ino = 0;\n+                #[cfg(unix)]\n+                let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n+                #[cfg(not(unix))]\n+                let ino = 0;\n \n-                    let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n+                let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n \n-                    let imms = [\n-                        immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n-                        immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n-                        immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n-                        immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n-                    ];\n-                    this.write_packed_immediates(entry_place, &imms)?;\n+                let imms = [\n+                    immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n+                    immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n+                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n+                ];\n+                this.write_packed_immediates(entry_place, &imms)?;\n \n-                    let result_place = this.deref_operand(result_op)?;\n-                    this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n+                let result_place = this.deref_operand(result_op)?;\n+                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n \n-                    Ok(0)\n-                }\n+                Ok(0)\n+            }\n+            None => {\n+                // end of stream: return 0, assign *result=NULL\n+                this.write_null(this.deref_operand(result_op)?.into())?;\n+                Ok(0)\n+            }\n+            Some(Err(e)) => match e.raw_os_error() {\n+                // return positive error number on error\n+                Some(error) => Ok(error),\n                 None => {\n-                    // end of stream: return 0, assign *result=NULL\n-                    this.write_null(this.deref_operand(result_op)?.into())?;\n-                    Ok(0)\n-                }\n-                Some(Err(e)) => match e.raw_os_error() {\n-                    // return positive error number on error\n-                    Some(error) => Ok(error),\n-                    None => throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e),\n+                    throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e)\n                 }\n-            }\n-        } else {\n-            throw_unsup_format!(\"The DIR pointer passed to readdir64_r did not come from opendir\")\n+            },\n         }\n     }\n \n@@ -943,64 +945,65 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let entry_ptr = this.force_ptr(this.read_scalar(entry_op)?.not_undef()?)?;\n         let dirent_layout = this.libc_ty_layout(\"dirent\")?;\n \n-        if let Some(dir_iter) = this.machine.dir_handler.streams.get_mut(&dirp) {\n-            match dir_iter.next() {\n-                Some(Ok(dir_entry)) => {\n-                    // Write into entry, write pointer to result, return 0 on success.\n-                    // The name is written with write_os_str_to_c_str, while the rest of the\n-                    // dirent struct is written using write_packed_Immediates.\n-\n-                    let name_offset = dirent_layout.details.fields.offset(5);\n-                    let name_ptr = entry_ptr.offset(name_offset, this)?;\n+        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"The DIR pointer passed to readdir_r did not come from opendir\")\n+        })?;\n+        match dir_iter.next() {\n+            Some(Ok(dir_entry)) => {\n+                // Write into entry, write pointer to result, return 0 on success.\n+                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // dirent struct is written using write_packed_Immediates.\n+\n+                let name_offset = dirent_layout.details.fields.offset(5);\n+                let name_ptr = entry_ptr.offset(name_offset, this)?;\n+\n+                let file_name = dir_entry.file_name();\n+                let name_fits = this.write_os_str_to_c_str(&file_name, Scalar::Ptr(name_ptr), 1024)?;\n+                if !name_fits {\n+                    panic!(\"A directory entry had a name too large to fit in libc::dirent\");\n+                }\n \n-                    let file_name = dir_entry.file_name();\n-                    let name_fits = this.write_os_str_to_c_str(&file_name, Scalar::Ptr(name_ptr), 1024)?;\n-                    if !name_fits {\n-                        panic!(\"A directory entry had a name too large to fit in libc::dirent\");\n-                    }\n+                let entry_place = this.deref_operand(entry_op)?;\n+                let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n+                let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n+                let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n+                let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n \n-                    let entry_place = this.deref_operand(entry_op)?;\n-                    let ino_t_layout = this.libc_ty_layout(\"ino_t\")?;\n-                    let off_t_layout = this.libc_ty_layout(\"off_t\")?;\n-                    let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n-                    let c_uchar_layout = this.libc_ty_layout(\"c_uchar\")?;\n+                #[cfg(unix)]\n+                let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n+                #[cfg(not(unix))]\n+                let ino = 0;\n \n-                    #[cfg(unix)]\n-                    let ino = std::os::unix::fs::DirEntryExt::ino(&dir_entry);\n-                    #[cfg(not(unix))]\n-                    let ino = 0;\n+                let file_name_len = this.os_str_length_as_c_str(&file_name)? as u128;\n \n-                    let file_name_len = this.os_str_length_as_c_str(&file_name)? as u128;\n+                let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n \n-                    let file_type = this.file_type_to_d_type(dir_entry.file_type())? as u128;\n+                let imms = [\n+                    immty_from_uint_checked(ino, ino_t_layout)?, // d_ino\n+                    immty_from_uint_checked(0u128, off_t_layout)?, // d_seekoff\n+                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n+                    immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n+                ];\n+                this.write_packed_immediates(entry_place, &imms)?;\n \n-                    let imms = [\n-                        immty_from_uint_checked(ino, ino_t_layout)?, // d_ino\n-                        immty_from_uint_checked(0u128, off_t_layout)?, // d_seekoff\n-                        immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n-                        immty_from_uint_checked(file_name_len, c_ushort_layout)?, // d_namlen\n-                        immty_from_uint_checked(file_type, c_uchar_layout)?, // d_type\n-                    ];\n-                    this.write_packed_immediates(entry_place, &imms)?;\n+                let result_place = this.deref_operand(result_op)?;\n+                this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n \n-                    let result_place = this.deref_operand(result_op)?;\n-                    this.write_scalar(this.read_scalar(entry_op)?, result_place.into())?;\n-\n-                    Ok(0)\n-                }\n+                Ok(0)\n+            }\n+            None => {\n+                // end of stream: return 0, assign *result=NULL\n+                this.write_null(this.deref_operand(result_op)?.into())?;\n+                Ok(0)\n+            }\n+            Some(Err(e)) => match e.raw_os_error() {\n+                // return positive error number on error\n+                Some(error) => Ok(error),\n                 None => {\n-                    // end of stream: return 0, assign *result=NULL\n-                    this.write_null(this.deref_operand(result_op)?.into())?;\n-                    Ok(0)\n+                    throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e)\n                 }\n-                Some(Err(e)) => match e.raw_os_error() {\n-                    // return positive error number on error\n-                    Some(error) => Ok(error),\n-                    None => throw_unsup_format!(\"The error {} couldn't be converted to a return value\", e),\n-                }\n-            }\n-        } else {\n-            throw_unsup_format!(\"The DIR pointer passed to readdir_r did not come from opendir\")\n+            },\n         }\n     }\n "}]}