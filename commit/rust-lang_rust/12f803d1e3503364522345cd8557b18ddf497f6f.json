{"sha": "12f803d1e3503364522345cd8557b18ddf497f6f", "node_id": "C_kwDOAAsO6NoAKDEyZjgwM2QxZTM1MDMzNjQ1MjIzNDVjZDg1NTdiMThkZGY0OTdmNmY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-07T14:38:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-07T14:38:46Z"}, "message": "Merge #11925\n\n11925: internal: Add and use `HirFormatter::write_{str,char}` r=Veykril a=lnicola\n\nSaves slightly over 3 KB of `text`, but comparing the total with that from two weeks ago in #11776, this is a losing battle (we're 951 KB larger).\r\n\r\n```\r\n   text\t   data\t    bss\t    dec\t    hex\tfilename\r\n24693512\t1542704\t   4424\t26240640\t1906680\trust-analyzer-baseline\r\n24690216\t1542112\t   4424\t26236752\t1905750\trust-analyzer-pr\r\n```\r\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "51a49b04b9c92a6457394e4ee44724e3235f4036", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51a49b04b9c92a6457394e4ee44724e3235f4036"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12f803d1e3503364522345cd8557b18ddf497f6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiTvd2CRBK7hj4Ov3rIwAAHD0IAGb59UHZN+Jc01g9H/6JdDYX\nQiBO+sMGMe2wTE6/y05nwhz+SVvqFpcnmQRze3MLkvSPC9K/wohBwoKTGhexycul\na4/LEE3yLQ+NRLslTZylT8UftdnTtDi6KLKTwEOQ07O0gDGigW5LiKaISAz0Lgib\nfkb0qadNIucYIJIzf2QyyOwHRowu4zu4ARRL2IGlzHvxcV6TXerN/7KbxMOU+iDp\n0Zukejp9QCQkfD4qk8YtZGh1IUyoAsWhEj2t4YstNysjNAbh6rv1r8ZW1nyiQrBd\nhgvBk/rhu6Pmc0fAu/gSG6HPv0p9hiWqgm2Z/oY8MqqKqXDCGtAt+aHDwdU9cDk=\n=s8GI\n-----END PGP SIGNATURE-----\n", "payload": "tree 51a49b04b9c92a6457394e4ee44724e3235f4036\nparent c9d1105a689cd0ad864cc1ad0b1aa23a32cedc88\nparent bd570903b07f798ed8e3b838f18eda18802c6175\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649342326 +0000\ncommitter GitHub <noreply@github.com> 1649342326 +0000\n\nMerge #11925\n\n11925: internal: Add and use `HirFormatter::write_{str,char}` r=Veykril a=lnicola\n\nSaves slightly over 3 KB of `text`, but comparing the total with that from two weeks ago in #11776, this is a losing battle (we're 951 KB larger).\r\n\r\n```\r\n   text\t   data\t    bss\t    dec\t    hex\tfilename\r\n24693512\t1542704\t   4424\t26240640\t1906680\trust-analyzer-baseline\r\n24690216\t1542112\t   4424\t26236752\t1905750\trust-analyzer-pr\r\n```\r\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12f803d1e3503364522345cd8557b18ddf497f6f", "html_url": "https://github.com/rust-lang/rust/commit/12f803d1e3503364522345cd8557b18ddf497f6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12f803d1e3503364522345cd8557b18ddf497f6f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9d1105a689cd0ad864cc1ad0b1aa23a32cedc88", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d1105a689cd0ad864cc1ad0b1aa23a32cedc88", "html_url": "https://github.com/rust-lang/rust/commit/c9d1105a689cd0ad864cc1ad0b1aa23a32cedc88"}, {"sha": "bd570903b07f798ed8e3b838f18eda18802c6175", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd570903b07f798ed8e3b838f18eda18802c6175", "html_url": "https://github.com/rust-lang/rust/commit/bd570903b07f798ed8e3b838f18eda18802c6175"}], "stats": {"total": 119, "additions": 64, "deletions": 55}, "files": [{"sha": "c1efab09183ecc31403e5565b7d510aa0e5281ed", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/12f803d1e3503364522345cd8557b18ddf497f6f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f803d1e3503364522345cd8557b18ddf497f6f/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=12f803d1e3503364522345cd8557b18ddf497f6f", "patch": "@@ -27,16 +27,16 @@ impl HirDisplay for Function {\n         let data = f.db.function_data(self.id);\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         if data.is_default() {\n-            write!(f, \"default \")?;\n+            f.write_str(\"default \")?;\n         }\n         if data.is_const() {\n-            write!(f, \"const \")?;\n+            f.write_str(\"const \")?;\n         }\n         if data.is_async() {\n-            write!(f, \"async \")?;\n+            f.write_str(\"async \")?;\n         }\n         if data.is_unsafe() {\n-            write!(f, \"unsafe \")?;\n+            f.write_str(\"unsafe \")?;\n         }\n         if let Some(abi) = &data.abi {\n             // FIXME: String escape?\n@@ -46,31 +46,31 @@ impl HirDisplay for Function {\n \n         write_generic_params(GenericDefId::FunctionId(self.id), f)?;\n \n-        write!(f, \"(\")?;\n+        f.write_char('(')?;\n \n         let write_self_param = |ty: &TypeRef, f: &mut HirFormatter| match ty {\n-            TypeRef::Path(p) if p.is_self_type() => write!(f, \"self\"),\n+            TypeRef::Path(p) if p.is_self_type() => f.write_str(\"self\"),\n             TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n             {\n-                write!(f, \"&\")?;\n+                f.write_char('&')?;\n                 if let Some(lifetime) = lifetime {\n                     write!(f, \"{} \", lifetime.name)?;\n                 }\n                 if let hir_def::type_ref::Mutability::Mut = mut_ {\n-                    write!(f, \"mut \")?;\n+                    f.write_str(\"mut \")?;\n                 }\n-                write!(f, \"self\")\n+                f.write_str(\"self\")\n             }\n             _ => {\n-                write!(f, \"self: \")?;\n+                f.write_str(\"self: \")?;\n                 ty.hir_fmt(f)\n             }\n         };\n \n         let mut first = true;\n         for (name, type_ref) in &data.params {\n             if !first {\n-                write!(f, \", \")?;\n+                f.write_str(\", \")?;\n             } else {\n                 first = false;\n                 if data.has_self_param() {\n@@ -80,18 +80,18 @@ impl HirDisplay for Function {\n             }\n             match name {\n                 Some(name) => write!(f, \"{}: \", name)?,\n-                None => write!(f, \"_: \")?,\n+                None => f.write_str(\"_: \")?,\n             }\n             // FIXME: Use resolved `param.ty` or raw `type_ref`?\n             // The former will ignore lifetime arguments currently.\n             type_ref.hir_fmt(f)?;\n         }\n \n         if data.is_varargs() {\n-            write!(f, \", ...\")?;\n+            f.write_str(\", ...\")?;\n         }\n \n-        write!(f, \")\")?;\n+        f.write_char(')')?;\n \n         // `FunctionData::ret_type` will be `::core::future::Future<Output = ...>` for async fns.\n         // Use ugly pattern match to strip the Future trait.\n@@ -117,7 +117,7 @@ impl HirDisplay for Function {\n         match ret_type {\n             TypeRef::Tuple(tup) if tup.is_empty() => {}\n             ty => {\n-                write!(f, \" -> \")?;\n+                f.write_str(\" -> \")?;\n                 ty.hir_fmt(f)?;\n             }\n         }\n@@ -141,7 +141,7 @@ impl HirDisplay for Adt {\n impl HirDisplay for Struct {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n-        write!(f, \"struct \")?;\n+        f.write_str(\"struct \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n         let def_id = GenericDefId::AdtId(AdtId::StructId(self.id));\n         write_generic_params(def_id, f)?;\n@@ -153,7 +153,7 @@ impl HirDisplay for Struct {\n impl HirDisplay for Enum {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n-        write!(f, \"enum \")?;\n+        f.write_str(\"enum \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n         let def_id = GenericDefId::AdtId(AdtId::EnumId(self.id));\n         write_generic_params(def_id, f)?;\n@@ -165,7 +165,7 @@ impl HirDisplay for Enum {\n impl HirDisplay for Union {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n-        write!(f, \"union \")?;\n+        f.write_str(\"union \")?;\n         write!(f, \"{}\", self.name(f.db))?;\n         let def_id = GenericDefId::AdtId(AdtId::UnionId(self.id));\n         write_generic_params(def_id, f)?;\n@@ -189,34 +189,34 @@ impl HirDisplay for Variant {\n         match &*data {\n             VariantData::Unit => {}\n             VariantData::Tuple(fields) => {\n-                write!(f, \"(\")?;\n+                f.write_char('(')?;\n                 let mut first = true;\n                 for (_, field) in fields.iter() {\n                     if first {\n                         first = false;\n                     } else {\n-                        write!(f, \", \")?;\n+                        f.write_str(\", \")?;\n                     }\n                     // Enum variant fields must be pub.\n                     field.type_ref.hir_fmt(f)?;\n                 }\n-                write!(f, \")\")?;\n+                f.write_char(')')?;\n             }\n             VariantData::Record(fields) => {\n-                write!(f, \" {{\")?;\n+                f.write_str(\" {{\")?;\n                 let mut first = true;\n                 for (_, field) in fields.iter() {\n                     if first {\n                         first = false;\n-                        write!(f, \" \")?;\n+                        f.write_char(' ')?;\n                     } else {\n-                        write!(f, \", \")?;\n+                        f.write_str(\", \")?;\n                     }\n                     // Enum variant fields must be pub.\n                     write!(f, \"{}: \", field.name)?;\n                     field.type_ref.hir_fmt(f)?;\n                 }\n-                write!(f, \" }}\")?;\n+                f.write_str(\" }}\")?;\n             }\n         }\n         Ok(())\n@@ -301,15 +301,15 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n     {\n         return Ok(());\n     }\n-    write!(f, \"<\")?;\n+    f.write_char('<')?;\n \n     let mut first = true;\n     let mut delim = |f: &mut HirFormatter| {\n         if first {\n             first = false;\n             Ok(())\n         } else {\n-            write!(f, \", \")\n+            f.write_str(\", \")\n         }\n     };\n     for (_, lifetime) in params.lifetimes.iter() {\n@@ -326,7 +326,7 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n                     delim(f)?;\n                     write!(f, \"{}\", name)?;\n                     if let Some(default) = &ty.default {\n-                        write!(f, \" = \")?;\n+                        f.write_str(\" = \")?;\n                         default.hir_fmt(f)?;\n                     }\n                 }\n@@ -339,7 +339,7 @@ fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), H\n         }\n     }\n \n-    write!(f, \">\")?;\n+    f.write_char('>')?;\n     Ok(())\n }\n \n@@ -370,31 +370,30 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n         WherePredicateTypeTarget::TypeOrConstParam(id) => {\n             match &params.type_or_consts[*id].name() {\n                 Some(name) => write!(f, \"{}\", name),\n-                None => write!(f, \"{{unnamed}}\"),\n+                None => f.write_str(\"{{unnamed}}\"),\n             }\n         }\n     };\n \n-    write!(f, \"\\nwhere\")?;\n+    f.write_str(\"\\nwhere\")?;\n \n     for (pred_idx, pred) in params.where_predicates.iter().enumerate() {\n         let prev_pred =\n             if pred_idx == 0 { None } else { Some(&params.where_predicates[pred_idx - 1]) };\n \n-        let new_predicate = |f: &mut HirFormatter| {\n-            write!(f, \"{}\", if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" })\n-        };\n+        let new_predicate =\n+            |f: &mut HirFormatter| f.write_str(if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" });\n \n         match pred {\n             WherePredicate::TypeBound { target, .. } if is_unnamed_type_target(target) => {}\n             WherePredicate::TypeBound { target, bound } => {\n                 if matches!(prev_pred, Some(WherePredicate::TypeBound { target: target_, .. }) if target_ == target)\n                 {\n-                    write!(f, \" + \")?;\n+                    f.write_str(\" + \")?;\n                 } else {\n                     new_predicate(f)?;\n                     write_target(target, f)?;\n-                    write!(f, \": \")?;\n+                    f.write_str(\": \")?;\n                 }\n                 bound.hir_fmt(f)?;\n             }\n@@ -413,27 +412,27 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n                     Some(WherePredicate::ForLifetime { lifetimes: lifetimes_, target: target_, .. })\n                     if lifetimes_ == lifetimes && target_ == target,\n                 ) {\n-                    write!(f, \" + \")?;\n+                    f.write_str(\" + \")?;\n                 } else {\n                     new_predicate(f)?;\n-                    write!(f, \"for<\")?;\n+                    f.write_str(\"for<\")?;\n                     for (idx, lifetime) in lifetimes.iter().enumerate() {\n                         if idx != 0 {\n-                            write!(f, \", \")?;\n+                            f.write_str(\", \")?;\n                         }\n                         write!(f, \"{}\", lifetime)?;\n                     }\n-                    write!(f, \"> \")?;\n+                    f.write_str(\"> \")?;\n                     write_target(target, f)?;\n-                    write!(f, \": \")?;\n+                    f.write_str(\": \")?;\n                 }\n                 bound.hir_fmt(f)?;\n             }\n         }\n     }\n \n     // End of final predicate. There must be at least one predicate here.\n-    write!(f, \",\")?;\n+    f.write_char(',')?;\n \n     Ok(())\n }\n@@ -442,10 +441,10 @@ impl HirDisplay for Const {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.const_data(self.id);\n-        write!(f, \"const \")?;\n+        f.write_str(\"const \")?;\n         match &data.name {\n             Some(name) => write!(f, \"{}: \", name)?,\n-            None => write!(f, \"_: \")?,\n+            None => f.write_str(\"_: \")?,\n         }\n         data.type_ref.hir_fmt(f)?;\n         Ok(())\n@@ -456,9 +455,9 @@ impl HirDisplay for Static {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.static_data(self.id);\n-        write!(f, \"static \")?;\n+        f.write_str(\"static \")?;\n         if data.mutable {\n-            write!(f, \"mut \")?;\n+            f.write_str(\"mut \")?;\n         }\n         write!(f, \"{}: \", &data.name)?;\n         data.type_ref.hir_fmt(f)?;\n@@ -471,10 +470,10 @@ impl HirDisplay for Trait {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.trait_data(self.id);\n         if data.is_unsafe {\n-            write!(f, \"unsafe \")?;\n+            f.write_str(\"unsafe \")?;\n         }\n         if data.is_auto {\n-            write!(f, \"auto \")?;\n+            f.write_str(\"auto \")?;\n         }\n         write!(f, \"trait {}\", data.name)?;\n         let def_id = GenericDefId::TraitId(self.id);\n@@ -490,11 +489,11 @@ impl HirDisplay for TypeAlias {\n         let data = f.db.type_alias_data(self.id);\n         write!(f, \"type {}\", data.name)?;\n         if !data.bounds.is_empty() {\n-            write!(f, \": \")?;\n+            f.write_str(\": \")?;\n             f.write_joined(&data.bounds, \" + \")?;\n         }\n         if let Some(ty) = &data.type_ref {\n-            write!(f, \" = \")?;\n+            f.write_str(\" = \")?;\n             ty.hir_fmt(f)?;\n         }\n         Ok(())\n@@ -508,19 +507,19 @@ impl HirDisplay for Module {\n             Some(name) => write!(f, \"mod {}\", name),\n             None if self.is_crate_root(f.db) => match self.krate().display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {}\", name),\n-                None => write!(f, \"extern crate {{unknown}}\"),\n+                None => f.write_str(\"extern crate {{unknown}}\"),\n             },\n-            None => write!(f, \"mod {{unnamed}}\"),\n+            None => f.write_str(\"mod {{unnamed}}\"),\n         }\n     }\n }\n \n impl HirDisplay for Macro {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self.id {\n-            hir_def::MacroId::Macro2Id(_) => write!(f, \"macro\"),\n-            hir_def::MacroId::MacroRulesId(_) => write!(f, \"macro_rules!\"),\n-            hir_def::MacroId::ProcMacroId(_) => write!(f, \"proc_macro\"),\n+            hir_def::MacroId::Macro2Id(_) => f.write_str(\"macro\"),\n+            hir_def::MacroId::MacroRulesId(_) => f.write_str(\"macro_rules!\"),\n+            hir_def::MacroId::ProcMacroId(_) => f.write_str(\"proc_macro\"),\n         }?;\n         write!(f, \" {}\", self.name(f.db))\n     }"}, {"sha": "2609a6079451028790d0f9511eced82531a9b789", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12f803d1e3503364522345cd8557b18ddf497f6f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f803d1e3503364522345cd8557b18ddf497f6f/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=12f803d1e3503364522345cd8557b18ddf497f6f", "patch": "@@ -172,6 +172,16 @@ impl<'a> HirFormatter<'a> {\n         self.fmt.write_str(&self.buf).map_err(HirDisplayError::from)\n     }\n \n+    pub fn write_str(&mut self, s: &str) -> Result<(), HirDisplayError> {\n+        self.fmt.write_str(s)?;\n+        Ok(())\n+    }\n+\n+    pub fn write_char(&mut self, c: char) -> Result<(), HirDisplayError> {\n+        self.fmt.write_char(c)?;\n+        Ok(())\n+    }\n+\n     pub fn should_truncate(&self) -> bool {\n         match self.max_size {\n             Some(max_size) => self.curr_size >= max_size,"}]}