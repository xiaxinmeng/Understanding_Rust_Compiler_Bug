{"sha": "ef3900090ef983368b9c9efaaace7dfaff8b0992", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMzkwMDA5MGVmOTgzMzY4YjljOWVmYWFhY2U3ZGZhZmY4YjA5OTI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-16T18:18:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T18:18:42Z"}, "message": "Rollup merge of #74140 - sexxi-goose:precise_hir_projections, r=nikomatsakis\n\nMake hir ProjectionKind more precise\n\nThis commit also categorizing access as Field, Index, or Subslice.\n\nIdeas are taken from `mir::ProjectionElem`.\n\nProposed changes: https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/1,\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/2\n\nr? @nikomatsakis @matthewjasper", "tree": {"sha": "db6bb1ba86d633af8cd27d8e6143a107c967acf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db6bb1ba86d633af8cd27d8e6143a107c967acf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef3900090ef983368b9c9efaaace7dfaff8b0992", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfEJoCCRBK7hj4Ov3rIwAAdHIIAF+0O8ZDxosdGz5Cl4IbyOUU\nIKo+B3gj56gQGefZFUzWolBQ2mg4uG+Evz1OCpqLqsGldMWxnLXtuIEhF2grH5ki\nfMfLuz/HcDhl3Q4a7x+DyRMUWpXJlJvlSPjhyDjrhnjsxXrOF61Ven/Lzpg0YO4R\nwHhYQ4bd2hYUBD+FS4aUEU2chNGZ6AMAyY1kmac90TaUcrqWqqS5X+7hIkM1xLbh\nbBpqAoKUfPWfPEx4A1giWCis5Tv57B9BJ9eCcB6GpEpPn6RQXId4j6ovzZPRCIqu\nA4ZqSTpgrLNELZxwSlMEB5IbkrkDM9r6ia0z8xhaBf/7vQnwhbztnc1grOG8aWc=\n=Xaln\n-----END PGP SIGNATURE-----\n", "payload": "tree db6bb1ba86d633af8cd27d8e6143a107c967acf0\nparent 6dc12fb5d5a7a1c912f73589ee6303bb32bc491b\nparent 1acccb0f52bc5812ae9431b36b6f8f232a513d1f\nauthor Manish Goregaokar <manishsmail@gmail.com> 1594923522 -0700\ncommitter GitHub <noreply@github.com> 1594923522 -0700\n\nRollup merge of #74140 - sexxi-goose:precise_hir_projections, r=nikomatsakis\n\nMake hir ProjectionKind more precise\n\nThis commit also categorizing access as Field, Index, or Subslice.\n\nIdeas are taken from `mir::ProjectionElem`.\n\nProposed changes: https://github.com/rust-lang/project-rfc-2229/blob/master/hir-place-target.md\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/1,\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/2\n\nr? @nikomatsakis @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3900090ef983368b9c9efaaace7dfaff8b0992", "html_url": "https://github.com/rust-lang/rust/commit/ef3900090ef983368b9c9efaaace7dfaff8b0992", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef3900090ef983368b9c9efaaace7dfaff8b0992/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dc12fb5d5a7a1c912f73589ee6303bb32bc491b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc12fb5d5a7a1c912f73589ee6303bb32bc491b", "html_url": "https://github.com/rust-lang/rust/commit/6dc12fb5d5a7a1c912f73589ee6303bb32bc491b"}, {"sha": "1acccb0f52bc5812ae9431b36b6f8f232a513d1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1acccb0f52bc5812ae9431b36b6f8f232a513d1f", "html_url": "https://github.com/rust-lang/rust/commit/1acccb0f52bc5812ae9431b36b6f8f232a513d1f"}], "stats": {"total": 173, "additions": 159, "deletions": 14}, "files": [{"sha": "1be32729b1ee57bc3bb63ee9b84564e0b0100210", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef3900090ef983368b9c9efaaace7dfaff8b0992/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3900090ef983368b9c9efaaace7dfaff8b0992/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=ef3900090ef983368b9c9efaaace7dfaff8b0992", "patch": "@@ -11,8 +11,10 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n+use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n+use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n use rustc_span::Span;\n@@ -396,6 +398,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             &*with_expr,\n                             with_place.clone(),\n                             with_field.ty(self.tcx(), substs),\n+                            mc::ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n                         );\n                         self.delegate_consume(&field_place);\n                     }"}, {"sha": "70fe2c2cda5122e2f95dd7667f3df91224a50633", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 156, "deletions": 14, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ef3900090ef983368b9c9efaaace7dfaff8b0992/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef3900090ef983368b9c9efaaace7dfaff8b0992/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=ef3900090ef983368b9c9efaaace7dfaff8b0992", "patch": "@@ -54,11 +54,14 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::PatKind;\n+use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n #[derive(Clone, Debug)]\n@@ -77,8 +80,20 @@ pub enum PlaceBase {\n pub enum ProjectionKind {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref,\n-    /// An index or a field\n-    Other,\n+\n+    /// `B.F` where `B` is the base expression and `F` is\n+    /// the field. The field is identified by which variant\n+    /// it appears in along with a field index. The variant\n+    /// is used for enums.\n+    Field(u32, VariantIdx),\n+\n+    /// Some index like `B[x]`, where `B` is the base\n+    /// expression. We don't preserve the index `x` because\n+    /// we won't need it.\n+    Index,\n+\n+    /// A subslice covering a range of values like `B[x..y]`.\n+    Subslice,\n }\n \n #[derive(Clone, Debug)]\n@@ -406,7 +421,20 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             hir::ExprKind::Field(ref base, _) => {\n                 let base = self.cat_expr(&base)?;\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\", expr.hir_id, expr, base);\n-                Ok(self.cat_projection(expr, base, expr_ty))\n+\n+                let field_idx = self\n+                    .tables\n+                    .field_indices()\n+                    .get(expr.hir_id)\n+                    .cloned()\n+                    .expect(\"Field index not found\");\n+\n+                Ok(self.cat_projection(\n+                    expr,\n+                    base,\n+                    expr_ty,\n+                    ProjectionKind::Field(field_idx as u32, VariantIdx::new(0)),\n+                ))\n             }\n \n             hir::ExprKind::Index(ref base, _) => {\n@@ -419,7 +447,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     self.cat_overloaded_place(expr, base)\n                 } else {\n                     let base = self.cat_expr(&base)?;\n-                    Ok(self.cat_projection(expr, base, expr_ty))\n+                    Ok(self.cat_projection(expr, base, expr_ty, ProjectionKind::Index))\n                 }\n             }\n \n@@ -533,9 +561,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         node: &N,\n         base_place: PlaceWithHirId<'tcx>,\n         ty: Ty<'tcx>,\n+        kind: ProjectionKind,\n     ) -> PlaceWithHirId<'tcx> {\n         let mut projections = base_place.place.projections;\n-        projections.push(Projection { kind: ProjectionKind::Other, ty: ty });\n+        projections.push(Projection { kind: kind, ty: ty });\n         let ret = PlaceWithHirId::new(\n             node.hir_id(),\n             base_place.place.base_ty,\n@@ -609,6 +638,75 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.cat_pattern_(place, pat, &mut op)\n     }\n \n+    /// Returns the variant index for an ADT used within a Struct or TupleStruct pattern\n+    /// Here `pat_hir_id` is the HirId of the pattern itself.\n+    fn variant_index_for_adt(\n+        &self,\n+        qpath: &hir::QPath<'_>,\n+        pat_hir_id: hir::HirId,\n+        span: Span,\n+    ) -> McResult<VariantIdx> {\n+        let res = self.tables.qpath_res(qpath, pat_hir_id);\n+        let ty = self.tables.node_type(pat_hir_id);\n+        let adt_def = match ty.kind {\n+            ty::Adt(adt_def, _) => adt_def,\n+            _ => {\n+                self.tcx()\n+                    .sess\n+                    .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n+                return Err(());\n+            }\n+        };\n+\n+        match res {\n+            Res::Def(DefKind::Variant, variant_id) => Ok(adt_def.variant_index_with_id(variant_id)),\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_id) => {\n+                Ok(adt_def.variant_index_with_ctor_id(variant_ctor_id))\n+            }\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, ..), _)\n+            | Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n+            | Res::SelfCtor(..)\n+            | Res::SelfTy(..) => {\n+                // Structs and Unions have only have one variant.\n+                Ok(VariantIdx::new(0))\n+            }\n+            _ => bug!(\"expected ADT path, found={:?}\", res),\n+        }\n+    }\n+\n+    /// Returns the total number of fields in an ADT variant used within a pattern.\n+    /// Here `pat_hir_id` is the HirId of the pattern itself.\n+    fn total_fields_in_adt_variant(\n+        &self,\n+        pat_hir_id: hir::HirId,\n+        variant_index: VariantIdx,\n+        span: Span,\n+    ) -> McResult<usize> {\n+        let ty = self.tables.node_type(pat_hir_id);\n+        match ty.kind {\n+            ty::Adt(adt_def, _) => Ok(adt_def.variants[variant_index].fields.len()),\n+            _ => {\n+                self.tcx()\n+                    .sess\n+                    .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n+                return Err(());\n+            }\n+        }\n+    }\n+\n+    /// Returns the total number of fields in a tuple used within a Tuple pattern.\n+    /// Here `pat_hir_id` is the HirId of the pattern itself.\n+    fn total_fields_in_tuple(&self, pat_hir_id: hir::HirId, span: Span) -> McResult<usize> {\n+        let ty = self.tables.node_type(pat_hir_id);\n+        match ty.kind {\n+            ty::Tuple(substs) => Ok(substs.len()),\n+            _ => {\n+                self.tcx().sess.delay_span_bug(span, \"tuple pattern not applied to a tuple\");\n+                return Err(());\n+            }\n+        }\n+    }\n+\n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(\n         &self,\n@@ -679,20 +777,54 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         op(&place_with_id, pat);\n \n         match pat.kind {\n-            PatKind::TupleStruct(_, ref subpats, _) | PatKind::Tuple(ref subpats, _) => {\n-                // S(p1, ..., pN) or (p1, ..., pN)\n-                for subpat in subpats.iter() {\n+            PatKind::Tuple(ref subpats, dots_pos) => {\n+                // (p1, ..., pN)\n+                let total_fields = self.total_fields_in_tuple(pat.hir_id, pat.span)?;\n+\n+                for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n                     let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n-                    let sub_place = self.cat_projection(pat, place_with_id.clone(), subpat_ty);\n+                    let projection_kind = ProjectionKind::Field(i as u32, VariantIdx::new(0));\n+                    let sub_place =\n+                        self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n                     self.cat_pattern_(sub_place, &subpat, op)?;\n                 }\n             }\n \n-            PatKind::Struct(_, field_pats, _) => {\n+            PatKind::TupleStruct(ref qpath, ref subpats, dots_pos) => {\n+                // S(p1, ..., pN)\n+                let variant_index = self.variant_index_for_adt(qpath, pat.hir_id, pat.span)?;\n+                let total_fields =\n+                    self.total_fields_in_adt_variant(pat.hir_id, variant_index, pat.span)?;\n+\n+                for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n+                    let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n+                    let projection_kind = ProjectionKind::Field(i as u32, variant_index);\n+                    let sub_place =\n+                        self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n+                    self.cat_pattern_(sub_place, &subpat, op)?;\n+                }\n+            }\n+\n+            PatKind::Struct(ref qpath, field_pats, _) => {\n                 // S { f1: p1, ..., fN: pN }\n+\n+                let variant_index = self.variant_index_for_adt(qpath, pat.hir_id, pat.span)?;\n+\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n-                    let field_place = self.cat_projection(pat, place_with_id.clone(), field_ty);\n+                    let field_index = self\n+                        .tables\n+                        .field_indices()\n+                        .get(fp.hir_id)\n+                        .cloned()\n+                        .expect(\"no index for a field\");\n+\n+                    let field_place = self.cat_projection(\n+                        pat,\n+                        place_with_id.clone(),\n+                        field_ty,\n+                        ProjectionKind::Field(field_index as u32, variant_index),\n+                    );\n                     self.cat_pattern_(field_place, &fp.pat, op)?;\n                 }\n             }\n@@ -723,13 +855,23 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         return Err(());\n                     }\n                 };\n-                let elt_place = self.cat_projection(pat, place_with_id.clone(), element_ty);\n+                let elt_place = self.cat_projection(\n+                    pat,\n+                    place_with_id.clone(),\n+                    element_ty,\n+                    ProjectionKind::Index,\n+                );\n                 for before_pat in before {\n                     self.cat_pattern_(elt_place.clone(), &before_pat, op)?;\n                 }\n                 if let Some(ref slice_pat) = *slice {\n                     let slice_pat_ty = self.pat_ty_adjusted(&slice_pat)?;\n-                    let slice_place = self.cat_projection(pat, place_with_id, slice_pat_ty);\n+                    let slice_place = self.cat_projection(\n+                        pat,\n+                        place_with_id,\n+                        slice_pat_ty,\n+                        ProjectionKind::Subslice,\n+                    );\n                     self.cat_pattern_(slice_place, &slice_pat, op)?;\n                 }\n                 for after_pat in after {"}]}