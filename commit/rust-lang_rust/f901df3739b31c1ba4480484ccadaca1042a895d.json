{"sha": "f901df3739b31c1ba4480484ccadaca1042a895d", "node_id": "C_kwDOAAsO6NoAKGY5MDFkZjM3MzliMzFjMWJhNDQ4MDQ4NGNjYWRhY2ExMDQyYTg5NWQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-29T13:37:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:00:44Z"}, "message": "Handle TAIT.", "tree": {"sha": "28cd176f793b17056b64184cbff17e78a4f8551d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28cd176f793b17056b64184cbff17e78a4f8551d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f901df3739b31c1ba4480484ccadaca1042a895d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f901df3739b31c1ba4480484ccadaca1042a895d", "html_url": "https://github.com/rust-lang/rust/commit/f901df3739b31c1ba4480484ccadaca1042a895d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f901df3739b31c1ba4480484ccadaca1042a895d/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f385f856cd9df6ded13248cc3d25e603e38b4f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f385f856cd9df6ded13248cc3d25e603e38b4f2f", "html_url": "https://github.com/rust-lang/rust/commit/f385f856cd9df6ded13248cc3d25e603e38b4f2f"}], "stats": {"total": 117, "additions": 21, "deletions": 96}, "files": [{"sha": "8831a99cdc8c44ab6fa1a8d869371783eea1a62e", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f901df3739b31c1ba4480484ccadaca1042a895d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f901df3739b31c1ba4480484ccadaca1042a895d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f901df3739b31c1ba4480484ccadaca1042a895d", "patch": "@@ -5,7 +5,7 @@ use crate::{Arena, FnDeclKind};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -340,12 +340,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n-                let ty = self.lower_ty(\n-                    ty,\n-                    ImplTraitContext::TypeAliasesOpaqueTy {\n-                        capturable_lifetimes: &mut FxHashSet::default(),\n-                    },\n-                );\n+                let ty = self.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, where_clauses, true);\n                 let generics = self.lower_generics(\n@@ -982,12 +977,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::ImplItemKind::TyAlias(ty)\n                     }\n                     Some(ty) => {\n-                        let ty = self.lower_ty(\n-                            ty,\n-                            ImplTraitContext::TypeAliasesOpaqueTy {\n-                                capturable_lifetimes: &mut FxHashSet::default(),\n-                            },\n-                        );\n+                        let ty = self.lower_ty(ty, ImplTraitContext::TypeAliasesOpaqueTy);\n                         hir::ImplItemKind::TyAlias(ty)\n                     }\n                 };"}, {"sha": "bf1843a00ec0ebd21bbcacc042b32fee2531d7ca", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 18, "deletions": 83, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f901df3739b31c1ba4480484ccadaca1042a895d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f901df3739b31c1ba4480484ccadaca1042a895d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f901df3739b31c1ba4480484ccadaca1042a895d", "patch": "@@ -269,29 +269,11 @@ enum ImplTraitContext<'b, 'a> {\n     /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -> T`.\n     ///\n     ReturnPositionOpaqueTy {\n-        /// `DefId` for the parent function, used to look up necessary\n-        /// information later.\n-        fn_def_id: LocalDefId,\n         /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,\n         origin: hir::OpaqueTyOrigin,\n     },\n     /// Impl trait in type aliases.\n-    TypeAliasesOpaqueTy {\n-        /// Set of lifetimes that this opaque type can capture, if it uses\n-        /// them. This includes lifetimes bound since we entered this context.\n-        /// For example:\n-        ///\n-        /// ```\n-        /// type A<'b> = impl for<'a> Trait<'a, Out = impl Sized + 'a>;\n-        /// ```\n-        ///\n-        /// Here the inner opaque type captures `'a` because it uses it. It doesn't\n-        /// need to capture `'b` because it already inherits the lifetime\n-        /// parameter from `A`.\n-        // FIXME(impl_trait): but `required_region_bounds` will ICE later\n-        // anyway.\n-        capturable_lifetimes: &'b mut FxHashSet<hir::ParamName>,\n-    },\n+    TypeAliasesOpaqueTy,\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n }\n@@ -325,12 +307,8 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params, parent) => Universal(params, *parent),\n-            ReturnPositionOpaqueTy { fn_def_id, origin } => {\n-                ReturnPositionOpaqueTy { fn_def_id: *fn_def_id, origin: *origin }\n-            }\n-            TypeAliasesOpaqueTy { capturable_lifetimes } => {\n-                TypeAliasesOpaqueTy { capturable_lifetimes }\n-            }\n+            ReturnPositionOpaqueTy { origin } => ReturnPositionOpaqueTy { origin: *origin },\n+            TypeAliasesOpaqueTy => TypeAliasesOpaqueTy,\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1011,7 +989,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TypeBindingKind::Equality { term }\n             }\n             AssocConstraintKind::Bound { ref bounds } => {\n-                let mut capturable_lifetimes;\n                 let mut parent_def_id = self.current_hir_id_owner;\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n@@ -1044,13 +1021,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        capturable_lifetimes = FxHashSet::default();\n-                        (\n-                            true,\n-                            ImplTraitContext::TypeAliasesOpaqueTy {\n-                                capturable_lifetimes: &mut capturable_lifetimes,\n-                            },\n-                        )\n+                        (true, ImplTraitContext::TypeAliasesOpaqueTy)\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1309,28 +1280,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::ReturnPositionOpaqueTy { fn_def_id, origin } => self\n-                        .lower_opaque_impl_trait(\n-                            span,\n-                            Some(fn_def_id),\n-                            origin,\n-                            def_node_id,\n-                            None,\n-                            |this| this.lower_param_bounds(bounds, itctx),\n-                        ),\n-                    ImplTraitContext::TypeAliasesOpaqueTy { ref capturable_lifetimes } => {\n-                        // Reset capturable lifetimes, any nested impl trait\n-                        // types will inherit lifetimes from this opaque type,\n-                        // so don't need to capture them again.\n-                        let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy {\n-                            capturable_lifetimes: &mut FxHashSet::default(),\n-                        };\n+                    ImplTraitContext::ReturnPositionOpaqueTy { origin } => self\n+                        .lower_opaque_impl_trait(span, origin, def_node_id, |this| {\n+                            this.lower_param_bounds(bounds, itctx)\n+                        }),\n+                    ImplTraitContext::TypeAliasesOpaqueTy => {\n+                        let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy;\n                         self.lower_opaque_impl_trait(\n                             span,\n-                            None,\n                             hir::OpaqueTyOrigin::TyAlias,\n                             def_node_id,\n-                            Some(capturable_lifetimes),\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n@@ -1392,10 +1351,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n-        fn_def_id: Option<LocalDefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n-        capturable_lifetimes: Option<&FxHashSet<hir::ParamName>>,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n         // Make sure we know that some funky desugaring has been going on here.\n@@ -1409,19 +1366,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n-            let lifetime_stash = std::mem::replace(\n-                &mut lctx.captured_lifetimes,\n-                Some((opaque_ty_def_id, FxHashMap::default(), FxHashSet::default())),\n-            );\n+            let capture_framework = if origin == hir::OpaqueTyOrigin::TyAlias {\n+                None\n+            } else {\n+                Some((opaque_ty_def_id, FxHashMap::default(), FxHashSet::default()))\n+            };\n+            let lifetime_stash = std::mem::replace(&mut lctx.captured_lifetimes, capture_framework);\n             let hir_bounds = lower_bounds(lctx);\n-            collected_lifetimes =\n-                std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap().1;\n-\n-            if let Some(capturable_lifetimes) = capturable_lifetimes {\n-                collected_lifetimes.retain(|_, (_, _, p_name, _)| {\n-                    capturable_lifetimes.contains(&p_name.normalize_to_macros_2_0())\n-                });\n-            }\n+            collected_lifetimes = std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash)\n+                .map_or_else(FxHashMap::default, |c| c.1);\n             debug!(?collected_lifetimes);\n \n             let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n@@ -1586,7 +1539,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         Some((node_id, _)) if kind.impl_trait_return_allowed() => {\n                             let fn_def_id = self.resolver.local_def_id(node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n-                                fn_def_id,\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             }\n                         }\n@@ -1867,7 +1819,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // `impl Future` opaque type that `async fn` implicitly\n                 // generates.\n                 let context = ImplTraitContext::ReturnPositionOpaqueTy {\n-                    fn_def_id,\n                     origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                 };\n                 self.lower_ty(ty, context)\n@@ -2118,28 +2069,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n \n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            // Any impl Trait types defined within this scope can capture\n-            // lifetimes bound on this predicate.\n-            let lt_def_names = p.bound_generic_params.iter().filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => {\n-                    Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n-                }\n-                _ => None,\n-            });\n-            if let ImplTraitContext::TypeAliasesOpaqueTy { ref mut capturable_lifetimes } = itctx {\n-                capturable_lifetimes.extend(lt_def_names.clone());\n-            }\n             if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n                 binders.insert(p.trait_ref.ref_id);\n             }\n \n             let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n \n-            if let ImplTraitContext::TypeAliasesOpaqueTy { ref mut capturable_lifetimes } = itctx {\n-                for param in lt_def_names {\n-                    capturable_lifetimes.remove(&param);\n-                }\n-            }\n             if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n                 binders.remove(&p.trait_ref.ref_id);\n             }"}]}