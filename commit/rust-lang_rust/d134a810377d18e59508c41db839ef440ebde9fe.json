{"sha": "d134a810377d18e59508c41db839ef440ebde9fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzRhODEwMzc3ZDE4ZTU5NTA4YzQxZGI4MzllZjQ0MGViZGU5ZmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-09-14T10:22:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-14T10:22:20Z"}, "message": "Merge #5976\n\n5976: Complete trait impl immediately after type/const/fn r=jonas-schievink a=oxalica\n\nCurrently, we can complete type/const/fn but only if we typed an identifier.\r\nThat is, `impl .. { fn f<|> }` has completions with all trait fn including `f`, but `impl .. { fn <|> }` doesn't provide any suggestion (even if explicit trigger it).\r\n\r\nThis PR tweak the logic of completion match to make it possible.\r\n\r\nHowever, we still need to explicit trigger suggestions (`Control + Space` by default) in vscode to show. Not sure if we can make it automatically triggered after typing the space after `fn`.\r\n\r\nAnother question is that I cannot figure out why `BLOCK_EXPR` need to be checked. A block expr directly inside a impl block should be invalid, and nested items will failed to locate impl block in specific offset and skip the suggestion. Now I simply removed it and no tests are broken.\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/4f91478e50dc5c2a87235e9be8bd91e3f62de4b4/crates/ide/src/completion/complete_trait_impl.rs#L109\r\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>", "tree": {"sha": "38f92d3234e9ebf23b7762794416fbc5c6d3b0a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38f92d3234e9ebf23b7762794416fbc5c6d3b0a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d134a810377d18e59508c41db839ef440ebde9fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfX0RcCRBK7hj4Ov3rIwAAdHIIAEGkCtUOWiJOU/Coa8yVFqJh\nVwZgLDrEfdzlJo4T2Qzc+EgvpzfmMsce7A+dOW1LNi4PmPal9XogFF9XzIby9Rfb\n/IcYrnee2Vs8q90MKZJCizIh1dqxcj4sbgFqQrs65NQCwVeA+xnkey8catGa8hej\nZGeYOyZemNyH+EBtEkwfoAbavbOWw8UoPEH4/ce6bNztgp3AwgkMsBQE2stoTzX/\nAEoKcyjOpBCvs800yArz/MS3wr8sXsr4rbUScCOp1hjh1Vpj4QEFI8P3nMA3x4p2\naz3Jzu0d+NH5nHV8VsxRlhwaaBZvgonQFeHdMZgrXhjAguLwMfgOlfzm55yD4lE=\n=0ASr\n-----END PGP SIGNATURE-----\n", "payload": "tree 38f92d3234e9ebf23b7762794416fbc5c6d3b0a8\nparent a61178d2186b8d9ca324231ab03368819be0ff6e\nparent 8ebf3596b78dc10541acd7e08d5c857967a9277c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1600078940 +0000\ncommitter GitHub <noreply@github.com> 1600078940 +0000\n\nMerge #5976\n\n5976: Complete trait impl immediately after type/const/fn r=jonas-schievink a=oxalica\n\nCurrently, we can complete type/const/fn but only if we typed an identifier.\r\nThat is, `impl .. { fn f<|> }` has completions with all trait fn including `f`, but `impl .. { fn <|> }` doesn't provide any suggestion (even if explicit trigger it).\r\n\r\nThis PR tweak the logic of completion match to make it possible.\r\n\r\nHowever, we still need to explicit trigger suggestions (`Control + Space` by default) in vscode to show. Not sure if we can make it automatically triggered after typing the space after `fn`.\r\n\r\nAnother question is that I cannot figure out why `BLOCK_EXPR` need to be checked. A block expr directly inside a impl block should be invalid, and nested items will failed to locate impl block in specific offset and skip the suggestion. Now I simply removed it and no tests are broken.\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/4f91478e50dc5c2a87235e9be8bd91e3f62de4b4/crates/ide/src/completion/complete_trait_impl.rs#L109\r\n\n\nCo-authored-by: oxalica <oxalicc@pm.me>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d134a810377d18e59508c41db839ef440ebde9fe", "html_url": "https://github.com/rust-lang/rust/commit/d134a810377d18e59508c41db839ef440ebde9fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d134a810377d18e59508c41db839ef440ebde9fe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61178d2186b8d9ca324231ab03368819be0ff6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61178d2186b8d9ca324231ab03368819be0ff6e", "html_url": "https://github.com/rust-lang/rust/commit/a61178d2186b8d9ca324231ab03368819be0ff6e"}, {"sha": "8ebf3596b78dc10541acd7e08d5c857967a9277c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebf3596b78dc10541acd7e08d5c857967a9277c", "html_url": "https://github.com/rust-lang/rust/commit/8ebf3596b78dc10541acd7e08d5c857967a9277c"}], "stats": {"total": 175, "additions": 119, "deletions": 56}, "files": [{"sha": "bff2603b82ec4e0adecc11cc9e56dc4433e3a994", "filename": "crates/ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 119, "deletions": 56, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/d134a810377d18e59508c41db839ef440ebde9fe/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d134a810377d18e59508c41db839ef440ebde9fe/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=d134a810377d18e59508c41db839ef440ebde9fe", "patch": "@@ -46,76 +46,76 @@ use crate::{\n     display::function_declaration,\n };\n \n+#[derive(Debug, PartialEq, Eq)]\n+enum ImplCompletionKind {\n+    All,\n+    Fn,\n+    TypeAlias,\n+    Const,\n+}\n+\n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some((trigger, impl_def)) = completion_match(ctx) {\n-        match trigger.kind() {\n-            SyntaxKind::NAME_REF => get_missing_assoc_items(&ctx.sema, &impl_def)\n-                .into_iter()\n-                .for_each(|item| match item {\n-                    hir::AssocItem::Function(fn_item) => {\n-                        add_function_impl(&trigger, acc, ctx, fn_item)\n-                    }\n-                    hir::AssocItem::TypeAlias(type_item) => {\n-                        add_type_alias_impl(&trigger, acc, ctx, type_item)\n-                    }\n-                    hir::AssocItem::Const(const_item) => {\n-                        add_const_impl(&trigger, acc, ctx, const_item)\n-                    }\n-                }),\n-\n-            SyntaxKind::FN => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::Function(fn_item) => Some(fn_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_function_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+    if let Some((kind, trigger, impl_def)) = completion_match(ctx) {\n+        get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| match item {\n+            hir::AssocItem::Function(fn_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Fn =>\n+            {\n+                add_function_impl(&trigger, acc, ctx, fn_item)\n             }\n-\n-            SyntaxKind::TYPE_ALIAS => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::TypeAlias(type_item) => Some(type_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_type_alias_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+            hir::AssocItem::TypeAlias(type_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::TypeAlias =>\n+            {\n+                add_type_alias_impl(&trigger, acc, ctx, type_item)\n             }\n-\n-            SyntaxKind::CONST => {\n-                for missing_fn in get_missing_assoc_items(&ctx.sema, &impl_def)\n-                    .into_iter()\n-                    .filter_map(|item| match item {\n-                        hir::AssocItem::Const(const_item) => Some(const_item),\n-                        _ => None,\n-                    })\n-                {\n-                    add_const_impl(&trigger, acc, ctx, missing_fn);\n-                }\n+            hir::AssocItem::Const(const_item)\n+                if kind == ImplCompletionKind::All || kind == ImplCompletionKind::Const =>\n+            {\n+                add_const_impl(&trigger, acc, ctx, const_item)\n             }\n-\n             _ => {}\n-        }\n+        });\n     }\n }\n \n-fn completion_match(ctx: &CompletionContext) -> Option<(SyntaxNode, Impl)> {\n-    let (trigger, impl_def_offset) = ctx.token.ancestors().find_map(|p| match p.kind() {\n-        SyntaxKind::FN | SyntaxKind::TYPE_ALIAS | SyntaxKind::CONST | SyntaxKind::BLOCK_EXPR => {\n-            Some((p, 2))\n+fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, SyntaxNode, Impl)> {\n+    let mut token = ctx.token.clone();\n+    // For keywork without name like `impl .. { fn <|> }`, the current position is inside\n+    // the whitespace token, which is outside `FN` syntax node.\n+    // We need to follow the previous token in this case.\n+    if token.kind() == SyntaxKind::WHITESPACE {\n+        token = token.prev_token()?;\n+    }\n+\n+    let (kind, trigger, impl_def_offset) = token.ancestors().find_map(|p| match p.kind() {\n+        // `const` can be a modifier of an item, so the `const` token may be inside another item syntax node.\n+        // Eg. `impl .. { const <|> fn bar() .. }`\n+        SyntaxKind::FN | SyntaxKind::TYPE_ALIAS | SyntaxKind::CONST\n+            if token.kind() == SyntaxKind::CONST_KW =>\n+        {\n+            Some((ImplCompletionKind::Const, p, 2))\n         }\n-        SyntaxKind::NAME_REF => Some((p, 5)),\n+        SyntaxKind::FN => Some((ImplCompletionKind::Fn, p, 2)),\n+        SyntaxKind::TYPE_ALIAS => Some((ImplCompletionKind::TypeAlias, p, 2)),\n+        SyntaxKind::CONST => Some((ImplCompletionKind::Const, p, 2)),\n+        // `impl .. { const <|> }` is parsed as:\n+        // IMPL\n+        //   ASSOC_ITEM_LIST\n+        //     ERROR\n+        //       CONST_KW <- token\n+        //     WHITESPACE <- ctx.token\n+        SyntaxKind::ERROR\n+            if p.first_token().map_or(false, |t| t.kind() == SyntaxKind::CONST_KW) =>\n+        {\n+            Some((ImplCompletionKind::Const, p, 2))\n+        }\n+        SyntaxKind::NAME_REF => Some((ImplCompletionKind::All, p, 5)),\n         _ => None,\n     })?;\n+\n     let impl_def = (0..impl_def_offset - 1)\n         .try_fold(trigger.parent()?, |t, _| t.parent())\n         .and_then(ast::Impl::cast)?;\n-    Some((trigger, impl_def))\n+    Some((kind, trigger, impl_def))\n }\n \n fn add_function_impl(\n@@ -485,4 +485,67 @@ impl Test for () {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn complete_without_name() {\n+        let test = |completion: &str, hint: &str, completed: &str, next_sibling: &str| {\n+            println!(\n+                \"completion='{}', hint='{}', next_sibling='{}'\",\n+                completion, hint, next_sibling\n+            );\n+\n+            check_edit(\n+                completion,\n+                &format!(\n+                    r#\"\n+trait Test {{\n+    type Foo;\n+    const CONST: u16;\n+    fn bar();\n+}}\n+struct T;\n+\n+impl Test for T {{\n+    {}\n+    {}\n+}}\n+\"#,\n+                    hint, next_sibling\n+                ),\n+                &format!(\n+                    r#\"\n+trait Test {{\n+    type Foo;\n+    const CONST: u16;\n+    fn bar();\n+}}\n+struct T;\n+\n+impl Test for T {{\n+    {}\n+    {}\n+}}\n+\"#,\n+                    completed, next_sibling\n+                ),\n+            )\n+        };\n+\n+        // Enumerate some possible next siblings.\n+        for next_sibling in &[\n+            \"\",\n+            \"fn other_fn() {}\", // `const <|> fn` -> `const fn`\n+            \"type OtherType = i32;\",\n+            \"const OTHER_CONST: i32 = 0;\",\n+            \"async fn other_fn() {}\",\n+            \"unsafe fn other_fn() {}\",\n+            \"default fn other_fn() {}\",\n+            \"default type OtherType = i32;\",\n+            \"default const OTHER_CONST: i32 = 0;\",\n+        ] {\n+            test(\"bar\", \"fn <|>\", \"fn bar() {\\n    $0\\n}\", next_sibling);\n+            test(\"Foo\", \"type <|>\", \"type Foo = \", next_sibling);\n+            test(\"CONST\", \"const <|>\", \"const CONST: u16 = \", next_sibling);\n+        }\n+    }\n }"}]}