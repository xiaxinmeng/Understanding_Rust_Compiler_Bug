{"sha": "4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZDVmY2IxMjI4NzBkNWIwODc2YjMyZTJkZmZlYjRlYTJiZDZhZWQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-11T11:31:14Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-11T12:20:33Z"}, "message": "extra: improvements & bug fixes to rl.\n\n- Removes a layer of indirection in the storage of the completion\n  callback.\n- Handles user tab completion in a task in which `complete` hasn't been\n  properly. Previously, if `complete` was called in one task, and `read`\n  called in another, attempting to get completions would crash. This\n  makes the completion handlers non-ambiguously task-local only.\n- Fix a mismatch in return values between the Rust code and linenoise.", "tree": {"sha": "5b02a869b295acc6dfabf04af97e29ec4d35fdea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b02a869b295acc6dfabf04af97e29ec4d35fdea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed", "html_url": "https://github.com/rust-lang/rust/commit/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe03d827a4910c561507be0802bb5f39a477cc02", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe03d827a4910c561507be0802bb5f39a477cc02", "html_url": "https://github.com/rust-lang/rust/commit/fe03d827a4910c561507be0802bb5f39a477cc02"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "74b7aea99787794ad9735519ca9a49023b285d5d", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=4ed5fcb122870d5b0876b32e2dffeb4ea2bd6aed", "patch": "@@ -74,14 +74,16 @@ pub fn set_history_max_len(len: int) -> bool {\n /// Save line history to a file\n pub fn save_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n-        (locked!(rustrt::linenoiseHistorySave(buf))) == 1 as c_int\n+        // 0 on success, -1 on failure\n+        (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n     }\n }\n \n /// Load line history from a file\n pub fn load_history(file: &str) -> bool {\n     do file.with_c_str |buf| {\n-        (locked!(rustrt::linenoiseHistoryLoad(buf))) == 1 as c_int\n+        // 0 on success, -1 on failure\n+        (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n     }\n }\n \n@@ -107,29 +109,35 @@ pub fn read(prompt: &str) -> Option<~str> {\n \n pub type CompletionCb = @fn(~str, @fn(~str));\n \n-static complete_key: local_data::Key<@CompletionCb> = &local_data::Key;\n+static complete_key: local_data::Key<CompletionCb> = &local_data::Key;\n \n-/// Bind to the main completion callback.\n+/// Bind to the main completion callback in the current task.\n ///\n /// The completion callback should not call any `extra::rl` functions\n /// other than the closure that it receives as its second\n /// argument. Calling such a function will deadlock on the mutex used\n /// to ensure that the calls are thread-safe.\n pub fn complete(cb: CompletionCb) {\n-    local_data::set(complete_key, @cb);\n-\n-    extern fn callback(line: *c_char, completions: *()) {\n-        do local_data::get(complete_key) |cb| {\n-            let cb = **cb.unwrap();\n-\n-            unsafe {\n-                do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do suggestion.with_c_str |buf| {\n-                        // This isn't locked, because `callback` gets\n-                        // called inside `rustrt::linenoise`, which\n-                        // *is* already inside the mutex, so\n-                        // re-locking would be a deadlock.\n-                        rustrt::linenoiseAddCompletion(completions, buf);\n+    local_data::set(complete_key, cb);\n+\n+    extern fn callback(c_line: *c_char, completions: *()) {\n+        do local_data::get(complete_key) |opt_cb| {\n+            // only fetch completions if a completion handler has been\n+            // registered in the current task.\n+            match opt_cb {\n+                None => {},\n+                Some(cb) => {\n+                    let line = unsafe { str::raw::from_c_str(c_line) };\n+                    do (*cb)(line) |suggestion| {\n+                        do suggestion.with_c_str |buf| {\n+                            // This isn't locked, because `callback` gets\n+                            // called inside `rustrt::linenoise`, which\n+                            // *is* already inside the mutex, so\n+                            // re-locking would be a deadlock.\n+                            unsafe {\n+                                rustrt::linenoiseAddCompletion(completions, buf);\n+                            }\n+                        }\n                     }\n                 }\n             }"}]}