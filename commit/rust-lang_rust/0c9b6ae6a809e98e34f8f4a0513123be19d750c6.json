{"sha": "0c9b6ae6a809e98e34f8f4a0513123be19d750c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOWI2YWU2YTgwOWU5OGUzNGY4ZjRhMDUxMzEyM2JlMTlkNzUwYzY=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T16:44:56Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:04:40Z"}, "message": "Deprecate the `TupleN` traits", "tree": {"sha": "6ac54839032cd4a8e001eea3e3d4295a18c94e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac54839032cd4a8e001eea3e3d4295a18c94e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c9b6ae6a809e98e34f8f4a0513123be19d750c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9b6ae6a809e98e34f8f4a0513123be19d750c6", "html_url": "https://github.com/rust-lang/rust/commit/0c9b6ae6a809e98e34f8f4a0513123be19d750c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c9b6ae6a809e98e34f8f4a0513123be19d750c6/comments", "author": null, "committer": null, "parents": [{"sha": "444fa1b7cffcd99ca5b8abb51acf979f06a25899", "url": "https://api.github.com/repos/rust-lang/rust/commits/444fa1b7cffcd99ca5b8abb51acf979f06a25899", "html_url": "https://github.com/rust-lang/rust/commit/444fa1b7cffcd99ca5b8abb51acf979f06a25899"}], "stats": {"total": 215, "additions": 109, "deletions": 106}, "files": [{"sha": "89d07a61da80d3ef60caf05e0dbb20a6c657857c", "filename": "src/libcore/tuple/mod.rs", "status": "modified", "additions": 109, "deletions": 106, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b6ae6a809e98e34f8f4a0513123be19d750c6/src%2Flibcore%2Ftuple%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b6ae6a809e98e34f8f4a0513123be19d750c6/src%2Flibcore%2Ftuple%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple%2Fmod.rs?ref=0c9b6ae6a809e98e34f8f4a0513123be19d750c6", "patch": "@@ -72,25 +72,28 @@ use default::Default;\n use option::Option;\n use option::Option::Some;\n \n+// FIXME(#19630) Remove this work-around\n+macro_rules! e {\n+    ($e:expr) => { $e }\n+}\n+\n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n     ($(\n         $Tuple:ident {\n-            $(($valN:ident, $refN:ident, $mutN:ident) -> $T:ident {\n-                ($($x:ident),+) => $ret:expr\n-            })+\n+            $(($valN:ident, $refN:ident, $mutN:ident, $idx:tt) -> $T:ident)+\n         }\n     )+) => {\n         $(\n             #[allow(missing_docs)]\n-            #[stable]\n+            #[deprecated]\n             pub trait $Tuple<$($T),+> {\n                 $(\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n                     fn $valN(self) -> $T;\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n                     fn $refN<'a>(&'a self) -> &'a $T;\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&mut tuple.N`\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T;\n                  )+\n             }\n@@ -99,43 +102,43 @@ macro_rules! tuple_impls {\n                 $(\n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `tuple.N`\"]\n                     fn $valN(self) -> $T {\n-                        let ($($x,)+) = self; $ret\n+                        e!(self.$idx)\n                     }\n \n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: `&tuple.N`\"]\n                     fn $refN<'a>(&'a self) -> &'a $T {\n-                        let ($(ref $x,)+) = *self; $ret\n+                        e!(&self.$idx)\n                     }\n \n                     #[inline]\n                     #[allow(unused_variables)]\n-                    #[unstable = \"may rename pending accessor naming conventions\"]\n+                    #[deprecated = \"use tuple indexing: &mut tuple.N\"]\n                     fn $mutN<'a>(&'a mut self) -> &'a mut $T {\n-                        let ($(ref mut $x,)+) = *self; $ret\n+                        e!(&mut self.$idx)\n                     }\n                 )+\n             }\n \n             #[unstable = \"waiting for Clone to stabilize\"]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n-                    ($(self.$refN().clone(),)+)\n+                    ($(e!(self.$idx.clone()),)+)\n                 }\n             }\n \n             #[unstable = \"waiting for PartialEq to stabilize\"]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$refN() == *other.$refN())&&+\n+                    e!($(self.$idx == other.$idx)&&+)\n                 }\n                 #[inline]\n                 fn ne(&self, other: &($($T,)+)) -> bool {\n-                    $(*self.$refN() != *other.$refN())||+\n+                    e!($(self.$idx != other.$idx)||+)\n                 }\n             }\n \n@@ -146,31 +149,31 @@ macro_rules! tuple_impls {\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn partial_cmp(&self, other: &($($T,)+)) -> Option<Ordering> {\n-                    lexical_partial_cmp!($(self.$refN(), other.$refN()),+)\n+                    lexical_partial_cmp!($(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(lt, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(lt, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn le(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(le, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(le, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn ge(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(ge, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(ge, $(self.$idx, other.$idx),+)\n                 }\n                 #[inline]\n                 fn gt(&self, other: &($($T,)+)) -> bool {\n-                    lexical_ord!(gt, $(self.$refN(), other.$refN()),+)\n+                    lexical_ord!(gt, $(self.$idx, other.$idx),+)\n                 }\n             }\n \n             #[unstable = \"waiting for Ord to stabilize\"]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n-                    lexical_cmp!($(self.$refN(), other.$refN()),+)\n+                    lexical_cmp!($(self.$idx, other.$idx),+)\n                 }\n             }\n \n@@ -191,134 +194,134 @@ macro_rules! tuple_impls {\n // a3, b3)` (and similarly for `lexical_cmp`)\n macro_rules! lexical_ord {\n     ($rel: ident, $a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        if *$a != *$b { lexical_ord!($rel, $a, $b) }\n+        if $a != $b { lexical_ord!($rel, $a, $b) }\n         else { lexical_ord!($rel, $($rest_a, $rest_b),+) }\n     };\n-    ($rel: ident, $a:expr, $b:expr) => { (*$a) . $rel ($b) };\n+    ($rel: ident, $a:expr, $b:expr) => { ($a) . $rel (& $b) };\n }\n \n macro_rules! lexical_partial_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        match ($a).partial_cmp($b) {\n+        match ($a).partial_cmp(&$b) {\n             Some(Equal) => lexical_partial_cmp!($($rest_a, $rest_b),+),\n             ordering   => ordering\n         }\n     };\n-    ($a:expr, $b:expr) => { ($a).partial_cmp($b) };\n+    ($a:expr, $b:expr) => { ($a).partial_cmp(&$b) };\n }\n \n macro_rules! lexical_cmp {\n     ($a:expr, $b:expr, $($rest_a:expr, $rest_b:expr),+) => {\n-        match ($a).cmp($b) {\n+        match ($a).cmp(&$b) {\n             Equal => lexical_cmp!($($rest_a, $rest_b),+),\n             ordering   => ordering\n         }\n     };\n-    ($a:expr, $b:expr) => { ($a).cmp($b) };\n+    ($a:expr, $b:expr) => { ($a).cmp(&$b) };\n }\n \n tuple_impls! {\n     Tuple1 {\n-        (val0, ref0, mut0) -> A { (a) => a }\n+        (val0, ref0, mut0, 0) -> A\n     }\n     Tuple2 {\n-        (val0, ref0, mut0) -> A { (a, b) => a }\n-        (val1, ref1, mut1) -> B { (a, b) => b }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n     }\n     Tuple3 {\n-        (val0, ref0, mut0) -> A { (a, b, c) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c) => c }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n     }\n     Tuple4 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d) => d }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n     }\n     Tuple5 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e) => e }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n     }\n     Tuple6 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f) => f }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n     }\n     Tuple7 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g) => g }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n     }\n     Tuple8 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h) => h }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n     }\n     Tuple9 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i) => h }\n-        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i) => i }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n     }\n     Tuple10 {\n-        (val0, ref0, mut0) -> A { (a, b, c, d, e, f, g, h, i, j) => a }\n-        (val1, ref1, mut1) -> B { (a, b, c, d, e, f, g, h, i, j) => b }\n-        (val2, ref2, mut2) -> C { (a, b, c, d, e, f, g, h, i, j) => c }\n-        (val3, ref3, mut3) -> D { (a, b, c, d, e, f, g, h, i, j) => d }\n-        (val4, ref4, mut4) -> E { (a, b, c, d, e, f, g, h, i, j) => e }\n-        (val5, ref5, mut5) -> F { (a, b, c, d, e, f, g, h, i, j) => f }\n-        (val6, ref6, mut6) -> G { (a, b, c, d, e, f, g, h, i, j) => g }\n-        (val7, ref7, mut7) -> H { (a, b, c, d, e, f, g, h, i, j) => h }\n-        (val8, ref8, mut8) -> I { (a, b, c, d, e, f, g, h, i, j) => i }\n-        (val9, ref9, mut9) -> J { (a, b, c, d, e, f, g, h, i, j) => j }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n     }\n     Tuple11 {\n-        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k) => a }\n-        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k) => b }\n-        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k) => c }\n-        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k) => d }\n-        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k) => e }\n-        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k) => f }\n-        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k) => g }\n-        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k) => h }\n-        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k) => i }\n-        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k) => j }\n-        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k) => k }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n+        (val10, ref10, mut10, 10) -> K\n     }\n     Tuple12 {\n-        (val0,  ref0,  mut0)  -> A { (a, b, c, d, e, f, g, h, i, j, k, l) => a }\n-        (val1,  ref1,  mut1)  -> B { (a, b, c, d, e, f, g, h, i, j, k, l) => b }\n-        (val2,  ref2,  mut2)  -> C { (a, b, c, d, e, f, g, h, i, j, k, l) => c }\n-        (val3,  ref3,  mut3)  -> D { (a, b, c, d, e, f, g, h, i, j, k, l) => d }\n-        (val4,  ref4,  mut4)  -> E { (a, b, c, d, e, f, g, h, i, j, k, l) => e }\n-        (val5,  ref5,  mut5)  -> F { (a, b, c, d, e, f, g, h, i, j, k, l) => f }\n-        (val6,  ref6,  mut6)  -> G { (a, b, c, d, e, f, g, h, i, j, k, l) => g }\n-        (val7,  ref7,  mut7)  -> H { (a, b, c, d, e, f, g, h, i, j, k, l) => h }\n-        (val8,  ref8,  mut8)  -> I { (a, b, c, d, e, f, g, h, i, j, k, l) => i }\n-        (val9,  ref9,  mut9)  -> J { (a, b, c, d, e, f, g, h, i, j, k, l) => j }\n-        (val10, ref10, mut10) -> K { (a, b, c, d, e, f, g, h, i, j, k, l) => k }\n-        (val11, ref11, mut11) -> L { (a, b, c, d, e, f, g, h, i, j, k, l) => l }\n+        (val0, ref0, mut0, 0) -> A\n+        (val1, ref1, mut1, 1) -> B\n+        (val2, ref2, mut2, 2) -> C\n+        (val3, ref3, mut3, 3) -> D\n+        (val4, ref4, mut4, 4) -> E\n+        (val5, ref5, mut5, 5) -> F\n+        (val6, ref6, mut6, 6) -> G\n+        (val7, ref7, mut7, 7) -> H\n+        (val8, ref8, mut8, 8) -> I\n+        (val9, ref9, mut9, 9) -> J\n+        (val10, ref10, mut10, 10) -> K\n+        (val11, ref11, mut11, 11) -> L\n     }\n }\n "}]}