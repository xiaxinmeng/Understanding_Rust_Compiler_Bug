{"sha": "9b7f1f5649a7b93c55dcab81878910d322342d74", "node_id": "C_kwDOAAsO6NoAKDliN2YxZjU2NDlhN2I5M2M1NWRjYWI4MTg3ODkxMGQzMjIzNDJkNzQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-04T17:42:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-04T17:42:16Z"}, "message": "Rollup merge of #93608 - nnethercote:speed-up-find_library_crate, r=petrochenkov\n\nClean up `find_library_crate`\n\nSome clean-ups.\n\nr? `@petrochenkov`", "tree": {"sha": "5061121203a1eac8f9fc0035e31859e8831513a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5061121203a1eac8f9fc0035e31859e8831513a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b7f1f5649a7b93c55dcab81878910d322342d74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh/WV4CRBK7hj4Ov3rIwAAIwEIADcir9ZRb/GWqiwQ7HqUKzXq\nHvjaDTjnTkph/nzFZ9nMtBy+1J+/Sk7J4x3/OuGgdZw0sVanvjkUID0zbyX4jEfr\n/advaZo9HUPe6Ks8EVzhEP5Ss900aHFFrmy1+yagNc+bqirV5K7SJ2dmbJmUUd5s\nLS6KS0RkGfHKde9WEyTUpY9rsz6TldKY2ST5Rjr67vUrwM7B3a6uTQAP0xySJJGy\nBcJpKEXXLUgFcLVTwML5RerEf+wbQta53YgZUe5tLUpBDF0s9Up8y4T7dlUdYTlD\nhynSk8ySHER3+pSZQEmC+8dTwDzost/wQu2aFT4C8+D4Jt1D09GW5d5/UdxsY5g=\n=wDgN\n-----END PGP SIGNATURE-----\n", "payload": "tree 5061121203a1eac8f9fc0035e31859e8831513a9\nparent 3edec8055165d5107bc9695a1f5ded67cdeb7aea\nparent 2826586b91977ce39eb6f82e68abcf7eb0bc6754\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643996536 +0100\ncommitter GitHub <noreply@github.com> 1643996536 +0100\n\nRollup merge of #93608 - nnethercote:speed-up-find_library_crate, r=petrochenkov\n\nClean up `find_library_crate`\n\nSome clean-ups.\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b7f1f5649a7b93c55dcab81878910d322342d74", "html_url": "https://github.com/rust-lang/rust/commit/9b7f1f5649a7b93c55dcab81878910d322342d74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b7f1f5649a7b93c55dcab81878910d322342d74/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3edec8055165d5107bc9695a1f5ded67cdeb7aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3edec8055165d5107bc9695a1f5ded67cdeb7aea", "html_url": "https://github.com/rust-lang/rust/commit/3edec8055165d5107bc9695a1f5ded67cdeb7aea"}, {"sha": "2826586b91977ce39eb6f82e68abcf7eb0bc6754", "url": "https://api.github.com/repos/rust-lang/rust/commits/2826586b91977ce39eb6f82e68abcf7eb0bc6754", "html_url": "https://github.com/rust-lang/rust/commit/2826586b91977ce39eb6f82e68abcf7eb0bc6754"}], "stats": {"total": 157, "additions": 67, "deletions": 90}, "files": [{"sha": "550b22a2a3c657d376cecac2b51f167432388e3b", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=9b7f1f5649a7b93c55dcab81878910d322342d74", "patch": "@@ -223,7 +223,7 @@ use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{struct_span_err, FatalError};\n use rustc_session::config::{self, CrateType};\n use rustc_session::cstore::{CrateSource, MetadataLoader};\n-use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n+use rustc_session::filesearch::FileSearch;\n use rustc_session::search_paths::PathKind;\n use rustc_session::utils::CanonicalizedPath;\n use rustc_session::Session;\n@@ -371,15 +371,20 @@ impl<'a> CrateLocator<'a> {\n         extra_prefix: &str,\n         seen_paths: &mut FxHashSet<PathBuf>,\n     ) -> Result<Option<Library>, CrateError> {\n-        // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}{}\", self.target.dll_prefix, self.crate_name, extra_prefix);\n-        let rlib_prefix = format!(\"lib{}{}\", self.crate_name, extra_prefix);\n+        let rmeta_prefix = &format!(\"lib{}{}\", self.crate_name, extra_prefix);\n+        let rlib_prefix = rmeta_prefix;\n+        let dylib_prefix =\n+            &format!(\"{}{}{}\", self.target.dll_prefix, self.crate_name, extra_prefix);\n         let staticlib_prefix =\n-            format!(\"{}{}{}\", self.target.staticlib_prefix, self.crate_name, extra_prefix);\n+            &format!(\"{}{}{}\", self.target.staticlib_prefix, self.crate_name, extra_prefix);\n+\n+        let rmeta_suffix = \".rmeta\";\n+        let rlib_suffix = \".rlib\";\n+        let dylib_suffix = &self.target.dll_suffix;\n+        let staticlib_suffix = &self.target.staticlib_suffix;\n \n         let mut candidates: FxHashMap<_, (FxHashMap<_, _>, FxHashMap<_, _>, FxHashMap<_, _>)> =\n             Default::default();\n-        let mut staticlibs = vec![];\n \n         // First, find all possible candidate rlibs and dylibs purely based on\n         // the name of the files themselves. We're trying to match against an\n@@ -394,46 +399,50 @@ impl<'a> CrateLocator<'a> {\n         // of the crate id (path/name/id).\n         //\n         // The goal of this step is to look at as little metadata as possible.\n-        self.filesearch.search(|spf, kind| {\n-            let file = match &spf.file_name_str {\n-                None => return FileDoesntMatch,\n-                Some(file) => file,\n-            };\n-            let (hash, found_kind) = if file.starts_with(&rlib_prefix) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n-            } else if file.starts_with(&rlib_prefix) && file.ends_with(\".rmeta\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n-            } else if file.starts_with(&dylib_prefix) && file.ends_with(&self.target.dll_suffix) {\n-                (\n-                    &file[(dylib_prefix.len())..(file.len() - self.target.dll_suffix.len())],\n-                    CrateFlavor::Dylib,\n-                )\n-            } else {\n-                if file.starts_with(&staticlib_prefix)\n-                    && file.ends_with(&self.target.staticlib_suffix)\n-                {\n-                    staticlibs\n-                        .push(CrateMismatch { path: spf.path.clone(), got: \"static\".to_string() });\n-                }\n-                return FileDoesntMatch;\n-            };\n+        // Unfortunately, the prefix-based matching sometimes is over-eager.\n+        // E.g. if `rlib_suffix` is `libstd` it'll match the file\n+        // `libstd_detect-8d6701fb958915ad.rlib` (incorrect) as well as\n+        // `libstd-f3ab5b1dea981f17.rlib` (correct). But this is hard to avoid\n+        // given that `extra_filename` comes from the `-C extra-filename`\n+        // option and thus can be anything, and the incorrect match will be\n+        // handled safely in `extract_one`.\n+        for search_path in self.filesearch.search_paths() {\n+            debug!(\"searching {}\", search_path.dir.display());\n+            for spf in search_path.files.iter() {\n+                debug!(\"testing {}\", spf.path.display());\n+\n+                let f = &spf.file_name_str;\n+                let (hash, kind) = if f.starts_with(rlib_prefix) && f.ends_with(rlib_suffix) {\n+                    (&f[rlib_prefix.len()..(f.len() - rlib_suffix.len())], CrateFlavor::Rlib)\n+                } else if f.starts_with(rmeta_prefix) && f.ends_with(rmeta_suffix) {\n+                    (&f[rmeta_prefix.len()..(f.len() - rmeta_suffix.len())], CrateFlavor::Rmeta)\n+                } else if f.starts_with(dylib_prefix) && f.ends_with(dylib_suffix) {\n+                    (&f[dylib_prefix.len()..(f.len() - dylib_suffix.len())], CrateFlavor::Dylib)\n+                } else {\n+                    if f.starts_with(staticlib_prefix) && f.ends_with(staticlib_suffix) {\n+                        self.crate_rejections.via_kind.push(CrateMismatch {\n+                            path: spf.path.clone(),\n+                            got: \"static\".to_string(),\n+                        });\n+                    }\n+                    continue;\n+                };\n \n-            info!(\"lib candidate: {}\", spf.path.display());\n+                info!(\"lib candidate: {}\", spf.path.display());\n \n-            let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-            let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n-            if seen_paths.contains(&path) {\n-                return FileDoesntMatch;\n-            };\n-            seen_paths.insert(path.clone());\n-            match found_kind {\n-                CrateFlavor::Rlib => rlibs.insert(path, kind),\n-                CrateFlavor::Rmeta => rmetas.insert(path, kind),\n-                CrateFlavor::Dylib => dylibs.insert(path, kind),\n-            };\n-            FileMatches\n-        });\n-        self.crate_rejections.via_kind.extend(staticlibs);\n+                let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n+                let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+                if seen_paths.contains(&path) {\n+                    continue;\n+                };\n+                seen_paths.insert(path.clone());\n+                match kind {\n+                    CrateFlavor::Rlib => rlibs.insert(path, search_path.kind),\n+                    CrateFlavor::Rmeta => rmetas.insert(path, search_path.kind),\n+                    CrateFlavor::Dylib => dylibs.insert(path, search_path.kind),\n+                };\n+            }\n+        }\n \n         // We have now collected all known libraries into a set of candidates\n         // keyed of the filename hash listed. For each filename, we also have a"}, {"sha": "9200be363addec569720abb729430f2e64ce633f", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=9b7f1f5649a7b93c55dcab81878910d322342d74", "patch": "@@ -1,13 +1,11 @@\n //! A module for searching for libraries\n \n-pub use self::FileMatch::*;\n-\n use std::env;\n use std::fs;\n use std::iter::FromIterator;\n use std::path::{Path, PathBuf};\n \n-use crate::search_paths::{PathKind, SearchPath, SearchPathFile};\n+use crate::search_paths::{PathKind, SearchPath};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use tracing::debug;\n \n@@ -43,36 +41,6 @@ impl<'a> FileSearch<'a> {\n         self.get_lib_path().join(\"self-contained\")\n     }\n \n-    pub fn search<F>(&self, mut pick: F)\n-    where\n-        F: FnMut(&SearchPathFile, PathKind) -> FileMatch,\n-    {\n-        for search_path in self.search_paths() {\n-            debug!(\"searching {}\", search_path.dir.display());\n-            fn is_rlib(spf: &SearchPathFile) -> bool {\n-                if let Some(f) = &spf.file_name_str { f.ends_with(\".rlib\") } else { false }\n-            }\n-            // Reading metadata out of rlibs is faster, and if we find both\n-            // an rlib and a dylib we only read one of the files of\n-            // metadata, so in the name of speed, bring all rlib files to\n-            // the front of the search list.\n-            let files1 = search_path.files.iter().filter(|spf| is_rlib(&spf));\n-            let files2 = search_path.files.iter().filter(|spf| !is_rlib(&spf));\n-            for spf in files1.chain(files2) {\n-                debug!(\"testing {}\", spf.path.display());\n-                let maybe_picked = pick(spf, search_path.kind);\n-                match maybe_picked {\n-                    FileMatches => {\n-                        debug!(\"picked {}\", spf.path.display());\n-                    }\n-                    FileDoesntMatch => {\n-                        debug!(\"rejected {}\", spf.path.display());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn new(\n         sysroot: &'a Path,\n         triple: &'a str,"}, {"sha": "b6bde28233d243bc2ad86c0e5619111f3bc1d6d7", "filename": "compiler/rustc_session/src/search_paths.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b7f1f5649a7b93c55dcab81878910d322342d74/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs?ref=9b7f1f5649a7b93c55dcab81878910d322342d74", "patch": "@@ -15,22 +15,15 @@ pub struct SearchPath {\n /// doable, but very slow, because it involves calls to `file_name` and\n /// `extension` that are themselves slow.\n ///\n-/// This type augments the `PathBuf` with an `Option<String>` containing the\n+/// This type augments the `PathBuf` with an `String` containing the\n /// `PathBuf`'s filename. The prefix and suffix checking is much faster on the\n-/// `Option<String>` than the `PathBuf`. (It's an `Option` because\n-/// `Path::file_name` can fail; if that happens then all subsequent checking\n-/// will also fail, which is fine.)\n+/// `String` than the `PathBuf`. (The filename must be valid UTF-8. If it's\n+/// not, the entry should be skipped, because all Rust output files are valid\n+/// UTF-8, and so a non-UTF-8 filename couldn't be one we're looking for.)\n #[derive(Clone, Debug)]\n pub struct SearchPathFile {\n     pub path: PathBuf,\n-    pub file_name_str: Option<String>,\n-}\n-\n-impl SearchPathFile {\n-    fn new(path: PathBuf) -> SearchPathFile {\n-        let file_name_str = path.file_name().and_then(|f| f.to_str()).map(|s| s.to_string());\n-        SearchPathFile { path, file_name_str }\n-    }\n+    pub file_name_str: String,\n }\n \n #[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, Encodable, Decodable)]\n@@ -85,7 +78,14 @@ impl SearchPath {\n         // Get the files within the directory.\n         let files = match std::fs::read_dir(&dir) {\n             Ok(files) => files\n-                .filter_map(|e| e.ok().map(|e| SearchPathFile::new(e.path())))\n+                .filter_map(|e| {\n+                    e.ok().and_then(|e| {\n+                        e.file_name().to_str().map(|s| SearchPathFile {\n+                            path: e.path(),\n+                            file_name_str: s.to_string(),\n+                        })\n+                    })\n+                })\n                 .collect::<Vec<_>>(),\n             Err(..) => vec![],\n         };"}]}