{"sha": "ab4764520c41a5ef5e0987b69e1673445bc40d0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNDc2NDUyMGM0MWE1ZWY1ZTA5ODdiNjllMTY3MzQ0NWJjNDBkMGY=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-02T19:22:17Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-08-02T21:46:02Z"}, "message": "Allow patterns of the form `[a, b, c ...] to be matched and transcribed.", "tree": {"sha": "ef996f561fff859f35da54758e43afc2228a6de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef996f561fff859f35da54758e43afc2228a6de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab4764520c41a5ef5e0987b69e1673445bc40d0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4764520c41a5ef5e0987b69e1673445bc40d0f", "html_url": "https://github.com/rust-lang/rust/commit/ab4764520c41a5ef5e0987b69e1673445bc40d0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab4764520c41a5ef5e0987b69e1673445bc40d0f/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea2a9681460c112e968a54f0d3378a0fab40e7b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2a9681460c112e968a54f0d3378a0fab40e7b1", "html_url": "https://github.com/rust-lang/rust/commit/ea2a9681460c112e968a54f0d3378a0fab40e7b1"}], "stats": {"total": 170, "additions": 99, "deletions": 71}, "files": [{"sha": "4e5470945440ed68fafc63736bfd3f83a6436c83", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 80, "deletions": 62, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -93,19 +93,20 @@ fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n type match_result = option::t[arb_depth[matchable]];\n type selector = fn(&matchable) -> match_result ;\n \n-fn elts_to_ell(cx: &ext_ctxt, elts: &(@expr)[]) -> option::t[@expr] {\n+fn elts_to_ell(cx: &ext_ctxt, elts: &(@expr)[])\n+    -> {fixed: (@expr)[], rep: option::t[@expr]} {\n     let idx: uint = 0u;\n     for elt: @expr  in elts {\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n               ast::mac_ellipsis. {\n-                if idx != 1u || ivec::len(elts) != 2u {\n-                    cx.span_fatal(m.span,\n-                                  \"Ellpisis may only appear\" +\n-                                      \" after exactly 1 item.\");\n+                let last = ivec::len(elts) - 1u;\n+                if idx != last {\n+                    cx.span_fatal(m.span, \"ellipses must occur last\");\n                 }\n-                ret some(elts.(0));\n+                ret {fixed: ivec::slice(elts, 0u, last - 1u),\n+                     rep: some(elts.(last - 1u))};\n               }\n               _ { }\n             }\n@@ -114,7 +115,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &(@expr)[]) -> option::t[@expr] {\n         }\n         idx += 1u;\n     }\n-    ret none;\n+    ret {fixed: elts, rep: none};\n }\n \n fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &vec[T]) ->\n@@ -271,57 +272,60 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable vec[uint],\n-                    recur: fn(&@expr) -> @expr , exprs: (@expr)[]) ->\n-   (@expr)[] {\n+                    recur: fn(&@expr) -> @expr , exprs: (@expr)[])\n+    -> (@expr)[] {\n     alt elts_to_ell(cx, exprs) {\n-      some(repeat_me) {\n-        let repeat: option::t[{rep_count: uint, name: ident}] = none;\n-        /* we need to walk over all the free vars in lockstep, except for\n-        the leaves, which are just duplicated */\n-        for each fv: ident  in free_vars(b, repeat_me) {\n-            let cur_pos = follow(b.get(fv), idx_path);\n-            alt cur_pos {\n-              leaf(_) { }\n-              seq(ms, _) {\n-                alt repeat {\n-                  none. {\n-                    repeat = some({rep_count: vec::len(ms), name: fv});\n-                  }\n-                  some({rep_count: old_len, name: old_name}) {\n-                    let len = vec::len(ms);\n-                    if old_len != len {\n-                        cx.span_fatal(repeat_me.span,\n-                                      #fmt(\"'%s' occurs %u times, but \", fv,\n-                                           len) +\n-                                          #fmt(\"'%s' occurs %u times\",\n-                                               old_name, old_len));\n+      {fixed: fixed, rep: repeat_me_maybe} {\n+        let res = ivec::map(recur, fixed);\n+        alt repeat_me_maybe {\n+          none. {}\n+          some(repeat_me) {\n+            let repeat: option::t[{rep_count: uint, name: ident}] = none;\n+            /* we need to walk over all the free vars in lockstep, except for\n+            the leaves, which are just duplicated */\n+            for each fv: ident  in free_vars(b, repeat_me) {\n+                let cur_pos = follow(b.get(fv), idx_path);\n+                alt cur_pos {\n+                  leaf(_) { }\n+                  seq(ms, _) {\n+                    alt repeat {\n+                      none. {\n+                        repeat = some({rep_count: vec::len(ms), name: fv});\n+                      }\n+                      some({rep_count: old_len, name: old_name}) {\n+                        let len = vec::len(ms);\n+                        if old_len != len {\n+                            let msg = #fmt(\"'%s' occurs %u times, but \", fv,\n+                                           len) + #fmt(\"'%s' occurs %u times\",\n+                                                       old_name, old_len);\n+                            cx.span_fatal(repeat_me.span, msg);\n+                        }\n+                      }\n                     }\n                   }\n                 }\n-              }\n             }\n-        }\n-        let res = ~[];\n-        alt repeat {\n-          none. {\n-            cx.span_fatal(repeat_me.span,\n-                          \"'...' surrounds an expression without any\" +\n+            alt repeat {\n+              none. {\n+                cx.span_fatal(repeat_me.span,\n+                              \"'...' surrounds an expression without any\" +\n                               \" repeating syntax variables\");\n-          }\n-          some({rep_count: rc, _}) {\n-            /* Whew, we now know how how many times to repeat */\n-            let idx: uint = 0u;\n-            while idx < rc {\n-                vec::push(*idx_path, idx);\n-                res += ~[recur(repeat_me)]; // whew!\n-                vec::pop(*idx_path);\n-                idx += 1u;\n+              }\n+              some({rep_count: rc, _}) {\n+                /* Whew, we now know how how many times to repeat */\n+                let idx: uint = 0u;\n+                while idx < rc {\n+                    vec::push(*idx_path, idx);\n+                    res += ~[recur(repeat_me)]; // whew!\n+                    vec::pop(*idx_path);\n+                    idx += 1u;\n+                }\n+              }\n             }\n           }\n         }\n         ret res;\n       }\n-      none. { ret ivec::map(recur, exprs); }\n     }\n }\n \n@@ -436,8 +440,15 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n           expr_path(p_pth) { p_t_s_r_path(cx, p_pth, s, b); }\n           expr_vec(p_elts, _, _) {\n             alt elts_to_ell(cx, p_elts) {\n-              some(repeat_me) { p_t_s_r_ellipses(cx, repeat_me, s, b); }\n-              none. { p_t_s_r_actual_vector(cx, p_elts, s, b); }\n+              {fixed: fixed, rep: some(repeat_me)} {\n+                if(ivec::len(fixed) > 0u) {\n+                    p_t_s_r_actual_vector(cx, fixed, true, s, b);\n+                }\n+                p_t_s_r_ellipses(cx, repeat_me, ivec::len(fixed), s, b);\n+              }\n+              {fixed: fixed, rep: none.} {\n+                p_t_s_r_actual_vector(cx, fixed, false, s, b);\n+              }\n             }\n           }\n \n@@ -575,20 +586,23 @@ fn ivec_to_vec[T](v: &T[]) -> vec[T] {\n     ret rs;\n }\n \n-fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, s: &selector,\n-                    b: &binders) {\n-    fn select(cx: &ext_ctxt, repeat_me: @expr, m: &matchable) ->\n+fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n+                    s: &selector, b: &binders) {\n+    fn select(cx: &ext_ctxt, repeat_me: @expr, offset: uint, m: &matchable) ->\n         match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _, _) {\n-                    let elts =\n-                        ivec::map(leaf, ivec::map(match_expr, arg_elts));\n-\n+                    let elts = [];\n+                    let idx = offset;\n+                    while idx < ivec::len(arg_elts) {\n+                        elts += [leaf(match_expr(arg_elts.(idx)))];\n+                        idx += 1u;\n+                    }\n                     // using repeat_me.span is a little wacky, but the\n                     // error we want to report is one in the macro def\n-                    some(seq(ivec_to_vec(elts), repeat_me.span))\n+                    some(seq(elts, repeat_me.span))\n                   }\n                   _ { none }\n                 }\n@@ -597,17 +611,20 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, s: &selector,\n             }\n     }\n     p_t_s_rec(cx, match_expr(repeat_me),\n-              compose_sels(s, bind select(cx, repeat_me, _)), b);\n+              compose_sels(s, bind select(cx, repeat_me, offset, _)), b);\n }\n \n-fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], s: &selector,\n-                         b: &binders) {\n-    fn len_select(cx: &ext_ctxt, m: &matchable, len: uint) -> match_result {\n+fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], repeat_after: bool,\n+                         s: &selector, b: &binders) {\n+    fn len_select(cx: &ext_ctxt, m: &matchable, repeat_after: bool, len: uint)\n+        -> match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _, _) {\n-                    if ivec::len(arg_elts) == len {\n+                    let actual_len = ivec::len(arg_elts);\n+                    if (repeat_after && actual_len >= len)\n+                        || actual_len == len {\n                         some(leaf(match_exact))\n                     } else { none }\n                   }\n@@ -618,7 +635,8 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: (@expr)[], s: &selector,\n             }\n     }\n     b.literal_ast_matchers +=\n-        ~[compose_sels(s, bind len_select(cx, _, ivec::len(elts)))];\n+        ~[compose_sels(s, bind len_select(cx, _, repeat_after,\n+                                          ivec::len(elts)))];\n \n \n     let idx: uint = 0u;"}, {"sha": "5a3973c79e3b13f466aa84b60822a92b6c3c2ca9", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n \n fn main() {\n-  #macro([#mylambda(x,body), {fn f(x: int) -> int { ret body }; f}]);\n+  #macro([#mylambda[x,body], {fn f(x: int) -> int { ret body }; f}]);\n \n-  assert(#mylambda(y,y*2)(8) == 16);\n+  assert(#mylambda[y,y*2](8) == 16);\n }\n\\ No newline at end of file"}, {"sha": "ab4599327b9f535792b79b7e7c39de16536d84f8", "filename": "src/test/run-pass/macro-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-3.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -1,7 +1,7 @@\n // xfail-stage0\n \n fn main() {\n-  #macro([#trivial(), 1*2*4*2*1]);\n+  #macro([#trivial[], 1*2*4*2*1]);\n \n-  assert(#trivial() == 16);\n+  assert(#trivial[] == 16);\n }"}, {"sha": "08e5c4e249f62f837e1681f8601c8eafe22c63e7", "filename": "src/test/run-pass/macro-by-example-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n-    #macro([#apply(f, [x, ...]), f(x, ...)]);\n+    #macro([#apply[f, [x, ...]], f(x, ...)]);\n \n     fn add(a: int, b: int) -> int { ret a + b; }\n \n-    assert (#apply(add, [1, 15]) == 16);\n+    assert (#apply[add, [1, 15]] == 16);\n }\n\\ No newline at end of file"}, {"sha": "382d06be37b424b1aeb169495597adef356dd419", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -31,6 +31,16 @@ fn main() {\n             }]);\n \n \n-    assert ((#lambda[i, #<uint>, i + 4u, #<uint>])(12u) == 16u)\n+    assert ((#lambda[i, #<uint>, i + 4u, #<uint>])(12u) == 16u);\n+\n+    #macro[[#sum[x, xs, ...], x + #sum[xs, ...]],\n+           [#sum[], 0]];\n+\n+    assert (#sum[1,2,3,4] == 10);\n+\n+\n+    #macro[[#transcr_mixed[a, as, ...], #sum[6, as, ...] * a]];\n+\n+    assert (#transcr_mixed[10, 5, 4, 3, 2, 1] == 210);\n \n }\n\\ No newline at end of file"}, {"sha": "9f001e93d2fc55f52890e45f8a6de6da790b48d1", "filename": "src/test/run-pass/macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab4764520c41a5ef5e0987b69e1673445bc40d0f/src%2Ftest%2Frun-pass%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro.rs?ref=ab4764520c41a5ef5e0987b69e1673445bc40d0f", "patch": "@@ -1,6 +1,6 @@\n // xfail-stage0\n \n fn main() {\n-  #macro([#m1(a), a*4]);\n-  assert (#m1(2) == 8);\n+  #macro[[#m1[a], a*4]];\n+  assert (#m1[2] == 8);\n }"}]}