{"sha": "2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiN2JjMjYwZGUzZmVkZDk0ZDQxMzRiM2UzYmRhNDhmNjBjNWZkMTc=", "commit": {"author": {"name": "Mikhail Babenko", "email": "misha-babenko@yandex.ru", "date": "2020-01-23T14:52:41Z"}, "committer": {"name": "Mikhail Babenko", "email": "misha-babenko@yandex.ru", "date": "2020-01-25T15:06:52Z"}, "message": "add size parameter for  lint", "tree": {"sha": "5a138e852b5a5eeab6ff7e00b47d7594947f80d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a138e852b5a5eeab6ff7e00b47d7594947f80d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "html_url": "https://github.com/rust-lang/rust/commit/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/comments", "author": {"login": "basil-cow", "id": 25266609, "node_id": "MDQ6VXNlcjI1MjY2NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/25266609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/basil-cow", "html_url": "https://github.com/basil-cow", "followers_url": "https://api.github.com/users/basil-cow/followers", "following_url": "https://api.github.com/users/basil-cow/following{/other_user}", "gists_url": "https://api.github.com/users/basil-cow/gists{/gist_id}", "starred_url": "https://api.github.com/users/basil-cow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/basil-cow/subscriptions", "organizations_url": "https://api.github.com/users/basil-cow/orgs", "repos_url": "https://api.github.com/users/basil-cow/repos", "events_url": "https://api.github.com/users/basil-cow/events{/privacy}", "received_events_url": "https://api.github.com/users/basil-cow/received_events", "type": "User", "site_admin": false}, "committer": {"login": "basil-cow", "id": 25266609, "node_id": "MDQ6VXNlcjI1MjY2NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/25266609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/basil-cow", "html_url": "https://github.com/basil-cow", "followers_url": "https://api.github.com/users/basil-cow/followers", "following_url": "https://api.github.com/users/basil-cow/following{/other_user}", "gists_url": "https://api.github.com/users/basil-cow/gists{/gist_id}", "starred_url": "https://api.github.com/users/basil-cow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/basil-cow/subscriptions", "organizations_url": "https://api.github.com/users/basil-cow/orgs", "repos_url": "https://api.github.com/users/basil-cow/repos", "events_url": "https://api.github.com/users/basil-cow/events{/privacy}", "received_events_url": "https://api.github.com/users/basil-cow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff3bc5e1ee9e25532f1db2bf423eb8d8458bd94", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff3bc5e1ee9e25532f1db2bf423eb8d8458bd94", "html_url": "https://github.com/rust-lang/rust/commit/eff3bc5e1ee9e25532f1db2bf423eb8d8458bd94"}], "stats": {"total": 439, "additions": 251, "deletions": 188}, "files": [{"sha": "7e05166b1a68cd610e4b822519a9cf377eab0eca", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -818,7 +818,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n     store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n     store.register_late_pass(|| box utils::author::Author);\n-    store.register_late_pass(|| box types::Types);\n+    let vec_box_size_threshold = conf.vec_box_size_threshold;\n+    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold));\n     store.register_late_pass(|| box booleans::NonminimalBool);\n     store.register_late_pass(|| box eq_op::EqOp);\n     store.register_late_pass(|| box enum_glob_use::EnumGlobUse);"}, {"sha": "b271b58d903b7f020b6890f0c9a180217feac8f2", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 199, "deletions": 181, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -167,7 +167,11 @@ declare_clippy_lint! {\n     \"a borrow of a boxed type\"\n }\n \n-declare_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX]);\n+pub struct Types {\n+    vec_box_size_threshold: u64,\n+}\n+\n+impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n     fn check_fn(\n@@ -186,38 +190,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n             }\n         }\n \n-        check_fn_decl(cx, decl);\n+        self.check_fn_decl(cx, decl);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField<'_>) {\n-        check_ty(cx, &field.ty, false);\n+        self.check_ty(cx, &field.ty, false);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &TraitItem<'_>) {\n         match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty, false),\n-            TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n+            TraitItemKind::Method(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local<'_>) {\n         if let Some(ref ty) = local.ty {\n-            check_ty(cx, ty, true);\n+            self.check_ty(cx, ty, true);\n         }\n     }\n }\n \n-fn check_fn_decl(cx: &LateContext<'_, '_>, decl: &FnDecl<'_>) {\n-    for input in decl.inputs {\n-        check_ty(cx, input, false);\n-    }\n-\n-    if let FunctionRetTy::Return(ref ty) = decl.output {\n-        check_ty(cx, ty, false);\n-    }\n-}\n-\n /// Checks if `qpath` has last segment with type parameter matching `path`\n fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, path: &[&str]) -> bool {\n     let last = last_path_segment(qpath);\n@@ -238,54 +232,71 @@ fn match_type_parameter(cx: &LateContext<'_, '_>, qpath: &QPath<'_>, path: &[&st\n     false\n }\n \n-/// Recursively check for `TypePass` lints in the given type. Stop at the first\n-/// lint found.\n-///\n-/// The parameter `is_local` distinguishes the context of the type; types from\n-/// local bindings should only be checked for the `BORROWED_BOX` lint.\n-#[allow(clippy::too_many_lines)]\n-fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n-    if hir_ty.span.from_expansion() {\n-        return;\n+impl Types {\n+    pub fn new(vec_box_size_threshold: u64) -> Self {\n+        Self { vec_box_size_threshold }\n     }\n-    match hir_ty.kind {\n-        TyKind::Path(ref qpath) if !is_local => {\n-            let hir_id = hir_ty.hir_id;\n-            let res = qpath_res(cx, qpath, hir_id);\n-            if let Some(def_id) = res.opt_def_id() {\n-                if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                    if match_type_parameter(cx, qpath, &paths::VEC) {\n-                        span_help_and_lint(\n-                            cx,\n-                            BOX_VEC,\n-                            hir_ty.span,\n-                            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n-                        );\n-                        return; // don't recurse into the type\n-                    }\n-                } else if cx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id) {\n-                    if_chain! {\n-                        // Get the _ part of Vec<_>\n-                        if let Some(ref last) = last_path_segment(qpath).args;\n-                        if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty),\n-                            _ => None,\n-                        });\n-                        // ty is now _ at this point\n-                        if let TyKind::Path(ref ty_qpath) = ty.kind;\n-                        let res = qpath_res(cx, ty_qpath, ty.hir_id);\n-                        if let Some(def_id) = res.opt_def_id();\n-                        if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                        // At this point, we know ty is Box<T>, now get T\n-                        if let Some(ref last) = last_path_segment(ty_qpath).args;\n-                        if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty),\n-                            _ => None,\n-                        });\n-                        then {\n+\n+    fn check_fn_decl(&mut self, cx: &LateContext<'_, '_>, decl: &FnDecl<'_>) {\n+        for input in decl.inputs {\n+            self.check_ty(cx, input, false);\n+        }\n+\n+        if let FunctionRetTy::Return(ref ty) = decl.output {\n+            self.check_ty(cx, ty, false);\n+        }\n+    }\n+\n+    /// Recursively check for `TypePass` lints in the given type. Stop at the first\n+    /// lint found.\n+    ///\n+    /// The parameter `is_local` distinguishes the context of the type; types from\n+    /// local bindings should only be checked for the `BORROWED_BOX` lint.\n+    #[allow(clippy::too_many_lines)]\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n+        if hir_ty.span.from_expansion() {\n+            return;\n+        }\n+        match hir_ty.kind {\n+            TyKind::Path(ref qpath) if !is_local => {\n+                let hir_id = hir_ty.hir_id;\n+                let res = qpath_res(cx, qpath, hir_id);\n+                if let Some(def_id) = res.opt_def_id() {\n+                    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+                        if match_type_parameter(cx, qpath, &paths::VEC) {\n+                            span_help_and_lint(\n+                                cx,\n+                                BOX_VEC,\n+                                hir_ty.span,\n+                                \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\",\n+                            );\n+                            return; // don't recurse into the type\n+                        }\n+                    } else if cx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id) {\n+                        if_chain! {\n+                            // Get the _ part of Vec<_>\n+                            if let Some(ref last) = last_path_segment(qpath).args;\n+                            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                _ => None,\n+                            });\n+                            // ty is now _ at this point\n+                            if let TyKind::Path(ref ty_qpath) = ty.kind;\n+                            let res = qpath_res(cx, ty_qpath, ty.hir_id);\n+                            if let Some(def_id) = res.opt_def_id();\n+                            if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                            // At this point, we know ty is Box<T>, now get T\n+                            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+                            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n+                                GenericArg::Type(ty) => Some(ty),\n+                                _ => None,\n+                            });\n                             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n-                            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env) {\n+                            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+                            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n+                            if ty_ty_size <= self.vec_box_size_threshold;\n+                            then {\n                                 span_lint_and_sugg(\n                                     cx,\n                                     VEC_BOX,\n@@ -298,137 +309,144 @@ fn check_ty(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n                                 return; // don't recurse into the type\n                             }\n                         }\n-                    }\n-                } else if match_def_path(cx, def_id, &paths::OPTION) {\n-                    if match_type_parameter(cx, qpath, &paths::OPTION) {\n-                        span_lint(\n+                    } else if match_def_path(cx, def_id, &paths::OPTION) {\n+                        if match_type_parameter(cx, qpath, &paths::OPTION) {\n+                            span_lint(\n+                                cx,\n+                                OPTION_OPTION,\n+                                hir_ty.span,\n+                                \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                                enum if you need to distinguish all 3 cases\",\n+                            );\n+                            return; // don't recurse into the type\n+                        }\n+                    } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n+                        span_help_and_lint(\n                             cx,\n-                            OPTION_OPTION,\n+                            LINKEDLIST,\n                             hir_ty.span,\n-                            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                             enum if you need to distinguish all 3 cases\",\n+                            \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                            \"a `VecDeque` might work\",\n                         );\n                         return; // don't recurse into the type\n                     }\n-                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n-                    span_help_and_lint(\n-                        cx,\n-                        LINKEDLIST,\n-                        hir_ty.span,\n-                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                        \"a `VecDeque` might work\",\n-                    );\n-                    return; // don't recurse into the type\n                 }\n-            }\n-            match *qpath {\n-                QPath::Resolved(Some(ref ty), ref p) => {\n-                    check_ty(cx, ty, is_local);\n-                    for ty in p.segments.iter().flat_map(|seg| {\n-                        seg.args\n-                            .as_ref()\n-                            .map_or_else(|| [].iter(), |params| params.args.iter())\n-                            .filter_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            })\n-                    }) {\n-                        check_ty(cx, ty, is_local);\n-                    }\n-                },\n-                QPath::Resolved(None, ref p) => {\n-                    for ty in p.segments.iter().flat_map(|seg| {\n-                        seg.args\n-                            .as_ref()\n-                            .map_or_else(|| [].iter(), |params| params.args.iter())\n-                            .filter_map(|arg| match arg {\n+                match *qpath {\n+                    QPath::Resolved(Some(ref ty), ref p) => {\n+                        self.check_ty(cx, ty, is_local);\n+                        for ty in p.segments.iter().flat_map(|seg| {\n+                            seg.args\n+                                .as_ref()\n+                                .map_or_else(|| [].iter(), |params| params.args.iter())\n+                                .filter_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty),\n+                                    _ => None,\n+                                })\n+                        }) {\n+                            self.check_ty(cx, ty, is_local);\n+                        }\n+                    },\n+                    QPath::Resolved(None, ref p) => {\n+                        for ty in p.segments.iter().flat_map(|seg| {\n+                            seg.args\n+                                .as_ref()\n+                                .map_or_else(|| [].iter(), |params| params.args.iter())\n+                                .filter_map(|arg| match arg {\n+                                    GenericArg::Type(ty) => Some(ty),\n+                                    _ => None,\n+                                })\n+                        }) {\n+                            self.check_ty(cx, ty, is_local);\n+                        }\n+                    },\n+                    QPath::TypeRelative(ref ty, ref seg) => {\n+                        self.check_ty(cx, ty, is_local);\n+                        if let Some(ref params) = seg.args {\n+                            for ty in params.args.iter().filter_map(|arg| match arg {\n                                 GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n-                            })\n-                    }) {\n-                        check_ty(cx, ty, is_local);\n-                    }\n-                },\n-                QPath::TypeRelative(ref ty, ref seg) => {\n-                    check_ty(cx, ty, is_local);\n-                    if let Some(ref params) = seg.args {\n-                        for ty in params.args.iter().filter_map(|arg| match arg {\n-                            GenericArg::Type(ty) => Some(ty),\n-                            _ => None,\n-                        }) {\n-                            check_ty(cx, ty, is_local);\n+                            }) {\n+                                self.check_ty(cx, ty, is_local);\n+                            }\n                         }\n-                    }\n-                },\n-            }\n-        },\n-        TyKind::Rptr(ref lt, ref mut_ty) => check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n-        // recurse\n-        TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n-            check_ty(cx, ty, is_local)\n-        },\n-        TyKind::Tup(tys) => {\n-            for ty in tys {\n-                check_ty(cx, ty, is_local);\n-            }\n-        },\n-        _ => {},\n+                    },\n+                }\n+            },\n+            TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n+            // recurse\n+            TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n+                self.check_ty(cx, ty, is_local)\n+            },\n+            TyKind::Tup(tys) => {\n+                for ty in tys {\n+                    self.check_ty(cx, ty, is_local);\n+                }\n+            },\n+            _ => {},\n+        }\n     }\n-}\n \n-fn check_ty_rptr(cx: &LateContext<'_, '_>, hir_ty: &hir::Ty<'_>, is_local: bool, lt: &Lifetime, mut_ty: &MutTy<'_>) {\n-    match mut_ty.ty.kind {\n-        TyKind::Path(ref qpath) => {\n-            let hir_id = mut_ty.ty.hir_id;\n-            let def = qpath_res(cx, qpath, hir_id);\n-            if_chain! {\n-                if let Some(def_id) = def.opt_def_id();\n-                if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                if let QPath::Resolved(None, ref path) = *qpath;\n-                if let [ref bx] = *path.segments;\n-                if let Some(ref params) = bx.args;\n-                if !params.parenthesized;\n-                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                    GenericArg::Type(ty) => Some(ty),\n-                    _ => None,\n-                });\n-                then {\n-                    if is_any_trait(inner) {\n-                        // Ignore `Box<Any>` types; see issue #1884 for details.\n-                        return;\n-                    }\n+    fn check_ty_rptr(\n+        &mut self,\n+        cx: &LateContext<'_, '_>,\n+        hir_ty: &hir::Ty<'_>,\n+        is_local: bool,\n+        lt: &Lifetime,\n+        mut_ty: &MutTy<'_>,\n+    ) {\n+        match mut_ty.ty.kind {\n+            TyKind::Path(ref qpath) => {\n+                let hir_id = mut_ty.ty.hir_id;\n+                let def = qpath_res(cx, qpath, hir_id);\n+                if_chain! {\n+                    if let Some(def_id) = def.opt_def_id();\n+                    if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                    if let QPath::Resolved(None, ref path) = *qpath;\n+                    if let [ref bx] = *path.segments;\n+                    if let Some(ref params) = bx.args;\n+                    if !params.parenthesized;\n+                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                        GenericArg::Type(ty) => Some(ty),\n+                        _ => None,\n+                    });\n+                    then {\n+                        if is_any_trait(inner) {\n+                            // Ignore `Box<Any>` types; see issue #1884 for details.\n+                            return;\n+                        }\n \n-                    let ltopt = if lt.is_elided() {\n-                        String::new()\n-                    } else {\n-                        format!(\"{} \", lt.name.ident().as_str())\n-                    };\n-                    let mutopt = if mut_ty.mutbl == Mutability::Mut {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    let mut applicability = Applicability::MachineApplicable;\n-                    span_lint_and_sugg(\n-                        cx,\n-                        BORROWED_BOX,\n-                        hir_ty.span,\n-                        \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                        \"try\",\n-                        format!(\n-                            \"&{}{}{}\",\n-                            ltopt,\n-                            mutopt,\n-                            &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)\n-                        ),\n-                        Applicability::Unspecified,\n-                    );\n-                    return; // don't recurse into the type\n-                }\n-            };\n-            check_ty(cx, &mut_ty.ty, is_local);\n-        },\n-        _ => check_ty(cx, &mut_ty.ty, is_local),\n+                        let ltopt = if lt.is_elided() {\n+                            String::new()\n+                        } else {\n+                            format!(\"{} \", lt.name.ident().as_str())\n+                        };\n+                        let mutopt = if mut_ty.mutbl == Mutability::Mut {\n+                            \"mut \"\n+                        } else {\n+                            \"\"\n+                        };\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            BORROWED_BOX,\n+                            hir_ty.span,\n+                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                            \"try\",\n+                            format!(\n+                                \"&{}{}{}\",\n+                                ltopt,\n+                                mutopt,\n+                                &snippet_with_applicability(cx, inner.span, \"..\", &mut applicability)\n+                            ),\n+                            Applicability::Unspecified,\n+                        );\n+                        return; // don't recurse into the type\n+                    }\n+                };\n+                self.check_ty(cx, &mut_ty.ty, is_local);\n+            },\n+            _ => self.check_ty(cx, &mut_ty.ty, is_local),\n+        }\n     }\n }\n "}, {"sha": "2b7c6d8920c45a6ced8f6fa62bbf34a71bc9d869", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -152,6 +152,8 @@ define_Conf! {\n     (too_many_lines_threshold, \"too_many_lines_threshold\", 100 => u64),\n     /// Lint: LARGE_STACK_ARRAYS. The maximum allowed size for arrays on the stack\n     (array_size_threshold, \"array_size_threshold\", 512_000 => u64),\n+    /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n+    (vec_box_size_threshold, \"vec_box_size_threshold\", 4096 => u64),\n }\n \n impl Default for Conf {"}, {"sha": "9eebc0bcf3fe5be7cc721fd9ee6ae5e3efd3cfd0", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "039ea47fc32d888f3a6233ab476d11eba84566e2", "filename": "tests/ui-toml/vec_box_sized/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fvec_box_sized%2Fclippy.toml?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -0,0 +1 @@\n+vec-box-size-threshold = 4"}, {"sha": "bf04bee16373c3c9e22f09bc896632540e6705f5", "filename": "tests/ui-toml/vec_box_sized/test.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fvec_box_sized%2Ftest.rs?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -0,0 +1,15 @@\n+struct S {\n+    x: u64,\n+}\n+\n+struct C {\n+    y: u16,\n+}\n+\n+struct Foo(Vec<Box<u8>>);\n+struct Bar(Vec<Box<u32>>);\n+struct Baz(Vec<Box<(u32, u32)>>);\n+struct BarBaz(Vec<Box<S>>);\n+struct FooBarBaz(Vec<Box<C>>);\n+\n+fn main() {}"}, {"sha": "3bdeca0bc8774a77fdd77f42f0ccdfd23fc03bc5", "filename": "tests/ui-toml/vec_box_sized/test.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fvec_box_sized%2Ftest.stderr?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -0,0 +1,22 @@\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+  --> $DIR/test.rs:9:12\n+   |\n+LL | struct Foo(Vec<Box<u8>>);\n+   |            ^^^^^^^^^^^^ help: try: `Vec<u8>`\n+   |\n+   = note: `-D clippy::vec-box` implied by `-D warnings`\n+\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+  --> $DIR/test.rs:10:12\n+   |\n+LL | struct Bar(Vec<Box<u32>>);\n+   |            ^^^^^^^^^^^^^ help: try: `Vec<u32>`\n+\n+error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n+  --> $DIR/test.rs:13:18\n+   |\n+LL | struct FooBarBaz(Vec<Box<C>>);\n+   |                  ^^^^^^^^^^^ help: try: `Vec<C>`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "d0bee2460dd843993f9bd2d9035446f803638cb6", "filename": "tests/ui/vec_box_sized.fixed", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.fixed?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -4,6 +4,7 @@\n \n struct SizedStruct(i32);\n struct UnsizedStruct([i32]);\n+struct BigStruct([i32; 10000]);\n \n /// The following should trigger the lint\n mod should_trigger {\n@@ -19,9 +20,10 @@ mod should_trigger {\n \n /// The following should not trigger the lint\n mod should_not_trigger {\n-    use super::UnsizedStruct;\n+    use super::{BigStruct, UnsizedStruct};\n \n     struct C(Vec<Box<UnsizedStruct>>);\n+    struct D(Vec<Box<BigStruct>>);\n \n     struct StructWithVecBoxButItsUnsized {\n         unsized_type: Vec<Box<UnsizedStruct>>,"}, {"sha": "500a0ae263ea509a8be6ba1d205000908fe3f766", "filename": "tests/ui/vec_box_sized.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.rs?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -4,6 +4,7 @@\n \n struct SizedStruct(i32);\n struct UnsizedStruct([i32]);\n+struct BigStruct([i32; 10000]);\n \n /// The following should trigger the lint\n mod should_trigger {\n@@ -19,9 +20,10 @@ mod should_trigger {\n \n /// The following should not trigger the lint\n mod should_not_trigger {\n-    use super::UnsizedStruct;\n+    use super::{BigStruct, UnsizedStruct};\n \n     struct C(Vec<Box<UnsizedStruct>>);\n+    struct D(Vec<Box<BigStruct>>);\n \n     struct StructWithVecBoxButItsUnsized {\n         unsized_type: Vec<Box<UnsizedStruct>>,"}, {"sha": "29bf7069e8adb84c68f55eefe214a2bae8381a6e", "filename": "tests/ui/vec_box_sized.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b7bc260de3fedd94d4134b3e3bda48f60c5fd17/tests%2Fui%2Fvec_box_sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fvec_box_sized.stderr?ref=2b7bc260de3fedd94d4134b3e3bda48f60c5fd17", "patch": "@@ -1,19 +1,19 @@\n error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n-  --> $DIR/vec_box_sized.rs:13:21\n+  --> $DIR/vec_box_sized.rs:14:21\n    |\n LL |         sized_type: Vec<Box<SizedStruct>>,\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try: `Vec<SizedStruct>`\n    |\n    = note: `-D clippy::vec-box` implied by `-D warnings`\n \n error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n-  --> $DIR/vec_box_sized.rs:16:14\n+  --> $DIR/vec_box_sized.rs:17:14\n    |\n LL |     struct A(Vec<Box<SizedStruct>>);\n    |              ^^^^^^^^^^^^^^^^^^^^^ help: try: `Vec<SizedStruct>`\n \n error: `Vec<T>` is already on the heap, the boxing is unnecessary.\n-  --> $DIR/vec_box_sized.rs:17:18\n+  --> $DIR/vec_box_sized.rs:18:18\n    |\n LL |     struct B(Vec<Vec<Box<(u32)>>>);\n    |                  ^^^^^^^^^^^^^^^ help: try: `Vec<u32>`"}]}