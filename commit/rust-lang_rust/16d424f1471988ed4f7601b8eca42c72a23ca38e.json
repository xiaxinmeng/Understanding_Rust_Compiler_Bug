{"sha": "16d424f1471988ed4f7601b8eca42c72a23ca38e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZDQyNGYxNDcxOTg4ZWQ0Zjc2MDFiOGVjYTQyYzcyYTIzY2EzOGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-03-14T05:58:45Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-03-14T19:35:25Z"}, "message": "Some tweaks to \"type parameters from outer function\" diagnostic\n\nFollow up to #47574.", "tree": {"sha": "7d782be01d1f34562ae6a475e9bf6404d3b5498e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d782be01d1f34562ae6a475e9bf6404d3b5498e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16d424f1471988ed4f7601b8eca42c72a23ca38e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16d424f1471988ed4f7601b8eca42c72a23ca38e", "html_url": "https://github.com/rust-lang/rust/commit/16d424f1471988ed4f7601b8eca42c72a23ca38e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16d424f1471988ed4f7601b8eca42c72a23ca38e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883e74645d350b6752cb94d48f46363f6f8789e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/883e74645d350b6752cb94d48f46363f6f8789e9", "html_url": "https://github.com/rust-lang/rust/commit/883e74645d350b6752cb94d48f46363f6f8789e9"}], "stats": {"total": 69, "additions": 42, "deletions": 27}, "files": [{"sha": "c84caee13e82a0c4233f535661ed12dd35367912", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=16d424f1471988ed4f7601b8eca42c72a23ca38e", "patch": "@@ -41,7 +41,7 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n \n-use syntax::codemap::{dummy_spanned, respan, CodeMap};\n+use syntax::codemap::{dummy_spanned, respan, BytePos, CodeMap};\n use syntax::ext::hygiene::{Mark, MarkKind, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, SpannedIdent, FloatTy, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n@@ -179,11 +179,12 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n                                            E0401,\n                                            \"can't use type parameters from outer function\");\n             err.span_label(span, \"use of type variable from outer function\");\n+\n+            let cm = resolver.session.codemap();\n             match outer_def {\n                 Def::SelfTy(_, maybe_impl_defid) => {\n                     if let Some(impl_span) = maybe_impl_defid.map_or(None,\n                             |def_id| resolver.definitions.opt_span(def_id)) {\n-                        let cm = resolver.session.codemap();\n                         err.span_label(reduce_impl_span_to_impl_keyword(cm, impl_span),\n                                     \"`Self` type implicitely declared here, on the `impl`\");\n                     }\n@@ -206,12 +207,13 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             // Try to retrieve the span of the function signature and generate a new message with\n             // a local type parameter\n             let sugg_msg = \"try using a local type parameter instead\";\n-            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(\n-                                                        resolver.session.codemap(), span) {\n+            if let Some((sugg_span, new_snippet)) = generate_local_type_param_snippet(cm, span) {\n                 // Suggest the modification to the user\n                 err.span_suggestion(sugg_span,\n                                     sugg_msg,\n                                     new_snippet);\n+            } else if let Some(sp) = generate_fn_name_span(cm, span) {\n+                err.span_label(sp, \"try adding a local type parameter in this method instead\");\n             } else {\n                 err.help(\"try using a local type parameter instead\");\n             }\n@@ -407,6 +409,15 @@ fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n     impl_span\n }\n \n+fn generate_fn_name_span(cm: &CodeMap, span: Span) -> Option<Span> {\n+    let prev_span = cm.span_extend_to_prev_str(span, \"fn\", true);\n+    cm.span_to_snippet(prev_span).map(|snippet| {\n+        let len = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+            .expect(\"no label after fn\");\n+        prev_span.with_hi(BytePos(prev_span.lo().0 + len as u32))\n+    }).ok()\n+}\n+\n /// Take the span of a type parameter in a function signature and try to generate a span for the\n /// function name (with generics) and a new snippet for this span with the pointed type parameter as\n /// a new local type parameter.\n@@ -428,17 +439,12 @@ fn reduce_impl_span_to_impl_keyword(cm: &CodeMap, impl_span: Span) -> Span {\n fn generate_local_type_param_snippet(cm: &CodeMap, span: Span) -> Option<(Span, String)> {\n     // Try to extend the span to the previous \"fn\" keyword to retrieve the function\n     // signature\n-    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\");\n+    let sugg_span = cm.span_extend_to_prev_str(span, \"fn\", false);\n     if sugg_span != span {\n         if let Ok(snippet) = cm.span_to_snippet(sugg_span) {\n-            use syntax::codemap::BytePos;\n-\n             // Consume the function name\n-            let mut offset = 0;\n-            for c in snippet.chars().take_while(|c| c.is_ascii_alphanumeric() ||\n-                                                    *c == '_') {\n-                offset += c.len_utf8();\n-            }\n+            let mut offset = snippet.find(|c: char| !c.is_alphanumeric() && c != '_')\n+                .expect(\"no label after fn\");\n \n             // Consume the generics part of the function signature\n             let mut bracket_counter = 0;"}, {"sha": "951f8a871ca66d2588f90f23a832ed154371453a", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=16d424f1471988ed4f7601b8eca42c72a23ca38e", "patch": "@@ -622,13 +622,21 @@ impl CodeMap {\n         sp\n     }\n \n-    /// Extend the given `Span` to just after the previous occurrence of `pat`. Return the same span\n-    /// if no character could be found or if an error occurred while retrieving the code snippet.\n-    pub fn span_extend_to_prev_str(&self, sp: Span, pat: &str) -> Span {\n-        if let Ok(prev_source) = self.span_to_prev_source(sp) {\n-            let prev_source = prev_source.rsplit(pat).nth(0).unwrap_or(\"\").trim_left();\n-            if !prev_source.is_empty() && !prev_source.contains('\\n') {\n-                return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+    /// Extend the given `Span` to just after the previous occurrence of `pat` when surrounded by\n+    /// whitespace. Return the same span if no character could be found or if an error occurred\n+    /// while retrieving the code snippet.\n+    pub fn span_extend_to_prev_str(&self, sp: Span, pat: &str, accept_newlines: bool) -> Span {\n+        // assure that the pattern is delimited, to avoid the following\n+        //     fn my_fn()\n+        //           ^^^^ returned span without the check\n+        //     ---------- correct span\n+        for ws in &[\" \", \"\\t\", \"\\n\"] {\n+            let pat = pat.to_owned() + ws;\n+            if let Ok(prev_source) = self.span_to_prev_source(sp) {\n+                let prev_source = prev_source.rsplit(&pat).nth(0).unwrap_or(\"\").trim_left();\n+                if !prev_source.is_empty() && (!prev_source.contains('\\n') || accept_newlines) {\n+                    return sp.with_lo(BytePos(sp.lo().0 - prev_source.len() as u32));\n+                }\n             }\n         }\n "}, {"sha": "4fc74f5ef22192adca43160e514666937f407d06", "filename": "src/test/ui/error-codes/E0401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.rs?ref=16d424f1471988ed4f7601b8eca42c72a23ca38e", "patch": "@@ -11,14 +11,14 @@\n trait Baz<T> {}\n \n fn foo<T>(x: T) {\n-    fn bar<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n+    fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n     }\n     fn baz<U,\n            V: Baz<U>,\n            W: Fn()>\n            (y: T) { //~ ERROR E0401\n     }\n-    bar(x);\n+    bfnr(x);\n }\n \n "}, {"sha": "e5a2be4dfb0263754f995bb8ad4a41305a16a4eb", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16d424f1471988ed4f7601b8eca42c72a23ca38e/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=16d424f1471988ed4f7601b8eca42c72a23ca38e", "patch": "@@ -1,23 +1,24 @@\n error[E0401]: can't use type parameters from outer function\n-  --> $DIR/E0401.rs:14:38\n+  --> $DIR/E0401.rs:14:39\n    |\n LL | fn foo<T>(x: T) {\n    |        - type variable from outer function\n-LL |     fn bar<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n-   |        --------------------------    ^ use of type variable from outer function\n+LL |     fn bfnr<U, V: Baz<U>, W: Fn()>(y: T) { //~ ERROR E0401\n+   |        ---------------------------    ^ use of type variable from outer function\n    |        |\n-   |        help: try using a local type parameter instead: `bar<U, V: Baz<U>, W: Fn(), T>`\n+   |        help: try using a local type parameter instead: `bfnr<U, V: Baz<U>, W: Fn(), T>`\n \n error[E0401]: can't use type parameters from outer function\n   --> $DIR/E0401.rs:19:16\n    |\n LL | fn foo<T>(x: T) {\n    |        - type variable from outer function\n ...\n+LL |     fn baz<U,\n+   |        --- try adding a local type parameter in this method instead\n+...\n LL |            (y: T) { //~ ERROR E0401\n    |                ^ use of type variable from outer function\n-   |\n-   = help: try using a local type parameter instead\n \n error[E0401]: can't use type parameters from outer function\n   --> $DIR/E0401.rs:32:25"}]}