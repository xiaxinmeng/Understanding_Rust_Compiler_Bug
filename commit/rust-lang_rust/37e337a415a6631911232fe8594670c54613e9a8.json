{"sha": "37e337a415a6631911232fe8594670c54613e9a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZTMzN2E0MTVhNjYzMTkxMTIzMmZlODU5NDY3MGM1NDYxM2U5YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-02T20:40:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-02T20:40:58Z"}, "message": "Auto merge of #30146 - steveklabnik:doc_string_intro, r=brson\n\nPart of #29376", "tree": {"sha": "d092b35fa070fc5a2d8287748c4d8a907047f56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d092b35fa070fc5a2d8287748c4d8a907047f56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37e337a415a6631911232fe8594670c54613e9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37e337a415a6631911232fe8594670c54613e9a8", "html_url": "https://github.com/rust-lang/rust/commit/37e337a415a6631911232fe8594670c54613e9a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37e337a415a6631911232fe8594670c54613e9a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5321f2abe7f6fadf8a3993b113ebb8ce9266fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5321f2abe7f6fadf8a3993b113ebb8ce9266fe9", "html_url": "https://github.com/rust-lang/rust/commit/d5321f2abe7f6fadf8a3993b113ebb8ce9266fe9"}, {"sha": "492f6fc9e98f7daa40f46a9ae2775b8529cecf6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/492f6fc9e98f7daa40f46a9ae2775b8529cecf6f", "html_url": "https://github.com/rust-lang/rust/commit/492f6fc9e98f7daa40f46a9ae2775b8529cecf6f"}], "stats": {"total": 198, "additions": 194, "deletions": 4}, "files": [{"sha": "c5e0af3d8003d795ec6dd8007095659499da10de", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 194, "deletions": 4, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/37e337a415a6631911232fe8594670c54613e9a8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37e337a415a6631911232fe8594670c54613e9a8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=37e337a415a6631911232fe8594670c54613e9a8", "patch": "@@ -8,7 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An owned, growable string that enforces that its contents are valid UTF-8.\n+//! A UTF-8 encoded, growable string.\n+//!\n+//! This module contains the [`String`] type, a trait for converting\n+//! [`ToString`]s, and several error types that may result from working with\n+//! [`String`]s.\n+//!\n+//! [`String`]: struct.String.html\n+//! [`ToString`]: trait.ToString.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -29,7 +36,190 @@ use str::{self, FromStr, Utf8Error, Chars};\n use vec::Vec;\n use boxed::Box;\n \n-/// A growable string stored as a UTF-8 encoded buffer.\n+/// A UTF-8 encoded, growable string.\n+///\n+/// The `String` type is the most common string type that has ownership over the\n+/// contents of the string. It has a close relationship with its borrowed\n+/// counterpart, the primitive [`str`].\n+///\n+/// [`str`]: ../primitive.str.html\n+///\n+/// # Examples\n+///\n+/// You can create a `String` from a literal string with `String::from`:\n+///\n+/// ```\n+/// let hello = String::from(\"Hello, world!\");\n+/// ```\n+///\n+/// You can append a [`char`] to a `String` with the [`push()`] method, and\n+/// append a [`&str`] with the [`push_str()`] method:\n+///\n+/// ```\n+/// let mut hello = String::from(\"Hello, \");\n+///\n+/// hello.push('w');\n+/// hello.push_str(\"orld!\");\n+/// ```\n+///\n+/// [`push()`]: #method.push\n+/// [`push_str()`]: #method.push_str\n+///\n+/// If you have a vector of UTF-8 bytes, you can create a `String` from it with\n+/// the [`from_utf8()`] method:\n+///\n+/// ```\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so we'll use `unwrap()`.\n+/// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+///\n+/// [`from_utf8()`]: #method.from_utf8\n+///\n+/// # UTF-8\n+///\n+/// `String`s are always valid UTF-8. This has a few implications, the first of\n+/// which is that if you need a non-UTF-8 string, consider [`OsString`]. It is\n+/// similar, but without the UTF-8 constraint. The second implication is that\n+/// you cannot index into a `String`:\n+///\n+/// ```ignore\n+/// let s = \"hello\";\n+///\n+/// println!(\"The first letter of s is {}\", s[0]); // ERROR!!!\n+/// ```\n+///\n+/// [`OsString`]: ../ffi/struct.OsString.html\n+///\n+/// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n+/// does not allow us to do this. Furtheremore, it's not clear what sort of\n+/// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n+/// The [`as_bytes()`] and [`chars()`] methods return iterators over the first\n+/// two, respectively.\n+///\n+/// [`as_bytes()`]: #method.as_bytes\n+/// [`chars()`]: #method.chars\n+///\n+/// # Deref\n+///\n+/// `String`s implement [`Deref`]`<Target=str>`, and so inherit all of [`str`]'s\n+/// methods. In addition, this means that you can pass a `String` to any\n+/// function which takes a [`&str`] by using an ampersand (`&`):\n+///\n+/// ```\n+/// fn takes_str(s: &str) { }\n+///\n+/// let s = String::from(\"Hello\");\n+///\n+/// takes_str(&s);\n+/// ```\n+///\n+/// [`&str`]: ../primitive.str.html\n+/// [`Deref`]: ../ops/trait.Deref.html\n+///\n+/// This will create a [`&str`] from the `String` and pass it in. This\n+/// conversion is very inexpensive, and so generally, functions will accept\n+/// [`&str`]s as arguments unless they need a `String` for some specific reason.\n+///\n+///\n+/// # Representation\n+///\n+/// A `String` is made up of three components: a pointer to some bytes, a\n+/// length, and a capacity. The pointer points to an internal buffer `String`\n+/// uses to store its data. The length is the number of bytes currently stored\n+/// in the buffer, and the capacity is the size of the buffer in bytes. As such,\n+/// the length will always be less than or equal to the capacity.\n+///\n+/// This buffer is always stored on the heap.\n+///\n+/// You can look at these with the [`as_ptr()`], [`len()`], and [`capacity()`]\n+/// methods:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let story = String::from(\"Once upon a time...\");\n+///\n+/// let ptr = story.as_ptr();\n+/// let len = story.len();\n+/// let capacity = story.capacity();\n+///\n+/// // story has thirteen bytes\n+/// assert_eq!(19, len);\n+///\n+/// // Now that we have our parts, we throw the story away.\n+/// mem::forget(story);\n+///\n+/// // We can re-build a String out of ptr, len, and capacity. This is all\n+/// // unsafe becuase we are responsible for making sure the components are\n+/// // valid:\n+/// let s = unsafe { String::from_raw_parts(ptr as *mut _, len, capacity) } ;\n+///\n+/// assert_eq!(String::from(\"Once upon a time...\"), s);\n+/// ```\n+///\n+/// [`as_ptr()`]: #method.as_ptr\n+/// [`len()`]: # method.len\n+/// [`capacity()`]: # method.capacity\n+///\n+/// If a `String` has enough capacity, adding elements to it will not\n+/// re-allocate. For example, consider this program:\n+///\n+/// ```\n+/// let mut s = String::new();\n+///\n+/// println!(\"{}\", s.capacity());\n+///\n+/// for _ in 0..5 {\n+///     s.push_str(\"hello\");\n+///     println!(\"{}\", s.capacity());\n+/// }\n+/// ```\n+///\n+/// This will output the following:\n+///\n+/// ```text\n+/// 0\n+/// 5\n+/// 10\n+/// 20\n+/// 20\n+/// 40\n+/// ```\n+///\n+/// At first, we have no memory allocated at all, but as we append to the\n+/// string, it increases its capacity appropriately. If we instead use the\n+/// [`with_capacity()`] method to allocate the correct capacity initially:\n+///\n+/// ```\n+/// let mut s = String::with_capacity(25);\n+///\n+/// println!(\"{}\", s.capacity());\n+///\n+/// for _ in 0..5 {\n+///     s.push_str(\"hello\");\n+///     println!(\"{}\", s.capacity());\n+/// }\n+/// ```\n+///\n+/// [`with_capacity()`]: #method.with_capacity\n+///\n+/// We end up with a different output:\n+///\n+/// ```text\n+/// 25\n+/// 25\n+/// 25\n+/// 25\n+/// 25\n+/// 25\n+/// ```\n+///\n+/// Here, there's no need to allocate more memory inside the loop.\n #[derive(PartialOrd, Eq, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n@@ -190,7 +380,7 @@ impl String {\n     /// // some bytes, in a vector\n     /// let sparkle_heart = vec![240, 159, 146, 150];\n     ///\n-    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// // We know these bytes are valid, so we'll use `unwrap()`.\n     /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n     ///\n     /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n@@ -252,7 +442,7 @@ impl String {\n     /// // some bytes, in a vector\n     /// let sparkle_heart = vec![240, 159, 146, 150];\n     ///\n-    /// // We know these bytes are valid, so just use `unwrap()`.\n+    /// // We know these bytes are valid, so we'll use `unwrap()`.\n     /// let sparkle_heart = String::from_utf8(sparkle_heart).unwrap();\n     ///\n     /// assert_eq!(\"\ud83d\udc96\", sparkle_heart);"}]}