{"sha": "35bc8ae86fe295e77fa1c290bebc52b08782018c", "node_id": "C_kwDOAAsO6NoAKDM1YmM4YWU4NmZlMjk1ZTc3ZmExYzI5MGJlYmM1MmIwODc4MjAxOGM", "commit": {"author": {"name": "b-naber", "email": "b_naber@gmx.de", "date": "2023-03-07T10:22:01Z"}, "committer": {"name": "b-naber", "email": "b_naber@gmx.de", "date": "2023-03-22T16:59:46Z"}, "message": "eager nll type relating", "tree": {"sha": "45c456cd0e2104c1d1ae128aec9749ea2bddee34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45c456cd0e2104c1d1ae128aec9749ea2bddee34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35bc8ae86fe295e77fa1c290bebc52b08782018c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35bc8ae86fe295e77fa1c290bebc52b08782018c", "html_url": "https://github.com/rust-lang/rust/commit/35bc8ae86fe295e77fa1c290bebc52b08782018c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35bc8ae86fe295e77fa1c290bebc52b08782018c/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da0fe80137e59708ca809f1a7e0e89e62e3ffcda", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0fe80137e59708ca809f1a7e0e89e62e3ffcda", "html_url": "https://github.com/rust-lang/rust/commit/da0fe80137e59708ca809f1a7e0e89e62e3ffcda"}], "stats": {"total": 274, "additions": 104, "deletions": 170}, "files": [{"sha": "2320f6bfb1674a434c493896e850870210fddff3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 104, "deletions": 170, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/35bc8ae86fe295e77fa1c290bebc52b08782018c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35bc8ae86fe295e77fa1c290bebc52b08782018c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=35bc8ae86fe295e77fa1c290bebc52b08782018c", "patch": "@@ -28,6 +28,7 @@ use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt, TypeVisitor};\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n@@ -55,21 +56,6 @@ where\n     ambient_variance: ty::Variance,\n \n     ambient_variance_info: ty::VarianceDiagInfo<'tcx>,\n-\n-    /// When we pass through a set of binders (e.g., when looking into\n-    /// a `fn` type), we push a new bound region scope onto here. This\n-    /// will contain the instantiated region for each region in those\n-    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n-    /// use the De Bruijn index `d` to find the right scope, and then\n-    /// bound region name `br` to find the specific instantiation from\n-    /// within that scope. See `replace_bound_region`.\n-    ///\n-    /// This field stores the instantiations for late-bound regions in\n-    /// the `a` type.\n-    a_scopes: Vec<BoundRegionScope<'tcx>>,\n-\n-    /// Same as `a_scopes`, but for the `b` type.\n-    b_scopes: Vec<BoundRegionScope<'tcx>>,\n }\n \n pub trait TypeRelatingDelegate<'tcx> {\n@@ -147,8 +133,6 @@ where\n             delegate,\n             ambient_variance,\n             ambient_variance_info: ty::VarianceDiagInfo::default(),\n-            a_scopes: vec![],\n-            b_scopes: vec![],\n         }\n     }\n \n@@ -166,88 +150,6 @@ where\n         }\n     }\n \n-    fn create_scope(\n-        &mut self,\n-        value: ty::Binder<'tcx, impl Relate<'tcx>>,\n-        universally_quantified: UniversallyQuantified,\n-    ) -> BoundRegionScope<'tcx> {\n-        let mut scope = BoundRegionScope::default();\n-\n-        // Create a callback that creates (via the delegate) either an\n-        // existential or placeholder region as needed.\n-        let mut next_region = {\n-            let delegate = &mut self.delegate;\n-            let mut lazy_universe = None;\n-            move |br: ty::BoundRegion| {\n-                if universally_quantified.0 {\n-                    // The first time this closure is called, create a\n-                    // new universe for the placeholders we will make\n-                    // from here out.\n-                    let universe = lazy_universe.unwrap_or_else(|| {\n-                        let universe = delegate.create_next_universe();\n-                        lazy_universe = Some(universe);\n-                        universe\n-                    });\n-\n-                    let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n-                    delegate.next_placeholder_region(placeholder)\n-                } else {\n-                    delegate.next_existential_region_var(true, br.kind.get_name())\n-                }\n-            }\n-        };\n-\n-        value.skip_binder().visit_with(&mut ScopeInstantiator {\n-            next_region: &mut next_region,\n-            target_index: ty::INNERMOST,\n-            bound_region_scope: &mut scope,\n-        });\n-\n-        scope\n-    }\n-\n-    /// When we encounter binders during the type traversal, we record\n-    /// the value to substitute for each of the things contained in\n-    /// that binder. (This will be either a universal placeholder or\n-    /// an existential inference variable.) Given the De Bruijn index\n-    /// `debruijn` (and name `br`) of some binder we have now\n-    /// encountered, this routine finds the value that we instantiated\n-    /// the region with; to do so, it indexes backwards into the list\n-    /// of ambient scopes `scopes`.\n-    fn lookup_bound_region(\n-        debruijn: ty::DebruijnIndex,\n-        br: &ty::BoundRegion,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        // The debruijn index is a \"reverse index\" into the\n-        // scopes listing. So when we have INNERMOST (0), we\n-        // want the *last* scope pushed, and so forth.\n-        let debruijn_index = debruijn.index() - first_free_index.index();\n-        let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-        // Find this bound region in that scope to map to a\n-        // particular region.\n-        scope.map[br]\n-    }\n-\n-    /// If `r` is a bound region, find the scope in which it is bound\n-    /// (from `scopes`) and return the value that we instantiated it\n-    /// with. Otherwise just return `r`.\n-    fn replace_bound_region(\n-        &self,\n-        r: ty::Region<'tcx>,\n-        first_free_index: ty::DebruijnIndex,\n-        scopes: &[BoundRegionScope<'tcx>],\n-    ) -> ty::Region<'tcx> {\n-        debug!(\"replace_bound_regions(scopes={:?})\", scopes);\n-        if let ty::ReLateBound(debruijn, br) = *r {\n-            Self::lookup_bound_region(debruijn, &br, first_free_index, scopes)\n-        } else {\n-            r\n-        }\n-    }\n-\n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n     fn push_outlives(\n@@ -314,18 +216,9 @@ where\n \n         self.infcx.inner.borrow_mut().type_variables().instantiate(vid, generalized_ty);\n \n-        // The generalized values we extract from `canonical_var_values` have\n-        // been fully instantiated and hence the set of scopes we have\n-        // doesn't matter -- just to be sure, put an empty vector\n-        // in there.\n-        let old_a_scopes = std::mem::take(pair.vid_scopes(self));\n-\n         // Relate the generalized kind to the original one.\n         let result = pair.relate_generalized_ty(self, generalized_ty);\n \n-        // Restore the old scopes now.\n-        *pair.vid_scopes(self) = old_a_scopes;\n-\n         debug!(\"relate_ty_var: complete, result = {:?}\", result);\n         result\n     }\n@@ -379,6 +272,97 @@ where\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_placeholders<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut lazy_universe = None;\n+\n+            move |br: ty::BoundRegion| {\n+                // The first time this closure is called, create a\n+                // new universe for the placeholders we will make\n+                // from here out.\n+                let universe = lazy_universe.unwrap_or_else(|| {\n+                    let universe = nll_delegate.create_next_universe();\n+                    lazy_universe = Some(universe);\n+                    universe\n+                });\n+\n+                let placeholder = ty::PlaceholderRegion { universe, name: br.kind };\n+                debug!(?placeholder);\n+                let placeholder_reg = nll_delegate.next_placeholder_region(placeholder);\n+                debug!(?placeholder_reg);\n+\n+                placeholder_reg\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn instantiate_binder_with_existentials<T>(&mut self, binder: ty::Binder<'tcx, T>) -> T\n+    where\n+        T: ty::TypeFoldable<TyCtxt<'tcx>> + Copy,\n+    {\n+        if let Some(inner) = binder.no_bound_vars() {\n+            return inner;\n+        }\n+\n+        let mut next_region = {\n+            let nll_delegate = &mut self.delegate;\n+            let mut reg_map = FxHashMap::default();\n+\n+            move |br: ty::BoundRegion| {\n+                if let Some(ex_reg_var) = reg_map.get(&br) {\n+                    return *ex_reg_var;\n+                } else {\n+                    let ex_reg_var =\n+                        nll_delegate.next_existential_region_var(true, br.kind.get_name());\n+                    debug!(?ex_reg_var);\n+                    reg_map.insert(br, ex_reg_var);\n+\n+                    ex_reg_var\n+                }\n+            }\n+        };\n+\n+        let delegate = FnMutDelegate {\n+            regions: &mut next_region,\n+            types: &mut |_bound_ty: ty::BoundTy| {\n+                unreachable!(\"we only replace regions in nll_relate, not types\")\n+            },\n+            consts: &mut |_bound_var: ty::BoundVar, _ty| {\n+                unreachable!(\"we only replace regions in nll_relate, not consts\")\n+            },\n+        };\n+\n+        let replaced = self.infcx.tcx.replace_bound_vars_uncached(binder, delegate);\n+        debug!(?replaced);\n+\n+        replaced\n+    }\n }\n \n /// When we instantiate an inference variable with a value in\n@@ -396,14 +380,6 @@ trait VidValuePair<'tcx>: Debug {\n     /// opposite part of the tuple from the vid).\n     fn value_ty(&self) -> Ty<'tcx>;\n \n-    /// Extract the scopes that apply to whichever side of the tuple\n-    /// the vid was found on. See the comment where this is called\n-    /// for more details on why we want them.\n-    fn vid_scopes<'r, D: TypeRelatingDelegate<'tcx>>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>;\n-\n     /// Given a generalized type G that should replace the vid, relate\n     /// G to the value, putting G on whichever side the vid would have\n     /// appeared.\n@@ -425,16 +401,6 @@ impl<'tcx> VidValuePair<'tcx> for (ty::TyVid, Ty<'tcx>) {\n         self.1\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.a_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -457,16 +423,6 @@ impl<'tcx> VidValuePair<'tcx> for (Ty<'tcx>, ty::TyVid) {\n         self.0\n     }\n \n-    fn vid_scopes<'r, D>(\n-        &self,\n-        relate: &'r mut TypeRelating<'_, 'tcx, D>,\n-    ) -> &'r mut Vec<BoundRegionScope<'tcx>>\n-    where\n-        D: TypeRelatingDelegate<'tcx>,\n-    {\n-        &mut relate.b_scopes\n-    }\n-\n     fn relate_generalized_ty<D>(\n         &self,\n         relate: &mut TypeRelating<'_, 'tcx, D>,\n@@ -602,20 +558,14 @@ where\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(?self.ambient_variance);\n \n-        let v_a = self.replace_bound_region(a, ty::INNERMOST, &self.a_scopes);\n-        let v_b = self.replace_bound_region(b, ty::INNERMOST, &self.b_scopes);\n-\n-        debug!(?v_a);\n-        debug!(?v_b);\n-\n         if self.ambient_covariance() {\n             // Covariant: &'a u8 <: &'b u8. Hence, `'a: 'b`.\n-            self.push_outlives(v_a, v_b, self.ambient_variance_info);\n+            self.push_outlives(a, b, self.ambient_variance_info);\n         }\n \n         if self.ambient_contravariance() {\n             // Contravariant: &'b u8 <: &'a u8. Hence, `'b: 'a`.\n-            self.push_outlives(v_b, v_a, self.ambient_variance_info);\n+            self.push_outlives(b, a, self.ambient_variance_info);\n         }\n \n         Ok(a)\n@@ -689,15 +639,6 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // universals).\n \n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(existential)\");\n-            debug!(?b_scope, \"(universal)\");\n-\n-            self.b_scopes.push(b_scope);\n-            self.a_scopes.push(a_scope);\n-\n             // Reset the ambient variance to covariant. This is needed\n             // to correctly handle cases like\n             //\n@@ -718,12 +659,14 @@ where\n             //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n             let variance = std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            // Note: the order here is important. Create the placeholders first, otherwise\n+            // we assign the wrong universe to the existential!\n+            let b_replaced = self.instantiate_binder_with_placeholders(b);\n+            let a_replaced = self.instantiate_binder_with_existentials(a);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         if self.ambient_contravariance() {\n@@ -733,26 +676,17 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // existentials). Opposite of above.\n \n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n-\n-            debug!(?a_scope, \"(universal)\");\n-            debug!(?b_scope, \"(existential)\");\n-\n-            self.a_scopes.push(a_scope);\n-            self.b_scopes.push(b_scope);\n-\n             // Reset ambient variance to contravariance. See the\n             // covariant case above for an explanation.\n             let variance =\n                 std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            let a_replaced = self.instantiate_binder_with_placeholders(a);\n+            let b_replaced = self.instantiate_binder_with_existentials(b);\n \n-            self.ambient_variance = variance;\n+            self.relate(a_replaced, b_replaced)?;\n \n-            self.b_scopes.pop().unwrap();\n-            self.a_scopes.pop().unwrap();\n+            self.ambient_variance = variance;\n         }\n \n         Ok(a)"}]}