{"sha": "53733c87b64855ac8f15ea3886e6a8ed6097545a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNzMzYzg3YjY0ODU1YWM4ZjE1ZWEzODg2ZTZhOGVkNjA5NzU0NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T10:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T10:01:49Z"}, "message": "auto merge of #11633 : chromatic/rust/master, r=alexcrichton", "tree": {"sha": "d77527533324e7e1e92ba8a058a897525c7d3281", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77527533324e7e1e92ba8a058a897525c7d3281"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53733c87b64855ac8f15ea3886e6a8ed6097545a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53733c87b64855ac8f15ea3886e6a8ed6097545a", "html_url": "https://github.com/rust-lang/rust/commit/53733c87b64855ac8f15ea3886e6a8ed6097545a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53733c87b64855ac8f15ea3886e6a8ed6097545a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d58c70fb3c9bb0160f51368e1acaaa175747734", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d58c70fb3c9bb0160f51368e1acaaa175747734", "html_url": "https://github.com/rust-lang/rust/commit/6d58c70fb3c9bb0160f51368e1acaaa175747734"}, {"sha": "0578c15abd5d889199f1e48db890a12ed4df3c67", "url": "https://api.github.com/repos/rust-lang/rust/commits/0578c15abd5d889199f1e48db890a12ed4df3c67", "html_url": "https://github.com/rust-lang/rust/commit/0578c15abd5d889199f1e48db890a12ed4df3c67"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "5f1542f750116702615a0e47230c922d70e7eac8", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53733c87b64855ac8f15ea3886e6a8ed6097545a/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53733c87b64855ac8f15ea3886e6a8ed6097545a/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=53733c87b64855ac8f15ea3886e6a8ed6097545a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -133,12 +133,12 @@ impl Archive {\n         run_ar(self.sess, \"d\", None, [&self.dst, &Path::new(file)]);\n     }\n \n-    /// Update all symbols in the archive (runs 'ar s' over it)\n+    /// Updates all symbols in the archive (runs 'ar s' over it)\n     pub fn update_symbols(&mut self) {\n         run_ar(self.sess, \"s\", None, [&self.dst]);\n     }\n \n-    /// List all files in an archive\n+    /// Lists all files in an archive\n     pub fn files(&self) -> ~[~str] {\n         let output = run_ar(self.sess, \"t\", None, [&self.dst]);\n         str::from_utf8(output.output).lines().map(|s| s.to_owned()).collect()\n@@ -182,7 +182,7 @@ impl Archive {\n         let (osprefix, osext) = match self.sess.targ_cfg.os {\n             abi::OsWin32 => (\"\", \"lib\"), _ => (\"lib\", \"a\"),\n         };\n-        // On windows, static libraries sometimes show up as libfoo.a and other\n+        // On Windows, static libraries sometimes show up as libfoo.a and other\n         // times show up as foo.lib\n         let oslibname = format!(\"{}{}.{}\", osprefix, name, osext);\n         let unixlibname = format!(\"lib{}.a\", name);\n@@ -228,7 +228,7 @@ impl ArchiveRO {\n         }\n     }\n \n-    /// Read a file in the archive\n+    /// Reads a file in the archive\n     pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n         unsafe {\n             let mut size = 0 as libc::size_t;"}, {"sha": "101b2e36bd6c11a888b9854aa87c5210a7f848bb", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/53733c87b64855ac8f15ea3886e6a8ed6097545a/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53733c87b64855ac8f15ea3886e6a8ed6097545a/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=53733c87b64855ac8f15ea3886e6a8ed6097545a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -183,7 +183,7 @@ pub mod write {\n             llvm::LLVMDisposePassManager(mpm);\n \n             // Emit the bytecode if we're either saving our temporaries or\n-            // emitting an rlib. Whenever an rlib is create, the bytecode is\n+            // emitting an rlib. Whenever an rlib is created, the bytecode is\n             // inserted into the archive in order to allow LTO against it.\n             let outputs = sess.outputs.borrow();\n             if sess.opts.save_temps ||\n@@ -314,7 +314,7 @@ pub mod write {\n         use std::unstable::mutex::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n \n-        // Copy what clan does by turning on loop vectorization at O2 and\n+        // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n         let vectorize_loop = !sess.no_vectorize_loops() &&\n                              (sess.opts.optimize == session::Default ||\n@@ -347,7 +347,7 @@ pub mod write {\n             // Only initialize the platforms supported by Rust here, because\n             // using --llvm-root will have multiple platforms that rustllvm\n             // doesn't actually link to and it's pointless to put target info\n-            // into the registry that Rust can not generate machine code for.\n+            // into the registry that Rust cannot generate machine code for.\n             llvm::LLVMInitializeX86TargetInfo();\n             llvm::LLVMInitializeX86Target();\n             llvm::LLVMInitializeX86TargetMC();\n@@ -381,7 +381,7 @@ pub mod write {\n         let builder = llvm::LLVMPassManagerBuilderCreate();\n         match opt {\n             lib::llvm::CodeGenLevelNone => {\n-                // Don't add lifetime intrinsics add O0\n+                // Don't add lifetime intrinsics at O0\n                 llvm::LLVMRustAddAlwaysInlinePass(builder, false);\n             }\n             lib::llvm::CodeGenLevelLess => {\n@@ -591,7 +591,7 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n     //\n     // It turns out that on OSX you can actually have arbitrary symbols in\n     // function names (at least when given to LLVM), but this is not possible\n-    // when using unix's linker. Perhaps one day when we just a linker from LLVM\n+    // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n     // we won't need to do this name mangling. The problem with name mangling is\n     // that it seriously limits the available characters. For example we can't\n     // have things like @T or ~[T] in symbol names when one would theoretically\n@@ -894,7 +894,7 @@ fn link_rlib(sess: Session,\n     //   determine the architecture of the archive in order to see whether its\n     //   linkable.\n     //\n-    //   The algorithm for this detections is: iterate over the files in the\n+    //   The algorithm for this detection is: iterate over the files in the\n     //   archive. Skip magical SYMDEF names. Interpret the first file as an\n     //   object file. Read architecture from the object file.\n     //\n@@ -941,7 +941,7 @@ fn link_rlib(sess: Session,\n // Create a static archive\n //\n // This is essentially the same thing as an rlib, but it also involves adding\n-// all of the upstream crates' objects into the the archive. This will slurp in\n+// all of the upstream crates' objects into the archive. This will slurp in\n // all of the native libraries of upstream dependencies as well.\n //\n // Additionally, there's no way for us to link dynamic libraries, so we warn\n@@ -1058,7 +1058,7 @@ fn link_args(sess: Session,\n     if sess.targ_cfg.os == abi::OsLinux {\n         // GNU-style linkers will use this to omit linking to libraries which\n         // don't actually fulfill any relocations, but only for libraries which\n-        // follow this flag. Thus, use it before specifing libraries to link to.\n+        // follow this flag. Thus, use it before specifying libraries to link to.\n         args.push(~\"-Wl,--as-needed\");\n \n         // GNU-style linkers support optimization with -O. --gc-sections\n@@ -1074,7 +1074,7 @@ fn link_args(sess: Session,\n     if sess.targ_cfg.os == abi::OsWin32 {\n         // Make sure that we link to the dynamic libgcc, otherwise cross-module\n         // DWARF stack unwinding will not work.\n-        // This behavior may be overriden by --link-args \"-static-libgcc\"\n+        // This behavior may be overridden by --link-args \"-static-libgcc\"\n         args.push(~\"-shared-libgcc\");\n     }\n \n@@ -1124,7 +1124,7 @@ fn link_args(sess: Session,\n \n // # Native library linking\n //\n-// User-supplied library search paths (-L on the cammand line) These are\n+// User-supplied library search paths (-L on the command line). These are\n // the same paths used to find Rust crates, so some of them may have been\n // added already by the previous crate linking code. This only allows them\n // to be found at compile time so it is still entirely up to outside\n@@ -1182,12 +1182,12 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     if !dylib && !sess.prefer_dynamic() {\n         // With an executable, things get a little interesting. As a limitation\n         // of the current implementation, we require that everything must be\n-        // static, or everything must be dynamic. The reasons for this are a\n+        // static or everything must be dynamic. The reasons for this are a\n         // little subtle, but as with the above two cases, the goal is to\n         // prevent duplicate copies of the same library showing up. For example,\n         // a static immediate dependency might show up as an upstream dynamic\n         // dependency and we currently have no way of knowing that. We know that\n-        // all dynamic libaries require dynamic dependencies (see above), so\n+        // all dynamic libraries require dynamic dependencies (see above), so\n         // it's satisfactory to include either all static libraries or all\n         // dynamic libraries.\n         let crates = cstore.get_used_crates(cstore::RequireStatic);\n@@ -1232,7 +1232,7 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n \n     // If we're performing LTO, then it should have been previously required\n-    // that all upstream rust depenencies were available in an rlib format.\n+    // that all upstream rust dependencies were available in an rlib format.\n     assert!(!sess.lto());\n \n     // This is a fallback of three different  cases of linking:"}]}