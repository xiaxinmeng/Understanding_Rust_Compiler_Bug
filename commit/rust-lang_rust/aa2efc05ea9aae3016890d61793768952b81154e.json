{"sha": "aa2efc05ea9aae3016890d61793768952b81154e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMmVmYzA1ZWE5YWFlMzAxNjg5MGQ2MTc5Mzc2ODk1MmI4MTE1NGU=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-25T22:29:27Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-05-29T17:43:19Z"}, "message": "Adding shared_arc to hide some of the tedium of sharing an arc between tasks.\n\nAlso added some asserts and logging to trans.\n\nModified graph500 to use the shared_arc, but this unfortunately doesn't work due to #2444.", "tree": {"sha": "6e7663008aae393821181fd8691e05ed931d1d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7663008aae393821181fd8691e05ed931d1d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa2efc05ea9aae3016890d61793768952b81154e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2efc05ea9aae3016890d61793768952b81154e", "html_url": "https://github.com/rust-lang/rust/commit/aa2efc05ea9aae3016890d61793768952b81154e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa2efc05ea9aae3016890d61793768952b81154e/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f0358bc5cbdde0ea511f117e39f97bd40f82dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0358bc5cbdde0ea511f117e39f97bd40f82dc1", "html_url": "https://github.com/rust-lang/rust/commit/3f0358bc5cbdde0ea511f117e39f97bd40f82dc1"}], "stats": {"total": 115, "additions": 88, "deletions": 27}, "files": [{"sha": "ce9599762d0bafd7c29c2dd2ce5e5409621cbcea", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/aa2efc05ea9aae3016890d61793768952b81154e/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2efc05ea9aae3016890d61793768952b81154e/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=aa2efc05ea9aae3016890d61793768952b81154e", "patch": "@@ -1,7 +1,9 @@\n #[doc = \"An atomically reference counted wrapper that can be used to\n share immutable data between tasks.\"]\n \n-export arc, get, clone;\n+import comm::{port, chan, methods};\n+\n+export arc, get, clone, shared_arc, get_arc;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n@@ -14,12 +16,12 @@ native mod rustrt {\n         -> libc::intptr_t;\n }\n \n-type arc_data<T> = {\n+type arc_data<T: const> = {\n     mut count: libc::intptr_t,\n     data: T\n };\n \n-resource arc_destruct<T>(data: *libc::c_void) {\n+resource arc_destruct<T: const>(data: *libc::c_void) {\n     unsafe {\n         let data: ~arc_data<T> = unsafe::reinterpret_cast(data);\n         let ref_ptr = &mut data.count;\n@@ -34,10 +36,10 @@ resource arc_destruct<T>(data: *libc::c_void) {\n     }\n }\n \n-type arc<T> = arc_destruct<T>;\n+type arc<T: const> = arc_destruct<T>;\n \n #[doc=\"Create an atomically reference counted wrapper.\"]\n-fn arc<T>(-data: T) -> arc<T> {\n+fn arc<T: const>(-data: T) -> arc<T> {\n     let data = ~{mut count: 1, data: data};\n     unsafe {\n         let ptr = unsafe::reinterpret_cast(data);\n@@ -48,7 +50,7 @@ fn arc<T>(-data: T) -> arc<T> {\n \n #[doc=\"Access the underlying data in an atomically reference counted\n  wrapper.\"]\n-fn get<T>(rc: &a.arc<T>) -> &a.T {\n+fn get<T: const>(rc: &a.arc<T>) -> &a.T {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast(**rc);\n         // Cast us back into the correct region\n@@ -63,11 +65,44 @@ fn get<T>(rc: &a.arc<T>) -> &a.T {\n The resulting two `arc` objects will point to the same underlying data\n object. However, one of the `arc` objects can be sent to another task,\n allowing them to share the underlying data.\"]\n-fn clone<T>(rc: &arc<T>) -> arc<T> {\n+fn clone<T: const>(rc: &arc<T>) -> arc<T> {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast(**rc);\n         rustrt::rust_atomic_increment(&mut ptr.count);\n         unsafe::forget(ptr);\n     }\n     arc_destruct(**rc)\n }\n+\n+// Convenience code for sharing arcs between tasks\n+\n+enum proto<T: send const> {\n+    terminate,\n+    shared_get(comm::chan<arc::arc<T>>)\n+}\n+\n+resource shared_arc_res<T: send const>(c: comm::chan<proto<T>>) {\n+    c.send(terminate);\n+}\n+\n+fn shared_arc<T: send const>(-data: T) -> shared_arc_res<T> {\n+    let a = arc::arc(data);\n+    let c = task::spawn_listener::<proto<T>>() {|p, move a|\n+        let mut live = true;\n+        while live {\n+            alt p.recv() {\n+              terminate { live = false; }\n+              shared_get(cc) {\n+                cc.send(arc::clone(&a));\n+              }\n+            }\n+        }\n+    };\n+    shared_arc_res(c)\n+}\n+\n+fn get_arc<T: send const>(c: comm::chan<proto<T>>) -> arc::arc<T> {\n+    let p = port();\n+    c.send(shared_get(chan(p)));\n+    p.recv()\n+}"}, {"sha": "bdde26a0f8254f1690c8e8366815cd6b6fb21d55", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa2efc05ea9aae3016890d61793768952b81154e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2efc05ea9aae3016890d61793768952b81154e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=aa2efc05ea9aae3016890d61793768952b81154e", "patch": "@@ -2028,6 +2028,14 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         }\n     });\n \n+    #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?\",\n+           fn_id, ty::item_path_str(ccx.tcx, fn_id),\n+           real_substs.map({|s| ty_to_str(ccx.tcx, s)}),\n+           substs.map({|s| ty_to_str(ccx.tcx, s)})];\n+\n+    for real_substs.each() {|s| assert !ty::type_has_params(s); };\n+    for substs.each() {|s| assert !ty::type_has_params(s); };\n+\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, some(param_uses));\n     if vec::any(hash_id.params,\n@@ -4231,6 +4239,7 @@ fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n     let llty = type_of(ccx, t);\n+    if ty::type_has_params(t) { log(error, ty_to_str(ccx.tcx, t)); }\n     assert !ty::type_has_params(t);\n     let val = alloca(bcx, llty);\n     ret val;"}, {"sha": "b7da3b6821e414d09798d3c0223bf84b9ee858bd", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa2efc05ea9aae3016890d61793768952b81154e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2efc05ea9aae3016890d61793768952b81154e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=aa2efc05ea9aae3016890d61793768952b81154e", "patch": "@@ -14,6 +14,7 @@ import syntax::ast;\n import syntax::ast_util::{dummy_sp, new_def_hash};\n import syntax::util::interner;\n import util::common;\n+import util::ppaux::ty_to_str;\n import syntax::codemap::span;\n import dvec::{dvec, extensions};\n \n@@ -445,6 +446,11 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         s\n       }\n       ty::ty_res(did, raw_subt, substs) {\n+        #debug[\"ty_res(%?, %?, %?)\",\n+               did,\n+               ty_to_str(ccx.tcx, raw_subt),\n+               substs.tps.map({|t| ty_to_str(ccx.tcx, t) })];\n+        for substs.tps.each() {|t| assert !ty::type_has_params(t); }\n         let subt = ty::subst(ccx.tcx, substs, raw_subt);\n         let tps = substs.tps;\n         let ri = {did: did, tps: tps};\n@@ -589,8 +595,9 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let mut dtors = [];\n     let len = interner::len(ccx.shape_cx.resources);\n     for uint::range(0u, len) {|i|\n-      let ri = interner::get(ccx.shape_cx.resources, i);\n-      dtors += [trans::base::get_res_dtor(ccx, ri.did, ri.tps)];\n+        let ri = interner::get(ccx.shape_cx.resources, i);\n+        for ri.tps.each() {|s| assert !ty::type_has_params(s); }\n+        dtors += [trans::base::get_res_dtor(ccx, ri.did, ri.tps)];\n     }\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }"}, {"sha": "45f43f551ce939e458b04963c1af5e427b9d99df", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aa2efc05ea9aae3016890d61793768952b81154e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa2efc05ea9aae3016890d61793768952b81154e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=aa2efc05ea9aae3016890d61793768952b81154e", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test :(\n+\n /**\n \n An implementation of the Graph500 Bread First Search problem in Rust.\n@@ -10,6 +12,7 @@ import std::map;\n import std::map::hashmap;\n import std::deque;\n import std::deque::t;\n+import std::arc;\n import io::writer_util;\n import comm::*;\n import int::abs;\n@@ -264,34 +267,41 @@ fn pbfs(graph: graph, key: node_id) -> bfs_result {\n         }\n     }\n \n+    let graph_arc = arc::shared_arc(copy graph);\n+    let graph = *graph_arc;\n+\n     let mut i = 0u;\n     while par::any(colors, is_gray) {\n         // Do the BFS.\n         log(info, #fmt(\"PBFS iteration %?\", i));\n         i += 1u;\n         let old_len = colors.len();\n-        let pc = ptr::addr_of(colors);\n-        let pg = ptr::addr_of(graph);\n+\n+        let colors_arc = arc::shared_arc(copy colors);\n+        let color = *colors_arc;\n+\n         colors = par::mapi(colors) {|i, c|\n             let c : color = c;\n+            let colors = &arc::get_arc(color);\n+            let colors : [color] = *arc::get(colors);\n+            let graph = &arc::get_arc(graph);\n+            let graph : graph = *arc::get(graph);\n             alt c {\n               white {\n-                unsafe {\n-                    let i = i as node_id;\n-                    \n-                    let neighbors = &(*pg)[i];\n-                    \n-                    let mut color = white;\n-                    \n-                    (*neighbors).each() {|k|\n-                        if is_gray((*pc)[k]) {\n-                            color = gray(k);\n-                            false\n-                        }\n-                        else { true }\n+                let i = i as node_id;\n+                \n+                let neighbors = graph[i];\n+                \n+                let mut color = white;\n+                \n+                neighbors.each() {|k|\n+                    if is_gray(colors[k]) {\n+                        color = gray(k);\n+                        false\n+                    }\n+                    else { true }\n                     };\n-                    color\n-                }\n+                color\n               }\n               gray(parent) { black(parent) }\n               black(parent) { black(parent) }\n@@ -621,4 +631,4 @@ fn alli<A: copy send>(xs: [A], f: fn~(uint, A) -> bool) -> bool {\n         }) {|x| x }\n     }\n \n-}\n\\ No newline at end of file\n+}"}]}