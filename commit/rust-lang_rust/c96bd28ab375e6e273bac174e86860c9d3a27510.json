{"sha": "c96bd28ab375e6e273bac174e86860c9d3a27510", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NmJkMjhhYjM3NWU2ZTI3M2JhYzE3NGU4Njg2MGM5ZDNhMjc1MTA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-26T18:41:31Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:33Z"}, "message": "Recompute `MissingConstructors` when needed\n\nThis only happens in a slow (diagnostics) path, so the code clarity gain\nis worth it.", "tree": {"sha": "4ccab990b56a08c53465dfab933e964113918d4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ccab990b56a08c53465dfab933e964113918d4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c96bd28ab375e6e273bac174e86860c9d3a27510", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c96bd28ab375e6e273bac174e86860c9d3a27510", "html_url": "https://github.com/rust-lang/rust/commit/c96bd28ab375e6e273bac174e86860c9d3a27510", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c96bd28ab375e6e273bac174e86860c9d3a27510/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "html_url": "https://github.com/rust-lang/rust/commit/b49f90760d0c464e6e7c3da06dc6a1eb122552ec"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "948c441f2c903ccb1c818b9356f12ea5c071c92b", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c96bd28ab375e6e273bac174e86860c9d3a27510/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96bd28ab375e6e273bac174e86860c9d3a27510/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=c96bd28ab375e6e273bac174e86860c9d3a27510", "patch": "@@ -1285,7 +1285,9 @@ impl<'tcx> Constructor<'tcx> {\n             IntRange(range) => return range.to_pat(pcx.cx.tcx),\n             NonExhaustive => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n-            Wildcard => bug!(\"we should not try to apply a wildcard constructor\"),\n+            Wildcard => bug!(\n+                \"trying to apply a wildcard constructor; this should have been done in `apply_constructors`\"\n+            ),\n         };\n \n         Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1610,27 +1612,13 @@ impl<'tcx> Usefulness<'tcx> {\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n-    ) -> Self {\n-        match self {\n-            UsefulWithWitness(witnesses) => UsefulWithWitness(\n-                witnesses\n-                    .into_iter()\n-                    .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n-                    .collect(),\n-            ),\n-            x => x,\n-        }\n-    }\n-\n-    fn apply_wildcard<'p>(\n-        self,\n-        pcx: PatCtxt<'_, 'p, 'tcx>,\n-        missing_ctors: MissingConstructors<'tcx>,\n+        is_top_level: bool,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let new_patterns = missing_ctors.report_patterns(pcx);\n-                UsefulWithWitness(\n+                let new_witnesses = if ctor.is_wildcard() {\n+                    let missing_ctors = MissingConstructors::new(pcx, is_top_level);\n+                    let new_patterns = missing_ctors.report_patterns(pcx);\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -1640,8 +1628,14 @@ impl<'tcx> Usefulness<'tcx> {\n                                 witness\n                             })\n                         })\n-                        .collect(),\n-                )\n+                        .collect()\n+                } else {\n+                    witnesses\n+                        .into_iter()\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .collect()\n+                };\n+                UsefulWithWitness(new_witnesses)\n             }\n             x => x,\n         }\n@@ -2419,7 +2413,17 @@ crate fn is_useful<'p, 'tcx>(\n         constructor\n             .split(pcx, Some(hir_id))\n             .into_iter()\n-            .map(|c| is_useful_specialized(pcx, v, c, witness_preference, hir_id, is_under_guard))\n+            .map(|c| {\n+                is_useful_specialized(\n+                    pcx,\n+                    v,\n+                    &c,\n+                    witness_preference,\n+                    hir_id,\n+                    is_under_guard,\n+                    is_top_level,\n+                )\n+            })\n             .find(|result| result.is_useful())\n             .unwrap_or(NotUseful)\n     } else {\n@@ -2446,20 +2450,31 @@ crate fn is_useful<'p, 'tcx>(\n                 .into_iter()\n                 .flat_map(|ctor| ctor.split(pcx, None))\n                 .map(|c| {\n-                    is_useful_specialized(pcx, v, c, witness_preference, hir_id, is_under_guard)\n+                    is_useful_specialized(\n+                        pcx,\n+                        v,\n+                        &c,\n+                        witness_preference,\n+                        hir_id,\n+                        is_under_guard,\n+                        is_top_level,\n+                    )\n                 })\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n-            let ctor_wild_subpatterns = Fields::empty();\n-            let matrix = matrix.specialize_constructor(pcx, &constructor, &ctor_wild_subpatterns);\n-            // Unwrap is ok: v can always be specialized with its own constructor.\n-            let v =\n-                v.specialize_constructor(pcx, &constructor, &ctor_wild_subpatterns, true).unwrap();\n-            let usefulness =\n-                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-\n-            usefulness.apply_wildcard(pcx, missing_ctors)\n+            // Some constructors are missing, thus we can specialize with the wildcard constructor,\n+            // which will stand for those constructors that are missing, and behaves like any of\n+            // them.\n+            is_useful_specialized(\n+                pcx,\n+                v,\n+                constructor,\n+                witness_preference,\n+                hir_id,\n+                is_under_guard,\n+                is_top_level,\n+            )\n         }\n     };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n@@ -2471,20 +2486,22 @@ crate fn is_useful<'p, 'tcx>(\n fn is_useful_specialized<'p, 'tcx>(\n     pcx: PatCtxt<'_, 'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n-    ctor: Constructor<'tcx>,\n+    ctor: &Constructor<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n     is_under_guard: bool,\n+    is_top_level: bool,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, pcx.ty);\n \n     // We cache the result of `Fields::wildcards` because it is used a lot.\n-    let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n-    let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns, true)\n-        .map(|v| is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n-        .map(|u| u.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns))\n-        .unwrap_or(NotUseful)\n+    let ctor_wild_subpatterns = Fields::wildcards(pcx, ctor);\n+    let matrix = pcx.matrix.specialize_constructor(pcx, ctor, &ctor_wild_subpatterns);\n+    // Unwrap is ok: v can always be specialized with its own constructor.\n+    let v = v.specialize_constructor(pcx, ctor, &ctor_wild_subpatterns, true).unwrap();\n+    let usefulness =\n+        is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+    usefulness.apply_constructor(pcx, ctor, &ctor_wild_subpatterns, is_top_level)\n }\n \n /// Determines the constructor that the given pattern can be specialized to."}]}