{"sha": "3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNzhkNDMxOGM2NjllYjBhN2JmOTg1ZTJkNjAzYThlOWUxOTE3ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-08T06:56:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-08T06:56:17Z"}, "message": "Auto merge of #41156 - TimNN:rollup, r=TimNN\n\nRollup of 4 pull requests\n\n- Successful merges: #41135, #41143, #41146, #41152\n- Failed merges:", "tree": {"sha": "1a53c946e9407e71010e7cf0408eb3d12924fbb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a53c946e9407e71010e7cf0408eb3d12924fbb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "html_url": "https://github.com/rust-lang/rust/commit/3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547c12b8a61d7d0c047649c236f84b59ca2d2cc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/547c12b8a61d7d0c047649c236f84b59ca2d2cc9", "html_url": "https://github.com/rust-lang/rust/commit/547c12b8a61d7d0c047649c236f84b59ca2d2cc9"}, {"sha": "c04b39f1f8b645ff938e8ee610f76feeea9132ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c04b39f1f8b645ff938e8ee610f76feeea9132ff", "html_url": "https://github.com/rust-lang/rust/commit/c04b39f1f8b645ff938e8ee610f76feeea9132ff"}], "stats": {"total": 167, "additions": 149, "deletions": 18}, "files": [{"sha": "2e33b4511949d208723bf5fe8858712a30b5d2ac", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -472,10 +472,10 @@ def build_triple(self):\n             cputype = 'i686'\n         elif cputype in {'xscale', 'arm'}:\n             cputype = 'arm'\n-        elif cputype in {'armv6l', 'armv7l', 'armv8l'}:\n+        elif cputype == 'armv6l':\n             cputype = 'arm'\n             ostype += 'eabihf'\n-        elif cputype == 'armv7l':\n+        elif cputype in {'armv7l', 'armv8l'}:\n             cputype = 'armv7'\n             ostype += 'eabihf'\n         elif cputype == 'aarch64':"}, {"sha": "b10bc41cb1439d08b46195030212d962535a96f3", "filename": "src/doc/unstable-book/src/abi-msp430-interrupt.md", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-msp430-interrupt.md", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-msp430-interrupt.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-msp430-interrupt.md?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -5,3 +5,38 @@ The tracking issue for this feature is: [#38487]\n [#38487]: https://github.com/rust-lang/rust/issues/38487\n \n ------------------------\n+\n+In the MSP430 architecture, interrupt handlers have a special calling\n+convention. You can use the `\"msp430-interrupt\"` ABI to make the compiler apply\n+the right calling convention to the interrupt handlers you define.\n+\n+<!-- NOTE(ignore) this example is specific to the msp430 target -->\n+\n+``` rust,ignore\n+#![feature(abi_msp430_interrupt)]\n+#![no_std]\n+\n+// Place the interrupt handler at the appropriate memory address\n+// (Alternatively, you can use `#[used]` and remove `pub` and `#[no_mangle]`)\n+#[link_section = \"__interrupt_vector_10\"]\n+#[no_mangle]\n+pub static TIM0_VECTOR: extern \"msp430-interrupt\" fn() = tim0;\n+\n+// The interrupt handler\n+extern \"msp430-interrupt\" fn tim0() {\n+    // ..\n+}\n+```\n+\n+``` text\n+$ msp430-elf-objdump -CD ./target/msp430/release/app\n+Disassembly of section __interrupt_vector_10:\n+\n+0000fff2 <TIM0_VECTOR>:\n+    fff2:       00 c0           interrupt service routine at 0xc000\n+\n+Disassembly of section .text:\n+\n+0000c000 <int::tim0>:\n+    c000:       00 13           reti\n+```"}, {"sha": "0ded3ceeaef2ce9ea0457dc563aa53a0014b6737", "filename": "src/doc/unstable-book/src/abi-ptx.md", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-ptx.md", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-ptx.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fabi-ptx.md?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -1,5 +1,60 @@\n # `abi_ptx`\n \n-The tracking issue for this feature is: None.\n+The tracking issue for this feature is: [#38788]\n+\n+[#38788]: https://github.com/rust-lang/rust/issues/38788\n \n ------------------------\n+\n+When emitting PTX code, all vanilla Rust functions (`fn`) get translated to\n+\"device\" functions. These functions are *not* callable from the host via the\n+CUDA API so a crate with only device functions is not too useful!\n+\n+OTOH, \"global\" functions *can* be called by the host; you can think of them\n+as the real public API of your crate. To produce a global function use the\n+`\"ptx-kernel\"` ABI.\n+\n+<!-- NOTE(ignore) this example is specific to the nvptx targets -->\n+\n+``` rust,ignore\n+#![feature(abi_ptx)]\n+#![no_std]\n+\n+pub unsafe extern \"ptx-kernel\" fn global_function() {\n+    device_function();\n+}\n+\n+pub fn device_function() {\n+    // ..\n+}\n+```\n+\n+``` text\n+$ xargo rustc --target nvptx64-nvidia-cuda --release -- --emit=asm\n+\n+$ cat $(find -name '*.s')\n+//\n+// Generated by LLVM NVPTX Back-End\n+//\n+\n+.version 3.2\n+.target sm_20\n+.address_size 64\n+\n+        // .globl       _ZN6kernel15global_function17h46111ebe6516b382E\n+\n+.visible .entry _ZN6kernel15global_function17h46111ebe6516b382E()\n+{\n+\n+\n+        ret;\n+}\n+\n+        // .globl       _ZN6kernel15device_function17hd6a0e4993bbf3f78E\n+.visible .func _ZN6kernel15device_function17hd6a0e4993bbf3f78E()\n+{\n+\n+\n+        ret;\n+}\n+```"}, {"sha": "5da8968fd0ce22724a09ae8be37a36ab8053671c", "filename": "src/doc/unstable-book/src/compiler-builtins-lib.md", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins-lib.md?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -1,5 +1,35 @@\n # `compiler_builtins_lib`\n \n-This feature is internal to the Rust compiler and is not intended for general use.\n+The tracking issue for this feature is: None.\n \n ------------------------\n+\n+This feature is required to link to the `compiler_builtins` crate which contains\n+\"compiler intrinsics\". Compiler intrinsics are software implementations of basic\n+operations like multiplication of `u64`s. These intrinsics are only required on\n+platforms where these operations don't directly map to a hardware instruction.\n+\n+You should never need to explicitly link to the `compiler_builtins` crate when\n+building \"std\" programs as `compiler_builtins` is already in the dependency\n+graph of `std`. But you may need it when building `no_std` **binary** crates. If\n+you get a *linker* error like:\n+\n+``` text\n+$PWD/src/main.rs:11: undefined reference to `__aeabi_lmul'\n+$PWD/src/main.rs:11: undefined reference to `__aeabi_uldivmod'\n+```\n+\n+That means that you need to link to this crate.\n+\n+When you link to this crate, make sure it only appears once in your crate\n+dependency graph. Also, it doesn't matter where in the dependency graph, you\n+place the `compiler_builtins` crate.\n+\n+<!-- NOTE(ignore) doctests don't support `no_std` binaries -->\n+\n+``` rust,ignore\n+#![feature(compiler_builtins_lib)]\n+#![no_std]\n+\n+extern crate compiler_builtins;\n+```"}, {"sha": "52fac575b6e8631cea0c182325979b84d63b18af", "filename": "src/doc/unstable-book/src/compiler-builtins.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins.md", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-builtins.md?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -1,6 +1,5 @@\n # `compiler_builtins`\n \n-The tracking issue for this feature is: None.\n+This feature is internal to the Rust compiler and is not intended for general use.\n \n ------------------------\n-"}, {"sha": "a4050f271eb99b30a08eb91961680bf468444e28", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -539,17 +539,16 @@ impl AtomicBool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n         // with an 8-bit integer internally, which would set the upper 7 bits.\n-        // So we just use a compare-exchange loop instead, which is what the\n-        // intrinsic actually expands to anyways on many platforms.\n-        let mut old = self.load(Relaxed);\n-        loop {\n-            let new = !(old && val);\n-            match self.compare_exchange_weak(old, new, order, Relaxed) {\n-                Ok(_) => break,\n-                Err(x) => old = x,\n-            }\n+        // So we just use fetch_xor or swap instead.\n+        if val {\n+            // !(x & true) == !x\n+            // We must invert the bool.\n+            self.fetch_xor(true, order)\n+        } else {\n+            // !(x & false) == true\n+            // We must set the bool to true.\n+            self.swap(true, order)\n         }\n-        old\n     }\n \n     /// Logical \"or\" with a boolean value."}, {"sha": "9babe24a985634e14975237f000d9edc400fba7e", "filename": "src/libcore/tests/atomic.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibcore%2Ftests%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibcore%2Ftests%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fatomic.rs?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -24,10 +24,23 @@ fn bool_() {\n #[test]\n fn bool_and() {\n     let a = AtomicBool::new(true);\n-    assert_eq!(a.fetch_and(false, SeqCst),true);\n+    assert_eq!(a.fetch_and(false, SeqCst), true);\n     assert_eq!(a.load(SeqCst),false);\n }\n \n+#[test]\n+fn bool_nand() {\n+    let a = AtomicBool::new(false);\n+    assert_eq!(a.fetch_nand(false, SeqCst), false);\n+    assert_eq!(a.load(SeqCst), true);\n+    assert_eq!(a.fetch_nand(false, SeqCst), true);\n+    assert_eq!(a.load(SeqCst), true);\n+    assert_eq!(a.fetch_nand(true, SeqCst), true);\n+    assert_eq!(a.load(SeqCst), false);\n+    assert_eq!(a.fetch_nand(true, SeqCst), false);\n+    assert_eq!(a.load(SeqCst), true);\n+}\n+\n #[test]\n fn uint_and() {\n     let x = AtomicUsize::new(0xf731);"}, {"sha": "c68e2ae34687b347cc095ca3b6d7787ec3c265db", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3178d4318c669eb0a7bf985e2d603a8e9e1917e7/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3178d4318c669eb0a7bf985e2d603a8e9e1917e7", "patch": "@@ -408,7 +408,7 @@ declare_features! (\n     // Allows the definition recursive static items.\n     (accepted, static_recursion, \"1.17.0\", Some(29719)),\n     // pub(restricted) visibilities (RFC 1422)\n-    (accepted, pub_restricted, \"1.17.0\", Some(32409)),\n+    (accepted, pub_restricted, \"1.18.0\", Some(32409)),\n     // The #![windows_subsystem] attribute\n     (accepted, windows_subsystem, \"1.18.0\", Some(37499)),\n );"}]}