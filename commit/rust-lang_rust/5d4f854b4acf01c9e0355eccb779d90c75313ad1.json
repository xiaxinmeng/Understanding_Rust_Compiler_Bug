{"sha": "5d4f854b4acf01c9e0355eccb779d90c75313ad1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNGY4NTRiNGFjZjAxYzllMDM1NWVjY2I3NzlkOTBjNzUzMTNhZDE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-30T04:42:27Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-30T04:42:27Z"}, "message": "so much unwinding", "tree": {"sha": "a8096a3a255ed626b4c757652233ce6d1ba58cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8096a3a255ed626b4c757652233ce6d1ba58cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d4f854b4acf01c9e0355eccb779d90c75313ad1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4f854b4acf01c9e0355eccb779d90c75313ad1", "html_url": "https://github.com/rust-lang/rust/commit/5d4f854b4acf01c9e0355eccb779d90c75313ad1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d4f854b4acf01c9e0355eccb779d90c75313ad1/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10af239aad8024f1eed093947b8516ecf873d735", "url": "https://api.github.com/repos/rust-lang/rust/commits/10af239aad8024f1eed093947b8516ecf873d735", "html_url": "https://github.com/rust-lang/rust/commit/10af239aad8024f1eed093947b8516ecf873d735"}], "stats": {"total": 244, "additions": 228, "deletions": 16}, "files": [{"sha": "925f304236623e457e05da2462da6f20a4fbedea", "filename": "unwinding.md", "status": "modified", "additions": 228, "deletions": 16, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/5d4f854b4acf01c9e0355eccb779d90c75313ad1/unwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d4f854b4acf01c9e0355eccb779d90c75313ad1/unwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/unwinding.md?ref=5d4f854b4acf01c9e0355eccb779d90c75313ad1", "patch": "@@ -28,10 +28,9 @@ Rust very poor for long-running systems!\n As the Rust we know today came to be, this style of programming grew out of\n fashion in the push for less-and-less abstraction. Light-weight tasks were\n killed in the name of heavy-weight OS threads. Still, panics could only be\n-caught by the parent thread. This meant catching a panic required spinning up\n-an entire OS thread! Although Rust maintains the philosophy that panics should\n-not be used for \"basic\" error-handling like C++ or Java, it is still desirable\n-to not have the entire program crash in the face of a panic.\n+caught by the parent thread. This means catching a panic requires spinning up\n+an entire OS thread! This unfortunately stands in conflict to Rust's philosophy\n+of zero-cost abstractions.\n \n In the near future there will be a stable interface for catching panics in an\n arbitrary location, though we would encourage you to still only do this\n@@ -40,14 +39,14 @@ optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n should be no runtime cost for the program being *ready* to unwind. As a\n consequence, *actually* unwinding will be more expensive than in e.g. Java.\n Don't build your programs to unwind under normal circumstances. Ideally, you\n-should only panic for programming errors.\n+should only panic for programming errors or *extreme* problems.\n \n \n \n \n # Exception Safety\n \n-Being ready for unwinding is often referred to as \"exception safety\"\n+Being ready for unwinding is often referred to as *exception safety*\n in the broader programming world. In Rust, their are two levels of exception\n safety that one may concern themselves with:\n \n@@ -60,23 +59,236 @@ safety that one may concern themselves with:\n As is the case in many places in Rust, unsafe code must be ready to deal with\n bad safe code, and that includes code that panics. Code that transiently creates\n unsound states must be careful that a panic does not cause that state to be\n-used. Generally this means ensuring that only non-panicing code is run while\n+used. Generally this means ensuring that only non-panicking code is run while\n these states exist, or making a guard that cleans up the state in the case of\n a panic. This does not necessarily mean that the state a panic witnesses is a\n fully *coherent* state. We need only guarantee that it's a *safe* state.\n \n-For instance, consider extending a Vec:\n+Most unsafe code is leaf-like, and therefore fairly easy to make exception-safe.\n+It controls all the code that runs, and most of that code can't panic. However\n+it is often the case that code that works with arrays works with temporarily\n+uninitialized data while repeatedly invoking caller-provided code. Such code\n+needs to be careful, and consider exception-safety.\n+\n+\n+\n+\n+\n+## Vec::push_all\n+\n+`Vec::push_all` is a temporary hack to get extending a Vec by a slice reliably\n+effecient without specialization. Here's a simple implementation:\n+\n+```rust,ignore\n+impl<T: Clone> Vec<T> {\n+    fn push_all(&mut self, to_push: &[T]) {\n+        self.reserve(to_push.len());\n+        unsafe {\n+            // can't overflow because we just reserved this\n+            self.set_len(self.len() + to_push.len());\n+\n+            for (i, x) in to_push.iter().enumerate() {\n+                self.ptr().offset(i as isize).write(x.clone());\n+            }\n+        }\n+    }\n+}\n+```\n+\n+We bypass `push` in order to avoid redundant capacity and `len` checks on the\n+Vec that we definitely know has capacity. The logic is totally correct, except\n+there's a subtle problem with our code: it's not exception-safe! `set_len`,\n+`offset`, and `write` are all fine, but *clone* is the panic bomb we over-looked.\n+\n+Clone is completely out of our control, and is totally free to panic. If it does,\n+our function will exit early with the length of the Vec set too large. If\n+the Vec is looked at or dropped, uninitialized memory will be read!\n+\n+The fix in this case is fairly simple. If we want to guarantee that the values\n+we *did* clone are dropped we can set the len *in* the loop. If we just want to\n+guarantee that uninitialized memory can't be observed, we can set the len *after*\n+the loop.\n+\n+\n+\n+\n+\n+## BinaryHeap::sift_up\n+\n+Bubbling an element up a heap is a bit more complicated than extending a Vec.\n+The pseudocode is as follows:\n+\n+```text\n+bubble_up(heap, index):\n+    while index != 0 && heap[index] < heap[parent(index)]:\n+        heap.swap(index, parent(index))\n+        index = parent(index)\n+\n+```\n+\n+A literal transcription of this code to Rust is totally fine, but has an annoying\n+performance characteristic: the `self` element is swapped over and over again\n+uselessly. We would *rather* have the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    while index != 0 && element < heap[parent(index)]:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+This code ensures that each element is copied as little as possible (it is in\n+fact necessary that elem be copied twice in general). However it now exposes\n+some exception-safety trouble! At all times, there exists two copies of one\n+value. If we panic in this function something will be double-dropped.\n+Unfortunately, we also don't have full control of the code: that comparison is\n+user-defined!\n+\n+Unlike Vec, the fix isn't as easy here. One option is to break the user-defined\n+code and the unsafe code into two separate phases:\n+\n+```text\n+bubble_up(heap, index):\n+    let end_index = index;\n+    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:\n+        end_index = parent(end_index)\n+\n+    let elem = heap[index]\n+    while index != end_index:\n+        heap[index] = heap[parent(index)]\n+        index = parent(index)\n+    heap[index] = elem\n+```\n+\n+If the user-defined code blows up, that's no problem anymore, because we haven't\n+actually touched the state of the heap yet. Once we do start messing with the\n+heap, we're working with only data and functions that we trust, so there's no\n+concern of panics.\n+\n+Perhaps you're not happy with this design. Surely, it's cheating! And we have\n+to do the complex heap traversal *twice*! Alright, let's bite the bullet. Let's\n+intermix untrusted and unsafe code *for reals*.\n+\n+If Rust had `try` and `finally` like in Java, we could do the following:\n+\n+```text\n+bubble_up(heap, index):\n+    let elem = heap[index]\n+    try:\n+        while index != 0 && element < heap[parent(index)]:\n+            heap[index] = heap[parent(index)]\n+            index = parent(index)\n+    finally:\n+        heap[index] = elem\n+```\n+\n+The basic idea is simple: if the comparison panics, we just toss the loose\n+element in the logically uninitialized index and bail out. Anyone who observes\n+the heap will see a potentially *inconsistent* heap, but at least it won't\n+cause any double-drops! If the algorithm terminates normally, then this\n+operation happens to coincide precisely with the how we finish up regardless.\n+\n+Sadly, Rust has no such construct, so we're going to need to roll our own! The\n+way to do this is to store the algorithm's state in a separate struct with a\n+destructor for the \"finally\" logic. Whether we panic or not, that destructor\n+will run and clean up after us.\n \n ```rust\n+struct Hole<'a, T: 'a> {\n+    data: &'a mut [T],\n+    /// `elt` is always `Some` from new until drop.\n+    elt: Option<T>,\n+    pos: usize,\n+}\n \n-impl Extend<T> for Vec<T> {\n-\tfn extend<I: IntoIter<Item=T>>(&mut self, iterable: I) {\n-\t\tlet mut iter = iterable.into_iter();\n-\t\tlet size_hint = iter.size_hint().0;\n-\t\tself.reserve(size_hint);\n-\t\tself.set_len(self.len() + size_hint());\n+impl<'a, T> Hole<'a, T> {\n+    fn new(data: &'a mut [T], pos: usize) -> Self {\n+        unsafe {\n+            let elt = ptr::read(&data[pos]);\n+            Hole {\n+                data: data,\n+                elt: Some(elt),\n+                pos: pos,\n+            }\n+        }\n+    }\n \n-\t\tfor\n-\t}\n+    fn pos(&self) -> usize { self.pos }\n+\n+    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }\n+\n+    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }\n+\n+    unsafe fn move_to(&mut self, index: usize) {\n+        let index_ptr: *const _ = &self.data[index];\n+        let hole_ptr = &mut self.data[self.pos];\n+        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        self.pos = index;\n+    }\n }\n \n+impl<'a, T> Drop for Hole<'a, T> {\n+    fn drop(&mut self) {\n+        // fill the hole again\n+        unsafe {\n+            let pos = self.pos;\n+            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+        }\n+    }\n+}\n+\n+impl<T: Ord> BinaryHeap<T> {\n+    fn sift_up(&mut self, pos: usize) {\n+        unsafe {\n+            // Take out the value at `pos` and create a hole.\n+            let mut hole = Hole::new(&mut self.data, pos);\n+\n+            while hole.pos() != 0 {\n+                let parent = parent(hole.pos());\n+                if hole.removed() <= hole.get(parent) { break }\n+                hole.move_to(parent);\n+            }\n+            // Hole will be unconditionally filled here; panic or not!\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+\n+## Poisoning\n+\n+Although all unsafe code *must* ensure some minimal level of exception safety,\n+some types may choose to explicitly *poison* themselves if they witness a panic.\n+The most notable example of this is the standard library's Mutex type. A Mutex\n+will poison itself if one of its MutexGuards (the thing it returns when a lock\n+is obtained) is dropped during a panic. Any future attempts to lock the Mutex\n+will return an `Err`.\n+\n+Mutex poisons not for *true* safety in the sense that Rust normally cares about. It\n+poisons as a safety-guard against blindly using the data that comes out of a Mutex\n+that has witnessed a panic while locked. The data in such a Mutex was likely in the\n+middle of being modified, and as such may be in an inconsistent or incomplete state.\n+It is important to note that one cannot violate memory safety with such a type\n+if it is correctly written. After all, it must be exception safe!\n+\n+However if the Mutex contained, say, a BinaryHeap that does not actually have the\n+heap property, it's unlikely that any code that uses it will do\n+what the author intended. As such, the program should not proceed normally.\n+Still, if you're double-plus-sure that you can do *something* with the value,\n+the Err exposes a method to get the lock anyway. It *is* safe, after all.\n+\n+\n+\n+# FFI\n+\n+Rust's unwinding strategy is not specified to be fundamentally compatible\n+with any other language's unwinding. As such, unwinding into Rust from another\n+language, or unwinding into another language from Rust is Undefined Behaviour.\n+What you do at that point is up to you, but you must *absolutely* catch any\n+panics at the FFI boundary! At best, your application will crash and burn. At\n+worst, your application *won't* crash and burn, and will proceed with completely\n+clobbered state."}]}