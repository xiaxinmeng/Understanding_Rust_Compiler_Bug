{"sha": "cc794209681d6b11a63282bcd1513caa50127816", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzk0MjA5NjgxZDZiMTFhNjMyODJiY2QxNTEzY2FhNTAxMjc4MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-25T06:48:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-25T06:48:40Z"}, "message": "Auto merge of #50106 - nnethercote:nearest_common_ancestor, r=nikomatsakis\n\nSpeed up `nearest_common_ancestor`.\n\n`nearest_common_ancestor` can be made faster.\n\nHere are all the benchmarks where one of the measurements improved by at least 1%.\n```\nclap-rs-check\n\tavg: -4.5%\tmin: -8.8%\tmax: -0.3%\nclap-rs\n\tavg: -2.6%\tmin: -4.5%\tmax: 0.5%\nscript-servo\n\tavg: -1.7%\tmin: -3.6%\tmax: 0.0%\nregression-31157\n\tavg: -1.5%\tmin: -2.6%\tmax: -0.4%\nhyper\n\tavg: -1.2%\tmin: -2.5%\tmax: -0.0%\npiston-image\n\tavg: -1.6%\tmin: -2.5%\tmax: 0.1%\nregex\n\tavg: -1.2%\tmin: -2.2%\tmax: 0.0%\nissue-46449\n\tavg: -1.8%\tmin: -2.1%\tmax: -0.7%\ncrates.io\n\tavg: -1.2%\tmin: -2.1%\tmax: 0.0%\nhyper-check\n\tavg: -1.0%\tmin: -2.1%\tmax: -0.1%\nclap-rs-opt\n\tavg: -1.4%\tmin: -2.0%\tmax: -0.3%\npiston-image-check\n\tavg: -1.2%\tmin: -1.9%\tmax: -0.1%\nregex-check\n\tavg: -0.5%\tmin: -1.8%\tmax: -0.1%\nsyn\n\tavg: -1.1%\tmin: -1.7%\tmax: -0.1%\ntokio-webpush-simple-check\n\tavg: -1.1%\tmin: -1.6%\tmax: -0.3%\ntokio-webpush-simple\n\tavg: -1.2%\tmin: -1.6%\tmax: -0.0%\nhelloworld-check\n\tavg: -1.4%\tmin: -1.6%\tmax: -1.2%\ndeeply-nested\n\tavg: -1.2%\tmin: -1.4%\tmax: -0.8%\nencoding-check\n\tavg: -0.8%\tmin: -1.3%\tmax: -0.3%\nunify-linearly-check\n\tavg: -1.0%\tmin: -1.3%\tmax: -0.8%\nscript-servo-check\n\tavg: -0.6%\tmin: -1.3%\tmax: 0.0%\nregression-31157-check\n\tavg: -0.9%\tmin: -1.2%\tmax: -0.7%\nscript-servo-opt\n\tavg: -0.5%\tmin: -1.2%\tmax: 0.1%\ndeeply-nested-check\n\tavg: -0.8%\tmin: -1.2%\tmax: -0.7%\nencoding\n\tavg: -0.7%\tmin: -1.1%\tmax: -0.3%\nissue-46449-check\n\tavg: -0.9%\tmin: -1.1%\tmax: -0.6%\nparser-check\n\tavg: -0.9%\tmin: -1.1%\tmax: -0.8%\nhtml5ever\n\tavg: -0.5%\tmin: -1.0%\tmax: -0.0%\n```", "tree": {"sha": "b8ef0b68c7bc44d7428302588c036e068609939a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8ef0b68c7bc44d7428302588c036e068609939a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc794209681d6b11a63282bcd1513caa50127816", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc794209681d6b11a63282bcd1513caa50127816", "html_url": "https://github.com/rust-lang/rust/commit/cc794209681d6b11a63282bcd1513caa50127816", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc794209681d6b11a63282bcd1513caa50127816/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "432fe0cefc76045a98a38ba6c7a74b018aae1b7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/432fe0cefc76045a98a38ba6c7a74b018aae1b7d", "html_url": "https://github.com/rust-lang/rust/commit/432fe0cefc76045a98a38ba6c7a74b018aae1b7d"}, {"sha": "cccd51cd6e8861ba2640834c11fa67f83fa7698f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cccd51cd6e8861ba2640834c11fa67f83fa7698f", "html_url": "https://github.com/rust-lang/rust/commit/cccd51cd6e8861ba2640834c11fa67f83fa7698f"}], "stats": {"total": 140, "additions": 60, "deletions": 80}, "files": [{"sha": "5f4efbeeaa8762da80ffc0cf8119189a29e418d7", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 60, "deletions": 80, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/cc794209681d6b11a63282bcd1513caa50127816/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc794209681d6b11a63282bcd1513caa50127816/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cc794209681d6b11a63282bcd1513caa50127816", "patch": "@@ -22,6 +22,7 @@ use ty;\n \n use std::fmt;\n use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::sync::Lrc;\n use syntax::codemap;\n use syntax::ast;\n@@ -677,96 +678,75 @@ impl<'tcx> ScopeTree {\n                                    -> Scope {\n         if scope_a == scope_b { return scope_a; }\n \n-        // [1] The initial values for `a_buf` and `b_buf` are not used.\n-        // The `ancestors_of` function will return some prefix that\n-        // is re-initialized with new values (or else fallback to a\n-        // heap-allocated vector).\n-        let mut a_buf: [Scope; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<Scope> = vec![];\n-        let mut b_buf: [Scope; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<Scope> = vec![];\n-        let parent_map = &self.parent_map;\n-        let a_ancestors = ancestors_of(parent_map, scope_a, &mut a_buf, &mut a_vec);\n-        let b_ancestors = ancestors_of(parent_map, scope_b, &mut b_buf, &mut b_vec);\n-        let mut a_index = a_ancestors.len() - 1;\n-        let mut b_index = b_ancestors.len() - 1;\n-\n-        // Here, [ab]_ancestors is a vector going from narrow to broad.\n-        // The end of each vector will be the item where the scope is\n-        // defined; if there are any common ancestors, then the tails of\n-        // the vector will be the same.  So basically we want to walk\n-        // backwards from the tail of each vector and find the first point\n-        // where they diverge.  If one vector is a suffix of the other,\n-        // then the corresponding scope is a superscope of the other.\n-\n-        if a_ancestors[a_index] != b_ancestors[b_index] {\n-            // In this case, the two regions belong to completely\n-            // different functions.  Compare those fn for lexical\n-            // nesting. The reasoning behind this is subtle.  See the\n-            // \"Modeling closures\" section of the README in\n-            // infer::region_constraints for more details.\n-            let a_root_scope = a_ancestors[a_index];\n-            let b_root_scope = a_ancestors[a_index];\n-            return match (a_root_scope.data(), b_root_scope.data()) {\n-                (ScopeData::Destruction(a_root_id),\n-                 ScopeData::Destruction(b_root_id)) => {\n-                    if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n-                        // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n-                        scope_b\n-                    } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n-                        // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n-                        scope_a\n-                    } else {\n-                        // neither fn encloses the other\n-                        bug!()\n-                    }\n+        // Process the lists in tandem from the innermost scope, recording the\n+        // scopes seen so far. The first scope that comes up for a second time\n+        // is the nearest common ancestor.\n+        //\n+        // Note: another way to compute the nearest common ancestor is to get\n+        // the full scope chain for both scopes and then compare the chains to\n+        // find the first scope in a common tail. But getting a parent scope\n+        // requires a hash table lookup, and we often have very long scope\n+        // chains (10s or 100s of scopes) that only differ by a few elements at\n+        // the start. So this algorithm is faster.\n+        let mut ma = Some(scope_a);\n+        let mut mb = Some(scope_b);\n+        let mut seen: SmallVec<[Scope; 32]> = SmallVec::new();\n+        loop {\n+            if let Some(a) = ma {\n+                if seen.iter().position(|s| *s == a).is_some() {\n+                    return a;\n                 }\n-                _ => {\n-                    // root ids are always Node right now\n-                    bug!()\n+                seen.push(a);\n+                ma = self.parent_map.get(&a).map(|s| *s);\n+            }\n+\n+            if let Some(b) = mb {\n+                if seen.iter().position(|s| *s == b).is_some() {\n+                    return b;\n                 }\n-            };\n-        }\n+                seen.push(b);\n+                mb = self.parent_map.get(&b).map(|s| *s);\n+            }\n \n-        loop {\n-            // Loop invariant: a_ancestors[a_index] == b_ancestors[b_index]\n-            // for all indices between a_index and the end of the array\n-            if a_index == 0 { return scope_a; }\n-            if b_index == 0 { return scope_b; }\n-            a_index -= 1;\n-            b_index -= 1;\n-            if a_ancestors[a_index] != b_ancestors[b_index] {\n-                return a_ancestors[a_index + 1];\n+            if ma.is_none() && mb.is_none() {\n+                break;\n             }\n-        }\n+        };\n \n-        fn ancestors_of<'a, 'tcx>(parent_map: &FxHashMap<Scope, Scope>,\n-                                  scope: Scope,\n-                                  buf: &'a mut [Scope; 32],\n-                                  vec: &'a mut Vec<Scope>)\n-                                  -> &'a [Scope] {\n-            // debug!(\"ancestors_of(scope={:?})\", scope);\n+        fn outermost_scope(parent_map: &FxHashMap<Scope, Scope>, scope: Scope) -> Scope {\n             let mut scope = scope;\n-\n-            let mut i = 0;\n-            while i < 32 {\n-                buf[i] = scope;\n-                match parent_map.get(&scope) {\n-                    Some(&superscope) => scope = superscope,\n-                    _ => return &buf[..i+1]\n-                }\n-                i += 1;\n+            loop {\n+               match parent_map.get(&scope) {\n+                   Some(&superscope) => scope = superscope,\n+                   None => break scope,\n+               }\n             }\n+        }\n \n-            *vec = Vec::with_capacity(64);\n-            vec.extend_from_slice(buf);\n-            loop {\n-                vec.push(scope);\n-                match parent_map.get(&scope) {\n-                    Some(&superscope) => scope = superscope,\n-                    _ => return &*vec\n+        // In this (rare) case, the two regions belong to completely different\n+        // functions. Compare those fn for lexical nesting. The reasoning\n+        // behind this is subtle. See the \"Modeling closures\" section of the\n+        // README in infer::region_constraints for more details.\n+        let a_root_scope = outermost_scope(&self.parent_map, scope_a);\n+        let b_root_scope = outermost_scope(&self.parent_map, scope_b);\n+        match (a_root_scope.data(), b_root_scope.data()) {\n+            (ScopeData::Destruction(a_root_id),\n+             ScopeData::Destruction(b_root_id)) => {\n+                if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n+                    // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n+                    scope_b\n+                } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n+                    // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n+                    scope_a\n+                } else {\n+                    // neither fn encloses the other\n+                    bug!()\n                 }\n             }\n+            _ => {\n+                // root ids are always Node right now\n+                bug!()\n+            }\n         }\n     }\n "}]}