{"sha": "b1a3e7e9c898831dfedf1846664d651a62906505", "node_id": "C_kwDOAAsO6NoAKGIxYTNlN2U5Yzg5ODgzMWRmZWRmMTg0NjY2NGQ2NTFhNjI5MDY1MDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-04T07:41:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-04T07:41:27Z"}, "message": "Auto merge of #8937 - Jarcho:merge_match_passes, r=llogiq\n\nMerge various passes into `Matches`\n\nchangelog: None", "tree": {"sha": "27e0303cf964757986f7e6659c3acef5d78ad3d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27e0303cf964757986f7e6659c3acef5d78ad3d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1a3e7e9c898831dfedf1846664d651a62906505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a3e7e9c898831dfedf1846664d651a62906505", "html_url": "https://github.com/rust-lang/rust/commit/b1a3e7e9c898831dfedf1846664d651a62906505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1a3e7e9c898831dfedf1846664d651a62906505/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebd357e4ab7a011a98630559d723658f902163f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd357e4ab7a011a98630559d723658f902163f3", "html_url": "https://github.com/rust-lang/rust/commit/ebd357e4ab7a011a98630559d723658f902163f3"}, {"sha": "68c411ff943c71cd86d18a0b50f23b8da9d78181", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c411ff943c71cd86d18a0b50f23b8da9d78181", "html_url": "https://github.com/rust-lang/rust/commit/68c411ff943c71cd86d18a0b50f23b8da9d78181"}], "stats": {"total": 2086, "additions": 1052, "deletions": 1034}, "files": [{"sha": "d4ec046d0bb08b2100dc3cc585123b473c2ce2d2", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -38,7 +38,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n     LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(copies::IFS_SAME_COND),\n     LintId::of(copies::IF_SAME_THEN_ELSE),\n@@ -134,23 +133,25 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n-    LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n+    LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_MAP),\n+    LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n+    LintId::of(matches::MATCH_STR_CASE_MISMATCH),\n     LintId::of(matches::NEEDLESS_MATCH),\n     LintId::of(matches::REDUNDANT_PATTERN_MATCHING),\n+    LintId::of(matches::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(matches::SINGLE_MATCH),\n     LintId::of(matches::WILDCARD_IN_OR_PATTERNS),\n     LintId::of(mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n@@ -282,7 +283,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n-    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),"}, {"sha": "4f1c3673f853cd9cf8fb451c2f3a2c8ac4e01985", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -25,9 +25,9 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(loops::SINGLE_ELEMENT_LOOP),\n     LintId::of(loops::WHILE_LET_LOOP),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n+    LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),\n     LintId::of(matches::NEEDLESS_MATCH),"}, {"sha": "50cdd0af923051f2453dc36a62f3506f94a6bbac", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -39,7 +39,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(loops::ITER_NEXT_LOOP),\n     LintId::of(loops::NEVER_LOOP),\n     LintId::of(loops::WHILE_IMMUTABLE_CONDITION),\n-    LintId::of(match_str_case_mismatch::MATCH_STR_CASE_MISMATCH),\n+    LintId::of(matches::MATCH_STR_CASE_MISMATCH),\n     LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n     LintId::of(methods::CLONE_DOUBLE_REF),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),"}, {"sha": "b927ba3b17c0ec04ae34fd75ebfa46b9b130ff06", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -94,7 +94,6 @@ store.register_lints(&[\n     cognitive_complexity::COGNITIVE_COMPLEXITY,\n     collapsible_if::COLLAPSIBLE_ELSE_IF,\n     collapsible_if::COLLAPSIBLE_IF,\n-    collapsible_match::COLLAPSIBLE_MATCH,\n     comparison_chain::COMPARISON_CHAIN,\n     copies::BRANCHES_SHARING_CODE,\n     copies::IFS_SAME_COND,\n@@ -252,33 +251,36 @@ store.register_lints(&[\n     manual_assert::MANUAL_ASSERT,\n     manual_async_fn::MANUAL_ASYNC_FN,\n     manual_bits::MANUAL_BITS,\n-    manual_map::MANUAL_MAP,\n     manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n     manual_ok_or::MANUAL_OK_OR,\n     manual_strip::MANUAL_STRIP,\n-    manual_unwrap_or::MANUAL_UNWRAP_OR,\n     map_clone::MAP_CLONE,\n     map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n-    match_on_vec_items::MATCH_ON_VEC_ITEMS,\n     match_result_ok::MATCH_RESULT_OK,\n-    match_str_case_mismatch::MATCH_STR_CASE_MISMATCH,\n+    matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_MAP,\n+    matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,\n     matches::MATCH_BOOL,\n     matches::MATCH_LIKE_MATCHES_MACRO,\n+    matches::MATCH_ON_VEC_ITEMS,\n     matches::MATCH_OVERLAPPING_ARM,\n     matches::MATCH_REF_PATS,\n     matches::MATCH_SAME_ARMS,\n     matches::MATCH_SINGLE_BINDING,\n+    matches::MATCH_STR_CASE_MISMATCH,\n     matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n     matches::MATCH_WILD_ERR_ARM,\n     matches::NEEDLESS_MATCH,\n     matches::REDUNDANT_PATTERN_MATCHING,\n     matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    matches::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     matches::SINGLE_MATCH,\n     matches::SINGLE_MATCH_ELSE,\n+    matches::TRY_ERR,\n     matches::WILDCARD_ENUM_MATCH_ARM,\n     matches::WILDCARD_IN_OR_PATTERNS,\n     mem_forget::MEM_FORGET,\n@@ -480,7 +482,6 @@ store.register_lints(&[\n     shadow::SHADOW_REUSE,\n     shadow::SHADOW_SAME,\n     shadow::SHADOW_UNRELATED,\n-    significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE,\n     single_char_lifetime_names::SINGLE_CHAR_LIFETIME_NAMES,\n     single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n     size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT,\n@@ -522,7 +523,6 @@ store.register_lints(&[\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,\n     transmuting_null::TRANSMUTING_NULL,\n-    try_err::TRY_ERR,\n     types::BORROWED_BOX,\n     types::BOX_COLLECTION,\n     types::LINKEDLIST,"}, {"sha": "a8b6c5a5d63fe5f5c249239af3697bb13982580d", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -51,8 +51,8 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(macro_use::MACRO_USE_IMPORTS),\n     LintId::of(manual_assert::MANUAL_ASSERT),\n     LintId::of(manual_ok_or::MANUAL_OK_OR),\n-    LintId::of(match_on_vec_items::MATCH_ON_VEC_ITEMS),\n     LintId::of(matches::MATCH_BOOL),\n+    LintId::of(matches::MATCH_ON_VEC_ITEMS),\n     LintId::of(matches::MATCH_SAME_ARMS),\n     LintId::of(matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS),\n     LintId::of(matches::MATCH_WILD_ERR_ARM),"}, {"sha": "3695012f552389f7d7e7062218c293aac6387db9", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -31,6 +31,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n     LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n     LintId::of(matches::REST_PAT_IN_FULLY_BOUND_STRUCTS),\n+    LintId::of(matches::TRY_ERR),\n     LintId::of(matches::WILDCARD_ENUM_MATCH_ARM),\n     LintId::of(mem_forget::MEM_FORGET),\n     LintId::of(methods::CLONE_ON_REF_PTR),\n@@ -68,7 +69,6 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(strings::STRING_SLICE),\n     LintId::of(strings::STRING_TO_STRING),\n     LintId::of(strings::STR_TO_STRING),\n-    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::RC_BUFFER),\n     LintId::of(types::RC_MUTEX),\n     LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),"}, {"sha": "35575351784a287786eba32e8b2b7dfc3934227f", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -12,7 +12,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(casts::FN_TO_NUMERIC_CAST_WITH_TRUNCATION),\n     LintId::of(collapsible_if::COLLAPSIBLE_ELSE_IF),\n     LintId::of(collapsible_if::COLLAPSIBLE_IF),\n-    LintId::of(collapsible_match::COLLAPSIBLE_MATCH),\n     LintId::of(comparison_chain::COMPARISON_CHAIN),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(dereference::NEEDLESS_BORROW),\n@@ -46,11 +45,12 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(main_recursion::MAIN_RECURSION),\n     LintId::of(manual_async_fn::MANUAL_ASYNC_FN),\n     LintId::of(manual_bits::MANUAL_BITS),\n-    LintId::of(manual_map::MANUAL_MAP),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n     LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n+    LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MATCH_LIKE_MATCHES_MACRO),\n     LintId::of(matches::MATCH_OVERLAPPING_ARM),\n     LintId::of(matches::MATCH_REF_PATS),"}, {"sha": "7b13713c36e59abdc34f34765d7c18c91bfd45ee", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -24,12 +24,12 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(loops::EMPTY_LOOP),\n     LintId::of(loops::FOR_LOOPS_OVER_FALLIBLES),\n     LintId::of(loops::MUT_RANGE_BOUND),\n+    LintId::of(matches::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(methods::NO_EFFECT_REPLACE),\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(rc_clone_in_vec_init::RC_CLONE_IN_VEC_INIT),\n-    LintId::of(significant_drop_in_scrutinee::SIGNIFICANT_DROP_IN_SCRUTINEE),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),"}, {"sha": "ee0416fc0ff5e32400f85c80e09869f9bace1f98", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -193,7 +193,6 @@ mod casts;\n mod checked_conversions;\n mod cognitive_complexity;\n mod collapsible_if;\n-mod collapsible_match;\n mod comparison_chain;\n mod copies;\n mod copy_iterator;\n@@ -281,17 +280,13 @@ mod main_recursion;\n mod manual_assert;\n mod manual_async_fn;\n mod manual_bits;\n-mod manual_map;\n mod manual_non_exhaustive;\n mod manual_ok_or;\n mod manual_strip;\n-mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n mod map_unit_fn;\n-mod match_on_vec_items;\n mod match_result_ok;\n-mod match_str_case_mismatch;\n mod matches;\n mod mem_forget;\n mod mem_replace;\n@@ -372,7 +367,6 @@ mod self_named_constructors;\n mod semicolon_if_nothing_returned;\n mod serde_api;\n mod shadow;\n-mod significant_drop_in_scrutinee;\n mod single_char_lifetime_names;\n mod single_component_path_imports;\n mod size_of_in_element_count;\n@@ -391,7 +385,6 @@ mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n-mod try_err;\n mod types;\n mod undocumented_unsafe_blocks;\n mod unicode;\n@@ -569,7 +562,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(len_zero::LenZero));\n     store.register_late_pass(|| Box::new(attrs::Attributes));\n     store.register_late_pass(|| Box::new(blocks_in_if_conditions::BlocksInIfConditions));\n-    store.register_late_pass(|| Box::new(collapsible_match::CollapsibleMatch));\n     store.register_late_pass(|| Box::new(unicode::Unicode));\n     store.register_late_pass(|| Box::new(uninit_vec::UninitVec));\n     store.register_late_pass(|| Box::new(unit_hash::UnitHash));\n@@ -707,7 +699,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_late_pass(move || Box::new(pass_by_ref_or_value));\n     store.register_late_pass(|| Box::new(ref_option_ref::RefOptionRef));\n-    store.register_late_pass(|| Box::new(try_err::TryErr));\n     store.register_late_pass(|| Box::new(bytecount::ByteCount));\n     store.register_late_pass(|| Box::new(infinite_iter::InfiniteIter));\n     store.register_late_pass(|| Box::new(inline_fn_without_body::InlineFnWithoutBody));\n@@ -819,7 +810,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(if_not_else::IfNotElse));\n     store.register_late_pass(|| Box::new(equatable_if_let::PatternEquality));\n     store.register_late_pass(|| Box::new(mut_mutex_lock::MutMutexLock));\n-    store.register_late_pass(|| Box::new(match_on_vec_items::MatchOnVecItems));\n     store.register_late_pass(|| Box::new(manual_async_fn::ManualAsyncFn));\n     store.register_late_pass(|| Box::new(vec_resize_to_zero::VecResizeToZero));\n     store.register_late_pass(|| Box::new(panic_in_result_fn::PanicInResultFn));\n@@ -837,7 +827,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(repeat_once::RepeatOnce));\n     store.register_late_pass(|| Box::new(unwrap_in_result::UnwrapInResult));\n     store.register_late_pass(|| Box::new(self_assignment::SelfAssignment));\n-    store.register_late_pass(|| Box::new(manual_unwrap_or::ManualUnwrapOr));\n     store.register_late_pass(|| Box::new(manual_ok_or::ManualOkOr));\n     store.register_late_pass(|| Box::new(float_equality_without_abs::FloatEqualityWithoutAbs));\n     store.register_late_pass(|| Box::new(semicolon_if_nothing_returned::SemicolonIfNothingReturned));\n@@ -856,7 +845,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_late_pass(|| Box::new(redundant_slicing::RedundantSlicing));\n     store.register_late_pass(|| Box::new(from_str_radix_10::FromStrRadix10));\n-    store.register_late_pass(|| Box::new(manual_map::ManualMap));\n     store.register_late_pass(move || Box::new(if_then_some_else_none::IfThenSomeElseNone::new(msrv)));\n     store.register_late_pass(|| Box::new(bool_assert_comparison::BoolAssertComparison));\n     store.register_early_pass(move || Box::new(module_style::ModStyle));\n@@ -882,7 +870,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         ))\n     });\n     store.register_late_pass(move || Box::new(undocumented_unsafe_blocks::UndocumentedUnsafeBlocks));\n-    store.register_late_pass(|| Box::new(match_str_case_mismatch::MatchStrCaseMismatch));\n     store.register_late_pass(move || Box::new(format_args::FormatArgs));\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n     store.register_early_pass(|| Box::new(octal_escapes::OctalEscapes));\n@@ -895,7 +882,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n     store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n-    store.register_late_pass(|| Box::new(significant_drop_in_scrutinee::SignificantDropInScrutinee));\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;"}, {"sha": "230ae029ed9d28978eeb256c40604e24e0df1d81", "filename": "clippy_lints/src/manual_map.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=ebd357e4ab7a011a98630559d723658f902163f3", "patch": "@@ -1,316 +0,0 @@\n-use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher::IfLetOrMatch;\n-use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n-use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n-};\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n-    QPath, UnsafeSource,\n-};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, SyntaxContext};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of `match` which could be implemented using `map`\n-    ///\n-    /// ### Why is this bad?\n-    /// Using the `map` method is clearer and more concise.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// match Some(0) {\n-    ///     Some(x) => Some(x + 1),\n-    ///     None => None,\n-    /// };\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// Some(0).map(|x| x + 1);\n-    /// ```\n-    #[clippy::version = \"1.52.0\"]\n-    pub MANUAL_MAP,\n-    style,\n-    \"reimplementation of `map`\"\n-}\n-\n-declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualMap {\n-    #[expect(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (scrutinee, then_pat, then_body, else_pat, else_body) = match IfLetOrMatch::parse(cx, expr) {\n-            Some(IfLetOrMatch::IfLet(scrutinee, pat, body, Some(r#else))) => (scrutinee, pat, body, None, r#else),\n-            Some(IfLetOrMatch::Match(\n-                scrutinee,\n-                [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n-                _,\n-            )) => (scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body),\n-            _ => return,\n-        };\n-        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-            return;\n-        }\n-\n-        let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-            peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-        if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n-            && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n-        {\n-            return;\n-        }\n-\n-        let expr_ctxt = expr.span.ctxt();\n-        let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-            try_parse_pattern(cx, then_pat, expr_ctxt),\n-            else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n-        ) {\n-            (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-                (else_body, pattern, ref_count, true)\n-            },\n-            (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-                (else_body, pattern, ref_count, false)\n-            },\n-            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n-                (then_body, pattern, ref_count, true)\n-            },\n-            (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n-                (then_body, pattern, ref_count, false)\n-            },\n-            _ => return,\n-        };\n-\n-        // Top level or patterns aren't allowed in closures.\n-        if matches!(some_pat.kind, PatKind::Or(_)) {\n-            return;\n-        }\n-\n-        let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n-            Some(expr) => expr,\n-            None => return,\n-        };\n-\n-        // These two lints will go back and forth with each other.\n-        if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n-            && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-        {\n-            return;\n-        }\n-\n-        // `map` won't perform any adjustments.\n-        if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-            return;\n-        }\n-\n-        // Determine which binding mode to use.\n-        let explicit_ref = some_pat.contains_explicit_ref_binding();\n-        let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n-\n-        let as_ref_str = match binding_ref {\n-            Some(Mutability::Mut) => \".as_mut()\",\n-            Some(Mutability::Not) => \".as_ref()\",\n-            None => \"\",\n-        };\n-\n-        match can_move_expr_to_closure(cx, some_expr.expr) {\n-            Some(captures) => {\n-                // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-                // TODO: check all the references made in the scrutinee expression. This will require interacting\n-                // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-                if let Some(binding_ref_mutability) = binding_ref {\n-                    let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                        ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                        _ => None,\n-                    });\n-                    if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                        match captures.get(l) {\n-                            Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                            Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                                return;\n-                            },\n-                            Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                        }\n-                    }\n-                }\n-            },\n-            None => return,\n-        };\n-\n-        let mut app = Applicability::MachineApplicable;\n-\n-        // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-        // it's being passed by value.\n-        let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-        let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-        let scrutinee_str =\n-            if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-                format!(\"({})\", scrutinee_str)\n-            } else {\n-                scrutinee_str.into()\n-            };\n-\n-        let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-            if_chain! {\n-                if !some_expr.needs_unsafe_block;\n-                if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n-                if func.span.ctxt() == some_expr.expr.span.ctxt();\n-                then {\n-                    snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                } else {\n-                    if path_to_local_id(some_expr.expr, id)\n-                        && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                        && binding_ref.is_some()\n-                    {\n-                        return;\n-                    }\n-\n-                    // `ref` and `ref mut` annotations were handled earlier.\n-                    let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                        \"mut \"\n-                    } else {\n-                        \"\"\n-                    };\n-                    let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-                    if some_expr.needs_unsafe_block {\n-                        format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n-                    } else {\n-                        format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n-                    }\n-                }\n-            }\n-        } else if !is_wild_none && explicit_ref.is_none() {\n-            // TODO: handle explicit reference annotations.\n-            let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-            let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-            if some_expr.needs_unsafe_block {\n-                format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n-            } else {\n-                format!(\"|{}| {}\", pat_snip, expr_snip)\n-            }\n-        } else {\n-            // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-            return;\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            MANUAL_MAP,\n-            expr.span,\n-            \"manual implementation of `Option::map`\",\n-            \"try this\",\n-            if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-                format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-            } else {\n-                format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-            },\n-            app,\n-        );\n-    }\n-}\n-\n-// Checks whether the expression could be passed as a function, or whether a closure is needed.\n-// Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match expr.kind {\n-        ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding)\n-                && cx.typeck_results().expr_adjustments(arg).is_empty()\n-                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n-        {\n-            Some(func)\n-        },\n-        _ => None,\n-    }\n-}\n-\n-enum OptionPat<'a> {\n-    Wild,\n-    None,\n-    Some {\n-        // The pattern contained in the `Some` tuple.\n-        pattern: &'a Pat<'a>,\n-        // The number of references before the `Some` tuple.\n-        // e.g. `&&Some(_)` has a ref count of 2.\n-        ref_count: usize,\n-    },\n-}\n-\n-struct SomeExpr<'tcx> {\n-    expr: &'tcx Expr<'tcx>,\n-    needs_unsafe_block: bool,\n-}\n-\n-// Try to parse into a recognized `Option` pattern.\n-// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        pat: &'tcx Pat<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n-            PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n-                Some(OptionPat::Some { pattern, ref_count })\n-            },\n-            _ => None,\n-        }\n-    }\n-    f(cx, pat, 0, ctxt)\n-}\n-\n-// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n-fn get_some_expr<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    needs_unsafe_block: bool,\n-    ctxt: SyntaxContext,\n-) -> Option<SomeExpr<'tcx>> {\n-    // TODO: Allow more complex expressions.\n-    match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                rules,\n-                ..\n-            },\n-            _,\n-        ) => get_some_expr(\n-            cx,\n-            expr,\n-            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-            ctxt,\n-        ),\n-        _ => None,\n-    }\n-}\n-\n-// Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}"}, {"sha": "b3a91d9f18f5d94ff4d782900996310d161ed6f9", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=ebd357e4ab7a011a98630559d723658f902163f3", "patch": "@@ -1,123 +0,0 @@\n-use clippy_utils::consts::constant_simple;\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{in_constant, is_lang_ctor, path_to_local_id, sugg};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n-use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n-use rustc_lint::LintContext;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Concise code helps focusing on behavior instead of boilerplate.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// match foo {\n-    ///     Some(v) => v,\n-    ///     None => 1,\n-    /// };\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust\n-    /// let foo: Option<i32> = None;\n-    /// foo.unwrap_or(1);\n-    /// ```\n-    #[clippy::version = \"1.49.0\"]\n-    pub MANUAL_UNWRAP_OR,\n-    complexity,\n-    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n-}\n-\n-declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for ManualUnwrapOr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-            return;\n-        }\n-        lint_manual_unwrap_or(cx, expr);\n-    }\n-}\n-\n-fn lint_manual_unwrap_or<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-    fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n-        if_chain! {\n-            if arms.len() == 2;\n-            if arms.iter().all(|arm| arm.guard.is_none());\n-            if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n-                match arm.pat.kind {\n-                    PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-                    PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                        matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n-                    _ => false,\n-                }\n-            });\n-            let unwrap_arm = &arms[1 - idx];\n-            if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-            if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n-            if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n-            if path_to_local_id(unwrap_arm.body, binding_hir_id);\n-            if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();\n-            if !contains_return_break_continue_macro(or_arm.body);\n-            then {\n-                Some(or_arm)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    if_chain! {\n-        if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n-        let ty = cx.typeck_results().expr_ty(scrutinee);\n-        if let Some(ty_name) = if is_type_diagnostic_item(cx, ty, sym::Option) {\n-            Some(\"Option\")\n-        } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n-            Some(\"Result\")\n-        } else {\n-            None\n-        };\n-        if let Some(or_arm) = applicable_or_arm(cx, match_arms);\n-        if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n-        if let Some(indent) = indent_of(cx, expr.span);\n-        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n-        then {\n-            let reindented_or_body =\n-                reindent_multiline(or_body_snippet.into(), true, Some(indent));\n-\n-            let suggestion = if scrutinee.span.from_expansion() {\n-                    // we don't want parentheses around macro, e.g. `(some_macro!()).unwrap_or(0)`\n-                    sugg::Sugg::hir_with_macro_callsite(cx, scrutinee, \"..\")\n-                }\n-                else {\n-                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par()\n-                };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_UNWRAP_OR, expr.span,\n-                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n-                \"replace with\",\n-                format!(\n-                    \"{}.unwrap_or({})\",\n-                    suggestion,\n-                    reindented_or_body,\n-                ),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}"}, {"sha": "583b577ffe25d51ea72332b2e130b77c07b7ba20", "filename": "clippy_lints/src/match_on_vec_items.rs", "status": "removed", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_on_vec_items.rs?ref=ebd357e4ab7a011a98630559d723658f902163f3", "patch": "@@ -1,104 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, LangItem, MatchSource};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match vec[idx]` or `match vec[n..m]`.\n-    ///\n-    /// ### Why is this bad?\n-    /// This can panic at runtime.\n-    ///\n-    /// ### Example\n-    /// ```rust, no_run\n-    /// let arr = vec![0, 1, 2, 3];\n-    /// let idx = 1;\n-    ///\n-    /// // Bad\n-    /// match arr[idx] {\n-    ///     0 => println!(\"{}\", 0),\n-    ///     1 => println!(\"{}\", 3),\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust, no_run\n-    /// let arr = vec![0, 1, 2, 3];\n-    /// let idx = 1;\n-    ///\n-    /// // Good\n-    /// match arr.get(idx) {\n-    ///     Some(0) => println!(\"{}\", 0),\n-    ///     Some(1) => println!(\"{}\", 3),\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.45.0\"]\n-    pub MATCH_ON_VEC_ITEMS,\n-    pedantic,\n-    \"matching on vector elements can panic\"\n-}\n-\n-declare_lint_pass!(MatchOnVecItems => [MATCH_ON_VEC_ITEMS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MatchOnVecItems {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if !in_external_macro(cx.sess(), expr.span);\n-            if let ExprKind::Match(match_expr, _, MatchSource::Normal) = expr.kind;\n-            if let Some(idx_expr) = is_vec_indexing(cx, match_expr);\n-            if let ExprKind::Index(vec, idx) = idx_expr.kind;\n-\n-            then {\n-                // FIXME: could be improved to suggest surrounding every pattern with Some(_),\n-                // but only when `or_patterns` are stabilized.\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_ON_VEC_ITEMS,\n-                    match_expr.span,\n-                    \"indexing into a vector may panic\",\n-                    \"try this\",\n-                    format!(\n-                        \"{}.get({})\",\n-                        snippet(cx, vec.span, \"..\"),\n-                        snippet(cx, idx.span, \"..\")\n-                    ),\n-                    Applicability::MaybeIncorrect\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if_chain! {\n-        if let ExprKind::Index(array, index) = expr.kind;\n-        if is_vector(cx, array);\n-        if !is_full_range(cx, index);\n-\n-        then {\n-            return Some(expr);\n-        }\n-    }\n-\n-    None\n-}\n-\n-fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    let ty = ty.peel_refs();\n-    is_type_diagnostic_item(cx, ty, sym::Vec)\n-}\n-\n-fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    let ty = ty.peel_refs();\n-    is_type_lang_item(cx, ty, LangItem::RangeFull)\n-}"}, {"sha": "07021f1bcad8db24b6f625a618a2c03d24477392", "filename": "clippy_lints/src/matches/collapsible_match.rs", "status": "renamed", "additions": 15, "deletions": 55, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -6,68 +6,28 @@ use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n use rustc_hir::{Arm, Expr, Guard, HirId, Let, Pat, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_lint::LateContext;\n use rustc_span::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n-    /// without adding any branches.\n-    ///\n-    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n-    /// cases where merging would most likely make the code more readable.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is unnecessarily verbose and complex.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn func(opt: Option<Result<u64, String>>) {\n-    ///     let n = match opt {\n-    ///         Some(n) => match n {\n-    ///             Ok(n) => n,\n-    ///             _ => return,\n-    ///         }\n-    ///         None => return,\n-    ///     };\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// fn func(opt: Option<Result<u64, String>>) {\n-    ///     let n = match opt {\n-    ///         Some(Ok(n)) => n,\n-    ///         _ => return,\n-    ///     };\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.50.0\"]\n-    pub COLLAPSIBLE_MATCH,\n-    style,\n-    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n-}\n-\n-declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n+use super::COLLAPSIBLE_MATCH;\n \n-impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n-        match IfLetOrMatch::parse(cx, expr) {\n-            Some(IfLetOrMatch::Match(_, arms, _)) => {\n-                if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n-                    for arm in arms {\n-                        check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n-                    }\n-                }\n-            },\n-            Some(IfLetOrMatch::IfLet(_, pat, body, els)) => {\n-                check_arm(cx, false, pat, body, None, els);\n-            },\n-            None => {},\n+pub(super) fn check_match<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+    if let Some(els_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+        for arm in arms {\n+            check_arm(cx, true, arm.pat, arm.body, arm.guard.as_ref(), Some(els_arm.body));\n         }\n     }\n }\n \n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    body: &'tcx Expr<'_>,\n+    else_expr: Option<&'tcx Expr<'_>>,\n+) {\n+    check_arm(cx, false, pat, body, None, else_expr);\n+}\n+\n fn check_arm<'tcx>(\n     cx: &LateContext<'tcx>,\n     outer_is_match: bool,", "previous_filename": "clippy_lints/src/collapsible_match.rs"}, {"sha": "542905a2d763cffa4879b4f75d7acefa3e4aa7a3", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -0,0 +1,306 @@\n+use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::{\n+    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n+    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{\n+    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n+    QPath, UnsafeSource,\n+};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+use super::MANUAL_MAP;\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+) {\n+    if let [arm1, arm2] = arms\n+        && arm1.guard.is_none()\n+        && arm2.guard.is_none()\n+    {\n+        check(cx, expr, scrutinee, arm1.pat, arm1.body, Some(arm2.pat), arm2.body);\n+    }\n+}\n+\n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n+}\n+\n+#[expect(clippy::too_many_lines)]\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+) {\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n+    {\n+        return;\n+    }\n+\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, false)\n+        },\n+        _ => return,\n+    };\n+\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return;\n+    }\n+\n+    let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return,\n+    };\n+\n+    // These two lints will go back and forth with each other.\n+    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n+        return;\n+    }\n+\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n+        return;\n+    }\n+\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    match can_move_expr_to_closure(cx, some_expr.expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return,\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({})\", scrutinee_str)\n+    } else {\n+        scrutinee_str.into()\n+    };\n+\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        if_chain! {\n+            if !some_expr.needs_unsafe_block;\n+            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+            if func.span.ctxt() == some_expr.expr.span.ctxt();\n+            then {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            } else {\n+                if path_to_local_id(some_expr.expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return;\n+                }\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+                let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+                if some_expr.needs_unsafe_block {\n+                    format!(\"|{}{}| unsafe {{ {} }}\", annotation, some_binding, expr_snip)\n+                } else {\n+                    format!(\"|{}{}| {}\", annotation, some_binding, expr_snip)\n+                }\n+            }\n+        }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+        let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n+        if some_expr.needs_unsafe_block {\n+            format!(\"|{}| unsafe {{ {} }}\", pat_snip, expr_snip)\n+        } else {\n+            format!(\"|{}| {}\", pat_snip, expr_snip)\n+        }\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return;\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_MAP,\n+        expr.span,\n+        \"manual implementation of `Option::map`\",\n+        \"try this\",\n+        if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n+            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+        } else {\n+            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+        },\n+        app,\n+    );\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+struct SomeExpr<'tcx> {\n+    expr: &'tcx Expr<'tcx>,\n+    needs_unsafe_block: bool,\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0, ctxt)\n+}\n+\n+// Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n+fn get_some_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    needs_unsafe_block: bool,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n+    // TODO: Allow more complex expressions.\n+    match expr.kind {\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(ref qpath),\n+                ..\n+            },\n+            [arg],\n+        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n+            expr: arg,\n+            needs_unsafe_block,\n+        }),\n+        ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr: Some(expr),\n+                rules,\n+                ..\n+            },\n+            _,\n+        ) => get_some_expr(\n+            cx,\n+            expr,\n+            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+            ctxt,\n+        ),\n+        _ => None,\n+    }\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+}"}, {"sha": "e1111c80f2fe287712dd64b73b656060b9038e3f", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -0,0 +1,83 @@\n+use clippy_utils::consts::constant_simple;\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::usage::contains_return_break_continue_macro;\n+use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MANUAL_UNWRAP_OR;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, scrutinee: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(scrutinee);\n+    if_chain! {\n+        if let Some(ty_name) = if is_type_diagnostic_item(cx, ty, sym::Option) {\n+            Some(\"Option\")\n+        } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n+            Some(\"Result\")\n+        } else {\n+            None\n+        };\n+        if let Some(or_arm) = applicable_or_arm(cx, arms);\n+        if let Some(or_body_snippet) = snippet_opt(cx, or_arm.body.span);\n+        if let Some(indent) = indent_of(cx, expr.span);\n+        if constant_simple(cx, cx.typeck_results(), or_arm.body).is_some();\n+        then {\n+            let reindented_or_body =\n+                reindent_multiline(or_body_snippet.into(), true, Some(indent));\n+\n+            let suggestion = if scrutinee.span.from_expansion() {\n+                    // we don't want parentheses around macro, e.g. `(some_macro!()).unwrap_or(0)`\n+                    sugg::Sugg::hir_with_macro_callsite(cx, scrutinee, \"..\")\n+                }\n+                else {\n+                    sugg::Sugg::hir(cx, scrutinee, \"..\").maybe_par()\n+                };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                MANUAL_UNWRAP_OR, expr.span,\n+                &format!(\"this pattern reimplements `{}::unwrap_or`\", ty_name),\n+                \"replace with\",\n+                format!(\n+                    \"{}.unwrap_or({})\",\n+                    suggestion,\n+                    reindented_or_body,\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if arms.iter().all(|arm| arm.guard.is_none());\n+        if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n+            match arm.pat.kind {\n+                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::TupleStruct(ref qpath, [pat], _) =>\n+                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                _ => false,\n+            }\n+        });\n+        let unwrap_arm = &arms[1 - idx];\n+        if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n+        if path_to_local_id(unwrap_arm.body, binding_hir_id);\n+        if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();\n+        if !contains_return_break_continue_macro(or_arm.body);\n+        then {\n+            Some(or_arm)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "a68eec842abc51a08418e793c9b670e93e5b45a6", "filename": "clippy_lints/src/matches/match_like_matches.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_wild;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{higher, is_wild};\n use rustc_ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Guard, Pat};\n@@ -11,22 +11,24 @@ use rustc_span::source_map::Spanned;\n use super::MATCH_LIKE_MATCHES_MACRO;\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let Some(higher::IfLet {\n-        let_pat,\n+pub(crate) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    find_matches_sugg(\n+        cx,\n         let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n+        IntoIterator::into_iter([\n+            (&[][..], Some(let_pat), then_expr, None),\n+            (&[][..], None, else_expr, None),\n+        ]),\n+        expr,\n+        true,\n+    );\n }\n \n pub(super) fn check_match<'tcx>("}, {"sha": "2917f85c45f53250d889ec05242dfb5234ba15fa", "filename": "clippy_lints/src/matches/match_on_vec_items.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_on_vec_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_on_vec_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_on_vec_items.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -0,0 +1,61 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::MATCH_ON_VEC_ITEMS;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'_>) {\n+    if_chain! {\n+        if let Some(idx_expr) = is_vec_indexing(cx, scrutinee);\n+        if let ExprKind::Index(vec, idx) = idx_expr.kind;\n+\n+        then {\n+            // FIXME: could be improved to suggest surrounding every pattern with Some(_),\n+            // but only when `or_patterns` are stabilized.\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_ON_VEC_ITEMS,\n+                scrutinee.span,\n+                \"indexing into a vector may panic\",\n+                \"try this\",\n+                format!(\n+                    \"{}.get({})\",\n+                    snippet(cx, vec.span, \"..\"),\n+                    snippet(cx, idx.span, \"..\")\n+                ),\n+                Applicability::MaybeIncorrect\n+            );\n+        }\n+    }\n+}\n+\n+fn is_vec_indexing<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    if_chain! {\n+        if let ExprKind::Index(array, index) = expr.kind;\n+        if is_vector(cx, array);\n+        if !is_full_range(cx, index);\n+\n+        then {\n+            return Some(expr);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn is_vector(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let ty = ty.peel_refs();\n+    is_type_diagnostic_item(cx, ty, sym::Vec)\n+}\n+\n+fn is_full_range(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    let ty = ty.peel_refs();\n+    is_type_lang_item(cx, ty, LangItem::RangeFull)\n+}"}, {"sha": "8302ce426e5707e257db4116b21740abb3e95a74", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "renamed", "additions": 18, "deletions": 55, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -3,46 +3,13 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{Arm, Expr, ExprKind, MatchSource, PatKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Symbol;\n use rustc_span::{sym, Span};\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match` expressions modifying the case of a string with non-compliant arms\n-    ///\n-    /// ### Why is this bad?\n-    /// The arm is unreachable, which is likely a mistake\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let text = \"Foo\";\n-    /// match &*text.to_ascii_lowercase() {\n-    ///     \"foo\" => {},\n-    ///     \"Bar\" => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # let text = \"Foo\";\n-    /// match &*text.to_ascii_lowercase() {\n-    ///     \"foo\" => {},\n-    ///     \"bar\" => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.58.0\"]\n-    pub MATCH_STR_CASE_MISMATCH,\n-    correctness,\n-    \"creation of a case altering match expression with non-compliant arms\"\n-}\n-\n-declare_lint_pass!(MatchStrCaseMismatch => [MATCH_STR_CASE_MISMATCH]);\n+use super::MATCH_STR_CASE_MISMATCH;\n \n #[derive(Debug)]\n enum CaseMethod {\n@@ -52,25 +19,21 @@ enum CaseMethod {\n     AsciiUppercase,\n }\n \n-impl<'tcx> LateLintPass<'tcx> for MatchStrCaseMismatch {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if !in_external_macro(cx.tcx.sess, expr.span);\n-            if let ExprKind::Match(match_expr, arms, MatchSource::Normal) = expr.kind;\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(match_expr).kind();\n-            if let ty::Str = ty.kind();\n-            then {\n-                let mut visitor = MatchExprVisitor {\n-                    cx,\n-                    case_method: None,\n-                };\n-\n-                visitor.visit_expr(match_expr);\n-\n-                if let Some(case_method) = visitor.case_method {\n-                    if let Some((bad_case_span, bad_case_sym)) = verify_case(&case_method, arms) {\n-                        lint(cx, &case_method, bad_case_span, bad_case_sym.as_str());\n-                    }\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, scrutinee: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    if_chain! {\n+        if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty(scrutinee).kind();\n+        if let ty::Str = ty.kind();\n+        then {\n+            let mut visitor = MatchExprVisitor {\n+                cx,\n+                case_method: None,\n+            };\n+\n+            visitor.visit_expr(scrutinee);\n+\n+            if let Some(case_method) = visitor.case_method {\n+                if let Some((bad_case_span, bad_case_sym)) = verify_case(&case_method, arms) {\n+                    lint(cx, &case_method, bad_case_span, bad_case_sym.as_str());\n                 }\n             }\n         }", "previous_filename": "clippy_lints/src/match_str_case_mismatch.rs"}, {"sha": "d1e42f39e470dde07bdf5daee81a034846d5dd97", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 338, "deletions": 13, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -1,26 +1,34 @@\n use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n-use clippy_utils::{meets_msrv, msrvs};\n+use clippy_utils::{higher, in_constant, meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{Span, SpanData, SyntaxContext};\n \n+mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_map;\n+mod manual_unwrap_or;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n+mod match_on_vec_items;\n mod match_ref_pats;\n mod match_same_arms;\n mod match_single_binding;\n+mod match_str_case_mismatch;\n mod match_wild_enum;\n mod match_wild_err_arm;\n mod needless_match;\n mod overlapping_arms;\n mod redundant_pattern_match;\n mod rest_pat_in_fully_bound_struct;\n+mod significant_drop_in_scrutinee;\n mod single_match;\n+mod try_err;\n mod wild_in_or_pats;\n \n declare_clippy_lint! {\n@@ -610,6 +618,274 @@ declare_clippy_lint! {\n     \"`match` or match-like `if let` that are unnecessary\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds nested `match` or `if let` expressions where the patterns may be \"collapsed\" together\n+    /// without adding any branches.\n+    ///\n+    /// Note that this lint is not intended to find _all_ cases where nested match patterns can be merged, but only\n+    /// cases where merging would most likely make the code more readable.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is unnecessarily verbose and complex.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(n) => match n {\n+    ///             Ok(n) => n,\n+    ///             _ => return,\n+    ///         }\n+    ///         None => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn func(opt: Option<Result<u64, String>>) {\n+    ///     let n = match opt {\n+    ///         Some(Ok(n)) => n,\n+    ///         _ => return,\n+    ///     };\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.50.0\"]\n+    pub COLLAPSIBLE_MATCH,\n+    style,\n+    \"Nested `match` or `if let` expressions where the patterns may be \\\"collapsed\\\" together.\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds patterns that reimplement `Option::unwrap_or` or `Result::unwrap_or`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// match foo {\n+    ///     Some(v) => v,\n+    ///     None => 1,\n+    /// };\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.unwrap_or(1);\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub MANUAL_UNWRAP_OR,\n+    complexity,\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or` or `Result::unwrap_or`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match vec[idx]` or `match vec[n..m]`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This can panic at runtime.\n+    ///\n+    /// ### Example\n+    /// ```rust, no_run\n+    /// let arr = vec![0, 1, 2, 3];\n+    /// let idx = 1;\n+    ///\n+    /// // Bad\n+    /// match arr[idx] {\n+    ///     0 => println!(\"{}\", 0),\n+    ///     1 => println!(\"{}\", 3),\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust, no_run\n+    /// let arr = vec![0, 1, 2, 3];\n+    /// let idx = 1;\n+    ///\n+    /// // Good\n+    /// match arr.get(idx) {\n+    ///     Some(0) => println!(\"{}\", 0),\n+    ///     Some(1) => println!(\"{}\", 3),\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.45.0\"]\n+    pub MATCH_ON_VEC_ITEMS,\n+    pedantic,\n+    \"matching on vector elements can panic\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match` expressions modifying the case of a string with non-compliant arms\n+    ///\n+    /// ### Why is this bad?\n+    /// The arm is unreachable, which is likely a mistake\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let text = \"Foo\";\n+    /// match &*text.to_ascii_lowercase() {\n+    ///     \"foo\" => {},\n+    ///     \"Bar\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let text = \"Foo\";\n+    /// match &*text.to_ascii_lowercase() {\n+    ///     \"foo\" => {},\n+    ///     \"bar\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub MATCH_STR_CASE_MISMATCH,\n+    correctness,\n+    \"creation of a case altering match expression with non-compliant arms\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check for temporaries returned from function calls in a match scrutinee that have the\n+    /// `clippy::has_significant_drop` attribute.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\n+    /// an important side-effect, such as unlocking a mutex, making it important for users to be\n+    /// able to accurately understand their lifetimes. When a temporary is returned in a function\n+    /// call in a match scrutinee, its lifetime lasts until the end of the match block, which may\n+    /// be surprising.\n+    ///\n+    /// For `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\n+    /// function call that returns a `MutexGuard` and then tries to lock again in one of the match\n+    /// arms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\n+    /// the match block and thus will not unlock.\n+    ///\n+    /// ### Example\n+    /// ```rust.ignore\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// match mutex.lock().unwrap().foo() {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar(); // Deadlock!\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    ///\n+    /// # struct State {}\n+    ///\n+    /// # impl State {\n+    /// #     fn foo(&self) -> bool {\n+    /// #         true\n+    /// #     }\n+    ///\n+    /// #     fn bar(&self) {}\n+    /// # }\n+    ///\n+    /// let mutex = Mutex::new(State {});\n+    ///\n+    /// let is_foo = mutex.lock().unwrap().foo();\n+    /// match is_foo {\n+    ///     true => {\n+    ///         mutex.lock().unwrap().bar();\n+    ///     }\n+    ///     false => {}\n+    /// };\n+    ///\n+    /// println!(\"All done!\");\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub SIGNIFICANT_DROP_IN_SCRUTINEE,\n+    suspicious,\n+    \"warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `Err(x)?`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `?` operator is designed to allow calls that\n+    /// can fail to be easily chained. For example, `foo()?.bar()` or\n+    /// `foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\n+    /// always return), it is more clear to write `return Err(x)`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// fn foo(fail: bool) -> Result<i32, String> {\n+    ///     if fail {\n+    ///       Err(\"failed\")?;\n+    ///     }\n+    ///     Ok(0)\n+    /// }\n+    /// ```\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// fn foo(fail: bool) -> Result<i32, String> {\n+    ///     if fail {\n+    ///       return Err(\"failed\".into());\n+    ///     }\n+    ///     Ok(0)\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.38.0\"]\n+    pub TRY_ERR,\n+    restriction,\n+    \"return errors explicitly rather than hiding them behind a `?`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `match` which could be implemented using `map`\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the `map` method is clearer and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => Some(x + 1),\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).map(|x| x + 1);\n+    /// ```\n+    #[clippy::version = \"1.52.0\"]\n+    pub MANUAL_MAP,\n+    style,\n+    \"reimplementation of `map`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -644,19 +920,42 @@ impl_lint_pass!(Matches => [\n     MATCH_LIKE_MATCHES_MACRO,\n     MATCH_SAME_ARMS,\n     NEEDLESS_MATCH,\n+    COLLAPSIBLE_MATCH,\n+    MANUAL_UNWRAP_OR,\n+    MATCH_ON_VEC_ITEMS,\n+    MATCH_STR_CASE_MISMATCH,\n+    SIGNIFICANT_DROP_IN_SCRUTINEE,\n+    TRY_ERR,\n+    MANUAL_MAP,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n+        if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+        let from_expansion = expr.span.from_expansion();\n \n         if let ExprKind::Match(ex, arms, source) = expr.kind {\n-            if !span_starts_with(cx, expr.span, \"match\") {\n+            if source == MatchSource::Normal && !span_starts_with(cx, expr.span, \"match\") {\n                 return;\n             }\n-            if !contains_cfg_arm(cx, expr, ex, arms) {\n+            if matches!(source, MatchSource::Normal | MatchSource::ForLoopDesugar) {\n+                significant_drop_in_scrutinee::check(cx, expr, ex, source);\n+            }\n+\n+            collapsible_match::check_match(cx, arms);\n+            if !from_expansion {\n+                // These don't depend on a relationship between multiple arms\n+                match_wild_err_arm::check(cx, ex, arms);\n+                wild_in_or_pats::check(cx, arms);\n+            }\n+\n+            if source == MatchSource::TryDesugar {\n+                try_err::check(cx, expr, ex);\n+            }\n+\n+            if !from_expansion && !contains_cfg_arm(cx, expr, ex, arms) {\n                 if source == MatchSource::Normal {\n                     if !(meets_msrv(self.msrv, msrvs::MATCHES_MACRO)\n                         && match_like_matches::check_match(cx, expr, ex, arms))\n@@ -671,6 +970,13 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     match_wild_enum::check(cx, ex, arms);\n                     match_as_ref::check(cx, ex, arms, expr);\n                     needless_match::check_match(cx, ex, arms, expr);\n+                    match_on_vec_items::check(cx, ex);\n+                    match_str_case_mismatch::check(cx, ex, arms);\n+\n+                    if !in_constant(cx, expr.hir_id) {\n+                        manual_unwrap_or::check(cx, expr, ex, arms);\n+                        manual_map::check_match(cx, expr, ex, arms);\n+                    }\n \n                     if self.infallible_destructuring_match_linted {\n                         self.infallible_destructuring_match_linted = false;\n@@ -680,16 +986,35 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 }\n                 match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n             }\n-\n-            // These don't depend on a relationship between multiple arms\n-            match_wild_err_arm::check(cx, ex, arms);\n-            wild_in_or_pats::check(cx, arms);\n-        } else {\n-            if meets_msrv(self.msrv, msrvs::MATCHES_MACRO) {\n-                match_like_matches::check(cx, expr);\n+        } else if let Some(if_let) = higher::IfLet::hir(cx, expr) {\n+            collapsible_match::check_if_let(cx, if_let.let_pat, if_let.if_then, if_let.if_else);\n+            if !from_expansion {\n+                if let Some(else_expr) = if_let.if_else {\n+                    if meets_msrv(self.msrv, msrvs::MATCHES_MACRO) {\n+                        match_like_matches::check_if_let(\n+                            cx,\n+                            expr,\n+                            if_let.let_pat,\n+                            if_let.let_expr,\n+                            if_let.if_then,\n+                            else_expr,\n+                        );\n+                    }\n+                    if !in_constant(cx, expr.hir_id) {\n+                        manual_map::check_if_let(cx, expr, if_let.let_pat, if_let.let_expr, if_let.if_then, else_expr);\n+                    }\n+                }\n+                redundant_pattern_match::check_if_let(\n+                    cx,\n+                    expr,\n+                    if_let.let_pat,\n+                    if_let.let_expr,\n+                    if_let.if_else.is_some(),\n+                );\n+                needless_match::check_if_let(cx, expr, &if_let);\n             }\n+        } else if !from_expansion {\n             redundant_pattern_match::check(cx, expr);\n-            needless_match::check(cx, expr);\n         }\n     }\n "}, {"sha": "fa19cddd35ec7afff4258f68eb901967e01b411b", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -47,20 +47,18 @@ pub(crate) fn check_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>],\n ///     some_enum\n /// }\n /// ```\n-pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>) {\n-    if let Some(ref if_let) = higher::IfLet::hir(cx, ex) {\n-        if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let(cx, if_let) {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_MATCH,\n-                ex.span,\n-                \"this if-let expression is unnecessary\",\n-                \"replace it with\",\n-                snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n-                applicability,\n-            );\n-        }\n+pub(crate) fn check_if_let<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'_>, if_let: &higher::IfLet<'tcx>) {\n+    if !is_else_clause(cx.tcx, ex) && expr_ty_matches_p_ty(cx, if_let.let_expr, ex) && check_if_let_inner(cx, if_let) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_MATCH,\n+            ex.span,\n+            \"this if-let expression is unnecessary\",\n+            \"replace it with\",\n+            snippet_with_applicability(cx, if_let.let_expr.span, \"..\", &mut applicability).to_string(),\n+            applicability,\n+        );\n     }\n }\n \n@@ -77,15 +75,15 @@ fn check_all_arms(cx: &LateContext<'_>, match_expr: &Expr<'_>, arms: &[Arm<'_>])\n     true\n }\n \n-fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n+fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n     if let Some(if_else) = if_let.if_else {\n         if !pat_same_as_expr(if_let.let_pat, peel_blocks_with_stmt(if_let.if_then)) {\n             return false;\n         }\n \n         // Recursively check for each `else if let` phrase,\n         if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n-            return check_if_let(cx, nested_if_let);\n+            return check_if_let_inner(cx, nested_if_let);\n         }\n \n         if matches!(if_else.kind, ExprKind::Block(..)) {"}, {"sha": "095cd43ea13fb2f9bda22d36d3a7d9dc690fd8b9", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -18,19 +18,21 @@ use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n use rustc_span::sym;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let Some(higher::IfLet {\n-        if_else,\n-        let_pat,\n-        let_expr,\n-        ..\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-    } else if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n         find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n     }\n }\n \n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    pat: &'tcx Pat<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    has_else: bool,\n+) {\n+    find_sugg_for_if_let(cx, expr, pat, scrutinee, \"if\", has_else);\n+}\n+\n // Extract the generic arguments out of a type\n fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     if_chain! {"}, {"sha": "a211dc18f9e1e75c2676fcc371ec21694de5f9b0", "filename": "clippy_lints/src/matches/significant_drop_in_scrutinee.rs", "status": "renamed", "additions": 24, "deletions": 108, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsignificant_drop_in_scrutinee.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -5,98 +5,24 @@ use clippy_utils::source::{indent_of, snippet};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{Expr, ExprKind, MatchSource};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{Ty, TypeAndMut};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n \n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check for temporaries returned from function calls in a match scrutinee that have the\n-    /// `clippy::has_significant_drop` attribute.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `clippy::has_significant_drop` attribute can be added to types whose Drop impls have\n-    /// an important side-effect, such as unlocking a mutex, making it important for users to be\n-    /// able to accurately understand their lifetimes. When a temporary is returned in a function\n-    /// call in a match scrutinee, its lifetime lasts until the end of the match block, which may\n-    /// be surprising.\n-    ///\n-    /// For `Mutex`es this can lead to a deadlock. This happens when the match scrutinee uses a\n-    /// function call that returns a `MutexGuard` and then tries to lock again in one of the match\n-    /// arms. In that case the `MutexGuard` in the scrutinee will not be dropped until the end of\n-    /// the match block and thus will not unlock.\n-    ///\n-    /// ### Example\n-    /// ```rust.ignore\n-    /// # use std::sync::Mutex;\n-    ///\n-    /// # struct State {}\n-    ///\n-    /// # impl State {\n-    /// #     fn foo(&self) -> bool {\n-    /// #         true\n-    /// #     }\n-    ///\n-    /// #     fn bar(&self) {}\n-    /// # }\n-    ///\n-    ///\n-    /// let mutex = Mutex::new(State {});\n-    ///\n-    /// match mutex.lock().unwrap().foo() {\n-    ///     true => {\n-    ///         mutex.lock().unwrap().bar(); // Deadlock!\n-    ///     }\n-    ///     false => {}\n-    /// };\n-    ///\n-    /// println!(\"All done!\");\n-    ///\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # use std::sync::Mutex;\n-    ///\n-    /// # struct State {}\n-    ///\n-    /// # impl State {\n-    /// #     fn foo(&self) -> bool {\n-    /// #         true\n-    /// #     }\n-    ///\n-    /// #     fn bar(&self) {}\n-    /// # }\n-    ///\n-    /// let mutex = Mutex::new(State {});\n-    ///\n-    /// let is_foo = mutex.lock().unwrap().foo();\n-    /// match is_foo {\n-    ///     true => {\n-    ///         mutex.lock().unwrap().bar();\n-    ///     }\n-    ///     false => {}\n-    /// };\n-    ///\n-    /// println!(\"All done!\");\n-    /// ```\n-    #[clippy::version = \"1.60.0\"]\n-    pub SIGNIFICANT_DROP_IN_SCRUTINEE,\n-    suspicious,\n-    \"warns when a temporary of a type with a drop with a significant side-effect might have a surprising lifetime\"\n-}\n-\n-declare_lint_pass!(SignificantDropInScrutinee => [SIGNIFICANT_DROP_IN_SCRUTINEE]);\n+use super::SIGNIFICANT_DROP_IN_SCRUTINEE;\n \n-impl<'tcx> LateLintPass<'tcx> for SignificantDropInScrutinee {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if let Some((suggestions, message)) = has_significant_drop_in_scrutinee(cx, expr) {\n-            for found in suggestions {\n-                span_lint_and_then(cx, SIGNIFICANT_DROP_IN_SCRUTINEE, found.found_span, message, |diag| {\n-                    set_diagnostic(diag, cx, expr, found);\n-                });\n-            }\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    scrutinee: &'tcx Expr<'_>,\n+    source: MatchSource,\n+) {\n+    if let Some((suggestions, message)) = has_significant_drop_in_scrutinee(cx, scrutinee, source) {\n+        for found in suggestions {\n+            span_lint_and_then(cx, SIGNIFICANT_DROP_IN_SCRUTINEE, found.found_span, message, |diag| {\n+                set_diagnostic(diag, cx, expr, found);\n+            });\n         }\n     }\n }\n@@ -148,28 +74,18 @@ fn set_diagnostic<'tcx>(diag: &mut Diagnostic, cx: &LateContext<'tcx>, expr: &'t\n /// may have a surprising lifetime.\n fn has_significant_drop_in_scrutinee<'tcx, 'a>(\n     cx: &'a LateContext<'tcx>,\n-    expr: &'tcx Expr<'tcx>,\n+    scrutinee: &'tcx Expr<'tcx>,\n+    source: MatchSource,\n ) -> Option<(Vec<FoundSigDrop>, &'static str)> {\n-    match expr.kind {\n-        ExprKind::Match(match_expr, _, source) => {\n-            match source {\n-                MatchSource::Normal | MatchSource::ForLoopDesugar => {\n-                    let mut helper = SigDropHelper::new(cx);\n-                    helper.find_sig_drop(match_expr).map(|drops| {\n-                        let message = if source == MatchSource::Normal {\n-                            \"temporary with significant drop in match scrutinee\"\n-                        } else {\n-                            \"temporary with significant drop in for loop\"\n-                        };\n-                        (drops, message)\n-                    })\n-                },\n-                // MatchSource of TryDesugar or AwaitDesugar is out of scope for this lint\n-                MatchSource::TryDesugar | MatchSource::AwaitDesugar => None,\n-            }\n-        },\n-        _ => None,\n-    }\n+    let mut helper = SigDropHelper::new(cx);\n+    helper.find_sig_drop(scrutinee).map(|drops| {\n+        let message = if source == MatchSource::Normal {\n+            \"temporary with significant drop in match scrutinee\"\n+        } else {\n+            \"temporary with significant drop in for loop\"\n+        };\n+        (drops, message)\n+    })\n }\n \n struct SigDropHelper<'a, 'tcx> {", "previous_filename": "clippy_lints/src/significant_drop_in_scrutinee.rs"}, {"sha": "0491a0679f37abc89393aec264321c296316b721", "filename": "clippy_lints/src/matches/try_err.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a3e7e9c898831dfedf1846664d651a62906505/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=b1a3e7e9c898831dfedf1846664d651a62906505", "patch": "@@ -0,0 +1,145 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::ResultErr;\n+use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_span::{hygiene, sym};\n+\n+use super::TRY_ERR;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutinee: &'tcx Expr<'_>) {\n+    // Looks for a structure like this:\n+    // match ::std::ops::Try::into_result(Err(5)) {\n+    //     ::std::result::Result::Err(err) =>\n+    //         #[allow(unreachable_code)]\n+    //         return ::std::ops::Try::from_error(::std::convert::From::from(err)),\n+    //     ::std::result::Result::Ok(val) =>\n+    //         #[allow(unreachable_code)]\n+    //         val,\n+    // };\n+    if_chain! {\n+        if let ExprKind::Call(match_fun, try_args) = scrutinee.kind;\n+        if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n+        if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n+        if let Some(try_arg) = try_args.get(0);\n+        if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n+        if let Some(err_arg) = err_args.get(0);\n+        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n+        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if let Some(return_ty) = find_return_type(cx, &expr.kind);\n+        then {\n+            let prefix;\n+            let suffix;\n+            let err_ty;\n+\n+            if let Some(ty) = result_error_type(cx, return_ty) {\n+                prefix = \"Err(\";\n+                suffix = \")\";\n+                err_ty = ty;\n+            } else if let Some(ty) = poll_result_error_type(cx, return_ty) {\n+                prefix = \"Poll::Ready(Err(\";\n+                suffix = \"))\";\n+                err_ty = ty;\n+            } else if let Some(ty) = poll_option_result_error_type(cx, return_ty) {\n+                prefix = \"Poll::Ready(Some(Err(\";\n+                suffix = \")))\";\n+                err_ty = ty;\n+            } else {\n+                return;\n+            };\n+\n+            let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n+            let span = hygiene::walk_chain(err_arg.span, try_arg.span.ctxt());\n+            let mut applicability = Applicability::MachineApplicable;\n+            let origin_snippet = snippet_with_applicability(cx, span, \"_\", &mut applicability);\n+            let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n+                \"\" // already returns\n+            } else {\n+                \"return \"\n+            };\n+            let suggestion = if err_ty == expr_err_ty {\n+                format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n+            } else {\n+                format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                TRY_ERR,\n+                expr.span,\n+                \"returning an `Err(_)` with the `?` operator\",\n+                \"try this\",\n+                suggestion,\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+/// Finds function return type by examining return expressions in match arms.\n+fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n+    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n+        for arm in arms.iter() {\n+            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n+                return Some(cx.typeck_results().expr_ty(ret));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+/// Extracts the error type from Result<T, E>.\n+fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(_, subst) = ty.kind();\n+        if is_type_diagnostic_item(cx, ty, sym::Result);\n+        then {\n+            Some(subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Result<T, E>>.\n+fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind();\n+        if match_def_path(cx, def.did(), &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did());\n+        then {\n+            Some(ready_subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Option<Result<T, E>>>.\n+fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind();\n+        if match_def_path(cx, def.did(), &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did());\n+        let some_ty = ready_subst.type_at(0);\n+\n+        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n+        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did());\n+        then {\n+            Some(some_subst.type_at(1))\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "e108f7be12e6a69c7835db14c506239fdc9e33fa", "filename": "clippy_lints/src/try_err.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd357e4ab7a011a98630559d723658f902163f3/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=ebd357e4ab7a011a98630559d723658f902163f3", "patch": "@@ -1,186 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::ResultErr;\n-use rustc_hir::{Expr, ExprKind, LangItem, MatchSource, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{hygiene, sym};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of `Err(x)?`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `?` operator is designed to allow calls that\n-    /// can fail to be easily chained. For example, `foo()?.bar()` or\n-    /// `foo(bar()?)`. Because `Err(x)?` can't be used that way (it will\n-    /// always return), it is more clear to write `return Err(x)`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// fn foo(fail: bool) -> Result<i32, String> {\n-    ///     if fail {\n-    ///       Err(\"failed\")?;\n-    ///     }\n-    ///     Ok(0)\n-    /// }\n-    /// ```\n-    /// Could be written:\n-    ///\n-    /// ```rust\n-    /// fn foo(fail: bool) -> Result<i32, String> {\n-    ///     if fail {\n-    ///       return Err(\"failed\".into());\n-    ///     }\n-    ///     Ok(0)\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.38.0\"]\n-    pub TRY_ERR,\n-    restriction,\n-    \"return errors explicitly rather than hiding them behind a `?`\"\n-}\n-\n-declare_lint_pass!(TryErr => [TRY_ERR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TryErr {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        // Looks for a structure like this:\n-        // match ::std::ops::Try::into_result(Err(5)) {\n-        //     ::std::result::Result::Err(err) =>\n-        //         #[allow(unreachable_code)]\n-        //         return ::std::ops::Try::from_error(::std::convert::From::from(err)),\n-        //     ::std::result::Result::Ok(val) =>\n-        //         #[allow(unreachable_code)]\n-        //         val,\n-        // };\n-        if_chain! {\n-            if !in_external_macro(cx.tcx.sess, expr.span);\n-            if let ExprKind::Match(match_arg, _, MatchSource::TryDesugar) = expr.kind;\n-            if let ExprKind::Call(match_fun, try_args) = match_arg.kind;\n-            if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n-            if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n-            if let Some(try_arg) = try_args.get(0);\n-            if let ExprKind::Call(err_fun, err_args) = try_arg.kind;\n-            if let Some(err_arg) = err_args.get(0);\n-            if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-            if is_lang_ctor(cx, err_fun_path, ResultErr);\n-            if let Some(return_ty) = find_return_type(cx, &expr.kind);\n-            then {\n-                let prefix;\n-                let suffix;\n-                let err_ty;\n-\n-                if let Some(ty) = result_error_type(cx, return_ty) {\n-                    prefix = \"Err(\";\n-                    suffix = \")\";\n-                    err_ty = ty;\n-                } else if let Some(ty) = poll_result_error_type(cx, return_ty) {\n-                    prefix = \"Poll::Ready(Err(\";\n-                    suffix = \"))\";\n-                    err_ty = ty;\n-                } else if let Some(ty) = poll_option_result_error_type(cx, return_ty) {\n-                    prefix = \"Poll::Ready(Some(Err(\";\n-                    suffix = \")))\";\n-                    err_ty = ty;\n-                } else {\n-                    return;\n-                };\n-\n-                let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n-                let span = hygiene::walk_chain(err_arg.span, try_arg.span.ctxt());\n-                let mut applicability = Applicability::MachineApplicable;\n-                let origin_snippet = snippet_with_applicability(cx, span, \"_\", &mut applicability);\n-                let ret_prefix = if get_parent_expr(cx, expr).map_or(false, |e| matches!(e.kind, ExprKind::Ret(_))) {\n-                    \"\" // already returns\n-                } else {\n-                    \"return \"\n-                };\n-                let suggestion = if err_ty == expr_err_ty {\n-                    format!(\"{}{}{}{}\", ret_prefix, prefix, origin_snippet, suffix)\n-                } else {\n-                    format!(\"{}{}{}.into(){}\", ret_prefix, prefix, origin_snippet, suffix)\n-                };\n-\n-                span_lint_and_sugg(\n-                    cx,\n-                    TRY_ERR,\n-                    expr.span,\n-                    \"returning an `Err(_)` with the `?` operator\",\n-                    \"try this\",\n-                    suggestion,\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Finds function return type by examining return expressions in match arms.\n-fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n-    if let ExprKind::Match(_, arms, MatchSource::TryDesugar) = expr {\n-        for arm in arms.iter() {\n-            if let ExprKind::Ret(Some(ret)) = arm.body.kind {\n-                return Some(cx.typeck_results().expr_ty(ret));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n-/// Extracts the error type from Result<T, E>.\n-fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(_, subst) = ty.kind();\n-        if is_type_diagnostic_item(cx, ty, sym::Result);\n-        then {\n-            Some(subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extracts the error type from Poll<Result<T, E>>.\n-fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n-        let ready_ty = subst.type_at(0);\n-\n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, ready_def.did());\n-        then {\n-            Some(ready_subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Extracts the error type from Poll<Option<Result<T, E>>>.\n-fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n-    if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind();\n-        if match_def_path(cx, def.did(), &paths::POLL);\n-        let ready_ty = subst.type_at(0);\n-\n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Option, ready_def.did());\n-        let some_ty = ready_subst.type_at(0);\n-\n-        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n-        if cx.tcx.is_diagnostic_item(sym::Result, some_def.did());\n-        then {\n-            Some(some_subst.type_at(1))\n-        } else {\n-            None\n-        }\n-    }\n-}"}]}