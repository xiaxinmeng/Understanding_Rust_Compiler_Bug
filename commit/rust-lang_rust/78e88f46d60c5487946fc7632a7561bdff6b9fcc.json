{"sha": "78e88f46d60c5487946fc7632a7561bdff6b9fcc", "node_id": "C_kwDOAAsO6NoAKDc4ZTg4ZjQ2ZDYwYzU0ODc5NDZmYzc2MzJhNzU2MWJkZmY2YjlmY2M", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-11-08T19:15:54Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-12-07T02:05:34Z"}, "message": "Only shown relevant type params in E0283 label\n\nWhen we point at a binding to suggest giving it a type, erase all the\ntype for ADTs that have been resolved, leaving only the ones that could\nnot be inferred. For small shallow types this is not a problem, but for\nbig nested types with lots of params, this can otherwise cause a lot of\nunnecessary visual output.", "tree": {"sha": "44b9100cdf3f2468ec60299b3adebc9ce16d3d55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44b9100cdf3f2468ec60299b3adebc9ce16d3d55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e88f46d60c5487946fc7632a7561bdff6b9fcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e88f46d60c5487946fc7632a7561bdff6b9fcc", "html_url": "https://github.com/rust-lang/rust/commit/78e88f46d60c5487946fc7632a7561bdff6b9fcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e88f46d60c5487946fc7632a7561bdff6b9fcc/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c", "html_url": "https://github.com/rust-lang/rust/commit/0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c"}], "stats": {"total": 139, "additions": 136, "deletions": 3}, "files": [{"sha": "6b9952ba5d684c3d6eac8e700c8c087e55d5a63b", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/78e88f46d60c5487946fc7632a7561bdff6b9fcc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e88f46d60c5487946fc7632a7561bdff6b9fcc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=78e88f46d60c5487946fc7632a7561bdff6b9fcc", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::infer::unify_key::ConstVariableOriginKind;\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, InferConst, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -629,6 +629,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n             Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != arg_data.name => {\n+                let ty = ResolvedTypeParamEraser::new(self.tcx).fold_ty(ty);\n+                let ty = ErrTypeParamEraser(self.tcx).fold_ty(ty);\n                 let ty = ty_to_string(ty);\n                 format!(\n                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n@@ -908,3 +910,99 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err\n     }\n }\n+\n+/// Turn resolved type params into `[type error]` to signal we don't want to display them.\n+struct ResolvedTypeParamEraser<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    level: usize,\n+}\n+\n+impl<'tcx> ResolvedTypeParamEraser<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        ResolvedTypeParamEraser { tcx, level: 0 }\n+    }\n+}\n+impl<'tcx> TypeFolder<'tcx> for ResolvedTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        self.level += 1;\n+        let t = match t.kind() {\n+            // We'll hide this type only if all its type params are hidden as well.\n+            ty::Adt(def, substs) => {\n+                let generics = self.tcx().generics_of(def.did);\n+                // Account for params with default values, like `Vec`, where we\n+                // want to show `Vec<T>`, not `Vec<T, _>`. If we replaced that\n+                // subst, then we'd get the incorrect output, so we passthrough.\n+                let substs: Vec<_> = substs\n+                    .iter()\n+                    .zip(generics.params.iter())\n+                    .map(|(subst, param)| match &param.kind {\n+                        ty::GenericParamDefKind::Type { has_default: true, .. } => subst,\n+                        _ => subst.super_fold_with(self),\n+                    })\n+                    .collect();\n+                if self.level == 1\n+                    || substs.iter().any(|subst| match subst.unpack() {\n+                        ty::subst::GenericArgKind::Type(t) => match t.kind() {\n+                            ty::Error(_) => false,\n+                            _ => true,\n+                        },\n+                        // Account for `const` params here, otherwise `doesnt_infer.rs`\n+                        // shows `_` instead of `Foo<{ _: u32 }>`\n+                        ty::subst::GenericArgKind::Const(_) => true,\n+                        _ => false,\n+                    })\n+                {\n+                    let substs = self.tcx().intern_substs(&substs[..]);\n+                    self.tcx().mk_ty(ty::Adt(def, substs))\n+                } else {\n+                    self.tcx().ty_error()\n+                }\n+            }\n+            ty::Ref(_, ty, _) => {\n+                let ty = self.fold_ty(ty);\n+                match ty.kind() {\n+                    // Avoid `&_`, these can be safely presented as `_`.\n+                    ty::Error(_) => self.tcx().ty_error(),\n+                    _ => t.super_fold_with(self),\n+                }\n+            }\n+            // We could account for `()` if we wanted to replace it, but it's assured to be short.\n+            ty::Tuple(_)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::Opaque(..)\n+            | ty::Projection(_)\n+            | ty::Never\n+            | ty::Array(..) => t.super_fold_with(self),\n+            // We don't want to hide type params that haven't been resolved yet.\n+            // This would be the type that will be written out with the type param\n+            // name in the output.\n+            ty::Infer(_) => t,\n+            // We don't want to hide the outermost type, only its type params.\n+            _ if self.level == 1 => t.super_fold_with(self),\n+            // Hide this type\n+            _ => self.tcx().ty_error(),\n+        };\n+        self.level -= 1;\n+        t\n+    }\n+}\n+\n+/// Replace `[type error]` with `ty::Infer(ty::Var)` to display `_`.\n+struct ErrTypeParamEraser<'tcx>(TyCtxt<'tcx>);\n+impl<'tcx> TypeFolder<'tcx> for ErrTypeParamEraser<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.kind() {\n+            ty::Error(_) => self.tcx().mk_ty_var(ty::TyVid::from_u32(0)),\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+}"}, {"sha": "183be1b1517a79f7a0c2d688d1f717f7583e2bb8", "filename": "src/test/ui/const-generics/defaults/doesnt_infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fdoesnt_infer.stderr?ref=78e88f46d60c5487946fc7632a7561bdff6b9fcc", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `Foo<{_: u32}>`\n LL |     let foo = Foo::foo();\n    |         ---   ^^^^^^^^ cannot infer the value of const parameter `N`\n    |         |\n-   |         consider giving `foo` the explicit type `Foo<{_: u32}>`, where the type parameter `N` is specified\n+   |         consider giving `foo` the explicit type `Foo<{_: _}>`, where the type parameter `N` is specified\n \n error: aborting due to previous error\n "}, {"sha": "4a163d0b8109489d7e27fcb53134950e8384cabe", "filename": "src/test/ui/inference/erase-type-params-in-label.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.rs?ref=78e88f46d60c5487946fc7632a7561bdff6b9fcc", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    let foo = new(1, \"\"); //~ ERROR E0283\n+}\n+\n+struct Bar<T, K, N: Default> {\n+    t: T,\n+    k: K,\n+    n: N,\n+}\n+\n+fn new<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+    Bar { t, k, n: Default::default() }\n+}"}, {"sha": "b665fade9d88fe307a1cf29375efa10c6b62eb00", "filename": "src/test/ui/inference/erase-type-params-in-label.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Ferase-type-params-in-label.stderr?ref=78e88f46d60c5487946fc7632a7561bdff6b9fcc", "patch": "@@ -0,0 +1,22 @@\n+error[E0283]: type annotations needed for `Bar<i32, &str, Z>`\n+  --> $DIR/erase-type-params-in-label.rs:2:15\n+   |\n+LL |     let foo = new(1, \"\");\n+   |         ---   ^^^ cannot infer type for type parameter `Z` declared on the function `new`\n+   |         |\n+   |         consider giving `foo` the explicit type `Bar<_, _, Z>`, where the type parameter `Z` is specified\n+   |\n+   = note: cannot satisfy `_: Default`\n+note: required by a bound in `new`\n+  --> $DIR/erase-type-params-in-label.rs:11:17\n+   |\n+LL | fn new<T, K, Z: Default>(t: T, k: K) -> Bar<T, K, Z> {\n+   |                 ^^^^^^^ required by this bound in `new`\n+help: consider specifying the type arguments in the function call\n+   |\n+LL |     let foo = new::<T, K, Z>(1, \"\");\n+   |                  +++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0283`."}, {"sha": "c66606b9c8304279b6fc70bd1ee404b8b344f3ad", "filename": "src/test/ui/inference/issue-83606.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/78e88f46d60c5487946fc7632a7561bdff6b9fcc/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fissue-83606.stderr?ref=78e88f46d60c5487946fc7632a7561bdff6b9fcc", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed for `[usize; _]`\n LL |     let _ = foo(\"foo\"); //<- Do not suggest `foo::<N>(\"foo\");`!\n    |         -   ^^^ cannot infer the value of const parameter `N` declared on the function `foo`\n    |         |\n-   |         consider giving this pattern the explicit type `[usize; _]`, where the type parameter `N` is specified\n+   |         consider giving this pattern the explicit type `[_; _]`, where the type parameter `N` is specified\n \n error: aborting due to previous error\n "}]}