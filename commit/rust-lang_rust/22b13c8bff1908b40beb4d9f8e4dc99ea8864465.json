{"sha": "22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "node_id": "C_kwDOAAsO6NoAKDIyYjEzYzhiZmYxOTA4YjQwYmViNGQ5ZjhlNGRjOTllYTg4NjQ0NjU", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-04-08T16:06:18Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-04-08T17:56:41Z"}, "message": "Make trait item completions work in a bare impl and score them", "tree": {"sha": "3563dab336e4ff51b0ec5ce6c64cc915b4578165", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3563dab336e4ff51b0ec5ce6c64cc915b4578165"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "html_url": "https://github.com/rust-lang/rust/commit/22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdeb6140bf88b34771f13bccb81d604b2ef9ad62", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdeb6140bf88b34771f13bccb81d604b2ef9ad62", "html_url": "https://github.com/rust-lang/rust/commit/cdeb6140bf88b34771f13bccb81d604b2ef9ad62"}], "stats": {"total": 206, "additions": 139, "deletions": 67}, "files": [{"sha": "13e05049e2f89e0717e84ba3014613a4aa16b23e", "filename": "crates/ide_completion/src/completions/trait_impl.rs", "status": "modified", "additions": 126, "deletions": 66, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ftrait_impl.rs?ref=22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "patch": "@@ -36,11 +36,13 @@ use ide_db::{path_transform::PathTransform, traits::get_missing_assoc_items, Sym\n use syntax::{\n     ast::{self, edit_in_place::AttrsOwnerEdit},\n     display::function_declaration,\n-    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, T,\n+    AstNode, SyntaxElement, SyntaxKind, SyntaxNode, TextRange, T,\n };\n use text_edit::TextEdit;\n \n-use crate::{CompletionContext, CompletionItem, CompletionItemKind, Completions};\n+use crate::{\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n+};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ImplCompletionKind {\n@@ -51,84 +53,102 @@ enum ImplCompletionKind {\n }\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n-    if let Some((kind, trigger, impl_def)) = completion_match(ctx.token.clone()) {\n+    if let Some((kind, replacement_range, impl_def)) = completion_match(ctx) {\n         if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n             get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| {\n                 match (item, kind) {\n                     (\n                         hir::AssocItem::Function(fn_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Fn,\n-                    ) => add_function_impl(acc, ctx, &trigger, fn_item, hir_impl),\n+                    ) => add_function_impl(acc, ctx, replacement_range, fn_item, hir_impl),\n                     (\n                         hir::AssocItem::TypeAlias(type_item),\n                         ImplCompletionKind::All | ImplCompletionKind::TypeAlias,\n-                    ) => add_type_alias_impl(acc, ctx, &trigger, type_item),\n+                    ) => add_type_alias_impl(acc, ctx, replacement_range, type_item),\n                     (\n                         hir::AssocItem::Const(const_item),\n                         ImplCompletionKind::All | ImplCompletionKind::Const,\n-                    ) => add_const_impl(acc, ctx, &trigger, const_item, hir_impl),\n+                    ) => add_const_impl(acc, ctx, replacement_range, const_item, hir_impl),\n                     _ => {}\n                 }\n             });\n         }\n     }\n }\n \n-fn completion_match(mut token: SyntaxToken) -> Option<(ImplCompletionKind, SyntaxNode, ast::Impl)> {\n+fn completion_match(ctx: &CompletionContext) -> Option<(ImplCompletionKind, TextRange, ast::Impl)> {\n+    let token = ctx.token.clone();\n+\n     // For keyword without name like `impl .. { fn $0 }`, the current position is inside\n     // the whitespace token, which is outside `FN` syntax node.\n     // We need to follow the previous token in this case.\n+    let mut token_before_ws = token.clone();\n     if token.kind() == SyntaxKind::WHITESPACE {\n-        token = token.prev_token()?;\n+        token_before_ws = token.prev_token()?;\n     }\n \n-    let parent_kind = token.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n-    let impl_item_offset = match token.kind() {\n-        // `impl .. { const $0 }`\n-        // ERROR      0\n-        //   CONST_KW <- *\n-        T![const] => 0,\n-        // `impl .. { fn/type $0 }`\n-        // FN/TYPE_ALIAS  0\n-        //   FN_KW        <- *\n-        T![fn] | T![type] => 0,\n-        // `impl .. { fn/type/const foo$0 }`\n-        // FN/TYPE_ALIAS/CONST  1\n-        //  NAME                0\n-        //    IDENT             <- *\n-        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n-        // `impl .. { foo$0 }`\n-        // MACRO_CALL       3\n-        //  PATH            2\n-        //    PATH_SEGMENT  1\n-        //      NAME_REF    0\n-        //        IDENT     <- *\n-        SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n-        _ => return None,\n-    };\n+    let parent_kind = token_before_ws.parent().map_or(SyntaxKind::EOF, |it| it.kind());\n+    if token.parent().map(|n| n.kind()) == Some(SyntaxKind::ASSOC_ITEM_LIST)\n+        && matches!(\n+            token_before_ws.kind(),\n+            SyntaxKind::SEMICOLON | SyntaxKind::R_CURLY | SyntaxKind::L_CURLY\n+        )\n+    {\n+        let impl_def = ast::Impl::cast(token.parent()?.parent()?)?;\n+        let kind = ImplCompletionKind::All;\n+        let replacement_range = TextRange::empty(ctx.position.offset);\n+        Some((kind, replacement_range, impl_def))\n+    } else {\n+        let impl_item_offset = match token_before_ws.kind() {\n+            // `impl .. { const $0 }`\n+            // ERROR      0\n+            //   CONST_KW <- *\n+            T![const] => 0,\n+            // `impl .. { fn/type $0 }`\n+            // FN/TYPE_ALIAS  0\n+            //   FN_KW        <- *\n+            T![fn] | T![type] => 0,\n+            // `impl .. { fn/type/const foo$0 }`\n+            // FN/TYPE_ALIAS/CONST  1\n+            //  NAME                0\n+            //    IDENT             <- *\n+            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME => 1,\n+            // `impl .. { foo$0 }`\n+            // MACRO_CALL       3\n+            //  PATH            2\n+            //    PATH_SEGMENT  1\n+            //      NAME_REF    0\n+            //        IDENT     <- *\n+            SyntaxKind::IDENT if parent_kind == SyntaxKind::NAME_REF => 3,\n+            _ => return None,\n+        };\n \n-    let impl_item = token.ancestors().nth(impl_item_offset)?;\n-    // Must directly belong to an impl block.\n-    // IMPL\n-    //   ASSOC_ITEM_LIST\n-    //     <item>\n-    let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n-    let kind = match impl_item.kind() {\n-        // `impl ... { const $0 fn/type/const }`\n-        _ if token.kind() == T![const] => ImplCompletionKind::Const,\n-        SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n-        SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n-        SyntaxKind::FN => ImplCompletionKind::Fn,\n-        SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n-        _ => return None,\n-    };\n-    Some((kind, impl_item, impl_def))\n+        let impl_item = token_before_ws.ancestors().nth(impl_item_offset)?;\n+        // Must directly belong to an impl block.\n+        // IMPL\n+        //   ASSOC_ITEM_LIST\n+        //     <item>\n+        let impl_def = ast::Impl::cast(impl_item.parent()?.parent()?)?;\n+        let kind = match impl_item.kind() {\n+            // `impl ... { const $0 fn/type/const }`\n+            _ if token_before_ws.kind() == T![const] => ImplCompletionKind::Const,\n+            SyntaxKind::CONST | SyntaxKind::ERROR => ImplCompletionKind::Const,\n+            SyntaxKind::TYPE_ALIAS => ImplCompletionKind::TypeAlias,\n+            SyntaxKind::FN => ImplCompletionKind::Fn,\n+            SyntaxKind::MACRO_CALL => ImplCompletionKind::All,\n+            _ => return None,\n+        };\n+\n+        let replacement_range = replacement_range(ctx, &impl_item);\n+\n+        Some((kind, replacement_range, impl_def))\n+    }\n }\n \n fn add_function_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    fn_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     func: hir::Function,\n     impl_def: hir::Impl,\n ) {\n@@ -146,9 +166,10 @@ fn add_function_impl(\n         CompletionItemKind::SymbolKind(SymbolKind::Function)\n     };\n \n-    let range = replacement_range(ctx, fn_def_node);\n-    let mut item = CompletionItem::new(completion_kind, range, label);\n-    item.lookup_by(fn_name).set_documentation(func.docs(ctx.db));\n+    let mut item = CompletionItem::new(completion_kind, replacement_range, label);\n+    item.lookup_by(fn_name)\n+        .set_documentation(func.docs(ctx.db))\n+        .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n \n     if let Some(source) = ctx.sema.source(func) {\n         let assoc_item = ast::AssocItem::Fn(source.value);\n@@ -162,11 +183,11 @@ fn add_function_impl(\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n-                    item.snippet_edit(cap, TextEdit::replace(range, snippet));\n+                    item.snippet_edit(cap, TextEdit::replace(replacement_range, snippet));\n                 }\n                 None => {\n                     let header = format!(\"{} {{\", function_decl);\n-                    item.text_edit(TextEdit::replace(range, header));\n+                    item.text_edit(TextEdit::replace(replacement_range, header));\n                 }\n             };\n             item.add_to(acc);\n@@ -201,25 +222,26 @@ fn get_transformed_assoc_item(\n fn add_type_alias_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    type_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     type_alias: hir::TypeAlias,\n ) {\n     let alias_name = type_alias.name(ctx.db).to_smol_str();\n \n+    let label = format!(\"type {} =\", alias_name);\n     let snippet = format!(\"type {} = \", alias_name);\n \n-    let range = replacement_range(ctx, type_def_node);\n-    let mut item = CompletionItem::new(SymbolKind::TypeAlias, range, &snippet);\n-    item.text_edit(TextEdit::replace(range, snippet))\n+    let mut item = CompletionItem::new(SymbolKind::TypeAlias, replacement_range, label);\n+    item.text_edit(TextEdit::replace(replacement_range, snippet))\n         .lookup_by(alias_name)\n-        .set_documentation(type_alias.docs(ctx.db));\n+        .set_documentation(type_alias.docs(ctx.db))\n+        .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n     item.add_to(acc);\n }\n \n fn add_const_impl(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    const_def_node: &SyntaxNode,\n+    replacement_range: TextRange,\n     const_: hir::Const,\n     impl_def: hir::Impl,\n ) {\n@@ -234,13 +256,17 @@ fn add_const_impl(\n                     _ => unreachable!(),\n                 };\n \n-                let snippet = make_const_compl_syntax(&transformed_const);\n+                let label = make_const_compl_syntax(&transformed_const);\n+                let snippet = format!(\"{} \", label);\n \n-                let range = replacement_range(ctx, const_def_node);\n-                let mut item = CompletionItem::new(SymbolKind::Const, range, &snippet);\n-                item.text_edit(TextEdit::replace(range, snippet))\n+                let mut item = CompletionItem::new(SymbolKind::Const, replacement_range, label);\n+                item.text_edit(TextEdit::replace(replacement_range, snippet))\n                     .lookup_by(const_name)\n-                    .set_documentation(const_.docs(ctx.db));\n+                    .set_documentation(const_.docs(ctx.db))\n+                    .set_relevance(CompletionRelevance {\n+                        is_item_from_trait: true,\n+                        ..Default::default()\n+                    });\n                 item.add_to(acc);\n             }\n         }\n@@ -267,7 +293,7 @@ fn make_const_compl_syntax(const_: &ast::Const) -> String {\n \n     let syntax = const_.syntax().text().slice(range).to_string();\n \n-    format!(\"{} = \", syntax.trim_end())\n+    format!(\"{} =\", syntax.trim_end())\n }\n \n fn replacement_range(ctx: &CompletionContext, item: &SyntaxNode) -> TextRange {\n@@ -987,4 +1013,38 @@ where Self: SomeTrait<u32> {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn works_directly_in_impl() {\n+        check(\n+            r#\"\n+trait Tr {\n+    fn required();\n+}\n+\n+impl Tr for () {\n+    $0\n+}\n+\"#,\n+            expect![[r#\"\n+            fn fn required()\n+        \"#]],\n+        );\n+        check(\n+            r#\"\n+trait Tr {\n+    fn provided() {}\n+    fn required();\n+}\n+\n+impl Tr for () {\n+    fn provided() {}\n+    $0\n+}\n+\"#,\n+            expect![[r#\"\n+            fn fn required()\n+        \"#]],\n+        );\n+    }\n }"}, {"sha": "2fa8f77264231884c57589bc89613529ea40540b", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "patch": "@@ -132,6 +132,8 @@ pub struct CompletionRelevance {\n     /// }\n     /// ```\n     pub is_local: bool,\n+    /// This is set when trait items are completed in an impl of that trait.\n+    pub is_item_from_trait: bool,\n     /// Set for method completions of the `core::ops` and `core::cmp` family.\n     pub is_op_method: bool,\n     /// Set for item completions that are private but in the workspace.\n@@ -197,6 +199,7 @@ impl CompletionRelevance {\n             exact_name_match,\n             type_match,\n             is_local,\n+            is_item_from_trait,\n             is_op_method,\n             is_private_editable,\n             postfix_match,\n@@ -228,6 +231,9 @@ impl CompletionRelevance {\n         if is_local {\n             score += 1;\n         }\n+        if is_item_from_trait {\n+            score += 1;\n+        }\n         if is_definite {\n             score += 10;\n         }"}, {"sha": "5b0257f6b40e682f383430d3be36bea662e9c6c7", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "patch": "@@ -624,6 +624,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,\n@@ -646,6 +647,7 @@ fn main() { let _: m::Spam = S$0 }\n                                 Exact,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,\n@@ -734,6 +736,7 @@ fn foo() { A { the$0 } }\n                                 CouldUnify,\n                             ),\n                             is_local: false,\n+                            is_item_from_trait: false,\n                             is_op_method: false,\n                             is_private_editable: false,\n                             postfix_match: None,"}, {"sha": "0e60f748790bf07fcfeca3843255b432e4178ada", "filename": "crates/ide_completion/src/tests/item_list.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b13c8bff1908b40beb4d9f8e4dc99ea8864465/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fitem_list.rs?ref=22b13c8bff1908b40beb4d9f8e4dc99ea8864465", "patch": "@@ -241,11 +241,14 @@ impl Test for () {\n             kw fn\n             kw const\n             kw type\n+            ta type Type1 =\n+            ct const CONST1: () =\n+            fn fn function1()\n             kw self\n             kw super\n             kw crate\n             md module\n-            ma makro!(\u2026)  macro_rules! makro\n+            ma makro!(\u2026)          macro_rules! makro\n         \"#]],\n     );\n }"}]}