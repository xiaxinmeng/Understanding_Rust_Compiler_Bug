{"sha": "68e129dc39b29a2a67dda9da2c123c111b271522", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZTEyOWRjMzliMjlhMmE2N2RkYTlkYTJjMTIzYzExMWIyNzE1MjI=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-29T12:47:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: dump the tcp::new_listener server API", "tree": {"sha": "c397ec55e270d925d2a3102dcc79075e0eabcbfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c397ec55e270d925d2a3102dcc79075e0eabcbfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68e129dc39b29a2a67dda9da2c123c111b271522", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68e129dc39b29a2a67dda9da2c123c111b271522", "html_url": "https://github.com/rust-lang/rust/commit/68e129dc39b29a2a67dda9da2c123c111b271522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68e129dc39b29a2a67dda9da2c123c111b271522/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "html_url": "https://github.com/rust-lang/rust/commit/5d86686e7facd7a5e5acc1c8b682310ad1fe878c"}], "stats": {"total": 209, "additions": 7, "deletions": 202}, "files": [{"sha": "1f732978f4bac7f158ac54daa3c3376fc053946a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 7, "deletions": 202, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/68e129dc39b29a2a67dda9da2c123c111b271522/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e129dc39b29a2a67dda9da2c123c111b271522/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=68e129dc39b29a2a67dda9da2c123c111b271522", "patch": "@@ -13,14 +13,13 @@ import libc::size_t;\n import str::extensions;\n \n // tcp interfaces\n-export tcp_socket, tcp_conn_port;\n+export tcp_socket;\n // errors\n export tcp_err_data, tcp_connect_err_data;\n // operations on a tcp_socket\n export write, write_future, read_start, read_stop;\n // tcp server stuff\n export listen_for_conn, accept;\n-export new_listener, conn_recv, conn_recv_spawn, conn_peek;\n // tcp client stuff\n export connect;\n // helper methods\n@@ -51,23 +50,6 @@ class tcp_socket {\n   }\n }\n \n-class tcp_conn_port {\n-  let conn_data: @tcp_conn_port_data;\n-  new(conn_data: @tcp_conn_port_data) { self.conn_data = conn_data; }\n-  drop unsafe {\n-    let conn_data_ptr = ptr::addr_of(*(self.conn_data));\n-    let server_stream_ptr = ptr::addr_of((*conn_data_ptr).server_stream);\n-    let stream_closed_po = (*(self.conn_data)).stream_closed_po;\n-    let iotask = (*conn_data_ptr).iotask;\n-    iotask::interact(iotask) {|loop_ptr|\n-        log(debug, #fmt(\"dtor for tcp_conn_port loop: %?\",\n-                       loop_ptr));\n-        uv::ll::close(server_stream_ptr, tcp_nl_close_cb);\n-    }\n-    comm::recv(stream_closed_po);\n-  }\n-}\n-\n #[doc=\"\n Contains raw, string-based, error information returned from libuv\n \"]\n@@ -351,6 +333,7 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n }\n \n #[doc=\"\n+<<<<<<< HEAD\n Bind to a given IP/port and listen for new connections\n \n # Arguments\n@@ -527,6 +510,8 @@ fn conn_peek(server_port: tcp_conn_port) -> bool {\n }\n \n #[doc=\"\n+=======\n+>>>>>>> std: dump the tcp::new_listener server API\n Bind an incoming client connection to a `net::tcp::tcp_socket`\n \n # Notes\n@@ -782,17 +767,6 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n }\n \n mod net_tcp_methods {\n-    #[doc=\"\n-    Convenience methods extending `net::tcp::tcp_conn_port`\n-    \"]\n-    impl methods_tcp_conn_port for tcp_conn_port {\n-        fn recv() -> result::result<tcp_socket, tcp_err_data> {\n-            conn_recv(self) }\n-        fn recv_spawn(cb: fn~(result::result<tcp_socket,tcp_err_data>))\n-                      { conn_recv_spawn(self, cb); }\n-        fn peek() -> bool { conn_peek(self) }\n-    }\n-\n     #[doc=\"\n     Convenience methods extending `net::tcp::tcp_socket`\n     \"]\n@@ -993,6 +967,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     }\n }\n \n+<<<<<<< HEAD\n // various recv_* can use a tcp_conn_port can re-use this..\n fn conn_port_new_tcp_socket(\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n@@ -1022,21 +997,12 @@ fn conn_port_new_tcp_socket(\n     result::ok(tcp_socket(client_socket_data))\n }\n \n+=======\n+>>>>>>> std: dump the tcp::new_listener server API\n enum tcp_new_connection {\n     new_tcp_conn(*uv::ll::uv_tcp_t)\n }\n \n-type tcp_conn_port_data = {\n-    server_stream: uv::ll::uv_tcp_t,\n-    stream_closed_po: comm::port<()>,\n-    stream_closed_ch: comm::chan<()>,\n-    iotask: iotask,\n-    new_conn_po: comm::port<result::result<*uv::ll::uv_tcp_t,\n-                                            tcp_err_data>>,\n-    new_conn_ch: comm::chan<result::result<*uv::ll::uv_tcp_t,\n-                                           tcp_err_data>>\n-};\n-\n type tcp_listen_fc_data = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: comm::chan<()>,\n@@ -1075,66 +1041,11 @@ crust fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n     }\n }\n \n-crust fn tcp_nl_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    let conn_data_ptr = uv::ll::get_data_for_uv_handle(\n-        handle) as *tcp_conn_port_data;\n-    comm::send((*conn_data_ptr).stream_closed_ch, ());\n-}\n-\n fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t unsafe {\n     rustrt::rust_uv_current_kernel_malloc(\n         rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n }\n \n-crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n-                                     status: libc::c_int) unsafe {\n-    let server_data_ptr = uv::ll::get_data_for_uv_handle(server_handle_ptr)\n-        as *tcp_conn_port_data;\n-    let new_conn_ch = (*server_data_ptr).new_conn_ch;\n-    let loop_ptr = uv::ll::get_loop_for_uv_handle(server_handle_ptr);\n-    alt status {\n-      0i32 {\n-        let client_stream_handle_ptr = malloc_uv_tcp_t();\n-        *(client_stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n-            uv::ll::tcp_t();\n-        alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n-          0i32 {\n-            log(debug, \"uv_tcp_init successful for client stream\");\n-            alt uv::ll::accept(\n-                server_handle_ptr as *libc::c_void,\n-                client_stream_handle_ptr as *libc::c_void) {\n-              0i32 {\n-                log(debug, \"successfully accepted client connection\");\n-                comm::send(new_conn_ch,\n-                           result::ok(client_stream_handle_ptr));\n-              }\n-              _ {\n-                log(debug, \"failed to accept client conn\");\n-                comm::send(\n-                    new_conn_ch,\n-                    result::err(uv::ll::get_last_err_data(loop_ptr)\n-                        .to_tcp_err()));\n-              }\n-            }\n-          }\n-          _ {\n-            log(debug, \"failed to init client stream\");\n-            comm::send(\n-                new_conn_ch,\n-                result::err(uv::ll::get_last_err_data(loop_ptr)\n-                    .to_tcp_err()));\n-          }\n-        }\n-      }\n-      _ {\n-        comm::send(\n-            new_conn_ch,\n-            result::err(uv::ll::get_last_err_data(loop_ptr)\n-                .to_tcp_err()));\n-      }\n-    }\n-}\n-\n enum tcp_connect_result {\n     tcp_connected(tcp_socket),\n     tcp_connect_error(tcp_err_data)\n@@ -1331,10 +1242,6 @@ mod test {\n                 impl_gl_tcp_ipv4_server_and_client();\n             }\n             #[test]\n-            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n-                impl_gl_tcp_ipv4_server_listener_and_client();\n-            }\n-            #[test]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n@@ -1348,11 +1255,6 @@ mod test {\n             }\n             #[test]\n             #[ignore(cfg(target_os = \"linux\"))]\n-            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n-                impl_gl_tcp_ipv4_server_listener_and_client();\n-            }\n-            #[test]\n-            #[ignore(cfg(target_os = \"linux\"))]\n             fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n                 impl_gl_tcp_ipv4_client_error_connection_refused();\n             }\n@@ -1404,52 +1306,6 @@ mod test {\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n-    fn impl_gl_tcp_ipv4_server_listener_and_client() {\n-        let hl_loop = uv::global_loop::get();\n-        let server_ip = \"127.0.0.1\";\n-        let server_port = 8889u;\n-        let expected_req = \"ping\";\n-        let expected_resp = \"pong\";\n-\n-        let server_result_po = comm::port::<str>();\n-        let server_result_ch = comm::chan(server_result_po);\n-\n-        let cont_po = comm::port::<()>();\n-        let cont_ch = comm::chan(cont_po);\n-        // server\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            let actual_req = comm::listen {|server_ch|\n-                run_tcp_test_server_listener(\n-                    server_ip,\n-                    server_port,\n-                    expected_resp,\n-                    server_ch,\n-                    cont_ch,\n-                    hl_loop)\n-            };\n-            server_result_ch.send(actual_req);\n-        };\n-        comm::recv(cont_po);\n-        // client\n-        log(debug, \"server started, firing up client..\");\n-        let actual_resp_result = comm::listen {|client_ch|\n-            run_tcp_test_client(\n-                server_ip,\n-                server_port,\n-                expected_req,\n-                client_ch,\n-                hl_loop)\n-        };\n-        assert actual_resp_result.is_success();\n-        let actual_resp = actual_resp_result.get();\n-        let actual_req = comm::recv(server_result_po);\n-        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req));\n-        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp));\n-        assert str::contains(actual_req, expected_req);\n-        assert str::contains(actual_resp, expected_resp);\n-    }\n     fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n         let hl_loop = uv::global_loop::get();\n         let server_ip = \"127.0.0.1\";\n@@ -1552,57 +1408,6 @@ mod test {\n         ret_val\n     }\n \n-    fn run_tcp_test_server_listener(server_ip: str,\n-                                    server_port: uint, resp: str,\n-                                    server_ch: comm::chan<str>,\n-                                    cont_ch: comm::chan<()>,\n-                                    iotask: iotask) -> str {\n-\n-        task::spawn_sched(task::manual_threads(1u)) {||\n-            let server_ip_addr = ip::v4::parse_addr(server_ip);\n-            let new_listener_result =\n-                new_listener(server_ip_addr, server_port, 128u, iotask);\n-            if result::is_err(new_listener_result) {\n-                let err_data = result::get_err(new_listener_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n-                fail \"couldn't set up new listener\";\n-            }\n-            let server_port = result::unwrap(new_listener_result);\n-            cont_ch.send(());\n-            // receive a single new connection.. normally this'd be\n-            // in a loop {}, but we're just going to take a single\n-            // client.. get their req, write a resp and then exit\n-            let new_conn_result = server_port.recv();\n-            if result::is_err(new_conn_result) {\n-                let err_data = result::get_err(new_conn_result);\n-                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                err_data.err_name, err_data.err_msg));\n-                fail \"couldn't recv new conn\";\n-            }\n-            let sock = result::unwrap(new_conn_result);\n-            log(debug, \"SERVER: successfully accepted\"+\n-                \"connection!\");\n-            let received_req_bytes =\n-                read(sock, 0u);\n-            alt received_req_bytes {\n-              result::ok(data) {\n-                server_ch.send(\n-                    str::from_bytes(data));\n-                log(debug, \"SERVER: before write\");\n-                tcp_write_single(sock, str::bytes(resp));\n-                log(debug, \"SERVER: after write.. die\");\n-              }\n-              result::err(err_data) {\n-                server_ch.send(\"\");\n-              }\n-            }\n-        };\n-        let ret_val = server_ch.recv();\n-        log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n-        ret_val\n-    }\n-\n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>,\n                           iotask: iotask) -> result::result<str,"}]}