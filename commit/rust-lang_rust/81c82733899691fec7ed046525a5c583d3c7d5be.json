{"sha": "81c82733899691fec7ed046525a5c583d3c7d5be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYzgyNzMzODk5NjkxZmVjN2VkMDQ2NTI1YTVjNTgzZDNjN2Q1YmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-16T20:18:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-16T20:18:28Z"}, "message": "Merge #5415\n\n5415: Remove FunctionSignature r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "74f7814de8380f97c645afbfe3dad7d924785fcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74f7814de8380f97c645afbfe3dad7d924785fcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81c82733899691fec7ed046525a5c583d3c7d5be", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfELYUCRBK7hj4Ov3rIwAAdHIIAISlJ9DLFLzzI9hsLoPdCcvG\naADHc+s7lj2n0NYaRPqWrE53inweR4/kdmNZ8nEWwVJV2EgFGKNehqbG5uo6OO5B\nFfAFdoakrQxhu55HevfkIo66itmVT0MXL65LlNyXO0KzN4+Db7ipb2+nizqgKpPR\nuNAzdIivMYwfoGg9r0TwseCcq0zUycG3i3pZ5e8jsC527MAJhcnX3muc9cNVGaEc\nUZt5GyBjKzvc1MFfP99r5OsEAPDV1De9txMmLqgP65prQRZgkE1Mhr0/LMXG0tkD\n+Yoj2guRWqQNDYD/D7qh6KMkM8PCm7CfiyvOSXQAHrs9KIBKRJPm0VpPql1bKR8=\n=rhSw\n-----END PGP SIGNATURE-----\n", "payload": "tree 74f7814de8380f97c645afbfe3dad7d924785fcb\nparent 4759a39f06be1ec1469101a8aac39039b8743806\nparent 3823c2dc1995ec261e36435662b8802c714e23d4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594930708 +0000\ncommitter GitHub <noreply@github.com> 1594930708 +0000\n\nMerge #5415\n\n5415: Remove FunctionSignature r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81c82733899691fec7ed046525a5c583d3c7d5be", "html_url": "https://github.com/rust-lang/rust/commit/81c82733899691fec7ed046525a5c583d3c7d5be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81c82733899691fec7ed046525a5c583d3c7d5be/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4759a39f06be1ec1469101a8aac39039b8743806", "url": "https://api.github.com/repos/rust-lang/rust/commits/4759a39f06be1ec1469101a8aac39039b8743806", "html_url": "https://github.com/rust-lang/rust/commit/4759a39f06be1ec1469101a8aac39039b8743806"}, {"sha": "3823c2dc1995ec261e36435662b8802c714e23d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3823c2dc1995ec261e36435662b8802c714e23d4", "html_url": "https://github.com/rust-lang/rust/commit/3823c2dc1995ec261e36435662b8802c714e23d4"}], "stats": {"total": 466, "additions": 87, "deletions": 379}, "files": [{"sha": "0f6953158a59a832df22da0ed6013f75f779b452", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -1552,6 +1552,9 @@ impl Callable {\n         let param_list = src.value.param_list()?;\n         param_list.self_param()\n     }\n+    pub fn n_params(&self) -> usize {\n+        self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n+    }\n     pub fn params(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "cf716540f5cdd45331510122d99b315f98c79b0b", "filename": "crates/ra_ide/src/completion/complete_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -43,7 +43,7 @@ use crate::{\n     completion::{\n         CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n     },\n-    display::function_signature::FunctionSignature,\n+    display::function_declaration,\n };\n \n pub(crate) fn complete_trait_impl(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -125,8 +125,6 @@ fn add_function_impl(\n     ctx: &CompletionContext,\n     func: hir::Function,\n ) {\n-    let signature = FunctionSignature::from_hir(ctx.db, func);\n-\n     let fn_name = func.name(ctx.db).to_string();\n \n     let label = if !func.params(ctx.db).is_empty() {\n@@ -146,13 +144,14 @@ fn add_function_impl(\n     };\n     let range = TextRange::new(fn_def_node.text_range().start(), ctx.source_range().end());\n \n+    let function_decl = function_declaration(&func.source(ctx.db).value);\n     match ctx.config.snippet_cap {\n         Some(cap) => {\n-            let snippet = format!(\"{} {{\\n    $0\\n}}\", signature);\n+            let snippet = format!(\"{} {{\\n    $0\\n}}\", function_decl);\n             builder.snippet_edit(cap, TextEdit::replace(range, snippet))\n         }\n         None => {\n-            let header = format!(\"{} {{\", signature);\n+            let header = format!(\"{} {{\", function_decl);\n             builder.text_edit(TextEdit::replace(range, header))\n         }\n     }"}, {"sha": "c7b74e6355e556bea52c4397b5c6e83d66720622", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -11,7 +11,7 @@ use crate::{\n         completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n         CompletionKind, Completions,\n     },\n-    display::{const_label, function_signature::FunctionSignature, macro_label, type_label},\n+    display::{const_label, function_declaration, macro_label, type_label},\n     CompletionScore, RootDatabase,\n };\n \n@@ -195,7 +195,6 @@ impl Completions {\n \n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n-        let function_signature = FunctionSignature::from(&ast_node);\n \n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n@@ -206,13 +205,14 @@ impl Completions {\n                 })\n                 .set_documentation(func.docs(ctx.db))\n                 .set_deprecated(is_deprecated(func, ctx.db))\n-                .detail(function_signature.to_string());\n+                .detail(function_declaration(&ast_node));\n \n-        let params = function_signature\n-            .parameter_names\n-            .iter()\n-            .skip(if function_signature.has_self_param { 1 } else { 0 })\n-            .map(|name| name.trim_start_matches('_').into())\n+        let params = ast_node\n+            .param_list()\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .flat_map(|it| it.pat())\n+            .map(|pat| pat.to_string().trim_start_matches('_').into())\n             .collect();\n \n         builder = builder.add_call_parens(ctx, name, Params::Named(params));"}, {"sha": "6d4151dd85d42de957af50d54ffdb945a876432a", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -1,7 +1,6 @@\n //! This module contains utilities for turning SyntaxNodes and HIR types\n //! into types that may be used to render in a UI.\n \n-pub(crate) mod function_signature;\n mod navigation_target;\n mod short_label;\n \n@@ -10,13 +9,49 @@ use ra_syntax::{\n     SyntaxKind::{ATTR, COMMENT},\n };\n \n-pub(crate) use navigation_target::{ToNav, TryToNav};\n-pub(crate) use short_label::ShortLabel;\n+use ast::VisibilityOwner;\n+use stdx::format_to;\n \n pub use navigation_target::NavigationTarget;\n+pub(crate) use navigation_target::{ToNav, TryToNav};\n+pub(crate) use short_label::ShortLabel;\n \n-pub(crate) fn function_label(node: &ast::FnDef) -> String {\n-    function_signature::FunctionSignature::from(node).to_string()\n+pub(crate) fn function_declaration(node: &ast::FnDef) -> String {\n+    let mut buf = String::new();\n+    if let Some(vis) = node.visibility() {\n+        format_to!(buf, \"{} \", vis);\n+    }\n+    if node.async_token().is_some() {\n+        format_to!(buf, \"async \");\n+    }\n+    if node.const_token().is_some() {\n+        format_to!(buf, \"const \");\n+    }\n+    if node.unsafe_token().is_some() {\n+        format_to!(buf, \"unsafe \");\n+    }\n+    if let Some(abi) = node.abi() {\n+        // Keyword `extern` is included in the string.\n+        format_to!(buf, \"{} \", abi);\n+    }\n+    if let Some(name) = node.name() {\n+        format_to!(buf, \"fn {}\", name)\n+    }\n+    if let Some(type_params) = node.type_param_list() {\n+        format_to!(buf, \"{}\", type_params);\n+    }\n+    if let Some(param_list) = node.param_list() {\n+        format_to!(buf, \"{}\", param_list);\n+    }\n+    if let Some(ret_type) = node.ret_type() {\n+        if ret_type.type_ref().is_some() {\n+            format_to!(buf, \" {}\", ret_type);\n+        }\n+    }\n+    if let Some(where_clause) = node.where_clause() {\n+        format_to!(buf, \"\\n{}\", where_clause);\n+    }\n+    buf\n }\n \n pub(crate) fn const_label(node: &ast::ConstDef) -> String {\n@@ -41,23 +76,6 @@ pub(crate) fn type_label(node: &ast::TypeAliasDef) -> String {\n     label.trim().to_owned()\n }\n \n-pub(crate) fn generic_parameters<N: TypeParamsOwner>(node: &N) -> Vec<String> {\n-    let mut res = vec![];\n-    if let Some(type_params) = node.type_param_list() {\n-        res.extend(type_params.lifetime_params().map(|p| p.syntax().text().to_string()));\n-        res.extend(type_params.type_params().map(|p| p.syntax().text().to_string()));\n-    }\n-    res\n-}\n-\n-pub(crate) fn where_predicates<N: TypeParamsOwner>(node: &N) -> Vec<String> {\n-    let mut res = vec![];\n-    if let Some(clause) = node.where_clause() {\n-        res.extend(clause.predicates().map(|p| p.syntax().text().to_string()));\n-    }\n-    res\n-}\n-\n pub(crate) fn macro_label(node: &ast::MacroCall) -> String {\n     let name = node.name().map(|name| name.syntax().text().to_string()).unwrap_or_default();\n     let vis = if node.has_atom_attr(\"macro_export\") { \"#[macro_export]\\n\" } else { \"\" };"}, {"sha": "9b7220d1fe30a5935c9b4600c9ccfa4c2422ac4a", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/4759a39f06be1ec1469101a8aac39039b8743806/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4759a39f06be1ec1469101a8aac39039b8743806/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=4759a39f06be1ec1469101a8aac39039b8743806", "patch": "@@ -1,298 +0,0 @@\n-//! FIXME: write short doc here\n-\n-// FIXME: this modules relies on strings and AST way too much, and it should be\n-// rewritten (matklad 2020-05-07)\n-use std::{\n-    convert::From,\n-    fmt::{self, Display},\n-};\n-\n-use hir::{Docs, Documentation, HasSource, HirDisplay};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n-use stdx::{split_delim, SepBy};\n-\n-use crate::display::{generic_parameters, where_predicates};\n-\n-#[derive(Debug)]\n-pub(crate) enum CallableKind {\n-    Function,\n-    StructConstructor,\n-    VariantConstructor,\n-}\n-\n-/// Contains information about a function signature\n-#[derive(Debug)]\n-pub(crate) struct FunctionSignature {\n-    pub(crate) kind: CallableKind,\n-    /// Optional visibility\n-    pub(crate) visibility: Option<String>,\n-    /// Qualifiers like `async`, `unsafe`, ...\n-    pub(crate) qualifier: FunctionQualifier,\n-    /// Name of the function\n-    pub(crate) name: Option<String>,\n-    /// Documentation for the function\n-    pub(crate) doc: Option<Documentation>,\n-    /// Generic parameters\n-    pub(crate) generic_parameters: Vec<String>,\n-    /// Parameters of the function\n-    pub(crate) parameters: Vec<String>,\n-    /// Parameter names of the function\n-    pub(crate) parameter_names: Vec<String>,\n-    /// Parameter types of the function\n-    pub(crate) parameter_types: Vec<String>,\n-    /// Optional return type\n-    pub(crate) ret_type: Option<String>,\n-    /// Where predicates\n-    pub(crate) where_predicates: Vec<String>,\n-    /// Self param presence\n-    pub(crate) has_self_param: bool,\n-}\n-\n-#[derive(Debug, Default)]\n-pub(crate) struct FunctionQualifier {\n-    // `async` and `const` are mutually exclusive. Do we need to enforcing it here?\n-    pub(crate) is_async: bool,\n-    pub(crate) is_const: bool,\n-    pub(crate) is_unsafe: bool,\n-    /// The string `extern \"..\"`\n-    pub(crate) extern_abi: Option<String>,\n-}\n-\n-impl FunctionSignature {\n-    pub(crate) fn from_hir(db: &RootDatabase, function: hir::Function) -> Self {\n-        let ast_node = function.source(db).value;\n-        let mut res = FunctionSignature::from(&ast_node);\n-        res.doc = function.docs(db);\n-        res\n-    }\n-\n-    pub(crate) fn from_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n-        let node: ast::StructDef = st.source(db).value;\n-        if let ast::StructKind::Record(_) = node.kind() {\n-            return None;\n-        };\n-\n-        let mut params = vec![];\n-        let mut parameter_types = vec![];\n-        for field in st.fields(db).into_iter() {\n-            let ty = field.signature_ty(db);\n-            let raw_param = format!(\"{}\", ty.display(db));\n-\n-            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n-                parameter_types.push(param_type.to_string());\n-            } else {\n-                // useful when you have tuple struct\n-                parameter_types.push(raw_param.clone());\n-            }\n-            params.push(raw_param);\n-        }\n-\n-        Some(FunctionSignature {\n-            kind: CallableKind::StructConstructor,\n-            visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n-            // Do we need `const`?\n-            qualifier: Default::default(),\n-            name: node.name().map(|n| n.text().to_string()),\n-            ret_type: node.name().map(|n| n.text().to_string()),\n-            parameters: params,\n-            parameter_names: vec![],\n-            parameter_types,\n-            generic_parameters: generic_parameters(&node),\n-            where_predicates: where_predicates(&node),\n-            doc: st.docs(db),\n-            has_self_param: false,\n-        })\n-    }\n-\n-    pub(crate) fn from_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n-        let node: ast::EnumVariant = variant.source(db).value;\n-        match node.kind() {\n-            ast::StructKind::Record(_) | ast::StructKind::Unit => return None,\n-            _ => (),\n-        };\n-\n-        let parent_name = variant.parent_enum(db).name(db).to_string();\n-\n-        let name = format!(\"{}::{}\", parent_name, variant.name(db));\n-\n-        let mut params = vec![];\n-        let mut parameter_types = vec![];\n-        for field in variant.fields(db).into_iter() {\n-            let ty = field.signature_ty(db);\n-            let raw_param = format!(\"{}\", ty.display(db));\n-            if let Some(param_type) = raw_param.split(':').nth(1).and_then(|it| it.get(1..)) {\n-                parameter_types.push(param_type.to_string());\n-            } else {\n-                // The unwrap_or_else is useful when you have tuple\n-                parameter_types.push(raw_param);\n-            }\n-            let name = field.name(db);\n-\n-            params.push(format!(\"{}: {}\", name, ty.display(db)));\n-        }\n-\n-        Some(FunctionSignature {\n-            kind: CallableKind::VariantConstructor,\n-            visibility: None,\n-            // Do we need `const`?\n-            qualifier: Default::default(),\n-            name: Some(name),\n-            ret_type: None,\n-            parameters: params,\n-            parameter_names: vec![],\n-            parameter_types,\n-            generic_parameters: vec![],\n-            where_predicates: vec![],\n-            doc: variant.docs(db),\n-            has_self_param: false,\n-        })\n-    }\n-}\n-\n-impl From<&'_ ast::FnDef> for FunctionSignature {\n-    fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>, Vec<String>) {\n-            let mut res = vec![];\n-            let mut res_types = vec![];\n-            let mut has_self_param = false;\n-            if let Some(param_list) = node.param_list() {\n-                if let Some(self_param) = param_list.self_param() {\n-                    has_self_param = true;\n-                    let raw_param = self_param.syntax().text().to_string();\n-\n-                    res_types.push(\n-                        raw_param\n-                            .split(':')\n-                            .nth(1)\n-                            .and_then(|it| it.get(1..))\n-                            .unwrap_or_else(|| \"Self\")\n-                            .to_string(),\n-                    );\n-                    res.push(raw_param);\n-                }\n-\n-                // macro-generated functions are missing whitespace\n-                fn fmt_param(param: ast::Param) -> String {\n-                    let text = param.syntax().text().to_string();\n-                    match split_delim(&text, ':') {\n-                        Some((left, right)) => format!(\"{}: {}\", left.trim(), right.trim()),\n-                        _ => text,\n-                    }\n-                }\n-\n-                res.extend(param_list.params().map(fmt_param));\n-                res_types.extend(param_list.params().map(|param| {\n-                    let param_text = param.syntax().text().to_string();\n-                    match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {\n-                        Some(it) => it.to_string(),\n-                        None => param_text,\n-                    }\n-                }));\n-            }\n-            (has_self_param, res, res_types)\n-        }\n-\n-        fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n-            let mut res = vec![];\n-            if let Some(param_list) = node.param_list() {\n-                if let Some(self_param) = param_list.self_param() {\n-                    res.push(self_param.syntax().text().to_string())\n-                }\n-\n-                res.extend(\n-                    param_list\n-                        .params()\n-                        .map(|param| {\n-                            Some(\n-                                param\n-                                    .pat()?\n-                                    .syntax()\n-                                    .descendants()\n-                                    .find_map(ast::Name::cast)?\n-                                    .text()\n-                                    .to_string(),\n-                            )\n-                        })\n-                        .map(|param| param.unwrap_or_default()),\n-                );\n-            }\n-            res\n-        }\n-\n-        let (has_self_param, parameters, parameter_types) = param_list(node);\n-\n-        FunctionSignature {\n-            kind: CallableKind::Function,\n-            visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n-            qualifier: FunctionQualifier {\n-                is_async: node.async_token().is_some(),\n-                is_const: node.const_token().is_some(),\n-                is_unsafe: node.unsafe_token().is_some(),\n-                extern_abi: node.abi().map(|n| n.to_string()),\n-            },\n-            name: node.name().map(|n| n.text().to_string()),\n-            ret_type: node\n-                .ret_type()\n-                .and_then(|r| r.type_ref())\n-                .map(|n| n.syntax().text().to_string()),\n-            parameters,\n-            parameter_names: param_name_list(node),\n-            parameter_types,\n-            generic_parameters: generic_parameters(node),\n-            where_predicates: where_predicates(node),\n-            // docs are processed separately\n-            doc: None,\n-            has_self_param,\n-        }\n-    }\n-}\n-\n-impl Display for FunctionSignature {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if let Some(t) = &self.visibility {\n-            write!(f, \"{} \", t)?;\n-        }\n-\n-        if self.qualifier.is_async {\n-            write!(f, \"async \")?;\n-        }\n-\n-        if self.qualifier.is_const {\n-            write!(f, \"const \")?;\n-        }\n-\n-        if self.qualifier.is_unsafe {\n-            write!(f, \"unsafe \")?;\n-        }\n-\n-        if let Some(extern_abi) = &self.qualifier.extern_abi {\n-            // Keyword `extern` is included in the string.\n-            write!(f, \"{} \", extern_abi)?;\n-        }\n-\n-        if let Some(name) = &self.name {\n-            match self.kind {\n-                CallableKind::Function => write!(f, \"fn {}\", name)?,\n-                CallableKind::StructConstructor => write!(f, \"struct {}\", name)?,\n-                CallableKind::VariantConstructor => write!(f, \"{}\", name)?,\n-            }\n-        }\n-\n-        if !self.generic_parameters.is_empty() {\n-            write!(f, \"{}\", self.generic_parameters.iter().sep_by(\", \").surround_with(\"<\", \">\"))?;\n-        }\n-\n-        write!(f, \"{}\", self.parameters.iter().sep_by(\", \").surround_with(\"(\", \")\"))?;\n-\n-        if let Some(t) = &self.ret_type {\n-            write!(f, \" -> {}\", t)?;\n-        }\n-\n-        if !self.where_predicates.is_empty() {\n-            write!(f, \"\\nwhere {}\", self.where_predicates.iter().sep_by(\",\\n      \"))?;\n-        }\n-\n-        Ok(())\n-    }\n-}"}, {"sha": "5588130a10752f9f8b5b907d255001975a1693d4", "filename": "crates/ra_ide/src/display/short_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -9,7 +9,7 @@ pub(crate) trait ShortLabel {\n \n impl ShortLabel for ast::FnDef {\n     fn short_label(&self) -> Option<String> {\n-        Some(crate::display::function_label(self))\n+        Some(crate::display::function_declaration(self))\n     }\n }\n "}, {"sha": "cec3b04e86e639f0fb84bfdf8d8896d1e2d9083f", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 31, "deletions": 45, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81c82733899691fec7ed046525a5c583d3c7d5be/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=81c82733899691fec7ed046525a5c583d3c7d5be", "patch": "@@ -1,4 +1,4 @@\n-use hir::{Adt, HirDisplay, Semantics, Type};\n+use hir::{Adt, Callable, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n@@ -7,7 +7,9 @@ use ra_syntax::{\n };\n use stdx::to_lower_snake_case;\n \n-use crate::{display::function_signature::FunctionSignature, FileId};\n+use crate::FileId;\n+use ast::NameOwner;\n+use either::Either;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct InlayHintsConfig {\n@@ -150,23 +152,26 @@ fn get_param_name_hints(\n         _ => return None,\n     };\n \n-    let fn_signature = get_fn_signature(sema, &expr)?;\n-    let n_params_to_skip =\n-        if fn_signature.has_self_param && matches!(&expr, ast::Expr::MethodCallExpr(_)) {\n-            1\n-        } else {\n-            0\n-        };\n-    let hints = fn_signature\n-        .parameter_names\n-        .iter()\n-        .skip(n_params_to_skip)\n+    let callable = get_callable(sema, &expr)?;\n+    let hints = callable\n+        .params(sema.db)\n+        .into_iter()\n         .zip(args)\n-        .filter(|(param, arg)| should_show_param_name_hint(sema, &fn_signature, param, &arg))\n+        .filter_map(|((param, _ty), arg)| match param? {\n+            Either::Left(self_param) => Some((self_param.to_string(), arg)),\n+            Either::Right(pat) => {\n+                let param_name = match pat {\n+                    ast::Pat::BindPat(it) => it.name()?.to_string(),\n+                    it => it.to_string(),\n+                };\n+                Some((param_name, arg))\n+            }\n+        })\n+        .filter(|(param_name, arg)| should_show_param_name_hint(sema, &callable, &param_name, &arg))\n         .map(|(param_name, arg)| InlayHint {\n             range: arg.syntax().text_range(),\n             kind: InlayKind::ParameterHint,\n-            label: param_name.into(),\n+            label: param_name.to_string().into(),\n         });\n \n     acc.extend(hints);\n@@ -250,28 +255,26 @@ fn should_not_display_type_hint(db: &RootDatabase, bind_pat: &ast::BindPat, pat_\n \n fn should_show_param_name_hint(\n     sema: &Semantics<RootDatabase>,\n-    fn_signature: &FunctionSignature,\n+    callable: &Callable,\n     param_name: &str,\n     argument: &ast::Expr,\n ) -> bool {\n     let param_name = param_name.trim_start_matches('_');\n+    let fn_name = match callable.kind() {\n+        hir::CallableKind::Function(it) => Some(it.name(sema.db).to_string()),\n+        hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => None,\n+    };\n     if param_name.is_empty()\n-        || Some(param_name) == fn_signature.name.as_ref().map(|s| s.trim_start_matches('_'))\n+        || Some(param_name) == fn_name.as_ref().map(|s| s.trim_start_matches('_'))\n         || is_argument_similar_to_param_name(sema, argument, param_name)\n         || param_name.starts_with(\"ra_fixture\")\n     {\n         return false;\n     }\n \n-    let parameters_len = if fn_signature.has_self_param {\n-        fn_signature.parameters.len() - 1\n-    } else {\n-        fn_signature.parameters.len()\n-    };\n-\n     // avoid displaying hints for common functions like map, filter, etc.\n     // or other obvious words used in std\n-    !(parameters_len == 1 && is_obvious_param(param_name))\n+    !(callable.n_params() == 1 && is_obvious_param(param_name))\n }\n \n fn is_argument_similar_to_param_name(\n@@ -318,27 +321,10 @@ fn is_obvious_param(param_name: &str) -> bool {\n     param_name.len() == 1 || is_obvious_param_name\n }\n \n-fn get_fn_signature(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<FunctionSignature> {\n+fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<Callable> {\n     match expr {\n-        ast::Expr::CallExpr(expr) => {\n-            // FIXME: Type::as_callable is broken for closures\n-            let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db)?;\n-            match callable.kind() {\n-                hir::CallableKind::Function(it) => {\n-                    Some(FunctionSignature::from_hir(sema.db, it.into()))\n-                }\n-                hir::CallableKind::TupleStruct(it) => {\n-                    FunctionSignature::from_struct(sema.db, it.into())\n-                }\n-                hir::CallableKind::TupleEnumVariant(it) => {\n-                    FunctionSignature::from_enum_variant(sema.db, it.into())\n-                }\n-            }\n-        }\n-        ast::Expr::MethodCallExpr(expr) => {\n-            let fn_def = sema.resolve_method_call(&expr)?;\n-            Some(FunctionSignature::from_hir(sema.db, fn_def))\n-        }\n+        ast::Expr::CallExpr(expr) => sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db),\n+        ast::Expr::MethodCallExpr(expr) => sema.resolve_method_call_as_callable(expr),\n         _ => None,\n     }\n }\n@@ -360,7 +346,7 @@ mod tests {\n         let inlay_hints = analysis.inlay_hints(file_id, &config).unwrap();\n         let actual =\n             inlay_hints.into_iter().map(|it| (it.range, it.label.to_string())).collect::<Vec<_>>();\n-        assert_eq!(expected, actual);\n+        assert_eq!(expected, actual, \"\\nExpected:\\n{:#?}\\n\\nActual:\\n{:#?}\", expected, actual);\n     }\n \n     fn check_expect(config: InlayHintsConfig, ra_fixture: &str, expect: Expect) {"}]}