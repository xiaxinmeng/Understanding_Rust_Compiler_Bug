{"sha": "f94360fd83b49554b6c26999a0030e9cfe800f32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NDM2MGZkODNiNDk1NTRiNmMyNjk5OWEwMDMwZTljZmU4MDBmMzI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-03-27T03:23:20Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-03-27T03:32:18Z"}, "message": "Always preserve `None`-delimited groups in a captured `TokenStream`\n\nPreviously, we would silently remove any `None`-delimiters when\ncapturing a `TokenStream`, 'flattenting' them to their inner tokens.\nThis was not normally visible, since we usually have\n`TokenKind::Interpolated` (which gets converted to a `None`-delimited\ngroup during macro invocation) instead of an actual `None`-delimited\ngroup.\n\nHowever, there are a couple of cases where this becomes visible to\nproc-macros:\n1. A cross-crate `macro_rules!` macro has a `None`-delimited group\n   stored in its body (as a result of being produced by another\n   `macro_rules!` macro). The cross-crate `macro_rules!` invocation\n   can then expand to an attribute macro invocation, which needs\n   to be able to see the `None`-delimited group.\n2. A proc-macro can invoke an attribute proc-macro with its re-collected\n   input. If there are any nonterminals present in the input, they will\n   get re-collected to `None`-delimited groups, which will then get\n   captured as part of the attribute macro invocation.\n\nBoth of these cases are incredibly obscure, so there hopefully won't be\nany breakage. This change will allow more agressive 'flattenting' of\nnonterminals in #82608 without losing `None`-delimited groups.", "tree": {"sha": "1a0a71c244967964d54ad691e63b1bfb8c24f374", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a0a71c244967964d54ad691e63b1bfb8c24f374"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f94360fd83b49554b6c26999a0030e9cfe800f32", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmBeqKEACgkQtAh+UQ6Y\nsWSd2RAApHu/dEvlKQA9HrgR5Q6xAmIeyfRpqr9uxFzHEkAXNeod3QZRZtlAW8sH\nbEyYU5po7AkD8ixG3sJoDBNZgb0SVkjwemelsvwpWjXCDWAvjp9roRvImKHaumJq\n345Ubnj2eiVTw3+wRIVOSCG2zDUyDXGzYXElKpqYWVSoP0AzX4NtRhUbazaJypN9\nUtK6p6S+KEbsj8n8g474XYqByr/c7sZqdTgg2gBP8Njbf8973pwUd/SVxeIa4vGH\nFaN6FBFn2/4EjbRIzDhkyD+VVcuFVXaxhI7Ruxam2SnCYkJNgmqyBvgjzr0igHzD\nZIOQEnPzY47ou2pB0Zme3WNuvcgm6VcYY4K+o3GYldHlxq4RC2DoeTa7YZDS70im\n9dUa/7HyGlbtVEo9440T0486I1dy6jo16fn4w69FzsAPZ6HElbnP/pITu4zdG8sz\nIjs8RaEK+P3bFv/FzxG7gSHSgvnvtWQr4xT44ey64lu6hIxALI6RKLplsv+1HIdy\njMrO3KOdugBa0w2mg184S5pn+BH4Pus6CZ8AaXvHw3yzesZhiyl/MY44h53WjD19\nguaQdFHOAHqilnUUpQZJ0iAXW/Ea7ZlVnHRfxSbJkSujFqwC9Ug6MyOuzQTnRbw1\nGcM/4zoWoTyndhGabFBQXe73tz9QyTwGne/FITt/kJtjnt+JaAU=\n=dQhS\n-----END PGP SIGNATURE-----", "payload": "tree 1a0a71c244967964d54ad691e63b1bfb8c24f374\nparent f811f14006fa46030f1af714f7d640580d3ad822\nauthor Aaron Hill <aa1ronham@gmail.com> 1616815400 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1616815938 -0400\n\nAlways preserve `None`-delimited groups in a captured `TokenStream`\n\nPreviously, we would silently remove any `None`-delimiters when\ncapturing a `TokenStream`, 'flattenting' them to their inner tokens.\nThis was not normally visible, since we usually have\n`TokenKind::Interpolated` (which gets converted to a `None`-delimited\ngroup during macro invocation) instead of an actual `None`-delimited\ngroup.\n\nHowever, there are a couple of cases where this becomes visible to\nproc-macros:\n1. A cross-crate `macro_rules!` macro has a `None`-delimited group\n   stored in its body (as a result of being produced by another\n   `macro_rules!` macro). The cross-crate `macro_rules!` invocation\n   can then expand to an attribute macro invocation, which needs\n   to be able to see the `None`-delimited group.\n2. A proc-macro can invoke an attribute proc-macro with its re-collected\n   input. If there are any nonterminals present in the input, they will\n   get re-collected to `None`-delimited groups, which will then get\n   captured as part of the attribute macro invocation.\n\nBoth of these cases are incredibly obscure, so there hopefully won't be\nany breakage. This change will allow more agressive 'flattenting' of\nnonterminals in #82608 without losing `None`-delimited groups.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f94360fd83b49554b6c26999a0030e9cfe800f32", "html_url": "https://github.com/rust-lang/rust/commit/f94360fd83b49554b6c26999a0030e9cfe800f32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f94360fd83b49554b6c26999a0030e9cfe800f32/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f811f14006fa46030f1af714f7d640580d3ad822", "url": "https://api.github.com/repos/rust-lang/rust/commits/f811f14006fa46030f1af714f7d640580d3ad822", "html_url": "https://github.com/rust-lang/rust/commit/f811f14006fa46030f1af714f7d640580d3ad822"}], "stats": {"total": 141, "additions": 113, "deletions": 28}, "files": [{"sha": "36a0fda645805d747280f9f3849eaf824977ae1d", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f94360fd83b49554b6c26999a0030e9cfe800f32/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94360fd83b49554b6c26999a0030e9cfe800f32/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=f94360fd83b49554b6c26999a0030e9cfe800f32", "patch": "@@ -98,21 +98,46 @@ impl<'a> Parser<'a> {\n         }\n         impl CreateTokenStream for LazyTokenStreamImpl {\n             fn create_token_stream(&self) -> TokenStream {\n-                // The token produced by the final call to `next` or `next_desugared`\n-                // was not actually consumed by the callback. The combination\n-                // of chaining the initial token and using `take` produces the desired\n-                // result - we produce an empty `TokenStream` if no calls were made,\n-                // and omit the final token otherwise.\n+                if self.num_calls == 0 {\n+                    return TokenStream::new(vec![]);\n+                }\n+\n                 let mut cursor_snapshot = self.cursor_snapshot.clone();\n-                let tokens = std::iter::once(self.start_token.clone())\n-                    .chain((0..self.num_calls).map(|_| {\n-                        if self.desugar_doc_comments {\n+                // Don't skip `None` delimiters, since we want to pass them to\n+                // proc macros. Normally, we'll end up capturing `TokenKind::Interpolated`,\n+                // which gets converted to a `None`-delimited group when we invoke\n+                // a proc-macro. However, it's possible to already have a `None`-delimited\n+                // group in the stream (such as when parsing the output of a proc-macro,\n+                // or in certain unusual cases with cross-crate `macro_rules!` macros).\n+                cursor_snapshot.skip_none_delims = false;\n+\n+                // The token produced by the final call to `next` or `next_desugared`\n+                // was not actually consumed by the callback.\n+                let num_calls = self.num_calls - 1;\n+                let mut i = 0;\n+                let tokens =\n+                    std::iter::once(self.start_token.clone()).chain(std::iter::from_fn(|| {\n+                        if i >= num_calls {\n+                            return None;\n+                        }\n+\n+                        let token = if self.desugar_doc_comments {\n                             cursor_snapshot.next_desugared()\n                         } else {\n                             cursor_snapshot.next()\n+                        };\n+\n+                        // When the `LazyTokenStreamImpl` was original produced, we did *not*\n+                        // include `NoDelim` tokens in `num_calls`, since they are normally ignored\n+                        // by the parser. Therefore, we only increment our counter for other types of tokens.\n+                        if !matches!(\n+                            token.0.kind,\n+                            token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim)\n+                        ) {\n+                            i += 1;\n                         }\n-                    }))\n-                    .take(self.num_calls);\n+                        Some(token)\n+                    }));\n \n                 make_token_stream(tokens, self.append_unglued_token.clone())\n             }"}, {"sha": "748a8e2bb490fbefa6e749c7686c4ac83729ec4b", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f94360fd83b49554b6c26999a0030e9cfe800f32/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94360fd83b49554b6c26999a0030e9cfe800f32/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=f94360fd83b49554b6c26999a0030e9cfe800f32", "patch": "@@ -172,6 +172,13 @@ struct TokenCursor {\n     // appended to the captured stream when\n     // we evaluate a `LazyTokenStream`\n     append_unglued_token: Option<TreeAndSpacing>,\n+    // If `true`, skip the delimiters for `None`-delimited groups,\n+    // and just yield the inner tokens. This is `true` during\n+    // normal parsing, since the parser code is not currently prepared\n+    // to handle `None` delimiters. When capturing a `TokenStream`,\n+    // however, we want to handle `None`-delimiters, since\n+    // proc-macros always see `None`-delimited groups.\n+    skip_none_delims: bool,\n }\n \n #[derive(Clone)]\n@@ -184,13 +191,13 @@ struct TokenCursorFrame {\n }\n \n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n+    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream, skip_none_delims: bool) -> Self {\n         TokenCursorFrame {\n             delim,\n             span,\n-            open_delim: delim == token::NoDelim,\n+            open_delim: delim == token::NoDelim && skip_none_delims,\n             tree_cursor: tts.into_trees(),\n-            close_delim: delim == token::NoDelim,\n+            close_delim: delim == token::NoDelim && skip_none_delims,\n         }\n     }\n }\n@@ -218,7 +225,7 @@ impl TokenCursor {\n                     return (token, spacing);\n                 }\n                 TokenTree::Delimited(sp, delim, tts) => {\n-                    let frame = TokenCursorFrame::new(sp, delim, tts);\n+                    let frame = TokenCursorFrame::new(sp, delim, tts, self.skip_none_delims);\n                     self.stack.push(mem::replace(&mut self.frame, frame));\n                 }\n             }\n@@ -276,6 +283,7 @@ impl TokenCursor {\n                         .cloned()\n                         .collect::<TokenStream>()\n                 },\n+                self.skip_none_delims,\n             ),\n         ));\n \n@@ -371,12 +379,19 @@ impl<'a> Parser<'a> {\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n+            // Skip over the delimiters for `None`-delimited groups\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens),\n+                frame: TokenCursorFrame::new(\n+                    DelimSpan::dummy(),\n+                    token::NoDelim,\n+                    tokens,\n+                    /* skip_none_delims */ true,\n+                ),\n                 stack: Vec::new(),\n                 num_next_calls: 0,\n                 desugar_doc_comments,\n                 append_unglued_token: None,\n+                skip_none_delims: true,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,"}, {"sha": "27676a5cb8112e2a3a077d4f6279fd020ad38bbe", "filename": "src/test/ui/proc-macro/auxiliary/nested-macro-rules.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs?ref=f94360fd83b49554b6c26999a0030e9cfe800f32", "patch": "@@ -2,14 +2,15 @@ pub struct FirstStruct;\n \n #[macro_export]\n macro_rules! outer_macro {\n-    ($name:ident) => {\n+    ($name:ident, $attr_struct_name:ident) => {\n         #[macro_export]\n         macro_rules! inner_macro {\n-            ($wrapper:ident) => {\n-                $wrapper!($name)\n+            ($bang_macro:ident, $attr_macro:ident) => {\n+                $bang_macro!($name);\n+                #[$attr_macro] struct $attr_struct_name {}\n             }\n         }\n     }\n }\n \n-outer_macro!(FirstStruct);\n+outer_macro!(FirstStruct, FirstAttrStruct);"}, {"sha": "25ffcfad7c7eaac28500fec2c7c74cae7c9e9d16", "filename": "src/test/ui/proc-macro/nested-macro-rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs?ref=f94360fd83b49554b6c26999a0030e9cfe800f32", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // aux-build:nested-macro-rules.rs\n // aux-build:test-macros.rs\n-// compile-flags: -Z span-debug\n+// compile-flags: -Z span-debug -Z macro-backtrace\n // edition:2018\n \n #![no_std] // Don't load unnecessary hygiene information from std\n@@ -10,14 +10,14 @@ extern crate std;\n extern crate nested_macro_rules;\n extern crate test_macros;\n \n-use test_macros::print_bang;\n+use test_macros::{print_bang, print_attr};\n \n use nested_macro_rules::FirstStruct;\n struct SecondStruct;\n \n fn main() {\n-    nested_macro_rules::inner_macro!(print_bang);\n+    nested_macro_rules::inner_macro!(print_bang, print_attr);\n \n-    nested_macro_rules::outer_macro!(SecondStruct);\n-    inner_macro!(print_bang);\n+    nested_macro_rules::outer_macro!(SecondStruct, SecondAttrStruct);\n+    inner_macro!(print_bang, print_attr);\n }"}, {"sha": "8292617fc1675687a360a71b3ee0fff04a7ba3f1", "filename": "src/test/ui/proc-macro/nested-macro-rules.stdout", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f94360fd83b49554b6c26999a0030e9cfe800f32/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout?ref=f94360fd83b49554b6c26999a0030e9cfe800f32", "patch": "@@ -5,10 +5,32 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         stream: TokenStream [\n             Ident {\n                 ident: \"FirstStruct\",\n-                span: $DIR/auxiliary/nested-macro-rules.rs:15:14: 15:25 (#7),\n+                span: $DIR/auxiliary/nested-macro-rules.rs:16:14: 16:25 (#7),\n             },\n         ],\n-        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#6),\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:30: 9:35 (#6),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct FirstAttrStruct { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:32: 10:38 (#6),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"FirstAttrStruct\",\n+                span: $DIR/auxiliary/nested-macro-rules.rs:16:27: 16:42 (#7),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:39: 10:56 (#6),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:57: 10:59 (#6),\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): SecondStruct\n@@ -18,9 +40,31 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         stream: TokenStream [\n             Ident {\n                 ident: \"SecondStruct\",\n-                span: $DIR/nested-macro-rules.rs:21:38: 21:50 (#13),\n+                span: $DIR/nested-macro-rules.rs:21:38: 21:50 (#16),\n             },\n         ],\n-        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#12),\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:30: 9:35 (#15),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): struct SecondAttrStruct { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:32: 10:38 (#15),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"SecondAttrStruct\",\n+                span: $DIR/nested-macro-rules.rs:21:52: 21:68 (#16),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:39: 10:56 (#15),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:10:57: 10:59 (#15),\n     },\n ]"}]}