{"sha": "b58e31ac03d3f338385593496426534ad5a150a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OGUzMWFjMDNkM2YzMzgzODU1OTM0OTY0MjY1MzRhZDVhMTUwYTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-30T05:30:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-30T05:30:28Z"}, "message": "Auto merge of #43880 - arielb1:noninvasive-probe, r=nikomatsakis\n\nRemove the trait selection impl in method::probe\n\nThis removes the hacky trait selection reimplementation in `method::probe`, which occasionally comes and causes problems.\n\nThere are 2 issues I've found with this approach:\n1. The older implementation sometimes had a \"guess\" type from an impl, which allowed subtyping to work. This is why I needed to make a change in `libtest`: there's an `impl<A> Clone for fn(A)` and we're calling `<for<'a> fn(&'a T) as Clone>::clone`. The older implementation would do a subtyping between the impl type and the trait type, so it would do the check for `<fn(A) as Clone>::clone`, and confirmation would continue with the subtyping. The newer implementation directly passes `<for<'a> fn(&'a T) as Clone>::clone` to selection, which fails. I'm not sure how big of a problem that would be in reality, especially after #43690 would remove the `Clone` problem, but I still want a crater run to avoid breaking the world.\n2. The older implementation \"looked into\" impls to display error messages. I'm not sure that's an advantage - it looked exactly 1 level deep.\n\nr? @eddyb", "tree": {"sha": "6f5e3876d4d80f3ce558e7d73f5f1296d48d901a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f5e3876d4d80f3ce558e7d73f5f1296d48d901a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b58e31ac03d3f338385593496426534ad5a150a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b58e31ac03d3f338385593496426534ad5a150a7", "html_url": "https://github.com/rust-lang/rust/commit/b58e31ac03d3f338385593496426534ad5a150a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b58e31ac03d3f338385593496426534ad5a150a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2f9cc4a3bf8917e6cd9f31e3a2e9baa8c15e8f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2f9cc4a3bf8917e6cd9f31e3a2e9baa8c15e8f1", "html_url": "https://github.com/rust-lang/rust/commit/c2f9cc4a3bf8917e6cd9f31e3a2e9baa8c15e8f1"}, {"sha": "15f6540ec02a6e1c556f0a915c494d8a45ea9338", "url": "https://api.github.com/repos/rust-lang/rust/commits/15f6540ec02a6e1c556f0a915c494d8a45ea9338", "html_url": "https://github.com/rust-lang/rust/commit/15f6540ec02a6e1c556f0a915c494d8a45ea9338"}], "stats": {"total": 1156, "additions": 463, "deletions": 693}, "files": [{"sha": "4e9398e5058066ee3f19709ffe556590be839b15", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 80, "deletions": 106, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -194,13 +194,12 @@ enum SelectionCandidate<'tcx> {\n     ProjectionCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression. The ty::ClosureKind informs the\n-    /// confirmation step what ClosureKind obligation to emit.\n-    ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n+    /// generated for a `||` expression.\n+    ClosureCandidate,\n \n     /// Implementation of a `Generator` trait by one of the anonymous types\n     /// generated for a generator.\n-    GeneratorCandidate(/* function / closure */ DefId, ty::ClosureSubsts<'tcx>),\n+    GeneratorCandidate,\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -229,20 +228,12 @@ impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n             ObjectCandidate => ObjectCandidate,\n             BuiltinObjectCandidate => BuiltinObjectCandidate,\n             BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n+            ClosureCandidate => ClosureCandidate,\n+            GeneratorCandidate => GeneratorCandidate,\n \n             ParamCandidate(ref trait_ref) => {\n                 return tcx.lift(trait_ref).map(ParamCandidate);\n             }\n-            GeneratorCandidate(def_id, ref substs) => {\n-                return tcx.lift(substs).map(|substs| {\n-                    GeneratorCandidate(def_id, substs)\n-                });\n-            }\n-            ClosureCandidate(def_id, ref substs, kind) => {\n-                return tcx.lift(substs).map(|substs| {\n-                    ClosureCandidate(def_id, substs, kind)\n-                });\n-            }\n         })\n     }\n }\n@@ -1471,23 +1462,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n-        let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyGenerator(id, substs, _) => (id, substs),\n+        match self_ty.sty {\n+            ty::TyGenerator(..) => {\n+                debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n+                       self_ty,\n+                       obligation);\n+\n+                candidates.vec.push(GeneratorCandidate);\n+                Ok(())\n+            }\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_generator_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n             _ => { return Ok(()); }\n-        };\n-\n-        debug!(\"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n-               self_ty,\n-               obligation);\n-\n-        candidates.vec.push(GeneratorCandidate(closure_def_id, substs));\n-\n-        Ok(())\n+        }\n     }\n \n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n@@ -1509,36 +1499,31 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // ok to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        let self_ty = *obligation.self_ty().skip_binder();\n-        let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, substs) => (id, substs),\n+        match obligation.self_ty().skip_binder().sty {\n+            ty::TyClosure(closure_def_id, _) => {\n+                debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\",\n+                       kind, obligation);\n+                match self.infcx.closure_kind(closure_def_id) {\n+                    Some(closure_kind) => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n+                        if closure_kind.extends(kind) {\n+                            candidates.vec.push(ClosureCandidate);\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n+                        candidates.vec.push(ClosureCandidate);\n+                    }\n+                };\n+                Ok(())\n+            }\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n             _ => { return Ok(()); }\n-        };\n-\n-        debug!(\"assemble_unboxed_candidates: self_ty={:?} kind={:?} obligation={:?}\",\n-               self_ty,\n-               kind,\n-               obligation);\n-\n-        match self.infcx.closure_kind(closure_def_id) {\n-            Some(closure_kind) => {\n-                debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                if closure_kind.extends(kind) {\n-                    candidates.vec.push(ClosureCandidate(closure_def_id, substs, kind));\n-                }\n-            }\n-            None => {\n-                debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n-                candidates.vec.push(ClosureCandidate(closure_def_id, substs, kind));\n-            }\n         }\n-\n-        Ok(())\n     }\n \n     /// Implement one of the `Fn()` family for a fn pointer.\n@@ -1855,8 +1840,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                          when there are other valid candidates\");\n                 }\n                 ImplCandidate(..) |\n-                ClosureCandidate(..) |\n-                GeneratorCandidate(..) |\n+                ClosureCandidate |\n+                GeneratorCandidate |\n                 FnPointerCandidate |\n                 BuiltinObjectCandidate |\n                 BuiltinUnsizeCandidate |\n@@ -2198,15 +2183,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Ok(VtableImpl(self.confirm_impl_candidate(obligation, impl_def_id)))\n             }\n \n-            ClosureCandidate(closure_def_id, substs, kind) => {\n-                let vtable_closure =\n-                    self.confirm_closure_candidate(obligation, closure_def_id, substs, kind)?;\n+            ClosureCandidate => {\n+                let vtable_closure = self.confirm_closure_candidate(obligation)?;\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n-            GeneratorCandidate(closure_def_id, substs) => {\n-                let vtable_generator =\n-                    self.confirm_generator_candidate(obligation, closure_def_id, substs)?;\n+            GeneratorCandidate => {\n+                let vtable_generator = self.confirm_generator_candidate(obligation)?;\n                 Ok(VtableGenerator(vtable_generator))\n             }\n \n@@ -2543,21 +2526,34 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_generator_candidate(&mut self,\n-                                 obligation: &TraitObligation<'tcx>,\n-                                 closure_def_id: DefId,\n-                                 substs: ty::ClosureSubsts<'tcx>)\n-                                 -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+                                   obligation: &TraitObligation<'tcx>)\n+                                   -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n+        // ok to skip binder because the substs on generator types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyGenerator(id, substs, _) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n+        };\n+\n         debug!(\"confirm_generator_candidate({:?},{:?},{:?})\",\n                obligation,\n                closure_def_id,\n                substs);\n \n+        let trait_ref =\n+            self.generator_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n             obligations\n-        } = self.generator_trait_ref(obligation, closure_def_id, substs);\n+        } = normalize_with_depth(self,\n+                                 obligation.param_env,\n+                                 obligation.cause.clone(),\n+                                 obligation.recursion_depth+1,\n+                                 &trait_ref);\n \n         debug!(\"confirm_generator_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n                closure_def_id,\n@@ -2577,22 +2573,36 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     }\n \n     fn confirm_closure_candidate(&mut self,\n-                                 obligation: &TraitObligation<'tcx>,\n-                                 closure_def_id: DefId,\n-                                 substs: ty::ClosureSubsts<'tcx>,\n-                                 kind: ty::ClosureKind)\n+                                 obligation: &TraitObligation<'tcx>)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n-        debug!(\"confirm_closure_candidate({:?},{:?},{:?})\",\n-               obligation,\n-               closure_def_id,\n-               substs);\n+        debug!(\"confirm_closure_candidate({:?})\", obligation);\n+\n+        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+            Some(k) => k,\n+            None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n+        };\n+\n+        // ok to skip binder because the substs on closure types never\n+        // touch bound regions, they just capture the in-scope\n+        // type/region parameters\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyClosure(id, substs) => (id, substs),\n+            _ => bug!(\"closure candidate for non-closure {:?}\", obligation)\n+        };\n \n+        let trait_ref =\n+            self.closure_trait_ref_unnormalized(obligation, closure_def_id, substs);\n         let Normalized {\n             value: trait_ref,\n             mut obligations\n-        } = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        } = normalize_with_depth(self,\n+                                 obligation.param_env,\n+                                 obligation.cause.clone(),\n+                                 obligation.recursion_depth+1,\n+                                 &trait_ref);\n \n         debug!(\"confirm_closure_candidate(closure_def_id={:?}, trait_ref={:?}, obligations={:?})\",\n                closure_def_id,\n@@ -3059,24 +3069,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n-    fn closure_trait_ref(&mut self,\n-                         obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: DefId,\n-                         substs: ty::ClosureSubsts<'tcx>)\n-                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        let trait_ref = self.closure_trait_ref_unnormalized(\n-            obligation, closure_def_id, substs);\n-\n-        // A closure signature can contain associated types which\n-        // must be normalized.\n-        normalize_with_depth(self,\n-                             obligation.param_env,\n-                             obligation.cause.clone(),\n-                             obligation.recursion_depth+1,\n-                             &trait_ref)\n-    }\n-\n     fn generator_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: DefId,\n@@ -3098,24 +3090,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n-    fn generator_trait_ref(&mut self,\n-                         obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: DefId,\n-                         substs: ty::ClosureSubsts<'tcx>)\n-                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n-    {\n-        let trait_ref = self.generator_trait_ref_unnormalized(\n-            obligation, closure_def_id, substs);\n-\n-        // A generator signature can contain associated types which\n-        // must be normalized.\n-        normalize_with_depth(self,\n-                             obligation.param_env,\n-                             obligation.cause.clone(),\n-                             obligation.recursion_depth+1,\n-                             &trait_ref)\n-    }\n-\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}, {"sha": "08ec3bf74a71daf355cd41ff0cac98f22b32ec59", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -232,24 +232,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 })\n             }\n \n-            probe::ExtensionImplPick(impl_def_id) => {\n-                // The method being invoked is the method as defined on the trait,\n-                // so return the substitutions from the trait. Consider:\n-                //\n-                //     impl<A,B,C> Trait<A,B> for Foo<C> { ... }\n-                //\n-                // If we instantiate A, B, and C with $A, $B, and $C\n-                // respectively, then we want to return the type\n-                // parameters from the trait ([$A,$B]), not those from\n-                // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n-                let impl_polytype = self.impl_self_ty(self.span, impl_def_id);\n-                let impl_trait_ref =\n-                    self.instantiate_type_scheme(self.span,\n-                                                 impl_polytype.substs,\n-                                                 &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n-                impl_trait_ref.substs\n-            }\n-\n             probe::TraitPick => {\n                 let trait_def_id = pick.item.container.id();\n "}, {"sha": "31ceed5b965bff71377c4b3f9e121c702167fecd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -52,17 +52,16 @@ pub enum MethodError<'tcx> {\n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n \n-    // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n-    ClosureAmbiguity(// DefId of fn trait\n-                     DefId),\n-\n     // Found an applicable method, but it is not visible. The second argument contains a list of\n     // not-in-scope traits which may work.\n     PrivateMatch(Def, Vec<DefId>),\n \n     // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n     // forgotten to import a trait.\n     IllegalSizedBound(Vec<DefId>),\n+\n+    // Found a match, but the return type is wrong\n+    BadReturnType,\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -113,9 +112,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n-            Err(ClosureAmbiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n             Err(IllegalSizedBound(..)) => true,\n+            Err(BadReturnType) => {\n+                bug!(\"no return type expectations but got BadReturnType\")\n+            }\n+\n         }\n     }\n "}, {"sha": "228b6c88f24db77cbca22040d670d251369c8ce5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 293, "deletions": 544, "changes": 837, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -18,7 +18,7 @@ use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TraitRef, TypeFoldable};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::util::nodemap::FxHashSet;\n use rustc::infer::{self, InferOk};\n@@ -32,15 +32,6 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n-pub enum LookingFor<'tcx> {\n-    /// looking for methods with the given name; this is the normal case\n-    MethodName(ast::Name),\n-\n-    /// looking for methods that return a given type; this is used to\n-    /// assemble suggestions\n-    ReturnType(Ty<'tcx>),\n-}\n-\n /// Boolean flag used to indicate if this search is for a suggestion\n /// or not.  If true, we can allow ambiguity and so forth.\n pub struct IsSuggestion(pub bool);\n@@ -49,9 +40,9 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    looking_for: LookingFor<'tcx>,\n+    method_name: Option<ast::Name>,\n+    return_type: Option<Ty<'tcx>>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n-    opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: FxHashSet<DefId>,\n@@ -85,6 +76,7 @@ struct CandidateStep<'tcx> {\n #[derive(Debug)]\n struct Candidate<'tcx> {\n     xform_self_ty: Ty<'tcx>,\n+    xform_ret_ty: Option<Ty<'tcx>>,\n     item: ty::AssociatedItem,\n     kind: CandidateKind<'tcx>,\n     import_id: Option<ast::NodeId>,\n@@ -95,17 +87,19 @@ enum CandidateKind<'tcx> {\n     InherentImplCandidate(&'tcx Substs<'tcx>,\n                           // Normalize obligations\n                           Vec<traits::PredicateObligation<'tcx>>),\n-    ExtensionImplCandidate(// Impl\n-                           DefId,\n-                           &'tcx Substs<'tcx>,\n-                           // Normalize obligations\n-                           Vec<traits::PredicateObligation<'tcx>>),\n     ObjectCandidate,\n-    TraitCandidate,\n+    TraitCandidate(ty::TraitRef<'tcx>),\n     WhereClauseCandidate(// Trait\n                          ty::PolyTraitRef<'tcx>),\n }\n \n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum ProbeResult {\n+    NoMatch,\n+    BadReturnType,\n+    Match,\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n@@ -133,8 +127,6 @@ pub struct Pick<'tcx> {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n-    ExtensionImplPick(// Impl\n-                      DefId),\n     ObjectPick,\n     TraitPick,\n     WhereClausePick(// Trait\n@@ -183,19 +175,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                return_type,\n                scope_expr_id);\n         let method_names =\n-            self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n+            self.probe_op(span, mode, None, Some(return_type), IsSuggestion(true),\n                           self_ty, scope_expr_id, ProbeScope::TraitsInScope,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n-        method_names\n-            .iter()\n-            .flat_map(|&method_name| {\n-                match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n-                                          scope_expr_id, ProbeScope::TraitsInScope) {\n-                    Ok(pick) => Some(pick.item),\n-                    Err(_) => None,\n-                }\n-            })\n+         method_names\n+             .iter()\n+             .flat_map(|&method_name| {\n+                 self.probe_op(\n+                     span, mode, Some(method_name), Some(return_type),\n+                     IsSuggestion(true), self_ty, scope_expr_id,\n+                     ProbeScope::TraitsInScope, |probe_cx| probe_cx.pick()\n+                 ).ok().map(|pick| pick.item)\n+             })\n             .collect()\n     }\n \n@@ -214,7 +206,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                scope_expr_id);\n         self.probe_op(span,\n                       mode,\n-                      LookingFor::MethodName(item_name),\n+                      Some(item_name),\n+                      None,\n                       is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n@@ -225,7 +218,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn probe_op<OP,R>(&'a self,\n                       span: Span,\n                       mode: Mode,\n-                      looking_for: LookingFor<'tcx>,\n+                      method_name: Option<ast::Name>,\n+                      return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n@@ -259,24 +253,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                  }]\n         };\n \n-        // Create a list of simplified self types, if we can.\n-        let mut simplified_steps = Vec::new();\n-        for step in &steps {\n-            match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n-                None => {\n-                    break;\n-                }\n-                Some(simplified_type) => {\n-                    simplified_steps.push(simplified_type);\n-                }\n-            }\n-        }\n-        let opt_simplified_steps = if simplified_steps.len() < steps.len() {\n-            None // failed to convert at least one of the steps\n-        } else {\n-            Some(simplified_steps)\n-        };\n-\n         debug!(\"ProbeContext: steps for self_ty={:?} are {:?}\",\n                self_ty,\n                steps);\n@@ -285,8 +261,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // that we create during the probe process are removed later\n         self.probe(|_| {\n             let mut probe_cx =\n-                ProbeContext::new(self, span, mode, looking_for,\n-                                  steps, opt_simplified_steps);\n+                ProbeContext::new(self, span, mode, method_name, return_type, steps);\n \n             probe_cx.assemble_inherent_candidates();\n             match scope {\n@@ -356,20 +331,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           looking_for: LookingFor<'tcx>,\n-           steps: Vec<CandidateStep<'tcx>>,\n-           opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n+           method_name: Option<ast::Name>,\n+           return_type: Option<Ty<'tcx>>,\n+           steps: Vec<CandidateStep<'tcx>>)\n            -> ProbeContext<'a, 'gcx, 'tcx> {\n         ProbeContext {\n             fcx,\n             span,\n             mode,\n-            looking_for,\n+            method_name,\n+            return_type,\n             inherent_candidates: Vec::new(),\n             extension_candidates: Vec::new(),\n             impl_dups: FxHashSet(),\n             steps: Rc::new(steps),\n-            opt_simplified_steps,\n             static_candidates: Vec::new(),\n             private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n@@ -387,33 +362,25 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n \n-    fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n-                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n-            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n-            item.vis.is_accessible_from(def_scope, self.tcx)\n-        } else {\n-            true\n-        };\n-        if is_accessible {\n-            self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n-        } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(item.def());\n-        }\n-    }\n-\n-    fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n-                               kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+    fn push_candidate(&mut self,\n+                      candidate: Candidate<'tcx>,\n+                      is_inherent: bool)\n+    {\n+        let is_accessible = if let Some(name) = self.method_name {\n+            let item = candidate.item;\n             let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true\n         };\n         if is_accessible {\n-            self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n+            if is_inherent {\n+                self.inherent_candidates.push(candidate);\n+            } else {\n+                self.extension_candidates.push(candidate);\n+            }\n         } else if self.private_candidate.is_none() {\n-            self.private_candidate = Some(item.def());\n+            self.private_candidate = Some(candidate.item.def());\n         }\n     }\n \n@@ -551,19 +518,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n \n             // Determine the receiver type that the method itself expects.\n-            let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n+            let xform_tys = self.xform_self_ty(&item, impl_ty, impl_substs);\n \n             // We can't use normalize_associated_types_in as it will pollute the\n             // fcx's fulfillment context after this probe is over.\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n             let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n-            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-                   xform_self_ty);\n-\n-            self.push_inherent_candidate(xform_self_ty, item,\n-                                         InherentImplCandidate(impl_substs, obligations), None);\n+            let traits::Normalized { value: (xform_self_ty, xform_ret_ty), obligations } =\n+                traits::normalize(selcx, self.param_env, cause, &xform_tys);\n+            debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}/{:?}\",\n+                   xform_self_ty, xform_ret_ty);\n+\n+            self.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: InherentImplCandidate(impl_substs, obligations),\n+                import_id: None\n+            }, true);\n         }\n     }\n \n@@ -584,10 +554,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n-            let xform_self_ty =\n+            let (xform_self_ty, xform_ret_ty) =\n                 this.xform_self_ty(&item, new_trait_ref.self_ty(), new_trait_ref.substs);\n-\n-            this.push_inherent_candidate(xform_self_ty, item, ObjectCandidate, None);\n+            this.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: ObjectCandidate,\n+                import_id: None\n+            }, true);\n         });\n     }\n \n@@ -624,7 +597,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         self.elaborate_bounds(&bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);\n \n-            let xform_self_ty = this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n+            let (xform_self_ty, xform_ret_ty) =\n+                this.xform_self_ty(&item, trait_ref.self_ty(), trait_ref.substs);\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n@@ -633,8 +607,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             // `WhereClausePick`.\n             assert!(!trait_ref.substs.needs_infer());\n \n-            this.push_inherent_candidate(xform_self_ty, item,\n-                                         WhereClauseCandidate(poly_trait_ref), None);\n+            this.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item,\n+                kind: WhereClauseCandidate(poly_trait_ref),\n+                import_id: None\n+            }, true);\n         });\n     }\n \n@@ -687,17 +664,27 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn matches_return_type(&self, method: &ty::AssociatedItem,\n-                               expected: ty::Ty<'tcx>) -> bool {\n+    pub fn matches_return_type(&self,\n+                               method: &ty::AssociatedItem,\n+                               self_ty: Option<Ty<'tcx>>,\n+                               expected: Ty<'tcx>) -> bool {\n         match method.def() {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n-                    let output = fty.output().subst(self.tcx, substs);\n-                    let (output, _) = self.replace_late_bound_regions_with_fresh_var(\n-                        self.span, infer::FnCall, &output);\n-                    self.can_sub(self.param_env, output, expected).is_ok()\n+                    let fty = fty.subst(self.tcx, substs);\n+                    let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n+                        self.span, infer::FnCall, &fty);\n+\n+                    if let Some(self_ty) = self_ty {\n+                        if let Err(_) = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .sup(fty.inputs()[0], self_ty)\n+                        {\n+                            return false\n+                        }\n+                    }\n+                    self.can_sub(self.param_env, fty.output(), expected).is_ok()\n                 })\n             }\n             _ => false,\n@@ -710,6 +697,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                                -> Result<(), MethodError<'tcx>> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n+        let trait_substs = self.fresh_item_substs(trait_def_id);\n+        let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n \n         for item in self.impl_or_trait_item(trait_def_id) {\n             // Check whether `trait_def_id` defines a method with suitable name:\n@@ -719,326 +708,31 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            self.assemble_builtin_candidates(import_id, trait_def_id, item.clone());\n-\n-            self.assemble_extension_candidates_for_trait_impls(import_id, trait_def_id,\n-                                                               item.clone());\n-\n-            self.assemble_closure_candidates(import_id, trait_def_id, item.clone())?;\n-\n-            self.assemble_generator_candidates(import_id, trait_def_id, item.clone())?;\n-\n-            self.assemble_projection_candidates(import_id, trait_def_id, item.clone());\n-\n-            self.assemble_where_clause_candidates(import_id, trait_def_id, item.clone());\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_builtin_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem) {\n-        if Some(trait_def_id) == self.tcx.lang_items.clone_trait() {\n-            self.assemble_builtin_clone_candidates(import_id, trait_def_id, item);\n-        }\n-    }\n-\n-    fn assemble_builtin_clone_candidates(&mut self,\n-                                         import_id: Option<ast::NodeId>,\n-                                         trait_def_id: DefId,\n-                                         item: ty::AssociatedItem) {\n-        for step in Rc::clone(&self.steps).iter() {\n-            match step.self_ty.sty {\n-                ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n-                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-                ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n-                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) |\n-                ty::TyArray(..) | ty::TyTuple(..) => {\n-                    ()\n-                }\n-\n-                _ => continue,\n-            };\n-\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-        }\n-    }\n-\n-    fn assemble_extension_candidates_for_trait_impls(&mut self,\n-                                                     import_id: Option<ast::NodeId>,\n-                                                     trait_def_id: DefId,\n-                                                     item: ty::AssociatedItem) {\n-        // FIXME(arielb1): can we use for_each_relevant_impl here?\n-        self.tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-            debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n-                                                                  impl_def_id={:?}\",\n-                   trait_def_id,\n-                   impl_def_id);\n-\n-            if !self.impl_can_possibly_match(impl_def_id) {\n-                return;\n-            }\n-\n-            let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-\n-            debug!(\"impl_substs={:?}\", impl_substs);\n-\n-            let impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id)\n-                .unwrap() // we know this is a trait impl\n-                .subst(self.tcx, impl_substs);\n-\n-            debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n-\n-            // Determine the receiver type that the method itself expects.\n-            let xform_self_ty =\n-                self.xform_self_ty(&item, impl_trait_ref.self_ty(), impl_trait_ref.substs);\n-\n-            // Normalize the receiver. We can't use normalize_associated_types_in\n-            // as it will pollute the fcx's fulfillment context after this probe\n-            // is over.\n-            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-            let selcx = &mut traits::SelectionContext::new(self.fcx);\n-            let traits::Normalized { value: xform_self_ty, obligations } =\n-                traits::normalize(selcx, self.param_env, cause, &xform_self_ty);\n-\n-            debug!(\"xform_self_ty={:?}\", xform_self_ty);\n-\n-            self.push_extension_candidate(xform_self_ty, item,\n-                        ExtensionImplCandidate(impl_def_id, impl_substs, obligations), import_id);\n-        });\n-    }\n-\n-    fn impl_can_possibly_match(&self, impl_def_id: DefId) -> bool {\n-        let simplified_steps = match self.opt_simplified_steps {\n-            Some(ref simplified_steps) => simplified_steps,\n-            None => {\n-                return true;\n-            }\n-        };\n-\n-        let impl_type = self.tcx.type_of(impl_def_id);\n-        let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx, impl_type, false) {\n-                Some(simplified_type) => simplified_type,\n-                None => {\n-                    return true;\n-                }\n-            };\n-\n-        simplified_steps.contains(&impl_simplified_type)\n-    }\n-\n-    fn assemble_closure_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem)\n-                                   -> Result<(), MethodError<'tcx>> {\n-        // Check if this is one of the Fn,FnMut,FnOnce traits.\n-        let tcx = self.tcx;\n-        let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            ty::ClosureKind::Fn\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            ty::ClosureKind::FnMut\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            ty::ClosureKind::FnOnce\n-        } else {\n-            return Ok(());\n-        };\n-\n-        // Check if there is an unboxed-closure self-type in the list of receivers.\n-        // If so, add \"synthetic impls\".\n-        let steps = self.steps.clone();\n-        for step in steps.iter() {\n-            let closure_id = match step.self_ty.sty {\n-                ty::TyClosure(def_id, _) => {\n-                    if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        self.tcx.hir.node_to_hir_id(id)\n-                    } else {\n-                        continue;\n-                    }\n-                }\n-                _ => continue,\n-            };\n-\n-            let closure_kind = {\n-                match self.tables.borrow().closure_kinds().get(closure_id) {\n-                    Some(&(k, _)) => k,\n-                    None => {\n-                        return Err(MethodError::ClosureAmbiguity(trait_def_id));\n-                    }\n-                }\n-            };\n-\n-            // this closure doesn't implement the right kind of `Fn` trait\n-            if !closure_kind.extends(kind) {\n-                continue;\n-            }\n-\n-            // create some substitutions for the argument/return type;\n-            // for the purposes of our method lookup, we only take\n-            // receiver type into account, so we can just substitute\n-            // fresh types here to use during substitution and subtyping.\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn assemble_generator_candidates(&mut self,\n-                                   import_id: Option<ast::NodeId>,\n-                                   trait_def_id: DefId,\n-                                   item: ty::AssociatedItem)\n-                                   -> Result<(), MethodError<'tcx>> {\n-        // Check if this is the Generator trait.\n-        let tcx = self.tcx;\n-        if Some(trait_def_id) != tcx.lang_items.gen_trait() {\n-            return Ok(());\n-        }\n-\n-        // Check if there is an generator self-type in the list of receivers.\n-        // If so, add \"synthetic impls\".\n-        let steps = self.steps.clone();\n-        for step in steps.iter() {\n-            match step.self_ty.sty {\n-                ty::TyGenerator(..) => (),\n-                _ => continue,\n-            };\n-\n-            // create some substitutions for the argument/return type;\n-            // for the purposes of our method lookup, we only take\n-            // receiver type into account, so we can just substitute\n-            // fresh types here to use during substitution and subtyping.\n-            let substs = Substs::for_item(self.tcx,\n-                                          trait_def_id,\n-                                          |def, _| self.region_var_for_def(self.span, def),\n-                                          |def, substs| {\n-                if def.index == 0 {\n-                    step.self_ty\n-                } else {\n-                    self.type_var_for_def(self.span, def, substs)\n-                }\n-            });\n-\n-            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n-            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+            let (xform_self_ty, xform_ret_ty) =\n+                self.xform_self_ty(&item, trait_ref.self_ty(), trait_substs);\n+            self.push_candidate(Candidate {\n+                xform_self_ty, xform_ret_ty, item, import_id,\n+                kind: TraitCandidate(trait_ref),\n+            }, false);\n         }\n-\n         Ok(())\n     }\n \n-    fn assemble_projection_candidates(&mut self,\n-                                      import_id: Option<ast::NodeId>,\n-                                      trait_def_id: DefId,\n-                                      item: ty::AssociatedItem) {\n-        debug!(\"assemble_projection_candidates(\\\n-               trait_def_id={:?}, \\\n-               item={:?})\",\n-               trait_def_id,\n-               item);\n-\n-        for step in Rc::clone(&self.steps).iter() {\n-            debug!(\"assemble_projection_candidates: step={:?}\", step);\n-\n-            let (def_id, substs) = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => {\n-                    let trait_ref = data.trait_ref(self.tcx);\n-                    (trait_ref.def_id, trait_ref.substs)\n-                },\n-                ty::TyAnon(def_id, substs) => (def_id, substs),\n-                _ => continue,\n-            };\n-\n-            debug!(\"assemble_projection_candidates: def_id={:?} substs={:?}\",\n-                   def_id,\n-                   substs);\n-\n-            let trait_predicates = self.tcx.predicates_of(def_id);\n-            let bounds = trait_predicates.instantiate(self.tcx, substs);\n-            let predicates = bounds.predicates;\n-            debug!(\"assemble_projection_candidates: predicates={:?}\",\n-                   predicates);\n-            for poly_bound in traits::elaborate_predicates(self.tcx, predicates)\n-                .filter_map(|p| p.to_opt_poly_trait_ref())\n-                .filter(|b| b.def_id() == trait_def_id) {\n-                let bound = self.erase_late_bound_regions(&poly_bound);\n-\n-                debug!(\"assemble_projection_candidates: def_id={:?} substs={:?} bound={:?}\",\n-                       def_id,\n-                       substs,\n-                       bound);\n-\n-                if self.can_eq(self.param_env, step.self_ty, bound.self_ty()).is_ok() {\n-                    let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n-\n-                    debug!(\"assemble_projection_candidates: bound={:?} xform_self_ty={:?}\",\n-                           bound,\n-                           xform_self_ty);\n-\n-                    self.push_extension_candidate(xform_self_ty, item, TraitCandidate, import_id);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn assemble_where_clause_candidates(&mut self,\n-                                        import_id: Option<ast::NodeId>,\n-                                        trait_def_id: DefId,\n-                                        item: ty::AssociatedItem) {\n-        debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n-               trait_def_id);\n-\n-        let caller_predicates = self.param_env.caller_bounds.to_vec();\n-        for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n-            .filter_map(|p| p.to_opt_poly_trait_ref())\n-            .filter(|b| b.def_id() == trait_def_id) {\n-            let bound = self.erase_late_bound_regions(&poly_bound);\n-            let xform_self_ty = self.xform_self_ty(&item, bound.self_ty(), bound.substs);\n-\n-            debug!(\"assemble_where_clause_candidates: bound={:?} xform_self_ty={:?}\",\n-                   bound,\n-                   xform_self_ty);\n-\n-            self.push_extension_candidate(xform_self_ty, item,\n-                                          WhereClauseCandidate(poly_bound), import_id);\n-        }\n-    }\n-\n     fn candidate_method_names(&self) -> Vec<ast::Name> {\n         let mut set = FxHashSet();\n-        let mut names: Vec<_> =\n-            self.inherent_candidates\n-                .iter()\n-                .chain(&self.extension_candidates)\n-                .map(|candidate| candidate.item.name)\n-                .filter(|&name| set.insert(name))\n-                .collect();\n+        let mut names: Vec<_> = self.inherent_candidates\n+            .iter()\n+            .chain(&self.extension_candidates)\n+            .filter(|candidate| {\n+                if let Some(return_ty) = self.return_type {\n+                    self.matches_return_type(&candidate.item, None, return_ty)\n+                } else {\n+                    true\n+                }\n+            })\n+            .map(|candidate| candidate.item.name)\n+            .filter(|&name| set.insert(name))\n+            .collect();\n \n         // sort them by the name so we have a stable result\n         names.sort_by_key(|n| n.as_str());\n@@ -1049,10 +743,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n-        assert!(match self.looking_for {\n-            LookingFor::MethodName(_) => true,\n-            LookingFor::ReturnType(_) => false,\n-        });\n+        assert!(self.method_name.is_some());\n \n         if let Some(r) = self.pick_core() {\n             return r;\n@@ -1095,10 +786,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n-            Some(Err(MethodError::ClosureAmbiguity(..))) => {\n-                // this error only occurs when assembling candidates\n-                span_bug!(span, \"encountered ClosureAmbiguity from pick_core\");\n-            }\n             _ => vec![],\n         };\n \n@@ -1116,21 +803,17 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let steps = self.steps.clone();\n \n         // find the first step that works\n-        steps.iter().filter_map(|step| self.pick_step(step)).next()\n-    }\n-\n-    fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_step: step={:?}\", step);\n-\n-        if step.self_ty.references_error() {\n-            return None;\n-        }\n-\n-        if let Some(result) = self.pick_by_value_method(step) {\n-            return Some(result);\n-        }\n-\n-        self.pick_autorefd_method(step)\n+        steps\n+            .iter()\n+            .filter(|step| {\n+                debug!(\"pick_core: step={:?}\", step);\n+                !step.self_ty.references_error()\n+            }).flat_map(|step| {\n+                self.pick_by_value_method(step).or_else(|| {\n+                self.pick_autorefd_method(step, hir::MutImmutable).or_else(|| {\n+                self.pick_autorefd_method(step, hir::MutMutable)\n+            })})})\n+            .next()\n     }\n \n     fn pick_by_value_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1161,36 +844,30 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn pick_autorefd_method(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n+    fn pick_autorefd_method(&mut self, step: &CandidateStep<'tcx>, mutbl: hir::Mutability)\n+                            -> Option<PickResult<'tcx>> {\n         let tcx = self.tcx;\n \n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n         let region = tcx.types.re_erased;\n \n-        // Search through mutabilities in order to find one where pick works:\n-        [hir::MutImmutable, hir::MutMutable]\n-            .iter()\n-            .filter_map(|&m| {\n-                let autoref_ty = tcx.mk_ref(region,\n-                                            ty::TypeAndMut {\n-                                                ty: step.self_ty,\n-                                                mutbl: m,\n-                                            });\n-                self.pick_method(autoref_ty).map(|r| {\n-                    r.map(|mut pick| {\n-                        pick.autoderefs = step.autoderefs;\n-                        pick.autoref = Some(m);\n-                        pick.unsize = if step.unsize {\n-                            Some(step.self_ty)\n-                        } else {\n-                            None\n-                        };\n-                        pick\n-                    })\n-                })\n+        let autoref_ty = tcx.mk_ref(region,\n+                                    ty::TypeAndMut {\n+                                        ty: step.self_ty, mutbl\n+                                    });\n+        self.pick_method(autoref_ty).map(|r| {\n+            r.map(|mut pick| {\n+                pick.autoderefs = step.autoderefs;\n+                pick.autoref = Some(mutbl);\n+                pick.unsize = if step.unsize {\n+                    Some(step.self_ty)\n+                } else {\n+                    None\n+                };\n+                pick\n             })\n-            .nth(0)\n+        })\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n@@ -1221,7 +898,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                            possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n         let mut applicable_candidates: Vec<_> = probes.iter()\n-            .filter(|&probe| self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n+            .map(|probe| {\n+                (probe, self.consider_probe(self_ty, probe, possibly_unsatisfied_predicates))\n+            })\n+            .filter(|&(_, status)| status != ProbeResult::NoMatch)\n             .collect();\n \n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n@@ -1236,18 +916,60 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         if applicable_candidates.len() > 1 {\n-            let sources = probes.iter().map(|p| p.to_source()).collect();\n+            let sources = probes.iter()\n+                .map(|p| self.candidate_source(p, self_ty))\n+                .collect();\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|probe| Ok(probe.to_unadjusted_pick()))\n+        applicable_candidates.pop().map(|(probe, status)| {\n+            if status == ProbeResult::Match {\n+                Ok(probe.to_unadjusted_pick())\n+            } else {\n+                Err(MethodError::BadReturnType)\n+            }\n+        })\n+    }\n+\n+    fn select_trait_candidate(&self, trait_ref: ty::TraitRef<'tcx>)\n+                              -> traits::SelectionResult<'tcx, traits::Selection<'tcx>>\n+    {\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+        let predicate =\n+            trait_ref.to_poly_trait_ref().to_poly_trait_predicate();\n+        let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n+        traits::SelectionContext::new(self).select(&obligation)\n+    }\n+\n+    fn candidate_source(&self, candidate: &Candidate<'tcx>, self_ty: Ty<'tcx>)\n+                        -> CandidateSource\n+    {\n+        match candidate.kind {\n+            InherentImplCandidate(..) => ImplSource(candidate.item.container.id()),\n+            ObjectCandidate |\n+            WhereClauseCandidate(_) => TraitSource(candidate.item.container.id()),\n+            TraitCandidate(trait_ref) => self.probe(|_| {\n+                let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                    .sup(candidate.xform_self_ty, self_ty);\n+                match self.select_trait_candidate(trait_ref) {\n+                    Ok(Some(traits::Vtable::VtableImpl(ref impl_data))) => {\n+                        // If only a single impl matches, make the error message point\n+                        // to that impl.\n+                        ImplSource(impl_data.impl_def_id)\n+                    }\n+                    _ => {\n+                        TraitSource(candidate.item.container.id())\n+                    }\n+                }\n+            })\n+        }\n     }\n \n     fn consider_probe(&self,\n                       self_ty: Ty<'tcx>,\n                       probe: &Candidate<'tcx>,\n                       possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n-                      -> bool {\n+                      -> ProbeResult {\n         debug!(\"consider_probe: self_ty={:?} probe={:?}\", self_ty, probe);\n \n         self.probe(|_| {\n@@ -1257,60 +979,102 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");\n-                    return false;\n+                    return ProbeResult::NoMatch;\n                 }\n             };\n \n+            let mut result = ProbeResult::Match;\n+            let selcx = &mut traits::SelectionContext::new(self);\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+\n             // If so, impls may carry other conditions (e.g., where\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n-            let (impl_def_id, substs, ref_obligations) = match probe.kind {\n+            let candidate_obligations : Vec<_> = match probe.kind {\n                 InherentImplCandidate(ref substs, ref ref_obligations) => {\n-                    (probe.item.container.id(), substs, ref_obligations)\n-                }\n-\n-                ExtensionImplCandidate(impl_def_id, ref substs, ref ref_obligations) => {\n-                    (impl_def_id, substs, ref_obligations)\n+                    // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_def_id = probe.item.container.id();\n+                    let impl_bounds = self.tcx.predicates_of(impl_def_id);\n+                    let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n+                    let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n+                        traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n+\n+                    // Convert the bounds into obligations.\n+                    let impl_obligations = traits::predicates_for_generics(\n+                        cause.clone(), self.param_env, &impl_bounds);\n+\n+                    debug!(\"impl_obligations={:?}\", impl_obligations);\n+                    impl_obligations.into_iter()\n+                        .chain(norm_obligations.into_iter())\n+                        .chain(ref_obligations.iter().cloned())\n+                        .collect()\n                 }\n \n                 ObjectCandidate |\n-                TraitCandidate |\n                 WhereClauseCandidate(..) => {\n                     // These have no additional conditions to check.\n-                    return true;\n+                    vec![]\n                 }\n-            };\n \n-            let selcx = &mut traits::SelectionContext::new(self);\n-            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n-            // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx.predicates_of(impl_def_id);\n-            let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n-            let traits::Normalized { value: impl_bounds, obligations: norm_obligations } =\n-                traits::normalize(selcx, self.param_env, cause.clone(), &impl_bounds);\n+                TraitCandidate(trait_ref) => {\n+                    let predicate = trait_ref.to_predicate();\n+                    let obligation =\n+                        traits::Obligation::new(cause.clone(), self.param_env, predicate);\n+                    if !selcx.evaluate_obligation(&obligation) {\n+                        if self.probe(|_| self.select_trait_candidate(trait_ref).is_err()) {\n+                            // This candidate's primary obligation doesn't even\n+                            // select - don't bother registering anything in\n+                            // `potentially_unsatisfied_predicates`.\n+                            return ProbeResult::NoMatch;\n+                        } else {\n+                            // Some nested subobligation of this predicate\n+                            // failed.\n+                            //\n+                            // FIXME: try to find the exact nested subobligation\n+                            // and point at it rather than reporting the entire\n+                            // trait-ref?\n+                            result = ProbeResult::NoMatch;\n+                            let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                            possibly_unsatisfied_predicates.push(trait_ref);\n+                        }\n+                    }\n+                    vec![]\n+                }\n+            };\n \n-            // Convert the bounds into obligations.\n-            let obligations = traits::predicates_for_generics(cause.clone(),\n-                                                              self.param_env,\n-                                                              &impl_bounds);\n-            debug!(\"impl_obligations={:?}\", obligations);\n+            debug!(\"consider_probe - candidate_obligations={:?} sub_obligations={:?}\",\n+                   candidate_obligations, sub_obligations);\n \n             // Evaluate those obligations to see if they might possibly hold.\n-            let mut all_true = true;\n-            for o in obligations.iter()\n-                .chain(sub_obligations.iter())\n-                .chain(norm_obligations.iter())\n-                .chain(ref_obligations.iter()) {\n-                if !selcx.evaluate_obligation(o) {\n-                    all_true = false;\n+            for o in candidate_obligations.into_iter().chain(sub_obligations) {\n+                let o = self.resolve_type_vars_if_possible(&o);\n+                if !selcx.evaluate_obligation(&o) {\n+                    result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n                         possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n                     }\n                 }\n             }\n-            all_true\n+\n+            if let ProbeResult::Match = result {\n+                if let (Some(return_ty), Some(xform_ret_ty)) =\n+                    (self.return_type, probe.xform_ret_ty)\n+                {\n+                    let xform_ret_ty = self.resolve_type_vars_if_possible(&xform_ret_ty);\n+                    debug!(\"comparing return_ty {:?} with xform ret ty {:?}\",\n+                           return_ty,\n+                           probe.xform_ret_ty);\n+                    if self.at(&ObligationCause::dummy(), self.param_env)\n+                        .sup(return_ty, xform_ret_ty)\n+                        .is_err()\n+                    {\n+                        return ProbeResult::BadReturnType;\n+                    }\n+                }\n+            }\n+\n+            result\n         })\n     }\n \n@@ -1331,22 +1095,25 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     ///\n     /// Now imagine the receiver is `Vec<_>`. It doesn't really matter at this time which impl we\n     /// use, so it's ok to just commit to \"using the method from the trait Foo\".\n-    fn collapse_candidates_to_trait_pick(&self, probes: &[&Candidate<'tcx>]) -> Option<Pick<'tcx>> {\n+    fn collapse_candidates_to_trait_pick(&self, probes: &[(&Candidate<'tcx>, ProbeResult)])\n+                                         -> Option<Pick<'tcx>>\n+    {\n         // Do all probes correspond to the same trait?\n-        let container = probes[0].item.container;\n+        let container = probes[0].0.item.container;\n         match container {\n             ty::TraitContainer(_) => {}\n             ty::ImplContainer(_) => return None,\n         }\n-        if probes[1..].iter().any(|p| p.item.container != container) {\n+        if probes[1..].iter().any(|&(p, _)| p.item.container != container) {\n             return None;\n         }\n \n+        // FIXME: check the return type here somehow.\n         // If so, just use this trait and call it a day.\n         Some(Pick {\n-            item: probes[0].item.clone(),\n+            item: probes[0].0.item.clone(),\n             kind: TraitPick,\n-            import_id: probes[0].import_id,\n+            import_id: probes[0].0.import_id,\n             autoderefs: 0,\n             autoref: None,\n             unsize: None,\n@@ -1384,23 +1151,23 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                      item: &ty::AssociatedItem,\n                      impl_ty: Ty<'tcx>,\n                      substs: &Substs<'tcx>)\n-                     -> Ty<'tcx> {\n+                     -> (Ty<'tcx>, Option<Ty<'tcx>>) {\n         if item.kind == ty::AssociatedKind::Method && self.mode == Mode::MethodCall {\n-            self.xform_method_self_ty(item.def_id, impl_ty, substs)\n+            let sig = self.xform_method_sig(item.def_id, substs);\n+            (sig.inputs()[0], Some(sig.output()))\n         } else {\n-            impl_ty\n+            (impl_ty, None)\n         }\n     }\n \n-    fn xform_method_self_ty(&self,\n-                            method: DefId,\n-                            impl_ty: Ty<'tcx>,\n-                            substs: &Substs<'tcx>)\n-                            -> Ty<'tcx> {\n-        let self_ty = self.tcx.fn_sig(method).input(0);\n-        debug!(\"xform_self_ty(impl_ty={:?}, self_ty={:?}, substs={:?})\",\n-               impl_ty,\n-               self_ty,\n+    fn xform_method_sig(&self,\n+                        method: DefId,\n+                        substs: &Substs<'tcx>)\n+                        -> ty::FnSig<'tcx>\n+    {\n+        let fn_sig = self.tcx.fn_sig(method);\n+        debug!(\"xform_self_ty(fn_sig={:?}, substs={:?})\",\n+               fn_sig,\n                substs);\n \n         assert!(!substs.has_escaping_regions());\n@@ -1416,10 +1183,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         // Erase any late-bound regions from the method and substitute\n         // in the values from the substitution.\n-        let xform_self_ty = self.erase_late_bound_regions(&self_ty);\n+        let xform_fn_sig = self.erase_late_bound_regions(&fn_sig);\n \n         if generics.types.is_empty() && generics.regions.is_empty() {\n-            xform_self_ty.subst(self.tcx, substs)\n+            xform_fn_sig.subst(self.tcx, substs)\n         } else {\n             let substs = Substs::for_item(self.tcx, method, |def, _| {\n                 let i = def.index as usize;\n@@ -1438,22 +1205,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     self.type_var_for_def(self.span, def, cur_substs)\n                 }\n             });\n-            xform_self_ty.subst(self.tcx, substs)\n+            xform_fn_sig.subst(self.tcx, substs)\n         }\n     }\n \n     /// Get the type of an impl and generate substitutions with placeholders.\n     fn impl_ty_and_substs(&self, impl_def_id: DefId) -> (Ty<'tcx>, &'tcx Substs<'tcx>) {\n-        let impl_ty = self.tcx.type_of(impl_def_id);\n-\n-        let substs = Substs::for_item(self.tcx,\n-                                      impl_def_id,\n-                                      |_, _| self.tcx.types.re_erased,\n-                                      |_, _| self.next_ty_var(\n-                                        TypeVariableOrigin::SubstitutionPlaceholder(\n-                                            self.tcx.def_span(impl_def_id))));\n+        (self.tcx.type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n+    }\n \n-        (impl_ty, substs)\n+    fn fresh_item_substs(&self, def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx,\n+                         def_id,\n+                         |_, _| self.tcx.types.re_erased,\n+                         |_, _| self.next_ty_var(\n+                             TypeVariableOrigin::SubstitutionPlaceholder(\n+                                 self.tcx.def_span(def_id))))\n     }\n \n     /// Replace late-bound-regions bound by `value` with `'static` using\n@@ -1482,17 +1249,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     /// Find the method with the appropriate name (or return type, as the case may be).\n     fn impl_or_trait_item(&self, def_id: DefId) -> Vec<ty::AssociatedItem> {\n-        match self.looking_for {\n-            LookingFor::MethodName(name) => {\n-                self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n-            }\n-            LookingFor::ReturnType(return_ty) => {\n-                self.tcx\n-                    .associated_items(def_id)\n-                    .map(|did| self.tcx.associated_item(did.def_id))\n-                    .filter(|m| self.matches_return_type(m, return_ty))\n-                    .collect()\n-            }\n+        if let Some(name) = self.method_name {\n+            self.fcx.associated_item(def_id, name).map_or(Vec::new(), |x| vec![x])\n+        } else {\n+            self.tcx.associated_items(def_id).collect()\n         }\n     }\n }\n@@ -1503,9 +1263,8 @@ impl<'tcx> Candidate<'tcx> {\n             item: self.item.clone(),\n             kind: match self.kind {\n                 InherentImplCandidate(..) => InherentImplPick,\n-                ExtensionImplCandidate(def_id, ..) => ExtensionImplPick(def_id),\n                 ObjectCandidate => ObjectPick,\n-                TraitCandidate => TraitPick,\n+                TraitCandidate(_) => TraitPick,\n                 WhereClauseCandidate(ref trait_ref) => {\n                     // Only trait derived from where-clauses should\n                     // appear here, so they should not contain any\n@@ -1523,14 +1282,4 @@ impl<'tcx> Candidate<'tcx> {\n             unsize: None,\n         }\n     }\n-\n-    fn to_source(&self) -> CandidateSource {\n-        match self.kind {\n-            InherentImplCandidate(..) => ImplSource(self.item.container.id()),\n-            ExtensionImplCandidate(def_id, ..) => ImplSource(def_id),\n-            ObjectCandidate |\n-            TraitCandidate |\n-            WhereClauseCandidate(_) => TraitSource(self.item.container.id()),\n-        }\n-    }\n }"}, {"sha": "f2d7842e473f61df3e943edf823badbbc8d3f147", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -296,22 +296,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.emit();\n             }\n \n-            MethodError::ClosureAmbiguity(trait_def_id) => {\n-                let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n-                                   invoked on this closure as we have not yet inferred what \\\n-                                   kind of closure it is\",\n-                                  item_name,\n-                                  self.tcx.item_path_str(trait_def_id));\n-                let msg = if let Some(callee) = rcvr_expr {\n-                    format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n-                            msg,\n-                            self.tcx.hir.node_to_pretty_string(callee.id))\n-                } else {\n-                    msg\n-                };\n-                self.sess().span_err(span, &msg);\n-            }\n-\n             MethodError::PrivateMatch(def, out_of_scope_traits) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0624,\n                                                \"{} `{}` is private\", def.kind_name(), item_name);\n@@ -337,6 +321,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 err.emit();\n             }\n+\n+            MethodError::BadReturnType => {\n+                bug!(\"no return type expectations but got BadReturnType\")\n+            }\n         }\n     }\n "}, {"sha": "e937770bb016135413130aa0a521420987593fc6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -2818,6 +2818,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            formal_ret: Ty<'tcx>,\n                                            formal_args: &[Ty<'tcx>])\n                                            -> Vec<Ty<'tcx>> {\n+        let formal_ret = self.resolve_type_vars_with_obligations(formal_ret);\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n             self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n@@ -3978,6 +3979,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprTup(ref elts) => {\n             let flds = expected.only_has_type(self).and_then(|ty| {\n+                let ty = self.resolve_type_vars_with_obligations(ty);\n                 match ty.sty {\n                     ty::TyTuple(ref flds, _) => Some(&flds[..]),\n                     _ => None"}, {"sha": "76b8cf92329d1ccc6446442f31e3b40dbb6cd6c5", "filename": "src/test/run-pass/method-argument-inference-associated-type.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Frun-pass%2Fmethod-argument-inference-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Frun-pass%2Fmethod-argument-inference-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-argument-inference-associated-type.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct ClientMap;\n+pub struct ClientMap2;\n+\n+pub trait Service {\n+    type Request;\n+    fn call(&self, _req: Self::Request);\n+}\n+\n+pub struct S<T>(T);\n+\n+impl Service for ClientMap {\n+    type Request = S<Box<Fn(i32)>>;\n+    fn call(&self, _req: Self::Request) {}\n+}\n+\n+\n+impl Service for ClientMap2 {\n+    type Request = (Box<Fn(i32)>,);\n+    fn call(&self, _req: Self::Request) {}\n+}\n+\n+\n+fn main() {\n+    ClientMap.call(S { 0: Box::new(|_msgid| ()) });\n+    ClientMap.call(S(Box::new(|_msgid| ())));\n+    ClientMap2.call((Box::new(|_msgid| ()),));\n+}"}, {"sha": "028f2e9375b3cf8caad48aeb44d67d4ca1408946", "filename": "src/test/run-pass/unboxed-closures-infer-explicit-call-early.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-explicit-call-early.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(fn_traits)]\n+\n fn main() {\n-    let mut zero = || {};\n-    let () = zero.call_mut(());\n-    //~^ ERROR we have not yet inferred what kind of closure it is\n+    let mut zero = || 0;\n+    let x = zero.call_mut(());\n+    assert_eq!(x, 0);\n }", "previous_filename": "src/test/compile-fail/unboxed-closures-infer-explicit-call-too-early.rs"}, {"sha": "23f115858cd5e6b53c66cb24ddf3d9b7e4d58668", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -8,6 +8,8 @@ error[E0599]: no method named `method` found for type `u32` in the current scope\n    = note: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n            candidate #1: `use foo::Bar;`\n            candidate #2: `use no_method_suggested_traits::foo::PubPub;`\n+           candidate #3: `use no_method_suggested_traits::qux::PrivPub;`\n+           candidate #4: `use no_method_suggested_traits::Reexported;`\n \n error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::boxed::Box<&u32>>` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:38:44\n@@ -19,6 +21,8 @@ error[E0599]: no method named `method` found for type `std::rc::Rc<&mut std::box\n    = note: the following traits are implemented but not in scope, perhaps add a `use` for one of them:\n            candidate #1: `use foo::Bar;`\n            candidate #2: `use no_method_suggested_traits::foo::PubPub;`\n+           candidate #3: `use no_method_suggested_traits::qux::PrivPub;`\n+           candidate #4: `use no_method_suggested_traits::Reexported;`\n \n error[E0599]: no method named `method` found for type `char` in the current scope\n   --> $DIR/no-method-suggested-traits.rs:44:9"}, {"sha": "e2e2019307f34f53160b3148a781273cf12ccae2", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -5,8 +5,8 @@ error[E0599]: no method named `count` found for type `std::iter::Filter<std::ite\n    |                                                       ^^^^^\n    |\n    = note: the method `count` exists but the following trait bounds were not satisfied:\n-           `[closure@$DIR/issue-36053-2.rs:17:39: 17:53] : std::ops::FnMut<(&_,)>`\n            `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n+           `&mut std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n \n error[E0281]: type mismatch: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53]` implements the trait `for<'r> std::ops::FnMut<(&'r str,)>`, but the trait `for<'r> std::ops::FnMut<(&'r &str,)>` is required\n   --> $DIR/issue-36053-2.rs:17:32"}, {"sha": "d504b7cae28c4bb36d25e5c22a6bc19c849d9460", "filename": "src/test/ui/suggestions/issue-43420-no-over-suggest.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.rs?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we substitute type parameters before we suggest anything - otherwise\n+// we would suggest function such as `as_slice` for the `&[u16]`.\n+\n+fn foo(b: &[u16]) {}\n+\n+fn main() {\n+    let a: Vec<u8> = Vec::new();\n+    foo(&a);\n+}"}, {"sha": "bcad9ce56c65e8dc1f2c28d286dc3b01eb1dca22", "filename": "src/test/ui/suggestions/issue-43420-no-over-suggest.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b58e31ac03d3f338385593496426534ad5a150a7/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-43420-no-over-suggest.stderr?ref=b58e31ac03d3f338385593496426534ad5a150a7", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-43420-no-over-suggest.rs:18:9\n+   |\n+18 |     foo(&a);\n+   |         ^^ expected slice, found struct `std::vec::Vec`\n+   |\n+   = note: expected type `&[u16]`\n+              found type `&std::vec::Vec<u8>`\n+\n+error: aborting due to previous error\n+"}]}