{"sha": "3f391b84552f210adec7893b50c5da74f9362ae4", "node_id": "C_kwDOAAsO6NoAKDNmMzkxYjg0NTUyZjIxMGFkZWM3ODkzYjUwYzVkYTc0ZjkzNjJhZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T18:51:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T18:51:40Z"}, "message": "Auto merge of #96087 - Dylan-DPC:rollup-k6yzk55, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #94457 (Stabilize `derive_default_enum`)\n - #94461 (Create (unstable) 2024 edition)\n - #94849 (Check var scope if it exist)\n - #95194 (remove find_use_placement)\n - #95749 (only downgrade selection Error -> Ambiguous if type error is in predicate)\n - #96026 (couple of clippy::complexity fixes)\n - #96027 (remove function parameters only used in recursion)\n - #96034 ([test] Add test cases of untested functions for BTreeSet )\n - #96040 (Use u32 instead of i32 for futexes.)\n - #96062 (docs: Update tests chapter for Termination stabilization)\n - #96065 (Refactor: Use `format-args-capture` and remove unnecessary nested blocks in rustc_typeck)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bd7084e37d615bb22152fce22c7c9328f5316c4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd7084e37d615bb22152fce22c7c9328f5316c4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f391b84552f210adec7893b50c5da74f9362ae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f391b84552f210adec7893b50c5da74f9362ae4", "html_url": "https://github.com/rust-lang/rust/commit/3f391b84552f210adec7893b50c5da74f9362ae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f391b84552f210adec7893b50c5da74f9362ae4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e6fe5855a115ef7f17f3e17205fab7340775701", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6fe5855a115ef7f17f3e17205fab7340775701", "html_url": "https://github.com/rust-lang/rust/commit/1e6fe5855a115ef7f17f3e17205fab7340775701"}, {"sha": "fa281fdf65f63da72abfef83abeb8bea37fddfd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa281fdf65f63da72abfef83abeb8bea37fddfd9", "html_url": "https://github.com/rust-lang/rust/commit/fa281fdf65f63da72abfef83abeb8bea37fddfd9"}], "stats": {"total": 2084, "additions": 1020, "deletions": 1064}, "files": [{"sha": "5aa8011ca5eb627a99e24c70ba9b75d085d4e7d5", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -722,7 +722,7 @@ impl NonterminalKind {\n                 Edition::Edition2015 | Edition::Edition2018 => {\n                     NonterminalKind::PatParam { inferred: true }\n                 }\n-                Edition::Edition2021 => NonterminalKind::PatWithOr,\n+                Edition::Edition2021 | Edition::Edition2024 => NonterminalKind::PatWithOr,\n             },\n             sym::pat_param => NonterminalKind::PatParam { inferred: false },\n             sym::expr => NonterminalKind::Expr,"}, {"sha": "5eab21bf79a90c9a95b57a41534df927793c3832", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -52,7 +52,9 @@ pub(super) fn index_hir<'hir>(\n     };\n \n     match item {\n-        OwnerNode::Crate(citem) => collector.visit_mod(&citem, citem.inner, hir::CRATE_HIR_ID),\n+        OwnerNode::Crate(citem) => {\n+            collector.visit_mod(&citem, citem.spans.inner_span, hir::CRATE_HIR_ID)\n+        }\n         OwnerNode::Item(item) => collector.visit_item(item),\n         OwnerNode::TraitItem(item) => collector.visit_trait_item(item),\n         OwnerNode::ImplItem(item) => collector.visit_impl_item(item),"}, {"sha": "a8bd8c92a41c47b54d45329720f092185260300f", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n         debug_assert_eq!(self.resolver.local_def_id(CRATE_NODE_ID), CRATE_DEF_ID);\n \n         self.with_lctx(CRATE_NODE_ID, |lctx| {\n-            let module = lctx.lower_mod(&c.items, c.spans.inner_span);\n+            let module = lctx.lower_mod(&c.items, &c.spans);\n             lctx.lower_attrs(hir::CRATE_HIR_ID, &c.attrs);\n             hir::OwnerNode::Crate(lctx.arena.alloc(module))\n         })\n@@ -186,9 +186,12 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n }\n \n impl<'hir> LoweringContext<'_, 'hir> {\n-    pub(super) fn lower_mod(&mut self, items: &[P<Item>], inner: Span) -> hir::Mod<'hir> {\n+    pub(super) fn lower_mod(&mut self, items: &[P<Item>], spans: &ModSpans) -> hir::Mod<'hir> {\n         hir::Mod {\n-            inner: self.lower_span(inner),\n+            spans: hir::ModSpans {\n+                inner_span: self.lower_span(spans.inner_span),\n+                inject_use_span: self.lower_span(spans.inject_use_span),\n+            },\n             item_ids: self.arena.alloc_from_iter(items.iter().flat_map(|x| self.lower_item_ref(x))),\n         }\n     }\n@@ -308,8 +311,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 })\n             }\n             ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n-                ModKind::Loaded(items, _, ModSpans { inner_span, inject_use_span: _ }) => {\n-                    hir::ItemKind::Mod(self.lower_mod(items, *inner_span))\n+                ModKind::Loaded(items, _, spans) => {\n+                    hir::ItemKind::Mod(self.lower_mod(items, spans))\n                 }\n                 ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n             },"}, {"sha": "2c5260616c7da398c6bce5a84e25e4691333aeec", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -46,18 +46,7 @@ pub fn expand_deriving_default(\n                     StaticStruct(_, fields) => {\n                         default_struct_substructure(cx, trait_span, substr, fields)\n                     }\n-                    StaticEnum(enum_def, _) => {\n-                        if !cx.sess.features_untracked().derive_default_enum {\n-                            rustc_session::parse::feature_err(\n-                                cx.parse_sess(),\n-                                sym::derive_default_enum,\n-                                span,\n-                                \"deriving `Default` on enums is experimental\",\n-                            )\n-                            .emit();\n-                        }\n-                        default_enum_substructure(cx, trait_span, enum_def)\n-                    }\n+                    StaticEnum(enum_def, _) => default_enum_substructure(cx, trait_span, enum_def),\n                     _ => cx.span_bug(trait_span, \"method in `derive(Default)`\"),\n                 }\n             })),"}, {"sha": "09ad5f9b3eaa98d40984ae1ed059e95962fb0c50", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -70,6 +70,7 @@ pub fn inject(\n             Edition2015 => sym::rust_2015,\n             Edition2018 => sym::rust_2018,\n             Edition2021 => sym::rust_2021,\n+            Edition2024 => sym::rust_2024,\n         }])\n         .map(|&symbol| Ident::new(symbol, span))\n         .collect();"}, {"sha": "9cd072c8b4cdf38af332c504b226cea1996edb3f", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -832,7 +832,7 @@ impl Diagnostic {\n         name: impl Into<Cow<'static, str>>,\n         arg: DiagnosticArgValue<'static>,\n     ) -> &mut Self {\n-        self.args.push((name.into(), arg.into()));\n+        self.args.push((name.into(), arg));\n         self\n     }\n "}, {"sha": "c6a6e3d125f709196f09194bdfc509afb571c41d", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -270,7 +270,7 @@ fn check_binders(\n                     MISSING_FRAGMENT_SPECIFIER,\n                     span,\n                     node_id,\n-                    &format!(\"missing fragment specifier\"),\n+                    \"missing fragment specifier\",\n                 );\n             }\n             if !macros.is_empty() {"}, {"sha": "63aac64989dfaa4d4712bbade80c1cc4eee67b8c", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -77,7 +77,6 @@ use crate::mbe::{KleeneOp, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n use rustc_parse::parser::{NtOrTt, Parser};\n-use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n@@ -128,9 +127,8 @@ pub(super) enum MatcherLoc {\n     Eof,\n }\n \n-pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<MatcherLoc> {\n+pub(super) fn compute_locs(matcher: &[TokenTree]) -> Vec<MatcherLoc> {\n     fn inner(\n-        sess: &ParseSess,\n         tts: &[TokenTree],\n         locs: &mut Vec<MatcherLoc>,\n         next_metavar: &mut usize,\n@@ -147,7 +145,7 @@ pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<Match\n \n                     locs.push(MatcherLoc::Delimited);\n                     locs.push(MatcherLoc::Token { token: open_token });\n-                    inner(sess, &delimited.tts, locs, next_metavar, seq_depth);\n+                    inner(&delimited.tts, locs, next_metavar, seq_depth);\n                     locs.push(MatcherLoc::Token { token: close_token });\n                 }\n                 TokenTree::Sequence(_, seq) => {\n@@ -162,7 +160,7 @@ pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<Match\n                     let op = seq.kleene.op;\n                     let idx_first = locs.len();\n                     let idx_seq = idx_first - 1;\n-                    inner(sess, &seq.tts, locs, next_metavar, seq_depth + 1);\n+                    inner(&seq.tts, locs, next_metavar, seq_depth + 1);\n \n                     if let Some(separator) = &seq.separator {\n                         locs.push(MatcherLoc::SequenceSep { separator: separator.clone() });\n@@ -197,7 +195,7 @@ pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<Match\n \n     let mut locs = vec![];\n     let mut next_metavar = 0;\n-    inner(sess, matcher, &mut locs, &mut next_metavar, /* seq_depth */ 0);\n+    inner(matcher, &mut locs, &mut next_metavar, /* seq_depth */ 0);\n \n     // A final entry is needed for eof.\n     locs.push(MatcherLoc::Eof);"}, {"sha": "2cfd6968accf7744a3b54d1e1588d206d92757de", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -435,7 +435,7 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n     // Convert it into `MatcherLoc` form.\n-    let argument_gram = mbe::macro_parser::compute_locs(&sess.parse_sess, &argument_gram);\n+    let argument_gram = mbe::macro_parser::compute_locs(&argument_gram);\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser =\n@@ -478,7 +478,7 @@ pub fn compile_declarative_macro(\n                     )\n                     .pop()\n                     .unwrap();\n-                    valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n+                    valid &= check_lhs_nt_follows(&sess.parse_sess, &def, &tt);\n                     return tt;\n                 }\n                 sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n@@ -540,7 +540,7 @@ pub fn compile_declarative_macro(\n                 // Ignore the delimiters around the matcher.\n                 match lhs {\n                     mbe::TokenTree::Delimited(_, delimited) => {\n-                        mbe::macro_parser::compute_locs(&sess.parse_sess, &delimited.tts)\n+                        mbe::macro_parser::compute_locs(&delimited.tts)\n                     }\n                     _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"malformed macro lhs\"),\n                 }\n@@ -563,16 +563,11 @@ pub fn compile_declarative_macro(\n     }))\n }\n \n-fn check_lhs_nt_follows(\n-    sess: &ParseSess,\n-    features: &Features,\n-    def: &ast::Item,\n-    lhs: &mbe::TokenTree,\n-) -> bool {\n+fn check_lhs_nt_follows(sess: &ParseSess, def: &ast::Item, lhs: &mbe::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let mbe::TokenTree::Delimited(_, delimited) = lhs {\n-        check_matcher(sess, features, def, &delimited.tts)\n+        check_matcher(sess, def, &delimited.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -632,16 +627,11 @@ fn check_rhs(sess: &ParseSess, rhs: &mbe::TokenTree) -> bool {\n     false\n }\n \n-fn check_matcher(\n-    sess: &ParseSess,\n-    features: &Features,\n-    def: &ast::Item,\n-    matcher: &[mbe::TokenTree],\n-) -> bool {\n+fn check_matcher(sess: &ParseSess, def: &ast::Item, matcher: &[mbe::TokenTree]) -> bool {\n     let first_sets = FirstSets::new(matcher);\n     let empty_suffix = TokenSet::empty();\n     let err = sess.span_diagnostic.err_count();\n-    check_matcher_core(sess, features, def, &first_sets, matcher, &empty_suffix);\n+    check_matcher_core(sess, def, &first_sets, matcher, &empty_suffix);\n     err == sess.span_diagnostic.err_count()\n }\n \n@@ -955,7 +945,6 @@ impl<'tt> TokenSet<'tt> {\n // see `FirstSets::new`.\n fn check_matcher_core<'tt>(\n     sess: &ParseSess,\n-    features: &Features,\n     def: &ast::Item,\n     first_sets: &FirstSets<'tt>,\n     matcher: &'tt [mbe::TokenTree],\n@@ -1008,7 +997,7 @@ fn check_matcher_core<'tt>(\n                     token::CloseDelim(d.delim),\n                     span.close,\n                 ));\n-                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n+                check_matcher_core(sess, def, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n \n@@ -1040,8 +1029,7 @@ fn check_matcher_core<'tt>(\n                 // At this point, `suffix_first` is built, and\n                 // `my_suffix` is some TokenSet that we can use\n                 // for checking the interior of `seq_rep`.\n-                let next =\n-                    check_matcher_core(sess, features, def, first_sets, &seq_rep.tts, my_suffix);\n+                let next = check_matcher_core(sess, def, first_sets, &seq_rep.tts, my_suffix);\n                 if next.maybe_empty {\n                     last.add_all(&next);\n                 } else {\n@@ -1114,7 +1102,7 @@ fn check_matcher_core<'tt>(\n                             err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n \n                             if kind == NonterminalKind::PatWithOr\n-                                && sess.edition == Edition::Edition2021\n+                                && sess.edition.rust_2021()\n                                 && next_token.is_token(&BinOp(token::BinOpToken::Or))\n                             {\n                                 let suggestion = quoted_tt_to_string(&TokenTree::MetaVarDecl("}, {"sha": "048039343a7a2e9bc8e6c7bf13c9b8426c7bd83d", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -126,6 +126,8 @@ declare_features! (\n     (accepted, default_type_params, \"1.0.0\", None, None),\n     /// Allows `#[deprecated]` attribute.\n     (accepted, deprecated, \"1.9.0\", Some(29935), None),\n+    /// Allows `#[derive(Default)]` and `#[default]` on enums.\n+    (accepted, derive_default_enum, \"1.62.0\", Some(86985), None),\n     /// Allows the use of destructuring assignments.\n     (accepted, destructuring_assignment, \"1.59.0\", Some(71126), None),\n     /// Allows `#[doc(alias = \"...\")]`."}, {"sha": "f3d4c8ab4384311b56a55ba6ef896bda98b40a3a", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -368,8 +368,6 @@ declare_features! (\n     (active, deprecated_safe, \"1.61.0\", Some(94978), None),\n     /// Allows having using `suggestion` in the `#[deprecated]` attribute.\n     (active, deprecated_suggestion, \"1.61.0\", Some(94785), None),\n-    /// Allows `#[derive(Default)]` and `#[default]` on enums.\n-    (active, derive_default_enum, \"1.56.0\", Some(86985), None),\n     /// Tells rustdoc to automatically generate `#[doc(cfg(...))]`.\n     (active, doc_auto_cfg, \"1.58.0\", Some(43781), None),\n     /// Allows `#[doc(cfg(...))]`."}, {"sha": "940c4ecdcc23a07b5106f74ef5c7da35c77b371a", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -11,7 +11,7 @@\n //! even if it is stabilized or removed, *do not remove it*. Instead, move the\n //! symbol to the `accepted` or `removed` modules respectively.\n \n-#![feature(derive_default_enum)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(once_cell)]\n \n mod accepted;"}, {"sha": "68ae2441af7979d185e1db47dbdf7908e82b0cd5", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -2557,11 +2557,17 @@ impl FnRetTy<'_> {\n \n #[derive(Encodable, Debug, HashStable_Generic)]\n pub struct Mod<'hir> {\n+    pub spans: ModSpans,\n+    pub item_ids: &'hir [ItemId],\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable_Generic, Encodable)]\n+pub struct ModSpans {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n-    pub inner: Span,\n-    pub item_ids: &'hir [ItemId],\n+    pub inner_span: Span,\n+    pub inject_use_span: Span,\n }\n \n #[derive(Debug, HashStable_Generic)]\n@@ -3059,8 +3065,8 @@ impl<'hir> OwnerNode<'hir> {\n             OwnerNode::Item(Item { span, .. })\n             | OwnerNode::ForeignItem(ForeignItem { span, .. })\n             | OwnerNode::ImplItem(ImplItem { span, .. })\n-            | OwnerNode::TraitItem(TraitItem { span, .. })\n-            | OwnerNode::Crate(Mod { inner: span, .. }) => *span,\n+            | OwnerNode::TraitItem(TraitItem { span, .. }) => *span,\n+            OwnerNode::Crate(Mod { spans: ModSpans { inner_span, .. }, .. }) => *inner_span,\n         }\n     }\n "}, {"sha": "58c309a5c52ea7a52aa3efbe39157cc8ad225ff6", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -63,9 +63,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// common state. Used in coherence.\n     pub fn fork(&self) -> Self {\n         Self {\n-            tcx: self.tcx.clone(),\n-            defining_use_anchor: self.defining_use_anchor.clone(),\n-            in_progress_typeck_results: self.in_progress_typeck_results.clone(),\n+            tcx: self.tcx,\n+            defining_use_anchor: self.defining_use_anchor,\n+            in_progress_typeck_results: self.in_progress_typeck_results,\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),\n             lexical_region_resolutions: self.lexical_region_resolutions.clone(),"}, {"sha": "e859bcaec120692b917cba3f207019e6d8361bac", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -17,7 +17,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(derive_default_enum)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(extend_one)]\n #![feature(label_break_value)]\n #![feature(let_chains)]"}, {"sha": "b53ef8161359a48fec2941ff7624152df91b82cf", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -44,7 +44,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n #[proc_macro]\n #[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n pub fn newtype_index(input: TokenStream) -> TokenStream {\n-    newtype::newtype(input).into()\n+    newtype::newtype(input)\n }\n \n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);"}, {"sha": "08cd40f38efcede73570b5bede8fef5fc9de1949", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -584,7 +584,7 @@ impl<'hir> Map<'hir> {\n             Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n                 (m, span, hir_id)\n             }\n-            Some(OwnerNode::Crate(item)) => (item, item.inner, hir_id),\n+            Some(OwnerNode::Crate(item)) => (item, item.spans.inner_span, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -1012,7 +1012,7 @@ impl<'hir> Map<'hir> {\n             Node::Infer(i) => i.span,\n             Node::Visibility(v) => bug!(\"unexpected Visibility {:?}\", v),\n             Node::Local(local) => local.span,\n-            Node::Crate(item) => item.inner,\n+            Node::Crate(item) => item.spans.inner_span,\n         };\n         Some(span)\n     }"}, {"sha": "199b5fa0314b35014e211763aa503f96bd125dba", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -30,7 +30,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(core_intrinsics)]\n-#![feature(derive_default_enum)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(discriminant_kind)]\n #![feature(exhaustive_patterns)]\n #![feature(get_mut_unchecked)]"}, {"sha": "af16e5e3fc871ff162a184071c5b94ba0a8b0c29", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -362,12 +362,9 @@ impl ScopeTree {\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n-    /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Scope {\n-        self.var_map\n-            .get(&var_id)\n-            .cloned()\n-            .unwrap_or_else(|| bug!(\"no enclosing scope for id {:?}\", var_id))\n+    /// Returns the lifetime of the local variable `var_id`, if any.\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> Option<Scope> {\n+        self.var_map.get(&var_id).cloned()\n     }\n \n     /// Returns the scope when the temp created by `expr_id` will be cleaned up."}, {"sha": "226456588e75d3c12545132f4671ce3b23ecfc9d", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -191,7 +191,7 @@ impl<'tcx> Ty<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest<'tcx> {\n-        tcx.type_uninhabited_from(param_env.and(self)).clone()\n+        tcx.type_uninhabited_from(param_env.and(self))\n     }\n }\n "}, {"sha": "3a6e59db90b91d08cd492268ebf3ebf934210cbc", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     };\n \n-                Constant { span, user_ty: None, literal: literal.into() }\n+                Constant { span, user_ty: None, literal }\n             }\n             ExprKind::NonHirLiteral { lit, user_ty } => {\n                 let user_ty = user_ty.map(|user_ty| {"}, {"sha": "823f5f4cf12c460f74c79946e47e658050c76a2a", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -423,11 +423,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                         thir::InlineAsmOperand::Const { value, span } => {\n                             mir::InlineAsmOperand::Const {\n-                                value: Box::new(Constant {\n-                                    span,\n-                                    user_ty: None,\n-                                    literal: value.into(),\n-                                }),\n+                                value: Box::new(Constant { span, user_ty: None, literal: value }),\n                             }\n                         }\n                         thir::InlineAsmOperand::SymFn { expr } => mir::InlineAsmOperand::SymFn {"}, {"sha": "d45ae19752e8c0f0019166c143ffdc60c7a95426", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -701,17 +701,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n         self.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(local_id) });\n-        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n-        if schedule_drop {\n+        // Altough there is almost always scope for given variable in corner cases\n+        // like #92893 we might get variable with no scope.\n+        if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) && schedule_drop{\n             self.schedule_drop(span, region_scope, local_id, DropKind::Storage);\n         }\n         Place::from(local_id)\n     }\n \n     crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n-        let region_scope = self.region_scope_tree.var_scope(var.local_id);\n-        self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n+        if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) {\n+            self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n+        }\n     }\n \n     /// Visit all of the primary bindings in a patterns, that is, visit the"}, {"sha": "0e9e98693766084ec18e95d4d1f10904dbd7c2ee", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -441,7 +441,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // Need to experiment.\n                     user_ty: None,\n \n-                    literal: method.into(),\n+                    literal: method,\n                 })),\n                 args: vec![val, expect],\n                 destination: Some((eq_result, eq_block)),"}, {"sha": "1b4510b62206803d6b9a710bbaee2fb13db5fdc0", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -539,13 +539,13 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n             UnusedUnsafe::InUnsafeBlock(id) => {\n                 db.span_label(\n                     tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n-                    format!(\"because it's nested under this `unsafe` block\"),\n+                    \"because it's nested under this `unsafe` block\",\n                 );\n             }\n             UnusedUnsafe::InUnsafeFn(id, usage_lint_root) => {\n                 db.span_label(\n                     tcx.sess.source_map().guess_head_span(tcx.hir().span(id)),\n-                    format!(\"because it's nested under this `unsafe` fn\"),\n+                    \"because it's nested under this `unsafe` fn\",\n                 )\n                 .note(\n                     \"this `unsafe` block does contain unsafe operations, \\"}, {"sha": "79f0237fd9b7478f4128c70465c92f0a1246915e", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -234,13 +234,13 @@ impl<'a> StringReader<'a> {\n             rustc_lexer::TokenKind::InvalidIdent\n                 // Do not recover an identifier with emoji if the codepoint is a confusable\n                 // with a recoverable substitution token, like `\u2796`.\n-                if UNICODE_ARRAY\n+                if !UNICODE_ARRAY\n                     .iter()\n-                    .find(|&&(c, _, _)| {\n+                    .any(|&(c, _, _)| {\n                         let sym = self.str_from(start);\n                         sym.chars().count() == 1 && c == sym.chars().next().unwrap()\n                     })\n-                    .is_none() =>\n+                     =>\n             {\n                 let sym = nfc_normalize(self.str_from(start));\n                 let span = self.mk_sp(start, self.pos);"}, {"sha": "8c979a124667c015e860de514c343cd14c913e49", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -158,7 +158,6 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     #[allow(dead_code)] // FIXME(81658): should be used + lint reinstated after #83171 relands.\n     fn check_for_self_assign(&mut self, assign: &'tcx hir::Expr<'tcx>) {\n         fn check_for_self_assign_helper<'tcx>(\n-            tcx: TyCtxt<'tcx>,\n             typeck_results: &'tcx ty::TypeckResults<'tcx>,\n             lhs: &'tcx hir::Expr<'tcx>,\n             rhs: &'tcx hir::Expr<'tcx>,\n@@ -177,7 +176,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 }\n                 (hir::ExprKind::Field(lhs_l, ident_l), hir::ExprKind::Field(lhs_r, ident_r)) => {\n                     if ident_l == ident_r {\n-                        return check_for_self_assign_helper(tcx, typeck_results, lhs_l, lhs_r);\n+                        return check_for_self_assign_helper(typeck_results, lhs_l, lhs_r);\n                     }\n                     return false;\n                 }\n@@ -188,7 +187,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         }\n \n         if let hir::ExprKind::Assign(lhs, rhs, _) = assign.kind {\n-            if check_for_self_assign_helper(self.tcx, self.typeck_results(), lhs, rhs)\n+            if check_for_self_assign_helper(self.typeck_results(), lhs, rhs)\n                 && !assign.span.from_expansion()\n             {\n                 let is_field_assign = matches!(lhs.kind, hir::ExprKind::Field(..));"}, {"sha": "01ba9e35c24dc65c22e1ba4d79e9ef381214cfbc", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -133,9 +133,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n \n             // `Deprecation` is just two pointers, no need to intern it\n-            let depr_entry = DeprecationEntry::local(depr.clone(), def_id);\n+            let depr_entry = DeprecationEntry::local(*depr, def_id);\n             self.index.depr_map.insert(def_id, depr_entry);\n-        } else if let Some(parent_depr) = self.parent_depr.clone() {\n+        } else if let Some(parent_depr) = self.parent_depr {\n             if inherit_deprecation.yes() {\n                 is_deprecated = true;\n                 info!(\"tagging child {:?} as deprecated from parent\", def_id);"}, {"sha": "22d0a20395ec7d77b62a9811f14049940e55f1a2", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1095,11 +1095,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n \n         let sm = self.tcx.sess.source_map();\n         let krate_mod = self.tcx.hir().root_module();\n-        let filename = sm.span_to_filename(krate_mod.inner);\n+        let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n         let data_id = id_from_hir_id(id, &self.save_ctxt);\n         let children =\n             krate_mod.item_ids.iter().map(|i| id_from_def_id(i.def_id.to_def_id())).collect();\n-        let span = self.span_from_span(krate_mod.inner);\n+        let span = self.span_from_span(krate_mod.spans.inner_span);\n         let attrs = self.tcx.hir().attrs(id);\n \n         self.dumper.dump_def("}, {"sha": "102268c6ca3524b1b7e39c51bb02217f6925f148", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -282,7 +282,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n \n                 let sm = self.tcx.sess.source_map();\n-                let filename = sm.span_to_filename(m.inner);\n+                let filename = sm.span_to_filename(m.spans.inner_span);\n \n                 filter!(self.span_utils, item.ident.span);\n "}, {"sha": "054b18b6b633aabc71cf2e5941c07a3ce4c59a79", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,7 +1,7 @@\n #![feature(crate_visibility_modifier)]\n-#![feature(derive_default_enum)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "b4548129689b1e90f718d7737ce28c48131170a1", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -238,7 +238,7 @@ impl Session {\n             }\n             diag.emit();\n             // If we should err, make sure we did.\n-            if must_err && !self.has_errors().is_some() {\n+            if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject.\n                 self.err(\n                     \"`-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature \\\n@@ -991,6 +991,11 @@ impl Session {\n         self.opts.edition >= Edition::Edition2021\n     }\n \n+    /// Are we allowed to use features from the Rust 2024 edition?\n+    pub fn rust_2024(&self) -> bool {\n+        self.opts.edition >= Edition::Edition2024\n+    }\n+\n     pub fn edition(&self) -> Edition {\n         self.opts.edition\n     }"}, {"sha": "065d3660e5008955269305b45450874886d8a7f2", "filename": "compiler/rustc_span/src/edition.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedition.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -22,13 +22,15 @@ pub enum Edition {\n     Edition2018,\n     /// The 2021 edition\n     Edition2021,\n+    /// The 2024 edition\n+    Edition2024,\n }\n \n // Must be in order from oldest to newest.\n pub const ALL_EDITIONS: &[Edition] =\n-    &[Edition::Edition2015, Edition::Edition2018, Edition::Edition2021];\n+    &[Edition::Edition2015, Edition::Edition2018, Edition::Edition2021, Edition::Edition2024];\n \n-pub const EDITION_NAME_LIST: &str = \"2015|2018|2021\";\n+pub const EDITION_NAME_LIST: &str = \"2015|2018|2021|2024\";\n \n pub const DEFAULT_EDITION: Edition = Edition::Edition2015;\n \n@@ -40,6 +42,7 @@ impl fmt::Display for Edition {\n             Edition::Edition2015 => \"2015\",\n             Edition::Edition2018 => \"2018\",\n             Edition::Edition2021 => \"2021\",\n+            Edition::Edition2024 => \"2024\",\n         };\n         write!(f, \"{}\", s)\n     }\n@@ -51,6 +54,7 @@ impl Edition {\n             Edition::Edition2015 => \"rust_2015_compatibility\",\n             Edition::Edition2018 => \"rust_2018_compatibility\",\n             Edition::Edition2021 => \"rust_2021_compatibility\",\n+            Edition::Edition2024 => \"rust_2024_compatibility\",\n         }\n     }\n \n@@ -59,6 +63,7 @@ impl Edition {\n             Edition::Edition2015 => sym::rust_2015_preview,\n             Edition::Edition2018 => sym::rust_2018_preview,\n             Edition::Edition2021 => sym::rust_2021_preview,\n+            Edition::Edition2024 => sym::rust_2024_preview,\n         }\n     }\n \n@@ -67,8 +72,28 @@ impl Edition {\n             Edition::Edition2015 => true,\n             Edition::Edition2018 => true,\n             Edition::Edition2021 => true,\n+            Edition::Edition2024 => false,\n         }\n     }\n+\n+    pub fn rust_2015(&self) -> bool {\n+        *self == Edition::Edition2015\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2018 edition?\n+    pub fn rust_2018(&self) -> bool {\n+        *self >= Edition::Edition2018\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2021 edition?\n+    pub fn rust_2021(&self) -> bool {\n+        *self >= Edition::Edition2021\n+    }\n+\n+    /// Are we allowed to use features from the Rust 2024 edition?\n+    pub fn rust_2024(&self) -> bool {\n+        *self >= Edition::Edition2024\n+    }\n }\n \n impl FromStr for Edition {\n@@ -78,6 +103,7 @@ impl FromStr for Edition {\n             \"2015\" => Ok(Edition::Edition2015),\n             \"2018\" => Ok(Edition::Edition2018),\n             \"2021\" => Ok(Edition::Edition2021),\n+            \"2024\" => Ok(Edition::Edition2024),\n             _ => Err(()),\n         }\n     }"}, {"sha": "b132c0a2132b724b0077f3019432112d4a1ba55e", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -684,6 +684,11 @@ impl Span {\n         self.edition() >= edition::Edition::Edition2021\n     }\n \n+    #[inline]\n+    pub fn rust_2024(self) -> bool {\n+        self.edition() >= edition::Edition::Edition2024\n+    }\n+\n     /// Returns the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,"}, {"sha": "f6acb3c76fe588f6a455fca793157fd5cab8a095", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1149,6 +1149,8 @@ symbols! {\n         rust_2018_preview,\n         rust_2021,\n         rust_2021_preview,\n+        rust_2024,\n+        rust_2024_preview,\n         rust_begin_unwind,\n         rust_eh_catch_typeinfo,\n         rust_eh_personality,"}, {"sha": "cc3a0a69999b0bc77bf99dbb1aad837f88c0d933", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -113,11 +113,11 @@ where\n             data = arg_scalar(cx, &scalar, offset, data);\n         }\n         abi::Abi::Aggregate { .. } => {\n-            for i in 0..layout.fields.count().clone() {\n+            for i in 0..layout.fields.count() {\n                 if offset < layout.fields.offset(i) {\n                     offset = layout.fields.offset(i);\n                 }\n-                data = parse_structure(cx, layout.field(cx, i).clone(), data.clone(), offset);\n+                data = parse_structure(cx, layout.field(cx, i), data.clone(), offset);\n             }\n         }\n         _ => {\n@@ -161,7 +161,7 @@ where\n \n             let mut data = parse_structure(\n                 cx,\n-                arg.layout.clone(),\n+                arg.layout,\n                 Sdata {\n                     prefix: [None; 8],\n                     prefix_index: 0,"}, {"sha": "2ae7f34a91e00a4b1c398f36a8924b8f080aecd5", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -16,7 +16,7 @@\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n-#![feature(derive_default_enum)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n #![feature(label_break_value)]"}, {"sha": "ce0e0a21ff516f0adaab581cfa80bf828836af39", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -258,7 +258,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 enclosing_scope = Some(enclosing_scope_.clone());\n             }\n \n-            append_const_msg = command.append_const_msg.clone();\n+            append_const_msg = command.append_const_msg;\n         }\n \n         OnUnimplementedNote {"}, {"sha": "dbb6c54fcd93b4962b178e35e1dec680a20083b2", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -231,8 +231,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n             // emitting additional spurious errors, since we're guaranteed\n             // to have emitted at least one.\n-            if stack.obligation.references_error() {\n-                debug!(\"no results for error type, treating as ambiguous\");\n+            if stack.obligation.predicate.references_error() {\n+                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n                 return Ok(None);\n             }\n             return Err(Unimplemented);"}, {"sha": "1c7e7c935c4a1c4ee378394a29ab4dbf8239681a", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -260,10 +260,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &mut |err| {\n                 if let Some((span, msg)) = &ret_reason {\n                     err.span_label(*span, msg.as_str());\n-                } else if let ExprKind::Block(block, _) = &then_expr.kind {\n-                    if let Some(expr) = &block.expr {\n-                        err.span_label(expr.span, \"found here\".to_string());\n-                    }\n+                } else if let ExprKind::Block(block, _) = &then_expr.kind\n+                    && let Some(expr) = &block.expr\n+                {\n+                    err.span_label(expr.span, \"found here\".to_string());\n                 }\n                 err.note(\"`if` expressions without `else` evaluate to `()`\");\n                 err.help(\"consider adding an `else` block that evaluates to the expected type\");\n@@ -293,7 +293,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n                         let span = fn_decl.output.span();\n                         let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n-                        Some((span, format!(\"expected `{}` because of this return type\", snippet)))\n+                        Some((span, format!(\"expected `{snippet}` because of this return type\")))\n                     });\n                 }\n             }"}, {"sha": "580fb7c3e0f063b289179fd5668d50bbda393d74", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -43,7 +43,7 @@ pub fn check_legal_trait_for_method_call(\n         let (sp, suggestion) = receiver\n             .and_then(|s| tcx.sess.source_map().span_to_snippet(s).ok())\n             .filter(|snippet| !snippet.is_empty())\n-            .map(|snippet| (expr_span, format!(\"drop({})\", snippet)))\n+            .map(|snippet| (expr_span, format!(\"drop({snippet})\")))\n             .unwrap_or_else(|| (span, \"drop\".to_string()));\n \n         err.span_suggestion(\n@@ -315,17 +315,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::ExprKind::Tup(exp),\n             hir::ExprKind::Call(_, args),\n         ) = (parent_node, &callee_expr.kind, &call_expr.kind)\n+            && args.len() == exp.len()\n         {\n-            if args.len() == exp.len() {\n-                let start = callee_expr.span.shrink_to_hi();\n-                err.span_suggestion(\n-                    start,\n-                    \"consider separating array elements with a comma\",\n-                    \",\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                return true;\n-            }\n+            let start = callee_expr.span.shrink_to_hi();\n+            err.span_suggestion(\n+                start,\n+                \"consider separating array elements with a comma\",\n+                \",\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n         }\n         false\n     }\n@@ -373,15 +372,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ref t => {\n                 let mut unit_variant = None;\n                 let mut removal_span = call_expr.span;\n-                if let ty::Adt(adt_def, ..) = t {\n-                    if adt_def.is_enum() {\n-                        if let hir::ExprKind::Call(expr, _) = call_expr.kind {\n-                            removal_span =\n-                                expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                            unit_variant =\n-                                self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n-                        }\n-                    }\n+                if let ty::Adt(adt_def, ..) = t\n+                    && adt_def.is_enum()\n+                    && let hir::ExprKind::Call(expr, _) = call_expr.kind\n+                {\n+                    removal_span =\n+                        expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+                    unit_variant =\n+                        self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n                 }\n \n                 let callee_ty = self.resolve_vars_if_possible(callee_ty);\n@@ -392,8 +390,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     E0618,\n                     \"expected function, found {}\",\n                     match unit_variant {\n-                        Some(ref path) => format!(\"enum variant `{}`\", path),\n-                        None => format!(\"`{}`\", callee_ty),\n+                        Some(ref path) => format!(\"enum variant `{path}`\"),\n+                        None => format!(\"`{callee_ty}`\"),\n                     }\n                 );\n \n@@ -408,8 +406,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         removal_span,\n                         &format!(\n-                            \"`{}` is a unit variant, you need to write it without the parentheses\",\n-                            path\n+                            \"`{path}` is a unit variant, you need to write it without the parentheses\",\n                         ),\n                         String::new(),\n                         Applicability::MachineApplicable,\n@@ -452,14 +449,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(span) = self.tcx.hir().res_span(def) {\n                     let callee_ty = callee_ty.to_string();\n                     let label = match (unit_variant, inner_callee_path) {\n-                        (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                        (Some(path), _) => Some(format!(\"`{path}` defined here\")),\n                         (_, Some(hir::QPath::Resolved(_, path))) => self\n                             .tcx\n                             .sess\n                             .source_map()\n                             .span_to_snippet(path.span)\n                             .ok()\n-                            .map(|p| format!(\"`{}` defined here returns `{}`\", p, callee_ty)),\n+                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n                         _ => {\n                             match def {\n                                 // Emit a different diagnostic for local variables, as they are not\n@@ -475,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                         self.tcx.def_path_str(def_id),\n                                     ))\n                                 }\n-                                _ => Some(format!(\"`{}` defined here\", callee_ty)),\n+                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n                             }\n                         }\n                     };"}, {"sha": "049940d19a651b3622f278c0b829c3097abe27c2", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 70, "deletions": 76, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             err.span_suggestion(\n                                 self.span,\n                                 \"compare with zero instead\",\n-                                format!(\"{} != 0\", snippet),\n+                                format!(\"{snippet} != 0\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n@@ -373,8 +373,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 let mut sugg = None;\n                 let mut sugg_mutref = false;\n                 if let ty::Ref(reg, cast_ty, mutbl) = *self.cast_ty.kind() {\n-                    if let ty::RawPtr(TypeAndMut { ty: expr_ty, .. }) = *self.expr_ty.kind() {\n-                        if fcx\n+                    if let ty::RawPtr(TypeAndMut { ty: expr_ty, .. }) = *self.expr_ty.kind()\n+                        && fcx\n                             .try_coerce(\n                                 self.expr,\n                                 fcx.tcx.mk_ref(\n@@ -386,27 +386,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                 None,\n                             )\n                             .is_ok()\n-                        {\n-                            sugg = Some((format!(\"&{}*\", mutbl.prefix_str()), cast_ty == expr_ty));\n-                        }\n-                    } else if let ty::Ref(expr_reg, expr_ty, expr_mutbl) = *self.expr_ty.kind() {\n-                        if expr_mutbl == Mutability::Not\n-                            && mutbl == Mutability::Mut\n-                            && fcx\n-                                .try_coerce(\n-                                    self.expr,\n-                                    fcx.tcx.mk_ref(\n-                                        expr_reg,\n-                                        TypeAndMut { ty: expr_ty, mutbl: Mutability::Mut },\n-                                    ),\n-                                    self.cast_ty,\n-                                    AllowTwoPhase::No,\n-                                    None,\n-                                )\n-                                .is_ok()\n-                        {\n-                            sugg_mutref = true;\n-                        }\n+                    {\n+                        sugg = Some((format!(\"&{}*\", mutbl.prefix_str()), cast_ty == expr_ty));\n+                    } else if let ty::Ref(expr_reg, expr_ty, expr_mutbl) = *self.expr_ty.kind()\n+                        && expr_mutbl == Mutability::Not\n+                        && mutbl == Mutability::Mut\n+                        && fcx\n+                            .try_coerce(\n+                                self.expr,\n+                                fcx.tcx.mk_ref(\n+                                    expr_reg,\n+                                    TypeAndMut { ty: expr_ty, mutbl: Mutability::Mut },\n+                                ),\n+                                self.cast_ty,\n+                                AllowTwoPhase::No,\n+                                None,\n+                            )\n+                            .is_ok()\n+                    {\n+                        sugg_mutref = true;\n                     }\n \n                     if !sugg_mutref\n@@ -423,8 +421,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     {\n                         sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n                     }\n-                } else if let ty::RawPtr(TypeAndMut { mutbl, .. }) = *self.cast_ty.kind() {\n-                    if fcx\n+                } else if let ty::RawPtr(TypeAndMut { mutbl, .. }) = *self.cast_ty.kind()\n+                    && fcx\n                         .try_coerce(\n                             self.expr,\n                             fcx.tcx.mk_ref(\n@@ -436,9 +434,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             None,\n                         )\n                         .is_ok()\n-                    {\n-                        sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n-                    }\n+                {\n+                    sugg = Some((format!(\"&{}\", mutbl.prefix_str()), false));\n                 }\n                 if sugg_mutref {\n                     err.span_label(self.span, \"invalid cast\");\n@@ -483,28 +480,28 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 ) {\n                     let mut label = true;\n                     // Check `impl From<self.expr_ty> for self.cast_ty {}` for accurate suggestion:\n-                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span) {\n-                        if let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::From) {\n-                            let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n-                            // Erase regions to avoid panic in `prove_value` when calling\n-                            // `type_implements_trait`.\n-                            let ty = fcx.tcx.erase_regions(ty);\n-                            let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n-                            let expr_ty = fcx.tcx.erase_regions(expr_ty);\n-                            let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n-                            if fcx\n-                                .infcx\n-                                .type_implements_trait(from_trait, ty, ty_params, fcx.param_env)\n-                                .must_apply_modulo_regions()\n-                            {\n-                                label = false;\n-                                err.span_suggestion(\n-                                    self.span,\n-                                    \"consider using the `From` trait instead\",\n-                                    format!(\"{}::from({})\", self.cast_ty, snippet),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n+                    if let Ok(snippet) = fcx.tcx.sess.source_map().span_to_snippet(self.expr_span)\n+                        && let Some(from_trait) = fcx.tcx.get_diagnostic_item(sym::From)\n+                    {\n+                        let ty = fcx.resolve_vars_if_possible(self.cast_ty);\n+                        // Erase regions to avoid panic in `prove_value` when calling\n+                        // `type_implements_trait`.\n+                        let ty = fcx.tcx.erase_regions(ty);\n+                        let expr_ty = fcx.resolve_vars_if_possible(self.expr_ty);\n+                        let expr_ty = fcx.tcx.erase_regions(expr_ty);\n+                        let ty_params = fcx.tcx.mk_substs_trait(expr_ty, &[]);\n+                        if fcx\n+                            .infcx\n+                            .type_implements_trait(from_trait, ty, ty_params, fcx.param_env)\n+                            .must_apply_modulo_regions()\n+                        {\n+                            label = false;\n+                            err.span_suggestion(\n+                                self.span,\n+                                \"consider using the `From` trait instead\",\n+                                format!(\"{}::from({})\", self.cast_ty, snippet),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n                     }\n                     let msg = \"an `as` expression can only be used to convert between primitive \\\n@@ -627,10 +624,8 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         }\n                     }\n                 } else {\n-                    let msg = &format!(\n-                        \"consider using an implicit coercion to `&{}{}` instead\",\n-                        mtstr, tstr\n-                    );\n+                    let msg =\n+                        &format!(\"consider using an implicit coercion to `&{mtstr}{tstr}` instead\");\n                     err.span_help(self.span, msg);\n                 }\n             }\n@@ -640,14 +635,14 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         err.span_suggestion(\n                             self.cast_span,\n                             \"you can cast to a `Box` instead\",\n-                            format!(\"Box<{}>\", s),\n+                            format!(\"Box<{s}>\"),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                     Err(_) => {\n                         err.span_help(\n                             self.cast_span,\n-                            &format!(\"you might have meant `Box<{}>`\", tstr),\n+                            &format!(\"you might have meant `Box<{tstr}>`\"),\n                         );\n                     }\n                 }\n@@ -678,8 +673,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             ))\n             .help(&format!(\n                 \"cast can be replaced by coercion; this might \\\n-                                   require {}a temporary variable\",\n-                type_asc_or\n+                                   require {type_asc_or}a temporary variable\"\n             ))\n             .emit();\n         });\n@@ -969,21 +963,21 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn cenum_impl_drop_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n-        if let ty::Adt(d, _) = self.expr_ty.kind() {\n-            if d.has_dtor(fcx.tcx) {\n-                fcx.tcx.struct_span_lint_hir(\n-                    lint::builtin::CENUM_IMPL_DROP_CAST,\n-                    self.expr.hir_id,\n-                    self.span,\n-                    |err| {\n-                        err.build(&format!(\n-                            \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n-                            self.expr_ty, self.cast_ty\n-                        ))\n-                        .emit();\n-                    },\n-                );\n-            }\n+        if let ty::Adt(d, _) = self.expr_ty.kind()\n+            && d.has_dtor(fcx.tcx)\n+        {\n+            fcx.tcx.struct_span_lint_hir(\n+                lint::builtin::CENUM_IMPL_DROP_CAST,\n+                self.expr.hir_id,\n+                self.span,\n+                |err| {\n+                    err.build(&format!(\n+                        \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                        self.expr_ty, self.cast_ty\n+                    ))\n+                    .emit();\n+                },\n+            );\n         }\n     }\n \n@@ -1007,7 +1001,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     err.span_suggestion(\n                         self.span,\n                         msg,\n-                        format!(\"({}).addr(){}\", snippet, scalar_cast),\n+                        format!(\"({snippet}).addr(){scalar_cast}\"),\n                         Applicability::MaybeIncorrect\n                     );\n                 } else {\n@@ -1038,7 +1032,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     err.span_suggestion(\n                         self.span,\n                         msg,\n-                        format!(\"(...).with_addr({})\", snippet),\n+                        format!(\"(...).with_addr({snippet})\"),\n                         Applicability::HasPlaceholders,\n                     );\n                 } else {"}, {"sha": "314236b1cdfbcbeec787166b1aac931aee4b9c5b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 153, "deletions": 157, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -43,8 +43,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n                 tcx.sess,\n                 span,\n                 E0570,\n-                \"`{}` is not a supported ABI for the current target\",\n-                abi\n+                \"`{abi}` is not a supported ABI for the current target\",\n             )\n             .emit();\n         }\n@@ -249,84 +248,84 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fcx.demand_suptype(span, declared_ret_ty, actual_return_ty);\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n-        if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n+        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n+            if *declared_ret_ty.kind() != ty::Never {\n+                sess.span_err(decl.output.span(), \"return type should be `!`\");\n+            }\n \n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_panic_info = match *inputs[0].kind() {\n-                        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-                            ty::Adt(ref adt, _) => {\n-                                adt.did() == panic_info_did\n-                                    && mutbl == hir::Mutability::Not\n-                                    && !region.is_static()\n-                            }\n-                            _ => false,\n-                        },\n+            let inputs = fn_sig.inputs();\n+            let span = hir.span(fn_id);\n+            if inputs.len() == 1 {\n+                let arg_is_panic_info = match *inputs[0].kind() {\n+                    ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+                        ty::Adt(ref adt, _) => {\n+                            adt.did() == panic_info_did\n+                                && mutbl == hir::Mutability::Not\n+                                && !region.is_static()\n+                        }\n                         _ => false,\n-                    };\n-\n-                    if !arg_is_panic_info {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-                    }\n+                    },\n+                    _ => false,\n+                };\n \n-                    if let Node::Item(item) = hir.get(fn_id)\n-                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                        && !generics.params.is_empty()\n-                    {\n-                                sess.span_err(span, \"should have no type parameters\");\n-                            }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n+                if !arg_is_panic_info {\n+                    sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                 }\n+\n+                if let Node::Item(item) = hir.get(fn_id)\n+                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                    && !generics.params.is_empty()\n+                {\n+                            sess.span_err(span, \"should have no type parameters\");\n+                        }\n             } else {\n-                sess.err(\"language item required, but not found: `panic_info`\");\n+                let span = sess.source_map().guess_head_span(span);\n+                sess.span_err(span, \"function should have one argument\");\n             }\n+        } else {\n+            sess.err(\"language item required, but not found: `panic_info`\");\n         }\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n-        if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n-            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-                if *declared_ret_ty.kind() != ty::Never {\n-                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n-                }\n-\n-                let inputs = fn_sig.inputs();\n-                let span = hir.span(fn_id);\n-                if inputs.len() == 1 {\n-                    let arg_is_alloc_layout = match inputs[0].kind() {\n-                        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-                        _ => false,\n-                    };\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n+        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n+            if *declared_ret_ty.kind() != ty::Never {\n+                sess.span_err(decl.output.span(), \"return type should be `!`\");\n+            }\n \n-                    if !arg_is_alloc_layout {\n-                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-                    }\n+            let inputs = fn_sig.inputs();\n+            let span = hir.span(fn_id);\n+            if inputs.len() == 1 {\n+                let arg_is_alloc_layout = match inputs[0].kind() {\n+                    ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+                    _ => false,\n+                };\n \n-                    if let Node::Item(item) = hir.get(fn_id)\n-                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n-                        && !generics.params.is_empty()\n-                    {\n-                                sess.span_err(\n-                                    span,\n-                            \"`#[alloc_error_handler]` function should have no type parameters\",\n-                                );\n-                            }\n-                } else {\n-                    let span = sess.source_map().guess_head_span(span);\n-                    sess.span_err(span, \"function should have one argument\");\n+                if !arg_is_alloc_layout {\n+                    sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                 }\n+\n+                if let Node::Item(item) = hir.get(fn_id)\n+                    && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                    && !generics.params.is_empty()\n+                {\n+                            sess.span_err(\n+                                span,\n+                        \"`#[alloc_error_handler]` function should have no type parameters\",\n+                            );\n+                        }\n             } else {\n-                sess.err(\"language item required, but not found: `alloc_layout`\");\n+                let span = sess.source_map().guess_head_span(span);\n+                sess.span_err(span, \"function should have one argument\");\n             }\n+        } else {\n+            sess.err(\"language item required, but not found: `alloc_layout`\");\n         }\n     }\n \n@@ -670,7 +669,7 @@ fn check_opaque_meets_bounds<'tcx>(\n             Err(ty_err) => {\n                 tcx.sess.delay_span_bug(\n                     span,\n-                    &format!(\"could not unify `{}` with revealed type:\\n{}\", hidden_type, ty_err,),\n+                    &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n                 );\n             }\n         }\n@@ -817,10 +816,9 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n                             tcx.sess,\n                             item.span,\n                             E0044,\n-                            \"foreign items may not have {} parameters\",\n-                            kinds,\n+                            \"foreign items may not have {kinds} parameters\",\n                         )\n-                        .span_label(item.span, &format!(\"can't have {} parameters\", kinds))\n+                        .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n                         .help(\n                             // FIXME: once we start storing spans for type arguments, turn this\n                             // into a suggestion.\n@@ -1065,68 +1063,67 @@ pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalD\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n-    if let ty::Adt(def, substs) = t.kind() {\n-        if def.is_struct() {\n-            let fields = &def.non_enum_variant().fields;\n-            if fields.is_empty() {\n+    if let ty::Adt(def, substs) = t.kind()\n+        && def.is_struct()\n+    {\n+        let fields = &def.non_enum_variant().fields;\n+        if fields.is_empty() {\n+            struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n+            return;\n+        }\n+        let e = fields[0].ty(tcx, substs);\n+        if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n+            struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n+                .span_label(sp, \"SIMD elements must have the same type\")\n+                .emit();\n+            return;\n+        }\n+\n+        let len = if let ty::Array(_ty, c) = e.kind() {\n+            c.try_eval_usize(tcx, tcx.param_env(def.did()))\n+        } else {\n+            Some(fields.len() as u64)\n+        };\n+        if let Some(len) = len {\n+            if len == 0 {\n                 struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n                 return;\n-            }\n-            let e = fields[0].ty(tcx, substs);\n-            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n-                struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n-                    .span_label(sp, \"SIMD elements must have the same type\")\n-                    .emit();\n+            } else if len > MAX_SIMD_LANES {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0075,\n+                    \"SIMD vector cannot have more than {MAX_SIMD_LANES} elements\",\n+                )\n+                .emit();\n                 return;\n             }\n+        }\n \n-            let len = if let ty::Array(_ty, c) = e.kind() {\n-                c.try_eval_usize(tcx, tcx.param_env(def.did()))\n-            } else {\n-                Some(fields.len() as u64)\n-            };\n-            if let Some(len) = len {\n-                if len == 0 {\n-                    struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n-                    return;\n-                } else if len > MAX_SIMD_LANES {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0075,\n-                        \"SIMD vector cannot have more than {} elements\",\n-                        MAX_SIMD_LANES,\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-            }\n-\n-            // Check that we use types valid for use in the lanes of a SIMD \"vector register\"\n-            // These are scalar types which directly match a \"machine\" type\n-            // Yes: Integers, floats, \"thin\" pointers\n-            // No: char, \"fat\" pointers, compound types\n-            match e.kind() {\n-                ty::Param(_) => (), // pass struct<T>(T, T, T, T) through, let monomorphization catch errors\n-                ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) => (), // struct(u8, u8, u8, u8) is ok\n-                ty::Array(t, _) if matches!(t.kind(), ty::Param(_)) => (), // pass struct<T>([T; N]) through, let monomorphization catch errors\n-                ty::Array(t, _clen)\n-                    if matches!(\n-                        t.kind(),\n-                        ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_)\n-                    ) =>\n-                { /* struct([f32; 4]) is ok */ }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        sp,\n-                        E0077,\n-                        \"SIMD vector element type should be a \\\n-                         primitive scalar (integer/float/pointer) type\"\n-                    )\n-                    .emit();\n-                    return;\n-                }\n+        // Check that we use types valid for use in the lanes of a SIMD \"vector register\"\n+        // These are scalar types which directly match a \"machine\" type\n+        // Yes: Integers, floats, \"thin\" pointers\n+        // No: char, \"fat\" pointers, compound types\n+        match e.kind() {\n+            ty::Param(_) => (), // pass struct<T>(T, T, T, T) through, let monomorphization catch errors\n+            ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_) => (), // struct(u8, u8, u8, u8) is ok\n+            ty::Array(t, _) if matches!(t.kind(), ty::Param(_)) => (), // pass struct<T>([T; N]) through, let monomorphization catch errors\n+            ty::Array(t, _clen)\n+                if matches!(\n+                    t.kind(),\n+                    ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::RawPtr(_)\n+                ) =>\n+            { /* struct([f32; 4]) is ok */ }\n+            _ => {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0077,\n+                    \"SIMD vector element type should be a \\\n+                        primitive scalar (integer/float/pointer) type\"\n+                )\n+                .emit();\n+                return;\n             }\n         }\n     }\n@@ -1189,7 +1186,7 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n                                     ident\n                                 )\n                             } else {\n-                                format!(\"...which contains a field of type `{}`\", ident)\n+                                format!(\"...which contains a field of type `{ident}`\")\n                             },\n                         );\n                         first = false;\n@@ -1215,13 +1212,12 @@ pub(super) fn check_packed_inner(\n \n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n-                if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n-                    if !stack.contains(&def.did()) {\n-                        if let Some(mut defs) = check_packed_inner(tcx, def.did(), stack) {\n-                            defs.push((def.did(), field.ident(tcx).span));\n-                            return Some(defs);\n-                        }\n-                    }\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind()\n+                    && !stack.contains(&def.did())\n+                    && let Some(mut defs) = check_packed_inner(tcx, def.did(), stack)\n+                {\n+                    defs.push((def.did(), field.ident(tcx).span));\n+                    return Some(defs);\n                 }\n             }\n             stack.pop();\n@@ -1370,8 +1366,8 @@ fn check_enum<'tcx>(\n                 \"discriminant value `{}` already exists\",\n                 discr.val,\n             )\n-            .span_label(i_span, format!(\"first use of {}\", display_discr_i))\n-            .span_label(span, format!(\"enum already has {}\", display_discr))\n+            .span_label(i_span, format!(\"first use of {display_discr_i}\"))\n+            .span_label(span, format!(\"enum already has {display_discr}\"))\n             .emit();\n         }\n         disr_vals.push(discr);\n@@ -1393,7 +1389,7 @@ fn display_discriminant_value<'tcx>(\n             && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n             && evaluated != *lit_value\n         {\n-                    return format!(\"`{}` (overflowed from `{}`)\", evaluated, lit_value);\n+                    return format!(\"`{evaluated}` (overflowed from `{lit_value}`)\");\n         }\n     }\n     format!(\"`{}`\", evaluated)\n@@ -1422,28 +1418,28 @@ pub(super) fn check_type_params_are_used<'tcx>(\n     }\n \n     for leaf in ty.walk() {\n-        if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n-            if let ty::Param(param) = leaf_ty.kind() {\n-                debug!(\"found use of ty param {:?}\", param);\n-                params_used.insert(param.index);\n-            }\n+        if let GenericArgKind::Type(leaf_ty) = leaf.unpack()\n+            && let ty::Param(param) = leaf_ty.kind()\n+        {\n+            debug!(\"found use of ty param {:?}\", param);\n+            params_used.insert(param.index);\n         }\n     }\n \n     for param in &generics.params {\n-        if !params_used.contains(param.index) {\n-            if let ty::GenericParamDefKind::Type { .. } = param.kind {\n-                let span = tcx.def_span(param.def_id);\n-                struct_span_err!(\n-                    tcx.sess,\n-                    span,\n-                    E0091,\n-                    \"type parameter `{}` is unused\",\n-                    param.name,\n-                )\n-                .span_label(span, \"unused type parameter\")\n-                .emit();\n-            }\n+        if !params_used.contains(param.index)\n+            && let ty::GenericParamDefKind::Type { .. } = param.kind\n+        {\n+            let span = tcx.def_span(param.def_id);\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0091,\n+                \"type parameter `{}` is unused\",\n+                param.name,\n+            )\n+            .span_label(span, \"unused type parameter\")\n+            .emit();\n         }\n     }\n }\n@@ -1534,10 +1530,10 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> E\n                 for def_id in visitor.0 {\n                     let ty_span = tcx.def_span(def_id);\n                     if !seen.contains(&ty_span) {\n-                        err.span_label(ty_span, &format!(\"returning this opaque type `{}`\", ty));\n+                        err.span_label(ty_span, &format!(\"returning this opaque type `{ty}`\"));\n                         seen.insert(ty_span);\n                     }\n-                    err.span_label(sp, &format!(\"returning here with type `{}`\", ty));\n+                    err.span_label(sp, &format!(\"returning here with type `{ty}`\"));\n                 }\n             }\n         }"}, {"sha": "3162de38aaea1ca7e0afca8911d43373d1522eb4", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -632,11 +632,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n                         if let (ty::Dynamic(ref data_a, ..), ty::Dynamic(ref data_b, ..)) =\n                             (self_ty.kind(), unsize_ty.kind())\n+                            && data_a.principal_def_id() != data_b.principal_def_id()\n                         {\n-                            if data_a.principal_def_id() != data_b.principal_def_id() {\n-                                debug!(\"coerce_unsized: found trait upcasting coercion\");\n-                                has_trait_upcasting_coercion = true;\n-                            }\n+                            debug!(\"coerce_unsized: found trait upcasting coercion\");\n+                            has_trait_upcasting_coercion = true;\n                         }\n                         if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n@@ -732,13 +731,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        if let ty::FnPtr(fn_ty_b) = b.kind() {\n-            if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n+        if let ty::FnPtr(fn_ty_b) = b.kind()\n+            && let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                 (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n-            {\n-                let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n-                return self.unify_and(unsafe_a, b, to_unsafe);\n-            }\n+        {\n+            let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n+            return self.unify_and(unsafe_a, b, to_unsafe);\n         }\n         self.unify_and(a, b, normal)\n     }\n@@ -783,12 +781,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n \n                 // Safe `#[target_feature]` functions are not assignable to safe fn pointers (RFC 2396).\n-                if let ty::FnDef(def_id, _) = *a.kind() {\n-                    if b_sig.unsafety() == hir::Unsafety::Normal\n-                        && !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n-                    {\n-                        return Err(TypeError::TargetFeatureCast(def_id));\n-                    }\n+                if let ty::FnDef(def_id, _) = *a.kind()\n+                    && b_sig.unsafety() == hir::Unsafety::Normal\n+                    && !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+                {\n+                    return Err(TypeError::TargetFeatureCast(def_id));\n                 }\n \n                 let InferOk { value: a_sig, obligations: o1 } =\n@@ -1540,23 +1537,22 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 fcx.tcx.hir().get_if_cause(expr.hir_id),\n                 expected.is_unit(),\n                 pointing_at_return_type,\n-            ) {\n+            )\n                 // If the block is from an external macro or try (`?`) desugaring, then\n                 // do not suggest adding a semicolon, because there's nowhere to put it.\n                 // See issues #81943 and #87051.\n-                if matches!(\n+                && matches!(\n                     cond_expr.span.desugaring_kind(),\n                     None | Some(DesugaringKind::WhileLoop)\n                 ) && !in_external_macro(fcx.tcx.sess, cond_expr.span)\n                     && !matches!(\n                         cond_expr.kind,\n                         hir::ExprKind::Match(.., hir::MatchSource::TryDesugar)\n                     )\n-                {\n-                    err.span_label(cond_expr.span, \"expected this to be `()`\");\n-                    if expr.can_have_side_effects() {\n-                        fcx.suggest_semicolon_at_end(cond_expr.span, &mut err);\n-                    }\n+            {\n+                err.span_label(cond_expr.span, \"expected this to be `()`\");\n+                if expr.can_have_side_effects() {\n+                    fcx.suggest_semicolon_at_end(cond_expr.span, &mut err);\n                 }\n             }\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n@@ -1636,28 +1632,27 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n         // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n         let mut is_object_safe = false;\n-        if let hir::FnRetTy::Return(ty) = fn_output {\n+        if let hir::FnRetTy::Return(ty) = fn_output\n             // Get the return type.\n-            if let hir::TyKind::OpaqueDef(..) = ty.kind {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n-                // Get the `impl Trait`'s `DefId`.\n-                if let ty::Opaque(def_id, _) = ty.kind() {\n-                    // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n-                    // get the `Trait`'s `DefId`.\n-                    if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n-                        fcx.tcx.hir().expect_item(def_id.expect_local()).kind\n-                    {\n-                        // Are of this `impl Trait`'s traits object safe?\n-                        is_object_safe = bounds.iter().all(|bound| {\n-                            bound\n-                                .trait_ref()\n-                                .and_then(|t| t.trait_def_id())\n-                                .map_or(false, |def_id| {\n-                                    fcx.tcx.object_safety_violations(def_id).is_empty()\n-                                })\n+            && let hir::TyKind::OpaqueDef(..) = ty.kind\n+        {\n+            let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n+            // Get the `impl Trait`'s `DefId`.\n+            if let ty::Opaque(def_id, _) = ty.kind()\n+                // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n+                // get the `Trait`'s `DefId`.\n+                && let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n+                    fcx.tcx.hir().expect_item(def_id.expect_local()).kind\n+            {\n+                // Are of this `impl Trait`'s traits object safe?\n+                is_object_safe = bounds.iter().all(|bound| {\n+                    bound\n+                        .trait_ref()\n+                        .and_then(|t| t.trait_def_id())\n+                        .map_or(false, |def_id| {\n+                            fcx.tcx.object_safety_violations(def_id).is_empty()\n                         })\n-                    }\n-                }\n+                })\n             }\n         };\n         if has_impl {\n@@ -1703,7 +1698,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n             && let ty::Dynamic(..) = ty.kind()\n         {\n-                    return true;\n+            return true;\n         }\n         false\n     }"}, {"sha": "4aa46c21fce91313288e77f433de1eaee71c9b23", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -315,7 +315,7 @@ fn compare_predicate_entailment<'tcx>(\n                         ExplicitSelf::ByReference(_, hir::Mutability::Mut) => {\n                             \"&mut self\".to_owned()\n                         }\n-                        _ => format!(\"self: {}\", ty),\n+                        _ => format!(\"self: {ty}\"),\n                     };\n \n                     // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n@@ -526,7 +526,7 @@ fn compare_self_type<'tcx>(\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n                 ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                _ => format!(\"self: {}\", self_arg_ty),\n+                _ => format!(\"self: {self_arg_ty}\"),\n             }\n         })\n     };\n@@ -544,9 +544,9 @@ fn compare_self_type<'tcx>(\n                 trait_m.name,\n                 self_descr\n             );\n-            err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"`{self_descr}` used in impl\"));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n-                err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n+                err.span_label(span, format!(\"trait method declared without `{self_descr}`\"));\n             } else {\n                 err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n@@ -564,9 +564,9 @@ fn compare_self_type<'tcx>(\n                 trait_m.name,\n                 self_descr\n             );\n-            err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n+            err.span_label(impl_m_span, format!(\"expected `{self_descr}` in impl\"));\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n-                err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n+                err.span_label(span, format!(\"`{self_descr}` used in trait\"));\n             } else {\n                 err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n             }\n@@ -668,7 +668,7 @@ fn compare_number_of_generics<'tcx>(\n                     err.span_label(*span, \"\");\n                 }\n             } else {\n-                suffix = Some(format!(\", expected {}\", trait_count));\n+                suffix = Some(format!(\", expected {trait_count}\"));\n             }\n \n             if let Some(span) = span {\n@@ -873,12 +873,10 @@ fn compare_synthetic_generics<'tcx>(\n                                 intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind\n+                                    && let Res::Def(DefKind::TyParam, def_id) = path.res\n+                                    && def_id == self.1\n                                 {\n-                                    if let Res::Def(DefKind::TyParam, def_id) = path.res {\n-                                        if def_id == self.1 {\n-                                            self.0 = Some(ty.span);\n-                                        }\n-                                    }\n+                                    self.0 = Some(ty.span);\n                                 }\n                             }\n                         }\n@@ -908,7 +906,7 @@ fn compare_synthetic_generics<'tcx>(\n                                 // delete generic parameters\n                                 (impl_m.generics.span, String::new()),\n                                 // replace param usage with `impl Trait`\n-                                (span, format!(\"impl {}\", bounds)),\n+                                (span, format!(\"impl {bounds}\")),\n                             ],\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -972,7 +970,7 @@ fn compare_const_param_types<'tcx>(\n                 &format!(\n                     \"the const parameter{} has type `{}`, but the declaration \\\n                               in trait `{}` has type `{}`\",\n-                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{}`\", ident)),\n+                    &impl_ident.map_or_else(|| \"\".to_string(), |ident| format!(\" `{ident}`\")),\n                     impl_ty,\n                     tcx.def_path_str(trait_m.def_id),\n                     trait_ty"}, {"sha": "7c5a312c40e628589b6529b0ef9e25ef827b98c5", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 131, "deletions": 141, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -241,13 +241,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We are pointing at the binding's type or initializer value, but it's pattern\n                     // is in a different line, so we point at both.\n                     err.span_label(secondary_span, \"expected due to the type of this binding\");\n-                    err.span_label(primary_span, &format!(\"expected due to this{}\", post_message));\n+                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n                 } else if post_message == \"\" {\n                     // We are pointing at either the assignment lhs or the binding def pattern.\n                     err.span_label(primary_span, \"expected due to the type of this binding\");\n                 } else {\n                     // We are pointing at the binding's type or initializer value.\n-                    err.span_label(primary_span, &format!(\"expected due to this{}\", post_message));\n+                    err.span_label(primary_span, &format!(\"expected due to this{post_message}\"));\n                 }\n \n                 if !lhs.is_syntactic_place_expr() {\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     \"try adding an expression at the end of the block\",\n                                     return_suggestions\n                                         .into_iter()\n-                                        .map(|r| format!(\"{}\\n{}{}\", semicolon, indent, r)),\n+                                        .map(|r| format!(\"{semicolon}\\n{indent}{r}\")),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n@@ -344,10 +344,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let variant_path =\n                             with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n                         // FIXME #56861: DRYer prelude filtering\n-                        if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n-                            if let Some((_, path)) = path.split_once(\"::\") {\n-                                return Some(path.to_string());\n-                            }\n+                        if let Some(path) = variant_path.strip_prefix(\"std::prelude::\")\n+                            && let Some((_, path)) = path.split_once(\"::\")\n+                        {\n+                            return Some(path.to_string());\n                         }\n                         Some(variant_path)\n                     } else {\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .collect();\n \n             let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                Some(ident) => format!(\"{}: \", ident),\n+                Some(ident) => format!(\"{ident}: \"),\n                 None => String::new(),\n             };\n \n@@ -366,9 +366,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 [variant] => {\n                     // Just a single matching variant.\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"try wrapping the expression in `{}`\", variant),\n+                        &format!(\"try wrapping the expression in `{variant}`\"),\n                         vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                            (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n                             (expr.span.shrink_to_hi(), \")\".to_string()),\n                         ],\n                         Applicability::MaybeIncorrect,\n@@ -383,7 +383,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                         compatible_variants.into_iter().map(|variant| {\n                             vec![\n-                                (expr.span.shrink_to_lo(), format!(\"{}{}(\", prefix, variant)),\n+                                (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n                                 (expr.span.shrink_to_hi(), \")\".to_string()),\n                             ]\n                         }),\n@@ -680,7 +680,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ if is_range_literal(expr) => true,\n                             _ => false,\n                         };\n-                        let sugg_expr = if needs_parens { format!(\"({})\", src) } else { src };\n+                        let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n \n                         if let Some(sugg) = self.can_use_as_ref(expr) {\n                             return Some((\n@@ -693,7 +693,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{}: \", ident),\n+                            Some(ident) => format!(\"{ident}: \"),\n                             None => String::new(),\n                         };\n \n@@ -727,14 +727,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             hir::Mutability::Mut => (\n                                 sp,\n                                 \"consider mutably borrowing here\".to_string(),\n-                                format!(\"{}&mut {}\", prefix, sugg_expr),\n+                                format!(\"{prefix}&mut {sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\".to_string(),\n-                                format!(\"{}&{}\", prefix, sugg_expr),\n+                                format!(\"{prefix}&{sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n                             ),\n@@ -758,96 +758,94 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let Some(call_span) =\n                         iter::successors(Some(expr.span), |s| s.parent_callsite())\n                             .find(|&s| sp.contains(s))\n+                        && sm.span_to_snippet(call_span).is_ok()\n                     {\n-                        if sm.span_to_snippet(call_span).is_ok() {\n-                            return Some((\n-                                sp.with_hi(call_span.lo()),\n-                                \"consider removing the borrow\".to_string(),\n-                                String::new(),\n-                                Applicability::MachineApplicable,\n-                                true,\n-                            ));\n-                        }\n-                    }\n-                    return None;\n-                }\n-                if sp.contains(expr.span) {\n-                    if sm.span_to_snippet(expr.span).is_ok() {\n                         return Some((\n-                            sp.with_hi(expr.span.lo()),\n+                            sp.with_hi(call_span.lo()),\n                             \"consider removing the borrow\".to_string(),\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n                         ));\n                     }\n+                    return None;\n+                }\n+                if sp.contains(expr.span)\n+                    && sm.span_to_snippet(expr.span).is_ok()\n+                {\n+                    return Some((\n+                        sp.with_hi(expr.span.lo()),\n+                        \"consider removing the borrow\".to_string(),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                        true,\n+                    ));\n                 }\n             }\n             (\n                 _,\n                 &ty::RawPtr(TypeAndMut { ty: ty_b, mutbl: mutbl_b }),\n                 &ty::Ref(_, ty_a, mutbl_a),\n             ) => {\n-                if let Some(steps) = self.deref_steps(ty_a, ty_b) {\n+                if let Some(steps) = self.deref_steps(ty_a, ty_b)\n                     // Only suggest valid if dereferencing needed.\n-                    if steps > 0 {\n-                        // The pointer type implements `Copy` trait so the suggestion is always valid.\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            let derefs = \"*\".repeat(steps);\n-                            if let Some((span, src, applicability)) = match mutbl_b {\n+                    && steps > 0\n+                    // The pointer type implements `Copy` trait so the suggestion is always valid.\n+                    && let Ok(src) = sm.span_to_snippet(sp)\n+                {\n+                    let derefs = \"*\".repeat(steps);\n+                    if let Some((span, src, applicability)) = match mutbl_b {\n+                        hir::Mutability::Mut => {\n+                            let new_prefix = \"&mut \".to_owned() + &derefs;\n+                            match mutbl_a {\n                                 hir::Mutability::Mut => {\n-                                    let new_prefix = \"&mut \".to_owned() + &derefs;\n-                                    match mutbl_a {\n-                                        hir::Mutability::Mut => {\n-                                            replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(5);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                        hir::Mutability::Not => {\n-                                            replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(1);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (\n-                                                    sp,\n-                                                    format!(\"mut {}\", derefs),\n-                                                    Applicability::Unspecified,\n-                                                )\n-                                            })\n-                                        }\n-                                    }\n+                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(5);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n                                 }\n                                 hir::Mutability::Not => {\n-                                    let new_prefix = \"&\".to_owned() + &derefs;\n-                                    match mutbl_a {\n-                                        hir::Mutability::Mut => {\n-                                            replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                                let lo = sp.lo() + BytePos(1);\n-                                                let hi = sp.lo() + BytePos(5);\n-                                                let sp = sp.with_lo(lo).with_hi(hi);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                        hir::Mutability::Not => {\n-                                            replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                                let pos = sp.lo() + BytePos(1);\n-                                                let sp = sp.with_lo(pos).with_hi(pos);\n-                                                (sp, derefs, Applicability::MachineApplicable)\n-                                            })\n-                                        }\n-                                    }\n+                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(1);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (\n+                                            sp,\n+                                            format!(\"mut {derefs}\"),\n+                                            Applicability::Unspecified,\n+                                        )\n+                                    })\n                                 }\n-                            } {\n-                                return Some((\n-                                    span,\n-                                    \"consider dereferencing\".to_string(),\n-                                    src,\n-                                    applicability,\n-                                    true,\n-                                ));\n                             }\n                         }\n+                        hir::Mutability::Not => {\n+                            let new_prefix = \"&\".to_owned() + &derefs;\n+                            match mutbl_a {\n+                                hir::Mutability::Mut => {\n+                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n+                                        let lo = sp.lo() + BytePos(1);\n+                                        let hi = sp.lo() + BytePos(5);\n+                                        let sp = sp.with_lo(lo).with_hi(hi);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n+                                }\n+                                hir::Mutability::Not => {\n+                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n+                                        let pos = sp.lo() + BytePos(1);\n+                                        let sp = sp.with_lo(pos).with_hi(pos);\n+                                        (sp, derefs, Applicability::MachineApplicable)\n+                                    })\n+                                }\n+                            }\n+                        }\n+                    } {\n+                        return Some((\n+                            span,\n+                            \"consider dereferencing\".to_string(),\n+                            src,\n+                            applicability,\n+                            true,\n+                        ));\n                     }\n                 }\n             }\n@@ -908,7 +906,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Suggest removing `&` if we have removed any, otherwise suggest just\n                         // dereferencing the remaining number of steps.\n                         let message = if remove.is_empty() {\n-                            format!(\"consider {}\", deref_kind)\n+                            format!(\"consider {deref_kind}\")\n                         } else {\n                             format!(\n                                 \"consider removing the `{}` and {} instead\",\n@@ -918,7 +916,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n \n                         let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                            Some(ident) => format!(\"{}: \", ident),\n+                            Some(ident) => format!(\"{ident}: \"),\n                             None => String::new(),\n                         };\n \n@@ -994,35 +992,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        if let hir::ExprKind::Call(path, args) = &expr.kind {\n-            if let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n+        if let hir::ExprKind::Call(path, args) = &expr.kind\n+            && let (hir::ExprKind::Path(hir::QPath::TypeRelative(base_ty, path_segment)), 1) =\n                 (&path.kind, args.len())\n-            {\n-                // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n-                if let (hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)), sym::from) =\n-                    (&base_ty.kind, path_segment.ident.name)\n-                {\n-                    if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n-                        match ident.name {\n-                            sym::i128\n-                            | sym::i64\n-                            | sym::i32\n-                            | sym::i16\n-                            | sym::i8\n-                            | sym::u128\n-                            | sym::u64\n-                            | sym::u32\n-                            | sym::u16\n-                            | sym::u8\n-                            | sym::isize\n-                            | sym::usize\n-                                if base_ty_path.segments.len() == 1 =>\n-                            {\n-                                return false;\n-                            }\n-                            _ => {}\n-                        }\n+            // `expr` is a conversion like `u32::from(val)`, do not suggest anything (#63697).\n+            && let (hir::TyKind::Path(hir::QPath::Resolved(None, base_ty_path)), sym::from) =\n+                (&base_ty.kind, path_segment.ident.name)\n+        {\n+            if let Some(ident) = &base_ty_path.segments.iter().map(|s| s.ident).next() {\n+                match ident.name {\n+                    sym::i128\n+                    | sym::i64\n+                    | sym::i32\n+                    | sym::i16\n+                    | sym::i8\n+                    | sym::u128\n+                    | sym::u64\n+                    | sym::u32\n+                    | sym::u16\n+                    | sym::u8\n+                    | sym::isize\n+                    | sym::usize\n+                        if base_ty_path.segments.len() == 1 =>\n+                    {\n+                        return false;\n                     }\n+                    _ => {}\n                 }\n             }\n         }\n@@ -1042,8 +1037,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expected_ty,\n         );\n         let lit_msg = format!(\n-            \"change the type of the numeric literal from `{}` to `{}`\",\n-            checked_ty, expected_ty,\n+            \"change the type of the numeric literal from `{checked_ty}` to `{expected_ty}`\",\n         );\n \n         let close_paren = if expr.precedence().order() < PREC_POSTFIX {\n@@ -1054,10 +1048,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut cast_suggestion = sugg.clone();\n-        cast_suggestion\n-            .push((expr.span.shrink_to_hi(), format!(\"{} as {}\", close_paren, expected_ty)));\n+        cast_suggestion.push((expr.span.shrink_to_hi(), format!(\"{close_paren} as {expected_ty}\")));\n         let mut into_suggestion = sugg.clone();\n-        into_suggestion.push((expr.span.shrink_to_hi(), format!(\"{}.into()\", close_paren)));\n+        into_suggestion.push((expr.span.shrink_to_hi(), format!(\"{close_paren}.into()\")));\n         let mut suffix_suggestion = sugg.clone();\n         suffix_suggestion.push((\n             if matches!(\n@@ -1074,7 +1067,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             if expr.precedence().order() < PREC_POSTFIX {\n                 // Readd `)`\n-                format!(\"{})\", expected_ty)\n+                format!(\"{expected_ty})\")\n             } else {\n                 expected_ty.to_string()\n             },\n@@ -1108,20 +1101,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (lhs_expr_and_src, exp_to_found_is_fallible)\n                 {\n                     let msg = format!(\n-                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n-                        lhs_src, expected_ty, checked_ty, src\n+                        \"you can convert `{lhs_src}` from `{expected_ty}` to `{checked_ty}`, matching the type of `{src}`\",\n                     );\n                     let suggestion = vec![\n-                        (lhs_expr.span.shrink_to_lo(), format!(\"{}::from(\", checked_ty)),\n+                        (lhs_expr.span.shrink_to_lo(), format!(\"{checked_ty}::from(\")),\n                         (lhs_expr.span.shrink_to_hi(), \")\".to_string()),\n                     ];\n                     (msg, suggestion)\n                 } else {\n-                    let msg = format!(\"{} and panic if the converted value doesn't fit\", msg);\n+                    let msg = format!(\"{msg} and panic if the converted value doesn't fit\");\n                     let mut suggestion = sugg.clone();\n                     suggestion.push((\n                         expr.span.shrink_to_hi(),\n-                        format!(\"{}.try_into().unwrap()\", close_paren),\n+                        format!(\"{close_paren}.try_into().unwrap()\"),\n                     ));\n                     (msg, suggestion)\n                 };\n@@ -1151,7 +1143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We now know that converting either the lhs or rhs is fallible. Before we\n                     // suggest a fallible conversion, check if the value can never fit in the\n                     // expected type.\n-                    let msg = format!(\"`{}` cannot fit into type `{}`\", src, expected_ty);\n+                    let msg = format!(\"`{src}` cannot fit into type `{expected_ty}`\");\n                     err.note(&msg);\n                     return;\n                 } else if in_const_context {\n@@ -1229,7 +1221,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else if can_cast {\n                     // Missing try_into implementation for `f64` to `f32`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{}, producing the closest possible value\", cast_msg),\n+                        &format!(\"{cast_msg}, producing the closest possible value\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1246,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 } else if can_cast {\n                     // Missing try_into implementation for `{float}` to `{integer}`\n                     err.multipart_suggestion_verbose(\n-                        &format!(\"{}, rounding the float towards zero\", msg),\n+                        &format!(\"{msg}, rounding the float towards zero\"),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n                     );\n@@ -1258,8 +1250,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if exp.bit_width() > found.bit_width().unwrap_or(256) {\n                     err.multipart_suggestion_verbose(\n                         &format!(\n-                            \"{}, producing the floating point representation of the integer\",\n-                            msg,\n+                            \"{msg}, producing the floating point representation of the integer\",\n                         ),\n                         into_suggestion,\n                         Applicability::MachineApplicable,\n@@ -1274,9 +1265,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Missing try_into implementation for `{integer}` to `{float}`\n                     err.multipart_suggestion_verbose(\n                         &format!(\n-                            \"{}, producing the floating point representation of the integer, \\\n+                            \"{cast_msg}, producing the floating point representation of the integer, \\\n                                  rounded if necessary\",\n-                            cast_msg,\n                         ),\n                         cast_suggestion,\n                         Applicability::MaybeIncorrect, // lossy conversion\n@@ -1321,7 +1311,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &ty::Char,\n             ) => {\n                 err.multipart_suggestion_verbose(\n-                    &format!(\"{}, since a `char` always occupies 4 bytes\", cast_msg,),\n+                    &format!(\"{cast_msg}, since a `char` always occupies 4 bytes\"),\n                     cast_suggestion,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1333,22 +1323,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     // Report the type inferred by the return statement.\n     fn report_closure_inferred_return_type(&self, err: &mut Diagnostic, expected: Ty<'tcx>) {\n-        if let Some(sp) = self.ret_coercion_span.get() {\n+        if let Some(sp) = self.ret_coercion_span.get()\n             // If the closure has an explicit return type annotation, or if\n             // the closure's return type has been inferred from outside\n             // requirements (such as an Fn* trait bound), then a type error\n             // may occur at the first return expression we see in the closure\n             // (if it conflicts with the declared return type). Skip adding a\n             // note in this case, since it would be incorrect.\n-            if !self.return_type_pre_known {\n-                err.span_note(\n-                    sp,\n-                    &format!(\n-                        \"return type inferred to be `{}` here\",\n-                        self.resolve_vars_if_possible(expected)\n-                    ),\n-                );\n-            }\n+            && !self.return_type_pre_known\n+        {\n+            err.span_note(\n+                sp,\n+                &format!(\n+                    \"return type inferred to be `{}` here\",\n+                    self.resolve_vars_if_possible(expected)\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "3bc92166543d4a2ece577248c035d740abc0bc1e", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -57,7 +57,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             let span = tcx.def_span(drop_impl_did);\n             let reported = tcx.sess.delay_span_bug(\n                 span,\n-                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type),\n+                &format!(\"should have been rejected by coherence check: {dtor_self_type}\"),\n             );\n             Err(reported)\n         }\n@@ -104,8 +104,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                     item_span,\n                     &format!(\n                         \"use the same sequence of generic type, lifetime and const parameters \\\n-                        as the {} definition\",\n-                        self_descr,\n+                        as the {self_descr} definition\",\n                     ),\n                 )\n                 .emit();\n@@ -262,9 +261,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                 tcx.sess,\n                 predicate_sp,\n                 E0367,\n-                \"`Drop` impl requires `{}` but the {} it is implemented for does not\",\n-                predicate,\n-                self_descr,\n+                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n             )\n             .span_note(item_span, \"the implementor must specify the same requirement\")\n             .emit();"}, {"sha": "4d15dd715f1fcf61b8ea8ade03cd4f1395a9c06c", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 54, "deletions": 69, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -181,13 +181,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // make this code only run with -Zverbose because it is probably slow\n             if let Ok(lint_str) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n                 if !lint_str.contains('\\n') {\n-                    debug!(\"expr text: {}\", lint_str);\n+                    debug!(\"expr text: {lint_str}\");\n                 } else {\n                     let mut lines = lint_str.lines();\n                     if let Some(line0) = lines.next() {\n                         let remaining_lines = lines.count();\n-                        debug!(\"expr text: {}\", line0);\n-                        debug!(\"expr text: ...(and {} more lines)\", remaining_lines);\n+                        debug!(\"expr text: {line0}\");\n+                        debug!(\"expr text: ...(and {remaining_lines} more lines)\");\n                     }\n                 }\n             }\n@@ -375,8 +375,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             expr.span,\n                             oprnd_t,\n                             E0614,\n-                            \"type `{}` cannot be dereferenced\",\n-                            oprnd_t,\n+                            \"type `{oprnd_t}` cannot be dereferenced\",\n                         );\n                         let sp = tcx.sess.source_map().start_point(expr.span);\n                         if let Some(sp) =\n@@ -652,7 +651,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 err.span_suggestion(\n                                     expr.span,\n                                     \"give it a value of the expected type\",\n-                                    format!(\"break{} {}\", label, val),\n+                                    format!(\"break{label} {val}\"),\n                                     Applicability::HasPlaceholders,\n                                 );\n                             }\n@@ -780,7 +779,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                             db.span_label(\n                                 span,\n-                                format!(\"expected `{}` because of this return type\", snippet),\n+                                format!(\"expected `{snippet}` because of this return type\"),\n                             );\n                         }\n                     },\n@@ -1611,15 +1610,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut truncated_fields_error = String::new();\n         let remaining_fields_names = match &displayable_field_names[..] {\n             [field1] => format!(\"`{}`\", field1),\n-            [field1, field2] => format!(\"`{}` and `{}`\", field1, field2),\n-            [field1, field2, field3] => format!(\"`{}`, `{}` and `{}`\", field1, field2, field3),\n+            [field1, field2] => format!(\"`{field1}` and `{field2}`\"),\n+            [field1, field2, field3] => format!(\"`{field1}`, `{field2}` and `{field3}`\"),\n             _ => {\n                 truncated_fields_error =\n                     format!(\" and {} other field{}\", len - 3, pluralize!(len - 3));\n                 displayable_field_names\n                     .iter()\n                     .take(3)\n-                    .map(|n| format!(\"`{}`\", n))\n+                    .map(|n| format!(\"`{n}`\"))\n                     .collect::<Vec<_>>()\n                     .join(\", \")\n             }\n@@ -1635,10 +1634,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             truncated_fields_error,\n             adt_ty\n         );\n-        err.span_label(\n-            span,\n-            format!(\"missing {}{}\", remaining_fields_names, truncated_fields_error),\n-        );\n+        err.span_label(span, format!(\"missing {remaining_fields_names}{truncated_fields_error}\"));\n \n         // If the last field is a range literal, but it isn't supposed to be, then they probably\n         // meant to use functional update syntax.\n@@ -1693,8 +1689,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             &format!(\n-                \"cannot construct `{}` with struct literal syntax due to inaccessible fields\",\n-                adt_ty,\n+                \"cannot construct `{adt_ty}` with struct literal syntax due to inaccessible fields\",\n             ),\n         );\n     }\n@@ -1807,7 +1802,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             } else {\n                                 err.span_label(\n                                     field.ident.span,\n-                                    format!(\"`{}` does not have this field\", ty),\n+                                    format!(\"`{ty}` does not have this field\"),\n                                 );\n                             }\n                             let available_field_names =\n@@ -1973,8 +1968,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 field.span,\n                 expr_t,\n                 E0610,\n-                \"`{}` is a primitive type and therefore doesn't have fields\",\n-                expr_t\n+                \"`{expr_t}` is a primitive type and therefore doesn't have fields\",\n             )\n             .emit();\n         }\n@@ -2018,7 +2012,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n         if add_label {\n-            err.span_label(field_ident.span, &format!(\"field not found in `{}`\", ty));\n+            err.span_label(field_ident.span, &format!(\"field not found in `{ty}`\"));\n         }\n     }\n \n@@ -2077,18 +2071,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx().sess,\n             field.span,\n             E0616,\n-            \"field `{}` of {} `{}` is private\",\n-            field,\n-            kind_name,\n-            struct_path\n+            \"field `{field}` of {kind_name} `{struct_path}` is private\",\n         );\n         err.span_label(field.span, \"private field\");\n         // Also check if an accessible method exists, which is often what is meant.\n         if self.method_exists(field, expr_t, expr.hir_id, false) && !self.expr_in_place(expr.hir_id)\n         {\n             self.suggest_method_call(\n                 &mut err,\n-                &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                &format!(\"a method `{field}` also exists, call it with parentheses\"),\n                 field,\n                 expr_t,\n                 expr,\n@@ -2104,9 +2095,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             field.span,\n             expr_t,\n             E0615,\n-            \"attempted to take value of method `{}` on type `{}`\",\n-            field,\n-            expr_t\n+            \"attempted to take value of method `{field}` on type `{expr_t}`\",\n         );\n         err.span_label(field.span, \"method, not a field\");\n         let expr_is_call =\n@@ -2150,27 +2139,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             let mut found = false;\n \n-            if let ty::RawPtr(ty_and_mut) = expr_t.kind() {\n-                if let ty::Adt(adt_def, _) = ty_and_mut.ty.kind() {\n-                    if adt_def.variants().len() == 1\n-                        && adt_def\n-                            .variants()\n-                            .iter()\n-                            .next()\n-                            .unwrap()\n-                            .fields\n-                            .iter()\n-                            .any(|f| f.ident(self.tcx) == field)\n-                    {\n-                        if let Some(dot_loc) = expr_snippet.rfind('.') {\n-                            found = true;\n-                            err.span_suggestion(\n-                                expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n-                                \"to access the field, dereference first\",\n-                                format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n+            if let ty::RawPtr(ty_and_mut) = expr_t.kind()\n+                && let ty::Adt(adt_def, _) = ty_and_mut.ty.kind()\n+            {\n+                if adt_def.variants().len() == 1\n+                    && adt_def\n+                        .variants()\n+                        .iter()\n+                        .next()\n+                        .unwrap()\n+                        .fields\n+                        .iter()\n+                        .any(|f| f.ident(self.tcx) == field)\n+                {\n+                    if let Some(dot_loc) = expr_snippet.rfind('.') {\n+                        found = true;\n+                        err.span_suggestion(\n+                            expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n+                            \"to access the field, dereference first\",\n+                            format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n                 }\n             }\n@@ -2197,7 +2186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let param_span = self.tcx.hir().span(param_hir_id);\n         let param_name = self.tcx.hir().ty_param_name(param_def_id.expect_local());\n \n-        err.span_label(param_span, &format!(\"type parameter '{}' declared here\", param_name));\n+        err.span_label(param_span, &format!(\"type parameter '{param_name}' declared here\"));\n     }\n \n     fn suggest_fields_on_recordish(\n@@ -2239,17 +2228,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         if let (Some(len), Ok(user_index)) =\n             (len.try_eval_usize(self.tcx, self.param_env), field.as_str().parse::<u64>())\n+            && let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span)\n         {\n-            if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n-                let help = \"instead of using tuple indexing, use array indexing\";\n-                let suggestion = format!(\"{}[{}]\", base, field);\n-                let applicability = if len < user_index {\n-                    Applicability::MachineApplicable\n-                } else {\n-                    Applicability::MaybeIncorrect\n-                };\n-                err.span_suggestion(expr.span, help, suggestion, applicability);\n-            }\n+            let help = \"instead of using tuple indexing, use array indexing\";\n+            let suggestion = format!(\"{base}[{field}]\");\n+            let applicability = if len < user_index {\n+                Applicability::MachineApplicable\n+            } else {\n+                Applicability::MaybeIncorrect\n+            };\n+            err.span_suggestion(expr.span, help, suggestion, applicability);\n         }\n     }\n \n@@ -2261,8 +2249,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n     ) {\n         if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n-            let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-            let suggestion = format!(\"(*{}).{}\", base, field);\n+            let msg = format!(\"`{base}` is a raw pointer; try dereferencing it\");\n+            let suggestion = format!(\"(*{base}).{field}\");\n             err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n         }\n     }\n@@ -2281,9 +2269,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             field.span,\n             expr_t,\n             E0609,\n-            \"no field `{}` on type `{}`\",\n-            field,\n-            expr_t\n+            \"no field `{field}` on type `{expr_t}`\",\n         );\n \n         // try to add a suggestion in case the field is a nested field of a field of the Adt\n@@ -2307,7 +2293,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         field.span.shrink_to_lo(),\n                         \"one of the expressions' fields has a field of the same name\",\n-                        format!(\"{}.\", field_path_str),\n+                        format!(\"{field_path_str}.\"),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n@@ -2419,8 +2405,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         expr.span,\n                         base_t,\n                         E0608,\n-                        \"cannot index into a value of type `{}`\",\n-                        base_t\n+                        \"cannot index into a value of type `{base_t}`\",\n                     );\n                     // Try to give some advice about indexing tuples.\n                     if let ty::Tuple(..) = base_t.kind() {\n@@ -2434,7 +2419,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         expr.span,\n                                         \"to access tuple elements, use\",\n-                                        format!(\"{}.{}\", snip, i),\n+                                        format!(\"{snip}.{i}\"),\n                                         Applicability::MachineApplicable,\n                                     );\n                                     needs_note = false;"}, {"sha": "9c702610888807edf93db00027866e1abda7f622", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -415,8 +415,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .get_if_local(def_id)\n                     .and_then(|node| node.body_id())\n                     .into_iter()\n-                    .map(|id| tcx.hir().body(id).params)\n-                    .flatten();\n+                    .flat_map(|id| tcx.hir().body(id).params)\n+                    ;\n \n                 for param in params {\n                     spans.push_span_label(param.span, String::new());"}, {"sha": "62518408b8b3097d3003936e6ccc6ced2322ace7", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -646,7 +646,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // now get all predicates in the same types as the where bounds, so we can chain them\n         let predicates_from_where =\n-            where_predicates.iter().flatten().map(|bounds| bounds.iter()).flatten();\n+            where_predicates.iter().flatten().flat_map(|bounds| bounds.iter());\n \n         // extract all bounds from the source code using their spans\n         let all_matching_bounds_strs = expected_generic_param"}, {"sha": "15edc11a4974d53e26a4c42b9e8a3f90868f70ec", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         self.expr_count += 1;\n \n         if let PatKind::Binding(..) = pat.kind {\n-            let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n+            let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n             let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n             self.record(ty, pat.hir_id, Some(scope), None, pat.span, false);\n         }\n@@ -567,7 +567,7 @@ pub fn check_must_not_suspend_ty<'tcx>(\n                 _ => None,\n             };\n             for (i, ty) in fields.iter().enumerate() {\n-                let descr_post = &format!(\" in tuple element {}\", i);\n+                let descr_post = &format!(\" in tuple element {i}\");\n                 let span = comps.and_then(|c| c.get(i)).map(|e| e.span).unwrap_or(data.source_span);\n                 if check_must_not_suspend_ty(\n                     fcx,"}, {"sha": "78e7758067942c3f16a45c11b5cafd39daa71b6a", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -484,14 +484,14 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n                 }\n                 Err(_) => {\n                     let msg =\n-                        format!(\"unrecognized platform-specific intrinsic function: `{}`\", name);\n+                        format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n                     tcx.sess.struct_span_err(it.span, &msg).emit();\n                     return;\n                 }\n             }\n         }\n         _ => {\n-            let msg = format!(\"unrecognized platform-specific intrinsic function: `{}`\", name);\n+            let msg = format!(\"unrecognized platform-specific intrinsic function: `{name}`\");\n             tcx.sess.struct_span_err(it.span, &msg).emit();\n             return;\n         }"}, {"sha": "2921176ca4b38e02e7acd0d2211fac3e0bc49152", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 21, "deletions": 125, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -8,7 +8,7 @@ use rustc_errors::{\n     MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1473,12 +1473,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_use_candidates(\n-        &self,\n-        err: &mut Diagnostic,\n-        mut msg: String,\n-        candidates: Vec<DefId>,\n-    ) {\n+    fn suggest_use_candidates(&self, err: &mut Diagnostic, msg: String, candidates: Vec<DefId>) {\n         let parent_map = self.tcx.visible_parent_map(());\n \n         // Separate out candidates that must be imported with a glob, because they are named `_`\n@@ -1502,80 +1497,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         });\n \n         let module_did = self.tcx.parent_module(self.body_id);\n-        let (span, found_use) = find_use_placement(self.tcx, module_did);\n-        if let Some(span) = span {\n-            let path_strings = candidates.iter().map(|trait_did| {\n-                // Produce an additional newline to separate the new use statement\n-                // from the directly following item.\n-                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n-                format!(\n-                    \"use {};\\n{}\",\n-                    with_crate_prefix!(self.tcx.def_path_str(*trait_did)),\n-                    additional_newline\n-                )\n-            });\n+        let (module, _, _) = self.tcx.hir().get_module(module_did);\n+        let span = module.spans.inject_use_span;\n \n-            let glob_path_strings = globs.iter().map(|trait_did| {\n-                let parent_did = parent_map.get(trait_did).unwrap();\n+        let path_strings = candidates.iter().map(|trait_did| {\n+            format!(\"use {};\\n\", with_crate_prefix!(self.tcx.def_path_str(*trait_did)),)\n+        });\n \n-                // Produce an additional newline to separate the new use statement\n-                // from the directly following item.\n-                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n-                format!(\n-                    \"use {}::*; // trait {}\\n{}\",\n-                    with_crate_prefix!(self.tcx.def_path_str(*parent_did)),\n-                    self.tcx.item_name(*trait_did),\n-                    additional_newline\n-                )\n-            });\n+        let glob_path_strings = globs.iter().map(|trait_did| {\n+            let parent_did = parent_map.get(trait_did).unwrap();\n+            format!(\n+                \"use {}::*; // trait {}\\n\",\n+                with_crate_prefix!(self.tcx.def_path_str(*parent_did)),\n+                self.tcx.item_name(*trait_did),\n+            )\n+        });\n \n-            err.span_suggestions(\n-                span,\n-                &msg,\n-                path_strings.chain(glob_path_strings),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            let limit = if candidates.len() + globs.len() == 5 { 5 } else { 4 };\n-            for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                if candidates.len() + globs.len() > 1 {\n-                    msg.push_str(&format!(\n-                        \"\\ncandidate #{}: `use {};`\",\n-                        i + 1,\n-                        with_crate_prefix!(self.tcx.def_path_str(*trait_did))\n-                    ));\n-                } else {\n-                    msg.push_str(&format!(\n-                        \"\\n`use {};`\",\n-                        with_crate_prefix!(self.tcx.def_path_str(*trait_did))\n-                    ));\n-                }\n-            }\n-            for (i, trait_did) in\n-                globs.iter().take(limit.saturating_sub(candidates.len())).enumerate()\n-            {\n-                let parent_did = parent_map.get(trait_did).unwrap();\n-\n-                if candidates.len() + globs.len() > 1 {\n-                    msg.push_str(&format!(\n-                        \"\\ncandidate #{}: `use {}::*; // trait {}`\",\n-                        candidates.len() + i + 1,\n-                        with_crate_prefix!(self.tcx.def_path_str(*parent_did)),\n-                        self.tcx.item_name(*trait_did),\n-                    ));\n-                } else {\n-                    msg.push_str(&format!(\n-                        \"\\n`use {}::*; // trait {}`\",\n-                        with_crate_prefix!(self.tcx.def_path_str(*parent_did)),\n-                        self.tcx.item_name(*trait_did),\n-                    ));\n-                }\n-            }\n-            if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() + globs.len() - limit));\n-            }\n-            err.note(&msg);\n-        }\n+        err.span_suggestions(\n+            span,\n+            &msg,\n+            path_strings.chain(glob_path_strings),\n+            Applicability::MaybeIncorrect,\n+        );\n     }\n \n     fn suggest_valid_traits(\n@@ -2106,53 +2049,6 @@ pub fn all_traits(tcx: TyCtxt<'_>) -> Vec<TraitInfo> {\n     tcx.all_traits().map(|def_id| TraitInfo { def_id }).collect()\n }\n \n-fn find_use_placement<'tcx>(tcx: TyCtxt<'tcx>, target_module: LocalDefId) -> (Option<Span>, bool) {\n-    // FIXME(#94854): this code uses an out-of-date method for inferring a span\n-    // to suggest. It would be better to thread the ModSpans from the AST into\n-    // the HIR, and then use that to drive the suggestion here.\n-\n-    let mut span = None;\n-    let mut found_use = false;\n-    let (module, _, _) = tcx.hir().get_module(target_module);\n-\n-    // Find a `use` statement.\n-    for &item_id in module.item_ids {\n-        let item = tcx.hir().item(item_id);\n-        match item.kind {\n-            hir::ItemKind::Use(..) => {\n-                // Don't suggest placing a `use` before the prelude\n-                // import or other generated ones.\n-                if !item.span.from_expansion() {\n-                    span = Some(item.span.shrink_to_lo());\n-                    found_use = true;\n-                    break;\n-                }\n-            }\n-            // Don't place `use` before `extern crate`...\n-            hir::ItemKind::ExternCrate(_) => {}\n-            // ...but do place them before the first other item.\n-            _ => {\n-                if span.map_or(true, |span| item.span < span) {\n-                    if !item.span.from_expansion() {\n-                        span = Some(item.span.shrink_to_lo());\n-                        // Don't insert between attributes and an item.\n-                        let attrs = tcx.hir().attrs(item.hir_id());\n-                        // Find the first attribute on the item.\n-                        // FIXME: This is broken for active attributes.\n-                        for attr in attrs {\n-                            if !attr.span.is_dummy() && span.map_or(true, |span| attr.span < span) {\n-                                span = Some(attr.span.shrink_to_lo());\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    (span, found_use)\n-}\n-\n fn print_disambiguation_help<'tcx>(\n     item_name: Ident,\n     args: Option<&'tcx [hir::Expr<'tcx>]>,"}, {"sha": "043472e37f5f4ee6f5df89818bdb52493f0281dc", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -553,13 +553,13 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id()) {\n-        if alloc.inner().relocations().len() != 0 {\n-            let msg = \"statics with a custom `#[link_section]` must be a \\\n-                           simple list of bytes on the wasm target with no \\\n-                           extra levels of indirection such as references\";\n-            tcx.sess.span_err(span, msg);\n-        }\n+    if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id())\n+        && alloc.inner().relocations().len() != 0\n+    {\n+        let msg = \"statics with a custom `#[link_section]` must be a \\\n+                        simple list of bytes on the wasm target with no \\\n+                        extra levels of indirection such as references\";\n+        tcx.sess.span_err(span, msg);\n     }\n }\n \n@@ -587,7 +587,7 @@ fn report_forbidden_specialization(\n             ));\n         }\n         Err(cname) => {\n-            err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n+            err.note(&format!(\"parent implementation is in crate `{cname}`\"));\n         }\n     }\n \n@@ -610,10 +610,9 @@ fn missing_items_err(\n         tcx.sess,\n         impl_span,\n         E0046,\n-        \"not all trait items implemented, missing: `{}`\",\n-        missing_items_msg\n+        \"not all trait items implemented, missing: `{missing_items_msg}`\",\n     );\n-    err.span_label(impl_span, format!(\"missing `{}` in implementation\", missing_items_msg));\n+    err.span_label(impl_span, format!(\"missing `{missing_items_msg}` in implementation\"));\n \n     // `Span` before impl block closing brace.\n     let hi = full_impl_span.hi() - BytePos(1);\n@@ -628,7 +627,7 @@ fn missing_items_err(\n     for trait_item in missing_items {\n         let snippet = suggestion_signature(trait_item, tcx);\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n-        let msg = format!(\"implement the missing item: `{}`\", snippet);\n+        let msg = format!(\"implement the missing item: `{snippet}`\");\n         let appl = Applicability::HasPlaceholders;\n         if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n             err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n@@ -653,10 +652,9 @@ fn missing_items_must_implement_one_of_err(\n         tcx.sess,\n         impl_span,\n         E0046,\n-        \"not all trait items implemented, missing one of: `{}`\",\n-        missing_items_msg\n+        \"not all trait items implemented, missing one of: `{missing_items_msg}`\",\n     );\n-    err.span_label(impl_span, format!(\"missing one of `{}` in implementation\", missing_items_msg));\n+    err.span_label(impl_span, format!(\"missing one of `{missing_items_msg}` in implementation\"));\n \n     if let Some(annotation_span) = annotation_span {\n         err.span_note(annotation_span, \"required because of this annotation\");\n@@ -749,27 +747,28 @@ fn fn_sig_suggestion<'tcx>(\n             Some(match ty.kind() {\n                 ty::Param(_) if assoc.fn_has_self_parameter && i == 0 => \"self\".to_string(),\n                 ty::Ref(reg, ref_ty, mutability) if i == 0 => {\n-                    let reg = match &format!(\"{}\", reg)[..] {\n-                        \"'_\" | \"\" => String::new(),\n-                        reg => format!(\"{} \", reg),\n+                    let reg = format!(\"{reg} \");\n+                    let reg = match &reg[..] {\n+                        \"'_ \" | \" \" => \"\",\n+                        reg => reg,\n                     };\n                     if assoc.fn_has_self_parameter {\n                         match ref_ty.kind() {\n                             ty::Param(param) if param.name == kw::SelfUpper => {\n                                 format!(\"&{}{}self\", reg, mutability.prefix_str())\n                             }\n \n-                            _ => format!(\"self: {}\", ty),\n+                            _ => format!(\"self: {ty}\"),\n                         }\n                     } else {\n-                        format!(\"_: {}\", ty)\n+                        format!(\"_: {ty}\")\n                     }\n                 }\n                 _ => {\n                     if assoc.fn_has_self_parameter && i == 0 {\n-                        format!(\"self: {}\", ty)\n+                        format!(\"self: {ty}\")\n                     } else {\n-                        format!(\"_: {}\", ty)\n+                        format!(\"_: {ty}\")\n                     }\n                 }\n             })\n@@ -779,7 +778,7 @@ fn fn_sig_suggestion<'tcx>(\n         .collect::<Vec<String>>()\n         .join(\", \");\n     let output = sig.output();\n-    let output = if !output.is_unit() { format!(\" -> {}\", output) } else { String::new() };\n+    let output = if !output.is_unit() { format!(\" -> {output}\") } else { String::new() };\n \n     let unsafety = sig.unsafety.prefix_str();\n     let (generics, where_clauses) = bounds_from_generic_predicates(tcx, predicates);\n@@ -789,10 +788,7 @@ fn fn_sig_suggestion<'tcx>(\n     // lifetimes between the `impl` and the `trait`, but this should be good enough to\n     // fill in a significant portion of the missing code, and other subsequent\n     // suggestions can help the user fix the code.\n-    format!(\n-        \"{}fn {}{}({}){}{} {{ todo!() }}\",\n-        unsafety, ident, generics, args, output, where_clauses\n-    )\n+    format!(\"{unsafety}fn {ident}{generics}({args}){output}{where_clauses} {{ todo!() }}\")\n }\n \n /// Return placeholder code for the given associated item.\n@@ -830,7 +826,7 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>, sp: Span, d\n         .map(|variant| tcx.hir().span_if_local(variant.def_id).unwrap())\n         .collect();\n     let msg = format!(\"needs exactly one variant, but has {}\", adt.variants().len(),);\n-    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n+    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {msg}\");\n     err.span_label(sp, &msg);\n     if let [start @ .., end] = &*variant_spans {\n         for variant_span in start {\n@@ -850,7 +846,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     field_spans: impl Iterator<Item = Span>,\n     sp: Span,\n ) {\n-    let msg = format!(\"needs at most one non-zero-sized field, but has {}\", field_count);\n+    let msg = format!(\"needs at most one non-zero-sized field, but has {field_count}\");\n     let mut err = struct_span_err!(\n         tcx.sess,\n         sp,\n@@ -877,7 +873,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n         tcx.sess\n             .source_map()\n             .span_to_snippet(span)\n-            .map_or_else(|_| String::new(), |s| format!(\" `{}`\", s)),\n+            .map_or_else(|_| String::new(), |s| format!(\" `{s}`\",)),\n     )\n     .emit();\n }"}, {"sha": "f3dcf5fff74cc39bd4562826d12b1263616f6d73", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -405,16 +405,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut pat_ty = ty;\n         if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n             let expected = self.structurally_resolved_type(span, expected);\n-            if let ty::Ref(_, inner_ty, _) = expected.kind() {\n-                if matches!(inner_ty.kind(), ty::Slice(_)) {\n-                    let tcx = self.tcx;\n-                    trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n-                    self.typeck_results\n-                        .borrow_mut()\n-                        .treat_byte_string_as_slice\n-                        .insert(lt.hir_id.local_id);\n-                    pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n-                }\n+            if let ty::Ref(_, inner_ty, _) = expected.kind()\n+                && matches!(inner_ty.kind(), ty::Slice(_))\n+            {\n+                let tcx = self.tcx;\n+                trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n+                self.typeck_results\n+                    .borrow_mut()\n+                    .treat_byte_string_as_slice\n+                    .insert(lt.hir_id.local_id);\n+                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n             }\n         }\n \n@@ -481,14 +481,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Unify each side with `expected`.\n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x: &mut _, y| {\n-            if let Some((ref mut fail, x_ty, x_span)) = *x {\n-                if let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti) {\n-                    if let Some((_, y_ty, y_span)) = y {\n-                        self.endpoint_has_type(&mut err, y_span, y_ty);\n-                    }\n-                    err.emit();\n-                    *fail = true;\n-                };\n+            if let Some((ref mut fail, x_ty, x_span)) = *x\n+                && let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti)\n+            {\n+                if let Some((_, y_ty, y_span)) = y {\n+                    self.endpoint_has_type(&mut err, y_span, y_ty);\n+                }\n+                err.emit();\n+                *fail = true;\n             }\n         };\n         demand_eqtype(&mut lhs, rhs);\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, var_ty, ty, ti) {\n             let hir = self.tcx.hir();\n             let var_ty = self.resolve_vars_with_obligations(var_ty);\n-            let msg = format!(\"first introduced with type `{}` here\", var_ty);\n+            let msg = format!(\"first introduced with type `{var_ty}` here\");\n             err.span_label(hir.span(var_id), msg);\n             let in_match = hir.parent_iter(var_id).any(|(_, n)| {\n                 matches!(\n@@ -665,8 +665,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     err.span_suggestion(\n                         *span,\n-                        &format!(\"did you mean `{}`\", snippet),\n-                        format!(\" &{}\", expected),\n+                        &format!(\"did you mean `{snippet}`\"),\n+                        format!(\" &{expected}\"),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n@@ -701,7 +701,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"type `{}` cannot be dereferenced\",\n                         type_str\n                     );\n-                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    err.span_label(span, format!(\"type `{type_str}` cannot be dereferenced\"));\n                     if self.tcx.sess.teach(&err.get_code().unwrap()) {\n                         err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n                     }\n@@ -918,7 +918,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 path_str\n             );\n \n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{msg}\");\n             match res {\n                 Res::Def(DefKind::Fn | DefKind::AssocFn, _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n@@ -1396,8 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     pat.span,\n                     E0769,\n-                    \"tuple variant `{}` written as struct variant\",\n-                    path\n+                    \"tuple variant `{path}` written as struct variant\",\n                 );\n                 err.span_suggestion_verbose(\n                     qpath.span().shrink_to_hi().to(pat.span.shrink_to_hi()),\n@@ -1422,8 +1421,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             sess,\n             pat.span,\n             E0638,\n-            \"`..` required with {} marked as non-exhaustive\",\n-            descr\n+            \"`..` required with {descr} marked as non-exhaustive\",\n         );\n         err.span_suggestion_verbose(\n             sp_comma,\n@@ -1442,8 +1440,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"field `{}` bound multiple times in the pattern\",\n             ident\n         )\n-        .span_label(span, format!(\"multiple uses of `{}` in pattern\", ident))\n-        .span_label(other_field, format!(\"first use of `{}`\", ident))\n+        .span_label(span, format!(\"multiple uses of `{ident}` in pattern\"))\n+        .span_label(other_field, format!(\"first use of `{ident}`\"))\n         .emit();\n     }\n "}, {"sha": "2e0f37eba232d4762d11b13ae1880f6b4fc6d05d", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -74,20 +74,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let mut err = self.tcx.sess.struct_span_err(\n             span,\n-            &format!(\"negative integers cannot be used to index on a `{}`\", ty),\n+            &format!(\"negative integers cannot be used to index on a `{ty}`\"),\n         );\n-        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{}`\", ty));\n+        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{ty}`\"));\n         if let (hir::ExprKind::Path(..), Ok(snippet)) =\n             (&base_expr.kind, self.tcx.sess.source_map().span_to_snippet(base_expr.span))\n         {\n             // `foo[-1]` to `foo[foo.len() - 1]`\n             err.span_suggestion_verbose(\n                 span.shrink_to_lo(),\n                 &format!(\n-                    \"to access an element starting from the end of the `{}`, compute the index\",\n-                    ty,\n+                    \"to access an element starting from the end of the `{ty}`, compute the index\",\n                 ),\n-                format!(\"{}.len() \", snippet),\n+                format!(\"{snippet}.len() \"),\n                 Applicability::MachineApplicable,\n             );\n         }\n@@ -314,32 +313,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.typeck_results.borrow_mut().adjustments_mut().remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 for adjustment in &mut adjustments {\n-                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_mutable_overloaded_place_op(\n+                    if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind\n+                        && let Some(ok) = self.try_mutable_overloaded_place_op(\n                             expr.span,\n                             source,\n                             &[],\n                             PlaceOp::Deref,\n-                        ) {\n-                            let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                *deref = OverloadedDeref { region, mutbl, span: deref.span };\n-                            }\n-                            // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n-                            // This helps avoid accidental drops.\n-                            if inside_union\n-                                && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n-                            {\n-                                let mut err = self.tcx.sess.struct_span_err(\n-                                    expr.span,\n-                                    \"not automatically applying `DerefMut` on `ManuallyDrop` union field\",\n-                                );\n-                                err.help(\n-                                    \"writing to this reference calls the destructor for the old value\",\n-                                );\n-                                err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n-                                err.emit();\n-                            }\n+                        )\n+                    {\n+                        let method = self.register_infer_ok_obligations(ok);\n+                        if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n+                            *deref = OverloadedDeref { region, mutbl, span: deref.span };\n+                        }\n+                        // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n+                        // This helps avoid accidental drops.\n+                        if inside_union\n+                            && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n+                        {\n+                            let mut err = self.tcx.sess.struct_span_err(\n+                                expr.span,\n+                                \"not automatically applying `DerefMut` on `ManuallyDrop` union field\",\n+                            );\n+                            err.help(\n+                                \"writing to this reference calls the destructor for the old value\",\n+                            );\n+                            err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n+                            err.emit();\n                         }\n                     }\n                     source = adjustment.target;"}, {"sha": "e37e83e748733ac9b074b9ac15fb7bfc234fb886", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -317,13 +317,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.body_id = body_id.hir_id;\n         self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n-        let fn_sig = {\n-            match self.typeck_results.borrow().liberated_fn_sigs().get(id) {\n-                Some(f) => *f,\n-                None => {\n-                    bug!(\"No fn-sig entry for id={:?}\", id);\n-                }\n-            }\n+        let Some(fn_sig) = self.typeck_results.borrow().liberated_fn_sigs().get(id) else {\n+            bug!(\"No fn-sig entry for id={:?}\", id);\n         };\n \n         // Collect the types from which we create inferred bounds.\n@@ -642,12 +637,9 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         ignore_err!(self.with_mc(|mc| {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n                 // `ref x` pattern\n-                if let PatKind::Binding(..) = kind {\n-                    if let Some(ty::BindByReference(mutbl)) =\n-                        mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n-                    {\n-                        self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n-                    }\n+                if let PatKind::Binding(..) = kind\n+                    && let Some(ty::BindByReference(mutbl)) = mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span) {\n+                    self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n                 }\n             })\n         }));"}, {"sha": "9dbb813293263af994eb12d4f17997860c482cbc", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -862,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos::from_usize(line1.len())).shrink_to_lo(),\n                                 &diagnostic_msg,\n-                                format!(\"\\n{}{};\", indent, migration_string),\n+                                format!(\"\\n{indent}{migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else if line1.starts_with('{') {\n@@ -873,7 +873,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos(1)).shrink_to_lo(),\n                                 &diagnostic_msg,\n-                                format!(\" {};\", migration_string),\n+                                format!(\" {migration_string};\"),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else {\n@@ -882,7 +882,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             diagnostics_builder.multipart_suggestion(\n                                 &diagnostic_msg,\n                                 vec![\n-                                    (closure_body_span.shrink_to_lo(), format!(\"{{ {}; \", migration_string)),\n+                                    (closure_body_span.shrink_to_lo(), format!(\"{{ {migration_string}; \")),\n                                     (closure_body_span.shrink_to_hi(), \" }\".to_string()),\n                                 ],\n                                 Applicability::MachineApplicable\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.sess.struct_span_err(closure_span, \"First Pass analysis includes:\");\n             for (place, capture_info) in capture_information {\n                 let capture_str = construct_capture_info_string(self.tcx, place, capture_info);\n-                let output_str = format!(\"Capturing {}\", capture_str);\n+                let output_str = format!(\"Capturing {capture_str}\");\n \n                 let span =\n                     capture_info.path_expr_id.map_or(closure_span, |e| self.tcx.hir().span(e));\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                         let capture_str =\n                             construct_capture_info_string(self.tcx, place, capture_info);\n-                        let output_str = format!(\"Min Capture {}\", capture_str);\n+                        let output_str = format!(\"Min Capture {capture_str}\");\n \n                         if capture.info.path_expr_id != capture.info.capture_kind_expr_id {\n                             let path_span = capture_info\n@@ -1969,7 +1969,7 @@ fn construct_place_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String\n         projections_str.push_str(proj.as_str());\n     }\n \n-    format!(\"{}[{}]\", variable_name, projections_str)\n+    format!(\"{variable_name}[{projections_str}]\")\n }\n \n fn construct_capture_kind_reason_string<'tcx>(\n@@ -1984,13 +1984,13 @@ fn construct_capture_kind_reason_string<'tcx>(\n         ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n \n-    format!(\"{} captured as {} here\", place_str, capture_kind_str)\n+    format!(\"{place_str} captured as {capture_kind_str} here\")\n }\n \n fn construct_path_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n-    format!(\"{} used here\", place_str)\n+    format!(\"{place_str} used here\")\n }\n \n fn construct_capture_info_string<'tcx>(\n@@ -2004,7 +2004,7 @@ fn construct_capture_info_string<'tcx>(\n         ty::UpvarCapture::ByValue => \"ByValue\".into(),\n         ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n-    format!(\"{} -> {}\", place_str, capture_kind_str)\n+    format!(\"{place_str} -> {capture_kind_str}\")\n }\n \n fn var_name(tcx: TyCtxt<'_>, var_hir_id: hir::HirId) -> Symbol {\n@@ -2035,16 +2035,16 @@ fn migration_suggestion_for_2229(\n         .collect::<Vec<_>>();\n \n     let migration_ref_concat =\n-        need_migrations_variables.iter().map(|v| format!(\"&{}\", v)).collect::<Vec<_>>().join(\", \");\n+        need_migrations_variables.iter().map(|v| format!(\"&{v}\")).collect::<Vec<_>>().join(\", \");\n \n     let migration_string = if 1 == need_migrations.len() {\n-        format!(\"let _ = {}\", migration_ref_concat)\n+        format!(\"let _ = {migration_ref_concat}\")\n     } else {\n-        format!(\"let _ = ({})\", migration_ref_concat)\n+        format!(\"let _ = ({migration_ref_concat})\")\n     };\n \n     let migrated_variables_concat =\n-        need_migrations_variables.iter().map(|v| format!(\"`{}`\", v)).collect::<Vec<_>>().join(\", \");\n+        need_migrations_variables.iter().map(|v| format!(\"`{v}`\")).collect::<Vec<_>>().join(\", \");\n \n     (migration_string, migrated_variables_concat)\n }"}, {"sha": "4e3e32670e96e0b29f32190317bc55ce924a6f0b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -230,8 +230,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                         .struct_span_err(\n                             self_ty.span,\n                             &format!(\n-                                \"first argument of `call` in `{}` lang item must be a reference\",\n-                                fn_lang_item_name\n+                                \"first argument of `call` in `{fn_lang_item_name}` lang item must be a reference\",\n                             ),\n                         )\n                         .emit();\n@@ -241,8 +240,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     .struct_span_err(\n                         *span,\n                         &format!(\n-                            \"`call` function in `{}` lang item takes exactly two arguments\",\n-                            fn_lang_item_name\n+                            \"`call` function in `{fn_lang_item_name}` lang item takes exactly two arguments\",\n                         ),\n                     )\n                     .emit();\n@@ -252,8 +250,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                 .struct_span_err(\n                     trait_item.span,\n                     &format!(\n-                        \"`call` trait item in `{}` lang item must be a function\",\n-                        fn_lang_item_name\n+                        \"`call` trait item in `{fn_lang_item_name}` lang item must be a function\",\n                     ),\n                 )\n                 .emit();\n@@ -432,7 +429,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             );\n             err.span_suggestion(\n                 gat_item_hir.generics.where_clause.tail_span_for_suggestion(),\n-                &format!(\"add the required where clause{}\", plural),\n+                &format!(\"add the required where clause{plural}\"),\n                 suggestion,\n                 Applicability::MachineApplicable,\n             );\n@@ -523,7 +520,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             // In our example, requires that `Self: 'a`\n             if ty_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *ty, *region_a) {\n                 debug!(?ty_idx, ?region_a_idx);\n-                debug!(\"required clause: {} must outlive {}\", ty, region_a);\n+                debug!(\"required clause: {ty} must outlive {region_a}\");\n                 // Translate into the generic parameters of the GAT. In\n                 // our example, the type was `Self`, which will also be\n                 // `Self` in the GAT.\n@@ -560,7 +557,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n             }\n             if region_known_to_outlive(tcx, item_hir, param_env, &wf_tys, *region_a, *region_b) {\n                 debug!(?region_a_idx, ?region_b_idx);\n-                debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                debug!(\"required clause: {region_a} must outlive {region_b}\");\n                 // Translate into the generic parameters of the GAT.\n                 let region_a_param = gat_generics.param_at(*region_a_idx, tcx);\n                 let region_a_param =\n@@ -869,7 +866,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                         )\n                         .span_label(\n                             hir_ty.span,\n-                            format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                            format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),\n                         )\n                         .emit();\n                     }\n@@ -884,7 +881,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n                     _ => {\n                         is_ptr = false;\n-                        err_ty_str = format!(\"`{}`\", ty);\n+                        err_ty_str = format!(\"`{ty}`\");\n                         Some(err_ty_str.as_str())\n                     }\n                 };\n@@ -894,16 +891,14 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                         tcx.sess.span_err(\n                             hir_ty.span,\n                             &format!(\n-                                \"using {} as const generic parameters is forbidden\",\n-                                unsupported_type\n+                                \"using {unsupported_type} as const generic parameters is forbidden\",\n                             ),\n                         );\n                     } else {\n                         let mut err = tcx.sess.struct_span_err(\n                             hir_ty.span,\n                             &format!(\n-                                \"{} is forbidden as the type of a const generic parameter\",\n-                                unsupported_type\n+                                \"{unsupported_type} is forbidden as the type of a const generic parameter\",\n                             ),\n                         );\n                         err.note(\"the only supported types are integers, `bool` and `char`\");\n@@ -1567,9 +1562,8 @@ fn check_method_receiver<'fcx, 'tcx>(\n                     sym::arbitrary_self_types,\n                     span,\n                     &format!(\n-                        \"`{}` cannot be used as the type of `self` without \\\n+                        \"`{receiver_ty}` cannot be used as the type of `self` without \\\n                          the `arbitrary_self_types` feature\",\n-                        receiver_ty,\n                     ),\n                 )\n                 .help(HELP_FOR_SELF_TYPE)\n@@ -1587,8 +1581,7 @@ fn e0307<'tcx>(fcx: &FnCtxt<'_, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n         fcx.tcx.sess.diagnostic(),\n         span,\n         E0307,\n-        \"invalid `self` parameter type: {}\",\n-        receiver_ty,\n+        \"invalid `self` parameter type: {receiver_ty}\"\n     )\n     .note(\"type of `self` must be `Self` or a type that dereferences to it\")\n     .help(HELP_FOR_SELF_TYPE)\n@@ -1793,7 +1786,7 @@ fn report_bivariance(\n             tcx.def_path_str(def_id),\n         )\n     } else {\n-        format!(\"consider removing `{}` or referring to it in a field\", param_name)\n+        format!(\"consider removing `{param_name}` or referring to it in a field\")\n     };\n     err.help(&msg);\n \n@@ -1993,8 +1986,7 @@ fn error_392(\n     span: Span,\n     param_name: Symbol,\n ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-    let mut err =\n-        struct_span_err!(tcx.sess, span, E0392, \"parameter `{}` is never used\", param_name);\n+    let mut err = struct_span_err!(tcx.sess, span, E0392, \"parameter `{param_name}` is never used\");\n     err.span_label(span, \"unused parameter\");\n     err\n }"}, {"sha": "429b1644976c71586589f49ed806ceb8cccb59a5", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -319,6 +319,42 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_is_superset() {\n+    fn is_superset(a: &[i32], b: &[i32]) -> bool {\n+        let set_a = BTreeSet::from_iter(a.iter());\n+        let set_b = BTreeSet::from_iter(b.iter());\n+        set_a.is_superset(&set_b)\n+    }\n+\n+    assert_eq!(is_superset(&[], &[]), true);\n+    assert_eq!(is_superset(&[], &[1, 2]), false);\n+    assert_eq!(is_superset(&[0], &[1, 2]), false);\n+    assert_eq!(is_superset(&[1], &[1, 2]), false);\n+    assert_eq!(is_superset(&[4], &[1, 2]), false);\n+    assert_eq!(is_superset(&[1, 4], &[1, 2]), false);\n+    assert_eq!(is_superset(&[1, 2], &[1, 2]), true);\n+    assert_eq!(is_superset(&[1, 2, 3], &[1, 3]), true);\n+    assert_eq!(is_superset(&[1, 2, 3], &[]), true);\n+    assert_eq!(is_superset(&[-1, 1, 2, 3], &[-1, 3]), true);\n+\n+    if cfg!(miri) {\n+        // Miri is too slow\n+        return;\n+    }\n+\n+    let large = Vec::from_iter(0..100);\n+    assert_eq!(is_superset(&[], &large), false);\n+    assert_eq!(is_superset(&large, &[]), true);\n+    assert_eq!(is_superset(&large, &[1]), true);\n+    assert_eq!(is_superset(&large, &[50, 99]), true);\n+    assert_eq!(is_superset(&large, &[100]), false);\n+    assert_eq!(is_superset(&large, &[0, 99]), true);\n+    assert_eq!(is_superset(&[-1], &large), false);\n+    assert_eq!(is_superset(&[0], &large), false);\n+    assert_eq!(is_superset(&[99, 100], &large), false);\n+}\n+\n #[test]\n fn test_retain() {\n     let mut set = BTreeSet::from([1, 2, 3, 4, 5, 6]);\n@@ -391,6 +427,26 @@ fn test_clear() {\n     x.clear();\n     assert!(x.is_empty());\n }\n+#[test]\n+fn test_remove() {\n+    let mut x = BTreeSet::new();\n+    assert!(x.is_empty());\n+\n+    x.insert(1);\n+    x.insert(2);\n+    x.insert(3);\n+    x.insert(4);\n+\n+    assert_eq!(x.remove(&2), true);\n+    assert_eq!(x.remove(&0), false);\n+    assert_eq!(x.remove(&5), false);\n+    assert_eq!(x.remove(&1), true);\n+    assert_eq!(x.remove(&2), false);\n+    assert_eq!(x.remove(&3), true);\n+    assert_eq!(x.remove(&4), true);\n+    assert_eq!(x.remove(&4), false);\n+    assert!(x.is_empty());\n+}\n \n #[test]\n fn test_zip() {"}, {"sha": "1ce00828bf3449c248c12b5a3f18ff07a62dab48", "filename": "library/core/src/default.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -52,6 +52,23 @@\n /// This trait can be used with `#[derive]` if all of the type's fields implement\n /// `Default`. When `derive`d, it will use the default value for each field's type.\n ///\n+/// ### `enum`s\n+///\n+/// When using `#[derive(Default)]` on an `enum`, you need to choose which unit variant will be\n+/// default. You do this by placing the `#[default]` attribute on the variant.\n+///\n+/// ```\n+/// #[derive(Default)]\n+/// enum Kind {\n+///     #[default]\n+///     A,\n+///     B,\n+///     C,\n+/// }\n+/// ```\n+///\n+/// You cannot use the `#[default]` attribute on non-unit or non-exhaustive variants.\n+///\n /// ## How can I implement `Default`?\n ///\n /// Provide an implementation for the `default()` method that returns the value of"}, {"sha": "8aa355a554d70a0d2c415c35f95aea42f1ee9d03", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -167,7 +167,7 @@\n #![feature(const_precise_live_drops)]\n #![feature(const_refs_to_cell)]\n #![feature(decl_macro)]\n-#![feature(derive_default_enum)]\n+#![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(deprecated_suggestion)]\n #![feature(doc_cfg)]\n #![feature(doc_notable_trait)]"}, {"sha": "3cd3a3b780e9c3621765a93048dc2c9bb509570c", "filename": "library/core/src/prelude/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -45,3 +45,13 @@ pub mod rust_2021 {\n     #[doc(no_inline)]\n     pub use crate::convert::{TryFrom, TryInto};\n }\n+\n+/// The 2024 edition of the core prelude.\n+///\n+/// See the [module-level documentation](self) for more.\n+#[unstable(feature = \"prelude_2024\", issue = \"none\")]\n+pub mod rust_2024 {\n+    #[unstable(feature = \"prelude_2024\", issue = \"none\")]\n+    #[doc(no_inline)]\n+    pub use super::rust_2021::*;\n+}"}, {"sha": "da7753216d0630b91aa893f256adf54036d96f3f", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -279,6 +279,7 @@\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n #![feature(portable_simd)]\n+#![feature(prelude_2024)]\n #![feature(ptr_as_uninit)]\n #![feature(raw_os_nonzero)]\n #![feature(slice_internals)]"}, {"sha": "c314bbbb68e570c2972df7f9358d321d9da470d6", "filename": "library/std/src/prelude/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -132,3 +132,17 @@ pub mod rust_2021 {\n     #[doc(no_inline)]\n     pub use core::prelude::rust_2021::*;\n }\n+\n+/// The 2024 version of the prelude of The Rust Standard Library.\n+///\n+/// See the [module-level documentation](self) for more.\n+#[unstable(feature = \"prelude_2024\", issue = \"none\")]\n+pub mod rust_2024 {\n+    #[unstable(feature = \"prelude_2024\", issue = \"none\")]\n+    #[doc(no_inline)]\n+    pub use super::v1::*;\n+\n+    #[unstable(feature = \"prelude_2024\", issue = \"none\")]\n+    #[doc(no_inline)]\n+    pub use core::prelude::rust_2024::*;\n+}"}, {"sha": "62760373a6affecba019d63754011973ffaa2db1", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -4,7 +4,7 @@\n     all(target_os = \"emscripten\", target_feature = \"atomics\")\n ))]\n \n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::time::Duration;\n \n /// Wait for a futex_wake operation to wake us.\n@@ -13,7 +13,7 @@ use crate::time::Duration;\n ///\n /// Returns false on timeout, and true in all other cases.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -> bool {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n     use super::time::Timespec;\n     use crate::ptr::null;\n     use crate::sync::atomic::Ordering::Relaxed;\n@@ -35,7 +35,7 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -\n         let r = unsafe {\n             libc::syscall(\n                 libc::SYS_futex,\n-                futex as *const AtomicI32,\n+                futex as *const AtomicU32,\n                 libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n                 expected,\n                 timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n@@ -53,21 +53,19 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n     extern \"C\" {\n         fn emscripten_futex_wait(\n-            addr: *const AtomicI32,\n+            addr: *const AtomicU32,\n             val: libc::c_uint,\n             max_wait_ms: libc::c_double,\n         ) -> libc::c_int;\n     }\n \n     unsafe {\n         emscripten_futex_wait(\n-            futex as *const AtomicI32,\n-            // `val` is declared unsigned to match the Emscripten headers, but since it's used as\n-            // an opaque value, we can ignore the meaning of signed vs. unsigned and cast here.\n-            expected as libc::c_uint,\n+            futex,\n+            expected,\n             timeout.map_or(crate::f64::INFINITY, |d| d.as_secs_f64() * 1000.0),\n         );\n     }\n@@ -78,11 +76,11 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n /// Returns true if this actually woke up such a thread,\n /// or false if no thread was waiting on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake(futex: &AtomicI32) -> bool {\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n-            futex as *const AtomicI32,\n+            futex as *const AtomicU32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             1,\n         ) > 0\n@@ -91,22 +89,22 @@ pub fn futex_wake(futex: &AtomicI32) -> bool {\n \n /// Wake up all threads that are waiting on futex_wait on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake_all(futex: &AtomicI32) {\n+pub fn futex_wake_all(futex: &AtomicU32) {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n-            futex as *const AtomicI32,\n+            futex as *const AtomicU32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             i32::MAX,\n         );\n     }\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wake(futex: &AtomicI32) -> bool {\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n     extern \"C\" {\n-        fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n+        fn emscripten_futex_wake(addr: *const AtomicU32, count: libc::c_int) -> libc::c_int;\n     }\n \n-    unsafe { emscripten_futex_wake(futex as *const AtomicI32, 1) > 0 }\n+    unsafe { emscripten_futex_wake(futex, 1) > 0 }\n }"}, {"sha": "b166e7c453cad17bbdee1ad7f4bae550d6a02e71", "filename": "library/std/src/sys/unix/locks/futex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,6 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::sync::atomic::{\n-    AtomicI32, AtomicUsize,\n+    AtomicU32, AtomicUsize,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -13,13 +13,13 @@ pub struct Mutex {\n     /// 0: unlocked\n     /// 1: locked, no other threads waiting\n     /// 2: locked, and other threads waiting (contended)\n-    futex: AtomicI32,\n+    futex: AtomicU32,\n }\n \n impl Mutex {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { futex: AtomicI32::new(0) }\n+        Self { futex: AtomicU32::new(0) }\n     }\n \n     #[inline]\n@@ -71,7 +71,7 @@ impl Mutex {\n         }\n     }\n \n-    fn spin(&self) -> i32 {\n+    fn spin(&self) -> u32 {\n         let mut spin = 100;\n         loop {\n             // We only use `load` (and not `swap` or `compare_exchange`)\n@@ -110,13 +110,13 @@ pub struct Condvar {\n     // The value of this atomic is simply incremented on every notification.\n     // This is used by `.wait()` to not miss any notifications after\n     // unlocking the mutex and before waiting for notifications.\n-    futex: AtomicI32,\n+    futex: AtomicU32,\n }\n \n impl Condvar {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { futex: AtomicI32::new(0) }\n+        Self { futex: AtomicU32::new(0) }\n     }\n \n     #[inline]"}, {"sha": "e42edb2585834da8d7fb6c94d4b0898055ad7f0a", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,5 +1,5 @@\n use crate::sync::atomic::{\n-    AtomicI32,\n+    AtomicU32,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n@@ -14,36 +14,36 @@ pub struct RwLock {\n     //   0x3FFF_FFFF: Write locked\n     // Bit 30: Readers are waiting on this futex.\n     // Bit 31: Writers are waiting on the writer_notify futex.\n-    state: AtomicI32,\n+    state: AtomicU32,\n     // The 'condition variable' to notify writers through.\n     // Incremented on every signal.\n-    writer_notify: AtomicI32,\n+    writer_notify: AtomicU32,\n }\n \n-const READ_LOCKED: i32 = 1;\n-const MASK: i32 = (1 << 30) - 1;\n-const WRITE_LOCKED: i32 = MASK;\n-const MAX_READERS: i32 = MASK - 1;\n-const READERS_WAITING: i32 = 1 << 30;\n-const WRITERS_WAITING: i32 = 1 << 31;\n+const READ_LOCKED: u32 = 1;\n+const MASK: u32 = (1 << 30) - 1;\n+const WRITE_LOCKED: u32 = MASK;\n+const MAX_READERS: u32 = MASK - 1;\n+const READERS_WAITING: u32 = 1 << 30;\n+const WRITERS_WAITING: u32 = 1 << 31;\n \n-fn is_unlocked(state: i32) -> bool {\n+fn is_unlocked(state: u32) -> bool {\n     state & MASK == 0\n }\n \n-fn is_write_locked(state: i32) -> bool {\n+fn is_write_locked(state: u32) -> bool {\n     state & MASK == WRITE_LOCKED\n }\n \n-fn has_readers_waiting(state: i32) -> bool {\n+fn has_readers_waiting(state: u32) -> bool {\n     state & READERS_WAITING != 0\n }\n \n-fn has_writers_waiting(state: i32) -> bool {\n+fn has_writers_waiting(state: u32) -> bool {\n     state & WRITERS_WAITING != 0\n }\n \n-fn is_read_lockable(state: i32) -> bool {\n+fn is_read_lockable(state: u32) -> bool {\n     // This also returns false if the counter could overflow if we tried to read lock it.\n     //\n     // We don't allow read-locking if there's readers waiting, even if the lock is unlocked\n@@ -53,14 +53,14 @@ fn is_read_lockable(state: i32) -> bool {\n     state & MASK < MAX_READERS && !has_readers_waiting(state) && !has_writers_waiting(state)\n }\n \n-fn has_reached_max_readers(state: i32) -> bool {\n+fn has_reached_max_readers(state: u32) -> bool {\n     state & MASK == MAX_READERS\n }\n \n impl RwLock {\n     #[inline]\n     pub const fn new() -> Self {\n-        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }\n+        Self { state: AtomicU32::new(0), writer_notify: AtomicU32::new(0) }\n     }\n \n     #[inline]\n@@ -227,7 +227,7 @@ impl RwLock {\n     /// If both are waiting, this will wake up only one writer, but will fall\n     /// back to waking up readers if there was no writer to wake up.\n     #[cold]\n-    fn wake_writer_or_readers(&self, mut state: i32) {\n+    fn wake_writer_or_readers(&self, mut state: u32) {\n         assert!(is_unlocked(state));\n \n         // The readers waiting bit might be turned on at any point now,\n@@ -287,7 +287,7 @@ impl RwLock {\n     }\n \n     /// Spin for a while, but stop directly at the given condition.\n-    fn spin_until(&self, f: impl Fn(i32) -> bool) -> i32 {\n+    fn spin_until(&self, f: impl Fn(u32) -> bool) -> u32 {\n         let mut spin = 100; // Chosen by fair dice roll.\n         loop {\n             let state = self.state.load(Relaxed);\n@@ -299,12 +299,12 @@ impl RwLock {\n         }\n     }\n \n-    fn spin_write(&self) -> i32 {\n+    fn spin_write(&self) -> u32 {\n         // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n         self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))\n     }\n \n-    fn spin_read(&self) -> i32 {\n+    fn spin_read(&self) -> u32 {\n         // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n         self.spin_until(|state| {\n             !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)"}, {"sha": "bbe9bd6951af967e12d9be38040d0e07b9349292", "filename": "library/std/src/sys/wasm/atomics/futex.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,17 +1,21 @@\n use crate::arch::wasm32;\n use crate::convert::TryInto;\n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::time::Duration;\n \n-pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n     let timeout = timeout.and_then(|t| t.as_nanos().try_into().ok()).unwrap_or(-1);\n     unsafe {\n-        wasm32::memory_atomic_wait32(futex as *const AtomicI32 as *mut i32, expected, timeout);\n+        wasm32::memory_atomic_wait32(\n+            futex as *const AtomicU32 as *mut i32,\n+            expected as i32,\n+            timeout,\n+        );\n     }\n }\n \n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicU32) {\n     unsafe {\n-        wasm32::memory_atomic_notify(futex as *const AtomicI32 as *mut i32, 1);\n+        wasm32::memory_atomic_notify(futex as *const AtomicU32 as *mut i32, 1);\n     }\n }"}, {"sha": "fbf6231ff4ab324e5e43815f65c224e3a78f7950", "filename": "library/std/src/sys_common/thread_parker/futex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Ffutex.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,14 +1,14 @@\n-use crate::sync::atomic::AtomicI32;\n+use crate::sync::atomic::AtomicU32;\n use crate::sync::atomic::Ordering::{Acquire, Release};\n use crate::sys::futex::{futex_wait, futex_wake};\n use crate::time::Duration;\n \n-const PARKED: i32 = -1;\n-const EMPTY: i32 = 0;\n-const NOTIFIED: i32 = 1;\n+const PARKED: u32 = u32::MAX;\n+const EMPTY: u32 = 0;\n+const NOTIFIED: u32 = 1;\n \n pub struct Parker {\n-    state: AtomicI32,\n+    state: AtomicU32,\n }\n \n // Notes about memory ordering:\n@@ -34,7 +34,7 @@ pub struct Parker {\n impl Parker {\n     #[inline]\n     pub const fn new() -> Self {\n-        Parker { state: AtomicI32::new(EMPTY) }\n+        Parker { state: AtomicU32::new(EMPTY) }\n     }\n \n     // Assumes this is only called by the thread that owns the Parker,"}, {"sha": "32baed9c94498bb8864af979b78959c79bfddb85", "filename": "src/doc/rustc/src/tests/index.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Fdoc%2Frustc%2Fsrc%2Ftests%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Fdoc%2Frustc%2Fsrc%2Ftests%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftests%2Findex.md?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -15,7 +15,8 @@ fn it_works() {\n ```\n \n Tests \"pass\" if they return without an error. They \"fail\" if they [panic], or\n-return a [`Result`] with an error.\n+return a type such as [`Result`] that implements the [`Termination`] trait\n+with a non-zero value.\n \n By passing the [`--test` option] to `rustc`, the compiler will build the crate\n in a special mode to construct an executable that will run the tests in the\n@@ -304,6 +305,7 @@ Experimental support for using custom test harnesses is available on the\n [`libtest`]: ../../test/index.html\n [`main` function]: ../../reference/crates-and-source-files.html#main-functions\n [`Result`]: ../../std/result/index.html\n+[`Termination`]: ../../std/process/trait.Termination.html\n [`test` cfg option]: ../../reference/conditional-compilation.html#test\n [attribute-ignore]: ../../reference/attributes/testing.html#the-ignore-attribute\n [attribute-should_panic]: ../../reference/attributes/testing.html#the-should_panic-attribute"}, {"sha": "06c63ec97d7f2f41f0a5f235e4fa77dfd85b1b1b", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -119,11 +119,14 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n     fn visit_mod(&mut self, m: &'tcx Mod<'tcx>, span: Span, id: HirId) {\n         // To make the difference between \"mod foo {}\" and \"mod foo;\". In case we \"import\" another\n         // file, we want to link to it. Otherwise no need to create a link.\n-        if !span.overlaps(m.inner) {\n+        if !span.overlaps(m.spans.inner_span) {\n             // Now that we confirmed it's a file import, we want to get the span for the module\n             // name only and not all the \"mod foo;\".\n             if let Some(Node::Item(item)) = self.tcx.hir().find(id) {\n-                self.matches.insert(item.ident.span, LinkFromSrc::Local(clean::Span::new(m.inner)));\n+                self.matches.insert(\n+                    item.ident.span,\n+                    LinkFromSrc::Local(clean::Span::new(m.spans.inner_span)),\n+                );\n             }\n         }\n         intravisit::walk_mod(self, m, id);"}, {"sha": "75276d18fe5e9374e22bc15e941956d2cf2ab023", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n     ) -> Module<'tcx> {\n-        let mut om = Module::new(name, id, m.inner);\n+        let mut om = Module::new(name, id, m.spans.inner_span);\n         let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;"}, {"sha": "d1a81c72c2fdcc0c2112daf7efb08249ee5dd8de", "filename": "src/test/ui/deriving/deriving-default-enum.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fderiving%2Fderiving-default-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fderiving%2Fderiving-default-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-default-enum.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(derive_default_enum)]\n-\n // nb: does not impl Default\n #[derive(Debug, PartialEq)]\n struct NotDefault;"}, {"sha": "1c30b0b6fba75c392329f11b6e11d6783c032a90", "filename": "src/test/ui/deriving/deriving-with-helper.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-with-helper.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -5,7 +5,6 @@\n #![feature(lang_items)]\n #![feature(no_core)]\n #![feature(rustc_attrs)]\n-#![feature(derive_default_enum)]\n \n #![no_core]\n "}, {"sha": "05a5d4e14223a0404202b1fc2b0a347d0e1153f0", "filename": "src/test/ui/feature-gates/feature-gate-derive_default_enum.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,7 +0,0 @@\n-#[derive(Default)] //~ ERROR deriving `Default` on enums is experimental\n-enum Foo {\n-    #[default]\n-    Alpha,\n-}\n-\n-fn main() {}"}, {"sha": "58dd4d508a7091695eb7d4b588d1bd308807c064", "filename": "src/test/ui/feature-gates/feature-gate-derive_default_enum.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-derive_default_enum.stderr?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,13 +0,0 @@\n-error[E0658]: deriving `Default` on enums is experimental\n-  --> $DIR/feature-gate-derive_default_enum.rs:1:10\n-   |\n-LL | #[derive(Default)]\n-   |          ^^^^^^^\n-   |\n-   = note: see issue #86985 <https://github.com/rust-lang/rust/issues/86985> for more information\n-   = help: add `#![feature(derive_default_enum)]` to the crate attributes to enable\n-   = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "e48ab4aa96fb979fcfbcb5a1ec2e4e9ebc7a0f29", "filename": "src/test/ui/functions-closures/fn-help-with-err-generic-is-not-function.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -8,15 +8,7 @@ where\n     //~^ ERROR cannot find type `T` in this scope\n     //~| NOTE not found in this scope\n {\n-    // The part where it claims that there is no method named `len` is a bug. Feel free to fix it.\n-    // This test is intended to ensure that a different bug, where it claimed\n-    // that `v` was a function, does not regress.\n     fn method(v: Vec<u8>) { v.len(); }\n-    //~^ ERROR type annotations needed\n-    //~| NOTE cannot infer type\n-    //~| NOTE type must be known at this point\n-    //~| ERROR no method named `len`\n-    //~| NOTE private field, not a method\n }\n \n fn main() {}"}, {"sha": "26bdf460f5e4d5c4c3671585607cc821b1ad586b", "filename": "src/test/ui/functions-closures/fn-help-with-err-generic-is-not-function.stderr", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err-generic-is-not-function.stderr?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -12,21 +12,6 @@ error[E0412]: cannot find type `T` in this scope\n LL |     T: Copy,\n    |     ^ not found in this scope\n \n-error[E0282]: type annotations needed\n-  --> $DIR/fn-help-with-err-generic-is-not-function.rs:14:31\n-   |\n-LL |     fn method(v: Vec<u8>) { v.len(); }\n-   |                               ^^^ cannot infer type\n-   |\n-   = note: type must be known at this point\n-\n-error[E0599]: no method named `len` found for struct `Vec<u8>` in the current scope\n-  --> $DIR/fn-help-with-err-generic-is-not-function.rs:14:31\n-   |\n-LL |     fn method(v: Vec<u8>) { v.len(); }\n-   |                               ^^^ private field, not a method\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0282, E0412, E0599.\n-For more information about an error, try `rustc --explain E0282`.\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "c66b7c60fb4eac0584a8d0578334dc7e3eefb827", "filename": "src/test/ui/hello.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhello.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,5 +1,12 @@\n // run-pass\n+// revisions: e2015 e2018 e2021 e2024\n \n-pub fn main() {\n-    println!(\"hello, world\");\n+//[e2018] edition:2018\n+//[e2021] edition:2021\n+//[e2024] edition:2024\n+\n+//[e2024] compile-flags: -Zunstable-options\n+\n+fn main() {\n+    println!(\"hello\");\n }"}, {"sha": "134d8af5bfb8aba42320695460111a4b87ca45cf", "filename": "src/test/ui/hello2021.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Fhello2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftest%2Fui%2Fhello2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhello2021.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,6 +0,0 @@\n-// run-pass\n-// edition:2021\n-\n-fn main() {\n-    println!(\"hello, 2021\");\n-}"}, {"sha": "69aba3ae9b4e75dda1e4738479979020991ebd9a", "filename": "src/test/ui/imports/overlapping_pub_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Foverlapping_pub_trait.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -4,10 +4,10 @@\n  * This crate declares two public paths, `m::Tr` and `prelude::_`. Make sure we prefer the former.\n  */\n extern crate overlapping_pub_trait_source;\n+//~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+//~| SUGGESTION overlapping_pub_trait_source::m::Tr\n \n fn main() {\n-    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n-    //~| SUGGESTION overlapping_pub_trait_source::m::Tr\n     use overlapping_pub_trait_source::S;\n     S.method();\n     //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]"}, {"sha": "c38fb17b97649719bbf605f1b89ea3835504e816", "filename": "src/test/ui/imports/unnamed_pub_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Funnamed_pub_trait.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -5,10 +5,10 @@\n  * importing it by name, and instead we suggest importing it by glob.\n  */\n extern crate unnamed_pub_trait_source;\n+//~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n+//~| SUGGESTION unnamed_pub_trait_source::prelude::*; // trait Tr\n \n fn main() {\n-    //~^ HELP the following trait is implemented but not in scope; perhaps add a `use` for it:\n-    //~| SUGGESTION unnamed_pub_trait_source::prelude::*; // trait Tr\n     use unnamed_pub_trait_source::S;\n     S.method();\n     //~^ ERROR no method named `method` found for struct `S` in the current scope [E0599]"}, {"sha": "e7a01f105de0be768fb14dc37c5d50cd5366f8f5", "filename": "src/test/ui/macros/macros-nonfatal-errors.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -5,7 +5,6 @@\n \n #![feature(trace_macros, concat_idents)]\n #![feature(stmt_expr_attributes, arbitrary_enum_discriminant)]\n-#![feature(derive_default_enum)]\n \n use std::arch::asm;\n "}, {"sha": "b3c6d07f96763a92ab3df33dd33330ccc01c7588", "filename": "src/test/ui/macros/macros-nonfatal-errors.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacros-nonfatal-errors.stderr?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -1,41 +1,41 @@\n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:14:5\n+  --> $DIR/macros-nonfatal-errors.rs:13:5\n    |\n LL |     #[default]\n    |     ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:19:36\n+  --> $DIR/macros-nonfatal-errors.rs:18:36\n    |\n LL | struct DefaultInnerAttrTupleStruct(#[default] ());\n    |                                    ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:23:1\n+  --> $DIR/macros-nonfatal-errors.rs:22:1\n    |\n LL | #[default]\n    | ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:27:1\n+  --> $DIR/macros-nonfatal-errors.rs:26:1\n    |\n LL | #[default]\n    | ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:37:11\n+  --> $DIR/macros-nonfatal-errors.rs:36:11\n    |\n LL |     Foo = #[default] 0,\n    |           ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:38:14\n+  --> $DIR/macros-nonfatal-errors.rs:37:14\n    |\n LL |     Bar([u8; #[default] 1]),\n    |              ^^^^^^^^^^\n \n error: no default declared\n-  --> $DIR/macros-nonfatal-errors.rs:43:10\n+  --> $DIR/macros-nonfatal-errors.rs:42:10\n    |\n LL | #[derive(Default)]\n    |          ^^^^^^^\n@@ -44,7 +44,7 @@ LL | #[derive(Default)]\n    = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: multiple declared defaults\n-  --> $DIR/macros-nonfatal-errors.rs:49:10\n+  --> $DIR/macros-nonfatal-errors.rs:48:10\n    |\n LL | #[derive(Default)]\n    |          ^^^^^^^\n@@ -62,15 +62,15 @@ LL |     Baz,\n    = note: this error originates in the derive macro `Default` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[default]` attribute does not accept a value\n-  --> $DIR/macros-nonfatal-errors.rs:61:5\n+  --> $DIR/macros-nonfatal-errors.rs:60:5\n    |\n LL |     #[default = 1]\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: try using `#[default]`\n \n error: multiple `#[default]` attributes\n-  --> $DIR/macros-nonfatal-errors.rs:69:5\n+  --> $DIR/macros-nonfatal-errors.rs:68:5\n    |\n LL |     #[default]\n    |     ---------- `#[default]` used here\n@@ -81,13 +81,13 @@ LL |     Foo,\n    |\n    = note: only one `#[default]` attribute is needed\n help: try removing this\n-  --> $DIR/macros-nonfatal-errors.rs:68:5\n+  --> $DIR/macros-nonfatal-errors.rs:67:5\n    |\n LL |     #[default]\n    |     ^^^^^^^^^^\n \n error: multiple `#[default]` attributes\n-  --> $DIR/macros-nonfatal-errors.rs:79:5\n+  --> $DIR/macros-nonfatal-errors.rs:78:5\n    |\n LL |     #[default]\n    |     ---------- `#[default]` used here\n@@ -99,7 +99,7 @@ LL |     Foo,\n    |\n    = note: only one `#[default]` attribute is needed\n help: try removing these\n-  --> $DIR/macros-nonfatal-errors.rs:76:5\n+  --> $DIR/macros-nonfatal-errors.rs:75:5\n    |\n LL |     #[default]\n    |     ^^^^^^^^^^\n@@ -109,15 +109,15 @@ LL |     #[default]\n    |     ^^^^^^^^^^\n \n error: the `#[default]` attribute may only be used on unit enum variants\n-  --> $DIR/macros-nonfatal-errors.rs:86:5\n+  --> $DIR/macros-nonfatal-errors.rs:85:5\n    |\n LL |     Foo {},\n    |     ^^^\n    |\n    = help: consider a manual implementation of `Default`\n \n error: default variant must be exhaustive\n-  --> $DIR/macros-nonfatal-errors.rs:94:5\n+  --> $DIR/macros-nonfatal-errors.rs:93:5\n    |\n LL |     #[non_exhaustive]\n    |     ----------------- declared `#[non_exhaustive]` here\n@@ -127,45 +127,45 @@ LL |     Foo,\n    = help: consider a manual implementation of `Default`\n \n error: asm template must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:99:10\n+  --> $DIR/macros-nonfatal-errors.rs:98:10\n    |\n LL |     asm!(invalid);\n    |          ^^^^^^^\n \n error: concat_idents! requires ident args\n-  --> $DIR/macros-nonfatal-errors.rs:102:5\n+  --> $DIR/macros-nonfatal-errors.rs:101:5\n    |\n LL |     concat_idents!(\"not\", \"idents\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:104:17\n+  --> $DIR/macros-nonfatal-errors.rs:103:17\n    |\n LL |     option_env!(invalid);\n    |                 ^^^^^^^\n \n error: expected string literal\n-  --> $DIR/macros-nonfatal-errors.rs:105:10\n+  --> $DIR/macros-nonfatal-errors.rs:104:10\n    |\n LL |     env!(invalid);\n    |          ^^^^^^^\n \n error: expected string literal\n-  --> $DIR/macros-nonfatal-errors.rs:106:10\n+  --> $DIR/macros-nonfatal-errors.rs:105:10\n    |\n LL |     env!(foo, abr, baz);\n    |          ^^^\n \n error: environment variable `RUST_HOPEFULLY_THIS_DOESNT_EXIST` not defined\n-  --> $DIR/macros-nonfatal-errors.rs:107:5\n+  --> $DIR/macros-nonfatal-errors.rs:106:5\n    |\n LL |     env!(\"RUST_HOPEFULLY_THIS_DOESNT_EXIST\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `env` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: format argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:109:13\n+  --> $DIR/macros-nonfatal-errors.rs:108:13\n    |\n LL |     format!(invalid);\n    |             ^^^^^^^\n@@ -176,47 +176,47 @@ LL |     format!(\"{}\", invalid);\n    |             +++++\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:111:14\n+  --> $DIR/macros-nonfatal-errors.rs:110:14\n    |\n LL |     include!(invalid);\n    |              ^^^^^^^\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:113:18\n+  --> $DIR/macros-nonfatal-errors.rs:112:18\n    |\n LL |     include_str!(invalid);\n    |                  ^^^^^^^\n \n error: couldn't read $DIR/i'd be quite surprised if a file with this name existed: $FILE_NOT_FOUND_MSG (os error 2)\n-  --> $DIR/macros-nonfatal-errors.rs:114:5\n+  --> $DIR/macros-nonfatal-errors.rs:113:5\n    |\n LL |     include_str!(\"i'd be quite surprised if a file with this name existed\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `include_str` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: argument must be a string literal\n-  --> $DIR/macros-nonfatal-errors.rs:115:20\n+  --> $DIR/macros-nonfatal-errors.rs:114:20\n    |\n LL |     include_bytes!(invalid);\n    |                    ^^^^^^^\n \n error: couldn't read $DIR/i'd be quite surprised if a file with this name existed: $FILE_NOT_FOUND_MSG (os error 2)\n-  --> $DIR/macros-nonfatal-errors.rs:116:5\n+  --> $DIR/macros-nonfatal-errors.rs:115:5\n    |\n LL |     include_bytes!(\"i'd be quite surprised if a file with this name existed\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: this error originates in the macro `include_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: trace_macros! accepts only `true` or `false`\n-  --> $DIR/macros-nonfatal-errors.rs:118:5\n+  --> $DIR/macros-nonfatal-errors.rs:117:5\n    |\n LL |     trace_macros!(invalid);\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find macro `llvm_asm` in this scope\n-  --> $DIR/macros-nonfatal-errors.rs:100:5\n+  --> $DIR/macros-nonfatal-errors.rs:99:5\n    |\n LL |     llvm_asm!(invalid);\n    |     ^^^^^^^^"}, {"sha": "d2bbb4f110114369f8c5b4ebf83d2a6421f7e9f8", "filename": "src/test/ui/mir/issue-92893.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmir%2Fissue-92893.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmir%2Fissue-92893.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-92893.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -0,0 +1,7 @@\n+struct Bug<A = [(); (let a = (), 1).1]> {\n+    //~^ `let` expressions are not supported here\n+    //~^^ `let` expressions in this position are unstable [E0658]\n+    a: A\n+}\n+\n+fn main() {}"}, {"sha": "063b5d66feb456f465f593f4f6d6e11dd75bec5a", "filename": "src/test/ui/mir/issue-92893.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmir%2Fissue-92893.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fmir%2Fissue-92893.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fissue-92893.stderr?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -0,0 +1,20 @@\n+error: `let` expressions are not supported here\n+  --> $DIR/issue-92893.rs:1:22\n+   |\n+LL | struct Bug<A = [(); (let a = (), 1).1]> {\n+   |                      ^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+\n+error[E0658]: `let` expressions in this position are unstable\n+  --> $DIR/issue-92893.rs:1:22\n+   |\n+LL | struct Bug<A = [(); (let a = (), 1).1]> {\n+   |                      ^^^^^^^^^^\n+   |\n+   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n+   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "37335da060e42f5eaec8a766dea247bb3ec91752", "filename": "src/test/ui/suggestions/use-placement-typeck.fixed", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fsuggestions%2Fuse-placement-typeck.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Fsuggestions%2Fuse-placement-typeck.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-placement-typeck.fixed?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -7,7 +7,6 @@\n #![allow(unused)]\n \n use m::Foo;\n-\n fn main() {\n     let s = m::S;\n     s.abc(); //~ ERROR no method named `abc`"}, {"sha": "ec96c61c63e3ab813b2a025f3f9cd0ba993d72be", "filename": "src/test/ui/typeck/autoderef-with-param-env-error.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -0,0 +1,9 @@\n+fn foo()\n+where\n+    T: Send,\n+    //~^ cannot find type `T` in this scope\n+{\n+    let s = \"abc\".to_string();\n+}\n+\n+fn main() {}"}, {"sha": "cde800336dd3d5ac813e0ffe17de1535cbfe5aeb", "filename": "src/test/ui/typeck/autoderef-with-param-env-error.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fautoderef-with-param-env-error.stderr?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -0,0 +1,12 @@\n+error[E0412]: cannot find type `T` in this scope\n+  --> $DIR/autoderef-with-param-env-error.rs:3:5\n+   |\n+LL | fn foo()\n+   |       - help: you might be missing a type parameter: `<T>`\n+LL | where\n+LL |     T: Send,\n+   |     ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "6ed141fa4a5a6dabe6b5b73560265eb98ef81b21", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -59,7 +59,7 @@ pub(super) fn check<'tcx>(\n                 if let Some(indexed_extent) = indexed_extent {\n                     let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n-                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n+                    let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id).unwrap();\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n                         return;\n                     }\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id).unwrap();\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,"}, {"sha": "1ab7f52110ce7c3742aeec202c9ccd4003959e99", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -160,8 +160,8 @@ impl<'tcx> LateLintPass<'tcx> for Shadow {\n \n fn is_shadow(cx: &LateContext<'_>, owner: LocalDefId, first: ItemLocalId, second: ItemLocalId) -> bool {\n     let scope_tree = cx.tcx.region_scope_tree(owner.to_def_id());\n-    let first_scope = scope_tree.var_scope(first);\n-    let second_scope = scope_tree.var_scope(second);\n+    let first_scope = scope_tree.var_scope(first).unwrap();\n+    let second_scope = scope_tree.var_scope(second).unwrap();\n     scope_tree.is_subscope_of(second_scope, first_scope)\n }\n "}, {"sha": "8e871e61f26837c5b2ed21cd1fd4348ec60e4cbd", "filename": "src/tools/rustfmt/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -693,6 +693,7 @@ fn edition_from_edition_str(edition_str: &str) -> Result<Edition> {\n         \"2015\" => Ok(Edition::Edition2015),\n         \"2018\" => Ok(Edition::Edition2018),\n         \"2021\" => Ok(Edition::Edition2021),\n+        \"2024\" => Ok(Edition::Edition2024),\n         _ => Err(format_err!(\"Invalid value for `--edition`\")),\n     }\n }"}, {"sha": "257a17b2703a9deab95d0e5f5533dde1523ed112", "filename": "src/tools/rustfmt/src/config/options.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f391b84552f210adec7893b50c5da74f9362ae4/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs?ref=3f391b84552f210adec7893b50c5da74f9362ae4", "patch": "@@ -423,6 +423,10 @@ pub enum Edition {\n     #[doc_hint = \"2021\"]\n     /// Edition 2021.\n     Edition2021,\n+    #[value = \"2024\"]\n+    #[doc_hint = \"2024\"]\n+    /// Edition 2024.\n+    Edition2024,\n }\n \n impl Default for Edition {\n@@ -437,6 +441,7 @@ impl From<Edition> for rustc_span::edition::Edition {\n             Edition::Edition2015 => Self::Edition2015,\n             Edition::Edition2018 => Self::Edition2018,\n             Edition::Edition2021 => Self::Edition2021,\n+            Edition::Edition2024 => Self::Edition2024,\n         }\n     }\n }"}]}