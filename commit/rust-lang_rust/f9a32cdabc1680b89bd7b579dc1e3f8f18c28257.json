{"sha": "f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YTMyY2RhYmMxNjgwYjg5YmQ3YjU3OWRjMWUzZjhmMThjMjgyNTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-31T00:55:20Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T17:32:35Z"}, "message": "std: Fixing all documentation\n\n* Stop referencing io_error\n* Start changing \"Failure\" sections to \"Error\" sections\n* Update all doc examples to work.", "tree": {"sha": "eb30082c0b18bd9510a805e9d416d69242652d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb30082c0b18bd9510a805e9d416d69242652d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "html_url": "https://github.com/rust-lang/rust/commit/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a7c5e0b724d8318a7e7762e483c225e8a7420a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a7c5e0b724d8318a7e7762e483c225e8a7420a1", "html_url": "https://github.com/rust-lang/rust/commit/2a7c5e0b724d8318a7e7762e483c225e8a7420a1"}], "stats": {"total": 599, "additions": 274, "deletions": 325}, "files": [{"sha": "7c22e90bbffe23518551129b36e8e7b676e2dca6", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -96,15 +96,15 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n             if fd == input {\n                 let mut buf = [0, ..1];\n                 // drain the input file descriptor of its input\n-                FileDesc::new(fd, false).inner_read(buf).unwrap();\n+                let _ = FileDesc::new(fd, false).inner_read(buf).unwrap();\n                 incoming = true;\n             } else {\n                 let mut bits = [0, ..8];\n                 // drain the timerfd of how many times its fired\n                 //\n                 // FIXME: should this perform a send() this number of\n                 //      times?\n-                FileDesc::new(fd, false).inner_read(bits).unwrap();\n+                let _ = FileDesc::new(fd, false).inner_read(bits).unwrap();\n                 let remove = {\n                     match map.find(&fd).expect(\"fd unregistered\") {\n                         &(ref c, oneshot) => !c.try_send(()) || oneshot\n@@ -166,7 +166,8 @@ impl Timer {\n     }\n \n     pub fn sleep(ms: u64) {\n-        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+        // FIXME: this can fail because of EINTR, what do do?\n+        let _ = unsafe { libc::usleep((ms * 1000) as libc::c_uint) };\n     }\n \n     fn remove(&mut self) {"}, {"sha": "0bc567b270a4ce739509789f68405a15dd1ff292", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -163,9 +163,10 @@ method of the signature:\n \n ```rust\n # use std;\n+# mod fmt { pub type Result = (); }\n # struct T;\n # trait SomeName<T> {\n-fn fmt(value: &T, f: &mut std::fmt::Formatter);\n+fn fmt(value: &T, f: &mut std::fmt::Formatter) -> fmt::Result;\n # }\n ```\n \n@@ -174,7 +175,14 @@ emit output into the `f.buf` stream. It is up to each format trait\n implementation to correctly adhere to the requested formatting parameters. The\n values of these parameters will be listed in the fields of the `Formatter`\n struct. In order to help with this, the `Formatter` struct also provides some\n-helper methods. An example of implementing the formatting traits would look\n+helper methods.\n+\n+Additionally, the return value of this function is `fmt::Result` which is a\n+typedef to `Result<(), IoError>` (also known as `IoError<()>`). Formatting\n+implementations should ensure that they return errors from `write!` correctly\n+(propagating errors upward).\n+\n+An example of implementing the formatting traits would look\n like:\n \n ```rust\n@@ -187,7 +195,7 @@ struct Vector2D {\n }\n \n impl fmt::Show for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n         // The `f.buf` value is of the type `&mut io::Writer`, which is what th\n         // write! macro is expecting. Note that this formatting ignores the\n         // various flags provided to format strings.\n@@ -198,7 +206,7 @@ impl fmt::Show for Vector2D {\n // Different traits allow different forms of output of a type. The meaning of\n // this format is to print the magnitude of a vector.\n impl fmt::Binary for Vector2D {\n-    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) {\n+    fn fmt(obj: &Vector2D, f: &mut fmt::Formatter) -> fmt::Result {\n         let magnitude = (obj.x * obj.x + obj.y * obj.y) as f64;\n         let magnitude = magnitude.sqrt();\n \n@@ -207,7 +215,7 @@ impl fmt::Binary for Vector2D {\n         // for details, and the function `pad` can be used to pad strings.\n         let decimals = f.precision.unwrap_or(3);\n         let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(string.as_bytes(), \"\", true);\n+        f.pad_integral(string.as_bytes(), \"\", true)\n     }\n }\n \n@@ -242,6 +250,7 @@ strings and instead directly write the output. Under the hood, this function is\n actually invoking the `write` function defined in this module. Example usage is:\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io;\n \n let mut w = io::MemWriter::new();\n@@ -655,11 +664,12 @@ uniform_fn_call_workaround! {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::fmt;\n /// use std::io;\n ///\n /// let w = &mut io::stdout() as &mut io::Writer;\n-/// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n+/// format_args!(|args| { fmt::write(w, args); }, \"Hello, {}!\", \"world\");\n /// ```\n pub fn write(output: &mut io::Writer, args: &Arguments) -> Result {\n     unsafe { write_unsafe(output, args.fmt, args.args) }"}, {"sha": "256f9d325f3edd92e8c9126ff8d55d945e00d25d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -31,14 +31,13 @@ use vec;\n /// ```rust\n /// use std::io::{BufferedReader, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut reader = BufferedReader::new(file);\n ///\n /// let mut buf = [0, ..100];\n /// match reader.read(buf) {\n-///     Some(nread) => println!(\"Read {} bytes\", nread),\n-///     None => println!(\"At the end of the file!\")\n+///     Ok(nread) => println!(\"Read {} bytes\", nread),\n+///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n pub struct BufferedReader<R> {\n@@ -121,9 +120,9 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::{BufferedWriter, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut writer = BufferedWriter::new(file);\n ///\n@@ -268,9 +267,9 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::{BufferedStream, File};\n ///\n-/// # let _g = ::std::io::ignore_io_error();\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut stream = BufferedStream::new(file);\n ///\n@@ -279,8 +278,8 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// let mut buf = [0, ..100];\n /// match stream.read(buf) {\n-///     Some(nread) => println!(\"Read {} bytes\", nread),\n-///     None => println!(\"At the end of the stream!\")\n+///     Ok(nread) => println!(\"Read {} bytes\", nread),\n+///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n pub struct BufferedStream<S> {"}, {"sha": "ef1b1a56ec0e0091a00ff580e8d634a5e8080c92", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 68, "deletions": 96, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -14,11 +14,11 @@ This module provides a set of functions and traits for working\n with regular files & directories on a filesystem.\n \n At the top-level of the module are a set of freestanding functions, associated\n-with various filesystem operations. They all operate on a `Path` object.\n+with various filesystem operations. They all operate on `Path` objects.\n \n All operations in this module, including those as part of `File` et al\n-block the task during execution. Most will raise `std::io::io_error`\n-conditions in the event of failure.\n+block the task during execution. In the event of failure, all functions/methods\n+will return an `IoResult` type with an `Err` value.\n \n Also included in this module is an implementation block on the `Path` object\n defined in `std::path::Path`. The impl adds useful methods about inspecting the\n@@ -42,7 +42,7 @@ file.write(bytes!(\"foobar\"));\n let mut file = File::open(&path);\n file.read_to_end();\n \n-println!(\"{}\", path.stat().size);\n+println!(\"{}\", path.stat().unwrap().size);\n # drop(file);\n fs::unlink(&path);\n ```\n@@ -68,11 +68,12 @@ use vec::{OwnedVector, ImmutableVector};\n /// Can be constructed via `File::open()`, `File::create()`, and\n /// `File::open_mode()`.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This type will raise an io_error condition if operations are attempted against\n-/// it for which its underlying file descriptor was not configured at creation\n-/// time, via the `FileAccess` parameter to `File::open_mode()`.\n+/// This type will return errors as an `IoResult<T>` if operations are\n+/// attempted against it for which its underlying file descriptor was not\n+/// configured at creation time, via the `FileAccess` parameter to\n+/// `File::open_mode()`.\n pub struct File {\n     priv fd: ~RtioFileStream,\n     priv path: Path,\n@@ -85,7 +86,7 @@ impl File {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```rust,should_fail\n     /// use std::io::{File, Open, ReadWrite};\n     ///\n     /// let p = Path::new(\"/some/file/path.txt\");\n@@ -107,12 +108,12 @@ impl File {\n     ///\n     /// Note that, with this function, a `File` is returned regardless of the\n     /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-    /// `File` opened as `Read` will raise an `io_error` condition at runtime).\n+    /// `File` opened as `Read` will return an error at runtime).\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n-    /// This function will raise an `io_error` condition under a number of\n-    /// different circumstances, to include but not limited to:\n+    /// This function will return an error under a number of different\n+    /// circumstances, to include but not limited to:\n     ///\n     /// * Opening a file that does not exist with `Read` access.\n     /// * Attempting to open a file with a `FileAccess` that the user lacks\n@@ -164,7 +165,7 @@ impl File {\n     /// let mut f = File::create(&Path::new(\"foo.txt\"));\n     /// f.write(bytes!(\"This is a sample file\"));\n     /// # drop(f);\n-    /// # ::std::io::fs::unlnk(&Path::new(\"foo.txt\"));\n+    /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n@@ -178,10 +179,6 @@ impl File {\n     /// Synchronizes all modifications to this file to its permanent storage\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n     pub fn fsync(&mut self) -> IoResult<()> {\n         self.fd.fsync()\n     }\n@@ -190,10 +187,6 @@ impl File {\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will raise on the `io_error` condition on failure.\n     pub fn datasync(&mut self) -> IoResult<()> {\n         self.fd.datasync()\n     }\n@@ -206,10 +199,6 @@ impl File {\n     /// be shrunk. If it is greater than the current file's size, then the file\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n-    ///\n-    /// # Errors\n-    ///\n-    /// On error, this function will raise on the `io_error` condition.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n         self.fd.truncate(size)\n     }\n@@ -239,11 +228,11 @@ impl File {\n /// guaranteed that a file is immediately deleted (e.g. depending on\n /// platform, other open file descriptors may prevent immediate removal)\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise an `io_error` condition if the path points to a\n-/// directory, the user lacks permissions to remove the file, or if some\n-/// other filesystem-level error occurs.\n+/// This function will return an error if the path points to a directory, the\n+/// user lacks permissions to remove the file, or if some other filesystem-level\n+/// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_unlink(&path.to_c_str()))\n }\n@@ -259,7 +248,6 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io;\n /// use std::io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n@@ -269,11 +257,11 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// }\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks the\n-/// requisite permissions to perform a `stat` call on the given path or if\n-/// there is no entry in the filesystem at the provided path.\n+/// This call will return an error if the user lacks the requisite permissions\n+/// to perform a `stat` call on the given path or if there is no entry in the\n+/// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_stat(&path.to_c_str())\n@@ -285,7 +273,7 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n /// information about the symlink file instead of the file that it points\n /// to.\n ///\n-/// # Errors\n+/// # Error\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n@@ -305,11 +293,11 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n /// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n+/// Will return an error if the provided `path` doesn't exist, the process lacks\n+/// permissions to view the contents, or if some other intermittent I/O error\n+/// occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()))\n }\n@@ -329,10 +317,10 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition is the following situations, but is\n-/// not limited to just these cases:\n+/// Will return an error in the following situations, but is not limited to\n+/// just these cases:\n ///\n /// * The `from` path is not a file\n /// * The `from` file does not exist\n@@ -373,7 +361,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// # #[allow(unused_must_use)]\n+/// # #[allow(unused_must_use)];\n /// use std::io;\n /// use std::io::fs;\n ///\n@@ -383,52 +371,39 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// fs::chmod(&Path::new(\"file.exe\"), io::UserExec);\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// If this function encounters an I/O error, it will raise on the `io_error`\n-/// condition. Some possible error situations are not having the permission to\n+/// If this function encounters an I/O error, it will return an `Err` value.\n+/// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_chmod(&path.to_c_str(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition on failure.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()))\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition on failure. Failure\n-/// conditions include reading a file that does not exist or reading a file\n-/// which is not a symlink.\n+/// This function will return an error on failure. Failure conditions include\n+/// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     LocalIo::maybe_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n@@ -446,11 +421,10 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// fs::mkdir(&p, io::UserRWX);\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to make a new directory at the provided path, or if the directory already\n-/// exists.\n+/// This call will return an error if the user lacks permissions to make a new\n+/// directory at the provided path, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_mkdir(&path.to_c_str(), mode))\n }\n@@ -467,11 +441,10 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// fs::rmdir(&p);\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This call will raise an `io_error` condition if the user lacks permissions\n-/// to remove the directory at the provided path, or if the directory isn't\n-/// empty.\n+/// This call will return an error if the user lacks permissions to remove the\n+/// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_rmdir(&path.to_c_str()))\n }\n@@ -481,26 +454,32 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n+/// use std::io;\n /// use std::io::fs;\n ///\n /// // one possible implementation of fs::walk_dir only visiting files\n-/// fn visit_dirs(dir: &Path, cb: |&Path|) {\n+/// fn visit_dirs(dir: &Path, cb: |&Path|) -> io::IoResult<()> {\n ///     if dir.is_dir() {\n-///         let contents = fs::readdir(dir).unwrap();\n+///         let contents = if_ok!(fs::readdir(dir));\n ///         for entry in contents.iter() {\n-///             if entry.is_dir() { visit_dirs(entry, cb); }\n-///             else { cb(entry); }\n+///             if entry.is_dir() {\n+///                 if_ok!(visit_dirs(entry, |p| cb(p)));\n+///             } else {\n+///                 cb(entry);\n+///             }\n ///         }\n+///         Ok(())\n+///     } else {\n+///         Err(io::standard_error(io::InvalidInput))\n ///     }\n-///     else { fail!(\"nope\"); }\n /// }\n /// ```\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// Will raise an `io_error` condition if the provided `from` doesn't exist,\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n+/// Will return an error if the provided `from` doesn't exist, the process lacks\n+/// permissions to view the contents or if the `path` points at a non-directory\n+/// file\n pub fn readdir(path: &Path) -> IoResult<~[Path]> {\n     LocalIo::maybe_raise(|io| {\n         io.fs_readdir(&path.to_c_str(), 0)\n@@ -539,11 +518,10 @@ impl Iterator<Path> for Directories {\n /// Recursively create a directory and all of its parent components if they\n /// are missing.\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens, see `fs::mkdir` for more information about error conditions\n-/// and performance.\n+/// This function will return an `Err` value if an error happens, see\n+/// `fs::mkdir` for more information about error conditions and performance.\n pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     // tjc: if directory exists but with different permissions,\n     // should we return false?\n@@ -559,11 +537,10 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// Removes a directory at this path, after removing all its contents. Use\n /// carefully!\n ///\n-/// # Errors\n+/// # Error\n ///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens. See `file::unlink` and `fs::readdir` for possible error\n-/// conditions.\n+/// This function will return an `Err` value if an error happens. See\n+/// `file::unlink` and `fs::readdir` for possible error conditions.\n pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     let children = if_ok!(readdir(path));\n     for child in children.iter() {\n@@ -581,11 +558,6 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// The file at the path specified will have its last access time set to\n /// `atime` and its modification time set to `mtime`. The times specified should\n /// be in milliseconds.\n-///\n-/// # Errors\n-///\n-/// This function will raise on the `io_error` condition if an error\n-/// happens.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     LocalIo::maybe_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime))\n@@ -639,7 +611,7 @@ impl path::Path {\n     /// filesystem. This will return true if the path points to either a\n     /// directory or a file.\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn exists(&self) -> bool {\n@@ -651,7 +623,7 @@ impl path::Path {\n     /// to non-existent locations or directories or other non-regular files\n     /// (named pipes, etc).\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn is_file(&self) -> bool {\n@@ -666,7 +638,7 @@ impl path::Path {\n     /// Will return false for paths to non-existent locations or if the item is\n     /// not a directory (eg files, named pipes, links, etc)\n     ///\n-    /// # Errors\n+    /// # Error\n     ///\n     /// Will not raise a condition\n     pub fn is_dir(&self) -> bool {"}, {"sha": "395ece17eded6b94a53c7b9e78b81bfb76d8883f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -25,6 +25,7 @@ use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::MemWriter;\n ///\n /// let mut w = MemWriter::new();\n@@ -113,11 +114,12 @@ impl Seek for MemWriter {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::MemReader;\n ///\n /// let mut r = MemReader::new(~[0, 1, 2]);\n ///\n-/// assert_eq!(r.read_to_end(), ~[0, 1, 2]);\n+/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2]);\n /// ```\n pub struct MemReader {\n     priv buf: ~[u8],\n@@ -182,12 +184,13 @@ impl Buffer for MemReader {\n \n /// Writes to a fixed-size byte slice\n ///\n-/// If a write will not fit in the buffer, it raises the `io_error`\n-/// condition and does not write any data.\n+/// If a write will not fit in the buffer, it returns an error and does not\n+/// write any data.\n ///\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::BufWriter;\n ///\n /// let mut buf = [0, ..4];\n@@ -252,12 +255,13 @@ impl<'a> Seek for BufWriter<'a> {\n /// # Example\n ///\n /// ```rust\n+/// # #[allow(unused_must_use)];\n /// use std::io::BufReader;\n ///\n /// let mut buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(buf);\n ///\n-/// assert_eq!(r.read_to_end(), ~[0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), ~[0, 1, 2, 3]);\n /// ```\n pub struct BufReader<'a> {\n     priv buf: &'a [u8],"}, {"sha": "58a35e96393a3326353974060bb6b0664a144fb1", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 138, "deletions": 149, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -29,7 +29,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::stdin;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let mut stdin = BufferedReader::new(stdin());\n     for line in stdin.lines() {\n         print!(\"{}\", line);\n@@ -41,7 +40,6 @@ Some examples of obvious things you might want to do\n     ```rust\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n     ```\n \n@@ -50,7 +48,6 @@ Some examples of obvious things you might want to do\n     ```rust\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let mut file = File::create(&Path::new(\"message.txt\"));\n     file.write(bytes!(\"hello, file!\\n\"));\n     # drop(file);\n@@ -63,7 +60,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     for line in file.lines() {\n@@ -77,7 +73,6 @@ Some examples of obvious things you might want to do\n     use std::io::BufferedReader;\n     use std::io::File;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     let lines: ~[~str] = file.lines().collect();\n@@ -91,7 +86,6 @@ Some examples of obvious things you might want to do\n     use std::io::net::ip::SocketAddr;\n     use std::io::net::tcp::TcpStream;\n \n-    # let _g = ::std::io::ignore_io_error();\n     let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n     let mut socket = TcpStream::connect(addr).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n@@ -168,72 +162,50 @@ asynchronous request completes.\n # Error Handling\n \n I/O is an area where nearly every operation can result in unexpected\n-errors. It should allow errors to be handled efficiently.\n-It needs to be convenient to use I/O when you don't care\n-about dealing with specific errors.\n+errors. Errors should be painfully visible when they happen, and handling them\n+should be easy to work with. It should be convenient to handle specific I/O\n+errors, and it should also be convenient to not deal with I/O errors.\n \n Rust's I/O employs a combination of techniques to reduce boilerplate\n while still providing feedback about errors. The basic strategy:\n \n-* Errors are fatal by default, resulting in task failure\n-* Errors raise the `io_error` condition which provides an opportunity to inspect\n-  an IoError object containing details.\n-* Return values must have a sensible null or zero value which is returned\n-  if a condition is handled successfully. This may be an `Option`, an empty\n-  vector, or other designated error value.\n-* Common traits are implemented for `Option`, e.g. `impl<R: Reader> Reader for Option<R>`,\n-  so that nullable values do not have to be 'unwrapped' before use.\n+* All I/O operations return `IoResult<T>` which is equivalent to\n+  `Result<T, IoError>`. The core `Result` type is defined in the `std::result`\n+  module.\n+* If the `Result` type goes unused, then the compiler will by default emit a\n+  warning about the unused result.\n+* Common traits are implemented for `IoResult`, e.g.\n+  `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n+  to be 'unwrapped' before use.\n \n These features combine in the API to allow for expressions like\n `File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"))`\n without having to worry about whether \"diary.txt\" exists or whether\n the write succeeds. As written, if either `new` or `write_line`\n-encounters an error the task will fail.\n+encounters an error then the result of the entire expression will\n+be an error.\n \n If you wanted to handle the error though you might write:\n \n ```rust\n use std::io::File;\n-use std::io::{IoError, io_error};\n \n-let mut error = None;\n-io_error::cond.trap(|e: IoError| {\n-    error = Some(e);\n-}).inside(|| {\n-    File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"));\n-});\n-\n-if error.is_some() {\n-    println!(\"failed to write my diary\");\n+match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n+    Ok(()) => { /* succeeded */ }\n+    Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n+\n # ::std::io::fs::unlink(&Path::new(\"diary.txt\"));\n ```\n \n-FIXME: Need better condition handling syntax\n-\n-In this case the condition handler will have the opportunity to\n-inspect the IoError raised by either the call to `new` or the call to\n-`write_line`, but then execution will continue.\n-\n-So what actually happens if `new` encounters an error? To understand\n-that it's important to know that what `new` returns is not a `File`\n-but an `Option<File>`.  If the file does not open, and the condition\n-is handled, then `new` will simply return `None`. Because there is an\n-implementation of `Writer` (the trait required ultimately required for\n-types to implement `write_line`) there is no need to inspect or unwrap\n-the `Option<File>` and we simply call `write_line` on it.  If `new`\n-returned a `None` then the followup call to `write_line` will also\n-raise an error.\n-\n-## Concerns about this strategy\n-\n-This structure will encourage a programming style that is prone\n-to errors similar to null pointer dereferences.\n-In particular code written to ignore errors and expect conditions to be unhandled\n-will start passing around null or zero objects when wrapped in a condition handler.\n-\n-* FIXME: How should we use condition handlers that return values?\n-* FIXME: Should EOF raise default conditions when EOF is not an error?\n+So what actually happens if `create` encounters an error?\n+It's important to know that what `new` returns is not a `File`\n+but an `IoResult<File>`.  If the file does not open, then `new` will simply\n+return `Err(..)`. Because there is an implementation of `Writer` (the trait\n+required ultimately required for types to implement `write_line`) there is no\n+need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n+on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n+will also return an error.\n \n # Issues with i/o scheduler affinity, work stealing, task pinning\n \n@@ -460,40 +432,23 @@ impl ToStr for IoErrorKind {\n \n pub trait Reader {\n \n-    // Only two methods which need to get implemented for this trait\n+    // Only method which need to get implemented for this trait\n \n     /// Read bytes, up to the length of `buf` and place them in `buf`.\n     /// Returns the number of bytes read. The number of bytes read my\n-    /// be less than the number requested, even 0. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n+    /// be less than the number requested, even 0. Returns `Err` on EOF.\n     ///\n-    /// Raises the `io_error` condition on error. If the condition\n-    /// is handled then no guarantee is made about the number of bytes\n-    /// read and the contents of `buf`. If the condition is handled\n-    /// returns `None` (FIXME see below).\n+    /// # Error\n     ///\n-    /// # FIXME\n-    ///\n-    /// * Should raise_default error on eof?\n-    /// * If the condition is handled it should still return the bytes read,\n-    ///   in which case there's no need to return Option - but then you *have*\n-    ///   to install a handler to detect eof.\n-    ///\n-    /// This doesn't take a `len` argument like the old `read`.\n-    /// Will people often need to slice their vectors to call this\n-    /// and will that be annoying?\n-    /// Is it actually possible for 0 bytes to be read successfully?\n+    /// If an error occurs during this I/O operation, then it is returned as\n+    /// `Err(IoError)`. Note that end-of-file is considered an error, and can be\n+    /// inspected for in the error's `kind` field. Also note that reading 0\n+    /// bytes is not considered an error in all circumstances\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n \n     // Convenient helper methods based on the above methods\n \n-    /// Reads a single byte. Returns `None` on EOF.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as the `read` method. Returns\n-    /// `None` if the condition is handled.\n+    /// Reads a single byte. Returns `Err` on EOF.\n     fn read_byte(&mut self) -> IoResult<u8> {\n         let mut buf = [0];\n         loop {\n@@ -511,13 +466,9 @@ pub trait Reader {\n     /// Reads `len` bytes and appends them to a vector.\n     ///\n     /// May push fewer than the requested number of bytes on error\n-    /// or EOF. Returns true on success, false on EOF or error.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then `push_bytes` may push less\n-    /// than the requested number of bytes.\n+    /// or EOF. If `Ok(())` is returned, then all of the requested bytes were\n+    /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n+    /// read (an error was encountered), and the error is returned.\n     fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n         let start_len = buf.len();\n         let mut total_read = 0;\n@@ -542,29 +493,36 @@ pub trait Reader {\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises the same conditions as `read`. Additionally raises `io_error`\n-    /// on EOF. If `io_error` is handled then the returned vector may\n-    /// contain less than the requested number of bytes.\n+    /// Fails with the same conditions as `read`. Additionally returns error on\n+    /// on EOF. Note that if an error is returned, then some number of bytes may\n+    /// have already been consumed from the underlying reader, and they are lost\n+    /// (not returned as part of the error). If this is unacceptable, then it is\n+    /// recommended to use the `push_bytes` or `read` methods.\n     fn read_bytes(&mut self, len: uint) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(len);\n-        if_ok!(self.push_bytes(&mut buf, len));\n-        return Ok(buf);\n+        match self.push_bytes(&mut buf, len) {\n+            Ok(()) => Ok(buf),\n+            Err(e) => Err(e),\n+        }\n     }\n \n     /// Reads all remaining bytes from the stream.\n     ///\n-    /// # Failure\n+    /// # Error\n+    ///\n+    /// Returns any non-EOF error immediately. Previously read bytes are\n+    /// discarded when an error is returned.\n     ///\n-    /// Raises the same conditions as the `read` method except for\n-    /// `EndOfFile` which is swallowed.\n+    /// When EOF is encountered, all bytes read up to that point are returned,\n+    /// but if 0 bytes have been read then the EOF error is returned.\n     fn read_to_end(&mut self) -> IoResult<~[u8]> {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         loop {\n             match self.push_bytes(&mut buf, DEFAULT_BUF_SIZE) {\n                 Ok(()) => {}\n-                Err(ref e) if e.kind == EndOfFile => break,\n+                Err(ref e) if buf.len() > 0 && e.kind == EndOfFile => break,\n                 Err(e) => return Err(e)\n             }\n         }\n@@ -574,10 +532,11 @@ pub trait Reader {\n     /// Reads all of the remaining bytes of this stream, interpreting them as a\n     /// UTF-8 encoded stream. The corresponding string is returned.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise all the same conditions as the `read` method,\n-    /// along with raising a condition if the input is not valid UTF-8.\n+    /// This function returns all of the same errors as `read_to_end` with an\n+    /// additional error if the reader's contents are not a valid sequence of\n+    /// UTF-8 bytes.\n     fn read_to_str(&mut self) -> IoResult<~str> {\n         self.read_to_end().and_then(|s| {\n             match str::from_utf8_owned(s) {\n@@ -590,11 +549,12 @@ pub trait Reader {\n     /// Create an iterator that reads a single byte on\n     /// each iteration, until EOF.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises the same conditions as the `read` method, for\n-    /// each call to its `.next()` method.\n-    /// Ends the iteration if the condition is handled.\n+    /// The iterator protocol causes all specifics about errors encountered to\n+    /// be swallowed. All errors will be signified by returning `None` from the\n+    /// iterator. If this is undesirable, it is recommended to use the\n+    /// `read_byte` method.\n     fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self> {\n         extensions::Bytes::new(self)\n     }\n@@ -825,11 +785,14 @@ fn extend_sign(val: u64, nbytes: uint) -> i64 {\n }\n \n pub trait Writer {\n-    /// Write the given buffer\n+    /// Write the entirety of a given buffer\n     ///\n-    /// # Failure\n+    /// # Errors\n     ///\n-    /// Raises the `io_error` condition on error\n+    /// If an error happens during the I/O operation, the error is returned as\n+    /// `Err`. Note that it is considered an error if the entire buffer could\n+    /// not be written, and if an error is returned then it is unknown how much\n+    /// data (if any) was actually written.\n     fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n@@ -1021,11 +984,11 @@ impl<T: Reader + Writer> Stream for T {}\n /// an iteration, but continue to yield elements if iteration\n /// is attempted again.\n ///\n-/// # Failure\n+/// # Error\n ///\n-/// Raises the same conditions as the `read` method except for `EndOfFile`\n-/// which is swallowed.\n-/// Iteration yields `None` if the condition is handled.\n+/// This iterator will swallow all I/O errors, transforming `Err` values to\n+/// `None`. If errors need to be handled, it is recommended to use the\n+/// `read_line` method directly.\n pub struct Lines<'r, T> {\n     priv buffer: &'r mut T,\n }\n@@ -1049,10 +1012,11 @@ pub trait Buffer: Reader {\n     /// consumed from this buffer returned to ensure that the bytes are never\n     /// returned twice.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n+    /// This function will return an I/O error if the underlying reader was\n+    /// read, but returned an error. Note that it is not an error to return a\n+    /// 0-length buffer.\n     fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n@@ -1067,50 +1031,73 @@ pub trait Buffer: Reader {\n     ///\n     /// ```rust\n     /// use std::io::{BufferedReader, stdin};\n-    /// # let _g = ::std::io::ignore_io_error();\n     ///\n     /// let mut reader = BufferedReader::new(stdin());\n     ///\n-    /// let input = reader.read_line().unwrap_or(~\"nothing\");\n+    /// let input = reader.read_line().ok().unwrap_or(~\"nothing\");\n     /// ```\n     ///\n-    /// # Failure\n+    /// # Error\n+    ///\n+    /// This function has the same error semantics as `read_until`:\n+    ///\n+    /// * All non-EOF errors will be returned immediately\n+    /// * If an error is returned previously consumed bytes are lost\n+    /// * EOF is only returned if no bytes have been read\n+    /// * Reach EOF may mean that the delimiter is not present in the return\n+    ///   value\n     ///\n-    /// This function will raise on the `io_error` condition (except for\n-    /// `EndOfFile` which is swallowed) if a read error is encountered.\n-    /// The task will also fail if sequence of bytes leading up to\n-    /// the newline character are not valid UTF-8.\n+    /// Additionally, this function can fail if the line of input read is not a\n+    /// valid UTF-8 sequence of bytes.\n     fn read_line(&mut self) -> IoResult<~str> {\n-        self.read_until('\\n' as u8).map(|line| str::from_utf8_owned(line).unwrap())\n+        self.read_until('\\n' as u8).and_then(|line|\n+            match str::from_utf8_owned(line) {\n+                Some(s) => Ok(s),\n+                None => Err(standard_error(InvalidInput)),\n+            }\n+        )\n     }\n \n     /// Create an iterator that reads a line on each iteration until EOF.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Iterator raises the same conditions as the `read` method\n-    /// except for `EndOfFile`.\n+    /// This iterator will transform all error values to `None`, discarding the\n+    /// cause of the error. If this is undesirable, it is recommended to call\n+    /// `read_line` directly.\n     fn lines<'r>(&'r mut self) -> Lines<'r, Self> {\n-        Lines {\n-            buffer: self,\n-        }\n+        Lines { buffer: self }\n     }\n \n     /// Reads a sequence of bytes leading up to a specified delimiter. Once the\n     /// specified byte is encountered, reading ceases and the bytes up to and\n     /// including the delimiter are returned.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered, except that `EndOfFile` is swallowed.\n+    /// If any I/O error is encountered other than EOF, the error is immediately\n+    /// returned. Note that this may discard bytes which have already been read,\n+    /// and those bytes will *not* be returned. It is recommended to use other\n+    /// methods if this case is worrying.\n+    ///\n+    /// If EOF is encountered, then this function will return EOF if 0 bytes\n+    /// have been read, otherwise the pending byte buffer is returned. This\n+    /// is the reason that the byte buffer returned may not always contain the\n+    /// delimiter.\n     fn read_until(&mut self, byte: u8) -> IoResult<~[u8]> {\n         let mut res = ~[];\n \n         let mut used;\n         loop {\n             {\n-                let available = if_ok!(self.fill());\n+                let available = match self.fill() {\n+                    Ok(n) => n,\n+                    Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n+                        used = 0;\n+                        break\n+                    }\n+                    Err(e) => return Err(e)\n+                };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n                         res.push_all(available.slice_to(i + 1));\n@@ -1131,13 +1118,11 @@ pub trait Buffer: Reader {\n \n     /// Reads the next utf8-encoded character from the underlying stream.\n     ///\n-    /// This will return `None` if the following sequence of bytes in the\n-    /// stream are not a valid utf8-sequence, or if an I/O error is encountered.\n+    /// # Error\n     ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if a read error is\n-    /// encountered.\n+    /// If an I/O error occurs, or EOF, then this function will return `Err`.\n+    /// This function will also return error if the stream does not contain a\n+    /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n     fn read_char(&mut self) -> IoResult<char> {\n         let first_byte = if_ok!(self.read_byte());\n         let width = str::utf8_char_width(first_byte);\n@@ -1186,28 +1171,32 @@ pub trait Seek {\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n }\n \n-/// A listener is a value that can consume itself to start listening for connections.\n+/// A listener is a value that can consume itself to start listening for\n+/// connections.\n+///\n /// Doing so produces some sort of Acceptor.\n pub trait Listener<T, A: Acceptor<T>> {\n     /// Spin up the listener and start queuing incoming connections\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// Raises `io_error` condition. If the condition is handled,\n-    /// then `listen` returns `None`.\n+    /// Returns `Err` if this listener could not be bound to listen for\n+    /// connections. In all cases, this listener is consumed.\n     fn listen(self) -> IoResult<A>;\n }\n \n /// An acceptor is a value that presents incoming connections\n pub trait Acceptor<T> {\n     /// Wait for and accept an incoming connection\n     ///\n-    /// # Failure\n-    /// Raise `io_error` condition. If the condition is handled,\n-    /// then `accept` returns `None`.\n+    /// # Error\n+    ///\n+    /// Returns `Err` if an I/O error is encountered.\n     fn accept(&mut self) -> IoResult<T>;\n \n-    /// Create an iterator over incoming connection attempts\n+    /// Create an iterator over incoming connection attempts.\n+    ///\n+    /// Note that I/O errors will be yielded by the iterator itself.\n     fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n         IncomingConnections { inc: self }\n     }\n@@ -1216,10 +1205,10 @@ pub trait Acceptor<T> {\n /// An infinite iterator over incoming connection attempts.\n /// Calling `next` will block the task until a connection is attempted.\n ///\n-/// Since connection attempts can continue forever, this iterator always returns Some.\n-/// The Some contains another Option representing whether the connection attempt was succesful.\n-/// A successful connection will be wrapped in Some.\n-/// A failed connection is represented as a None and raises a condition.\n+/// Since connection attempts can continue forever, this iterator always returns\n+/// `Some`. The `Some` contains the `IoResult` representing whether the\n+/// connection attempt was succesful.  A successful connection will be wrapped\n+/// in `Ok`. A failed connection is represented as an `Err`.\n pub struct IncomingConnections<'a, A> {\n     priv inc: &'a mut A,\n }\n@@ -1265,7 +1254,7 @@ pub enum FileMode {\n }\n \n /// Access permissions with which the file should be opened. `File`s\n-/// opened with `Read` will raise an `io_error` condition if written to.\n+/// opened with `Read` will return an error if written to.\n pub enum FileAccess {\n     Read,\n     Write,"}, {"sha": "e9ffe97f1c356d6b41768ce74b95d465a0ff0b63", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -70,10 +70,6 @@ pub struct Info {\n \n /// Easy name resolution. Given a hostname, returns the list of IP addresses for\n /// that hostname.\n-///\n-/// # Failure\n-///\n-/// On failure, this will raise on the `io_error` condition.\n pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n     lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n }\n@@ -88,10 +84,6 @@ pub fn get_host_addresses(host: &str) -> IoResult<~[IpAddr]> {\n /// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n ///          controls lookup\n ///\n-/// # Failure\n-///\n-/// On failure, this will raise on the `io_error` condition.\n-///\n /// FIXME: this is not public because the `Hint` structure is not ready for public\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)"}, {"sha": "ce95b987663f7be8f6675c10f621921ddfe0613c", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -45,11 +45,6 @@ impl UnixStream {\n     ///\n     /// The returned stream will be closed when the object falls out of scope.\n     ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if the connection\n-    /// could not be made.\n-    ///\n     /// # Example\n     ///\n     /// ```rust\n@@ -86,11 +81,6 @@ impl UnixListener {\n     ///\n     /// This listener will be closed when it falls out of scope.\n     ///\n-    /// # Failure\n-    ///\n-    /// This function will raise on the `io_error` condition if the specified\n-    /// path could not be bound.\n-    ///\n     /// # Example\n     ///\n     /// ```"}, {"sha": "ca85707149b92f212559d23a9907214e40ab56b8", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -32,16 +32,14 @@ impl PipeStream {\n     ///\n     /// # Example\n     ///\n-    ///     use std::libc;\n-    ///     use std::io::pipe;\n+    /// ```rust\n+    /// # #[allow(unused_must_use)];\n+    /// use std::libc;\n+    /// use std::io::pipe::PipeStream;\n     ///\n-    ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(bytes!(\"Hello, stderr!\"));\n-    ///\n-    /// # Failure\n-    ///\n-    /// If the pipe cannot be created, an error will be raised on the\n-    /// `io_error` condition.\n+    /// let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n+    /// pipe.write(bytes!(\"Hello, stderr!\"));\n+    /// ```\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n         LocalIo::maybe_raise(|io| {\n             io.pipe_open(fd).map(|obj| PipeStream { obj: obj })"}, {"sha": "ccf3d4582def4d5bf566b0e4e7a92c7b9d12bc0a", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -141,7 +141,7 @@ impl Process {\n     /// Note that this is purely a wrapper around libuv's `uv_process_kill`\n     /// function.\n     ///\n-    /// If the signal delivery fails, then the `io_error` condition is raised on\n+    /// If the signal delivery fails, the corresponding error is returned.\n     pub fn signal(&mut self, signal: int) -> IoResult<()> {\n         self.handle.kill(signal)\n     }"}, {"sha": "8e03cffd0fb24c1399b2aa364a571a7c24b2d2c0", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementations of I/O traits for the Option type\n+//! Implementations of I/O traits for the IoResult type\n //!\n //! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `Option<File>` to be used\n-//! as a `Reader` without unwrapping the option first.\n+//! These implementations allow e.g. `IoResult<File>` to be used\n+//! as a `Reader` without unwrapping the result first.\n \n use clone::Clone;\n use result::{Ok, Err};"}, {"sha": "92b86afe24df54087a26928185d92083cac64aef", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -113,11 +113,10 @@ impl Listener {\n     /// a signal, and a later call to `recv` will return the signal that was\n     /// received while no task was waiting on it.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n     /// If this function fails to register a signal handler, then an error will\n-    /// be raised on the `io_error` condition and the function will return\n-    /// false.\n+    /// be returned.\n     pub fn register(&mut self, signum: Signum) -> io::IoResult<()> {\n         if self.handles.contains_key(&signum) {\n             return Ok(()); // self is already listening to signum, so succeed\n@@ -206,13 +205,11 @@ mod test {\n         use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;\n-        io::io_error::cond.trap(|_| {\n-            called = true;\n-        }).inside(|| {\n-            if s.register(User1) {\n+        match s.register(User1) {\n+            Ok(..) => {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);\n             }\n-        });\n-        assert!(called);\n+            Err(..) => {}\n+        }\n     }\n }"}, {"sha": "937ad0783e9ab43b3725ba88c9494785f3621d03", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -18,6 +18,7 @@ about the stream or terminal that it is attached to.\n # Example\n \n ```rust\n+# #[allow(unused_must_use)];\n use std::io;\n \n let mut out = io::stdout();\n@@ -283,12 +284,12 @@ impl StdWriter {\n     /// when the writer is attached to something like a terminal, this is used\n     /// to fetch the dimensions of the terminal.\n     ///\n-    /// If successful, returns Some((width, height)).\n+    /// If successful, returns `Ok((width, height))`.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if an error\n-    /// happens.\n+    /// This function will return an error if the output stream is not actually\n+    /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn winsize(&mut self) -> IoResult<(int, int)> {\n         match self.inner {\n             TTY(ref mut tty) => tty.get_winsize(),\n@@ -305,10 +306,10 @@ impl StdWriter {\n     /// Controls whether this output stream is a \"raw stream\" or simply a normal\n     /// stream.\n     ///\n-    /// # Failure\n+    /// # Error\n     ///\n-    /// This function will raise on the `io_error` condition if an error\n-    /// happens.\n+    /// This function will return an error if the output stream is not actually\n+    /// connected to a TTY instance, or if querying the TTY instance fails.\n     pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n         match self.inner {\n             TTY(ref mut tty) => tty.set_raw(raw),"}, {"sha": "8815f88d694e37fb0e898f3def18d39478ef9f34", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -372,9 +372,9 @@ pub fn self_exe_name() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         use std::io;\n \n-        match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n-            Ok(Some(path)) => Some(path.as_vec().to_owned()),\n-            Ok(None) | Err(..) => None\n+        match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n+            Ok(path) => Some(path.as_vec().to_owned()),\n+            Err(..) => None\n         }\n     }\n "}, {"sha": "f0ef5014ca81721e13355cee080de756b5e353b9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9a32cdabc1680b89bd7b579dc1e3f8f18c28257/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f9a32cdabc1680b89bd7b579dc1e3f8f18c28257", "patch": "@@ -2059,21 +2059,17 @@ pub fn print_generics(s: &mut State,\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n                 let param = generics.ty_params.get(idx);\n-<<<<<<< HEAD\n-                print_ident(s, param.ident);\n-                print_bounds(s, &param.bounds, false);\n+                if_ok!(print_ident(s, param.ident));\n+                if_ok!(print_bounds(s, &param.bounds, false));\n                 match param.default {\n                     Some(default) => {\n-                        space(&mut s.s);\n-                        word_space(s, \"=\");\n-                        print_type(s, default);\n+                        if_ok!(space(&mut s.s));\n+                        if_ok!(word_space(s, \"=\"));\n+                        if_ok!(print_type(s, default));\n                     }\n                     _ => {}\n                 }\n-=======\n-                if_ok!(print_ident(s, param.ident));\n-                print_bounds(s, &param.bounds, false)\n->>>>>>> syntax: Remove io_error usage\n+                Ok(())\n             }\n         }\n "}]}