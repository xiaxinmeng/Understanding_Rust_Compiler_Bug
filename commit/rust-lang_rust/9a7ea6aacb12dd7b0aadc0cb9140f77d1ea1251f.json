{"sha": "9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhN2VhNmFhY2IxMmRkN2IwYWFkYzBjYjkxNDBmNzdkMWVhMTI1MWY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-02-08T03:28:35Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-02-10T15:34:23Z"}, "message": "Handle a macro argument with a single keyword\n\nCloses #3331.", "tree": {"sha": "617dea8946bc550b7885700cb55311ec09c559bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/617dea8946bc550b7885700cb55311ec09c559bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "html_url": "https://github.com/rust-lang/rust/commit/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4611a0e6bda21408f814bfaeb5d961fc84c25ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4611a0e6bda21408f814bfaeb5d961fc84c25ff", "html_url": "https://github.com/rust-lang/rust/commit/c4611a0e6bda21408f814bfaeb5d961fc84c25ff"}], "stats": {"total": 119, "additions": 110, "deletions": 9}, "files": [{"sha": "6b4c353cfd2550ca7c6f96f41d129c517e7c6224", "filename": "src/macros.rs", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "patch": "@@ -26,7 +26,7 @@ use syntax::parse::parser::Parser;\n use syntax::parse::token::{BinOpToken, DelimToken, Token};\n use syntax::print::pprust;\n use syntax::source_map::{BytePos, Span};\n-use syntax::symbol;\n+use syntax::symbol::keywords;\n use syntax::tokenstream::{Cursor, TokenStream, TokenTree};\n use syntax::ThinVec;\n use syntax::{ast, parse, ptr};\n@@ -64,6 +64,7 @@ pub enum MacroArg {\n     Ty(ptr::P<ast::Ty>),\n     Pat(ptr::P<ast::Pat>),\n     Item(ptr::P<ast::Item>),\n+    Keyword(ast::Ident, Span),\n }\n \n impl MacroArg {\n@@ -92,6 +93,7 @@ impl Rewrite for MacroArg {\n             MacroArg::Ty(ref ty) => ty.rewrite(context, shape),\n             MacroArg::Pat(ref pat) => pat.rewrite(context, shape),\n             MacroArg::Item(ref item) => item.rewrite(context, shape),\n+            MacroArg::Keyword(ident, _) => Some(ident.to_string()),\n         }\n     }\n }\n@@ -156,7 +158,7 @@ fn rewrite_macro_name(\n         format!(\"{}!\", path)\n     };\n     match extra_ident {\n-        Some(ident) if ident != symbol::keywords::Invalid.ident() => format!(\"{} {}\", name, ident),\n+        Some(ident) if ident != keywords::Invalid.ident() => format!(\"{} {}\", name, ident),\n         _ => name,\n     }\n }\n@@ -224,6 +226,23 @@ pub fn rewrite_macro(\n     result\n }\n \n+fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n+    for &keyword in RUST_KEYWORDS.iter() {\n+        if parser.token.is_keyword(keyword)\n+            && parser.look_ahead(1, |t| {\n+                *t == Token::Eof\n+                    || *t == Token::Comma\n+                    || *t == Token::CloseDelim(DelimToken::NoDelim)\n+            })\n+        {\n+            let macro_arg = MacroArg::Keyword(keyword.ident(), parser.span);\n+            parser.bump();\n+            return Some(macro_arg);\n+        }\n+    }\n+    None\n+}\n+\n pub fn rewrite_macro_inner(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n@@ -276,11 +295,12 @@ pub fn rewrite_macro_inner(\n \n     if DelimToken::Brace != style {\n         loop {\n-            match parse_macro_arg(&mut parser) {\n-                Some(arg) => arg_vec.push(arg),\n-                None => {\n-                    return return_macro_parse_failure_fallback(context, shape.indent, mac.span);\n-                }\n+            if let Some(arg) = parse_macro_arg(&mut parser) {\n+                arg_vec.push(arg);\n+            } else if let Some(arg) = check_keyword(&mut parser) {\n+                arg_vec.push(arg);\n+            } else {\n+                return return_macro_parse_failure_fallback(context, shape.indent, mac.span);\n             }\n \n             match parser.token {\n@@ -1373,8 +1393,8 @@ fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream)\n     while parser.token != Token::Eof {\n         // Parse a `lazy_static!` item.\n         let vis = crate::utils::format_visibility(context, &parse_or!(parse_visibility, false));\n-        parser.eat_keyword(symbol::keywords::Static);\n-        parser.eat_keyword(symbol::keywords::Ref);\n+        parser.eat_keyword(keywords::Static);\n+        parser.eat_keyword(keywords::Ref);\n         let id = parse_or!(parse_ident);\n         parser.eat(&Token::Colon);\n         let ty = parse_or!(parse_ty);\n@@ -1449,3 +1469,66 @@ fn rewrite_macro_with_items(\n     result.push_str(trailing_semicolon);\n     Some(result)\n }\n+\n+const RUST_KEYWORDS: [keywords::Keyword; 60] = [\n+    keywords::PathRoot,\n+    keywords::DollarCrate,\n+    keywords::Underscore,\n+    keywords::As,\n+    keywords::Box,\n+    keywords::Break,\n+    keywords::Const,\n+    keywords::Continue,\n+    keywords::Crate,\n+    keywords::Else,\n+    keywords::Enum,\n+    keywords::Extern,\n+    keywords::False,\n+    keywords::Fn,\n+    keywords::For,\n+    keywords::If,\n+    keywords::Impl,\n+    keywords::In,\n+    keywords::Let,\n+    keywords::Loop,\n+    keywords::Match,\n+    keywords::Mod,\n+    keywords::Move,\n+    keywords::Mut,\n+    keywords::Pub,\n+    keywords::Ref,\n+    keywords::Return,\n+    keywords::SelfLower,\n+    keywords::SelfUpper,\n+    keywords::Static,\n+    keywords::Struct,\n+    keywords::Super,\n+    keywords::Trait,\n+    keywords::True,\n+    keywords::Type,\n+    keywords::Unsafe,\n+    keywords::Use,\n+    keywords::Where,\n+    keywords::While,\n+    keywords::Abstract,\n+    keywords::Become,\n+    keywords::Do,\n+    keywords::Final,\n+    keywords::Macro,\n+    keywords::Override,\n+    keywords::Priv,\n+    keywords::Typeof,\n+    keywords::Unsized,\n+    keywords::Virtual,\n+    keywords::Yield,\n+    keywords::Dyn,\n+    keywords::Async,\n+    keywords::Try,\n+    keywords::UnderscoreLifetime,\n+    keywords::StaticLifetime,\n+    keywords::Auto,\n+    keywords::Catch,\n+    keywords::Default,\n+    keywords::Existential,\n+    keywords::Union,\n+];"}, {"sha": "6a2895d4ff9c644db13a23e2fc86e028abcbfd6e", "filename": "src/overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "patch": "@@ -167,6 +167,7 @@ impl<'a> OverflowableItem<'a> {\n                 MacroArg::Ty(ref ty) => can_be_overflowed_type(context, ty, len),\n                 MacroArg::Pat(..) => false,\n                 MacroArg::Item(..) => len == 1,\n+                MacroArg::Keyword(..) => false,\n             },\n             OverflowableItem::NestedMetaItem(nested_meta_item) if len == 1 => {\n                 match nested_meta_item.node {"}, {"sha": "9c45d6ae7059a30692c646a598cee49b409a5b64", "filename": "src/spanned.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "patch": "@@ -198,6 +198,7 @@ impl Spanned for MacroArg {\n             MacroArg::Ty(ref ty) => ty.span(),\n             MacroArg::Pat(ref pat) => pat.span(),\n             MacroArg::Item(ref item) => item.span(),\n+            MacroArg::Keyword(_, span) => span,\n         }\n     }\n }"}, {"sha": "d41a72e52f1428dfcf4b1f2fac7b2c16f17e1ead", "filename": "tests/source/macros.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/tests%2Fsource%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/tests%2Fsource%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmacros.rs?ref=9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "patch": "@@ -463,3 +463,11 @@ fn issue3004() {\n     foo!(|_| { (  ) });\n     stringify!(( foo+ ));\n }\n+\n+// #3331\n+pub fn fold_abi<V: Fold + ?Sized>(_visitor: &mut V, _i: Abi) -> Abi {\n+    Abi {\n+        extern_token: Token ! [ extern ](tokens_helper(_visitor, &_i.extern_token.span)),\n+        name: (_i.name).map(|it| _visitor.fold_lit_str(it)),\n+    }\n+}"}, {"sha": "d0fe892d91be53d1ac8a8ae4194d7b3b1e997034", "filename": "tests/target/macros.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/tests%2Ftarget%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f/tests%2Ftarget%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmacros.rs?ref=9a7ea6aacb12dd7b0aadc0cb9140f77d1ea1251f", "patch": "@@ -1040,3 +1040,11 @@ fn issue3004() {\n     foo!(|_| { () });\n     stringify!((foo+));\n }\n+\n+// #3331\n+pub fn fold_abi<V: Fold + ?Sized>(_visitor: &mut V, _i: Abi) -> Abi {\n+    Abi {\n+        extern_token: Token![extern](tokens_helper(_visitor, &_i.extern_token.span)),\n+        name: (_i.name).map(|it| _visitor.fold_lit_str(it)),\n+    }\n+}"}]}