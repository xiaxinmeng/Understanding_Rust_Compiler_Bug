{"sha": "50f8aadd746ebc929a752e5ffb133936ee75c52f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjhhYWRkNzQ2ZWJjOTI5YTc1MmU1ZmZiMTMzOTM2ZWU3NWM1MmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T07:55:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-07T07:55:39Z"}, "message": "Auto merge of #66180 - Centril:rollup-c1ji943, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #59789 (Revert two unapproved changes to rustc_typeck.)\n - #65752 (Use structured suggestions for missing associated items)\n - #65884 (syntax: ABI-oblivious grammar)\n - #65974 (A scheme for more macro-matcher friendly pre-expansion gating)\n - #66017 (Add future incompatibility lint for `array.into_iter()`)\n\nFailed merges:\n\n - #66056 (rustc_metadata: Some reorganization of the module structure)\n\nr? @ghost", "tree": {"sha": "47453a165c08c24ca9b3224506ff74a2f8b053e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47453a165c08c24ca9b3224506ff74a2f8b053e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f8aadd746ebc929a752e5ffb133936ee75c52f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f8aadd746ebc929a752e5ffb133936ee75c52f", "html_url": "https://github.com/rust-lang/rust/commit/50f8aadd746ebc929a752e5ffb133936ee75c52f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f8aadd746ebc929a752e5ffb133936ee75c52f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a76fe76f756895b8cda1e10398f2268656a2e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a76fe76f756895b8cda1e10398f2268656a2e0f", "html_url": "https://github.com/rust-lang/rust/commit/7a76fe76f756895b8cda1e10398f2268656a2e0f"}, {"sha": "c9eae9ea63abe57d8bb91905d5ca4cff8dd8ea56", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9eae9ea63abe57d8bb91905d5ca4cff8dd8ea56", "html_url": "https://github.com/rust-lang/rust/commit/c9eae9ea63abe57d8bb91905d5ca4cff8dd8ea56"}], "stats": {"total": 1875, "additions": 1141, "deletions": 734}, "files": [{"sha": "0f770f3eadbea34a6df31f41aaa9e8e98a84c01c", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -3762,7 +3762,6 @@ dependencies = [\n  \"rustc\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n- \"rustc_target\",\n  \"serde_json\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -4362,7 +4361,6 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n- \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n@@ -4380,7 +4378,6 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n- \"rustc_target\",\n  \"scoped-tls\",\n  \"serialize\",\n  \"smallvec 1.0.0\","}, {"sha": "bbdb169cac0fc89b0052d44266172851f9abd462", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -205,6 +205,7 @@ pub trait FromIterator<A>: Sized {\n ///         .collect()\n /// }\n /// ```\n+#[rustc_diagnostic_item = \"IntoIterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n     /// The type of the elements being iterated over."}, {"sha": "f40b892a06bf24230a9132ede389d318023a8610", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -2336,6 +2336,7 @@ the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n+    E0703, // invalid ABI\n //  E0707, // multiple elided lifetimes used in arguments of `async fn`\n     E0708, // `async` non-`move` closures with parameters are not currently\n            // supported"}, {"sha": "6344c7a233ca40440eca0fb802c78c60189ba30d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1216,7 +1216,7 @@ impl<'a> LoweringContext<'a> {\n                                     ImplTraitContext::disallowed(),\n                                 ),\n                                 unsafety: this.lower_unsafety(f.unsafety),\n-                                abi: f.abi,\n+                                abi: this.lower_abi(f.abi),\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n                                 param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))"}, {"sha": "5fe463d783f4b53c578bac39d16d7b51a1c443ee", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -12,6 +12,7 @@ use crate::hir::def::{Res, DefKind};\n use crate::util::nodemap::NodeMap;\n \n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_target::spec::abi;\n \n use std::collections::BTreeSet;\n use smallvec::SmallVec;\n@@ -735,7 +736,7 @@ impl LoweringContext<'_> {\n \n     fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n         hir::ForeignMod {\n-            abi: fm.abi,\n+            abi: self.lower_abi(fm.abi),\n             items: fm.items\n                 .iter()\n                 .map(|x| self.lower_foreign_item(x))\n@@ -1291,10 +1292,30 @@ impl LoweringContext<'_> {\n             unsafety: self.lower_unsafety(h.unsafety),\n             asyncness: self.lower_asyncness(h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n-            abi: h.abi,\n+            abi: self.lower_abi(h.abi),\n         }\n     }\n \n+    pub(super) fn lower_abi(&mut self, abi: Abi) -> abi::Abi {\n+        abi::lookup(&abi.symbol.as_str()).unwrap_or_else(|| {\n+            self.error_on_invalid_abi(abi);\n+            abi::Abi::Rust\n+        })\n+    }\n+\n+    fn error_on_invalid_abi(&self, abi: Abi) {\n+        struct_span_err!(\n+            self.sess,\n+            abi.span,\n+            E0703,\n+            \"invalid ABI: found `{}`\",\n+            abi.symbol\n+        )\n+        .span_label(abi.span, \"invalid ABI\")\n+        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+        .emit();\n+    }\n+\n     pub(super) fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n         match u {\n             Unsafety::Unsafe => hir::Unsafety::Unsafe,"}, {"sha": "d409ca6f3c5f520e34f19f59f24021a081340166", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1075,6 +1075,13 @@ impl Mutability {\n             MutImmutable => MutMutable,\n         }\n     }\n+\n+    pub fn prefix_str(&self) -> &'static str {\n+        match self {\n+            MutMutable => \"mut \",\n+            MutImmutable => \"\",\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2184,6 +2191,15 @@ pub enum Unsafety {\n     Normal,\n }\n \n+impl Unsafety {\n+    pub fn prefix_str(&self) -> &'static str {\n+        match self {\n+            Unsafety::Unsafe => \"unsafe \",\n+            Unsafety::Normal => \"\",\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum Constness {\n     Const,"}, {"sha": "a25c111b598719df27e48746902b8082df2087b5", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1734,9 +1734,7 @@ impl<'a> State<'a> {\n                     _ => false,\n                 };\n                 self.s.word(\"&\");\n-                if mutbl == hir::MutMutable {\n-                    self.s.word(\"mut \");\n-                }\n+                self.s.word(mutbl.prefix_str());\n                 if is_range_inner {\n                     self.popen();\n                 }"}, {"sha": "2201c4b0980b3ba07c81f92771f17134ef311832", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -124,7 +124,6 @@ for ::syntax::attr::StabilityLevel {\n \n impl_stable_hash_for!(struct ::syntax::attr::RustcDeprecation { since, reason, suggestion });\n \n-\n impl_stable_hash_for!(enum ::syntax::attr::IntType {\n     SignedInt(int_ty),\n     UnsignedInt(uint_ty)\n@@ -136,6 +135,11 @@ impl_stable_hash_for!(enum ::syntax::ast::LitIntType {\n     Unsuffixed\n });\n \n+impl_stable_hash_for!(enum ::syntax::ast::LitFloatType {\n+    Suffixed(float_ty),\n+    Unsuffixed\n+});\n+\n impl_stable_hash_for!(struct ::syntax::ast::Lit {\n     kind,\n     token,\n@@ -148,8 +152,7 @@ impl_stable_hash_for!(enum ::syntax::ast::LitKind {\n     Byte(value),\n     Char(value),\n     Int(value, lit_int_type),\n-    Float(value, float_ty),\n-    FloatUnsuffixed(value),\n+    Float(value, lit_float_type),\n     Bool(value),\n     Err(value)\n });\n@@ -159,6 +162,7 @@ impl_stable_hash_for_spanned!(::syntax::ast::LitKind);\n impl_stable_hash_for!(enum ::syntax::ast::IntTy { Isize, I8, I16, I32, I64, I128 });\n impl_stable_hash_for!(enum ::syntax::ast::UintTy { Usize, U8, U16, U32, U64, U128 });\n impl_stable_hash_for!(enum ::syntax::ast::FloatTy { F32, F64 });\n+impl_stable_hash_for!(enum ::rustc_target::abi::FloatTy { F32, F64 });\n impl_stable_hash_for!(enum ::syntax::ast::Unsafety { Unsafe, Normal });\n impl_stable_hash_for!(enum ::syntax::ast::Constness { Const, NotConst });\n impl_stable_hash_for!(enum ::syntax::ast::Defaultness { Default, Final });"}, {"sha": "38edef50c966275d2e8c2965e308c5783bdc184f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -897,11 +897,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             } else {\n                 r.push(' ');\n             }\n-            s.push_highlighted(format!(\n-                \"&{}{}\",\n-                r,\n-                if mutbl == hir::MutMutable { \"mut \" } else { \"\" }\n-            ));\n+            s.push_highlighted(format!(\"&{}{}\", r, mutbl.prefix_str()));\n             s.push_normal(ty.to_string());\n         }\n "}, {"sha": "60aab6b6aa924b380c687c193368de220cd32960", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -538,7 +538,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ty::Uint(ity) => {\n                 scalar(Int(Integer::from_attr(dl, attr::UnsignedInt(ity)), false))\n             }\n-            ty::Float(fty) => scalar(Float(fty)),\n+            ty::Float(fty) => scalar(Float(match fty {\n+                ast::FloatTy::F32 => FloatTy::F32,\n+                ast::FloatTy::F64 => FloatTy::F64,\n+            })),\n             ty::FnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n                 ptr.valid_range = 1..=*ptr.valid_range.end();"}, {"sha": "ddbba972e51a7e2f22306f12bc2d920d2b903530", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -12,7 +12,6 @@ use rustc::ty::{self, Const, Instance, Ty, TyCtxt};\n use rustc::{bug, hir};\n use std::fmt::Write;\n use std::iter;\n-use syntax::ast;\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n@@ -39,20 +38,9 @@ impl DefPathBasedNames<'tcx> {\n             ty::Char => output.push_str(\"char\"),\n             ty::Str => output.push_str(\"str\"),\n             ty::Never => output.push_str(\"!\"),\n-            ty::Int(ast::IntTy::Isize) => output.push_str(\"isize\"),\n-            ty::Int(ast::IntTy::I8) => output.push_str(\"i8\"),\n-            ty::Int(ast::IntTy::I16) => output.push_str(\"i16\"),\n-            ty::Int(ast::IntTy::I32) => output.push_str(\"i32\"),\n-            ty::Int(ast::IntTy::I64) => output.push_str(\"i64\"),\n-            ty::Int(ast::IntTy::I128) => output.push_str(\"i128\"),\n-            ty::Uint(ast::UintTy::Usize) => output.push_str(\"usize\"),\n-            ty::Uint(ast::UintTy::U8) => output.push_str(\"u8\"),\n-            ty::Uint(ast::UintTy::U16) => output.push_str(\"u16\"),\n-            ty::Uint(ast::UintTy::U32) => output.push_str(\"u32\"),\n-            ty::Uint(ast::UintTy::U64) => output.push_str(\"u64\"),\n-            ty::Uint(ast::UintTy::U128) => output.push_str(\"u128\"),\n-            ty::Float(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-            ty::Float(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+            ty::Int(ty) => output.push_str(ty.name_str()),\n+            ty::Uint(ty) => output.push_str(ty.name_str()),\n+            ty::Float(ty) => output.push_str(ty.name_str()),\n             ty::Adt(adt_def, substs) => {\n                 self.push_def_path(adt_def.did, output);\n                 self.push_generic_params(substs, iter::empty(), output, debug);\n@@ -80,9 +68,7 @@ impl DefPathBasedNames<'tcx> {\n             }\n             ty::Ref(_, inner_type, mutbl) => {\n                 output.push('&');\n-                if mutbl == hir::MutMutable {\n-                    output.push_str(\"mut \");\n-                }\n+                output.push_str(mutbl.prefix_str());\n \n                 self.push_type_name(inner_type, output, debug);\n             }\n@@ -114,9 +100,7 @@ impl DefPathBasedNames<'tcx> {\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let sig = t.fn_sig(self.tcx);\n-                if sig.unsafety() == hir::Unsafety::Unsafe {\n-                    output.push_str(\"unsafe \");\n-                }\n+                output.push_str(sig.unsafety().prefix_str());\n \n                 let abi = sig.abi();\n                 if abi != ::rustc_target::spec::abi::Abi::Rust {"}, {"sha": "4c75e474011384ef432c1b421a5220d8f0d90f0d", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -466,9 +466,9 @@ pub trait PrettyPrinter<'tcx>:\n         match ty.kind {\n             ty::Bool => p!(write(\"bool\")),\n             ty::Char => p!(write(\"char\")),\n-            ty::Int(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Uint(t) => p!(write(\"{}\", t.ty_to_string())),\n-            ty::Float(t) => p!(write(\"{}\", t.ty_to_string())),\n+            ty::Int(t) => p!(write(\"{}\", t.name_str())),\n+            ty::Uint(t) => p!(write(\"{}\", t.name_str())),\n+            ty::Float(t) => p!(write(\"{}\", t.name_str())),\n             ty::RawPtr(ref tm) => {\n                 p!(write(\"*{} \", match tm.mutbl {\n                     hir::MutMutable => \"mut\",\n@@ -895,10 +895,11 @@ pub trait PrettyPrinter<'tcx>:\n                 let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let max = truncate(u128::max_value(), bit_size);\n \n+                let ui_str = ui.name_str();\n                 if data == max {\n-                    p!(write(\"std::{}::MAX\", ui))\n+                    p!(write(\"std::{}::MAX\", ui_str))\n                 } else {\n-                    p!(write(\"{}{}\", data, ui))\n+                    p!(write(\"{}{}\", data, ui_str))\n                 };\n             },\n             (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n@@ -911,10 +912,11 @@ pub trait PrettyPrinter<'tcx>:\n                 let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                     .unwrap()\n                     .size;\n+                let i_str = i.name_str();\n                 match data {\n-                    d if d == min => p!(write(\"std::{}::MIN\", i)),\n-                    d if d == max => p!(write(\"std::{}::MAX\", i)),\n-                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n+                    d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n+                    d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n+                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i_str))\n                 }\n             },\n             (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n@@ -1666,8 +1668,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TypeAndMut<'tcx> {\n-        p!(write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n-            print(self.ty))\n+        p!(write(\"{}\", self.mutbl.prefix_str()), print(self.ty))\n     }\n \n     ty::ExistentialTraitRef<'tcx> {\n@@ -1693,9 +1694,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::FnSig<'tcx> {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            p!(write(\"unsafe \"));\n-        }\n+        p!(write(\"{}\", self.unsafety.prefix_str()));\n \n         if self.abi != Abi::Rust {\n             p!(write(\"extern {} \", self.abi));"}, {"sha": "5f18bb1700c1445b6809cdbf30dacb4c6b83c61f", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -843,13 +843,13 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n         ty::Int(int_ty) => {\n-            (int_ty.ty_to_string(), DW_ATE_signed)\n+            (int_ty.name_str(), DW_ATE_signed)\n         },\n         ty::Uint(uint_ty) => {\n-            (uint_ty.ty_to_string(), DW_ATE_unsigned)\n+            (uint_ty.name_str(), DW_ATE_unsigned)\n         },\n         ty::Float(float_ty) => {\n-            (float_ty.ty_to_string(), DW_ATE_float)\n+            (float_ty.name_str(), DW_ATE_float)\n         },\n         _ => bug!(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };"}, {"sha": "a4c3b42f51e9e5e2e4b73b862e907e6f9022ab0f", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -18,8 +18,8 @@ use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n-use syntax::ast::{self, FloatTy};\n-use rustc_target::abi::HasDataLayout;\n+use rustc_target::abi::{FloatTy, HasDataLayout};\n+use syntax::ast;\n \n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::traits::*;\n@@ -1335,7 +1335,7 @@ fn generic_simd_intrinsic(\n             },\n             ty::Float(f) => {\n                 return_error!(\"unsupported element type `{}` of floating-point vector `{}`\",\n-                              f, in_ty);\n+                              f.name_str(), in_ty);\n             },\n             _ => {\n                 return_error!(\"`{}` is not a floating-point type\", in_ty);"}, {"sha": "f40b942b1e3229282a35ccea6101984df91b0b7e", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -37,9 +37,9 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),\n         ty::Never => output.push_str(\"!\"),\n-        ty::Int(int_ty) => output.push_str(int_ty.ty_to_string()),\n-        ty::Uint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n-        ty::Float(float_ty) => output.push_str(float_ty.ty_to_string()),\n+        ty::Int(int_ty) => output.push_str(int_ty.name_str()),\n+        ty::Uint(uint_ty) => output.push_str(uint_ty.name_str()),\n+        ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n             push_item_name(tcx, def.did, qualified, output);\n@@ -76,9 +76,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n             if !cpp_like_names {\n                 output.push('&');\n             }\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n+            output.push_str(mutbl.prefix_str());\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n@@ -140,9 +138,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n \n \n             let sig = t.fn_sig(tcx);\n-            if sig.unsafety() == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n+            output.push_str(sig.unsafety().prefix_str());\n \n             let abi = sig.abi();\n             if abi != rustc_target::spec::abi::Abi::Rust {"}, {"sha": "35b93db1d6590db12d7ffec982d186a77e18277b", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -27,7 +27,6 @@ rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }\n-rustc_target = { path = \"../librustc_target\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }\n rustc_errors = { path = \"../librustc_errors\" }\n@@ -36,3 +35,6 @@ rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n tempfile = \"3.0.5\"\n once_cell = \"1\"\n+\n+[dev-dependencies]\n+rustc_target = { path = \"../librustc_target\" }"}, {"sha": "e73414174fb3524002bedbaee0d342660c26ff46", "filename": "src/librustc_lint/array_into_iter.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,91 @@\n+use crate::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::{\n+    lint::FutureIncompatibleInfo,\n+    hir,\n+    ty::{\n+        self,\n+        adjustment::{Adjust, Adjustment},\n+    },\n+};\n+use syntax::{\n+    errors::Applicability,\n+    symbol::sym,\n+};\n+\n+\n+declare_lint! {\n+    pub ARRAY_INTO_ITER,\n+    Warn,\n+    \"detects calling `into_iter` on arrays\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #66145 <https://github.com/rust-lang/rust/issues/66145>\",\n+        edition: None,\n+    };\n+}\n+\n+declare_lint_pass!(\n+    /// Checks for instances of calling `into_iter` on arrays.\n+    ArrayIntoIter => [ARRAY_INTO_ITER]\n+);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+        // We only care about method call expressions.\n+        if let hir::ExprKind::MethodCall(call, span, args) = &expr.kind {\n+            if call.ident.name != sym::into_iter {\n+                return;\n+            }\n+\n+            // Check if the method call actually calls the libcore\n+            // `IntoIterator::into_iter`.\n+            let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n+            match cx.tcx.trait_of_item(def_id) {\n+                Some(trait_id) if cx.tcx.is_diagnostic_item(sym::IntoIterator, trait_id) => {},\n+                _ => return,\n+            };\n+\n+            // As this is a method call expression, we have at least one\n+            // argument.\n+            let receiver_arg = &args[0];\n+\n+            // Test if the original `self` type is an array type.\n+            match cx.tables.expr_ty(receiver_arg).kind {\n+                ty::Array(..) => {}\n+                _ => return,\n+            }\n+\n+            // Make sure that the first adjustment is an autoref coercion.\n+            match cx.tables.expr_adjustments(receiver_arg).get(0) {\n+                Some(Adjustment { kind: Adjust::Borrow(_), .. }) => {}\n+                _ => return,\n+            }\n+\n+            // Emit lint diagnostic.\n+            let target = match cx.tables.expr_ty_adjusted(receiver_arg).kind {\n+                ty::Ref(_, ty::TyS { kind: ty::Array(..), ..}, _) => \"[T; N]\",\n+                ty::Ref(_, ty::TyS { kind: ty::Slice(..), ..}, _) => \"[T]\",\n+\n+                // We know the original first argument type is an array type,\n+                // we know that the first adjustment was an autoref coercion\n+                // and we know that `IntoIterator` is the trait involved. The\n+                // array cannot be coerced to something other than a reference\n+                // to an array or to a slice.\n+                _ => bug!(\"array type coerced to something other than array or slice\"),\n+            };\n+            let msg = format!(\n+                \"this method call currently resolves to `<&{} as IntoIterator>::into_iter` (due \\\n+                    to autoref coercions), but that might change in the future when \\\n+                    `IntoIterator` impls for arrays are added.\",\n+                target,\n+            );\n+            cx.struct_span_lint(ARRAY_INTO_ITER, *span, &msg)\n+                .span_suggestion(\n+                    call.ident.span,\n+                    \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n+                    \"iter\".into(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+}"}, {"sha": "d1dc1d0fb686d2df53b6b571301554a3221b7e4d", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -22,6 +22,7 @@\n #[macro_use]\n extern crate rustc;\n \n+mod array_into_iter;\n mod error_codes;\n mod nonstandard_style;\n mod redundant_semicolon;\n@@ -57,6 +58,7 @@ use types::*;\n use unused::*;\n use non_ascii_idents::*;\n use rustc::lint::internal::*;\n+use array_into_iter::ArrayIntoIter;\n \n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n@@ -131,6 +133,8 @@ macro_rules! late_lint_passes {\n             // FIXME: Turn the computation of types which implement Debug into a query\n             // and change this to a module lint pass\n             MissingDebugImplementations: MissingDebugImplementations::default(),\n+\n+            ArrayIntoIter: ArrayIntoIter,\n         ]);\n     )\n }"}, {"sha": "65e0940920bd741a3babfa0f4e7027c83aca450a", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -68,7 +68,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n     max: u128,\n     expr: &'tcx hir::Expr,\n     parent_expr: &'tcx hir::Expr,\n-    ty: impl std::fmt::Debug,\n+    ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n@@ -83,15 +83,15 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n             let mut err = cx.struct_span_lint(\n                 OVERFLOWING_LITERALS,\n                 parent_expr.span,\n-                &format!(\"range endpoint is out of range for `{:?}`\", ty),\n+                &format!(\"range endpoint is out of range for `{}`\", ty),\n             );\n             if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n                 use ast::{LitKind, LitIntType};\n                 // We need to preserve the literal's suffix,\n                 // as it may determine typing information.\n                 let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s),\n+                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n                     LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n                     _ => bug!(),\n                 };\n@@ -161,11 +161,11 @@ fn report_bin_hex_error(\n     let (t, actually) = match ty {\n         attr::IntType::SignedInt(t) => {\n             let actually = sign_extend(val, size) as i128;\n-            (format!(\"{:?}\", t), actually.to_string())\n+            (t.name_str(), actually.to_string())\n         }\n         attr::IntType::UnsignedInt(t) => {\n             let actually = truncate(val, size);\n-            (format!(\"{:?}\", t), actually.to_string())\n+            (t.name_str(), actually.to_string())\n         }\n     };\n     let mut err = cx.struct_span_lint(\n@@ -204,7 +204,7 @@ fn report_bin_hex_error(\n //  - `uX` => `uY`\n //\n // No suggestion for: `isize`, `usize`.\n-fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<String> {\n+fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static str> {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     macro_rules! find_fit {\n@@ -215,10 +215,10 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<String> {\n                 match $ty {\n                     $($type => {\n                         $(if !negative && val <= uint_ty_range($utypes).1 {\n-                            return Some(format!(\"{:?}\", $utypes))\n+                            return Some($utypes.name_str())\n                         })*\n                         $(if val <= int_ty_range($itypes).1 as u128 + _neg {\n-                            return Some(format!(\"{:?}\", $itypes))\n+                            return Some($itypes.name_str())\n                         })*\n                         None\n                     },)+\n@@ -281,7 +281,7 @@ fn lint_int_literal<'a, 'tcx>(\n         if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n             if let hir::ExprKind::Struct(..) = par_e.kind {\n                 if is_range_literal(cx.sess(), par_e)\n-                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t)\n+                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n                 {\n                     // The overflowing literal lint was overridden.\n                     return;\n@@ -292,7 +292,7 @@ fn lint_int_literal<'a, 'tcx>(\n         cx.span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{:?}`\", t),\n+            &format!(\"literal out of range for `{}`\", t.name_str()),\n         );\n     }\n }\n@@ -338,6 +338,7 @@ fn lint_uint_literal<'a, 'tcx>(\n                 }\n                 hir::ExprKind::Struct(..)\n                     if is_range_literal(cx.sess(), par_e) => {\n+                        let t = t.name_str();\n                         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n                             // The overflowing literal lint was overridden.\n                             return;\n@@ -353,7 +354,7 @@ fn lint_uint_literal<'a, 'tcx>(\n         cx.span_lint(\n             OVERFLOWING_LITERALS,\n             e.span,\n-            &format!(\"literal out of range for `{:?}`\", t),\n+            &format!(\"literal out of range for `{}`\", t.name_str()),\n         );\n     }\n }\n@@ -379,8 +380,7 @@ fn lint_literal<'a, 'tcx>(\n         }\n         ty::Float(t) => {\n             let is_infinite = match lit.node {\n-                ast::LitKind::Float(v, _) |\n-                ast::LitKind::FloatUnsuffixed(v) => {\n+                ast::LitKind::Float(v, _) => {\n                     match t {\n                         ast::FloatTy::F32 => v.as_str().parse().map(f32::is_infinite),\n                         ast::FloatTy::F64 => v.as_str().parse().map(f64::is_infinite),\n@@ -389,9 +389,11 @@ fn lint_literal<'a, 'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.span_lint(OVERFLOWING_LITERALS,\n-                             e.span,\n-                             &format!(\"literal out of range for `{:?}`\", t));\n+                cx.span_lint(\n+                    OVERFLOWING_LITERALS,\n+                    e.span,\n+                    &format!(\"literal out of range for `{}`\", t.name_str()),\n+                );\n             }\n         }\n         _ => {}"}, {"sha": "b01b99ffcfb09da2458caf6c58c29a6733b7b1a2", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -95,8 +95,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     generics_of => {\n         tcx.arena.alloc(cdata.get_generics(def_id.index, tcx.sess))\n     }\n-    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-    predicates_defined_on => { cdata.get_predicates_defined_on(def_id.index, tcx) }\n+    explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n+    inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n         tcx.arena.alloc(cdata.get_trait_def(def_id.index, tcx.sess))"}, {"sha": "771d01a4b6a1dbe67dec3a95092d4847f825b0bd", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -658,20 +658,22 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    crate fn get_predicates(\n+    crate fn get_explicit_predicates(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n+        self.root.per_def.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n-    crate fn get_predicates_defined_on(\n+    crate fn get_inferred_outlives(\n         &self,\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.per_def.predicates_defined_on.get(self, item_id).unwrap().decode((self, tcx))\n+    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n+        self.root.per_def.inferred_outlives.get(self, item_id).map(|predicates| {\n+            predicates.decode((self, tcx))\n+        }).unwrap_or_default()\n     }\n \n     crate fn get_super_predicates("}, {"sha": "618d342f6fe756d4495bac951b426047d96aa329", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -76,8 +76,8 @@ struct PerDefTables<'tcx> {\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n-    predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n-    predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    explicit_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    inferred_outlives: PerDefTable<Lazy<&'tcx [(ty::Predicate<'tcx>, Span)]>>,\n     super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n@@ -524,8 +524,8 @@ impl<'tcx> EncodeContext<'tcx> {\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n-            predicates: self.per_def.predicates.encode(&mut self.opaque),\n-            predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            explicit_predicates: self.per_def.explicit_predicates.encode(&mut self.opaque),\n+            inferred_outlives: self.per_def.inferred_outlives.encode(&mut self.opaque),\n             super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n@@ -675,7 +675,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -718,7 +719,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -776,7 +778,8 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n \n     fn encode_struct_ctor(&mut self, adt_def_id: DefId, def_id: DefId) {\n@@ -819,7 +822,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -829,15 +833,18 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.generics[def_id] <- self.tcx.generics_of(def_id));\n     }\n \n-    fn encode_predicates(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates({:?})\", def_id);\n-        record!(self.per_def.predicates[def_id] <- self.tcx.predicates_of(def_id));\n+    fn encode_explicit_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_explicit_predicates({:?})\", def_id);\n+        record!(self.per_def.explicit_predicates[def_id] <-\n+            self.tcx.explicit_predicates_of(def_id));\n     }\n \n-    fn encode_predicates_defined_on(&mut self, def_id: DefId) {\n-        debug!(\"EncodeContext::encode_predicates_defined_on({:?})\", def_id);\n-        record!(self.per_def.predicates_defined_on[def_id] <-\n-            self.tcx.predicates_defined_on(def_id))\n+    fn encode_inferred_outlives(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_inferred_outlives({:?})\", def_id);\n+        let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n+        if !inferred_outlives.is_empty() {\n+            record!(self.per_def.inferred_outlives[def_id] <- inferred_outlives);\n+        }\n     }\n \n     fn encode_super_predicates(&mut self, def_id: DefId) {\n@@ -919,7 +926,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -986,7 +994,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n             hir::ImplItemKind::Method(ref sig, _) => {\n@@ -1260,22 +1269,11 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n                 self.encode_generics(def_id);\n-                self.encode_predicates(def_id);\n+                self.encode_explicit_predicates(def_id);\n+                self.encode_inferred_outlives(def_id);\n             }\n             _ => {}\n         }\n-        // The only time that `predicates_defined_on` is used (on\n-        // an external item) is for traits, during chalk lowering,\n-        // so only encode it in that case as an efficiency\n-        // hack. (No reason not to expand it in the future if\n-        // necessary.)\n-        match item.kind {\n-            hir::ItemKind::Trait(..) |\n-            hir::ItemKind::TraitAlias(..) => {\n-                self.encode_predicates_defined_on(def_id);\n-            }\n-            _ => {} // not *wrong* for other kinds of items, but not needed\n-        }\n         match item.kind {\n             hir::ItemKind::Trait(..) |\n             hir::ItemKind::TraitAlias(..) => {\n@@ -1377,7 +1375,8 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id);\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -1588,7 +1587,8 @@ impl EncodeContext<'tcx> {\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n-        self.encode_predicates(def_id);\n+        self.encode_explicit_predicates(def_id);\n+        self.encode_inferred_outlives(def_id);\n     }\n }\n "}, {"sha": "f644b7264320b79076c4e6fe2c643fc2a1e5740c", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -244,8 +244,13 @@ crate struct LazyPerDefTables<'tcx> {\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-    pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n+    // doesn't handle shorthands in its own (de)serialization impls,\n+    // as it's an `enum` for which we want to derive (de)serialization,\n+    // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n+    // Also, as an optimization, a missing entry indicates an empty `&[]`.\n+    pub inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n     pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n \n     pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),"}, {"sha": "b9e75a576cad877ba5c03b27488e29fb2ad2f75a", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -45,10 +45,7 @@ crate fn lit_to_const<'tcx>(\n             trunc(n as u128)?\n         },\n         LitKind::Int(n, _) => trunc(n)?,\n-        LitKind::Float(n, fty) => {\n-            parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n+        LitKind::Float(n, _) => {\n             let fty = match ty.kind {\n                 ty::Float(fty) => fty,\n                 _ => bug!()"}, {"sha": "477ad10460f6b8445cf71c6427e5e870033bc771", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -293,10 +293,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 match self.ty.kind {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n-                        write!(f, \"&\")?;\n-                        if mutbl == hir::MutMutable {\n-                            write!(f, \"mut \")?;\n-                        }\n+                        write!(f, \"&{}\", mutbl.prefix_str())?;\n                     }\n                     _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n                 }"}, {"sha": "2d93585e50ee471a47a8883a4fc3e7fe82554b17", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -13,7 +13,6 @@ log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n-rustc_target = { path = \"../librustc_target\" }\n serde_json = \"1\"\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "019e92717b5d67e8b91970a4f7e4b353a92b22c1", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -32,7 +32,7 @@ use rls_data::{SigElement, Signature};\n use rustc::hir::def::{Res, DefKind};\n use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n-\n+use syntax_pos::sym;\n \n pub fn item_signature(item: &ast::Item, scx: &SaveContext<'_, '_>) -> Option<Signature> {\n     if !scx.config.signatures {\n@@ -157,6 +157,12 @@ fn text_sig(text: String) -> Signature {\n     }\n }\n \n+fn push_abi(text: &mut String, abi: ast::Abi) {\n+    if abi.symbol != sym::Rust {\n+        text.push_str(&format!(\"extern \\\"{}\\\" \", abi.symbol));\n+    }\n+}\n+\n impl Sig for ast::Ty {\n     fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let id = Some(self.id);\n@@ -231,11 +237,7 @@ impl Sig for ast::Ty {\n                 if f.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                if f.abi != rustc_target::spec::abi::Abi::Rust {\n-                    text.push_str(\"extern\");\n-                    text.push_str(&f.abi.to_string());\n-                    text.push(' ');\n-                }\n+                push_abi(&mut text, f.abi);\n                 text.push_str(\"fn(\");\n \n                 let mut defs = vec![];\n@@ -385,11 +387,7 @@ impl Sig for ast::Item {\n                 if header.unsafety == ast::Unsafety::Unsafe {\n                     text.push_str(\"unsafe \");\n                 }\n-                if header.abi != rustc_target::spec::abi::Abi::Rust {\n-                    text.push_str(\"extern\");\n-                    text.push_str(&header.abi.to_string());\n-                    text.push(' ');\n-                }\n+                push_abi(&mut text, header.abi);\n                 text.push_str(\"fn \");\n \n                 let mut sig = name_and_generics(text, offset, generics, self.id, self.ident, scx)?;\n@@ -948,11 +946,7 @@ fn make_method_signature(\n     if m.header.unsafety == ast::Unsafety::Unsafe {\n         text.push_str(\"unsafe \");\n     }\n-    if m.header.abi != rustc_target::spec::abi::Abi::Rust {\n-        text.push_str(\"extern\");\n-        text.push_str(&m.header.abi.to_string());\n-        text.push(' ');\n-    }\n+    push_abi(&mut text, m.header.abi);\n     text.push_str(\"fn \");\n \n     let mut sig = name_and_generics(text, 0, generics, id, ident, scx)?;"}, {"sha": "e58caed0c99dda623a4ec0f0d0fa1ddb9b1b8067", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -3,11 +3,9 @@ pub use Primitive::*;\n \n use crate::spec::Target;\n \n-use std::fmt;\n use std::ops::{Add, Deref, Sub, Mul, AddAssign, Range, RangeInclusive};\n \n use rustc_index::vec::{Idx, IndexVec};\n-use syntax_pos::symbol::{sym, Symbol};\n use syntax_pos::Span;\n \n pub mod call;\n@@ -534,49 +532,13 @@ impl Integer {\n     }\n }\n \n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n-         PartialOrd, Ord)]\n+         PartialOrd, Ord, Debug)]\n pub enum FloatTy {\n     F32,\n     F64,\n }\n \n-impl fmt::Debug for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for FloatTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n-impl FloatTy {\n-    pub fn ty_to_string(self) -> &'static str {\n-        match self {\n-            FloatTy::F32 => \"f32\",\n-            FloatTy::F64 => \"f64\",\n-        }\n-    }\n-\n-    pub fn to_symbol(self) -> Symbol {\n-        match self {\n-            FloatTy::F32 => sym::f32,\n-            FloatTy::F64 => sym::f64,\n-        }\n-    }\n-\n-    pub fn bit_width(self) -> usize {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n-}\n-\n /// Fundamental unit of memory access and layout.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Primitive {"}, {"sha": "ded655c1ae32af5918b47c3367e704280996661b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -341,10 +341,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                                          tstr);\n         match self.expr_ty.kind {\n             ty::Ref(_, _, mt) => {\n-                let mtstr = match mt {\n-                    hir::MutMutable => \"mut \",\n-                    hir::MutImmutable => \"\",\n-                };\n+                let mtstr = mt.prefix_str();\n                 if self.cast_ty.is_trait() {\n                     match fcx.tcx.sess.source_map().span_to_snippet(self.cast_span) {\n                         Ok(s) => {"}, {"sha": "bc1189e443e2843b6f847249e9edeeeade6cb3cc", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -592,20 +592,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             cause.span,\n                             target_id,\n                         );\n-                        let val = match ty.kind {\n-                            ty::Bool => \"true\",\n-                            ty::Char => \"'a'\",\n-                            ty::Int(_) | ty::Uint(_) => \"42\",\n-                            ty::Float(_) => \"3.14159\",\n-                            ty::Error | ty::Never => return,\n-                            _ => \"value\",\n-                        };\n-                        let msg = \"give it a value of the expected type\";\n-                        let label = destination.label\n-                            .map(|l| format!(\" {}\", l.ident))\n-                            .unwrap_or_else(String::new);\n-                        let sugg = format!(\"break{} {}\", label, val);\n-                        err.span_suggestion(expr.span, msg, sugg, Applicability::HasPlaceholders);\n+                        if let Some(val) = ty_kind_suggestion(ty) {\n+                            let label = destination.label\n+                                .map(|l| format!(\" {}\", l.ident))\n+                                .unwrap_or_else(String::new);\n+                            err.span_suggestion(\n+                                expr.span,\n+                                \"give it a value of the expected type\",\n+                                format!(\"break{} {}\", label, val),\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n                     }, false);\n                 }\n             } else {\n@@ -1725,3 +1722,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx.mk_unit()\n     }\n }\n+\n+pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n+    Some(match ty.kind {\n+        ty::Bool => \"true\",\n+        ty::Char => \"'a'\",\n+        ty::Int(_) | ty::Uint(_) => \"42\",\n+        ty::Float(_) => \"3.14159\",\n+        ty::Error | ty::Never => return None,\n+        _ => \"value\",\n+    })\n+}"}, {"sha": "fe2c7a200d202a7cb51432b596b1bc636b3d5de6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 127, "deletions": 30, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -127,7 +127,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{kw, sym, Ident};\n use syntax::util::parser::ExprPrecedence;\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n@@ -1800,12 +1800,12 @@ fn check_specialization_validity<'tcx>(\n \n fn check_impl_items_against_trait<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_span: Span,\n+    full_impl_span: Span,\n     impl_id: DefId,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef],\n ) {\n-    let impl_span = tcx.sess.source_map().def_span(impl_span);\n+    let impl_span = tcx.sess.source_map().def_span(full_impl_span);\n \n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n@@ -1925,35 +1925,132 @@ fn check_impl_items_against_trait<'tcx>(\n     }\n \n     if !missing_items.is_empty() {\n-        let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n-            \"not all trait items implemented, missing: `{}`\",\n-            missing_items.iter()\n-                .map(|trait_item| trait_item.ident.to_string())\n-                .collect::<Vec<_>>().join(\"`, `\"));\n-        err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n-                missing_items.iter()\n-                    .map(|trait_item| trait_item.ident.to_string())\n-                    .collect::<Vec<_>>().join(\"`, `\")));\n-        for trait_item in missing_items {\n-            if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n-                err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n-            } else {\n-                err.note_trait_signature(trait_item.ident.to_string(),\n-                                         trait_item.signature(tcx));\n-            }\n-        }\n-        err.emit();\n+        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n     }\n \n     if !invalidated_items.is_empty() {\n         let invalidator = overridden_associated_type.unwrap();\n-        span_err!(tcx.sess, invalidator.span, E0399,\n-                  \"the following trait items need to be reimplemented \\\n-                   as `{}` was overridden: `{}`\",\n-                  invalidator.ident,\n-                  invalidated_items.iter()\n-                                   .map(|name| name.to_string())\n-                                   .collect::<Vec<_>>().join(\"`, `\"))\n+        span_err!(\n+            tcx.sess,\n+            invalidator.span,\n+            E0399,\n+            \"the following trait items need to be reimplemented as `{}` was overridden: `{}`\",\n+            invalidator.ident,\n+            invalidated_items.iter()\n+                .map(|name| name.to_string())\n+                .collect::<Vec<_>>().join(\"`, `\")\n+        )\n+    }\n+}\n+\n+fn missing_items_err(\n+    tcx: TyCtxt<'_>,\n+    impl_span: Span,\n+    missing_items: &[ty::AssocItem],\n+    full_impl_span: Span,\n+) {\n+    let missing_items_msg = missing_items.iter()\n+        .map(|trait_item| trait_item.ident.to_string())\n+        .collect::<Vec<_>>().join(\"`, `\");\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0046,\n+        \"not all trait items implemented, missing: `{}`\",\n+        missing_items_msg\n+    );\n+    err.span_label(impl_span, format!(\"missing `{}` in implementation\", missing_items_msg));\n+\n+    // `Span` before impl block closing brace.\n+    let hi = full_impl_span.hi() - BytePos(1);\n+    // Point at the place right before the closing brace of the relevant `impl` to suggest\n+    // adding the associated item at the end of its body.\n+    let sugg_sp = full_impl_span.with_lo(hi).with_hi(hi);\n+    // Obtain the level of indentation ending in `sugg_sp`.\n+    let indentation = tcx.sess.source_map().span_to_margin(sugg_sp).unwrap_or(0);\n+    // Make the whitespace that will make the suggestion have the right indentation.\n+    let padding: String = (0..indentation).map(|_| \" \").collect();\n+\n+    for trait_item in missing_items {\n+        let snippet = suggestion_signature(&trait_item, tcx);\n+        let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n+        let msg = format!(\"implement the missing item: `{}`\", snippet);\n+        let appl = Applicability::HasPlaceholders;\n+        if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n+            err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n+            err.tool_only_span_suggestion(sugg_sp, &msg, code, appl);\n+        } else {\n+            err.span_suggestion_hidden(sugg_sp, &msg, code, appl);\n+        }\n+    }\n+    err.emit();\n+}\n+\n+/// Return placeholder code for the given function.\n+fn fn_sig_suggestion(sig: &ty::FnSig<'_>, ident: Ident) -> String {\n+    let args = sig.inputs()\n+        .iter()\n+        .map(|ty| Some(match ty.kind {\n+            ty::Param(param) if param.name == kw::SelfUpper => \"self\".to_string(),\n+            ty::Ref(reg, ref_ty, mutability) => {\n+                let reg = match &format!(\"{}\", reg)[..] {\n+                    \"'_\" | \"\" => String::new(),\n+                    reg => format!(\"{} \", reg),\n+                };\n+                match ref_ty.kind {\n+                    ty::Param(param) if param.name == kw::SelfUpper => {\n+                        format!(\"&{}{}self\", reg, mutability.prefix_str())\n+                    }\n+                    _ => format!(\"_: {:?}\", ty),\n+                }\n+            }\n+            _ => format!(\"_: {:?}\", ty),\n+        }))\n+        .chain(std::iter::once(if sig.c_variadic {\n+            Some(\"...\".to_string())\n+        } else {\n+            None\n+        }))\n+        .filter_map(|arg| arg)\n+        .collect::<Vec<String>>()\n+        .join(\", \");\n+    let output = sig.output();\n+    let output = if !output.is_unit() {\n+        format!(\" -> {:?}\", output)\n+    } else {\n+        String::new()\n+    };\n+\n+    let unsafety = sig.unsafety.prefix_str();\n+    // FIXME: this is not entirely correct, as the lifetimes from borrowed params will\n+    // not be present in the `fn` definition, not will we account for renamed\n+    // lifetimes between the `impl` and the `trait`, but this should be good enough to\n+    // fill in a significant portion of the missing code, and other subsequent\n+    // suggestions can help the user fix the code.\n+    format!(\"{}fn {}({}){} {{ unimplemented!() }}\", unsafety, ident, args, output)\n+}\n+\n+/// Return placeholder code for the given associated item.\n+/// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n+/// structured suggestion.\n+fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n+    match assoc.kind {\n+        ty::AssocKind::Method => {\n+            // We skip the binder here because the binder would deanonymize all\n+            // late-bound regions, and we don't want method signatures to show up\n+            // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+            // regions just fine, showing `fn(&MyType)`.\n+            fn_sig_suggestion(tcx.fn_sig(assoc.def_id).skip_binder(), assoc.ident)\n+        }\n+        ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),\n+        // FIXME(type_alias_impl_trait): we should print bounds here too.\n+        ty::AssocKind::OpaqueTy => format!(\"type {} = Type;\", assoc.ident),\n+        ty::AssocKind::Const => {\n+            let ty = tcx.type_of(assoc.def_id);\n+            let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");\n+            format!(\"const {}: {:?} = {};\", assoc.ident, ty, val)\n+        }\n     }\n }\n \n@@ -3660,8 +3757,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 });\n                 opt_ty.unwrap_or_else(|| self.next_int_var())\n             }\n-            ast::LitKind::Float(_, t) => tcx.mk_mach_float(t),\n-            ast::LitKind::FloatUnsuffixed(_) => {\n+            ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n+            ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n                 let opt_ty = expected.to_option(self).and_then(|ty| {\n                     match ty.kind {\n                         ty::Float(_) => Some(ty),"}, {"sha": "ef84f1cb20f5133a36f86436993794b72b3455ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1146,10 +1146,6 @@ fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n     );\n }\n \n-fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    checked_type_of(tcx, def_id, true).unwrap()\n-}\n-\n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n@@ -1193,26 +1189,14 @@ fn infer_placeholder_type(\n     ty\n }\n \n-/// Same as [`type_of`] but returns [`Option`] instead of failing.\n-///\n-/// If you want to fail anyway, you can set the `fail` parameter to true, but in this case,\n-/// you'd better just call [`type_of`] directly.\n-pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<'_>> {\n+fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     use rustc::hir::*;\n \n-    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n-        Some(hir_id) => hir_id,\n-        None => {\n-            if !fail {\n-                return None;\n-            }\n-            bug!(\"invalid node\");\n-        }\n-    };\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    Some(match tcx.hir().get(hir_id) {\n+    match tcx.hir().get(hir_id) {\n         Node::TraitItem(item) => match item.kind {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1229,9 +1213,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             },\n             TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n-                if !fail {\n-                    return None;\n-                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1325,9 +1306,6 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1365,7 +1343,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ..\n         }) => {\n             if gen.is_some() {\n-                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n+                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n             }\n \n             let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1440,13 +1418,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                     .map(|(index, _)| index)\n                                     .next()\n                             })\n-                            .or_else(|| {\n-                                if !fail {\n-                                    None\n-                                } else {\n-                                    bug!(\"no arg matching AnonConst in path\")\n-                                }\n-                            })?;\n+                            .unwrap_or_else(|| {\n+                                bug!(\"no arg matching AnonConst in path\");\n+                            });\n \n                         // We've encountered an `AnonConst` in some path, so we need to\n                         // figure out which generic parameter it corresponds to and return\n@@ -1456,8 +1430,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                 tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n                             Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return Some(tcx.types.err),\n-                            _ if !fail => return None,\n+                            Res::Err => return tcx.types.err,\n                             res => {\n                                 tcx.sess.delay_span_bug(\n                                     DUMMY_SP,\n@@ -1466,7 +1439,7 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                                         res,\n                                     ),\n                                 );\n-                                return Some(tcx.types.err);\n+                                return tcx.types.err;\n                             }\n                         };\n \n@@ -1484,24 +1457,18 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                             // probably from an extra arg where one is not needed.\n                             .unwrap_or(tcx.types.err)\n                     } else {\n-                        if !fail {\n-                            return None;\n-                        }\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n                             &format!(\n                                 \"unexpected const parent path {:?}\",\n                                 parent_node,\n                             ),\n                         );\n-                        return Some(tcx.types.err);\n+                        return tcx.types.err;\n                     }\n                 }\n \n                 x => {\n-                    if !fail {\n-                        return None;\n-                    }\n                     tcx.sess.delay_span_bug(\n                         DUMMY_SP,\n                         &format!(\n@@ -1551,21 +1518,13 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                 }\n                 ty\n             }\n-            x => {\n-                if !fail {\n-                    return None;\n-                }\n-                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n-            },\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n \n         x => {\n-            if !fail {\n-                return None;\n-            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    })\n+    }\n }\n \n fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n@@ -2075,10 +2034,7 @@ fn explicit_predicates_of(\n         }\n     }\n \n-    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n-        Some(hir_id) => hir_id,\n-        None => return tcx.predicates_of(def_id),\n-    };\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;"}, {"sha": "a5a4cfa2babc03e5a82167792a7fad07b22c310c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -109,8 +109,6 @@ use util::common::time;\n use std::iter;\n \n use astconv::{AstConv, Bounds};\n-pub use collect::checked_type_of;\n-\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "0c670e5e7179a132328347c9420b2366fb1a1a21", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1492,12 +1492,13 @@ impl GenericParamDefKind {\n         }\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        match *self {\n-            GenericParamDefKind::Type { did, .. } => {\n-                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n-            }\n-            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+    // FIXME(eddyb) this either returns the default of a type parameter, or the\n+    // type of a `const` parameter. It seems that the intention is to *visit*\n+    // any embedded types, but `get_type` seems to be the wrong name for that.\n+    pub fn get_type(&self) -> Option<Type> {\n+        match self {\n+            GenericParamDefKind::Type { default, .. } => default.clone(),\n+            GenericParamDefKind::Const { ty, .. } => Some(ty.clone()),\n             GenericParamDefKind::Lifetime => None,\n         }\n     }\n@@ -1523,8 +1524,8 @@ impl GenericParamDef {\n         self.kind.is_type()\n     }\n \n-    pub fn get_type(&self, cx: &DocContext<'_>) -> Option<Type> {\n-        self.kind.get_type(cx)\n+    pub fn get_type(&self) -> Option<Type> {\n+        self.kind.get_type()\n     }\n \n     pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n@@ -1892,7 +1893,7 @@ fn get_real_types(\n                             if !x.is_type() {\n                                 continue\n                             }\n-                            if let Some(ty) = x.get_type(cx) {\n+                            if let Some(ty) = x.get_type() {\n                                 let adds = get_real_types(generics, &ty, cx, recurse + 1);\n                                 if !adds.is_empty() {\n                                     res.extend(adds);"}, {"sha": "3e17e7949ea990b0ab461de0ca64cf2978ebd460", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -20,5 +20,4 @@ errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n-rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "67d1acbccfbe5beca1ca9dadde9cdf375899e67e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 73, "deletions": 42, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -22,7 +22,6 @@ pub use GenericArgs::*;\n pub use UnsafeSource::*;\n pub use crate::util::parser::ExprPrecedence;\n \n-pub use rustc_target::abi::FloatTy;\n pub use syntax_pos::symbol::{Ident, Symbol as Name};\n \n use crate::parse::token::{self, DelimToken};\n@@ -38,7 +37,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_index::vec::Idx;\n use rustc_serialize::{self, Decoder, Encoder};\n-use rustc_target::spec::abi::Abi;\n \n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n@@ -1401,7 +1399,7 @@ pub struct Lit {\n \n // Clippy uses Hash and PartialEq\n /// Type of the integer literal based on provided suffix.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n pub enum LitIntType {\n     /// e.g. `42_i32`.\n     Signed(IntTy),\n@@ -1411,6 +1409,15 @@ pub enum LitIntType {\n     Unsuffixed,\n }\n \n+/// Type of the float literal based on provided suffix.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, PartialEq)]\n+pub enum LitFloatType {\n+    /// A float literal with a suffix (`1f32` or `1E10f32`).\n+    Suffixed(FloatTy),\n+    /// A float literal without a suffix (`1.0 or 1.0E10`).\n+    Unsuffixed,\n+}\n+\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n@@ -1428,9 +1435,7 @@ pub enum LitKind {\n     /// An integer literal (`1`).\n     Int(u128, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`).\n-    Float(Symbol, FloatTy),\n-    /// A float literal without a suffix (`1.0 or 1.0E10`).\n-    FloatUnsuffixed(Symbol),\n+    Float(Symbol, LitFloatType),\n     /// A boolean literal.\n     Bool(bool),\n     /// Placeholder for a literal that wasn't well-formed in some way.\n@@ -1457,7 +1462,7 @@ impl LitKind {\n     /// Returns `true` if this is a numeric literal.\n     pub fn is_numeric(&self) -> bool {\n         match *self {\n-            LitKind::Int(..) | LitKind::Float(..) | LitKind::FloatUnsuffixed(..) => true,\n+            LitKind::Int(..) | LitKind::Float(..) => true,\n             _ => false,\n         }\n     }\n@@ -1474,14 +1479,14 @@ impl LitKind {\n             // suffixed variants\n             LitKind::Int(_, LitIntType::Signed(..))\n             | LitKind::Int(_, LitIntType::Unsigned(..))\n-            | LitKind::Float(..) => true,\n+            | LitKind::Float(_, LitFloatType::Suffixed(..)) => true,\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n-            | LitKind::FloatUnsuffixed(..)\n+            | LitKind::Float(_, LitFloatType::Unsuffixed)\n             | LitKind::Bool(..)\n             | LitKind::Err(..) => false,\n         }\n@@ -1553,7 +1558,36 @@ pub enum ImplItemKind {\n     Macro(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl FloatTy {\n+    pub fn name_str(self) -> &'static str {\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+\n+    pub fn name(self) -> Symbol {\n+        match self {\n+            FloatTy::F32 => sym::f32,\n+            FloatTy::F64 => sym::f64,\n+        }\n+    }\n+\n+    pub fn bit_width(self) -> usize {\n+        match self {\n+            FloatTy::F32 => 32,\n+            FloatTy::F64 => 64,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -1563,20 +1597,8 @@ pub enum IntTy {\n     I128,\n }\n \n-impl fmt::Debug for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for IntTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n impl IntTy {\n-    pub fn ty_to_string(&self) -> &'static str {\n+    pub fn name_str(&self) -> &'static str {\n         match *self {\n             IntTy::Isize => \"isize\",\n             IntTy::I8 => \"i8\",\n@@ -1587,7 +1609,7 @@ impl IntTy {\n         }\n     }\n \n-    pub fn to_symbol(&self) -> Symbol {\n+    pub fn name(&self) -> Symbol {\n         match *self {\n             IntTy::Isize => sym::isize,\n             IntTy::I8 => sym::i8,\n@@ -1602,7 +1624,7 @@ impl IntTy {\n         // Cast to a `u128` so we can correctly print `INT128_MIN`. All integral types\n         // are parsed as `u128`, so we wouldn't want to print an extra negative\n         // sign.\n-        format!(\"{}{}\", val as u128, self.ty_to_string())\n+        format!(\"{}{}\", val as u128, self.name_str())\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n@@ -1617,7 +1639,7 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy, Debug)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -1628,7 +1650,7 @@ pub enum UintTy {\n }\n \n impl UintTy {\n-    pub fn ty_to_string(&self) -> &'static str {\n+    pub fn name_str(&self) -> &'static str {\n         match *self {\n             UintTy::Usize => \"usize\",\n             UintTy::U8 => \"u8\",\n@@ -1639,7 +1661,7 @@ impl UintTy {\n         }\n     }\n \n-    pub fn to_symbol(&self) -> Symbol {\n+    pub fn name(&self) -> Symbol {\n         match *self {\n             UintTy::Usize => sym::usize,\n             UintTy::U8 => sym::u8,\n@@ -1651,7 +1673,7 @@ impl UintTy {\n     }\n \n     pub fn val_to_string(&self, val: u128) -> String {\n-        format!(\"{}{}\", val, self.ty_to_string())\n+        format!(\"{}{}\", val, self.name_str())\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n@@ -1666,18 +1688,6 @@ impl UintTy {\n     }\n }\n \n-impl fmt::Debug for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::Display for UintTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.ty_to_string())\n-    }\n-}\n-\n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -2358,6 +2368,27 @@ impl Item {\n     }\n }\n \n+/// A reference to an ABI.\n+///\n+/// In AST our notion of an ABI is still syntactic unlike in `rustc_target::spec::abi::Abi`.\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n+pub struct Abi {\n+    pub symbol: Symbol,\n+    pub span: Span,\n+}\n+\n+impl Abi {\n+    pub fn new(symbol: Symbol, span: Span) -> Self {\n+        Self { symbol, span }\n+    }\n+}\n+\n+impl Default for Abi {\n+    fn default() -> Self {\n+        Self::new(sym::Rust, DUMMY_SP)\n+    }\n+}\n+\n /// A function header.\n ///\n /// All the information between the visibility and the name of the function is\n@@ -2376,7 +2407,7 @@ impl Default for FnHeader {\n             unsafety: Unsafety::Normal,\n             asyncness: dummy_spanned(IsAsync::NotAsync),\n             constness: dummy_spanned(Constness::NotConst),\n-            abi: Abi::Rust,\n+            abi: Abi::default(),\n         }\n     }\n }"}, {"sha": "c23c8d65a7f23c6e36a0617f4e1ab5fa0519eda6", "filename": "src/libsyntax/error_codes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferror_codes.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -540,6 +540,5 @@ equivalent in Rust would be to use macros directly.\n     E0630,\n     E0693, // incorrect `repr(align)` attribute format\n //  E0694, // an unknown tool name found in scoped attributes\n-    E0703, // invalid ABI\n     E0717, // rustc_promotable without stability attribute\n }"}, {"sha": "5b1493ebc9b01dd2b0f6aa06a2aa12a54177f80a", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -18,7 +18,6 @@ use crate::tokenstream::TokenTree;\n \n use errors::{Applicability, DiagnosticBuilder, Handler};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_target::spec::abi::Abi;\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::debug;\n \n@@ -192,62 +191,70 @@ macro_rules! gate_feature_post {\n }\n \n impl<'a> PostExpansionVisitor<'a> {\n-    fn check_abi(&self, abi: Abi, span: Span) {\n-        match abi {\n-            Abi::RustIntrinsic => {\n+    fn check_abi(&self, abi: ast::Abi) {\n+        let ast::Abi { symbol, span } = abi;\n+\n+        match &*symbol.as_str() {\n+            // Stable\n+            \"Rust\" |\n+            \"C\" |\n+            \"cdecl\" |\n+            \"stdcall\" |\n+            \"fastcall\" |\n+            \"aapcs\" |\n+            \"win64\" |\n+            \"sysv64\" |\n+            \"system\" => {}\n+            \"rust-intrinsic\" => {\n                 gate_feature_post!(&self, intrinsics, span,\n                                    \"intrinsics are subject to change\");\n             },\n-            Abi::PlatformIntrinsic => {\n+            \"platform-intrinsic\" => {\n                 gate_feature_post!(&self, platform_intrinsics, span,\n                                    \"platform intrinsics are experimental and possibly buggy\");\n             },\n-            Abi::Vectorcall => {\n+            \"vectorcall\" => {\n                 gate_feature_post!(&self, abi_vectorcall, span,\n                                    \"vectorcall is experimental and subject to change\");\n             },\n-            Abi::Thiscall => {\n+            \"thiscall\" => {\n                 gate_feature_post!(&self, abi_thiscall, span,\n                                    \"thiscall is experimental and subject to change\");\n             },\n-            Abi::RustCall => {\n+            \"rust-call\" => {\n                 gate_feature_post!(&self, unboxed_closures, span,\n                                    \"rust-call ABI is subject to change\");\n             },\n-            Abi::PtxKernel => {\n+            \"ptx-kernel\" => {\n                 gate_feature_post!(&self, abi_ptx, span,\n                                    \"PTX ABIs are experimental and subject to change\");\n             },\n-            Abi::Unadjusted => {\n+            \"unadjusted\" => {\n                 gate_feature_post!(&self, abi_unadjusted, span,\n                                    \"unadjusted ABI is an implementation detail and perma-unstable\");\n             },\n-            Abi::Msp430Interrupt => {\n+            \"msp430-interrupt\" => {\n                 gate_feature_post!(&self, abi_msp430_interrupt, span,\n                                    \"msp430-interrupt ABI is experimental and subject to change\");\n             },\n-            Abi::X86Interrupt => {\n+            \"x86-interrupt\" => {\n                 gate_feature_post!(&self, abi_x86_interrupt, span,\n                                    \"x86-interrupt ABI is experimental and subject to change\");\n             },\n-            Abi::AmdGpuKernel => {\n+            \"amdgpu-kernel\" => {\n                 gate_feature_post!(&self, abi_amdgpu_kernel, span,\n                                    \"amdgpu-kernel ABI is experimental and subject to change\");\n             },\n-            Abi::EfiApi => {\n+            \"efiapi\" => {\n                 gate_feature_post!(&self, abi_efiapi, span,\n                                    \"efiapi ABI is experimental and subject to change\");\n             },\n-            // Stable\n-            Abi::Cdecl |\n-            Abi::Stdcall |\n-            Abi::Fastcall |\n-            Abi::Aapcs |\n-            Abi::Win64 |\n-            Abi::SysV64 |\n-            Abi::Rust |\n-            Abi::C |\n-            Abi::System => {}\n+            abi => {\n+                self.parse_sess.span_diagnostic.delay_span_bug(\n+                    span,\n+                    &format!(\"unrecognized ABI not caught in lowering: {}\", abi),\n+                )\n+            }\n         }\n     }\n \n@@ -373,7 +380,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.kind {\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n-                self.check_abi(foreign_module.abi, i.span);\n+                self.check_abi(foreign_module.abi);\n             }\n \n             ast::ItemKind::Fn(..) => {\n@@ -503,7 +510,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_ty(&mut self, ty: &'a ast::Ty) {\n         match ty.kind {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n-                self.check_abi(bare_fn_ty.abi, ty.span);\n+                self.check_abi(bare_fn_ty.abi);\n             }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span,\n@@ -597,7 +604,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             // Stability of const fn methods are covered in\n             // `visit_trait_item` and `visit_impl_item` below; this is\n             // because default methods don't pass through this point.\n-            self.check_abi(header.abi, span);\n+            self.check_abi(header.abi);\n         }\n \n         if fn_decl.c_variadic() {\n@@ -631,7 +638,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match ti.kind {\n             ast::TraitItemKind::Method(ref sig, ref block) => {\n                 if block.is_none() {\n-                    self.check_abi(sig.header.abi, ti.span);\n+                    self.check_abi(sig.header.abi);\n                 }\n                 if sig.decl.c_variadic() {\n                     gate_feature_post!(&self, c_variadic, ti.span,\n@@ -863,18 +870,17 @@ pub fn check_crate(krate: &ast::Crate,\n     maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n     let mut visitor = PostExpansionVisitor { parse_sess, features };\n \n+    let spans = parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n-        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n-        ($spans:ident, $gate:ident, $msg:literal) => {\n-            for span in &*parse_sess.gated_spans.$spans.borrow() {\n+        ($gate:ident, $msg:literal) => {\n+            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n                 gate_feature!(&visitor, $gate, *span, $msg);\n             }\n         }\n     }\n-\n     gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure, \"async closures are unstable\");\n-    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n \n@@ -885,7 +891,7 @@ pub fn check_crate(krate: &ast::Crate,\n             // FIXME(eddyb) do something more useful than always\n             // disabling these uses of early feature-gatings.\n             if false {\n-                for span in &*parse_sess.gated_spans.$gate.borrow() {\n+                for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n                     gate_feature!(&visitor, $gate, *span, $msg);\n                 }\n             }\n@@ -902,7 +908,6 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n     gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n-\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n     if parse_sess.span_diagnostic.err_count() == 0 {"}, {"sha": "a8eeac59954f14efcf6a3880e481561ab325605c", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -157,17 +157,18 @@ impl LitKind {\n             }\n             LitKind::Int(n, ty) => {\n                 let suffix = match ty {\n-                    ast::LitIntType::Unsigned(ty) => Some(ty.to_symbol()),\n-                    ast::LitIntType::Signed(ty) => Some(ty.to_symbol()),\n+                    ast::LitIntType::Unsigned(ty) => Some(ty.name()),\n+                    ast::LitIntType::Signed(ty) => Some(ty.name()),\n                     ast::LitIntType::Unsuffixed => None,\n                 };\n                 (token::Integer, sym::integer(n), suffix)\n             }\n             LitKind::Float(symbol, ty) => {\n-                (token::Float, symbol, Some(ty.to_symbol()))\n-            }\n-            LitKind::FloatUnsuffixed(symbol) => {\n-                (token::Float, symbol, None)\n+                let suffix = match ty {\n+                    ast::LitFloatType::Suffixed(ty) => Some(ty.name()),\n+                    ast::LitFloatType::Unsuffixed => None,\n+                };\n+                (token::Float, symbol, suffix)\n             }\n             LitKind::Bool(value) => {\n                 let symbol = if value { kw::True } else { kw::False };\n@@ -244,12 +245,12 @@ fn filtered_float_lit(symbol: Symbol, suffix: Option<Symbol>, base: u32)\n         return Err(LitError::NonDecimalFloat(base));\n     }\n     Ok(match suffix {\n-        Some(suf) => match suf {\n-            sym::f32 => LitKind::Float(symbol, ast::FloatTy::F32),\n-            sym::f64 => LitKind::Float(symbol, ast::FloatTy::F64),\n+        Some(suf) => LitKind::Float(symbol, ast::LitFloatType::Suffixed(match suf {\n+            sym::f32 => ast::FloatTy::F32,\n+            sym::f64 => ast::FloatTy::F64,\n             _ => return Err(LitError::InvalidFloatSuffix),\n-        }\n-        None => LitKind::FloatUnsuffixed(symbol)\n+        })),\n+        None => LitKind::Float(symbol, ast::LitFloatType::Unsuffixed)\n     })\n }\n "}, {"sha": "1284e89f195c753a127b38ea53a8e519ca6e6ff6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -12,7 +12,7 @@ mod diagnostics;\n use diagnostics::Error;\n \n use crate::ast::{\n-    self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n+    self, Abi, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Ident,\n     IsAsync, MacDelimiter, Mutability, StrStyle, Visibility, VisibilityKind, Unsafety,\n };\n use crate::parse::{PResult, Directory, DirectoryOwnership};\n@@ -28,7 +28,6 @@ use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::ThinVec;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n-use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{Span, BytePos, DUMMY_SP, FileName};\n use log::debug;\n \n@@ -1121,7 +1120,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.crate_visibility_modifier.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n \n@@ -1206,48 +1205,41 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    /// Parses `extern` followed by an optional ABI string, or nothing.\n+    /// Parses `extern string_literal?`.\n+    /// If `extern` is not found, the Rust ABI is used.\n+    /// If `extern` is found and a `string_literal` does not follow, the C ABI is used.\n     fn parse_extern_abi(&mut self) -> PResult<'a, Abi> {\n-        if self.eat_keyword(kw::Extern) {\n-            Ok(self.parse_opt_abi()?.unwrap_or(Abi::C))\n+        Ok(if self.eat_keyword(kw::Extern) {\n+            self.parse_opt_abi()?\n         } else {\n-            Ok(Abi::Rust)\n-        }\n+            Abi::default()\n+        })\n     }\n \n-    /// Parses a string as an ABI spec on an extern type or module. Consumes\n-    /// the `extern` keyword, if one is found.\n-    fn parse_opt_abi(&mut self) -> PResult<'a, Option<Abi>> {\n-        match self.token.kind {\n-            token::Literal(token::Lit { kind: token::Str, symbol, suffix }) |\n-            token::Literal(token::Lit { kind: token::StrRaw(..), symbol, suffix }) => {\n-                self.expect_no_suffix(self.token.span, \"an ABI spec\", suffix);\n-                self.bump();\n-                match abi::lookup(&symbol.as_str()) {\n-                    Some(abi) => Ok(Some(abi)),\n-                    None => {\n-                        self.error_on_invalid_abi(symbol);\n-                        Ok(None)\n-                    }\n+    /// Parses a string literal as an ABI spec.\n+    /// If one is not found, the \"C\" ABI is used.\n+    fn parse_opt_abi(&mut self) -> PResult<'a, Abi> {\n+        let span = if self.token.can_begin_literal_or_bool() {\n+            let ast::Lit { span, kind, .. } = self.parse_lit()?;\n+            match kind {\n+                ast::LitKind::Str(symbol, _) => return Ok(Abi::new(symbol, span)),\n+                ast::LitKind::Err(_) => {}\n+                _ => {\n+                    self.struct_span_err(span, \"non-string ABI literal\")\n+                        .span_suggestion(\n+                            span,\n+                            \"specify the ABI with a string literal\",\n+                            \"\\\"C\\\"\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                 }\n             }\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    /// Emit an error where `symbol` is an invalid ABI.\n-    fn error_on_invalid_abi(&self, symbol: Symbol) {\n-        let prev_span = self.prev_span;\n-        struct_span_err!(\n-            self.sess.span_diagnostic,\n-            prev_span,\n-            E0703,\n-            \"invalid ABI: found `{}`\",\n-            symbol\n-        )\n-        .span_label(prev_span, \"invalid ABI\")\n-        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n-        .emit();\n+            span\n+        } else {\n+            self.prev_span\n+        };\n+        Ok(Abi::new(sym::C, span))\n     }\n \n     /// We are parsing `async fn`. If we are on Rust 2015, emit an error."}, {"sha": "509e6482dcc06d48d3610528d41547185c29280e", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -16,10 +16,10 @@ use crate::parse::token::{self, Token, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{self, Span};\n-use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n use errors::Applicability;\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::Symbol;\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -252,7 +252,7 @@ impl<'a> Parser<'a> {\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.type_ascription.borrow_mut().push(lhs.span);\n+                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n@@ -455,7 +455,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span = lo.to(span);\n-                self.sess.gated_spans.box_syntax.borrow_mut().push(span);\n+                self.sess.gated_spans.gate(sym::box_syntax, span);\n                 (span, ExprKind::Box(e))\n             }\n             token::Ident(..) if self.token.is_ident_named(sym::not) => {\n@@ -1045,7 +1045,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let span = lo.to(hi);\n-                    self.sess.gated_spans.yields.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::generators, span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1116,7 +1116,11 @@ impl<'a> Parser<'a> {\n                 Err(self.span_fatal(token.span, &msg))\n             }\n             Err(err) => {\n-                let (lit, span) = (token.expect_lit(), token.span);\n+                let span = token.span;\n+                let lit = match token.kind {\n+                    token::Literal(lit) => lit,\n+                    _ => unreachable!(),\n+                };\n                 self.bump();\n                 self.error_literal_from_token(err, lit, span);\n                 // Pack possible quotes and prefixes from the original literal into\n@@ -1264,7 +1268,7 @@ impl<'a> Parser<'a> {\n         outer_attrs: ThinVec<Attribute>,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n-            self.sess.gated_spans.label_break_value.borrow_mut().push(label.ident.span);\n+            self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -1293,7 +1297,7 @@ impl<'a> Parser<'a> {\n         };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.async_closure.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1415,8 +1419,7 @@ impl<'a> Parser<'a> {\n \n         if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n-            debug_assert_eq!(cond.span, last.unwrap());\n+            self.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n         }\n \n         Ok(cond)\n@@ -1433,7 +1436,7 @@ impl<'a> Parser<'a> {\n             |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n-        self.sess.gated_spans.let_chains.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr), attrs))\n     }\n \n@@ -1654,7 +1657,7 @@ impl<'a> Parser<'a> {\n             Err(error)\n         } else {\n             let span = span_lo.to(body.span);\n-            self.sess.gated_spans.try_blocks.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::try_blocks, span);\n             Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n         }\n     }"}, {"sha": "3c094750b4d98ee9901bb3d8638cb20543d88136", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -3,7 +3,8 @@ use super::{Parser, PResult};\n use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n use crate::parse::token;\n use crate::source_map::DUMMY_SP;\n-use crate::symbol::kw;\n+\n+use syntax_pos::symbol::{kw, sym};\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -62,7 +63,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.const_generics.borrow_mut().push(lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n \n         Ok(GenericParam {\n             ident,"}, {"sha": "9d543055f23a7788335b1be7aef4f8d410d380ff", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -3,7 +3,7 @@ use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n use crate::ptr::P;\n-use crate::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n+use crate::ast::{self, Abi, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n use crate::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n use crate::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness};\n use crate::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n@@ -17,7 +17,6 @@ use crate::ThinVec;\n \n use log::debug;\n use std::mem;\n-use rustc_target::spec::abi::Abi;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n use syntax_pos::BytePos;\n \n@@ -111,7 +110,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(self.parse_item_extern_crate(lo, vis, attrs)?));\n             }\n \n-            let opt_abi = self.parse_opt_abi()?;\n+            let abi = self.parse_opt_abi()?;\n \n             if self.eat_keyword(kw::Fn) {\n                 // EXTERN FUNCTION ITEM\n@@ -120,12 +119,12 @@ impl<'a> Parser<'a> {\n                     unsafety: Unsafety::Normal,\n                     asyncness: respan(fn_span, IsAsync::NotAsync),\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi: opt_abi.unwrap_or(Abi::C),\n+                    abi,\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             } else if self.check(&token::OpenDelim(token::Brace)) {\n                 return Ok(Some(\n-                    self.parse_item_foreign_mod(lo, opt_abi, vis, attrs, extern_sp)?,\n+                    self.parse_item_foreign_mod(lo, abi, vis, attrs, extern_sp)?,\n                 ));\n             }\n \n@@ -147,9 +146,7 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n-                    self.sess.gated_spans.const_extern_fn.borrow_mut().push(\n-                        lo.to(self.token.span)\n-                    );\n+                    self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n                 let abi = self.parse_extern_abi()?;\n                 self.bump(); // `fn`\n@@ -201,7 +198,7 @@ impl<'a> Parser<'a> {\n                     unsafety,\n                     asyncness,\n                     constness: respan(fn_span, Constness::NotConst),\n-                    abi: Abi::Rust,\n+                    abi: Abi::new(sym::Rust, fn_span),\n                 };\n                 return self.parse_item_fn(lo, vis, attrs, header);\n             }\n@@ -238,7 +235,7 @@ impl<'a> Parser<'a> {\n                 unsafety: Unsafety::Normal,\n                 asyncness: respan(fn_span, IsAsync::NotAsync),\n                 constness: respan(fn_span, Constness::NotConst),\n-                abi: Abi::Rust,\n+                abi: Abi::new(sym::Rust, fn_span),\n             };\n             return self.parse_item_fn(lo, vis, attrs, header);\n         }\n@@ -832,7 +829,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n \n-            self.sess.gated_spans.trait_alias.borrow_mut().push(whole_span);\n+            self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n             Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n         } else {\n@@ -1115,15 +1112,13 @@ impl<'a> Parser<'a> {\n     fn parse_item_foreign_mod(\n         &mut self,\n         lo: Span,\n-        opt_abi: Option<Abi>,\n+        abi: Abi,\n         visibility: Visibility,\n         mut attrs: Vec<Attribute>,\n         extern_sp: Span,\n     ) -> PResult<'a, P<Item>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n-        let abi = opt_abi.unwrap_or(Abi::C);\n-\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let mut foreign_items = vec![];\n@@ -1714,7 +1709,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_span);\n \n         if !def.legacy {\n-            self.sess.gated_spans.decl_macro.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::decl_macro, span);\n         }\n \n         Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))\n@@ -1801,7 +1796,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, Option<P<Item>>> {\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: false,\n-            allow_c_variadic: header.abi == Abi::C && header.unsafety == Unsafety::Unsafe,\n+            allow_c_variadic: header.abi.symbol == sym::C && header.unsafety == Unsafety::Unsafe,\n             is_name_required: |_| true,\n         })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1930,7 +1925,7 @@ impl<'a> Parser<'a> {\n         let asyncness = respan(self.prev_span, asyncness);\n         let unsafety = self.parse_unsafety();\n         let (constness, unsafety, abi) = if is_const_fn {\n-            (respan(const_span, Constness::Const), unsafety, Abi::Rust)\n+            (respan(const_span, Constness::Const), unsafety, Abi::default())\n         } else {\n             let abi = self.parse_extern_abi()?;\n             (respan(self.prev_span, Constness::NotConst), unsafety, abi)"}, {"sha": "cc8738edff7f50f088a53ab2432364ae18e1b251", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -8,9 +8,8 @@ use crate::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n-use crate::symbol::kw;\n use crate::ThinVec;\n-\n+use syntax_pos::symbol::{kw, sym};\n use errors::{Applicability, DiagnosticBuilder};\n \n type Expected = Option<&'static str>;\n@@ -52,11 +51,8 @@ impl<'a> Parser<'a> {\n         // and no other gated or-pattern has been parsed thus far,\n         // then we should really gate the leading `|`.\n         // This complicated procedure is done purely for diagnostics UX.\n-        if gated_leading_vert {\n-            let mut or_pattern_spans = self.sess.gated_spans.or_patterns.borrow_mut();\n-            if or_pattern_spans.is_empty() {\n-                or_pattern_spans.push(leading_vert_span);\n-            }\n+        if gated_leading_vert && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n+            self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n         }\n \n         Ok(pat)\n@@ -117,7 +113,7 @@ impl<'a> Parser<'a> {\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n-            self.sess.gated_spans.or_patterns.borrow_mut().push(or_pattern_span);\n+            self.sess.gated_spans.gate(sym::or_patterns, or_pattern_span);\n         }\n \n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n@@ -325,7 +321,7 @@ impl<'a> Parser<'a> {\n             } else if self.eat_keyword(kw::Box) {\n                 // Parse `box pat`\n                 let pat = self.parse_pat_with_range_pat(false, None)?;\n-                self.sess.gated_spans.box_patterns.borrow_mut().push(lo.to(self.prev_span));\n+                self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n                 PatKind::Box(pat)\n             } else if self.can_be_ident_pat() {\n                 // Parse `ident @ pat`\n@@ -612,7 +608,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn excluded_range_end(&self, span: Span) -> RangeEnd {\n-        self.sess.gated_spans.exclusive_range_pattern.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::exclusive_range_pattern, span);\n         RangeEnd::Excluded\n     }\n "}, {"sha": "4438d61d9eedde05f130fb7170f513e59cf5c09f", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -5,7 +5,7 @@ use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, Angle\n use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n use crate::parse::token::{self, Token};\n use crate::source_map::{Span, BytePos};\n-use crate::symbol::kw;\n+use syntax_pos::symbol::{kw, sym};\n \n use std::mem;\n use log::debug;\n@@ -426,7 +426,7 @@ impl<'a> Parser<'a> {\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n-                    self.sess.gated_spans.associated_type_bounds.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                 }\n \n                 constraints.push(AssocTyConstraint {"}, {"sha": "6f3da344ccf88e6cc7a5857d809dcef8a3fcda56", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -381,9 +381,7 @@ impl Token {\n         match self.kind {\n             OpenDelim(Brace) => true,\n             Interpolated(ref nt) => match **nt {\n-                NtExpr(..) => true,\n-                NtBlock(..) => true,\n-                NtLiteral(..) => true,\n+                NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             }\n             _ => self.can_begin_literal_or_bool(),\n@@ -404,13 +402,6 @@ impl Token {\n         }\n     }\n \n-    crate fn expect_lit(&self) -> Lit {\n-        match self.kind {\n-            Literal(lit) => lit,\n-            _ => panic!(\"`expect_lit` called on non-literal\"),\n-        }\n-    }\n-\n     /// Returns `true` if the token is any literal, a minus (which can prefix a literal,\n     /// for example a '-42', or one of the boolean idents).\n     pub fn can_begin_literal_or_bool(&self) -> bool {"}, {"sha": "1d59c13a9d0818800aaaea91c1b36504ddcab8c5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -14,7 +14,6 @@ use crate::sess::ParseSess;\n use crate::symbol::{kw, sym};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n \n-use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{self, BytePos};\n use syntax_pos::{FileName, Span};\n \n@@ -1230,7 +1229,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\");\n-                self.word_nbsp(nmod.abi.to_string());\n+                self.print_abi(nmod.abi);\n                 self.bopen();\n                 self.print_foreign_mod(nmod, &item.attrs);\n                 self.bclose(item.span);\n@@ -2823,7 +2822,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_ty_fn(&mut self,\n-                       abi: abi::Abi,\n+                       abi: ast::Abi,\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n@@ -2884,14 +2883,18 @@ impl<'a> State<'a> {\n         self.print_asyncness(header.asyncness.node);\n         self.print_unsafety(header.unsafety);\n \n-        if header.abi != Abi::Rust {\n+        if header.abi.symbol != sym::Rust {\n             self.word_nbsp(\"extern\");\n-            self.word_nbsp(header.abi.to_string());\n+            self.print_abi(header.abi);\n         }\n \n         self.s.word(\"fn\")\n     }\n \n+    fn print_abi(&mut self, abi: ast::Abi) {\n+        self.word_nbsp(format!(\"\\\"{}\\\"\", abi.symbol));\n+    }\n+\n     crate fn print_unsafety(&mut self, s: ast::Unsafety) {\n         match s {\n             ast::Unsafety::Normal => {},"}, {"sha": "2c6dd0fb1c6dc05154407509a408784c005c760a", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -34,12 +34,7 @@ fn test_fun_to_string() {\n         assert_eq!(\n             fun_to_string(\n                 &decl,\n-                ast::FnHeader {\n-                    unsafety: ast::Unsafety::Normal,\n-                    constness: source_map::dummy_spanned(ast::Constness::NotConst),\n-                    asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),\n-                    abi: Abi::Rust,\n-                },\n+                ast::FnHeader::default(),\n                 abba_ident,\n                 &generics\n             ),"}, {"sha": "faad3e4af1e46daf93b376e7a7b7549df711bb8d", "filename": "src/libsyntax/sess.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsess.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -19,39 +19,53 @@ use std::str;\n /// Collected spans during parsing for places where a certain feature was\n /// used and should be feature gated accordingly in `check_crate`.\n #[derive(Default)]\n-crate struct GatedSpans {\n-    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n-    crate let_chains: Lock<Vec<Span>>,\n-    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n-    crate async_closure: Lock<Vec<Span>>,\n-    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n-    crate yields: Lock<Vec<Span>>,\n-    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n-    crate or_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n-    crate const_extern_fn: Lock<Vec<Span>>,\n-    /// Spans collected for gating `trait_alias`, e.g. `trait Foo = Ord + Eq;`.\n-    pub trait_alias: Lock<Vec<Span>>,\n-    /// Spans collected for gating `associated_type_bounds`, e.g. `Iterator<Item: Ord>`.\n-    pub associated_type_bounds: Lock<Vec<Span>>,\n-    /// Spans collected for gating `crate_visibility_modifier`, e.g. `crate fn`.\n-    pub crate_visibility_modifier: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_generics`, e.g. `const N: usize`.\n-    pub const_generics: Lock<Vec<Span>>,\n-    /// Spans collected for gating `decl_macro`, e.g. `macro m() {}`.\n-    pub decl_macro: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_patterns`, e.g. `box 0`.\n-    pub box_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `exclusive_range_pattern`, e.g. `0..2`.\n-    pub exclusive_range_pattern: Lock<Vec<Span>>,\n-    /// Spans collected for gating `try_blocks`, e.g. `try { a? + b? }`.\n-    pub try_blocks: Lock<Vec<Span>>,\n-    /// Spans collected for gating `label_break_value`, e.g. `'label: { ... }`.\n-    pub label_break_value: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_syntax`, e.g. `box $expr`.\n-    pub box_syntax: Lock<Vec<Span>>,\n-    /// Spans collected for gating `type_ascription`, e.g. `42: usize`.\n-    pub type_ascription: Lock<Vec<Span>>,\n+pub struct GatedSpans {\n+    pub spans: Lock<FxHashMap<Symbol, Vec<Span>>>,\n+}\n+\n+impl GatedSpans {\n+    /// Feature gate the given `span` under the given `feature`\n+    /// which is same `Symbol` used in `active.rs`.\n+    pub fn gate(&self, feature: Symbol, span: Span) {\n+        self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .push(span);\n+    }\n+\n+    /// Ungate the last span under the given `feature`.\n+    /// Panics if the given `span` wasn't the last one.\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn ungate_last(&self, feature: Symbol, span: Span) {\n+        let removed_span = self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .pop()\n+            .unwrap();\n+        debug_assert_eq!(span, removed_span);\n+    }\n+\n+    /// Is the provided `feature` gate ungated currently?\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn is_ungated(&self, feature: Symbol) -> bool {\n+        self.spans\n+            .borrow()\n+            .get(&feature)\n+            .map_or(true, |spans| spans.is_empty())\n+    }\n+\n+    /// Prepend the given set of `spans` onto the set in `self`.\n+    pub fn merge(&self, mut spans: FxHashMap<Symbol, Vec<Span>>) {\n+        let mut inner = self.spans.borrow_mut();\n+        for (gate, mut gate_spans) in inner.drain() {\n+            spans.entry(gate).or_default().append(&mut gate_spans);\n+        }\n+        *inner = spans;\n+    }\n }\n \n /// Info about a parsing session.\n@@ -72,7 +86,7 @@ pub struct ParseSess {\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n     pub injected_crate_name: Once<Symbol>,\n-    crate gated_spans: GatedSpans,\n+    pub gated_spans: GatedSpans,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n     pub reached_eof: Lock<bool>,\n }"}, {"sha": "02c711bc387e31f95c781a186e0023ebd1207ce7", "filename": "src/libsyntax_expand/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2FCargo.toml?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -21,6 +21,5 @@ errors = { path = \"../librustc_errors\", package = \"rustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n-rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "5571990740317f2dfbc50fd13bc53602d14e7e00", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -29,7 +29,7 @@ use syntax_pos::Span;\n use rustc_data_structures::fx::FxHashMap;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n-use std::slice;\n+use std::{mem, slice};\n \n use errors::Applicability;\n use rustc_data_structures::sync::Lrc;\n@@ -182,16 +182,25 @@ fn generic_extension<'cx>(\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_failure: Option<(Token, &str)> = None;\n-\n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n             _ => cx.span_bug(sp, \"malformed macro lhs\"),\n         };\n \n+        // Take a snapshot of the state of pre-expansion gating at this point.\n+        // This is used so that if a matcher is not `Success(..)`ful,\n+        // then the spans which became gated when parsing the unsucessful matcher\n+        // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n+        let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+\n         match parse_tt(cx, lhs_tt, arg.clone()) {\n             Success(named_matches) => {\n+                // The matcher was `Success(..)`ful.\n+                // Merge the gated spans from parsing the matcher with the pre-existing ones.\n+                cx.parse_sess.gated_spans.merge(gated_spans_snaphot);\n+\n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n                     mbe::TokenTree::Delimited(_, ref delimed) => delimed.tts.clone(),\n@@ -248,6 +257,10 @@ fn generic_extension<'cx>(\n             },\n             Error(err_sp, ref msg) => cx.span_fatal(err_sp.substitute_dummy(sp), &msg[..]),\n         }\n+\n+        // The matcher was not `Success(..)`ful.\n+        // Restore to the state before snapshotting and maybe try again.\n+        mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");"}, {"sha": "4bf13f37711022663d3b6f8a3f7a444f4f2e1521", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -21,8 +21,7 @@ pub fn expand_concat(\n         match e.kind {\n             ast::ExprKind::Lit(ref lit) => match lit.kind {\n                 ast::LitKind::Str(ref s, _)\n-                | ast::LitKind::Float(ref s, _)\n-                | ast::LitKind::FloatUnsuffixed(ref s) => {\n+                | ast::LitKind::Float(ref s, _) => {\n                     accumulator.push_str(&s.as_str());\n                 }\n                 ast::LitKind::Char(c) => {"}, {"sha": "b18fd50ae7605288ba6f959e1e5972bb7a295131", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -182,8 +182,7 @@ use std::iter;\n use std::vec;\n \n use rustc_data_structures::thin_vec::ThinVec;\n-use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n+use syntax::ast::{self, Abi, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n use syntax::source_map::respan;\n@@ -738,7 +737,7 @@ impl<'a> TraitDef<'a> {\n                                          self,\n                                          type_ident,\n                                          generics,\n-                                         Abi::Rust,\n+                                         sym::Rust,\n                                          explicit_self,\n                                          tys,\n                                          body)\n@@ -793,7 +792,7 @@ impl<'a> TraitDef<'a> {\n                                          self,\n                                          type_ident,\n                                          generics,\n-                                         Abi::Rust,\n+                                         sym::Rust,\n                                          explicit_self,\n                                          tys,\n                                          body)\n@@ -919,7 +918,7 @@ impl<'a> MethodDef<'a> {\n                      trait_: &TraitDef<'_>,\n                      type_ident: Ident,\n                      generics: &Generics,\n-                     abi: Abi,\n+                     abi: Symbol,\n                      explicit_self: Option<ast::ExplicitSelf>,\n                      arg_types: Vec<(Ident, P<ast::Ty>)>,\n                      body: P<Expr>)\n@@ -949,23 +948,27 @@ impl<'a> MethodDef<'a> {\n             ast::Unsafety::Normal\n         };\n \n+        let trait_lo_sp = trait_.span.shrink_to_lo();\n+\n+        let sig = ast::MethodSig {\n+            header: ast::FnHeader {\n+                unsafety,\n+                abi: Abi::new(abi, trait_lo_sp),\n+                ..ast::FnHeader::default()\n+            },\n+            decl: fn_decl,\n+        };\n+\n         // Create the method.\n         ast::ImplItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n             span: trait_.span,\n-            vis: respan(trait_.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+            vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n-            kind: ast::ImplItemKind::Method(ast::MethodSig {\n-                                                header: ast::FnHeader {\n-                                                    unsafety, abi,\n-                                                    ..ast::FnHeader::default()\n-                                                },\n-                                                decl: fn_decl,\n-                                            },\n-                                            body_block),\n+            kind: ast::ImplItemKind::Method(sig, body_block),\n             tokens: None,\n         }\n     }"}, {"sha": "d87b17eee3109dfdd2e2bb124dd871d4c42e7578", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -566,6 +566,7 @@ symbols! {\n         rust_2018_preview,\n         rust_begin_unwind,\n         rustc,\n+        Rust,\n         RustcDecodable,\n         RustcEncodable,\n         rustc_allocator,"}, {"sha": "e0e211444cff5a2bfe02f340713dbe5a2afeae08", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -269,7 +269,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n fn test_error_on_exceed() {\n     let types = [TestType::UnitTest, TestType::IntegrationTest, TestType::DocTest];\n \n-    for test_type in types.into_iter() {\n+    for test_type in types.iter() {\n         let result = time_test_failure_template(*test_type);\n \n         assert_eq!(result, TestResult::TrTimedFail);\n@@ -320,7 +320,7 @@ fn test_time_options_threshold() {\n         (TestType::DocTest, doc.critical.as_millis(), true, true),\n     ];\n \n-    for (test_type, time, expected_warn, expected_critical) in test_vector.into_iter() {\n+    for (test_type, time, expected_warn, expected_critical) in test_vector.iter() {\n         let test_desc = typed_test_desc(*test_type);\n         let exec_time = test_exec_time(*time as u64);\n "}, {"sha": "218e0292776d06d6a51368fe4d2d9beac98ad1c8", "filename": "src/test/ui/feature-gated-feature-in-macro-arg.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gated-feature-in-macro-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gated-feature-in-macro-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gated-feature-in-macro-arg.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,10 +1,8 @@\n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gated-feature-in-macro-arg.rs:8:9\n+  --> $DIR/feature-gated-feature-in-macro-arg.rs:8:16\n    |\n-LL | /         extern \"rust-intrinsic\" {\n-LL | |             fn atomic_fence();\n-LL | |         }\n-   | |_________^\n+LL |         extern \"rust-intrinsic\" {\n+   |                ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n "}, {"sha": "d58a2d91b2b7f8cbcc040692294f98ad260d4b20", "filename": "src/test/ui/feature-gates/feature-gate-abi-msp430-interrupt.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi-msp430-interrupt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi-msp430-interrupt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi-msp430-interrupt.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,8 +1,8 @@\n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi-msp430-interrupt.rs:4:1\n+  --> $DIR/feature-gate-abi-msp430-interrupt.rs:4:8\n    |\n LL | extern \"msp430-interrupt\" fn foo() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable"}, {"sha": "6db6cb49cef1436aea579eedb2b2c4fc69572c77", "filename": "src/test/ui/feature-gates/feature-gate-abi.stderr", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,591 +1,591 @@\n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:13:1\n+  --> $DIR/feature-gate-abi.rs:13:8\n    |\n LL | extern \"rust-intrinsic\" fn f1() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:15:1\n+  --> $DIR/feature-gate-abi.rs:15:8\n    |\n LL | extern \"platform-intrinsic\" fn f2() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:17:1\n+  --> $DIR/feature-gate-abi.rs:17:8\n    |\n LL | extern \"vectorcall\" fn f3() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:18:1\n+  --> $DIR/feature-gate-abi.rs:18:8\n    |\n LL | extern \"rust-call\" fn f4() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:19:1\n+  --> $DIR/feature-gate-abi.rs:19:8\n    |\n LL | extern \"msp430-interrupt\" fn f5() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:20:1\n+  --> $DIR/feature-gate-abi.rs:20:8\n    |\n LL | extern \"ptx-kernel\" fn f6() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:21:1\n+  --> $DIR/feature-gate-abi.rs:21:8\n    |\n LL | extern \"x86-interrupt\" fn f7() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:22:1\n+  --> $DIR/feature-gate-abi.rs:22:8\n    |\n LL | extern \"thiscall\" fn f8() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:23:1\n+  --> $DIR/feature-gate-abi.rs:23:8\n    |\n LL | extern \"amdgpu-kernel\" fn f9() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:24:1\n+  --> $DIR/feature-gate-abi.rs:24:8\n    |\n LL | extern \"efiapi\" fn f10() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:28:5\n+  --> $DIR/feature-gate-abi.rs:28:12\n    |\n LL |     extern \"rust-intrinsic\" fn m1();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:30:5\n+  --> $DIR/feature-gate-abi.rs:30:12\n    |\n LL |     extern \"platform-intrinsic\" fn m2();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:32:5\n+  --> $DIR/feature-gate-abi.rs:32:12\n    |\n LL |     extern \"vectorcall\" fn m3();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:33:5\n+  --> $DIR/feature-gate-abi.rs:33:12\n    |\n LL |     extern \"rust-call\" fn m4();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:34:5\n+  --> $DIR/feature-gate-abi.rs:34:12\n    |\n LL |     extern \"msp430-interrupt\" fn m5();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:35:5\n+  --> $DIR/feature-gate-abi.rs:35:12\n    |\n LL |     extern \"ptx-kernel\" fn m6();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:36:5\n+  --> $DIR/feature-gate-abi.rs:36:12\n    |\n LL |     extern \"x86-interrupt\" fn m7();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:37:5\n+  --> $DIR/feature-gate-abi.rs:37:12\n    |\n LL |     extern \"thiscall\" fn m8();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:38:5\n+  --> $DIR/feature-gate-abi.rs:38:12\n    |\n LL |     extern \"amdgpu-kernel\" fn m9();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:39:5\n+  --> $DIR/feature-gate-abi.rs:39:12\n    |\n LL |     extern \"efiapi\" fn m10();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:41:5\n+  --> $DIR/feature-gate-abi.rs:41:12\n    |\n LL |     extern \"vectorcall\" fn dm3() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:42:5\n+  --> $DIR/feature-gate-abi.rs:42:12\n    |\n LL |     extern \"rust-call\" fn dm4() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:43:5\n+  --> $DIR/feature-gate-abi.rs:43:12\n    |\n LL |     extern \"msp430-interrupt\" fn dm5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:44:5\n+  --> $DIR/feature-gate-abi.rs:44:12\n    |\n LL |     extern \"ptx-kernel\" fn dm6() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:45:5\n+  --> $DIR/feature-gate-abi.rs:45:12\n    |\n LL |     extern \"x86-interrupt\" fn dm7() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:46:5\n+  --> $DIR/feature-gate-abi.rs:46:12\n    |\n LL |     extern \"thiscall\" fn dm8() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:47:5\n+  --> $DIR/feature-gate-abi.rs:47:12\n    |\n LL |     extern \"amdgpu-kernel\" fn dm9() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:48:5\n+  --> $DIR/feature-gate-abi.rs:48:12\n    |\n LL |     extern \"efiapi\" fn dm10() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:55:5\n+  --> $DIR/feature-gate-abi.rs:55:12\n    |\n LL |     extern \"rust-intrinsic\" fn m1() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:57:5\n+  --> $DIR/feature-gate-abi.rs:57:12\n    |\n LL |     extern \"platform-intrinsic\" fn m2() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:59:5\n+  --> $DIR/feature-gate-abi.rs:59:12\n    |\n LL |     extern \"vectorcall\" fn m3() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:60:5\n+  --> $DIR/feature-gate-abi.rs:60:12\n    |\n LL |     extern \"rust-call\" fn m4() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:61:5\n+  --> $DIR/feature-gate-abi.rs:61:12\n    |\n LL |     extern \"msp430-interrupt\" fn m5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:62:5\n+  --> $DIR/feature-gate-abi.rs:62:12\n    |\n LL |     extern \"ptx-kernel\" fn m6() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:63:5\n+  --> $DIR/feature-gate-abi.rs:63:12\n    |\n LL |     extern \"x86-interrupt\" fn m7() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:64:5\n+  --> $DIR/feature-gate-abi.rs:64:12\n    |\n LL |     extern \"thiscall\" fn m8() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:65:5\n+  --> $DIR/feature-gate-abi.rs:65:12\n    |\n LL |     extern \"amdgpu-kernel\" fn m9() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:66:5\n+  --> $DIR/feature-gate-abi.rs:66:12\n    |\n LL |     extern \"efiapi\" fn m10() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:71:5\n+  --> $DIR/feature-gate-abi.rs:71:12\n    |\n LL |     extern \"rust-intrinsic\" fn im1() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:73:5\n+  --> $DIR/feature-gate-abi.rs:73:12\n    |\n LL |     extern \"platform-intrinsic\" fn im2() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:75:5\n+  --> $DIR/feature-gate-abi.rs:75:12\n    |\n LL |     extern \"vectorcall\" fn im3() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:76:5\n+  --> $DIR/feature-gate-abi.rs:76:12\n    |\n LL |     extern \"rust-call\" fn im4() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:77:5\n+  --> $DIR/feature-gate-abi.rs:77:12\n    |\n LL |     extern \"msp430-interrupt\" fn im5() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:78:5\n+  --> $DIR/feature-gate-abi.rs:78:12\n    |\n LL |     extern \"ptx-kernel\" fn im6() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:79:5\n+  --> $DIR/feature-gate-abi.rs:79:12\n    |\n LL |     extern \"x86-interrupt\" fn im7() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:80:5\n+  --> $DIR/feature-gate-abi.rs:80:12\n    |\n LL |     extern \"thiscall\" fn im8() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:81:5\n+  --> $DIR/feature-gate-abi.rs:81:12\n    |\n LL |     extern \"amdgpu-kernel\" fn im9() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:82:5\n+  --> $DIR/feature-gate-abi.rs:82:12\n    |\n LL |     extern \"efiapi\" fn im10() {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:86:11\n+  --> $DIR/feature-gate-abi.rs:86:18\n    |\n LL | type A1 = extern \"rust-intrinsic\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:87:11\n+  --> $DIR/feature-gate-abi.rs:87:18\n    |\n LL | type A2 = extern \"platform-intrinsic\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:88:11\n+  --> $DIR/feature-gate-abi.rs:88:18\n    |\n LL | type A3 = extern \"vectorcall\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:89:11\n+  --> $DIR/feature-gate-abi.rs:89:18\n    |\n LL | type A4 = extern \"rust-call\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:90:11\n+  --> $DIR/feature-gate-abi.rs:90:18\n    |\n LL | type A5 = extern \"msp430-interrupt\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:91:11\n+  --> $DIR/feature-gate-abi.rs:91:18\n    |\n LL | type A6 = extern \"ptx-kernel\" fn ();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:92:11\n+  --> $DIR/feature-gate-abi.rs:92:18\n    |\n LL | type A7 = extern \"x86-interrupt\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:93:11\n+  --> $DIR/feature-gate-abi.rs:93:18\n    |\n LL | type A8 = extern \"thiscall\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:94:11\n+  --> $DIR/feature-gate-abi.rs:94:18\n    |\n LL | type A9 = extern \"amdgpu-kernel\" fn();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:95:12\n+  --> $DIR/feature-gate-abi.rs:95:19\n    |\n LL | type A10 = extern \"efiapi\" fn();\n-   |            ^^^^^^^^^^^^^^^^^^^^\n+   |                   ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-abi.rs:98:1\n+  --> $DIR/feature-gate-abi.rs:98:8\n    |\n LL | extern \"rust-intrinsic\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: platform intrinsics are experimental and possibly buggy\n-  --> $DIR/feature-gate-abi.rs:99:1\n+  --> $DIR/feature-gate-abi.rs:99:8\n    |\n LL | extern \"platform-intrinsic\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27731\n    = help: add `#![feature(platform_intrinsics)]` to the crate attributes to enable\n \n error[E0658]: vectorcall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:100:1\n+  --> $DIR/feature-gate-abi.rs:100:8\n    |\n LL | extern \"vectorcall\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_vectorcall)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-abi.rs:101:1\n+  --> $DIR/feature-gate-abi.rs:101:8\n    |\n LL | extern \"rust-call\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: msp430-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:102:1\n+  --> $DIR/feature-gate-abi.rs:102:8\n    |\n LL | extern \"msp430-interrupt\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38487\n    = help: add `#![feature(abi_msp430_interrupt)]` to the crate attributes to enable\n \n error[E0658]: PTX ABIs are experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:103:1\n+  --> $DIR/feature-gate-abi.rs:103:8\n    |\n LL | extern \"ptx-kernel\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/38788\n    = help: add `#![feature(abi_ptx)]` to the crate attributes to enable\n \n error[E0658]: x86-interrupt ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:104:1\n+  --> $DIR/feature-gate-abi.rs:104:8\n    |\n LL | extern \"x86-interrupt\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/40180\n    = help: add `#![feature(abi_x86_interrupt)]` to the crate attributes to enable\n \n error[E0658]: thiscall is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:105:1\n+  --> $DIR/feature-gate-abi.rs:105:8\n    |\n LL | extern \"thiscall\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_thiscall)]` to the crate attributes to enable\n \n error[E0658]: amdgpu-kernel ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:106:1\n+  --> $DIR/feature-gate-abi.rs:106:8\n    |\n LL | extern \"amdgpu-kernel\" {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51575\n    = help: add `#![feature(abi_amdgpu_kernel)]` to the crate attributes to enable\n \n error[E0658]: efiapi ABI is experimental and subject to change\n-  --> $DIR/feature-gate-abi.rs:107:1\n+  --> $DIR/feature-gate-abi.rs:107:8\n    |\n LL | extern \"efiapi\" {}\n-   | ^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/65815\n    = help: add `#![feature(abi_efiapi)]` to the crate attributes to enable"}, {"sha": "1757befec35c059bffc15f13d0f4491bc855043c", "filename": "src/test/ui/feature-gates/feature-gate-abi_unadjusted.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi_unadjusted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi_unadjusted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-abi_unadjusted.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,10 +1,8 @@\n error[E0658]: unadjusted ABI is an implementation detail and perma-unstable\n-  --> $DIR/feature-gate-abi_unadjusted.rs:1:1\n+  --> $DIR/feature-gate-abi_unadjusted.rs:1:8\n    |\n-LL | / extern \"unadjusted\" fn foo() {\n-LL | |\n-LL | | }\n-   | |_^\n+LL | extern \"unadjusted\" fn foo() {\n+   |        ^^^^^^^^^^^^\n    |\n    = help: add `#![feature(abi_unadjusted)]` to the crate attributes to enable\n "}, {"sha": "8f943d357ce02f0685e19aeeaee3398d89cf581f", "filename": "src/test/ui/feature-gates/feature-gate-intrinsics.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-intrinsics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-intrinsics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-intrinsics.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,18 +1,16 @@\n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-intrinsics.rs:1:1\n+  --> $DIR/feature-gate-intrinsics.rs:1:8\n    |\n-LL | / extern \"rust-intrinsic\" {\n-LL | |     fn bar();\n-LL | | }\n-   | |_^\n+LL | extern \"rust-intrinsic\" {\n+   |        ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n \n error[E0658]: intrinsics are subject to change\n-  --> $DIR/feature-gate-intrinsics.rs:5:1\n+  --> $DIR/feature-gate-intrinsics.rs:5:8\n    |\n LL | extern \"rust-intrinsic\" fn baz() {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(intrinsics)]` to the crate attributes to enable\n "}, {"sha": "657bf13c8739ec57a5408a8710584f4a04e3a559", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,35 +1,35 @@\n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:11:5\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:11:12\n    |\n LL |     extern \"rust-call\" fn call(self, args: ()) -> () {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:17:5\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:17:12\n    |\n LL |     extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:5\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:23:12\n    |\n LL |     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:29:5\n+  --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:29:12\n    |\n LL |     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "f343a42eb8fa9ce0f8f35ace66b89ce82c43cf89", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,10 +1,8 @@\n error[E0658]: rust-call ABI is subject to change\n-  --> $DIR/feature-gate-unboxed-closures.rs:9:5\n+  --> $DIR/feature-gate-unboxed-closures.rs:9:12\n    |\n-LL | /     extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {\n-LL | |         a + b\n-LL | |     }\n-   | |_____^\n+LL |     extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {\n+   |            ^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "151dc68162155c971f4be0694ce111e42b3aeff1", "filename": "src/test/ui/impl-trait/trait_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -29,7 +29,7 @@ error[E0046]: not all trait items implemented, missing: `fmt`\n LL | impl std::fmt::Display for MyType4 {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `fmt` in implementation\n    |\n-   = note: `fmt` from trait: `fn(&Self, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n+   = help: implement the missing item: `fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> { unimplemented!() }`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "271fbb6c87426b9726d2848d538b8d26dbab5be4", "filename": "src/test/ui/issues/issue-3344.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fissues%2Fissue-3344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fissues%2Fissue-3344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3344.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -4,7 +4,7 @@ error[E0046]: not all trait items implemented, missing: `partial_cmp`\n LL | impl PartialOrd for Thing {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^ missing `partial_cmp` in implementation\n    |\n-   = note: `partial_cmp` from trait: `fn(&Self, &Rhs) -> std::option::Option<std::cmp::Ordering>`\n+   = help: implement the missing item: `fn partial_cmp(&self, _: &Rhs) -> std::option::Option<std::cmp::Ordering> { unimplemented!() }`\n \n error: aborting due to previous error\n "}, {"sha": "f88a52d31591872be8f921a53ca6f6f06d0c628e", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.fixed", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.fixed?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,33 @@\n+// run-pass\n+// run-rustfix\n+\n+fn main() {\n+    let small = [1, 2];\n+    let big = [0u8; 33];\n+\n+    // Expressions that should trigger the lint\n+    small.iter();\n+    //~^ WARNING this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    [1, 2].iter();\n+    //~^ WARNING this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    big.iter();\n+    //~^ WARNING this method call currently resolves to `<&[T] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    [0u8; 33].iter();\n+    //~^ WARNING this method call currently resolves to `<&[T] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+\n+\n+    // Expressions that should not\n+    (&[1, 2]).into_iter();\n+    (&small).into_iter();\n+    (&[0u8; 33]).into_iter();\n+    (&big).into_iter();\n+\n+    for _ in &[1, 2] {}\n+    (&small as &[_]).into_iter();\n+    small[..].into_iter();\n+    std::iter::IntoIterator::into_iter(&[1, 2]);\n+}"}, {"sha": "e1a4b535f383258b2d892b47e3b1ceafd8d4b6d6", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,33 @@\n+// run-pass\n+// run-rustfix\n+\n+fn main() {\n+    let small = [1, 2];\n+    let big = [0u8; 33];\n+\n+    // Expressions that should trigger the lint\n+    small.into_iter();\n+    //~^ WARNING this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    [1, 2].into_iter();\n+    //~^ WARNING this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    big.into_iter();\n+    //~^ WARNING this method call currently resolves to `<&[T] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+    [0u8; 33].into_iter();\n+    //~^ WARNING this method call currently resolves to `<&[T] as IntoIterator>::into_iter`\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+\n+\n+    // Expressions that should not\n+    (&[1, 2]).into_iter();\n+    (&small).into_iter();\n+    (&[0u8; 33]).into_iter();\n+    (&big).into_iter();\n+\n+    for _ in &[1, 2] {}\n+    (&small as &[_]).into_iter();\n+    small[..].into_iter();\n+    std::iter::IntoIterator::into_iter(&[1, 2]);\n+}"}, {"sha": "b5964bd44bff7b88e07298c05155d261c2fb7b7d", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,37 @@\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:9:11\n+   |\n+LL |     small.into_iter();\n+   |           ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = note: `#[warn(array_into_iter)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+warning: this method call currently resolves to `<&[T; N] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:12:12\n+   |\n+LL |     [1, 2].into_iter();\n+   |            ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+warning: this method call currently resolves to `<&[T] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:15:9\n+   |\n+LL |     big.into_iter();\n+   |         ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+\n+warning: this method call currently resolves to `<&[T] as IntoIterator>::into_iter` (due to autoref coercions), but that might change in the future when `IntoIterator` impls for arrays are added.\n+  --> $DIR/into-iter-on-arrays-lint.rs:18:15\n+   |\n+LL |     [0u8; 33].into_iter();\n+   |               ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #66145 <https://github.com/rust-lang/rust/issues/66145>\n+"}, {"sha": "f8243528d72cff0243759b5afba8633df46c6f9a", "filename": "src/test/ui/missing/missing-items/m2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -4,9 +4,9 @@ error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `met\n LL | impl m1::X for X {\n    | ^^^^^^^^^^^^^^^^ missing `CONSTANT`, `Type`, `method` in implementation\n    |\n-   = note: `CONSTANT` from trait: `const CONSTANT: u32;`\n-   = note: `Type` from trait: `type Type;`\n-   = note: `method` from trait: `fn(&Self, std::string::String) -> <Self as m1::X>::Type`\n+   = help: implement the missing item: `const CONSTANT: u32 = 42;`\n+   = help: implement the missing item: `type Type = Type;`\n+   = help: implement the missing item: `fn method(&self, _: std::string::String) -> <Self as m1::X>::Type { unimplemented!() }`\n \n error: aborting due to previous error\n "}, {"sha": "7db83674efc60620e086413be79f3332263a184d", "filename": "src/test/ui/parser/bad-lit-suffixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,9 +1,9 @@\n extern\n-    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n+    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n     fn foo() {}\n \n extern\n-    \"C\"suffix //~ ERROR suffixes on an ABI spec are invalid\n+    \"C\"suffix //~ ERROR suffixes on a string literal are invalid\n {}\n \n fn main() {"}, {"sha": "6b0049298ffd23e57f8996afc24a5b5ea5d9ee2e", "filename": "src/test/ui/parser/bad-lit-suffixes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fbad-lit-suffixes.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -1,10 +1,10 @@\n-error: suffixes on an ABI spec are invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:2:5\n    |\n LL |     \"C\"suffix\n    |     ^^^^^^^^^ invalid suffix `suffix`\n \n-error: suffixes on an ABI spec are invalid\n+error: suffixes on a string literal are invalid\n   --> $DIR/bad-lit-suffixes.rs:6:5\n    |\n LL |     \"C\"suffix"}, {"sha": "cb23f2c808c3478515e6366ce7d66d565062f2d7", "filename": "src/test/ui/parser/extern-abi-from-mac-literal-frag.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-from-mac-literal-frag.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+\n+// In this test we check that the parser accepts an ABI string when it\n+// comes from a macro `literal` fragment as opposed to a hardcoded string.\n+\n+fn main() {}\n+\n+macro_rules! abi_from_lit_frag {\n+    ($abi:literal) => {\n+        extern $abi {\n+            fn _import();\n+        }\n+\n+        extern $abi fn _export() {}\n+\n+        type _PTR = extern $abi fn();\n+    }\n+}\n+\n+mod rust {\n+    abi_from_lit_frag!(\"Rust\");\n+}\n+\n+mod c {\n+    abi_from_lit_frag!(\"C\");\n+}"}, {"sha": "fad855a21f6b1b92a3c1ae9478ae70c6fb9b3461", "filename": "src/test/ui/parser/extern-abi-raw-strings.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-raw-strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-raw-strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-raw-strings.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+// Check that the string literal in `extern lit` will accept raw strings.\n+\n+fn main() {}\n+\n+extern r#\"C\"# fn foo() {}\n+\n+extern r#\"C\"# {\n+    fn bar();\n+}\n+\n+type T = extern r#\"C\"# fn();"}, {"sha": "87bd31aabb67de05a31f9b78219bb7b9774c654c", "filename": "src/test/ui/parser/extern-abi-string-escaping.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-string-escaping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-string-escaping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-string-escaping.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+// Check that the string literal in `extern lit` will escapes.\n+\n+fn main() {}\n+\n+extern \"\\x43\" fn foo() {}\n+\n+extern \"\\x43\" {\n+    fn bar();\n+}\n+\n+type T = extern \"\\x43\" fn();"}, {"sha": "7d2bbfe8a0163cb2a8d75bdcf6b6894a278d9aeb", "filename": "src/test/ui/parser/extern-abi-syntactic.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-syntactic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fextern-abi-syntactic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fextern-abi-syntactic.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+// Check that from the grammar's point of view,\n+// the specific set of ABIs is not part of it.\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+extern \"some_abi_that_we_are_sure_does_not_exist_semantically\" fn foo() {}\n+\n+#[cfg(FALSE)]\n+extern \"some_abi_that_we_are_sure_does_not_exist_semantically\" {\n+    fn foo();\n+}\n+\n+#[cfg(FALSE)]\n+type T = extern \"some_abi_that_we_are_sure_does_not_exist_semantically\" fn();"}, {"sha": "9d68a7bffdeeebfb96b5b3617ea7d8c4cc5ac4fb", "filename": "src/test/ui/parser/issue-65846-rollback-gating-failing-matcher.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65846-rollback-gating-failing-matcher.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+\n+// Test that failing macro matchers will not cause pre-expansion errors\n+// even though they use a feature that is pre-expansion gated.\n+\n+macro_rules! m {\n+    ($e:expr) => { 0 }; // This fails on the input below due to `, foo`.\n+    ($e:expr,) => { 1 }; // This also fails to match due to `foo`.\n+    (box $e:expr, foo) => { 2 }; // Successful matcher, we should get `2`.\n+}\n+\n+fn main() {\n+    assert_eq!(2, m!(box 42, foo));\n+}"}, {"sha": "f23f421edc7c55dad352d0d48fb837acee5e377c", "filename": "src/test/ui/span/impl-wrong-item-for-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimpl-wrong-item-for-trait.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -64,7 +64,7 @@ error[E0046]: not all trait items implemented, missing: `fmt`\n LL | impl Debug for FooTypeForMethod {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `fmt` in implementation\n    |\n-   = note: `fmt` from trait: `fn(&Self, &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error>`\n+   = help: implement the missing item: `fn fmt(&self, _: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> { unimplemented!() }`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "f88ce6c88db2397d094cdd9a80acd28da8509f10", "filename": "src/test/ui/span/issue-23729.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23729.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -4,7 +4,7 @@ error[E0046]: not all trait items implemented, missing: `Item`\n LL |         impl Iterator for Recurrence {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `Item` in implementation\n    |\n-   = note: `Item` from trait: `type Item;`\n+   = help: implement the missing item: `type Item = Type;`\n \n error: aborting due to previous error\n "}, {"sha": "46a820f1b76606c1f850dffb4522ea92c9a6d4ca", "filename": "src/test/ui/span/issue-23827.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-23827.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -4,7 +4,7 @@ error[E0046]: not all trait items implemented, missing: `Output`\n LL | impl<C: Component> FnOnce<(C,)> for Prototype {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `Output` in implementation\n    |\n-   = note: `Output` from trait: `type Output;`\n+   = help: implement the missing item: `type Output = Type;`\n \n error: aborting due to previous error\n "}, {"sha": "a1f9b2550201903b5c03076a44b6d693cb853edd", "filename": "src/test/ui/span/issue-24356.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24356.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -4,7 +4,7 @@ error[E0046]: not all trait items implemented, missing: `Target`\n LL |         impl Deref for Thing {\n    |         ^^^^^^^^^^^^^^^^^^^^ missing `Target` in implementation\n    |\n-   = note: `Target` from trait: `type Target;`\n+   = help: implement the missing item: `type Target = Type;`\n \n error: aborting due to previous error\n "}, {"sha": "42f579a665e5fe0fcecd6a93a95d01bff609a421", "filename": "src/test/ui/suggestions/missing-trait-item.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.fixed?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+\n+trait T {\n+    unsafe fn foo(a: &usize, b: &usize) -> usize;\n+    fn bar(&self, a: &usize, b: &usize) -> usize;\n+}\n+\n+mod foo {\n+    use super::T;\n+    impl T for () {    fn bar(&self, _: &usize, _: &usize) -> usize { unimplemented!() }\n+        unsafe fn foo(_: &usize, _: &usize) -> usize { unimplemented!() }\n+    } //~ ERROR not all trait items\n+\n+    impl T for usize { //~ ERROR not all trait items\n+        fn bar(&self, _: &usize, _: &usize) -> usize { unimplemented!() }\n+        unsafe fn foo(_: &usize, _: &usize) -> usize { unimplemented!() }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b4fca25ba2f11c586fa0a3ebdb395a5a4b53a497", "filename": "src/test/ui/suggestions/missing-trait-item.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.rs?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+\n+trait T {\n+    unsafe fn foo(a: &usize, b: &usize) -> usize;\n+    fn bar(&self, a: &usize, b: &usize) -> usize;\n+}\n+\n+mod foo {\n+    use super::T;\n+    impl T for () {} //~ ERROR not all trait items\n+\n+    impl T for usize { //~ ERROR not all trait items\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4a9d7b472c93a16b9ed4d89538f9475a81713db7", "filename": "src/test/ui/suggestions/missing-trait-item.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50f8aadd746ebc929a752e5ffb133936ee75c52f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-trait-item.stderr?ref=50f8aadd746ebc929a752e5ffb133936ee75c52f", "patch": "@@ -0,0 +1,25 @@\n+error[E0046]: not all trait items implemented, missing: `foo`, `bar`\n+  --> $DIR/missing-trait-item.rs:10:5\n+   |\n+LL |     unsafe fn foo(a: &usize, b: &usize) -> usize;\n+   |     --------------------------------------------- `foo` from trait\n+LL |     fn bar(&self, a: &usize, b: &usize) -> usize;\n+   |     --------------------------------------------- `bar` from trait\n+...\n+LL |     impl T for () {}\n+   |     ^^^^^^^^^^^^^ missing `foo`, `bar` in implementation\n+\n+error[E0046]: not all trait items implemented, missing: `foo`, `bar`\n+  --> $DIR/missing-trait-item.rs:12:5\n+   |\n+LL |     unsafe fn foo(a: &usize, b: &usize) -> usize;\n+   |     --------------------------------------------- `foo` from trait\n+LL |     fn bar(&self, a: &usize, b: &usize) -> usize;\n+   |     --------------------------------------------- `bar` from trait\n+...\n+LL |     impl T for usize {\n+   |     ^^^^^^^^^^^^^^^^ missing `foo`, `bar` in implementation\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0046`."}]}