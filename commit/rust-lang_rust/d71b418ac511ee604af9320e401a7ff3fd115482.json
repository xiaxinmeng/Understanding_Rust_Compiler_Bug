{"sha": "d71b418ac511ee604af9320e401a7ff3fd115482", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MWI0MThhYzUxMWVlNjA0YWY5MzIwZTQwMWE3ZmYzZmQxMTU0ODI=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-08-16T18:47:50Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-08-16T18:47:50Z"}, "message": "Moved to submodule, don't trigger if map_unwrap_or does", "tree": {"sha": "11abd2a02280720217203587fe0b3f1cc73a147d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11abd2a02280720217203587fe0b3f1cc73a147d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d71b418ac511ee604af9320e401a7ff3fd115482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d71b418ac511ee604af9320e401a7ff3fd115482", "html_url": "https://github.com/rust-lang/rust/commit/d71b418ac511ee604af9320e401a7ff3fd115482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d71b418ac511ee604af9320e401a7ff3fd115482/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c41822d34c69dbfded4d9d8b4b8962564be80f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c41822d34c69dbfded4d9d8b4b8962564be80f1", "html_url": "https://github.com/rust-lang/rust/commit/9c41822d34c69dbfded4d9d8b4b8962564be80f1"}], "stats": {"total": 249, "additions": 132, "deletions": 117}, "files": [{"sha": "bfc89a747421f7868052a4bf41cc2afb91423460", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 19, "deletions": 117, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/d71b418ac511ee604af9320e401a7ff3fd115482/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71b418ac511ee604af9320e401a7ff3fd115482/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d71b418ac511ee604af9320e401a7ff3fd115482", "patch": "@@ -3,6 +3,7 @@ mod inefficient_to_string;\n mod manual_saturating_arithmetic;\n mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n+mod unnecessary_lazy_eval;\n \n use std::borrow::Cow;\n use std::fmt;\n@@ -1436,17 +1437,18 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"unwrap_or_else\", \"map\"] => {\n-                lint_lazy_eval(cx, expr, arg_lists[0], true, \"unwrap_or\");\n-                lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]);\n+                if !lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]) {\n+                    unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                }\n             },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n-                lint_lazy_eval(cx, expr, arg_lists[0], false, \"and\");\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"and\");\n                 bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n             },\n             [\"or_else\", ..] => {\n-                lint_lazy_eval(cx, expr, arg_lists[0], false, \"or\");\n+                unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], false, \"or\");\n                 bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1490,9 +1492,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n-            [\"unwrap_or_else\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n-            [\"get_or_insert_with\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n-            [\"ok_or_else\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"ok_or\"),\n+            [\"unwrap_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => unnecessary_lazy_eval::lint(cx, expr, arg_lists[0], true, \"ok_or\"),\n             _ => {},\n         }\n \n@@ -2708,119 +2710,13 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n }\n \n-/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n-/// replaced with `<fn>(return value of simple closure)`\n-fn lint_lazy_eval<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    args: &'tcx [hir::Expr<'_>],\n-    allow_variant_calls: bool,\n-    simplify_using: &str,\n-) {\n-    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n-    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n-\n-    if !is_option && !is_result {\n-        return;\n-    }\n-\n-    // Return true if the expression is an accessor of any of the arguments\n-    fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n-        params.iter().any(|arg| {\n-            if_chain! {\n-                if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n-                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n-                if let [p, ..] = path.segments;\n-                then {\n-                    ident.name == p.ident.name\n-                } else {\n-                    false\n-                }\n-            }\n-        })\n-    }\n-\n-    fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n-        paths.iter().any(|candidate| match_qpath(path, candidate))\n-    }\n-\n-    fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n-        match expr.kind {\n-            // Closures returning literals can be unconditionally simplified\n-            hir::ExprKind::Lit(_) => true,\n-\n-            hir::ExprKind::Index(ref object, ref index) => {\n-                // arguments are not being indexed into\n-                if !expr_uses_argument(object, params) {\n-                    // arguments are not used as index\n-                    !expr_uses_argument(index, params)\n-                } else {\n-                    false\n-                }\n-            },\n-\n-            // Reading fields can be simplified if the object is not an argument of the closure\n-            hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n-\n-            // Paths can be simplified if the root is not the argument, this also covers None\n-            hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n-\n-            // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n-            hir::ExprKind::Call(ref func, ref args) => if_chain! {\n-                if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n-                if let hir::ExprKind::Path(ref path) = func.kind;\n-                if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n-                then {\n-                    // Recursively check all arguments\n-                    args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n-                } else {\n-                    false\n-                }\n-            },\n-\n-            // For anything more complex than the above, a closure is probably the right solution,\n-            // or the case is handled by an other lint\n-            _ => false,\n-        }\n-    }\n-\n-    if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n-        let body = cx.tcx.hir().body(eid);\n-        let ex = &body.value;\n-        let params = &body.params;\n-\n-        if can_simplify(ex, params, allow_variant_calls) {\n-            let msg = if is_option {\n-                \"unnecessary closure used to substitute value for `Option::None`\"\n-            } else {\n-                \"unnecessary closure used to substitute value for `Result::Err`\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                UNNECESSARY_LAZY_EVALUATION,\n-                expr.span,\n-                msg,\n-                &format!(\"Use `{}` instead\", simplify_using),\n-                format!(\n-                    \"{0}.{1}({2})\",\n-                    snippet(cx, args[0].span, \"..\"),\n-                    simplify_using,\n-                    snippet(cx, ex.span, \"..\"),\n-                ),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-}\n-\n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'_>,\n     map_args: &'tcx [hir::Expr<'_>],\n     unwrap_args: &'tcx [hir::Expr<'_>],\n-) {\n+) -> bool {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type));\n     let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(result_type));\n@@ -2832,10 +2728,10 @@ fn lint_map_unwrap_or_else<'tcx>(\n         let unwrap_mutated_vars = mutated_variables(&unwrap_args[1], cx);\n         if let (Some(map_mutated_vars), Some(unwrap_mutated_vars)) = (map_mutated_vars, unwrap_mutated_vars) {\n             if map_mutated_vars.intersection(&unwrap_mutated_vars).next().is_some() {\n-                return;\n+                return false;\n             }\n         } else {\n-            return;\n+            return false;\n         }\n \n         // lint message\n@@ -2865,9 +2761,15 @@ fn lint_map_unwrap_or_else<'tcx>(\n                     map_snippet, unwrap_snippet,\n                 ),\n             );\n+            true\n         } else if same_span && multiline {\n             span_lint(cx, MAP_UNWRAP_OR, expr.span, msg);\n-        };\n+            true\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n     }\n }\n "}, {"sha": "0dbedc4919c3480aacedf2c8ab6fb6778843d234", "filename": "clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d71b418ac511ee604af9320e401a7ff3fd115482/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71b418ac511ee604af9320e401a7ff3fd115482/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=d71b418ac511ee604af9320e401a7ff3fd115482", "patch": "@@ -0,0 +1,113 @@\n+use crate::utils::{match_qpath, span_lint_and_sugg, snippet, is_type_diagnostic_item};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+use super::UNNECESSARY_LAZY_EVALUATION;\n+\n+/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n+/// replaced with `<fn>(return value of simple closure)`\n+pub(super) fn lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    args: &'tcx [hir::Expr<'_>],\n+    allow_variant_calls: bool,\n+    simplify_using: &str,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&args[0]), sym!(result_type));\n+\n+    if !is_option && !is_result {\n+        return;\n+    }\n+\n+    // Return true if the expression is an accessor of any of the arguments\n+    fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+        params.iter().any(|arg| {\n+            if_chain! {\n+                if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+                if let [p, ..] = path.segments;\n+                then {\n+                    ident.name == p.ident.name\n+                } else {\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+        paths.iter().any(|candidate| match_qpath(path, candidate))\n+    }\n+\n+    fn can_simplify(expr: &hir::Expr<'_>, params: &[hir::Param<'_>], variant_calls: bool) -> bool {\n+        match expr.kind {\n+            // Closures returning literals can be unconditionally simplified\n+            hir::ExprKind::Lit(_) => true,\n+\n+            hir::ExprKind::Index(ref object, ref index) => {\n+                // arguments are not being indexed into\n+                if !expr_uses_argument(object, params) {\n+                    // arguments are not used as index\n+                    !expr_uses_argument(index, params)\n+                } else {\n+                    false\n+                }\n+            },\n+\n+            // Reading fields can be simplified if the object is not an argument of the closure\n+            hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+            // Paths can be simplified if the root is not the argument, this also covers None\n+            hir::ExprKind::Path(_) => !expr_uses_argument(expr, params),\n+\n+            // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+            hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+                if variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+                if let hir::ExprKind::Path(ref path) = func.kind;\n+                if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+                then {\n+                    // Recursively check all arguments\n+                    args.iter().all(|arg| can_simplify(arg, params, variant_calls))\n+                } else {\n+                    false\n+                }\n+            },\n+\n+            // For anything more complex than the above, a closure is probably the right solution,\n+            // or the case is handled by an other lint\n+            _ => false,\n+        }\n+    }\n+\n+    if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+        let body = cx.tcx.hir().body(eid);\n+        let ex = &body.value;\n+        let params = &body.params;\n+\n+        if can_simplify(ex, params, allow_variant_calls) {\n+            let msg = if is_option {\n+                \"unnecessary closure used to substitute value for `Option::None`\"\n+            } else {\n+                \"unnecessary closure used to substitute value for `Result::Err`\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_LAZY_EVALUATION,\n+                expr.span,\n+                msg,\n+                &format!(\"Use `{}` instead\", simplify_using),\n+                format!(\n+                    \"{0}.{1}({2})\",\n+                    snippet(cx, args[0].span, \"..\"),\n+                    simplify_using,\n+                    snippet(cx, ex.span, \"..\"),\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}]}