{"sha": "ef895b96320a9d5c64090bad1c8a147b0431eef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODk1Yjk2MzIwYTlkNWM2NDA5MGJhZDFjOGExNDdiMDQzMWVlZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-11T03:41:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-11T03:57:00Z"}, "message": "update various parts of the tutorial", "tree": {"sha": "416e6d05266fe8d3afcb199024121f0c61e8aa0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/416e6d05266fe8d3afcb199024121f0c61e8aa0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef895b96320a9d5c64090bad1c8a147b0431eef1", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef895b96320a9d5c64090bad1c8a147b0431eef1", "html_url": "https://github.com/rust-lang/rust/commit/ef895b96320a9d5c64090bad1c8a147b0431eef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef895b96320a9d5c64090bad1c8a147b0431eef1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441a42c5d2707ae93a8be3c6be5c426e7416e50b", "url": "https://api.github.com/repos/rust-lang/rust/commits/441a42c5d2707ae93a8be3c6be5c426e7416e50b", "html_url": "https://github.com/rust-lang/rust/commit/441a42c5d2707ae93a8be3c6be5c426e7416e50b"}], "stats": {"total": 251, "additions": 202, "deletions": 49}, "files": [{"sha": "1906aac05f44a772891963868793bfe9449532e3", "filename": "doc/tutorial/data.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Fdata.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Fdata.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fdata.md?ref=ef895b96320a9d5c64090bad1c8a147b0431eef1", "patch": "@@ -188,6 +188,8 @@ All pointer types can be dereferenced with the `*` unary operator.\n \n ### Shared boxes\n \n+<a name=\"shared-box\"></a>\n+\n Shared boxes are pointers to heap-allocated, reference counted memory.\n A cycle collector ensures that circular references do not result in\n memory leaks.\n@@ -207,6 +209,8 @@ Shared boxes never cross task boundaries.\n \n ### Unique boxes\n \n+<a name=\"unique-box\"></a>\n+\n In contrast to shared boxes, unique boxes are not reference counted.\n Instead, it is statically guaranteed that only a single owner of the\n box exists at any time."}, {"sha": "f7397204f5c8c8581f78b5cef4ab01a28ee57235", "filename": "doc/tutorial/func.md", "status": "modified", "additions": 121, "deletions": 47, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Ffunc.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Ffunc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ffunc.md?ref=ef895b96320a9d5c64090bad1c8a147b0431eef1", "patch": "@@ -29,48 +29,86 @@ expected to return.\n \n ## Closures\n \n-Normal Rust functions (declared with `fn`) do not close over their\n-environment. A `lambda` expression can be used to create a closure.\n-\n-    fn make_plus_function(x: int) -> lambda(int) -> int {\n-        lambda(y: int) -> int { x + y }\n-    }\n-    let plus_two = make_plus_function(2);\n-    assert plus_two(3) == 5;\n-\n-A `lambda` function *copies* its environment (in this case, the\n-binding for `x`). It can not mutate the closed-over bindings, and will\n-not see changes made to these variables after the `lambda` was\n-evaluated. `lambda`s can be put in data structures and passed around\n-without limitation.\n-\n-The type of a closure is `lambda(args) -> type`, as opposed to\n-`fn(args) -> type`. The `fn` type stands for 'bare' functions, with no\n-closure attached. Keep this in mind when writing higher-order\n-functions.\n-\n-A different form of closure is the block. Blocks are written like they\n-are in Ruby: `{|x| x + y}`, the formal parameters between pipes,\n-followed by the function body. They are stack-allocated and properly\n-close over their environment (they see updates to closed over\n-variables, for example). But blocks can only be used in a limited set\n-of circumstances. They can be passed to other functions, but not\n-stored in data structures or returned.\n-\n-    fn map_int(f: block(int) -> int, vec: [int]) -> [int] {\n-        let result = [];\n-        for i in vec { result += [f(i)]; }\n-        ret result;\n-    }\n-    map_int({|x| x + 1 }, [1, 2, 3]);\n-\n-The type of blocks is spelled `block(args) -> type`. Both closures and\n-bare functions are automatically convert to `block`s when appropriate.\n-Most higher-order functions should take their function arguments as\n-`block`s.\n-\n-A block with no arguments is written `{|| body(); }`\u2014you can not leave\n-off the pipes.\n+Named rust functions, like those in the previous section, do not close\n+over their environment. Rust also includes support for closures, which\n+are anonymous functions that can access the variables that were in\n+scope at the time the closure was created.  Closures are represented\n+as the pair of a function pointer (as in C) and the environment, which\n+is where the values of the closed over variables are stored.  Rust\n+includes support for three varieties of closure, each with different\n+costs and capabilities:\n+\n+- Stack closures (written `block`) store their environment in the\n+  stack frame of their creator; they are very lightweight but cannot\n+  be stored in a data structure.\n+- Boxed closures (written `fn@`) store their environment in a\n+  [shared box](data#shared-box).  These are good for storing within\n+  data structures but cannot be sent to another task.\n+- Unique closures (written `fn~`) store their environment in a\n+  [unique box](data#unique-box).  These are limited in the kinds of\n+  data that they can close over so that they can be safely sent\n+  between tasks.  As with any unique pointer, copying a unique closure\n+  results in a deep clone of the environment.\n+  \n+Both boxed closures and unique closures are subtypes of stack\n+closures, meaning that wherever a stack closure type appears, a boxed\n+or unique closure value can be used.  This is due to the restrictions\n+placed on the use of stack closures, which ensure that all operations\n+on a stack closure are also safe on any kind of closure.\n+\n+### Working with closures\n+\n+Closures are specified by writing an inline, anonymous function\n+declaration.  For example, the following code creates a boxed closure:\n+\n+    let plus_two = fn@(x: int) -> int {\n+        ret x + 2;\n+    };\n+    \n+Creating a unique closure is very similar:\n+\n+    let plus_two_uniq = fn~(x: int) -> int {\n+        ret x + 2;\n+    };\n+    \n+Stack closures can be created in a similar way; however, because stack\n+closures literally point into their creator's stack frame, they can\n+only be used in a very specific way.  Stack closures may be passed as\n+parameters and they may be called, but they may not be stored into\n+local variables or fields.  Creating a stack closure can therefore be\n+done using a syntax like the following:\n+\n+    let doubled = vec::map([1, 2, 3], block(x: int) -> int {\n+        x * 2\n+    });\n+    \n+Here the `vec::map()` is the standard higher-order map function, which\n+applies the closure to each item in the vector and returns a new\n+vector containing the results.\n+    \n+### Shorthand syntax\n+\n+The syntax in the previous section was very explicit; it fully\n+specifies the kind of closure as well as the type of every parameter\n+and the return type.  In practice, however, closures are often used as\n+parameters to functions, and all of these details can be inferred.\n+Therefore, we support a shorthand syntax similar to Ruby or Smalltalk\n+blocks, which looks as follows:\n+\n+    let doubled = vec::map([1, 2, 3], {|x| x*2});\n+ \n+Here the vertical bars after the open brace `{` indicate that this is\n+a closure.  A list of parameters appears between the bars.  The bars\n+must always be present: if there are no arguments, then simply write\n+`{||...}`.\n+\n+As a further simplification, if the final parameter to a function is a\n+closure, the closure need not be placed within parenthesis.\n+Therefore, one could write\n+\n+    let doubled = vec::map([1, 2, 3]) {|x| x*2};\n+   \n+This form is often easier to parse as it involves less nesting.  \n \n ## Binding\n \n@@ -79,8 +117,8 @@ Partial application is done using the `bind` keyword in Rust.\n     let daynum = bind std::vec::position(_, [\"mo\", \"tu\", \"we\", \"do\",\n                                              \"fr\", \"sa\", \"su\"]);\n \n-Binding a function produces a closure (`lambda` type) in which some of\n-the arguments to the bound function have already been provided.\n+Binding a function produces a boxed closure (`fn@` type) in which some\n+of the arguments to the bound function have already been provided.\n `daynum` will be a function taking a single string argument, and\n returning the day of the week that string corresponds to (if any).\n \n@@ -103,11 +141,47 @@ To run such an iteration, you could do this:\n     # fn for_rev(v: [int], act: block(int)) {}\n     for_rev([1, 2, 3], {|n| log n; });\n \n-But Rust allows a more pleasant syntax for this situation, with the\n-loop block moved out of the parenthesis and the final semicolon\n-omitted:\n+Making use of the shorthand where a final closure argument can be\n+moved outside of the parentheses permits the following, which\n+looks quite like a normal loop:\n \n     # fn for_rev(v: [int], act: block(int)) {}\n     for_rev([1, 2, 3]) {|n|\n         log n;\n     }\n+\n+Note that, because `for_rev()` returns unit type, no semicolon is\n+needed when the final closure is pulled outside of the parentheses.\n+\n+## Capture clauses\n+\n+When creating a boxed or unique closure, the default is to copy in the\n+values of any closed over variables.  But sometimes, particularly if a\n+value is large or expensive to copy, you would like to *move* the\n+value into the closure instead.  Rust supports this via the use of a\n+capture clause, which lets you specify precisely whether each variable\n+used in the closure is copied or moved.\n+\n+As an example, let's assume we had some type of unique tree type:\n+\n+    tag tree<T> = tree_rec<T>;\n+    type tree_rec<T> = ~{left: option<tree>, right: option<tree>, val: T};\n+\n+Now if we have a function like the following:\n+\n+    let some_tree: tree<T> = ...;\n+    let some_closure = fn~() {\n+        ... use some_tree in some way ...\n+    };\n+    \n+Here the variable `some_tree` is used within the closure body, so a\n+deep copy will be performed.  This can become quite expensive if the\n+tree is large.  If we know that `some_tree` will not be used again,\n+we could avoid this expense by making use of a capture clause like so:\n+\n+    let some_tree: tree<T> = ...;\n+    let some_closure = fn~[move some_tree]() {\n+        ... use some_tree in some way ...\n+    };\n+\n+This is particularly useful when moving data into [child tasks](task)."}, {"sha": "c22d4016c4033c1d90c58aa8f7604921bf4c0d88", "filename": "doc/tutorial/generic.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Fgeneric.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Fgeneric.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fgeneric.md?ref=ef895b96320a9d5c64090bad1c8a147b0431eef1", "patch": "@@ -87,6 +87,8 @@ without any sophistication).\n \n ## Kinds\n \n+<a name=\"kind\"></a>\n+\n Perhaps surprisingly, the 'copy' (duplicate) operation is not defined\n for all Rust types. Resource types (types with destructors) can not be\n copied, and neither can any type whose copying would require copying a\n@@ -100,7 +102,7 @@ unless you explicitly declare that type parameter to have copyable\n     // This does not compile\n     fn head_bad<T>(v: [T]) -> T { v[0] }\n     // This does\n-    fn head<copy T>(v: [T]) -> T { v[0] }\n+    fn head<T:copy>(v: [T]) -> T { v[0] }\n \n When instantiating a generic function, you can only instantiate it\n with types that fit its kinds. So you could not apply `head` to a"}, {"sha": "b373e27dc214f2bc23a00e5c5daef768a8f5b91d", "filename": "doc/tutorial/task.md", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Ftask.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef895b96320a9d5c64090bad1c8a147b0431eef1/doc%2Ftutorial%2Ftask.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftask.md?ref=ef895b96320a9d5c64090bad1c8a147b0431eef1", "patch": "@@ -1,3 +1,76 @@\n # Tasks\n \n-FIXME to be written\n+Rust supports a system of lightweight tasks, similar to what is found\n+in Erlang or other actor systems.  Rust tasks communicate via messages\n+and do not share data.  However, it is possible to send data without\n+copying it by making use of [unique boxes][uniques] (still, the data\n+is owned by only one task at a time).\n+\n+[uniques]: data.html#unique-box\n+\n+NOTE: As Rust evolves, we expect the Task API to grow and change\n+somewhat.  The tutorial documents the API as it exists today.\n+\n+## Spawning a task\n+\n+Spawning a task is done using the various spawn functions in the\n+module task.  Let's begin with the simplest one, `task::spawn()`, and\n+later move on to the others:\n+\n+    let some_value = 22;\n+    let child_task = task::spawn {||\n+        std::io::println(\"This executes in the child task.\");\n+        std::io::println(#fmt(\"%d\", some_value));\n+    };\n+\n+The argument to `task::spawn()` is a [unique closure](func) of type\n+`fn~()`, meaning that it takes no arguments and generates no return\n+value.  The effect of `task::spawn()` is to fire up a child task that\n+will execute the closure in parallel with the creator.  The result is\n+a task id, here stored into the variable `child_task`.\n+\n+## Ports and channels\n+\n+Now that we have spawned a child task, it would be nice if we could\n+communicate with it.  This is done by creating a *port* with an\n+associated *channel*.  A port is simply a location to receive messages\n+of a particular type.  A channel is used to send messages to a port.\n+For example, imagine we wish to perform two expensive computations\n+in parallel.  We might write something like:\n+\n+    let port = comm::port::<int>();\n+    let chan = comm::chan::<int>(port);\n+    let child_task = task::spawn {||\n+        let result = some_expensive_computation();\n+        comm::send(chan, result);\n+    };\n+    some_other_expensive_computation();\n+    let result = comm::recv(port);\n+\n+Let's walk through this code line-by-line.  The first line creates a\n+port for receiving integers:\n+\n+    let port = comm::port::<int>();\n+    \n+This port is where we will receive the message from the child task\n+once it is complete.  The second line creates a channel for sending\n+integers to the port `port`:\n+\n+    let chan = comm::chan::<int>(port);\n+\n+The channel will be used by the child to send a message to the port.\n+The next statement actually spawns the child:\n+\n+    let child_task = task::spawn {||\n+        let result = some_expensive_computation();\n+        comm::send(chan, result);\n+    };\n+\n+This child will perform the expensive computation send the result\n+over the channel.  Finally, the parent continues by performing\n+some other expensive computation and then waiting for the child's result\n+to arrive on the port:\n+\n+    some_other_expensive_computation();\n+    let result = comm::recv(port);\n+"}]}