{"sha": "4d35cc387576be6645b12d24af09b1e9c3a5f65b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMzVjYzM4NzU3NmJlNjY0NWIxMmQyNGFmMDliMWU5YzNhNWY2NWI=", "commit": {"author": {"name": "DJMcNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2019-01-27T09:00:57Z"}, "committer": {"name": "DJMcNab", "email": "36049421+DJMcNab@users.noreply.github.com", "date": "2019-01-27T09:00:57Z"}, "message": "Stop using let_stmt twice", "tree": {"sha": "f29119867e76f16b4c166bfaa53923ad1d405b5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f29119867e76f16b4c166bfaa53923ad1d405b5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d35cc387576be6645b12d24af09b1e9c3a5f65b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d35cc387576be6645b12d24af09b1e9c3a5f65b", "html_url": "https://github.com/rust-lang/rust/commit/4d35cc387576be6645b12d24af09b1e9c3a5f65b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d35cc387576be6645b12d24af09b1e9c3a5f65b/comments", "author": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DJMcNab", "id": 36049421, "node_id": "MDQ6VXNlcjM2MDQ5NDIx", "avatar_url": "https://avatars.githubusercontent.com/u/36049421?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DJMcNab", "html_url": "https://github.com/DJMcNab", "followers_url": "https://api.github.com/users/DJMcNab/followers", "following_url": "https://api.github.com/users/DJMcNab/following{/other_user}", "gists_url": "https://api.github.com/users/DJMcNab/gists{/gist_id}", "starred_url": "https://api.github.com/users/DJMcNab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DJMcNab/subscriptions", "organizations_url": "https://api.github.com/users/DJMcNab/orgs", "repos_url": "https://api.github.com/users/DJMcNab/repos", "events_url": "https://api.github.com/users/DJMcNab/events{/privacy}", "received_events_url": "https://api.github.com/users/DJMcNab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7055d43c3a1edca16cf5625f1b908643fa0bf21a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7055d43c3a1edca16cf5625f1b908643fa0bf21a", "html_url": "https://github.com/rust-lang/rust/commit/7055d43c3a1edca16cf5625f1b908643fa0bf21a"}], "stats": {"total": 84, "additions": 41, "deletions": 43}, "files": [{"sha": "d27eb8b7e12664b9300a1e0c13bb3c7c5248f95e", "filename": "crates/ra_syntax/src/grammar/expressions.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4d35cc387576be6645b12d24af09b1e9c3a5f65b/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d35cc387576be6645b12d24af09b1e9c3a5f65b/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=4d35cc387576be6645b12d24af09b1e9c3a5f65b", "patch": "@@ -45,10 +45,6 @@ pub(crate) fn block(p: &mut Parser) {\n \n     while !p.at(EOF) && !p.at(R_CURLY) {\n         match p.current() {\n-            LET_KW => {\n-                let m = p.start();\n-                let_stmt(p, m)\n-            }\n             // test nocontentexpr\n             // fn foo(){\n             //     ;;;some_expr();;;;{;;;};;;;Ok(())\n@@ -60,49 +56,51 @@ pub(crate) fn block(p: &mut Parser) {\n                 let m = p.start();\n                 let has_attrs = p.at(POUND);\n                 attributes::outer_attributes(p);\n-                match items::maybe_item(p, items::ItemFlavor::Mod) {\n-                    items::MaybeItem::Item(kind) => {\n-                        m.complete(p, kind);\n-                    }\n-                    items::MaybeItem::Modifiers => {\n-                        m.abandon(p);\n-                        p.error(\"expected an item\");\n-                    }\n-                    // test pub_expr\n-                    // fn foo() { pub 92; } //FIXME\n-                    items::MaybeItem::None => {\n-                        if has_attrs {\n-                            if p.at(LET_KW) {\n-                                let_stmt(p, m);\n-                            } else {\n-                                m.abandon(p);\n-                                p.error(\"expected a let statement\");\n-                            }\n-                        } else {\n-                            let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n-                            if p.at(R_CURLY) {\n+                if p.at(LET_KW) {\n+                    let_stmt(p, m);\n+                } else {\n+                    match items::maybe_item(p, items::ItemFlavor::Mod) {\n+                        items::MaybeItem::Item(kind) => {\n+                            m.complete(p, kind);\n+                        }\n+                        items::MaybeItem::Modifiers => {\n+                            m.abandon(p);\n+                            p.error(\"expected an item\");\n+                        }\n+                        // test pub_expr\n+                        // fn foo() { pub 92; } //FIXME\n+                        items::MaybeItem::None => {\n+                            if has_attrs {\n                                 m.abandon(p);\n+                                p.error(\n+                                    \"expected a let statement or an item after attributes in block\",\n+                                );\n                             } else {\n-                                // test no_semi_after_block\n-                                // fn foo() {\n-                                //     if true {}\n-                                //     loop {}\n-                                //     match () {}\n-                                //     while true {}\n-                                //     for _ in () {}\n-                                //     {}\n-                                //     {}\n-                                //     macro_rules! test {\n-                                //          () => {}\n-                                //     }\n-                                //     test!{}\n-                                // }\n-                                if is_blocklike {\n-                                    p.eat(SEMI);\n+                                let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n+                                if p.at(R_CURLY) {\n+                                    m.abandon(p);\n                                 } else {\n-                                    p.expect(SEMI);\n+                                    // test no_semi_after_block\n+                                    // fn foo() {\n+                                    //     if true {}\n+                                    //     loop {}\n+                                    //     match () {}\n+                                    //     while true {}\n+                                    //     for _ in () {}\n+                                    //     {}\n+                                    //     {}\n+                                    //     macro_rules! test {\n+                                    //          () => {}\n+                                    //     }\n+                                    //     test!{}\n+                                    // }\n+                                    if is_blocklike {\n+                                        p.eat(SEMI);\n+                                    } else {\n+                                        p.expect(SEMI);\n+                                    }\n+                                    m.complete(p, EXPR_STMT);\n                                 }\n-                                m.complete(p, EXPR_STMT);\n                             }\n                         }\n                     }"}]}