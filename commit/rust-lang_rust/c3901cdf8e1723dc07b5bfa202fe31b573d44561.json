{"sha": "c3901cdf8e1723dc07b5bfa202fe31b573d44561", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTAxY2RmOGUxNzIzZGMwN2I1YmZhMjAyZmUzMWI1NzNkNDQ1NjE=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-06-21T00:26:17Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-28T15:02:12Z"}, "message": "Add simple syntax extension (#simplext)", "tree": {"sha": "76ce9e746aee876d0dd7e2e8290f12bc434b9f49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76ce9e746aee876d0dd7e2e8290f12bc434b9f49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3901cdf8e1723dc07b5bfa202fe31b573d44561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3901cdf8e1723dc07b5bfa202fe31b573d44561", "html_url": "https://github.com/rust-lang/rust/commit/c3901cdf8e1723dc07b5bfa202fe31b573d44561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3901cdf8e1723dc07b5bfa202fe31b573d44561/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6326817803079ed33b13b87429ef7d77ce5f4cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6326817803079ed33b13b87429ef7d77ce5f4cb", "html_url": "https://github.com/rust-lang/rust/commit/b6326817803079ed33b13b87429ef7d77ce5f4cb"}], "stats": {"total": 350, "additions": 290, "deletions": 60}, "files": [{"sha": "34b60d4668f6afbe1fc6ff0f77b02001e63bca97", "filename": "src/comp/front/ext.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fext.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -1,25 +1,29 @@\n-\n+import std::vec;\n import std::option;\n import std::map::hashmap;\n import driver::session::session;\n import front::parser::parser;\n import util::common::span;\n import util::common::new_str_hash;\n \n-type syntax_expander =\n-    fn(&ext_ctxt, span, &vec[@ast::expr], option::t[str]) -> @ast::expr ;\n-\n-\n-// Temporary: to introduce a tag in order to make a recursive type work\n-tag syntax_extension { x(syntax_expander); }\n+type syntax_expander = \n+    fn(&ext_ctxt, span, &vec[@ast::expr], option::t[str]) -> @ast::expr;\n+type macro_definer = fn(&ext_ctxt, span, &vec[@ast::expr],\n+                        option::t[str]) -> tup(str, syntax_extension);\n \n+tag syntax_extension {\n+    normal(syntax_expander);\n+    macro_defining(macro_definer);\n+}\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n     auto syntax_expanders = new_str_hash[syntax_extension]();\n-    syntax_expanders.insert(\"fmt\", x(extfmt::expand_syntax_ext));\n-    syntax_expanders.insert(\"env\", x(extenv::expand_syntax_ext));\n+    syntax_expanders.insert(\"fmt\", normal(extfmt::expand_syntax_ext));\n+    syntax_expanders.insert(\"env\", normal(extenv::expand_syntax_ext));\n+    syntax_expanders.insert(\"simplext\",    \n+                            macro_defining(extsimplext::add_new_extension));\n     ret syntax_expanders;\n }\n \n@@ -51,6 +55,37 @@ fn mk_ctxt(parser parser) -> ext_ctxt {\n             span_unimpl=ext_span_unimpl,\n             next_id=ext_next_id);\n }\n+\n+fn expr_to_str(&ext_ctxt cx, @ast::expr expr, str error) -> str {\n+    alt (expr.node) {\n+        case (ast::expr_lit(?l)) {\n+            alt (l.node) {\n+                case (ast::lit_str(?s, _)) { ret s; }\n+                case (_) { cx.span_fatal(l.span, error); }\n+            }\n+        }\n+        case (_) { cx.span_fatal(expr.span, error); }\n+    }\n+}\n+\n+fn expr_to_ident(&ext_ctxt cx, @ast::expr expr, str error) -> ast::ident {\n+    alt(expr.node) {\n+        case (ast::expr_path(?p)) {\n+            if (vec::len(p.node.types) > 0u \n+                || vec::len(p.node.idents) != 1u) {\n+                cx.span_fatal(expr.span, error);\n+            } else {\n+                ret p.node.idents.(0);\n+            }\n+        }\n+        case (_) {\n+            cx.span_fatal(expr.span, error);\n+        }\n+    }\n+}\n+\n+\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "acfb93e1cdce2d77a63dede522d8995da09100e8", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -21,27 +21,13 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t[str] rather than just an maybe-empty string.\n \n-    auto var = expr_to_str(cx, args.(0));\n+    auto var = expr_to_str(cx, args.(0), \"#env requires a string\");\n     alt (generic_os::getenv(var)) {\n         case (option::none) { ret make_new_str(cx, sp, \"\"); }\n         case (option::some(?s)) { ret make_new_str(cx, sp, s); }\n     }\n }\n \n-\n-// FIXME: duplicate code copied from extfmt:\n-fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n-    alt (expr.node) {\n-        case (ast::expr_lit(?l)) {\n-            alt (l.node) {\n-                case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_fatal(l.span, \"malformed #env call\"); }\n-            }\n-        }\n-        case (_) { cx.span_fatal(expr.span, \"malformed #env call\"); }\n-    }\n-}\n-\n fn make_new_lit(&ext_ctxt cx, common::span sp, ast::lit_ lit) -> @ast::expr {\n     auto sp_lit = @rec(node=lit, span=sp);\n     ret @rec(id=cx.next_id(), node=ast::expr_lit(sp_lit), span=sp);"}, {"sha": "0696e0d2c6975ac05f9ed4e0dd38057ea7e26467", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -20,7 +20,8 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n     if (vec::len[@ast::expr](args) == 0u) {\n         cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n-    auto fmt = expr_to_str(cx, args.(0));\n+    auto fmt = expr_to_str(cx, args.(0), \"first argument to #fmt must be a \"\n+                           + \"string literal.\");\n     auto fmtspan = args.(0).span;\n     log \"Format string:\";\n     log fmt;\n@@ -32,20 +33,6 @@ fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n     ret pieces_to_expr(cx, sp, pieces, args);\n }\n \n-fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n-    auto err_msg = \"first argument to #fmt must be a string literal\";\n-    alt (expr.node) {\n-        case (ast::expr_lit(?l)) {\n-            alt (l.node) {\n-                case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_fatal(l.span, err_msg); }\n-            }\n-        }\n-        case (_) { cx.span_fatal(expr.span, err_msg); }\n-    }\n-}\n-\n-\n // FIXME: A lot of these functions for producing expressions can probably\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions"}, {"sha": "3de737f0d53f410527abccc8aa73b85f3b5836dc", "filename": "src/comp/front/extsimplext.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fextsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextsimplext.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,144 @@\n+use std;\n+\n+import util::common::span;\n+import std::vec;\n+import std::option;\n+import vec::map;\n+import vec::len;\n+import option::some;\n+import option::none;\n+\n+import ext::syntax_extension;\n+import ext::ext_ctxt;\n+import ext::normal;\n+import ext::expr_to_str;\n+import ext::expr_to_ident;\n+\n+import fold::*;\n+import ast::ident;\n+import ast::path_;\n+import ast::expr_path;\n+\n+export add_new_extension;\n+\n+\n+//temporary, until 'position' shows up in the snapshot\n+fn position[T](&T x, &vec[T] v) -> option::t[uint] {\n+    let uint i = 0u;\n+    while (i < len(v)) {\n+        if (x == v.(i)) { ret some[uint](i); }\n+        i += 1u;\n+    }\n+    ret none[uint];\n+}\n+\n+// substitute, in a position that's required to be an ident\n+fn subst_ident(&ext_ctxt cx, &vec[@ast::expr] args, \n+               @vec[ident] param_names, &ident i, ast_fold fld) -> ident {\n+    alt (position(i, *param_names)) {\n+        case (some[uint](?idx)) {\n+            ret expr_to_ident(cx, args.(idx), \n+                              \"This argument is expanded as an \"\n+                              + \"identifier; it must be one.\");\n+        }\n+        case (none[uint]) {\n+            ret i;\n+        }\n+    }\n+}\n+\n+fn subst_path(&ext_ctxt cx, &vec[@ast::expr] args, \n+              @vec[ident] param_names, &path_ p, ast_fold fld) -> path_ {\n+    // Don't substitute into qualified names.\n+    if (len(p.types) > 0u || len(p.idents) != 1u) { ret p; }\n+    alt (position(p.idents.(0), *param_names)) {\n+        case (some[uint](?idx)) {\n+            alt (args.(idx).node) {\n+                case (expr_path(?new_path)) {\n+                    ret new_path.node;\n+                }\n+                case (_) {\n+                    cx.span_fatal(args.(idx).span,\n+                                \"This argument is expanded as a path; \"\n+                                + \"it must be one.\");\n+                }\n+            }\n+        }\n+        case (none[uint]) { ret p; }\n+    }\n+}\n+\n+\n+fn subst_expr(&ext_ctxt cx, &vec[@ast::expr] args, @vec[ident] param_names, \n+              &ast::expr_ e, ast_fold fld, \n+              fn(&ast::expr_, ast_fold) -> ast::expr_ orig) -> ast::expr_ {\n+    ret alt(e) {\n+        case (expr_path(?p)){\n+            // Don't substitute into qualified names.\n+            if (len(p.node.types) > 0u || len(p.node.idents) != 1u) { e }\n+            alt (position(p.node.idents.(0), *param_names)) {\n+                case (some[uint](?idx)) {\n+                    args.(idx).node\n+                }\n+                case (none[uint]) { e }\n+            }\n+        }\n+        case (_) { orig(e,fld) }\n+    }\n+}\n+\n+\n+fn add_new_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+                     option::t[str] body) -> tup(str, syntax_extension) {\n+    if (len(args) < 2u) {\n+        cx.span_fatal(sp, \"malformed extension description\");\n+    }\n+\n+    fn generic_extension(&ext_ctxt cx, span sp, &vec[@ast::expr] args,\n+                         option::t[str] body, @vec[ident] param_names,\n+                         @ast::expr dest_form) -> @ast::expr {\n+        if (len(args) != len(*param_names)) {\n+            cx.span_fatal(sp, #fmt(\"extension expects %u arguments, got %u\",\n+                                 len(*param_names), len(args)));\n+        }\n+\n+        auto afp = default_ast_fold();\n+        auto f_pre = \n+            rec(fold_ident = bind subst_ident(cx, args, param_names, _, _),\n+                fold_path = bind subst_path(cx, args, param_names, _, _),\n+                fold_expr = bind subst_expr(cx, args, param_names, _, _,\n+                                            afp.fold_expr)\n+                with *afp);\n+        auto f = make_fold(f_pre);\n+        auto result = f.fold_expr(dest_form);\n+        dummy_out(f); //temporary: kill circular reference\n+        ret result;\n+        \n+    }\n+\n+    let vec[ident] param_names = vec::empty[ident]();\n+    let uint idx = 1u;\n+    while(1u+idx < len(args)) {\n+        param_names +=\n+            [expr_to_ident(cx, args.(idx),\n+                           \"this parameter name must be an identifier.\")];\n+        idx += 1u;\n+    }\n+\n+    ret tup(expr_to_str(cx, args.(0), \"first arg must be a literal string.\"),\n+            normal(bind generic_extension(_,_,_,_,@param_names,\n+                                          args.(len(args)-1u))));\n+}\n+\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "c70dd354d088245df9049401c97ff842a6f45a15", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -963,10 +963,19 @@ fn expand_syntax_ext(&parser p, common::span sp, &ast::path path,\n     auto extname = path.node.idents.(0);\n     alt (p.get_syntax_expanders().find(extname)) {\n         case (none) { p.fatal(\"unknown syntax expander: '\" + extname + \"'\"); }\n-        case (some(ext::x(?ext))) {\n+        case (some(ext::normal(?ext))) {\n             auto ext_cx = ext::mk_ctxt(p);\n             ret ast::expr_ext(path, args, body, ext(ext_cx, sp, args, body));\n         }\n+        // because we have expansion inside parsing, new macros are only\n+        // visible further down the file\n+        case (some(ext::macro_defining(?ext))) {\n+            auto ext_cx = ext::mk_ctxt(p);\n+            auto name_and_extension = ext(ext_cx, sp, args, body);\n+            p.get_syntax_expanders().insert(name_and_extension._0,\n+                                            name_and_extension._1);\n+            ret ast::expr_tup(vec::empty[ast::elt]());\n+        }\n     }\n }\n "}, {"sha": "9b94be9f7d4bef990db752c2a55701690fc9d46a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -597,8 +597,6 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n    option::t[def] {\n     fn in_scope(&env e, &span sp, &ident name, &scope s, namespace ns) ->\n        option::t[def] {\n-        //not recursing through globs\n-\n         alt (s) {\n             case (scope_crate(?c)) {\n                 ret lookup_in_local_mod(e, -1, sp, name, ns, inside);"}, {"sha": "ac64e7068f2e54dc64f7bc768fb89a31202cb982", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -48,6 +48,7 @@ mod front {\n     mod ext;\n     mod extfmt;\n     mod extenv;\n+    mod extsimplext;\n     mod fold;\n     mod codemap;\n     mod lexer;"}, {"sha": "db57953a962c2e5e0f2986cecf5f88d4560d87ac", "filename": "src/lib/vec.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -228,6 +228,24 @@ fn find[T](fn(&T) -> bool  f, &vec[T] v) -> option::t[T] {\n     ret none[T];\n }\n \n+fn position[T](&T x, &array[T] v) -> option::t[uint] {\n+    let uint i = 0u;\n+    while (i < len(v)) {\n+        if (x == v.(i)) { ret some[uint](i); }\n+        i += 1u;\n+    }\n+    ret none[uint];\n+}\n+\n+fn position_pred[T](fn (&T) -> bool f, &vec[T] v) -> option::t[uint] {\n+    let uint i = 0u;\n+    while (i < len(v)) {\n+        if (f(v.(i))) { ret some[uint](i); }\n+        i += 1u;\n+    }\n+    ret none[uint];\n+}\n+\n fn member[T](&T x, &array[T] v) -> bool {\n     for (T elt in v) { if (x == elt) { ret true; } }\n     ret false;"}, {"sha": "7c082b42320f380a071e1e7ec5b7c1f6e3ba7e52", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:malformed #env call\n+// error-pattern:requires a string\n \n fn main() {\n   #env(10);"}, {"sha": "f833d87c8a0dc80dc84d76de613ddec080aa6f8b", "filename": "src/test/compile-fail/simplext-2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fsimplext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fsimplext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimplext-2.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,6 @@\n+//error-pattern:expanded as an identifier\n+fn main() {\n+  #simplext(\"mylambda\", x, body, {fn f(int x) -> int {ret body}; f});\n+  \n+  assert(#mylambda(y*1, y*2)(8) == 16);\n+}\n\\ No newline at end of file"}, {"sha": "953f97d0581f7cae1712817edf523639a47cf0a4", "filename": "src/test/compile-fail/simplext.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Fcompile-fail%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimplext.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,7 @@\n+//error-pattern:expects 0 arguments, got 16\n+\n+fn main() {\n+  #simplext(\"trivial\", 1*2*4*2*1);\n+  \n+  assert(#trivial(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16) == 16);\n+}"}, {"sha": "24adaaa5972ea7b2f4173c6c8f3d03b80f77d80e", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 42, "deletions": 17, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -1,9 +1,12 @@\n \n use std;\n \n+import std::vec::*;\n+import std::option;\n+\n fn test_init_elt() {\n-    let vec[uint] v = std::vec::init_elt[uint](5u, 3u);\n-    assert (std::vec::len[uint](v) == 3u);\n+    let vec[uint] v = init_elt[uint](5u, 3u);\n+    assert (len[uint](v) == 3u);\n     assert (v.(0) == 5u);\n     assert (v.(1) == 5u);\n     assert (v.(2) == 5u);\n@@ -13,8 +16,8 @@ fn id(uint x) -> uint { ret x; }\n \n fn test_init_fn() {\n     let fn(uint) -> uint  op = id;\n-    let vec[uint] v = std::vec::init_fn[uint](op, 5u);\n-    assert (std::vec::len[uint](v) == 5u);\n+    let vec[uint] v = init_fn[uint](op, 5u);\n+    assert (len[uint](v) == 5u);\n     assert (v.(0) == 0u);\n     assert (v.(1) == 1u);\n     assert (v.(2) == 2u);\n@@ -24,17 +27,17 @@ fn test_init_fn() {\n \n fn test_slice() {\n     let vec[int] v = [1, 2, 3, 4, 5];\n-    auto v2 = std::vec::slice[int](v, 2u, 4u);\n-    assert (std::vec::len[int](v2) == 2u);\n+    auto v2 = slice[int](v, 2u, 4u);\n+    assert (len[int](v2) == 2u);\n     assert (v2.(0) == 3);\n     assert (v2.(1) == 4);\n }\n \n fn test_map() {\n     fn square(&int x) -> int { ret x * x; }\n-    let std::option::operator[int, int] op = square;\n+    let option::operator[int, int] op = square;\n     let vec[int] v = [1, 2, 3, 4, 5];\n-    let vec[int] s = std::vec::map[int, int](op, v);\n+    let vec[int] s = map[int, int](op, v);\n     let int i = 0;\n     while (i < 5) { assert (v.(i) * v.(i) == s.(i)); i += 1; }\n }\n@@ -44,28 +47,48 @@ fn test_map2() {\n     auto f = times;\n     auto v0 = [1, 2, 3, 4, 5];\n     auto v1 = [5, 4, 3, 2, 1];\n-    auto u = std::vec::map2[int, int, int](f, v0, v1);\n+    auto u = map2[int, int, int](f, v0, v1);\n     auto i = 0;\n     while (i < 5) { assert (v0.(i) * v1.(i) == u.(i)); i += 1; }\n }\n \n fn test_filter_map() {\n-    fn halve(&int i) -> std::option::t[int] {\n+    fn halve(&int i) -> option::t[int] {\n         if (i % 2 == 0) {\n-            ret std::option::some[int](i / 2);\n-        } else { ret std::option::none[int]; }\n+            ret option::some[int](i / 2);\n+        } else { ret option::none[int]; }\n     }\n     fn halve_for_sure(&int i) -> int { ret i / 2; }\n     let vec[int] all_even = [0, 2, 8, 6];\n     let vec[int] all_odd1 = [1, 7, 3];\n     let vec[int] all_odd2 = [];\n     let vec[int] mix = [9, 2, 6, 7, 1, 0, 0, 3];\n     let vec[int] mix_dest = [1, 3, 0, 0];\n-    assert (std::vec::filter_map(halve, all_even) ==\n-                std::vec::map(halve_for_sure, all_even));\n-    assert (std::vec::filter_map(halve, all_odd1) == std::vec::empty[int]());\n-    assert (std::vec::filter_map(halve, all_odd2) == std::vec::empty[int]());\n-    assert (std::vec::filter_map(halve, mix) == mix_dest);\n+    assert (filter_map(halve, all_even) ==\n+                map(halve_for_sure, all_even));\n+    assert (filter_map(halve, all_odd1) == empty[int]());\n+    assert (filter_map(halve, all_odd2) == empty[int]());\n+    assert (filter_map(halve, mix) == mix_dest);\n+}\n+\n+fn test_position() {\n+  let vec[int] v1 = [1, 2, 3, 3, 2, 5];\n+  assert (position(1, v1) == option::some[uint](0u));\n+  assert (position(2, v1) == option::some[uint](1u));\n+  assert (position(5, v1) == option::some[uint](5u));\n+  assert (position(4, v1) == option::none[uint]);\n+}\n+\n+fn test_position_pred() {\n+  fn less_than_three(&int i) -> bool {\n+    ret i <3;\n+  }\n+  fn is_eighteen(&int i) -> bool {\n+    ret i == 18;\n+  }\n+  let vec[int] v1 = [5, 4, 3, 2, 1];\n+  assert (position_pred(less_than_three, v1) == option::some[uint](3u));\n+  assert (position_pred(is_eighteen, v1) == option::none[uint]);\n }\n \n fn main() {\n@@ -75,4 +98,6 @@ fn main() {\n     test_map();\n     test_map2();\n     test_filter_map();\n+    test_position();\n+    test_position_pred();\n }\n\\ No newline at end of file"}, {"sha": "c15d63e2e883d3cdf6e6f60aea553bdad0a1192e", "filename": "src/test/run-pass/simplext-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimplext-2.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+  #simplext(\"mylambda\", x, body, {fn f(int x) -> int {ret body}; f});\n+  \n+  assert(#mylambda(y,y*2)(8) == 16);\n+}\n\\ No newline at end of file"}, {"sha": "ad1b10a00520a9c4bca04d47e771e7a481f488b5", "filename": "src/test/run-pass/simplext-3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimplext-3.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+  #simplext(\"trivial\", 1*2*4*2*1);\n+  \n+  assert(#trivial() == 16);\n+}"}, {"sha": "9ca42e8c8feed010b90db4d5c84a27e7f4223bc8", "filename": "src/test/run-pass/simplext.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3901cdf8e1723dc07b5bfa202fe31b573d44561/src%2Ftest%2Frun-pass%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimplext.rs?ref=c3901cdf8e1723dc07b5bfa202fe31b573d44561", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+  #simplext(\"m1\", a, a*4);\n+  assert (#m1(2) == 8);  \n+}\n\\ No newline at end of file"}]}