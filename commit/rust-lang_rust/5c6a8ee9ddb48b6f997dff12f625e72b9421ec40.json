{"sha": "5c6a8ee9ddb48b6f997dff12f625e72b9421ec40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNmE4ZWU5ZGRiNDhiNmY5OTdkZmYxMmY2MjVlNzJiOTQyMWVjNDA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T07:55:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-01T07:55:38Z"}, "message": "Rollup merge of #64935 - AnthonyMikh:librustc_errors/emmiter__code-clarity, r=estebank\n\nImprove code clarity\n\nNo commit except 55b54285c811b6ab12bb0ba001126fd5b7d3bd09 address performance, just making the existing code more clear.\n\nr? @estebank", "tree": {"sha": "1710e0ac44e0ed4ec9896739b2ba8b3376a0913d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1710e0ac44e0ed4ec9896739b2ba8b3376a0913d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdkwZ6CRBK7hj4Ov3rIwAAdHIIAKE1+Q7hiGJv0lSI8fifM1AU\nqAyu5JiJTUTd1C94grH2UiztcYqkrDUlRih7IdqrOT6qc3Ryy6K6ib/BGTJ5H2K/\nGNLMOVUaoYxeZHDl6fdRMPxzntqlw0Xo/dr4P76feLcWMkhW+0capz4pfOHODbdI\nYy99SBOD/4mVqgTh/wIT4WrolmLuBmvsT9A0zGxU9fFlfWVypm4QQ9mxhhnbiEL5\nFNMQsIMJfduE4VHWTz0V7pw2nkl1C32cdqgTrYADSEUBuNz8u84Ed6LGjlVacxmL\nVBin0DBCrIZ4q/H3eYWMqePuLt8qB/k/DGUhb85Ti9ESe2yos9Hj85+O4NIxMv8=\n=2fk4\n-----END PGP SIGNATURE-----\n", "payload": "tree 1710e0ac44e0ed4ec9896739b2ba8b3376a0913d\nparent f4aa29fb1e5536b675895f5a3bd6ce595af91f75\nparent 50c2a58d086ec9124a6749eb75afc35c0bc1652f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569916538 +0200\ncommitter GitHub <noreply@github.com> 1569916538 +0200\n\nRollup merge of #64935 - AnthonyMikh:librustc_errors/emmiter__code-clarity, r=estebank\n\nImprove code clarity\n\nNo commit except 55b54285c811b6ab12bb0ba001126fd5b7d3bd09 address performance, just making the existing code more clear.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40", "html_url": "https://github.com/rust-lang/rust/commit/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4aa29fb1e5536b675895f5a3bd6ce595af91f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4aa29fb1e5536b675895f5a3bd6ce595af91f75", "html_url": "https://github.com/rust-lang/rust/commit/f4aa29fb1e5536b675895f5a3bd6ce595af91f75"}, {"sha": "50c2a58d086ec9124a6749eb75afc35c0bc1652f", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c2a58d086ec9124a6749eb75afc35c0bc1652f", "html_url": "https://github.com/rust-lang/rust/commit/50c2a58d086ec9124a6749eb75afc35c0bc1652f"}], "stats": {"total": 512, "additions": 239, "deletions": 273}, "files": [{"sha": "0c7aa3582ac23f096736eaab789326fb92b19c9a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 239, "deletions": 273, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c6a8ee9ddb48b6f997dff12f625e72b9421ec40/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=5c6a8ee9ddb48b6f997dff12f625e72b9421ec40", "patch": "@@ -99,8 +99,8 @@ impl Margin {\n         // ```\n \n         let mut m = Margin {\n-            whitespace_left: if whitespace_left >= 6 { whitespace_left - 6 } else { 0 },\n-            span_left: if span_left >= 6 { span_left - 6 } else { 0 },\n+            whitespace_left: whitespace_left.saturating_sub(6),\n+            span_left: span_left.saturating_sub(6),\n             span_right: span_right + 6,\n             computed_left: 0,\n             computed_right: 0,\n@@ -125,7 +125,7 @@ impl Margin {\n         } else {\n             self.computed_right\n         };\n-        right < line_len && line_len > self.computed_left + self.column_width\n+        right < line_len && self.computed_left + self.column_width < line_len\n     }\n \n     fn compute(&mut self, max_line_len: usize) {\n@@ -167,12 +167,10 @@ impl Margin {\n     }\n \n     fn right(&self, line_len: usize) -> usize {\n-        if max(line_len, self.computed_left) - self.computed_left <= self.column_width {\n-            line_len\n-        } else if self.computed_right > line_len {\n+        if line_len.saturating_sub(self.computed_left) <= self.column_width {\n             line_len\n         } else {\n-            self.computed_right\n+            min(line_len, self.computed_right)\n         }\n     }\n }\n@@ -297,81 +295,82 @@ pub trait Emitter {\n                                    source_map: &Option<Lrc<SourceMapperDyn>>,\n                                    span: &mut MultiSpan,\n                                    always_backtrace: bool) -> bool {\n-        let mut spans_updated = false;\n+        let sm = match source_map {\n+            Some(ref sm) => sm,\n+            None => return false,\n+        };\n \n-        if let Some(ref sm) = source_map {\n-            let mut before_after: Vec<(Span, Span)> = vec![];\n-            let mut new_labels: Vec<(Span, String)> = vec![];\n+        let mut before_after: Vec<(Span, Span)> = vec![];\n+        let mut new_labels: Vec<(Span, String)> = vec![];\n \n-            // First, find all the spans in <*macros> and point instead at their use site\n-            for sp in span.primary_spans() {\n-                if sp.is_dummy() {\n+        // First, find all the spans in <*macros> and point instead at their use site\n+        for sp in span.primary_spans() {\n+            if sp.is_dummy() {\n+                continue;\n+            }\n+            let call_sp = sm.call_span_if_macro(*sp);\n+            if call_sp != *sp && !always_backtrace {\n+                before_after.push((*sp, call_sp));\n+            }\n+            let backtrace_len = sp.macro_backtrace().len();\n+            for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n+                // Only show macro locations that are local\n+                // and display them like a span_note\n+                if trace.def_site_span.is_dummy() {\n                     continue;\n                 }\n-                let call_sp = sm.call_span_if_macro(*sp);\n-                if call_sp != *sp && !always_backtrace {\n-                    before_after.push((*sp, call_sp));\n+                if always_backtrace {\n+                    new_labels.push((trace.def_site_span,\n+                                        format!(\"in this expansion of `{}`{}\",\n+                                                trace.macro_decl_name,\n+                                                if backtrace_len > 2 {\n+                                                    // if backtrace_len == 1 it'll be pointed\n+                                                    // at by \"in this macro invocation\"\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n                 }\n-                let backtrace_len = sp.macro_backtrace().len();\n-                for (i, trace) in sp.macro_backtrace().iter().rev().enumerate() {\n-                    // Only show macro locations that are local\n-                    // and display them like a span_note\n-                    if trace.def_site_span.is_dummy() {\n-                        continue;\n-                    }\n-                    if always_backtrace {\n-                        new_labels.push((trace.def_site_span,\n-                                            format!(\"in this expansion of `{}`{}\",\n-                                                    trace.macro_decl_name,\n-                                                    if backtrace_len > 2 {\n-                                                        // if backtrace_len == 1 it'll be pointed\n-                                                        // at by \"in this macro invocation\"\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                    }\n-                    // Check to make sure we're not in any <*macros>\n-                    if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n-                        !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n-                        !trace.macro_decl_name.starts_with(\"#[\") ||\n-                        always_backtrace {\n-                        new_labels.push((trace.call_site,\n-                                            format!(\"in this macro invocation{}\",\n-                                                    if backtrace_len > 2 && always_backtrace {\n-                                                        // only specify order when the macro\n-                                                        // backtrace is multiple levels deep\n-                                                        format!(\" (#{})\", i + 1)\n-                                                    } else {\n-                                                        String::new()\n-                                                    })));\n-                        if !always_backtrace {\n-                            break;\n-                        }\n+                // Check to make sure we're not in any <*macros>\n+                if !sm.span_to_filename(trace.def_site_span).is_macros() &&\n+                    !trace.macro_decl_name.starts_with(\"desugaring of \") &&\n+                    !trace.macro_decl_name.starts_with(\"#[\") ||\n+                    always_backtrace {\n+                    new_labels.push((trace.call_site,\n+                                        format!(\"in this macro invocation{}\",\n+                                                if backtrace_len > 2 && always_backtrace {\n+                                                    // only specify order when the macro\n+                                                    // backtrace is multiple levels deep\n+                                                    format!(\" (#{})\", i + 1)\n+                                                } else {\n+                                                    String::new()\n+                                                })));\n+                    if !always_backtrace {\n+                        break;\n                     }\n                 }\n             }\n-            for (label_span, label_text) in new_labels {\n-                span.push_span_label(label_span, label_text);\n+        }\n+        for (label_span, label_text) in new_labels {\n+            span.push_span_label(label_span, label_text);\n+        }\n+        for sp_label in span.span_labels() {\n+            if sp_label.span.is_dummy() {\n+                continue;\n             }\n-            for sp_label in span.span_labels() {\n-                if sp_label.span.is_dummy() {\n-                    continue;\n-                }\n-                if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n-                    !always_backtrace\n-                {\n-                    let v = sp_label.span.macro_backtrace();\n-                    if let Some(use_site) = v.last() {\n-                        before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n-                    }\n+            if sm.span_to_filename(sp_label.span.clone()).is_macros() &&\n+                !always_backtrace\n+            {\n+                let v = sp_label.span.macro_backtrace();\n+                if let Some(use_site) = v.last() {\n+                    before_after.push((sp_label.span.clone(), use_site.call_site.clone()));\n                 }\n             }\n-            // After we have them, make sure we replace these 'bad' def sites with their use sites\n-            for (before, after) in before_after {\n-                span.replace(before, after);\n-                spans_updated = true;\n-            }\n+        }\n+        // After we have them, make sure we replace these 'bad' def sites with their use sites\n+        let spans_updated = !before_after.is_empty();\n+        for (before, after) in before_after {\n+            span.replace(before, after);\n         }\n \n         spans_updated\n@@ -593,9 +592,9 @@ impl EmitterWriter {\n \n         let left = margin.left(source_string.len()); // Left trim\n         // Account for unicode characters of width !=0 that were removed.\n-        let left = source_string.chars().take(left).fold(0, |acc, ch| {\n-            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n-        });\n+        let left = source_string.chars().take(left)\n+            .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+            .sum();\n \n         self.draw_line(\n             buffer,\n@@ -623,18 +622,16 @@ impl EmitterWriter {\n         // 3 | |\n         // 4 | | }\n         //   | |_^ test\n-        if line.annotations.len() == 1 {\n-            if let Some(ref ann) = line.annotations.get(0) {\n-                if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                    if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n-                        let style = if ann.is_primary {\n-                            Style::UnderlinePrimary\n-                        } else {\n-                            Style::UnderlineSecondary\n-                        };\n-                        buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n-                        return vec![(depth, style)];\n-                    }\n+        if let [ann] = &line.annotations[..] {\n+            if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n+                if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n+                    let style = if ann.is_primary {\n+                        Style::UnderlinePrimary\n+                    } else {\n+                        Style::UnderlineSecondary\n+                    };\n+                    buffer.putc(line_offset, width_offset + depth - 1, '/', style);\n+                    return vec![(depth, style)];\n                 }\n             }\n         }\n@@ -763,11 +760,7 @@ impl EmitterWriter {\n             annotations_position.push((p, annotation));\n             for (j, next) in annotations.iter().enumerate() {\n                 if j > i  {\n-                    let l = if let Some(ref label) = next.label {\n-                        label.len() + 2\n-                    } else {\n-                        0\n-                    };\n+                    let l = next.label.as_ref().map_or(0, |label| label.len() + 2);\n                     if (overlaps(next, annotation, l) // Do not allow two labels to be in the same\n                                                      // line if they overlap including padding, to\n                                                      // avoid situations like:\n@@ -797,9 +790,7 @@ impl EmitterWriter {\n                     }\n                 }\n             }\n-            if line_len < p {\n-                line_len = p;\n-            }\n+            line_len = max(line_len, p);\n         }\n \n         if line_len != 0 {\n@@ -941,17 +932,9 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, if annotation.end_col + 1 > left {\n-                    annotation.end_col + 1 - left\n-                } else {\n-                    0\n-                })\n+                (pos + 1, (annotation.end_col + 1).saturating_sub(left))\n             } else {\n-                (pos + 2, if annotation.start_col > left {\n-                    annotation.start_col - left\n-                } else {\n-                    0\n-                })\n+                (pos + 2, annotation.start_col.saturating_sub(left))\n             };\n             if let Some(ref label) = annotation.label {\n                 buffer.puts(line_offset + pos, code_offset + col, &label, style);\n@@ -966,9 +949,9 @@ impl EmitterWriter {\n         //   | |  |\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n-        annotations_position.sort_by(|a, b| {\n-            // Decreasing order. When `a` and `b` are the same length, prefer `Primary`.\n-            (a.1.len(), !a.1.is_primary).cmp(&(b.1.len(), !b.1.is_primary)).reverse()\n+        annotations_position.sort_by_key(|(_, ann)| {\n+            // Decreasing order. When annotations share the same length, prefer `Primary`.\n+            (Reverse(ann.len()), ann.is_primary)\n         });\n \n         // Write the underlines.\n@@ -991,11 +974,7 @@ impl EmitterWriter {\n             for p in annotation.start_col..annotation.end_col {\n                 buffer.putc(\n                     line_offset + 1,\n-                    if code_offset + p > left {\n-                        code_offset + p - left\n-                    } else {\n-                        0\n-                    },\n+                    (code_offset + p).saturating_sub(left),\n                     underline,\n                     style,\n                 );\n@@ -1018,40 +997,36 @@ impl EmitterWriter {\n     }\n \n     fn get_multispan_max_line_num(&mut self, msp: &MultiSpan) -> usize {\n+        let sm = match self.sm {\n+            Some(ref sm) => sm,\n+            None => return 0,\n+        };\n+\n         let mut max = 0;\n-        if let Some(ref sm) = self.sm {\n-            for primary_span in msp.primary_spans() {\n-                if !primary_span.is_dummy() {\n-                    let hi = sm.lookup_char_pos(primary_span.hi());\n-                    if hi.line > max {\n-                        max = hi.line;\n-                    }\n-                }\n+        for primary_span in msp.primary_spans() {\n+            if !primary_span.is_dummy() {\n+                let hi = sm.lookup_char_pos(primary_span.hi());\n+                max = (hi.line).max(max);\n             }\n-            if !self.short_message {\n-                for span_label in msp.span_labels() {\n-                    if !span_label.span.is_dummy() {\n-                        let hi = sm.lookup_char_pos(span_label.span.hi());\n-                        if hi.line > max {\n-                            max = hi.line;\n-                        }\n-                    }\n+        }\n+        if !self.short_message {\n+            for span_label in msp.span_labels() {\n+                if !span_label.span.is_dummy() {\n+                    let hi = sm.lookup_char_pos(span_label.span.hi());\n+                    max = (hi.line).max(max);\n                 }\n             }\n         }\n+\n         max\n     }\n \n     fn get_max_line_num(&mut self, span: &MultiSpan, children: &[SubDiagnostic]) -> usize {\n-\n         let primary = self.get_multispan_max_line_num(span);\n-        let mut max = primary;\n-\n-        for sub in children {\n-            let sub_result = self.get_multispan_max_line_num(&sub.span);\n-            max = std::cmp::max(sub_result, max);\n-        }\n-        max\n+        children.iter()\n+            .map(|sub| self.get_multispan_max_line_num(&sub.span))\n+            .max()\n+            .unwrap_or(primary)\n     }\n \n     /// Adds a left margin to every line but the first, given a padding length and the label being\n@@ -1081,14 +1056,12 @@ impl EmitterWriter {\n         //    `max_line_num_len`\n         let padding = \" \".repeat(padding + label.len() + 5);\n \n-        /// Returns `true` if `style`, or the override if present and the style is `NoStyle`.\n-        fn style_or_override(style: Style, override_style: Option<Style>) -> Style {\n-            if let Some(o) = override_style {\n-                if style == Style::NoStyle {\n-                    return o;\n-                }\n+        /// Returns `override` if it is present and `style` is `NoStyle` or `style` otherwise\n+        fn style_or_override(style: Style, override_: Option<Style>) -> Style {\n+            match (style, override_) {\n+                (Style::NoStyle, Some(override_)) => override_,\n+                _ => style,\n             }\n-            style\n         }\n \n         let mut line_number = 0;\n@@ -1324,13 +1297,12 @@ impl EmitterWriter {\n                 for line in &annotated_file.lines {\n                     max_line_len = max(max_line_len, annotated_file.file\n                         .get_line(line.line_index - 1)\n-                        .map(|s| s.len())\n-                        .unwrap_or(0));\n+                        .map_or(0, |s| s.len()));\n                     for ann in &line.annotations {\n                         span_right_margin = max(span_right_margin, ann.start_col);\n                         span_right_margin = max(span_right_margin, ann.end_col);\n                         // FIXME: account for labels not in the same line\n-                        let label_right = ann.label.as_ref().map(|l| l.len() + 1).unwrap_or(0);\n+                        let label_right = ann.label.as_ref().map_or(0, |l| l.len() + 1);\n                         label_right_margin = max(label_right_margin, ann.end_col + label_right);\n                     }\n                 }\n@@ -1459,122 +1431,125 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n-        if let Some(ref sm) = self.sm {\n-            let mut buffer = StyledBuffer::new();\n+        let sm = match self.sm {\n+            Some(ref sm) => sm,\n+            None => return Ok(())\n+        };\n \n-            // Render the suggestion message\n-            let level_str = level.to_string();\n-            if !level_str.is_empty() {\n-                buffer.append(0, &level_str, Style::Level(level.clone()));\n-                buffer.append(0, \": \", Style::HeaderMsg);\n+        let mut buffer = StyledBuffer::new();\n+\n+        // Render the suggestion message\n+        let level_str = level.to_string();\n+        if !level_str.is_empty() {\n+            buffer.append(0, &level_str, Style::Level(level.clone()));\n+            buffer.append(0, \": \", Style::HeaderMsg);\n+        }\n+        self.msg_to_buffer(\n+            &mut buffer,\n+            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+            max_line_num_len,\n+            \"suggestion\",\n+            Some(Style::HeaderMsg),\n+        );\n+\n+        // Render the replacements for each suggestion\n+        let suggestions = suggestion.splice_lines(&**sm);\n+\n+        let mut row_num = 2;\n+        for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+            // Only show underline if the suggestion spans a single line and doesn't cover the\n+            // entirety of the code output. If you have multiple replacements in the same line\n+            // of code, show the underline.\n+            let show_underline = !(parts.len() == 1\n+                && parts[0].snippet.trim() == complete.trim())\n+                && complete.lines().count() == 1;\n+\n+            let lines = sm.span_to_lines(parts[0].span).unwrap();\n+\n+            assert!(!lines.lines.is_empty());\n+\n+            let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n+            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+            let mut line_pos = 0;\n+            let mut lines = complete.lines();\n+            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n+                // Print the span column to avoid confusion\n+                buffer.puts(row_num,\n+                            0,\n+                            &self.maybe_anonymized(line_start + line_pos),\n+                            Style::LineNumber);\n+                // print the suggestion\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                buffer.append(row_num, line, Style::NoStyle);\n+                line_pos += 1;\n+                row_num += 1;\n             }\n-            self.msg_to_buffer(\n-                &mut buffer,\n-                &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                max_line_num_len,\n-                \"suggestion\",\n-                Some(Style::HeaderMsg),\n-            );\n-\n-            // Render the replacements for each suggestion\n-            let suggestions = suggestion.splice_lines(&**sm);\n-\n-            let mut row_num = 2;\n-            for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n-                // Only show underline if the suggestion spans a single line and doesn't cover the\n-                // entirety of the code output. If you have multiple replacements in the same line\n-                // of code, show the underline.\n-                let show_underline = !(parts.len() == 1\n-                    && parts[0].snippet.trim() == complete.trim())\n-                    && complete.lines().count() == 1;\n-\n-                let lines = sm.span_to_lines(parts[0].span).unwrap();\n-\n-                assert!(!lines.lines.is_empty());\n-\n-                let line_start = sm.lookup_char_pos(parts[0].span.lo()).line;\n-                draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n-                let mut line_pos = 0;\n-                let mut lines = complete.lines();\n-                for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                    // Print the span column to avoid confusion\n-                    buffer.puts(row_num,\n-                                0,\n-                                &self.maybe_anonymized(line_start + line_pos),\n-                                Style::LineNumber);\n-                    // print the suggestion\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    buffer.append(row_num, line, Style::NoStyle);\n-                    line_pos += 1;\n-                    row_num += 1;\n-                }\n \n-                // This offset and the ones below need to be signed to account for replacement code\n-                // that is shorter than the original code.\n-                let mut offset: isize = 0;\n-                // Only show an underline in the suggestions if the suggestion is not the\n-                // entirety of the code being shown and the displayed code is not multiline.\n-                if show_underline {\n-                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                    for part in parts {\n-                        let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n-                        let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n-\n-                        // Do not underline the leading...\n-                        let start = part.snippet.len()\n-                            .saturating_sub(part.snippet.trim_start().len());\n-                        // ...or trailing spaces. Account for substitutions containing unicode\n-                        // characters.\n-                        let sub_len = part.snippet.trim().chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1)\n-                        });\n-\n-                        let underline_start = (span_start_pos + start) as isize + offset;\n-                        let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n-                        for p in underline_start..underline_end {\n+            // This offset and the ones below need to be signed to account for replacement code\n+            // that is shorter than the original code.\n+            let mut offset: isize = 0;\n+            // Only show an underline in the suggestions if the suggestion is not the\n+            // entirety of the code being shown and the displayed code is not multiline.\n+            if show_underline {\n+                draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                for part in parts {\n+                    let span_start_pos = sm.lookup_char_pos(part.span.lo()).col_display;\n+                    let span_end_pos = sm.lookup_char_pos(part.span.hi()).col_display;\n+\n+                    // Do not underline the leading...\n+                    let start = part.snippet.len()\n+                        .saturating_sub(part.snippet.trim_start().len());\n+                    // ...or trailing spaces. Account for substitutions containing unicode\n+                    // characters.\n+                    let sub_len: usize = part.snippet.trim().chars()\n+                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum();\n+\n+                    let underline_start = (span_start_pos + start) as isize + offset;\n+                    let underline_end = (span_start_pos + start + sub_len) as isize + offset;\n+                    for p in underline_start..underline_end {\n+                        buffer.putc(row_num,\n+                                    max_line_num_len + 3 + p as usize,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n+                    }\n+                    // underline removals too\n+                    if underline_start == underline_end {\n+                        for p in underline_start-1..underline_start+1 {\n                             buffer.putc(row_num,\n                                         max_line_num_len + 3 + p as usize,\n-                                        '^',\n-                                        Style::UnderlinePrimary);\n+                                        '-',\n+                                        Style::UnderlineSecondary);\n                         }\n-                        // underline removals too\n-                        if underline_start == underline_end {\n-                            for p in underline_start-1..underline_start+1 {\n-                                buffer.putc(row_num,\n-                                            max_line_num_len + 3 + p as usize,\n-                                            '-',\n-                                            Style::UnderlineSecondary);\n-                            }\n-                        }\n-\n-                        // length of the code after substitution\n-                        let full_sub_len = part.snippet.chars().fold(0, |acc, ch| {\n-                            acc + unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1) as isize\n-                        });\n-\n-                        // length of the code to be substituted\n-                        let snippet_len = span_end_pos as isize - span_start_pos as isize;\n-                        // For multiple substitutions, use the position *after* the previous\n-                        // substitutions have happened.\n-                        offset += full_sub_len - snippet_len;\n                     }\n-                    row_num += 1;\n-                }\n \n-                // if we elided some lines, add an ellipsis\n-                if lines.next().is_some() {\n-                    buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n-                } else if !show_underline {\n-                    draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n-                    row_num += 1;\n+                    // length of the code after substitution\n+                    let full_sub_len = part.snippet.chars()\n+                        .map(|ch| unicode_width::UnicodeWidthChar::width(ch).unwrap_or(1))\n+                        .sum::<usize>() as isize;\n+\n+                    // length of the code to be substituted\n+                    let snippet_len = span_end_pos as isize - span_start_pos as isize;\n+                    // For multiple substitutions, use the position *after* the previous\n+                    // substitutions have happened.\n+                    offset += full_sub_len - snippet_len;\n                 }\n+                row_num += 1;\n             }\n-            if suggestions.len() > MAX_SUGGESTIONS {\n-                let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n-                buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+\n+            // if we elided some lines, add an ellipsis\n+            if lines.next().is_some() {\n+                buffer.puts(row_num, max_line_num_len - 1, \"...\", Style::LineNumber);\n+            } else if !show_underline {\n+                draw_col_separator_no_space(&mut buffer, row_num, max_line_num_len + 1);\n+                row_num += 1;\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         }\n+        if suggestions.len() > MAX_SUGGESTIONS {\n+            let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n+            buffer.puts(row_num, 0, &msg, Style::NoStyle);\n+        }\n+        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         Ok(())\n     }\n \n@@ -1732,42 +1707,35 @@ impl FileWithAnnotatedLines {\n                     hi.col_display += 1;\n                 }\n \n-                let ann_type = if lo.line != hi.line {\n+                if lo.line != hi.line {\n                     let ml = MultilineAnnotation {\n                         depth: 1,\n                         line_start: lo.line,\n                         line_end: hi.line,\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label.clone(),\n+                        label: span_label.label,\n                         overlaps_exactly: false,\n                     };\n-                    multiline_annotations.push((lo.file.clone(), ml.clone()));\n-                    AnnotationType::Multiline(ml)\n+                    multiline_annotations.push((lo.file, ml));\n                 } else {\n-                    AnnotationType::Singleline\n-                };\n-                let ann = Annotation {\n-                    start_col: lo.col_display,\n-                    end_col: hi.col_display,\n-                    is_primary: span_label.is_primary,\n-                    label: span_label.label.clone(),\n-                    annotation_type: ann_type,\n-                };\n-\n-                if !ann.is_multiline() {\n+                    let ann = Annotation {\n+                        start_col: lo.col_display,\n+                        end_col: hi.col_display,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label,\n+                        annotation_type: AnnotationType::Singleline,\n+                    };\n                     add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                }\n+                };\n             }\n         }\n \n         // Find overlapping multiline annotations, put them at different depths\n         multiline_annotations.sort_by_key(|&(_, ref ml)| (ml.line_start, ml.line_end));\n-        for item in multiline_annotations.clone() {\n-            let ann = item.1;\n-            for item in multiline_annotations.iter_mut() {\n-                let ref mut a = item.1;\n+        for (_, ann) in multiline_annotations.clone() {\n+            for (_, a) in multiline_annotations.iter_mut() {\n                 // Move all other multiline annotations overlapping with this one\n                 // one level to the right.\n                 if !(ann.same_span(a)) &&\n@@ -1784,9 +1752,7 @@ impl FileWithAnnotatedLines {\n \n         let mut max_depth = 0;  // max overlapping multiline spans\n         for (file, ann) in multiline_annotations {\n-            if ann.depth > max_depth {\n-                max_depth = ann.depth;\n-            }\n+            max_depth = max(max_depth, ann.depth);\n             let mut end_ann = ann.as_end();\n             if !ann.overlaps_exactly {\n                 // avoid output like"}]}