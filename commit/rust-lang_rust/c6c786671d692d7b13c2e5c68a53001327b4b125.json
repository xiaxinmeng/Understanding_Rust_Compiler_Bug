{"sha": "c6c786671d692d7b13c2e5c68a53001327b4b125", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2Yzc4NjY3MWQ2OTJkN2IxM2MyZTVjNjhhNTMwMDEzMjdiNGIxMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T00:50:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-04T00:50:59Z"}, "message": "auto merge of #20490 : japaric/rust/assoc-types, r=aturon\n\ncloses #20486 \r\ncloses #20474 \r\ncloses #20441\r\n\r\n[breaking-change]\r\n\r\nThe `Index[Mut]` traits now have one less input parameter, as the return type of the indexing operation is an associated type. This breaks all existing implementations.\r\n\r\n---\r\n\r\nbinop traits (`Add`, `Sub`, etc) now have an associated type for their return type. Also, the RHS input parameter now defaults to `Self` (except for the `Shl` and `Shr` traits). For example, the `Add` trait now looks like this:\r\n\r\n``` rust\r\ntrait Add<Rhs=Self> {\r\n    type Output;\r\n\r\n    fn add(self, Rhs) -> Self::Output;\r\n}\r\n```\r\n\r\nThe `Neg` and `Not` traits now also have an associated type for their return type.\r\n\r\nThis breaks all existing implementations of these traits.\r\n\r\n---\r\nAffected traits:\r\n\r\n- `Iterator { type Item }`\r\n- `IteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `DoubleEndedIteratorExt` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n- `RandomAccessIterator` no input/output types\r\n- `ExactSizeIterator` no input/output types, uses `<Self as Iterator>::Item` in its methods\r\n\r\nThis breaks all the implementations of these traits.", "tree": {"sha": "540a25d1333da9581000eb20a54664ecdb3f0bcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/540a25d1333da9581000eb20a54664ecdb3f0bcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6c786671d692d7b13c2e5c68a53001327b4b125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6c786671d692d7b13c2e5c68a53001327b4b125", "html_url": "https://github.com/rust-lang/rust/commit/c6c786671d692d7b13c2e5c68a53001327b4b125", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6c786671d692d7b13c2e5c68a53001327b4b125/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "496dc4eae7de9d14cd49511a9acfbf5f11ae6c3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/496dc4eae7de9d14cd49511a9acfbf5f11ae6c3f", "html_url": "https://github.com/rust-lang/rust/commit/496dc4eae7de9d14cd49511a9acfbf5f11ae6c3f"}, {"sha": "ce8f748b4cd64317c33d64ccf3a6127931980d90", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8f748b4cd64317c33d64ccf3a6127931980d90", "html_url": "https://github.com/rust-lang/rust/commit/ce8f748b4cd64317c33d64ccf3a6127931980d90"}], "stats": {"total": 2614, "additions": 1788, "deletions": 826}, "files": [{"sha": "da461ae2d4d53273a75cc4272f6bb50ea8fcae8e", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -573,7 +573,9 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n \n@@ -582,21 +584,23 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n \n #[stable]\n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n /// An iterator that moves out of a `BinaryHeap`.\n pub struct IntoIter<T> {\n     iter: vec::IntoIter<T>,\n }\n \n #[stable]\n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n@@ -605,21 +609,23 @@ impl<T> Iterator<T> for IntoIter<T> {\n }\n \n #[stable]\n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n #[stable]\n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n #[stable]\n-impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+impl<'a, T: 'a> Iterator for Drain<'a, T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n \n@@ -628,24 +634,24 @@ impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n \n #[stable]\n-impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable]\n impl<T: Ord> FromIterator<T> for BinaryHeap<T> {\n-    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BinaryHeap<T> {\n+    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BinaryHeap<T> {\n         BinaryHeap::from_vec(iter.collect())\n     }\n }\n \n #[stable]\n impl<T: Ord> Extend<T> for BinaryHeap<T> {\n-    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         let (lower, _) = iter.size_hint();\n \n         self.reserve(lower);"}, {"sha": "9674885c857c41c74d812f328fa197e152e2fc66", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -164,6 +164,8 @@ pub struct Bitv {\n     nbits: uint\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n // FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n impl Index<uint,bool> for Bitv {\n     #[inline]\n@@ -176,6 +178,21 @@ impl Index<uint,bool> for Bitv {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+// FIXME(Gankro): NopeNopeNopeNopeNope (wait for IndexGet to be a thing)\n+impl Index<uint> for Bitv {\n+    type Output = bool;\n+\n+    #[inline]\n+    fn index(&self, i: &uint) -> &bool {\n+        if self.get(*i).expect(\"index out of bounds\") {\n+            &TRUE\n+        } else {\n+            &FALSE\n+        }\n+    }\n+}\n+\n /// Computes how many blocks are needed to store that many bits\n fn blocks_for_bits(bits: uint) -> uint {\n     // If we want 17 bits, dividing by 32 will produce 0. So we add 1 to make sure we\n@@ -938,7 +955,7 @@ impl Default for Bitv {\n \n #[stable]\n impl FromIterator<bool> for Bitv {\n-    fn from_iter<I:Iterator<bool>>(iterator: I) -> Bitv {\n+    fn from_iter<I:Iterator<Item=bool>>(iterator: I) -> Bitv {\n         let mut ret = Bitv::new();\n         ret.extend(iterator);\n         ret\n@@ -948,7 +965,7 @@ impl FromIterator<bool> for Bitv {\n #[stable]\n impl Extend<bool> for Bitv {\n     #[inline]\n-    fn extend<I: Iterator<bool>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=bool>>(&mut self, mut iterator: I) {\n         let (min, _) = iterator.size_hint();\n         self.reserve(min);\n         for element in iterator {\n@@ -1031,7 +1048,9 @@ pub struct Iter<'a> {\n }\n \n #[stable]\n-impl<'a> Iterator<bool> for Iter<'a> {\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = bool;\n+\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -1050,7 +1069,7 @@ impl<'a> Iterator<bool> for Iter<'a> {\n }\n \n #[stable]\n-impl<'a> DoubleEndedIterator<bool> for Iter<'a> {\n+impl<'a> DoubleEndedIterator for Iter<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -1063,10 +1082,10 @@ impl<'a> DoubleEndedIterator<bool> for Iter<'a> {\n }\n \n #[stable]\n-impl<'a> ExactSizeIterator<bool> for Iter<'a> {}\n+impl<'a> ExactSizeIterator for Iter<'a> {}\n \n #[stable]\n-impl<'a> RandomAccessIterator<bool> for Iter<'a> {\n+impl<'a> RandomAccessIterator for Iter<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.end_idx - self.next_idx\n@@ -1134,7 +1153,7 @@ impl Default for BitvSet {\n \n #[stable]\n impl FromIterator<uint> for BitvSet {\n-    fn from_iter<I:Iterator<uint>>(iterator: I) -> BitvSet {\n+    fn from_iter<I:Iterator<Item=uint>>(iterator: I) -> BitvSet {\n         let mut ret = BitvSet::new();\n         ret.extend(iterator);\n         ret\n@@ -1144,7 +1163,7 @@ impl FromIterator<uint> for BitvSet {\n #[stable]\n impl Extend<uint> for BitvSet {\n     #[inline]\n-    fn extend<I: Iterator<uint>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=uint>>(&mut self, mut iterator: I) {\n         for i in iterator {\n             self.insert(i);\n         }\n@@ -1792,7 +1811,9 @@ pub struct Difference<'a>(TwoBitPositions<'a>);\n pub struct SymmetricDifference<'a>(TwoBitPositions<'a>);\n \n #[stable]\n-impl<'a> Iterator<uint> for SetIter<'a> {\n+impl<'a> Iterator for SetIter<'a> {\n+    type Item = uint;\n+\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.bitv.len() {\n             let idx = self.next_idx;\n@@ -1813,7 +1834,9 @@ impl<'a> Iterator<uint> for SetIter<'a> {\n }\n \n #[stable]\n-impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n+impl<'a> Iterator for TwoBitPositions<'a> {\n+    type Item = uint;\n+\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.bitv.len() ||\n               self.next_idx < self.other.bitv.len() {\n@@ -1849,25 +1872,33 @@ impl<'a> Iterator<uint> for TwoBitPositions<'a> {\n }\n \n #[stable]\n-impl<'a> Iterator<uint> for Union<'a> {\n+impl<'a> Iterator for Union<'a> {\n+    type Item = uint;\n+\n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n #[stable]\n-impl<'a> Iterator<uint> for Intersection<'a> {\n+impl<'a> Iterator for Intersection<'a> {\n+    type Item = uint;\n+\n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n #[stable]\n-impl<'a> Iterator<uint> for Difference<'a> {\n+impl<'a> Iterator for Difference<'a> {\n+    type Item = uint;\n+\n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }\n \n #[stable]\n-impl<'a> Iterator<uint> for SymmetricDifference<'a> {\n+impl<'a> Iterator for SymmetricDifference<'a> {\n+    type Item = uint;\n+\n     #[inline] fn next(&mut self) -> Option<uint> { self.0.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.0.size_hint() }\n }"}, {"sha": "e86e93266652a5fbcf0096617cf52e400f0d8347", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -823,7 +823,7 @@ mod stack {\n \n #[stable]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n-    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> BTreeMap<K, V> {\n+    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n         map.extend(iter);\n         map\n@@ -833,7 +833,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n #[stable]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n-    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n@@ -898,6 +898,8 @@ impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n@@ -907,6 +909,20 @@ impl<K: Ord, Sized? Q, V> Index<Q, V> for BTreeMap<K, V>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<K: Ord, Sized? Q, V> Index<Q> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    type Output = V;\n+\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n     where Q: BorrowFrom<K> + Ord\n@@ -916,6 +932,18 @@ impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for BTreeMap<K, V>\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<K: Ord, Sized? Q, V> IndexMut<Q> for BTreeMap<K, V>\n+    where Q: BorrowFrom<K> + Ord\n+{\n+    type Output = V;\n+\n+    fn index_mut(&mut self, key: &Q) -> &mut V {\n+        self.get_mut(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// Genericises over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {\n@@ -949,8 +977,11 @@ enum StackOp<T> {\n     Pop,\n }\n \n-impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        Iterator<(K, V)> for AbsIter<T> {\n+impl<K, V, E, T> Iterator for AbsIter<T> where\n+    T: DoubleEndedIterator + Iterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+{\n+    type Item = (K, V);\n+\n     // This function is pretty long, but only because there's a lot of cases to consider.\n     // Our iterator represents two search paths, left and right, to the smallest and largest\n     // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n@@ -1015,8 +1046,9 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n     }\n }\n \n-impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n-        DoubleEndedIterator<(K, V)> for AbsIter<T> {\n+impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n+    T: DoubleEndedIterator + Iterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n+{\n     // next_back is totally symmetric to next\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n@@ -1054,64 +1086,75 @@ impl<K, V, E, T: Traverse<E> + DoubleEndedIterator<TraversalItem<K, V, E>>>\n }\n \n #[stable]\n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n+impl<'a, K, V> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n     fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n #[stable]\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n }\n #[stable]\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a V)> for Iter<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {}\n \n #[stable]\n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n+impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n+\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n #[stable]\n-impl<'a, K, V> DoubleEndedIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n }\n #[stable]\n-impl<'a, K, V> ExactSizeIterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {}\n \n #[stable]\n-impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (K, V);\n+\n     fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n #[stable]\n-impl<K, V> DoubleEndedIterator<(K, V)> for IntoIter<K, V> {\n+impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> { self.inner.next_back() }\n }\n #[stable]\n-impl<K, V> ExactSizeIterator<(K, V)> for IntoIter<K, V> {}\n+impl<K, V> ExactSizeIterator for IntoIter<K, V> {}\n \n #[stable]\n-impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+impl<'a, K, V> Iterator for Keys<'a, K, V> {\n+    type Item = &'a K;\n+\n     fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n #[stable]\n-impl<'a, K, V> DoubleEndedIterator<&'a K> for Keys<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K)> { self.inner.next_back() }\n }\n #[stable]\n-impl<'a, K, V> ExactSizeIterator<&'a K> for Keys<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {}\n+\n \n #[stable]\n-impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n     fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n #[stable]\n-impl<'a, K, V> DoubleEndedIterator<&'a V> for Values<'a, K, V> {\n+impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.inner.next_back() }\n }\n #[stable]\n-impl<'a, K, V> ExactSizeIterator<&'a V> for Values<'a, K, V> {}\n+impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n \n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {"}, {"sha": "f50650c2c8be3ddc7b09517443e87627ad7ae5e5", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -210,7 +210,9 @@ impl<T> RawItems<T> {\n     }\n }\n \n-impl<T> Iterator<T> for RawItems<T> {\n+impl<T> Iterator for RawItems<T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -230,7 +232,7 @@ impl<T> Iterator<T> for RawItems<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for RawItems<T> {\n+impl<T> DoubleEndedIterator for RawItems<T> {\n     fn next_back(&mut self) -> Option<T> {\n         if self.head == self.tail {\n             None\n@@ -1321,8 +1323,10 @@ trait TraversalImpl<K, V, E> {\n /// as no deallocation needs to be done.\n struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n \n-impl<K, V, E, Elems: DoubleEndedIterator<(K, V)>, Edges: DoubleEndedIterator<E>>\n-        TraversalImpl<K, V, E> for ElemsAndEdges<Elems, Edges> {\n+impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n+        TraversalImpl<K, V, E> for ElemsAndEdges<Elems, Edges>\n+    where Elems : Iterator<Item=(K, V)>, Edges : Iterator<Item=E>\n+{\n \n     fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }\n     fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }\n@@ -1414,8 +1418,8 @@ pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a,\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n \n-impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n-        Iterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>> Iterator for AbsTraversal<Impl> {\n+    type Item = TraversalItem<K, V, E>;\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let head_is_edge = self.head_is_edge;\n@@ -1429,9 +1433,7 @@ impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n     }\n }\n \n-impl<K, V, E, Impl: TraversalImpl<K, V, E>>\n-        DoubleEndedIterator<TraversalItem<K, V, E>> for AbsTraversal<Impl> {\n-\n+impl<K, V, E, Impl: TraversalImpl<K, V, E>> DoubleEndedIterator for AbsTraversal<Impl> {\n     fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n         let tail_is_edge = self.tail_is_edge;\n         self.tail_is_edge = !tail_is_edge;"}, {"sha": "a2899f76dad4c213570256feb699f56494acd6ff", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -436,7 +436,7 @@ impl<T: Ord> BTreeSet<T> {\n \n #[stable]\n impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n-    fn from_iter<Iter: Iterator<T>>(iter: Iter) -> BTreeSet<T> {\n+    fn from_iter<Iter: Iterator<Item=T>>(iter: Iter) -> BTreeSet<T> {\n         let mut set = BTreeSet::new();\n         set.extend(iter);\n         set\n@@ -446,7 +446,7 @@ impl<T: Ord> FromIterator<T> for BTreeSet<T> {\n #[stable]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n-    fn extend<Iter: Iterator<T>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=T>>(&mut self, mut iter: Iter) {\n         for elem in iter {\n             self.insert(elem);\n         }\n@@ -462,7 +462,9 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[stable]\n-impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+    type Output = BTreeSet<T>;\n+\n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n     /// # Examples\n@@ -483,7 +485,9 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<\n }\n \n #[stable]\n-impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+    type Output = BTreeSet<T>;\n+\n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n     /// # Examples\n@@ -504,7 +508,9 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[stable]\n-impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+    type Output = BTreeSet<T>;\n+\n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n     /// # Examples\n@@ -525,7 +531,9 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeS\n }\n \n #[stable]\n-impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>, BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+    type Output = BTreeSet<T>;\n+\n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n     ///\n     /// # Examples\n@@ -560,28 +568,33 @@ impl<T: Show> Show for BTreeSet<T> {\n }\n \n #[stable]\n-impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n #[stable]\n-impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n }\n #[stable]\n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n+\n \n #[stable]\n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n #[stable]\n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     fn next_back(&mut self) -> Option<T> { self.iter.next_back() }\n }\n #[stable]\n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n@@ -594,7 +607,9 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n }\n \n #[stable]\n-impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n+impl<'a, T: Ord> Iterator for Difference<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n@@ -607,7 +622,9 @@ impl<'a, T: Ord> Iterator<&'a T> for Difference<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n+impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n@@ -620,7 +637,9 @@ impl<'a, T: Ord> Iterator<&'a T> for SymmetricDifference<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n+impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n@@ -639,7 +658,9 @@ impl<'a, T: Ord> Iterator<&'a T> for Intersection<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: Ord> Iterator<&'a T> for Union<'a, T> {\n+impl<'a, T: Ord> Iterator for Union<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {"}, {"sha": "b3d61f445639b3fb1b9d87cc324f4ee9357f0b66", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -508,7 +508,9 @@ impl<T> Drop for DList<T> {\n }\n \n #[stable]\n-impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> Iterator for Iter<'a, A> {\n+    type Item = &'a A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -528,7 +530,7 @@ impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n }\n \n #[stable]\n-impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n@@ -543,10 +545,11 @@ impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n }\n \n #[stable]\n-impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n+impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n #[stable]\n-impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> Iterator for IterMut<'a, A> {\n+    type Item = &'a mut A;\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -569,7 +572,7 @@ impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n }\n \n #[stable]\n-impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n@@ -584,7 +587,7 @@ impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n }\n \n #[stable]\n-impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n+impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// Allows mutating a `DList` while iterating.\n #[deprecated = \"Trait is deprecated, use inherent methods on the iterator instead\"]\n@@ -676,7 +679,9 @@ impl<'a, A> IterMut<'a, A> {\n }\n \n #[stable]\n-impl<A> Iterator<A> for IntoIter<A> {\n+impl<A> Iterator for IntoIter<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -687,14 +692,14 @@ impl<A> Iterator<A> for IntoIter<A> {\n }\n \n #[stable]\n-impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n+impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n \n #[stable]\n impl<A> FromIterator<A> for DList<A> {\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> DList<A> {\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> DList<A> {\n         let mut ret = DList::new();\n         ret.extend(iterator);\n         ret\n@@ -703,7 +708,7 @@ impl<A> FromIterator<A> for DList<A> {\n \n #[stable]\n impl<A> Extend<A> for DList<A> {\n-    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator { self.push_back(elt); }\n     }\n }"}, {"sha": "81e1541bea0bf70484490fc5e56baa05c812ef4e", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -185,25 +185,33 @@ impl<E:CLike> EnumSet<E> {\n     }\n }\n \n-impl<E:CLike> Sub<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+impl<E:CLike> Sub for EnumSet<E> {\n+    type Output = EnumSet<E>;\n+\n     fn sub(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & !e.bits}\n     }\n }\n \n-impl<E:CLike> BitOr<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+impl<E:CLike> BitOr for EnumSet<E> {\n+    type Output = EnumSet<E>;\n+\n     fn bitor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits | e.bits}\n     }\n }\n \n-impl<E:CLike> BitAnd<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+impl<E:CLike> BitAnd for EnumSet<E> {\n+    type Output = EnumSet<E>;\n+\n     fn bitand(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits & e.bits}\n     }\n }\n \n-impl<E:CLike> BitXor<EnumSet<E>, EnumSet<E>> for EnumSet<E> {\n+impl<E:CLike> BitXor for EnumSet<E> {\n+    type Output = EnumSet<E>;\n+\n     fn bitxor(self, e: EnumSet<E>) -> EnumSet<E> {\n         EnumSet {bits: self.bits ^ e.bits}\n     }\n@@ -231,7 +239,9 @@ impl<E:CLike> Iter<E> {\n     }\n }\n \n-impl<E:CLike> Iterator<E> for Iter<E> {\n+impl<E:CLike> Iterator for Iter<E> {\n+    type Item = E;\n+\n     fn next(&mut self) -> Option<E> {\n         if self.bits == 0 {\n             return None;\n@@ -254,15 +264,15 @@ impl<E:CLike> Iterator<E> for Iter<E> {\n }\n \n impl<E:CLike> FromIterator<E> for EnumSet<E> {\n-    fn from_iter<I:Iterator<E>>(iterator: I) -> EnumSet<E> {\n+    fn from_iter<I:Iterator<Item=E>>(iterator: I) -> EnumSet<E> {\n         let mut ret = EnumSet::new();\n         ret.extend(iterator);\n         ret\n     }\n }\n \n impl<E:CLike> Extend<E> for EnumSet<E> {\n-    fn extend<I: Iterator<E>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=E>>(&mut self, mut iterator: I) {\n         for element in iterator {\n             self.insert(element);\n         }"}, {"sha": "fb9530882db35ae4e97bb5250a21ce10fede58f7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -110,7 +110,7 @@ mod prelude {\n     pub use core::iter::range;\n     pub use core::iter::{FromIterator, Extend, IteratorExt};\n     pub use core::iter::{Iterator, DoubleEndedIterator, RandomAccessIterator};\n-    pub use core::iter::{IteratorCloneExt, CloneIteratorExt, DoubleEndedIteratorExt};\n+    pub use core::iter::{IteratorCloneExt, CloneIteratorExt};\n     pub use core::iter::{IteratorOrdExt, MutableDoubleEndedIterator, ExactSizeIterator};\n     pub use core::kinds::{Copy, Send, Sized, Sync};\n     pub use core::mem::drop;"}, {"sha": "dd78ae03c5af7c1fca66e1086098f3542accdd20", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1151,7 +1151,9 @@ impl<'a, T> Clone for Iter<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1170,7 +1172,7 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> {\n         if self.tail == self.head {\n@@ -1182,10 +1184,10 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable]\n-impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (len, _) = self.size_hint();\n@@ -1217,7 +1219,9 @@ pub struct IterMut<'a, T:'a> {\n }\n \n #[stable]\n-impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1239,7 +1243,7 @@ impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.tail == self.head {\n@@ -1254,7 +1258,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n }\n \n #[stable]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// A by-value RingBuf iterator\n #[stable]\n@@ -1263,7 +1267,9 @@ pub struct IntoIter<T> {\n }\n \n #[stable]\n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.inner.pop_front()\n@@ -1277,15 +1283,15 @@ impl<T> Iterator<T> for IntoIter<T> {\n }\n \n #[stable]\n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n #[stable]\n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n@@ -1304,7 +1310,9 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n+impl<'a, T: 'a> Iterator for Drain<'a, T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         self.inner.pop_front()\n@@ -1318,15 +1326,15 @@ impl<'a, T: 'a> Iterator<T> for Drain<'a, T> {\n }\n \n #[stable]\n-impl<'a, T: 'a> DoubleEndedIterator<T> for Drain<'a, T> {\n+impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.inner.pop_back()\n     }\n }\n \n #[stable]\n-impl<'a, T: 'a> ExactSizeIterator<T> for Drain<'a, T> {}\n+impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[stable]\n impl<A: PartialEq> PartialEq for RingBuf<A> {\n@@ -1364,6 +1372,8 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n@@ -1372,6 +1382,19 @@ impl<A> Index<uint, A> for RingBuf<A> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<A> Index<uint> for RingBuf<A> {\n+    type Output = A;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a A {\n+        self.get(*i).expect(\"Out of bounds access\")\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<A> IndexMut<uint, A> for RingBuf<A> {\n     #[inline]\n@@ -1380,9 +1403,20 @@ impl<A> IndexMut<uint, A> for RingBuf<A> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<A> IndexMut<uint> for RingBuf<A> {\n+    type Output = A;\n+\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut A {\n+        self.get_mut(*i).expect(\"Out of bounds access\")\n+    }\n+}\n+\n #[stable]\n impl<A> FromIterator<A> for RingBuf<A> {\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> RingBuf<A> {\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> RingBuf<A> {\n         let (lower, _) = iterator.size_hint();\n         let mut deq = RingBuf::with_capacity(lower);\n         deq.extend(iterator);\n@@ -1392,7 +1426,7 @@ impl<A> FromIterator<A> for RingBuf<A> {\n \n #[stable]\n impl<A> Extend<A> for RingBuf<A> {\n-    fn extend<T: Iterator<A>>(&mut self, mut iterator: T) {\n+    fn extend<T: Iterator<Item=A>>(&mut self, mut iterator: T) {\n         for elt in iterator {\n             self.push_back(elt);\n         }"}, {"sha": "5db4e8580d0a49fde6105b78835e64eb0c7370e4", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1140,7 +1140,9 @@ struct SizeDirection {\n     dir: Direction,\n }\n \n-impl Iterator<(uint, uint)> for ElementSwaps {\n+impl Iterator for ElementSwaps {\n+    type Item = (uint, uint);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         fn new_pos(i: uint, s: Direction) -> uint {\n@@ -1207,7 +1209,9 @@ pub struct Permutations<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n+impl<T: Clone> Iterator for Permutations<T> {\n+    type Item = Vec<T>;\n+\n     #[inline]\n     fn next(&mut self) -> Option<Vec<T>> {\n         match self.swaps.next() {\n@@ -1445,7 +1449,7 @@ pub mod raw {\n mod tests {\n     use std::boxed::Box;\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n-    use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{SliceExt, Iterator, IteratorExt};\n     use prelude::AsSlice;\n     use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;"}, {"sha": "6c51480931b3b3841a6cfbaae122fbef0e07b0fe", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -181,7 +181,9 @@ pub struct Decompositions<'a> {\n     sorted: bool\n }\n \n-impl<'a> Iterator<char> for Decompositions<'a> {\n+impl<'a> Iterator for Decompositions<'a> {\n+    type Item = char;\n+\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         match self.buffer.first() {\n@@ -268,7 +270,9 @@ pub struct Recompositions<'a> {\n     last_ccc: Option<u8>\n }\n \n-impl<'a> Iterator<char> for Recompositions<'a> {\n+impl<'a> Iterator for Recompositions<'a> {\n+    type Item = char;\n+\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         loop {\n@@ -357,7 +361,9 @@ pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n \n-impl<'a> Iterator<u16> for Utf16Units<'a> {\n+impl<'a> Iterator for Utf16Units<'a> {\n+    type Item = u16;\n+\n     #[inline]\n     fn next(&mut self) -> Option<u16> { self.encoder.next() }\n \n@@ -3272,7 +3278,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt, SliceConcatExt};\n+    use prelude::{SliceExt, IteratorExt, SliceConcatExt};\n     use test::Bencher;\n     use test::black_box;\n "}, {"sha": "35fa3fb55de23406a805af924092a82a7fe5dec0", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -781,7 +781,7 @@ impl fmt::Show for FromUtf16Error {\n \n #[experimental = \"waiting on FromIterator stabilization\"]\n impl FromIterator<char> for String {\n-    fn from_iter<I:Iterator<char>>(iterator: I) -> String {\n+    fn from_iter<I:Iterator<Item=char>>(iterator: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterator);\n         buf\n@@ -790,7 +790,7 @@ impl FromIterator<char> for String {\n \n #[experimental = \"waiting on FromIterator stabilization\"]\n impl<'a> FromIterator<&'a str> for String {\n-    fn from_iter<I:Iterator<&'a str>>(iterator: I) -> String {\n+    fn from_iter<I:Iterator<Item=&'a str>>(iterator: I) -> String {\n         let mut buf = String::new();\n         buf.extend(iterator);\n         buf\n@@ -799,7 +799,7 @@ impl<'a> FromIterator<&'a str> for String {\n \n #[experimental = \"waiting on Extend stabilization\"]\n impl Extend<char> for String {\n-    fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n+    fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n         for ch in iterator {\n@@ -810,7 +810,7 @@ impl Extend<char> for String {\n \n #[experimental = \"waiting on Extend stabilization\"]\n impl<'a> Extend<&'a str> for String {\n-    fn extend<I: Iterator<&'a str>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n         // A guess that at least one byte per iterator element will be needed.\n         let (lower_bound, _) = iterator.size_hint();\n         self.reserve(lower_bound);\n@@ -911,7 +911,9 @@ impl<'a, S: Str> Equiv<S> for String {\n }\n \n #[experimental = \"waiting on Add stabilization\"]\n-impl<'a> Add<&'a str, String> for String {\n+impl<'a> Add<&'a str> for String {\n+    type Output = String;\n+\n     fn add(mut self, other: &str) -> String {\n         self.push_str(other);\n         self"}, {"sha": "073388018725a79d936e293a4e5c39eac0c21e98", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1164,7 +1164,7 @@ impl<T: PartialEq> Vec<T> {\n \n /// Deprecated: use `unzip` directly on the iterator instead.\n #[deprecated = \"use unzip directly on the iterator instead\"]\n-pub fn unzip<T, U, V: Iterator<(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n+pub fn unzip<T, U, V: Iterator<Item=(T, U)>>(iter: V) -> (Vec<T>, Vec<U>) {\n     iter.unzip()\n }\n \n@@ -1245,6 +1245,8 @@ impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n@@ -1253,13 +1255,36 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[experimental = \"waiting on Index stability\"]\n+impl<T> Index<uint> for Vec<T> {\n+    type Output = T;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, index: &uint) -> &'a T {\n+        &self.as_slice()[*index]\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> IndexMut<uint,T> for Vec<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n         &mut self.as_mut_slice()[*index]\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<T> IndexMut<uint> for Vec<T> {\n+    type Output = T;\n+\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n+        &mut self.as_mut_slice()[*index]\n+    }\n+}\n+\n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -1317,7 +1342,7 @@ impl<T> ops::DerefMut for Vec<T> {\n #[experimental = \"waiting on FromIterator stability\"]\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n-    fn from_iter<I:Iterator<T>>(mut iterator: I) -> Vec<T> {\n+    fn from_iter<I:Iterator<Item=T>>(mut iterator: I) -> Vec<T> {\n         let (lower, _) = iterator.size_hint();\n         let mut vector = Vec::with_capacity(lower);\n         for element in iterator {\n@@ -1330,7 +1355,7 @@ impl<T> FromIterator<T> for Vec<T> {\n #[experimental = \"waiting on Extend stability\"]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n-    fn extend<I: Iterator<T>>(&mut self, mut iterator: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n         let (lower, _) = iterator.size_hint();\n         self.reserve(lower);\n         for element in iterator {\n@@ -1451,7 +1476,9 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-impl<'a, T: Clone> Add<&'a [T], Vec<T>> for Vec<T> {\n+impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n+    type Output = Vec<T>;\n+\n     #[inline]\n     fn add(mut self, rhs: &[T]) -> Vec<T> {\n         self.push_all(rhs);\n@@ -1506,7 +1533,7 @@ impl<'a> fmt::Writer for Vec<u8> {\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n-    fn from_iter<I: Iterator<T>>(it: I) -> CowVec<'a, T> {\n+    fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n     }\n }\n@@ -1557,7 +1584,9 @@ impl<T> IntoIter<T> {\n     pub fn unwrap(self) -> Vec<T> { self.into_inner() }\n }\n \n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1591,7 +1620,7 @@ impl<T> Iterator<T> for IntoIter<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back<'a>(&'a mut self) -> Option<T> {\n         unsafe {\n@@ -1614,7 +1643,7 @@ impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n     }\n }\n \n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n #[unsafe_destructor]\n impl<T> Drop for IntoIter<T> {\n@@ -1638,7 +1667,9 @@ pub struct Drain<'a, T> {\n     marker: ContravariantLifetime<'a>,\n }\n \n-impl<'a, T> Iterator<T> for Drain<'a, T> {\n+impl<'a, T> Iterator for Drain<'a, T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> {\n         unsafe {\n@@ -1672,7 +1703,7 @@ impl<'a, T> Iterator<T> for Drain<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<T> for Drain<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         unsafe {\n@@ -1695,7 +1726,7 @@ impl<'a, T> DoubleEndedIterator<T> for Drain<'a, T> {\n     }\n }\n \n-impl<'a, T> ExactSizeIterator<T> for Drain<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unsafe_destructor]\n impl<'a, T> Drop for Drain<'a, T> {"}, {"sha": "91edbc7b54e411ae7de9939fc5ac847adcdd0942", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -546,7 +546,7 @@ impl<V: fmt::Show> fmt::Show for VecMap<V> {\n \n #[stable]\n impl<V> FromIterator<(uint, V)> for VecMap<V> {\n-    fn from_iter<Iter: Iterator<(uint, V)>>(iter: Iter) -> VecMap<V> {\n+    fn from_iter<Iter: Iterator<Item=(uint, V)>>(iter: Iter) -> VecMap<V> {\n         let mut map = VecMap::new();\n         map.extend(iter);\n         map\n@@ -555,13 +555,15 @@ impl<V> FromIterator<(uint, V)> for VecMap<V> {\n \n #[stable]\n impl<V> Extend<(uint, V)> for VecMap<V> {\n-    fn extend<Iter: Iterator<(uint, V)>>(&mut self, mut iter: Iter) {\n+    fn extend<Iter: Iterator<Item=(uint, V)>>(&mut self, mut iter: Iter) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<V> Index<uint, V> for VecMap<V> {\n     #[inline]\n@@ -570,6 +572,18 @@ impl<V> Index<uint, V> for VecMap<V> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<V> Index<uint> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, i: &uint) -> &'a V {\n+        self.get(i).expect(\"key not present\")\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<V> IndexMut<uint, V> for VecMap<V> {\n     #[inline]\n@@ -578,10 +592,23 @@ impl<V> IndexMut<uint, V> for VecMap<V> {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<V> IndexMut<uint> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, i: &uint) -> &'a mut V {\n+        self.get_mut(i).expect(\"key not present\")\n+    }\n+}\n+\n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n         #[stable]\n-        impl<'a, V> Iterator<$elem> for $name<'a, V> {\n+        impl<'a, V> Iterator for $name<'a, V> {\n+            type Item = $elem;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n@@ -614,7 +641,7 @@ macro_rules! iterator {\n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $($getter:ident),+) => {\n         #[stable]\n-        impl<'a, V> DoubleEndedIterator<$elem> for $name<'a, V> {\n+        impl<'a, V> DoubleEndedIterator for $name<'a, V> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n@@ -713,32 +740,38 @@ pub struct IntoIter<V> {\n }\n \n #[stable]\n-impl<'a, V> Iterator<uint> for Keys<'a, V> {\n+impl<'a, V> Iterator for Keys<'a, V> {\n+    type Item = uint;\n+\n     fn next(&mut self) -> Option<uint> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n #[stable]\n-impl<'a, V> DoubleEndedIterator<uint> for Keys<'a, V> {\n+impl<'a, V> DoubleEndedIterator for Keys<'a, V> {\n     fn next_back(&mut self) -> Option<uint> { self.iter.next_back() }\n }\n \n #[stable]\n-impl<'a, V> Iterator<&'a V> for Values<'a, V> {\n+impl<'a, V> Iterator for Values<'a, V> {\n+    type Item = &'a V;\n+\n     fn next(&mut self) -> Option<(&'a V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n #[stable]\n-impl<'a, V> DoubleEndedIterator<&'a V> for Values<'a, V> {\n+impl<'a, V> DoubleEndedIterator for Values<'a, V> {\n     fn next_back(&mut self) -> Option<(&'a V)> { self.iter.next_back() }\n }\n \n #[stable]\n-impl<V> Iterator<(uint, V)> for IntoIter<V> {\n+impl<V> Iterator for IntoIter<V> {\n+    type Item = (uint, V);\n+\n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n #[stable]\n-impl<V> DoubleEndedIterator<(uint, V)> for IntoIter<V> {\n+impl<V> DoubleEndedIterator for IntoIter<V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }\n "}, {"sha": "aa6028a19b323fed8da1aae3416200786d9a5397", "filename": "src/libcore/char.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -446,7 +446,9 @@ enum EscapeUnicodeState {\n     Done,\n }\n \n-impl Iterator<char> for EscapeUnicode {\n+impl Iterator for EscapeUnicode {\n+    type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n             EscapeUnicodeState::Backslash => {\n@@ -501,7 +503,9 @@ enum EscapeDefaultState {\n     Unicode(EscapeUnicode),\n }\n \n-impl Iterator<char> for EscapeDefault {\n+impl Iterator for EscapeDefault {\n+    type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         match self.state {\n             EscapeDefaultState::Backslash(c) => {"}, {"sha": "27023fab858d939c6e688e56cc8b9bd6ba16f180", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -17,7 +17,7 @@ pub use self::SignFormat::*;\n use char;\n use char::Char;\n use fmt;\n-use iter::{range, DoubleEndedIteratorExt};\n+use iter::{IteratorExt, range};\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnOnce;"}, {"sha": "e680230265aa65e99f2ea452e026617501f81b71", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -15,7 +15,7 @@\n #![allow(unsigned_negation)]\n \n use fmt;\n-use iter::DoubleEndedIteratorExt;\n+use iter::IteratorExt;\n use num::{Int, cast};\n use slice::SliceExt;\n use str;"}, {"sha": "f65857b37fb2d7ba0fe2c6b8b95e8891de4cd8f4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 381, "deletions": 244, "changes": 625, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -82,9 +82,11 @@ use uint;\n /// else.\n #[lang=\"iterator\"]\n #[unstable = \"just split up for object safety\"]\n-pub trait Iterator<A> {\n+pub trait Iterator {\n+    type Item;\n+\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n-    fn next(&mut self) -> Option<A>;\n+    fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n@@ -98,19 +100,19 @@ pub trait Iterator<A> {\n #[unstable = \"may be replaced by a more general conversion trait\"]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n-    fn from_iter<T: Iterator<A>>(iterator: T) -> Self;\n+    fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n #[unstable = \"just renamed as part of collections reform\"]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n-    fn extend<T: Iterator<A>>(&mut self, iterator: T);\n+    fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n #[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n-pub trait IteratorExt<A>: Iterator<A> + Sized {\n+pub trait IteratorExt: Iterator + Sized {\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -127,7 +129,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n+    fn chain<U>(self, other: U) -> Chain<Self, U> where\n+        U: Iterator<Item=<Self as Iterator>::Item>,\n+    {\n         Chain{a: self, b: other, flag: false}\n     }\n \n@@ -148,7 +152,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n+    fn zip<B, U>(self, other: U) -> Zip<Self, U> where\n+        U: Iterator<Item=B>,\n+    {\n         Zip{a: self, b: other}\n     }\n \n@@ -166,7 +172,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn map<B, F: FnMut(A) -> B>(self, f: F) -> Map<A, B, Self, F> {\n+    fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n+        F: FnMut(<Self as Iterator>::Item) -> B,\n+    {\n         Map{iter: self, f: f}\n     }\n \n@@ -184,7 +192,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter<P>(self, predicate: P) -> Filter<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         Filter{iter: self, predicate: predicate}\n     }\n \n@@ -202,7 +212,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn filter_map<B, F>(self, f: F) -> FilterMap<A, B, Self, F> where F: FnMut(A) -> Option<B> {\n+    fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n+        F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n+    {\n         FilterMap { iter: self, f: f }\n     }\n \n@@ -244,7 +256,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn peekable(self) -> Peekable<A, Self> {\n+    fn peekable(self) -> Peekable< <Self as Iterator>::Item, Self> {\n         Peekable{iter: self, peeked: None}\n     }\n \n@@ -264,7 +276,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn skip_while<P>(self, predicate: P) -> SkipWhile<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -283,7 +297,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n-    fn take_while<P>(self, predicate: P) -> TakeWhile<A, Self, P> where P: FnMut(&A) -> bool {\n+    fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n     }\n \n@@ -346,8 +362,12 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<A, B, Self, St, F> where\n-        F: FnMut(&mut St, A) -> Option<B>,\n+    fn scan<St, B, F>(\n+        self,\n+        initial_state: St,\n+        f: F,\n+    ) -> Scan< <Self as Iterator>::Item, B, Self, St, F> where\n+        F: FnMut(&mut St, <Self as Iterator>::Item) -> Option<B>,\n     {\n         Scan{iter: self, f: f, state: initial_state}\n     }\n@@ -372,9 +392,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn flat_map<B, U, F>(self, f: F) -> FlatMap<A, B, Self, U, F> where\n-        U: Iterator<B>,\n-        F: FnMut(A) -> U,\n+    fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n+        U: Iterator<Item=B>,\n+        F: FnMut(<Self as Iterator>::Item) -> U,\n     {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n@@ -386,7 +406,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// # Example\n     ///\n     /// ```rust\n-    /// fn process<U: Iterator<int>>(it: U) -> int {\n+    /// fn process<U: Iterator<Item=int>>(it: U) -> int {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n     ///     for x in it {\n@@ -432,7 +452,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn inspect<F>(self, f: F) -> Inspect<A, Self, F> where F: FnMut(&A) {\n+    fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n+        F: FnMut(&<Self as Iterator>::Item),\n+    {\n         Inspect{iter: self, f: f}\n     }\n \n@@ -468,7 +490,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n-    fn collect<B: FromIterator<A>>(self) -> B {\n+    fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n \n@@ -485,7 +507,8 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[unstable = \"recently added as part of collections reform\"]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n-        B: Default + Extend<A>, F: FnMut(&A) -> bool\n+        B: Default + Extend< <Self as Iterator>::Item>,\n+        F: FnMut(&<Self as Iterator>::Item) -> bool\n     {\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n@@ -514,7 +537,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option<A> {\n+    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n         for x in *self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -533,7 +556,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"just changed to take self by value\"]\n-    fn last(mut self) -> Option<A> {\n+    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n         let mut last = None;\n         for x in self { last = Some(x); }\n         last\n@@ -550,7 +573,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where F: FnMut(B, A) -> B {\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+        F: FnMut(B, <Self as Iterator>::Item) -> B,\n+    {\n         let mut accum = init;\n         for x in self {\n             accum = f(accum, x);\n@@ -584,7 +609,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n+    fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n     }\n@@ -602,7 +627,7 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(A) -> bool {\n+    fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n     }\n@@ -612,7 +637,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<A> where P: FnMut(&A) -> bool {\n+    fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n+        P: FnMut(&<Self as Iterator>::Item) -> bool,\n+    {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -622,7 +649,9 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n+    fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+    {\n         let mut i = 0;\n         for x in *self {\n             if predicate(x) {\n@@ -646,8 +675,10 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn max_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n-        self.fold(None, |max: Option<(A, B)>, x| {\n+    fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n+        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    {\n+        self.fold(None, |max: Option<(<Self as Iterator>::Item, B)>, x| {\n             let x_val = f(&x);\n             match max {\n                 None             => Some((x, x_val)),\n@@ -673,8 +704,10 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n-    fn min_by<B: Ord, F>(self, mut f: F) -> Option<A> where F: FnMut(&A) -> B {\n-        self.fold(None, |min: Option<(A, B)>, x| {\n+    fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n+        F: FnMut(&<Self as Iterator>::Item) -> B,\n+    {\n+        self.fold(None, |min: Option<(<Self as Iterator>::Item, B)>, x| {\n             let x_val = f(&x);\n             match min {\n                 None             => Some((x, x_val)),\n@@ -686,23 +719,38 @@ pub trait IteratorExt<A>: Iterator<A> + Sized {\n             }\n         }).map(|(x, _)| x)\n     }\n-}\n \n-#[unstable = \"trait is unstable\"]\n-impl<A, I> IteratorExt<A> for I where I: Iterator<A> {}\n+    /// Change the direction of the iterator\n+    ///\n+    /// The flipped iterator swaps the ends on an iterator that can already\n+    /// be iterated from the front and from the back.\n+    ///\n+    ///\n+    /// If the iterator also implements RandomAccessIterator, the flipped\n+    /// iterator is also random access, with the indices starting at the back\n+    /// of the original iterator.\n+    ///\n+    /// Note: Random access with flipped indices still only applies to the first\n+    /// `uint::MAX` elements of the original iterator.\n+    #[inline]\n+    #[stable]\n+    fn rev(self) -> Rev<Self> {\n+        Rev{iter: self}\n+    }\n \n-/// Extention trait for iterators of pairs.\n-#[unstable = \"newly added trait, likely to be merged with IteratorExt\"]\n-pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n     /// Converts an iterator of pairs into a pair of containers.\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n-    fn unzip<FromA, FromB>(mut self) -> (FromA, FromB) where\n-        FromA: Default + Extend<A>, FromB: Default + Extend<B>\n+    fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n+        FromA: Default + Extend<A>,\n+        FromB: Default + Extend<B>,\n+        Self: Iterator<Item=(A, B)>,\n     {\n         struct SizeHint<A>(uint, Option<uint>);\n-        impl<A> Iterator<A> for SizeHint<A> {\n+        impl<A> Iterator for SizeHint<A> {\n+            type Item = A;\n+\n             fn next(&mut self) -> Option<A> { None }\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 (self.0, self.1)\n@@ -725,43 +773,19 @@ pub trait IteratorPairExt<A, B>: Iterator<(A, B)> + Sized {\n     }\n }\n \n-impl<A, B, I> IteratorPairExt<A, B> for I where I: Iterator<(A, B)> {}\n+#[unstable = \"trait is unstable\"]\n+impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n #[unstable = \"recently split into two traits\"]\n-pub trait DoubleEndedIterator<A>: Iterator<A> {\n+pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option<A>;\n-}\n-\n-/// Extension methods for double-ended iterators.\n-#[unstable = \"new extension trait convention\"]\n-pub trait DoubleEndedIteratorExt<A>: DoubleEndedIterator<A> + Sized {\n-    /// Change the direction of the iterator\n-    ///\n-    /// The flipped iterator swaps the ends on an iterator that can already\n-    /// be iterated from the front and from the back.\n-    ///\n-    ///\n-    /// If the iterator also implements RandomAccessIterator, the flipped\n-    /// iterator is also random access, with the indices starting at the back\n-    /// of the original iterator.\n-    ///\n-    /// Note: Random access with flipped indices still only applies to the first\n-    /// `uint::MAX` elements of the original iterator.\n-    #[inline]\n-    #[stable]\n-    fn rev(self) -> Rev<Self> {\n-        Rev{iter: self}\n-    }\n+    fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl<A, I> DoubleEndedIteratorExt<A> for I where I: DoubleEndedIterator<A> {}\n-\n /// A double-ended iterator yielding mutable references\n #[experimental = \"not widely used\"]\n pub trait MutableDoubleEndedIterator {\n@@ -771,7 +795,9 @@ pub trait MutableDoubleEndedIterator {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n+impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n+    I: DoubleEndedIterator + Iterator<Item=&'a mut T>,\n+{\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n     fn reverse_(&mut self) {\n@@ -792,13 +818,13 @@ impl<'a, A:'a, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n #[experimental = \"not widely used, may be better decomposed into Index and ExactSizeIterator\"]\n-pub trait RandomAccessIterator<A>: Iterator<A> {\n+pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n     fn indexable(&self) -> uint;\n \n     /// Return an element at an index, or `None` if the index is out of bounds\n-    fn idx(&mut self, index: uint) -> Option<A>;\n+    fn idx(&mut self, index: uint) -> Option< <Self as Iterator>::Item>;\n }\n \n /// An iterator that knows its exact length\n@@ -809,12 +835,14 @@ pub trait RandomAccessIterator<A>: Iterator<A> {\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n #[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n-pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n+pub trait ExactSizeIterator: DoubleEndedIterator {\n     /// Return the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n     #[inline]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where P: FnMut(A) -> bool {\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+    {\n         let len = self.len();\n         for i in range(0, len).rev() {\n             if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n@@ -840,22 +868,21 @@ pub trait ExactSizeIterator<A> : DoubleEndedIterator<A> {\n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<(uint, A)> for Enumerate<T> {}\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> ExactSizeIterator<A> for Inspect<A, I, F> where\n-    I: ExactSizeIterator<A>,\n+impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n+    I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {}\n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> ExactSizeIterator<A> for Rev<T> {}\n+impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator {}\n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> ExactSizeIterator<B> for Map<A, B, I, F> where\n-    I: ExactSizeIterator<A>,\n+impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n+    I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n #[unstable = \"trait is unstable\"]\n-impl<A, B, T, U> ExactSizeIterator<(A, B)> for Zip<T, U>\n-    where T: ExactSizeIterator<A>, U: ExactSizeIterator<B> {}\n+impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n #[deriving(Clone)]\n@@ -866,26 +893,27 @@ pub struct Rev<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Rev<T> {\n+impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Rev<T> {\n+impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n-    for Rev<T> {\n+impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         let amt = self.indexable();\n         self.iter.idx(amt - index - 1)\n     }\n@@ -894,22 +922,24 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n /// A mutable reference to an iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct ByRef<'a, T:'a> {\n-    iter: &'a mut T\n+pub struct ByRef<'a, I:'a> {\n+    iter: &'a mut I,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: Iterator<A>+'a> Iterator<A> for ByRef<'a, T> {\n+impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next() }\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<'a, A, T: DoubleEndedIterator<A>+'a> DoubleEndedIterator<A> for ByRef<'a, T> {\n+impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next_back() }\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n }\n \n /// A trait for iterators over elements which can be added together\n@@ -932,7 +962,7 @@ pub trait AdditiveIterator<A> {\n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n         #[experimental = \"trait is experimental\"]\n-        impl<T: Iterator<$A>> AdditiveIterator<$A> for T {\n+        impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n                 self.fold($init, |acc, x| acc + x)\n@@ -976,7 +1006,7 @@ pub trait MultiplicativeIterator<A> {\n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n         #[experimental = \"trait is experimental\"]\n-        impl<T: Iterator<$A>> MultiplicativeIterator<$A> for T {\n+        impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n                 self.fold($init, |acc, x| acc * x)\n@@ -1057,9 +1087,9 @@ pub trait IteratorOrdExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n+impl<T, I> IteratorOrdExt<T> for I where I: Iterator<Item=T>, T: Ord {\n     #[inline]\n-    fn max(self) -> Option<A> {\n+    fn max(self) -> Option<T> {\n         self.fold(None, |max, x| {\n             match max {\n                 None    => Some(x),\n@@ -1069,7 +1099,7 @@ impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n     }\n \n     #[inline]\n-    fn min(self) -> Option<A> {\n+    fn min(self) -> Option<T> {\n         self.fold(None, |min, x| {\n             match min {\n                 None    => Some(x),\n@@ -1078,7 +1108,7 @@ impl<A: Ord, T: Iterator<A>> IteratorOrdExt<A> for T {\n         })\n     }\n \n-    fn min_max(mut self) -> MinMaxResult<A> {\n+    fn min_max(mut self) -> MinMaxResult<T> {\n         let (mut min, mut max) = match self.next() {\n             None => return NoElements,\n             Some(x) => {\n@@ -1175,7 +1205,11 @@ pub trait IteratorCloneExt<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> IteratorCloneExt<A> for I {\n+impl<T, D, I> IteratorCloneExt<T> for I where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: Iterator<Item=D>,\n+{\n     fn cloned(self) -> Cloned<I> {\n         Cloned { it: self }\n     }\n@@ -1186,8 +1220,14 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n-    fn next(&mut self) -> Option<A> {\n+impl<T, D, I> Iterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: Iterator<Item=D>,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n         self.it.next().cloned()\n     }\n \n@@ -1196,15 +1236,22 @@ impl<A: Clone, D: Deref<Target=A>, I: Iterator<D>> Iterator<A> for Cloned<I> {\n     }\n }\n \n-impl<A: Clone, D: Deref<Target=A>, I: DoubleEndedIterator<D>>\n-        DoubleEndedIterator<A> for Cloned<I> {\n-    fn next_back(&mut self) -> Option<A> {\n+impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: DoubleEndedIterator + Iterator<Item=D>,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n         self.it.next_back().cloned()\n     }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone, D: Deref<Target=A>, I: ExactSizeIterator<D>> ExactSizeIterator<A> for Cloned<I> {}\n+impl<T, D, I> ExactSizeIterator for Cloned<I> where\n+    T: Clone,\n+    D: Deref<Target=T>,\n+    I: ExactSizeIterator + Iterator<Item=D>,\n+{}\n \n #[unstable = \"recently renamed for extension trait conventions\"]\n /// An extension trait for cloneable iterators.\n@@ -1225,7 +1272,7 @@ pub trait CloneIteratorExt {\n     fn cycle(self) -> Cycle<Self>;\n }\n \n-impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n+impl<I> CloneIteratorExt for I where I: Iterator + Clone {\n     #[inline]\n     fn cycle(self) -> Cycle<I> {\n         Cycle{orig: self.clone(), iter: self}\n@@ -1236,14 +1283,16 @@ impl<A, I> CloneIteratorExt for I where I: Iterator<A> + Clone {\n #[deriving(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Cycle<T> {\n-    orig: T,\n-    iter: T,\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n }\n \n-impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n+impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         match self.iter.next() {\n             None => { self.iter = self.orig.clone(); self.iter.next() }\n             y => y\n@@ -1262,7 +1311,9 @@ impl<A, T: Clone + Iterator<A>> Iterator<A> for Cycle<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T> {\n+impl<I> RandomAccessIterator for Cycle<I> where\n+    I: Clone + RandomAccessIterator,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         if self.orig.indexable() > 0 {\n@@ -1273,7 +1324,7 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         let liter = self.iter.indexable();\n         let lorig = self.orig.indexable();\n         if lorig == 0 {\n@@ -1290,16 +1341,18 @@ impl<A, T: Clone + RandomAccessIterator<A>> RandomAccessIterator<A> for Cycle<T>\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Chain<T, U> {\n-    a: T,\n-    b: U,\n+pub struct Chain<A, B> {\n+    a: A,\n+    b: B,\n     flag: bool,\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n+impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         if self.flag {\n             self.b.next()\n         } else {\n@@ -1329,10 +1382,12 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for Chain<T, U> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>, U: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n-for Chain<T, U> {\n+impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n+    A: DoubleEndedIterator + Iterator<Item=T>,\n+    B: DoubleEndedIterator + Iterator<Item=T>,\n+{\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option<T> {\n         match self.b.next_back() {\n             Some(x) => Some(x),\n             None => self.a.next_back()\n@@ -1341,16 +1396,18 @@ for Chain<T, U> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>, U: RandomAccessIterator<A>> RandomAccessIterator<A>\n-for Chain<T, U> {\n+impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n+    A: RandomAccessIterator + Iterator<Item=T>,\n+    B: RandomAccessIterator + Iterator<Item=T>,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (a, b) = (self.a.indexable(), self.b.indexable());\n         a.saturating_add(b)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option<T> {\n         let len = self.a.indexable();\n         if index < len {\n             self.a.idx(index)\n@@ -1364,15 +1421,20 @@ for Chain<T, U> {\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Zip<T, U> {\n-    a: T,\n-    b: U\n+pub struct Zip<A, B> {\n+    a: A,\n+    b: B\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n+impl<T, U, A, B> Iterator for Zip<A, B> where\n+    A: Iterator<Item = T>,\n+    B: Iterator<Item = U>,\n+{\n+    type Item = (T, U);\n+\n     #[inline]\n-    fn next(&mut self) -> Option<(A, B)> {\n+    fn next(&mut self) -> Option<(T, U)> {\n         match self.a.next() {\n             None => None,\n             Some(x) => match self.b.next() {\n@@ -1401,10 +1463,12 @@ impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, T: ExactSizeIterator<A>, U: ExactSizeIterator<B>> DoubleEndedIterator<(A, B)>\n-for Zip<T, U> {\n+impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n+    A: ExactSizeIterator + Iterator<Item=T>,\n+    B: ExactSizeIterator + Iterator<Item=U>,\n+{\n     #[inline]\n-    fn next_back(&mut self) -> Option<(A, B)> {\n+    fn next_back(&mut self) -> Option<(T, U)> {\n         let a_sz = self.a.len();\n         let b_sz = self.b.len();\n         if a_sz != b_sz {\n@@ -1424,15 +1488,17 @@ for Zip<T, U> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, B, T: RandomAccessIterator<A>, U: RandomAccessIterator<B>>\n-RandomAccessIterator<(A, B)> for Zip<T, U> {\n+impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n+    A: RandomAccessIterator + Iterator<Item=T>,\n+    B: RandomAccessIterator + Iterator<Item=U>,\n+{\n     #[inline]\n     fn indexable(&self) -> uint {\n         cmp::min(self.a.indexable(), self.b.indexable())\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(A, B)> {\n+    fn idx(&mut self, index: uint) -> Option<(T, U)> {\n         match self.a.idx(index) {\n             None => None,\n             Some(x) => match self.b.idx(index) {\n@@ -1446,15 +1512,15 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n /// An iterator that maps the values of `iter` with `f`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Map<A, B, I: Iterator<A>, F: FnMut(A) -> B> {\n+pub struct Map<A, B, I: Iterator<Item=A>, F: FnMut(A) -> B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, F> Clone for Map<A, B, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> B,\n {\n     fn clone(&self) -> Map<A, B, I, F> {\n@@ -1465,7 +1531,7 @@ impl<A, B, I, F> Clone for Map<A, B, I, F> where\n     }\n }\n \n-impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n+impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     #[inline]\n     fn do_map(&mut self, elt: Option<A>) -> Option<B> {\n         match elt {\n@@ -1476,7 +1542,9 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> Iterator<B> for Map<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> B {\n+impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         let next = self.iter.next();\n@@ -1490,8 +1558,8 @@ impl<A, B, I, F> Iterator<B> for Map<A, B, I, F> where I: Iterator<A>, F: FnMut(\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> DoubleEndedIterator<B> for Map<A, B, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1502,8 +1570,8 @@ impl<A, B, I, F> DoubleEndedIterator<B> for Map<A, B, I, F> where\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n-    I: RandomAccessIterator<A>,\n+impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n+    I: RandomAccessIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {\n     #[inline]\n@@ -1521,15 +1589,15 @@ impl<A, B, I, F> RandomAccessIterator<B> for Map<A, B, I, F> where\n /// An iterator that filters the elements of `iter` with `predicate`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     predicate: P,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for Filter<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> Filter<A, I, P> {\n@@ -1541,7 +1609,9 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1562,8 +1632,8 @@ impl<A, I, P> Iterator<A> for Filter<A, I, P> where I: Iterator<A>, P: FnMut(&A)\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     P: FnMut(&A) -> bool,\n {\n     #[inline]\n@@ -1580,15 +1650,15 @@ impl<A, I, P> DoubleEndedIterator<A> for Filter<A, I, P> where\n /// An iterator that uses `f` to both filter and map elements from `iter`\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct FilterMap<A, B, I, F> where I: Iterator<A>, F: FnMut(A) -> Option<B> {\n+pub struct FilterMap<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> Option<B> {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(A) -> Option<B>,\n {\n     fn clone(&self) -> FilterMap<A, B, I, F> {\n@@ -1600,10 +1670,12 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n-    I: Iterator<A>,\n+impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n+    I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         for x in self.iter {\n@@ -1623,8 +1695,8 @@ impl<A, B, I, F> Iterator<B> for FilterMap<A, B, I, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n {\n     #[inline]\n@@ -1643,15 +1715,17 @@ impl<A, B, I, F> DoubleEndedIterator<B> for FilterMap<A, B, I, F> where\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Enumerate<T> {\n-    iter: T,\n+pub struct Enumerate<I> {\n+    iter: I,\n     count: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n+impl<I> Iterator for Enumerate<I> where I: Iterator {\n+    type Item = (uint, <I as Iterator>::Item);\n+\n     #[inline]\n-    fn next(&mut self) -> Option<(uint, A)> {\n+    fn next(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next() {\n             Some(a) => {\n                 let ret = Some((self.count, a));\n@@ -1669,9 +1743,9 @@ impl<A, T: Iterator<A>> Iterator<(uint, A)> for Enumerate<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: ExactSizeIterator<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T> {\n+impl<I> DoubleEndedIterator for Enumerate<I> where I: ExactSizeIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, A)> {\n+    fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n             Some(a) => {\n                 let len = self.iter.len();\n@@ -1683,14 +1757,14 @@ impl<A, T: ExactSizeIterator<A>> DoubleEndedIterator<(uint, A)> for Enumerate<T>\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerate<T> {\n+impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<(uint, A)> {\n+    fn idx(&mut self, index: uint) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.idx(index) {\n             Some(a) => Some((self.count + index, a)),\n             _ => None,\n@@ -1702,14 +1776,16 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<(uint, A)> for Enumerat\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n #[deriving(Copy)]\n-pub struct Peekable<A, T> {\n-    iter: T,\n-    peeked: Option<A>,\n+pub struct Peekable<T, I> where I: Iterator<Item=T> {\n+    iter: I,\n+    peeked: Option<T>,\n }\n \n-impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n+impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option<T> {\n         if self.peeked.is_some() { self.peeked.take() }\n         else { self.iter.next() }\n     }\n@@ -1731,11 +1807,11 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n }\n \n #[stable]\n-impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n+impl<T, I> Peekable<T, I> where I: Iterator<Item=T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n     #[inline]\n-    pub fn peek(&'a mut self) -> Option<&'a A> {\n+    pub fn peek(&mut self) -> Option<&T> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n@@ -1755,7 +1831,7 @@ impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n /// An iterator that rejects elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n@@ -1764,7 +1840,7 @@ pub struct SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for SkipWhile<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> SkipWhile<A, I, P> {\n@@ -1777,7 +1853,9 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1799,7 +1877,7 @@ impl<A, I, P> Iterator<A> for SkipWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n /// An iterator that only accepts elements while `predicate` is true\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+pub struct TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     iter: I,\n     flag: bool,\n     predicate: P,\n@@ -1808,7 +1886,7 @@ pub struct TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, P> Clone for TakeWhile<A, I, P> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     P: Clone + FnMut(&A) -> bool,\n {\n     fn clone(&self) -> TakeWhile<A, I, P> {\n@@ -1821,7 +1899,9 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(&A) -> bool {\n+impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -1852,15 +1932,17 @@ impl<A, I, P> Iterator<A> for TakeWhile<A, I, P> where I: Iterator<A>, P: FnMut(\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Skip<T> {\n-    iter: T,\n+pub struct Skip<I> {\n+    iter: I,\n     n: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n+impl<I> Iterator for Skip<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         let mut next = self.iter.next();\n         if self.n == 0 {\n             next\n@@ -1900,14 +1982,14 @@ impl<A, T: Iterator<A>> Iterator<A> for Skip<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n+impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable().saturating_sub(self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         if index >= self.indexable() {\n             None\n         } else {\n@@ -1920,15 +2002,17 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Skip<T> {\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Take<T> {\n-    iter: T,\n+pub struct Take<I> {\n+    iter: I,\n     n: uint\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n+impl<I> Iterator for Take<I> where I: Iterator{\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.n != 0 {\n             self.n -= 1;\n             self.iter.next()\n@@ -1953,14 +2037,14 @@ impl<A, T: Iterator<A>> Iterator<A> for Take<T> {\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n+impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n         cmp::min(self.iter.indexable(), self.n)\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         if index >= self.n {\n             None\n         } else {\n@@ -1973,7 +2057,7 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Option<B> {\n+pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n \n@@ -1984,7 +2068,7 @@ pub struct Scan<A, B, I, St, F> where I: Iterator<A>, F: FnMut(&mut St, A) -> Op\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     St: Clone,\n     F: Clone + FnMut(&mut St, A) -> Option<B>,\n {\n@@ -1998,10 +2082,12 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n-    I: Iterator<A>,\n+impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n+    I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n@@ -2019,7 +2105,11 @@ impl<A, B, I, St, F> Iterator<B> for Scan<A, B, I, St, F> where\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut(A) -> U {\n+pub struct FlatMap<A, B, I, U, F> where\n+    I: Iterator<Item=A>,\n+    U: Iterator<Item=B>,\n+    F: FnMut(A) -> U,\n+{\n     iter: I,\n     f: F,\n     frontiter: Option<U>,\n@@ -2029,8 +2119,8 @@ pub struct FlatMap<A, B, I, U, F> where I: Iterator<A>, U: Iterator<B>, F: FnMut\n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n-    I: Clone + Iterator<A>,\n-    U: Clone + Iterator<B>,\n+    I: Clone + Iterator<Item=A>,\n+    U: Clone + Iterator<Item=B>,\n     F: Clone + FnMut(A) -> U,\n {\n     fn clone(&self) -> FlatMap<A, B, I, U, F> {\n@@ -2044,11 +2134,13 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n-    I: Iterator<A>,\n-    U: Iterator<B>,\n+impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n+    I: Iterator<Item=A>,\n+    U: Iterator<Item=B>,\n     F: FnMut(A) -> U,\n {\n+    type Item = B;\n+\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -2077,9 +2169,9 @@ impl<A, B, I, U, F> Iterator<B> for FlatMap<A, B, I, U, F> where\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, B, I, U, F> DoubleEndedIterator<B> for FlatMap<A, B, I, U, F> where\n-    I: DoubleEndedIterator<A>,\n-    U: DoubleEndedIterator<B>,\n+impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n+    U: DoubleEndedIterator + Iterator<Item=B>,\n     F: FnMut(A) -> U,\n {\n     #[inline]\n@@ -2104,15 +2196,17 @@ impl<A, B, I, U, F> DoubleEndedIterator<B> for FlatMap<A, B, I, U, F> where\n #[deriving(Clone)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable]\n-pub struct Fuse<T> {\n-    iter: T,\n+pub struct Fuse<I> {\n+    iter: I,\n     done: bool\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n+impl<I> Iterator for Fuse<I> where I: Iterator {\n+    type Item = <I as Iterator>::Item;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<A> {\n+    fn next(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2137,9 +2231,9 @@ impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n+impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n+    fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n         if self.done {\n             None\n         } else {\n@@ -2156,20 +2250,20 @@ impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n #[experimental = \"trait is experimental\"]\n-impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n+impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<A> {\n+    fn idx(&mut self, index: uint) -> Option< <I as Iterator>::Item> {\n         self.iter.idx(index)\n     }\n }\n \n #[experimental = \"seems marginal\"]\n-impl<T> Fuse<T> {\n+impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n@@ -2182,15 +2276,15 @@ impl<T> Fuse<T> {\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable = \"waiting for unboxed closures\"]\n-pub struct Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n }\n \n // FIXME(#19839) Remove in favor of `#[deriving(Clone)]`\n #[stable]\n impl<A, I, F> Clone for Inspect<A, I, F> where\n-    I: Clone + Iterator<A>,\n+    I: Clone + Iterator<Item=A>,\n     F: Clone + FnMut(&A),\n {\n     fn clone(&self) -> Inspect<A, I, F> {\n@@ -2201,7 +2295,7 @@ impl<A, I, F> Clone for Inspect<A, I, F> where\n     }\n }\n \n-impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     #[inline]\n     fn do_inspect(&mut self, elt: Option<A>) -> Option<A> {\n         match elt {\n@@ -2214,7 +2308,9 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> Iterator<A> for Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A) {\n+impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n@@ -2228,8 +2324,8 @@ impl<A, I, F> Iterator<A> for Inspect<A, I, F> where I: Iterator<A>, F: FnMut(&A\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A, I, F> DoubleEndedIterator<A> for Inspect<A, I, F> where\n-    I: DoubleEndedIterator<A>,\n+impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n+    I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]\n@@ -2240,8 +2336,8 @@ impl<A, I, F> DoubleEndedIterator<A> for Inspect<A, I, F> where\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A, I, F> RandomAccessIterator<A> for Inspect<A, I, F> where\n-    I: RandomAccessIterator<A>,\n+impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n+    I: RandomAccessIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {\n     #[inline]\n@@ -2323,7 +2419,9 @@ impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n }\n \n #[experimental]\n-impl<A, St, F> Iterator<A> for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)\n@@ -2355,7 +2453,9 @@ pub fn count<A>(start: A, step: A) -> Counter<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n+impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let result = self.state.clone();\n@@ -2402,7 +2502,9 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n \n // FIXME: #10414: Unfortunate type bound\n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> Iterator for Range<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.state < self.stop {\n@@ -2450,7 +2552,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for Range<A> {\n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for Range<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.stop > self.state {\n@@ -2481,7 +2583,9 @@ pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         match self.range.next() {\n@@ -2514,7 +2618,7 @@ impl<A: Int + ToPrimitive> Iterator<A> for RangeInclusive<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator<A> for RangeInclusive<A> {\n+impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.range.stop > self.range.state {\n@@ -2549,7 +2653,9 @@ pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int> Iterator<A> for RangeStep<A> {\n+impl<A: Int> Iterator for RangeStep<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if (self.rev && self.state > self.stop) || (!self.rev && self.state < self.stop) {\n@@ -2591,7 +2697,9 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Int> Iterator<A> for RangeStepInclusive<A> {\n+impl<A: Int> Iterator for RangeStepInclusive<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if !self.done && ((self.rev && self.state >= self.stop) ||\n@@ -2683,21 +2791,23 @@ impl<A: Clone> Repeat<A> {\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone> Iterator<A> for Repeat<A> {\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.idx(0) }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n #[unstable = \"trait is unstable\"]\n-impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n #[experimental = \"trait is experimental\"]\n-impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n+impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n     #[inline]\n@@ -2766,7 +2876,11 @@ pub mod order {\n     use super::Iterator;\n \n     /// Compare `a` and `b` for equality using `Eq`\n-    pub fn equals<A: Eq, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn equals<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: Eq,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2777,7 +2891,11 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `Ord`\n-    pub fn cmp<A: Ord, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> cmp::Ordering {\n+    pub fn cmp<A, T, S>(mut a: T, mut b: S) -> cmp::Ordering where\n+        A: Ord,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return Equal,\n@@ -2792,8 +2910,11 @@ pub mod order {\n     }\n \n     /// Order `a` and `b` lexicographically using `PartialOrd`\n-    pub fn partial_cmp<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S)\n-            -> Option<cmp::Ordering> {\n+    pub fn partial_cmp<A, T, S>(mut a: T, mut b: S) -> Option<cmp::Ordering> where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return Some(Equal),\n@@ -2810,8 +2931,8 @@ pub mod order {\n     /// Compare `a` and `b` for equality (Using partial equality, `PartialEq`)\n     pub fn eq<A, B, L, R>(mut a: L, mut b: R) -> bool where\n         A: PartialEq<B>,\n-        L: Iterator<A>,\n-        R: Iterator<B>,\n+        L: Iterator<Item=A>,\n+        R: Iterator<Item=B>,\n     {\n         loop {\n             match (a.next(), b.next()) {\n@@ -2825,8 +2946,8 @@ pub mod order {\n     /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n     pub fn ne<A, B, L, R>(mut a: L, mut b: R) -> bool where\n         A: PartialEq<B>,\n-        L: Iterator<A>,\n-        R: Iterator<B>,\n+        L: Iterator<Item=A>,\n+        R: Iterator<Item=B>,\n     {\n         loop {\n             match (a.next(), b.next()) {\n@@ -2838,7 +2959,11 @@ pub mod order {\n     }\n \n     /// Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn lt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn lt<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2850,7 +2975,11 @@ pub mod order {\n     }\n \n     /// Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn le<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn le<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,\n@@ -2862,7 +2991,11 @@ pub mod order {\n     }\n \n     /// Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn gt<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn gt<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return false,\n@@ -2874,7 +3007,11 @@ pub mod order {\n     }\n \n     /// Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn ge<A: PartialOrd, T: Iterator<A>, S: Iterator<A>>(mut a: T, mut b: S) -> bool {\n+    pub fn ge<A, T, S>(mut a: T, mut b: S) -> bool where\n+        A: PartialOrd,\n+        T: Iterator<Item=A>,\n+        S: Iterator<Item=A>,\n+    {\n         loop {\n             match (a.next(), b.next()) {\n                 (None, None) => return true,"}, {"sha": "254788f9a75f193b83ba19d964a721eef28f4126", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -35,7 +35,7 @@ use str::{FromStr, from_str, StrExt};\n /// Simultaneous division and remainder\n #[inline]\n #[deprecated = \"use division and remainder directly\"]\n-pub fn div_rem<T: Clone + Div<T, T> + Rem<T, T>>(x: T, y: T) -> (T, T) {\n+pub fn div_rem<T: Clone + Div<Output=T> + Rem<Output=T>>(x: T, y: T) -> (T, T) {\n     (x.clone() / y.clone(), x % y)\n }\n \n@@ -53,17 +53,17 @@ pub trait Int\n     + NumCast\n     + PartialOrd + Ord\n     + PartialEq + Eq\n-    + Add<Self,Self>\n-    + Sub<Self,Self>\n-    + Mul<Self,Self>\n-    + Div<Self,Self>\n-    + Rem<Self,Self>\n-    + Not<Self>\n-    + BitAnd<Self,Self>\n-    + BitOr<Self,Self>\n-    + BitXor<Self,Self>\n-    + Shl<uint,Self>\n-    + Shr<uint,Self>\n+    + Add<Output=Self>\n+    + Sub<Output=Self>\n+    + Mul<Output=Self>\n+    + Div<Output=Self>\n+    + Rem<Output=Self>\n+    + Not<Output=Self>\n+    + BitAnd<Output=Self>\n+    + BitOr<Output=Self>\n+    + BitXor<Output=Self>\n+    + Shl<uint, Output=Self>\n+    + Shr<uint, Output=Self>\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n@@ -613,7 +613,7 @@ int_impl! { int = i64, u64, 64,\n #[unstable = \"recently settled as part of numerics reform\"]\n pub trait SignedInt\n     : Int\n-    + Neg<Self>\n+    + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n@@ -1245,12 +1245,12 @@ pub trait Float\n     + NumCast\n     + PartialOrd\n     + PartialEq\n-    + Neg<Self>\n-    + Add<Self,Self>\n-    + Sub<Self,Self>\n-    + Mul<Self,Self>\n-    + Div<Self,Self>\n-    + Rem<Self,Self>\n+    + Neg<Output=Self>\n+    + Add<Output=Self>\n+    + Sub<Output=Self>\n+    + Mul<Output=Self>\n+    + Div<Output=Self>\n+    + Rem<Output=Self>\n {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n@@ -1718,12 +1718,12 @@ macro_rules! trait_impl {\n #[deprecated = \"Generalised numbers are no longer supported\"]\n #[allow(deprecated)]\n pub trait Num: PartialEq + Zero + One\n-             + Neg<Self>\n-             + Add<Self,Self>\n-             + Sub<Self,Self>\n-             + Mul<Self,Self>\n-             + Div<Self,Self>\n-             + Rem<Self,Self> {}\n+             + Neg<Output=Self>\n+             + Add<Output=Self>\n+             + Sub<Output=Self>\n+             + Mul<Output=Self>\n+             + Div<Output=Self>\n+             + Rem<Output=Self> {}\n trait_impl! { Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n #[deprecated = \"Generalised unsigned numbers are no longer supported\"]\n@@ -1737,7 +1737,7 @@ pub trait Primitive: Copy + Clone + Num + NumCast + PartialOrd {}\n trait_impl! { Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n #[deprecated = \"The generic `Zero` trait will be removed soon.\"]\n-pub trait Zero: Add<Self, Self> {\n+pub trait Zero: Add<Output=Self> {\n     #[deprecated = \"Use `Int::zero()` or `Float::zero()`.\"]\n     fn zero() -> Self;\n     #[deprecated = \"Use `x == Int::zero()` or `x == Float::zero()`.\"]\n@@ -1768,7 +1768,7 @@ zero_impl! { f32, 0.0f32 }\n zero_impl! { f64, 0.0f64 }\n \n #[deprecated = \"The generic `One` trait will be removed soon.\"]\n-pub trait One: Mul<Self, Self> {\n+pub trait One: Mul<Output=Self> {\n     #[deprecated = \"Use `Int::one()` or `Float::one()`.\"]\n     fn one() -> Self;\n }"}, {"sha": "bef91dbd7604733c17a1841d248cd3131fa473a5", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 204, "deletions": 62, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -25,6 +25,8 @@\n //! demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n+//! #![feature(associated_types)]\n+//!\n //! use std::ops::{Add, Sub};\n //!\n //! #[deriving(Show)]\n@@ -33,13 +35,17 @@\n //!     y: int\n //! }\n //!\n-//! impl Add<Point, Point> for Point {\n+//! impl Add for Point {\n+//!     type Output = Point;\n+//!\n //!     fn add(self, other: Point) -> Point {\n //!         Point {x: self.x + other.x, y: self.y + other.y}\n //!     }\n //! }\n //!\n-//! impl Sub<Point, Point> for Point {\n+//! impl Sub for Point {\n+//!     type Output = Point;\n+//!\n //!     fn sub(self, other: Point) -> Point {\n //!         Point {x: self.x - other.x, y: self.y - other.y}\n //!     }\n@@ -93,12 +99,16 @@ pub trait Drop {\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n /// ```rust\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Add;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Add<Foo, Foo> for Foo {\n+/// impl Add for Foo {\n+///     type Output = Foo;\n+///\n ///     fn add(self, _rhs: Foo) -> Foo {\n ///       println!(\"Adding!\");\n ///       self\n@@ -110,14 +120,18 @@ pub trait Drop {\n /// }\n /// ```\n #[lang=\"add\"]\n-pub trait Add<RHS, Result> {\n+pub trait Add<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `+` operator\n-    fn add(self, rhs: RHS) -> Result;\n+    fn add(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n-        impl Add<$t, $t> for $t {\n+        impl Add for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n@@ -134,12 +148,16 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n /// ```rust\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Sub;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Sub<Foo, Foo> for Foo {\n+/// impl Sub for Foo {\n+///     type Output = Foo;\n+///\n ///     fn sub(self, _rhs: Foo) -> Foo {\n ///         println!(\"Subtracting!\");\n ///         self\n@@ -151,14 +169,18 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"sub\"]\n-pub trait Sub<RHS, Result> {\n+pub trait Sub<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `-` operator\n-    fn sub(self, rhs: RHS) -> Result;\n+    fn sub(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n-        impl Sub<$t, $t> for $t {\n+        impl Sub for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n@@ -175,12 +197,16 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n /// ```rust\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Mul;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Mul<Foo, Foo> for Foo {\n+/// impl Mul for Foo {\n+///     type Output = Foo;\n+///\n ///     fn mul(self, _rhs: Foo) -> Foo {\n ///         println!(\"Multiplying!\");\n ///         self\n@@ -192,14 +218,18 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"mul\"]\n-pub trait Mul<RHS, Result> {\n+pub trait Mul<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `*` operator\n-    fn mul(self, rhs: RHS) -> Result;\n+    fn mul(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n-        impl Mul<$t, $t> for $t {\n+        impl Mul for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n@@ -216,12 +246,16 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `div`, and therefore, `main` prints `Dividing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Div;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Div<Foo, Foo> for Foo {\n+/// impl Div for Foo {\n+///     type Output = Foo;\n+///\n ///     fn div(self, _rhs: Foo) -> Foo {\n ///         println!(\"Dividing!\");\n ///         self\n@@ -233,14 +267,18 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"div\"]\n-pub trait Div<RHS, Result> {\n+pub trait Div<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `/` operator\n-    fn div(self, rhs: RHS) -> Result;\n+    fn div(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n-        impl Div<$t, $t> for $t {\n+        impl Div for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n@@ -257,12 +295,16 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Rem;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Rem<Foo, Foo> for Foo {\n+/// impl Rem for Foo {\n+///     type Output = Foo;\n+///\n ///     fn rem(self, _rhs: Foo) -> Foo {\n ///         println!(\"Remainder-ing!\");\n ///         self\n@@ -274,14 +316,18 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// }\n /// ```\n #[lang=\"rem\"]\n-pub trait Rem<RHS, Result> {\n+pub trait Rem<RHS=Self> {\n+    type Output = Self;\n+\n     /// The method for the `%` operator\n-    fn rem(self, rhs: RHS) -> Result;\n+    fn rem(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n-        impl Rem<$t, $t> for $t {\n+        impl Rem for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n@@ -290,7 +336,9 @@ macro_rules! rem_impl {\n \n macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n-        impl Rem<$t, $t> for $t {\n+        impl Rem for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn rem(self, other: $t) -> $t {\n                 extern { fn $fmod(a: $t, b: $t) -> $t; }\n@@ -312,13 +360,17 @@ rem_float_impl! { f64, fmod }\n /// `neg`, and therefore, `main` prints `Negating!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Neg;\n ///\n /// struct Foo;\n ///\n /// impl Copy for Foo {}\n ///\n-/// impl Neg<Foo> for Foo {\n+/// impl Neg for Foo {\n+///     type Output = Foo;\n+///\n ///     fn neg(self) -> Foo {\n ///         println!(\"Negating!\");\n ///         self\n@@ -330,14 +382,18 @@ rem_float_impl! { f64, fmod }\n /// }\n /// ```\n #[lang=\"neg\"]\n-pub trait Neg<Result> {\n+pub trait Neg {\n+    type Output;\n+\n     /// The method for the unary `-` operator\n-    fn neg(self) -> Result;\n+    fn neg(self) -> Self::Output;\n }\n \n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n-        impl Neg<$t> for $t {\n+        impl Neg for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn neg(self) -> $t { -self }\n         }\n@@ -346,7 +402,9 @@ macro_rules! neg_impl {\n \n macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n-        impl Neg<$t> for $t {\n+        impl Neg for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn neg(self) -> $t { -(self as $t_signed) as $t }\n         }\n@@ -370,13 +428,17 @@ neg_uint_impl! { u64, i64 }\n /// `not`, and therefore, `main` prints `Not-ing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Not;\n ///\n /// struct Foo;\n ///\n /// impl Copy for Foo {}\n ///\n-/// impl Not<Foo> for Foo {\n+/// impl Not for Foo {\n+///     type Output = Foo;\n+///\n ///     fn not(self) -> Foo {\n ///         println!(\"Not-ing!\");\n ///         self\n@@ -388,14 +450,18 @@ neg_uint_impl! { u64, i64 }\n /// }\n /// ```\n #[lang=\"not\"]\n-pub trait Not<Result> {\n+pub trait Not {\n+    type Output;\n+\n     /// The method for the unary `!` operator\n-    fn not(self) -> Result;\n+    fn not(self) -> Self::Output;\n }\n \n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n-        impl Not<$t> for $t {\n+        impl Not for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn not(self) -> $t { !self }\n         }\n@@ -412,12 +478,16 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::BitAnd;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl BitAnd<Foo, Foo> for Foo {\n+/// impl BitAnd for Foo {\n+///     type Output = Foo;\n+///\n ///     fn bitand(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise And-ing!\");\n ///         self\n@@ -429,14 +499,18 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitand\"]\n-pub trait BitAnd<RHS, Result> {\n+pub trait BitAnd<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `&` operator\n-    fn bitand(self, rhs: RHS) -> Result;\n+    fn bitand(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n-        impl BitAnd<$t, $t> for $t {\n+        impl BitAnd for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n@@ -453,12 +527,16 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::BitOr;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl BitOr<Foo, Foo> for Foo {\n+/// impl BitOr for Foo {\n+///     type Output = Foo;\n+///\n ///     fn bitor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Or-ing!\");\n ///         self\n@@ -470,14 +548,18 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitor\"]\n-pub trait BitOr<RHS, Result> {\n+pub trait BitOr<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `|` operator\n-    fn bitor(self, rhs: RHS) -> Result;\n+    fn bitor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n-        impl BitOr<$t,$t> for $t {\n+        impl BitOr for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n@@ -494,12 +576,16 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::BitXor;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl BitXor<Foo, Foo> for Foo {\n+/// impl BitXor for Foo {\n+///     type Output = Foo;\n+///\n ///     fn bitxor(self, _rhs: Foo) -> Foo {\n ///         println!(\"Bitwise Xor-ing!\");\n ///         self\n@@ -511,14 +597,18 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"bitxor\"]\n-pub trait BitXor<RHS, Result> {\n+pub trait BitXor<RHS=Self> {\n+    type Output;\n+\n     /// The method for the `^` operator\n-    fn bitxor(self, rhs: RHS) -> Result;\n+    fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n-        impl BitXor<$t, $t> for $t {\n+        impl BitXor for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n@@ -535,12 +625,16 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shl`, and therefore, `main` prints `Shifting left!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Shl;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Shl<Foo, Foo> for Foo {\n+/// impl Shl<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn shl(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting left!\");\n ///         self\n@@ -552,14 +646,18 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shl\"]\n-pub trait Shl<RHS, Result> {\n+pub trait Shl<RHS> {\n+    type Output;\n+\n     /// The method for the `<<` operator\n-    fn shl(self, rhs: RHS) -> Result;\n+    fn shl(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n-        impl Shl<uint, $t> for $t {\n+        impl Shl<uint> for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn shl(self, other: uint) -> $t {\n                 self << other\n@@ -578,12 +676,16 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shr`, and therefore, `main` prints `Shifting right!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Shr;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Shr<Foo, Foo> for Foo {\n+/// impl Shr<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn shr(self, _rhs: Foo) -> Foo {\n ///         println!(\"Shifting right!\");\n ///         self\n@@ -595,14 +697,18 @@ shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// }\n /// ```\n #[lang=\"shr\"]\n-pub trait Shr<RHS, Result> {\n+pub trait Shr<RHS> {\n+    type Output;\n+\n     /// The method for the `>>` operator\n-    fn shr(self, rhs: RHS) -> Result;\n+    fn shr(self, rhs: RHS) -> Self::Output;\n }\n \n macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n-        impl Shr<uint, $t> for $t {\n+        impl Shr<uint> for $t {\n+            type Output = $t;\n+\n             #[inline]\n             fn shr(self, other: uint) -> $t { self >> other }\n         }\n@@ -611,6 +717,15 @@ macro_rules! shr_impl {\n \n shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n+// NOTE(stage0) remove trait after a snapshot\n+#[cfg(stage0)]\n+#[allow(missing_docs)]\n+#[lang=\"index\"]\n+pub trait Index<Sized? Index, Sized? Result> for Sized? {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    fn index<'a>(&'a self, index: &Index) -> &'a Result;\n+}\n+\n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `arr[idx]` when used in an immutable context.\n ///\n@@ -620,12 +735,16 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `index`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::Index;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl Index<Foo, Foo> for Foo {\n+/// impl Index<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn index<'a>(&'a self, _index: &Foo) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n@@ -636,10 +755,22 @@ shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n ///     Foo[Foo];\n /// }\n /// ```\n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index\"]\n-pub trait Index<Sized? Index, Sized? Result> for Sized? {\n+pub trait Index<Sized? Index> for Sized? {\n+    type Sized? Output;\n+\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    fn index<'a>(&'a self, index: &Index) -> &'a Result;\n+    fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n+}\n+\n+// NOTE(stage0) remove trait after a snapshot\n+#[cfg(stage0)]\n+#[allow(missing_docs)]\n+#[lang=\"index_mut\"]\n+pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n@@ -651,12 +782,16 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n /// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n ///\n /// ```\n+/// #![feature(associated_types)]\n+///\n /// use std::ops::IndexMut;\n ///\n /// #[deriving(Copy)]\n /// struct Foo;\n ///\n-/// impl IndexMut<Foo, Foo> for Foo {\n+/// impl IndexMut<Foo> for Foo {\n+///     type Output = Foo;\n+///\n ///     fn index_mut<'a>(&'a mut self, _index: &Foo) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n@@ -667,10 +802,13 @@ pub trait Index<Sized? Index, Sized? Result> for Sized? {\n ///     &mut Foo[Foo];\n /// }\n /// ```\n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n #[lang=\"index_mut\"]\n-pub trait IndexMut<Sized? Index, Sized? Result> for Sized? {\n+pub trait IndexMut<Sized? Index> for Sized? {\n+    type Sized? Output;\n+\n     /// The method for the indexing (`Foo[Bar]`) operation\n-    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Result;\n+    fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// The `Slice` trait is used to specify the functionality of slicing operations\n@@ -789,7 +927,9 @@ pub struct Range<Idx> {\n \n // FIXME(#19391) needs a snapshot\n //impl<Idx: Clone + Step<T=uint>> Iterator<Idx> for Range<Idx> {\n-impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> Iterator for Range<Idx> {\n+    type Item = Idx;\n+\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n@@ -811,7 +951,7 @@ impl<Idx: Clone + Step> Iterator<Idx> for Range<Idx> {\n     }\n }\n \n-impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n+impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n         if self.start < self.end {\n@@ -823,7 +963,7 @@ impl<Idx: Clone + Step> DoubleEndedIterator<Idx> for Range<Idx> {\n     }\n }\n \n-impl<Idx: Clone + Step> ExactSizeIterator<Idx> for Range<Idx> {}\n+impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n /// A range which is only bounded below.\n #[deriving(Copy)]\n@@ -833,7 +973,9 @@ pub struct RangeFrom<Idx> {\n     pub start: Idx,\n }\n \n-impl<Idx: Clone + Step> Iterator<Idx> for RangeFrom<Idx> {\n+impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n+    type Item = Idx;\n+\n     #[inline]\n     fn next(&mut self) -> Option<Idx> {\n         // Deliberately overflow so we loop forever."}, {"sha": "92209b937d9271da06ba923ee835571c81d478c1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -777,7 +777,9 @@ struct Item<A> {\n     opt: Option<A>\n }\n \n-impl<A> Iterator<A> for Item<A> {\n+impl<A> Iterator for Item<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         self.opt.take()\n@@ -792,32 +794,34 @@ impl<A> Iterator<A> for Item<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for Item<A> {\n+impl<A> DoubleEndedIterator for Item<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         self.opt.take()\n     }\n }\n \n-impl<A> ExactSizeIterator<A> for Item<A> {}\n+impl<A> ExactSizeIterator for Item<A> {}\n \n /// An iterator over a reference of the contained item in an Option.\n #[stable]\n pub struct Iter<'a, A: 'a> { inner: Item<&'a A> }\n \n-impl<'a, A> Iterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> Iterator for Iter<'a, A> {\n+    type Item = &'a A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a A> for Iter<'a, A> {\n+impl<'a, A> DoubleEndedIterator for Iter<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a A> { self.inner.next_back() }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a A> for Iter<'a, A> {}\n+impl<'a, A> ExactSizeIterator for Iter<'a, A> {}\n \n #[stable]\n impl<'a, A> Clone for Iter<'a, A> {\n@@ -830,37 +834,41 @@ impl<'a, A> Clone for Iter<'a, A> {\n #[stable]\n pub struct IterMut<'a, A: 'a> { inner: Item<&'a mut A> }\n \n-impl<'a, A> Iterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> Iterator for IterMut<'a, A> {\n+    type Item = &'a mut A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<'a, A> DoubleEndedIterator<&'a mut A> for IterMut<'a, A> {\n+impl<'a, A> DoubleEndedIterator for IterMut<'a, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut A> { self.inner.next_back() }\n }\n \n-impl<'a, A> ExactSizeIterator<&'a mut A> for IterMut<'a, A> {}\n+impl<'a, A> ExactSizeIterator for IterMut<'a, A> {}\n \n /// An iterator over the item contained inside an Option.\n #[stable]\n pub struct IntoIter<A> { inner: Item<A> }\n \n-impl<A> Iterator<A> for IntoIter<A> {\n+impl<A> Iterator for IntoIter<A> {\n+    type Item = A;\n+\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n-impl<A> DoubleEndedIterator<A> for IntoIter<A> {\n+impl<A> DoubleEndedIterator for IntoIter<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.inner.next_back() }\n }\n \n-impl<A> ExactSizeIterator<A> for IntoIter<A> {}\n+impl<A> ExactSizeIterator for IntoIter<A> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n@@ -887,7 +895,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     #[inline]\n     #[stable]\n-    fn from_iter<I: Iterator<Option<A>>>(iter: I) -> Option<V> {\n+    fn from_iter<I: Iterator<Item=Option<A>>>(iter: I) -> Option<V> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -896,7 +904,9 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n             found_none: bool,\n         }\n \n-        impl<T, Iter: Iterator<Option<T>>> Iterator<T> for Adapter<Iter> {\n+        impl<T, Iter: Iterator<Item=Option<T>>> Iterator for Adapter<Iter> {\n+            type Item = T;\n+\n             #[inline]\n             fn next(&mut self) -> Option<T> {\n                 match self.iter.next() {"}, {"sha": "1355825e56dfda209a1d3999c0947362ee249dcb", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -42,9 +42,9 @@ pub use char::Char;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use iter::{Extend, IteratorExt};\n-pub use iter::{Iterator, DoubleEndedIterator, DoubleEndedIteratorExt};\n+pub use iter::{Iterator, DoubleEndedIterator};\n pub use iter::{IteratorCloneExt, CloneIteratorExt};\n-pub use iter::{IteratorOrdExt, ExactSizeIterator, IteratorPairExt};\n+pub use iter::{IteratorOrdExt, ExactSizeIterator};\n pub use option::Option::{mod, Some, None};\n pub use ptr::{PtrExt, MutPtrExt};\n pub use result::Result::{mod, Ok, Err};"}, {"sha": "b0ee5672e060dafe7f4d27025a024b0498f3a09d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -807,7 +807,9 @@ impl<T, E> AsSlice<T> for Result<T, E> {\n #[stable]\n pub struct Iter<'a, T: 'a> { inner: Option<&'a T> }\n \n-impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> Iterator for Iter<'a, T> {\n+    type Item = &'a T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a T> { self.inner.take() }\n     #[inline]\n@@ -817,12 +819,12 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a T> { self.inner.take() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { Iter { inner: self.inner } }\n@@ -832,7 +834,9 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[stable]\n pub struct IterMut<'a, T: 'a> { inner: Option<&'a mut T> }\n \n-impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut T> { self.inner.take() }\n     #[inline]\n@@ -842,18 +846,20 @@ impl<'a, T> Iterator<&'a mut T> for IterMut<'a, T> {\n     }\n }\n \n-impl<'a, T> DoubleEndedIterator<&'a mut T> for IterMut<'a, T> {\n+impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut T> { self.inner.take() }\n }\n \n-impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An iterator over the value in a `Ok` variant of a `Result`.\n #[stable]\n pub struct IntoIter<T> { inner: Option<T> }\n \n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     #[inline]\n     fn next(&mut self) -> Option<T> { self.inner.take() }\n     #[inline]\n@@ -863,12 +869,12 @@ impl<T> Iterator<T> for IntoIter<T> {\n     }\n }\n \n-impl<T> DoubleEndedIterator<T> for IntoIter<T> {\n+impl<T> DoubleEndedIterator for IntoIter<T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> { self.inner.take() }\n }\n \n-impl<T> ExactSizeIterator<T> for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /////////////////////////////////////////////////////////////////////////////\n // FromIterator\n@@ -894,7 +900,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// assert!(res == Ok(vec!(2u, 3u)));\n     /// ```\n     #[inline]\n-    fn from_iter<I: Iterator<Result<A, E>>>(iter: I) -> Result<V, E> {\n+    fn from_iter<I: Iterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this\n         // performance bug is closed.\n \n@@ -903,7 +909,9 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n             err: Option<E>,\n         }\n \n-        impl<T, E, Iter: Iterator<Result<T, E>>> Iterator<T> for Adapter<Iter, E> {\n+        impl<T, E, Iter: Iterator<Item=Result<T, E>>> Iterator for Adapter<Iter, E> {\n+            type Item = T;\n+\n             #[inline]\n             fn next(&mut self) -> Option<T> {\n                 match self.iter.next() {\n@@ -941,7 +949,7 @@ pub fn fold<T,\n             V,\n             E,\n             F: FnMut(V, T) -> V,\n-            Iter: Iterator<Result<T, E>>>(\n+            Iter: Iterator<Item=Result<T, E>>>(\n             mut iterator: Iter,\n             mut init: V,\n             mut f: F)"}, {"sha": "d5810a382968b29a0c56bbe280a31d3db37b78b5", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -531,6 +531,8 @@ impl<T> SliceExt for [T] {\n     }\n }\n \n+// NOTE(stage0) remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> ops::Index<uint, T> for [T] {\n     fn index(&self, &index: &uint) -> &T {\n         assert!(index < self.len());\n@@ -539,6 +541,19 @@ impl<T> ops::Index<uint, T> for [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n+impl<T> ops::Index<uint> for [T] {\n+    type Output = T;\n+\n+    fn index(&self, &index: &uint) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n+// NOTE(stage0) remove impl after a snapshot\n+#[cfg(stage0)]\n impl<T> ops::IndexMut<uint, T> for [T] {\n     fn index_mut(&mut self, &index: &uint) -> &mut T {\n         assert!(index < self.len());\n@@ -547,6 +562,17 @@ impl<T> ops::IndexMut<uint, T> for [T] {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0) remove cfg after a snapshot\n+impl<T> ops::IndexMut<uint> for [T] {\n+    type Output = T;\n+\n+    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+    }\n+}\n+\n impl<T> ops::Slice<uint, [T]> for [T] {\n     #[inline]\n     fn as_slice_<'a>(&'a self) -> &'a [T] {\n@@ -647,7 +673,9 @@ impl<'a, T> Default for &'a [T] {\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         #[experimental = \"needs review\"]\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+        impl<'a, T> Iterator for $name<'a, T> {\n+            type Item = $elem;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -683,7 +711,7 @@ macro_rules! iterator {\n         }\n \n         #[experimental = \"needs review\"]\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -766,15 +794,15 @@ impl<'a,T> Copy for Iter<'a,T> {}\n iterator!{struct Iter -> *const T, &'a T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a T> for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n \n #[stable]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n+impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n@@ -860,14 +888,14 @@ impl<'a, T> IterMut<'a, T> {\n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[experimental = \"needs review\"]\n-impl<'a, T> ExactSizeIterator<&'a mut T> for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n \n /// An internal abstraction over the splitting iterators, so that\n /// splitn, splitn_mut etc can be implemented once.\n-trait SplitIter<E>: DoubleEndedIterator<E> {\n+trait SplitIter: DoubleEndedIterator {\n     /// Mark the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n-    fn finish(&mut self) -> Option<E>;\n+    fn finish(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n /// An iterator over subslices separated by elements that match a predicate\n@@ -892,7 +920,9 @@ impl<'a, T, P> Clone for Split<'a, T, P> where P: Clone + FnMut(&T) -> bool {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -918,7 +948,7 @@ impl<'a, T, P> Iterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n@@ -934,7 +964,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a [T]> for Split<'a, T, P> where P: FnMut(&\n     }\n }\n \n-impl<'a, T, P> SplitIter<&'a [T]> for Split<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a [T]> {\n         if self.finished { None } else { self.finished = true; Some(self.v) }\n@@ -950,7 +980,7 @@ pub struct SplitMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n     finished: bool\n }\n \n-impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> SplitIter for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     #[inline]\n     fn finish(&mut self) -> Option<&'a mut [T]> {\n         if self.finished {\n@@ -963,7 +993,9 @@ impl<'a, T, P> SplitIter<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T)\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n@@ -996,7 +1028,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for SplitMut<'a, T, P> where P: FnMut(&T) -\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for SplitMut<'a, T, P> where\n+impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n@@ -1029,9 +1061,11 @@ struct GenericSplitN<I> {\n }\n \n #[experimental = \"needs review\"]\n-impl<E, I: SplitIter<E>> Iterator<E> for GenericSplitN<I> {\n+impl<T, I: SplitIter + Iterator<Item=T>> Iterator for GenericSplitN<I> {\n+    type Item = T;\n+\n     #[inline]\n-    fn next(&mut self) -> Option<E> {\n+    fn next(&mut self) -> Option<T> {\n         if self.count == 0 {\n             self.iter.finish()\n         } else {\n@@ -1075,9 +1109,11 @@ pub struct RSplitNMut<'a, T: 'a, P> where P: FnMut(&T) -> bool {\n \n macro_rules! forward_iterator {\n     ($name:ident: $elem:ident, $iter_of:ty) => {\n-        impl<'a, $elem, P> Iterator<$iter_of> for $name<'a, $elem, P> where\n+        impl<'a, $elem, P> Iterator for $name<'a, $elem, P> where\n             P: FnMut(&T) -> bool\n         {\n+            type Item = $iter_of;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$iter_of> {\n                 self.inner.next()\n@@ -1104,7 +1140,9 @@ pub struct Windows<'a, T:'a> {\n     size: uint\n }\n \n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n+impl<'a, T> Iterator for Windows<'a, T> {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.size > self.v.len() {\n@@ -1140,7 +1178,9 @@ pub struct Chunks<'a, T:'a> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> Iterator for Chunks<'a, T> {\n+    type Item = &'a [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -1167,7 +1207,7 @@ impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n@@ -1183,7 +1223,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n+impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n@@ -1213,7 +1253,9 @@ pub struct ChunksMut<'a, T:'a> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n+impl<'a, T> Iterator for ChunksMut<'a, T> {\n+    type Item = &'a mut [T];\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {\n@@ -1241,7 +1283,7 @@ impl<'a, T> Iterator<&'a mut [T]> for ChunksMut<'a, T> {\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for ChunksMut<'a, T> {\n+impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() == 0 {"}, {"sha": "7e99e4236083ec8666b809b4593d975773eadc55", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -21,7 +21,7 @@ use self::Searcher::{Naive, TwoWay, TwoWayLong};\n use cmp::{mod, Eq};\n use default::Default;\n use iter::range;\n-use iter::{DoubleEndedIteratorExt, ExactSizeIterator};\n+use iter::ExactSizeIterator;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use kinds::Sized;\n use mem;\n@@ -37,7 +37,7 @@ use uint;\n macro_rules! delegate_iter {\n     (exact $te:ty in $ti:ty) => {\n         delegate_iter!{$te in $ti}\n-        impl<'a> ExactSizeIterator<$te> for $ti {\n+        impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n             fn rposition<P>(&mut self, predicate: P) -> Option<uint> where P: FnMut($te) -> bool{\n                 self.0.rposition(predicate)\n@@ -49,7 +49,9 @@ macro_rules! delegate_iter {\n         }\n     };\n     ($te:ty in $ti:ty) => {\n-        impl<'a> Iterator<$te> for $ti {\n+        impl<'a> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -59,15 +61,17 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        impl<'a> DoubleEndedIterator<$te> for $ti {\n+        impl<'a> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n                 self.0.next_back()\n             }\n         }\n     };\n     (pattern $te:ty in $ti:ty) => {\n-        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+        impl<'a, P: CharEq> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -77,15 +81,17 @@ macro_rules! delegate_iter {\n                 self.0.size_hint()\n             }\n         }\n-        impl<'a, P: CharEq> DoubleEndedIterator<$te> for $ti {\n+        impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n                 self.0.next_back()\n             }\n         }\n     };\n     (pattern forward $te:ty in $ti:ty) => {\n-        impl<'a, P: CharEq> Iterator<$te> for $ti {\n+        impl<'a, P: CharEq> Iterator for $ti {\n+            type Item = $te;\n+\n             #[inline]\n             fn next(&mut self) -> Option<$te> {\n                 self.0.next()\n@@ -275,7 +281,9 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n     }\n }\n \n-impl<'a> Iterator<char> for Chars<'a> {\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = char;\n+\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         // Decode UTF-8, using the valid UTF-8 invariant\n@@ -318,7 +326,7 @@ impl<'a> Iterator<char> for Chars<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<char> for Chars<'a> {\n+impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         let w = match self.iter.next_back() {\n@@ -359,7 +367,9 @@ pub struct CharIndices<'a> {\n     iter: Chars<'a>,\n }\n \n-impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n+impl<'a> Iterator for CharIndices<'a> {\n+    type Item = (uint, char);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n@@ -380,7 +390,7 @@ impl<'a> Iterator<(uint, char)> for CharIndices<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, char)> for CharIndices<'a> {\n+impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         match self.iter.next_back() {\n@@ -463,7 +473,9 @@ impl<'a, Sep> CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -495,8 +507,7 @@ impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n-for CharSplits<'a, Sep> {\n+impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -537,7 +548,9 @@ for CharSplits<'a, Sep> {\n     }\n }\n \n-impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitsN<'a, Sep> {\n+impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n@@ -864,7 +877,9 @@ pub struct SplitStr<'a> {\n #[deprecated = \"Type is now named `SplitStr`\"]\n pub type StrSplits<'a> = SplitStr<'a>;\n \n-impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n+impl<'a> Iterator for MatchIndices<'a> {\n+    type Item = (uint, uint);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         match self.searcher {\n@@ -878,7 +893,9 @@ impl<'a> Iterator<(uint, uint)> for MatchIndices<'a> {\n     }\n }\n \n-impl<'a> Iterator<&'a str> for SplitStr<'a> {\n+impl<'a> Iterator for SplitStr<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None; }\n@@ -1672,23 +1689,27 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n-impl<'a> Iterator<&'a str> for Lines<'a> {\n+impl<'a> Iterator for Lines<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a> DoubleEndedIterator<&'a str> for Lines<'a> {\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }\n-impl<'a> Iterator<&'a str> for LinesAny<'a> {\n+impl<'a> Iterator for LinesAny<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n-impl<'a> DoubleEndedIterator<&'a str> for LinesAny<'a> {\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }"}, {"sha": "b53791f694480dd3b77cab9a6a26393f1361745b", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -561,7 +561,9 @@ fn test_rposition_panic() {\n \n \n #[cfg(test)]\n-fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+fn check_randacc_iter<A, T>(a: T, len: uint) where\n+    A: PartialEq,\n+    T: Clone + RandomAccessIterator + Iterator<Item=A>,\n {\n     let mut b = a.clone();\n     assert_eq!(len, b.indexable());"}, {"sha": "274b4cee3ba1282c948d62f7715d2672a2bf9b6e", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -31,9 +31,9 @@ mod uint;\n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq + NumCast\n-     + Add<T, T> + Sub<T, T>\n-     + Mul<T, T> + Div<T, T>\n-     + Rem<T, T> + Show\n+     + Add<Output=T> + Sub<Output=T>\n+     + Mul<Output=T> + Div<Output=T>\n+     + Rem<Output=T> + Show\n      + Copy\n {\n     assert_eq!(ten.add(two),  cast(12i).unwrap());"}, {"sha": "ecb657b5a2ba5853e784d1bf0523cf508d52544d", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -24,6 +24,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(macro_rules, globs, slicing_syntax)]\n+#![feature(associated_types)]\n \n pub use self::Piece::*;\n pub use self::Position::*;\n@@ -142,7 +143,9 @@ pub struct Parser<'a> {\n     pub errors: Vec<string::String>,\n }\n \n-impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n+impl<'a> Iterator for Parser<'a> {\n+    type Item = Piece<'a>;\n+\n     fn next(&mut self) -> Option<Piece<'a>> {\n         match self.cur.clone().next() {\n             Some((pos, '{')) => {"}, {"sha": "901dffc04c5e9369243517f787b5624992763d5e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -124,7 +124,7 @@ impl<'b,T> AsSlice<T> for MaybeOwnedVector<'b,T> {\n \n impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n     #[allow(deprecated)]\n-    fn from_iter<I:Iterator<T>>(iterator: I) -> MaybeOwnedVector<'a,T> {\n+    fn from_iter<I:Iterator<Item=T>>(iterator: I) -> MaybeOwnedVector<'a,T> {\n         // If we are building from scratch, might as well build the\n         // most flexible variant.\n         Growable(iterator.collect())"}, {"sha": "0f8dbc78cde3272c8ee62d2da768f1e16abeb65f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -25,6 +25,7 @@\n \n #![feature(macro_rules, phase, globs)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n #![no_std]\n #![experimental]\n \n@@ -314,7 +315,9 @@ pub struct Generator<'a, T, R:'a> {\n     rng: &'a mut R,\n }\n \n-impl<'a, T: Rand, R: Rng> Iterator<T> for Generator<'a, T, R> {\n+impl<'a, T: Rand, R: Rng> Iterator for Generator<'a, T, R> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         Some(self.rng.gen())\n     }\n@@ -327,7 +330,9 @@ pub struct AsciiGenerator<'a, R:'a> {\n     rng: &'a mut R,\n }\n \n-impl<'a, R: Rng> Iterator<char> for AsciiGenerator<'a, R> {\n+impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n+    type Item = char;\n+\n     fn next(&mut self) -> Option<char> {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] =\n             b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\"}, {"sha": "c546477ee0152f1a9002d5941e58b1e9de161bdd", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -373,6 +373,7 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "69c58eebd56d05ea5023e2bf69576d6f247ad90b", "filename": "src/libregex/re.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -546,7 +546,9 @@ pub enum NamesIter<'a> {\n     NamesIterDynamic(::std::slice::Iter<'a, Option<String>>)\n }\n \n-impl<'a> Iterator<Option<String>> for NamesIter<'a> {\n+impl<'a> Iterator for NamesIter<'a> {\n+    type Item = Option<String>;\n+\n     fn next(&mut self) -> Option<Option<String>> {\n         match *self {\n             NamesIterNative(ref mut i) => i.next().map(|x| x.map(|s| s.to_string())),\n@@ -603,7 +605,9 @@ pub struct RegexSplits<'r, 't> {\n     last: uint,\n }\n \n-impl<'r, 't> Iterator<&'t str> for RegexSplits<'r, 't> {\n+impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         let text = self.finder.search;\n         match self.finder.next() {\n@@ -638,7 +642,9 @@ pub struct RegexSplitsN<'r, 't> {\n     limit: uint,\n }\n \n-impl<'r, 't> Iterator<&'t str> for RegexSplitsN<'r, 't> {\n+impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         let text = self.splits.finder.search;\n         if self.cur >= self.limit {\n@@ -801,7 +807,9 @@ pub struct SubCaptures<'t> {\n     caps: &'t Captures<'t>,\n }\n \n-impl<'t> Iterator<&'t str> for SubCaptures<'t> {\n+impl<'t> Iterator for SubCaptures<'t> {\n+    type Item = &'t str;\n+\n     fn next(&mut self) -> Option<&'t str> {\n         if self.idx < self.caps.len() {\n             self.idx += 1;\n@@ -824,7 +832,9 @@ pub struct SubCapturesPos<'t> {\n     caps: &'t Captures<'t>,\n }\n \n-impl<'t> Iterator<Option<(uint, uint)>> for SubCapturesPos<'t> {\n+impl<'t> Iterator for SubCapturesPos<'t> {\n+    type Item = Option<(uint, uint)>;\n+\n     fn next(&mut self) -> Option<Option<(uint, uint)>> {\n         if self.idx < self.caps.len() {\n             self.idx += 1;\n@@ -850,7 +860,9 @@ pub struct FindCaptures<'r, 't> {\n     last_end: uint,\n }\n \n-impl<'r, 't> Iterator<Captures<'t>> for FindCaptures<'r, 't> {\n+impl<'r, 't> Iterator for FindCaptures<'r, 't> {\n+    type Item = Captures<'t>;\n+\n     fn next(&mut self) -> Option<Captures<'t>> {\n         if self.last_end > self.search.len() {\n             return None\n@@ -893,7 +905,9 @@ pub struct FindMatches<'r, 't> {\n     last_end: uint,\n }\n \n-impl<'r, 't> Iterator<(uint, uint)> for FindMatches<'r, 't> {\n+impl<'r, 't> Iterator for FindMatches<'r, 't> {\n+    type Item = (uint, uint);\n+\n     fn next(&mut self) -> Option<(uint, uint)> {\n         if self.last_end > self.search.len() {\n             return None"}, {"sha": "ebd1cc7e166d71e17cb7e4335c693f8c18b0c0c1", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -603,7 +603,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n     fn vec_expr<T, It, F>(&self, xs: It, mut to_expr: F) -> P<ast::Expr> where\n-        It: Iterator<T>,\n+        It: Iterator<Item=T>,\n         F: FnMut(&ExtCtxt, T) -> P<ast::Expr>,\n     {\n         let exprs = xs.map(|x| to_expr(self.cx, x)).collect();"}, {"sha": "122171e469108639178925a2e70b62b716bb075c", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "17663a127a881ed7c62dc9daf3553697a6ce9539", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -364,7 +364,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem>>(rbml_w: &mut Encoder, path: PI) {\n+fn encode_path<PI: Iterator<Item=PathElem>>(rbml_w: &mut Encoder, path: PI) {\n     let path = path.collect::<Vec<_>>();\n     rbml_w.start_tag(tag_path);\n     rbml_w.wr_tagged_u32(tag_path_len, path.len() as u32);"}, {"sha": "a7b28a6323eaff7e09d43f18e6180bbad77b1003", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -150,7 +150,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<'b, I: Iterator<&'b P<ast::Pat>>>(&mut self,\n+    fn pats_all<'b, I: Iterator<Item=&'b P<ast::Pat>>>(&mut self,\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n@@ -501,7 +501,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn call<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n+    fn call<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n             call_expr: &ast::Expr,\n             pred: CFGIndex,\n             func_or_rcvr: &ast::Expr,\n@@ -521,7 +521,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n+    fn exprs<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n                                              exprs: I,\n                                              pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline<'b, I: Iterator<&'b ast::Expr>>(&mut self,\n+    fn straightline<'b, I: Iterator<Item=&'b ast::Expr>>(&mut self,\n                     expr: &ast::Expr,\n                     pred: CFGIndex,\n                     subexprs: I) -> CFGIndex {"}, {"sha": "74f25332ecf312cf0afb724aea9bebaf724de8cd", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -92,7 +92,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n }\n \n impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n-    fn from_iter<T: Iterator<Vec<&'a Pat>>>(iterator: T) -> Matrix<'a> {\n+    fn from_iter<T: Iterator<Item=Vec<&'a Pat>>>(iterator: T) -> Matrix<'a> {\n         Matrix(iterator.collect())\n     }\n }"}, {"sha": "96b2a62326b17f13b62ee280c50f9f95ec002d44", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -81,7 +81,7 @@ pub fn join(a: constness, b: constness) -> constness {\n     }\n }\n \n-pub fn join_all<It: Iterator<constness>>(cs: It) -> constness {\n+pub fn join_all<It: Iterator<Item=constness>>(cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n "}, {"sha": "e8efdda3888a71aee027fde148870e56112920fa", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -305,7 +305,9 @@ pub struct DepthFirstTraversal<'g, N:'g, E:'g> {\n     visited: BitvSet\n }\n \n-impl<'g, N, E> Iterator<&'g N> for DepthFirstTraversal<'g, N, E> {\n+impl<'g, N, E> Iterator for DepthFirstTraversal<'g, N, E> {\n+    type Item = &'g N;\n+\n     fn next(&mut self) -> Option<&'g N> {\n         while let Some(idx) = self.stack.pop() {\n             if !self.visited.insert(idx.node_id()) {"}, {"sha": "e7971a82119ecfa8b2a515b92b7e5e904b8a5127", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -494,7 +494,9 @@ impl<'a,T> EnumeratedItems<'a,T> {\n     }\n }\n \n-impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n+impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n+    type Item = (ParamSpace, uint, &'a T);\n+\n     fn next(&mut self) -> Option<(ParamSpace, uint, &'a T)> {\n         let spaces = ParamSpace::all();\n         if self.space_index < spaces.len() {"}, {"sha": "c6fccab95a4ca9cd1a51173c53fdba61b376cd2b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -292,7 +292,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                 stack: Option<&TraitObligationStack<'o, 'tcx>>,\n                                                 mut predicates: I)\n                                                 -> EvaluationResult<'tcx>\n-        where I : Iterator<&'a PredicateObligation<'tcx>>, 'tcx:'a\n+        where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n@@ -2310,9 +2310,9 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     }\n }\n \n-impl<'o, 'tcx> Iterator<&'o TraitObligationStack<'o,'tcx>>\n-           for Option<&'o TraitObligationStack<'o, 'tcx>>\n-{\n+impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n+    type Item = &'o TraitObligationStack<'o,'tcx>;\n+\n     fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n         match *self {\n             Some(o) => {"}, {"sha": "e4578f74763298c4740e35b0bbb71782f319e49c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -133,7 +133,9 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> Iterator<ty::Predicate<'tcx>> for Elaborator<'cx, 'tcx> {\n+impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n+    type Item = ty::Predicate<'tcx>;\n+\n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n@@ -197,7 +199,9 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n-impl<'cx, 'tcx> Iterator<ty::PolyTraitRef<'tcx>> for Supertraits<'cx, 'tcx> {\n+impl<'cx, 'tcx> Iterator for Supertraits<'cx, 'tcx> {\n+    type Item = ty::PolyTraitRef<'tcx>;\n+\n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         loop {\n             match self.elaborator.next() {"}, {"sha": "20ded8ad0e0c1a80b527c8d840bf546a5ed39676", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -3259,19 +3259,25 @@ impl TypeContents {\n     }\n }\n \n-impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n+impl ops::BitOr for TypeContents {\n+    type Output = TypeContents;\n+\n     fn bitor(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n-impl ops::BitAnd<TypeContents, TypeContents> for TypeContents {\n+impl ops::BitAnd for TypeContents {\n+    type Output = TypeContents;\n+\n     fn bitand(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & other.bits}\n     }\n }\n \n-impl ops::Sub<TypeContents, TypeContents> for TypeContents {\n+impl ops::Sub for TypeContents {\n+    type Output = TypeContents;\n+\n     fn sub(self, other: TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}\n     }\n@@ -3740,10 +3746,10 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n                                    -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<'tcx, It: Iterator<Ty<'tcx>>>(cx: &ctxt<'tcx>, sp: Span,\n-                                                           seen: &mut Vec<Ty<'tcx>>,\n-                                                           iter: It)\n-                                                           -> Representability {\n+    fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &ctxt<'tcx>, sp: Span,\n+                                                                seen: &mut Vec<Ty<'tcx>>,\n+                                                                iter: It)\n+                                                                -> Representability {\n         iter.fold(Representable,\n                   |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n     }"}, {"sha": "12df36c10fc097780d0ac72398112bafca607ce7", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -94,7 +94,9 @@ impl<'tcx> TypeWalker<'tcx> {\n     }\n }\n \n-impl<'tcx> Iterator<Ty<'tcx>> for TypeWalker<'tcx> {\n+impl<'tcx> Iterator for TypeWalker<'tcx> {\n+    type Item = Ty<'tcx>;\n+\n     fn next(&mut self) -> Option<Ty<'tcx>> {\n         debug!(\"next(): stack={}\", self.stack);\n         match self.stack.pop() {"}, {"sha": "14ea2d3d33a267fba12fc72cad6b67a40226e9c2", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -53,7 +53,9 @@ impl SearchPaths {\n     }\n }\n \n-impl<'a> Iterator<&'a Path> for Iter<'a> {\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = &'a Path;\n+\n     fn next(&mut self) -> Option<&'a Path> {\n         loop {\n             match self.iter.next() {"}, {"sha": "9a993de098ea427176b28289d478006dcae3839c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -26,6 +26,7 @@\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "561099550cee3942452713dc3d8d556f8ea8a921", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -345,7 +345,9 @@ enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast>),\n }\n \n-impl<'a, 'ast> Iterator<ast::NodeId> for NodesMatchingUII<'a, 'ast> {\n+impl<'a, 'ast> Iterator for NodesMatchingUII<'a, 'ast> {\n+    type Item = ast::NodeId;\n+\n     fn next(&mut self) -> Option<ast::NodeId> {\n         match self {\n             &NodesMatchingDirect(ref mut iter) => iter.next(),"}, {"sha": "c3c97616ea83848e284df523b0ca9b15c108a052", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -266,7 +266,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n+pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n                                       hash: Option<&str>) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info."}, {"sha": "9dbff66aba2864518a24e484751ef50e796a68f9", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -28,6 +28,7 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "225f6f116dae32d9f7654aec93dd733d621dee4e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -3072,7 +3072,9 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n         step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n     }\n \n-    impl Iterator<ValueRef> for ValueIter {\n+    impl Iterator for ValueIter {\n+        type Item = ValueRef;\n+\n         fn next(&mut self) -> Option<ValueRef> {\n             let old = self.cur;\n             if !old.is_null() {"}, {"sha": "67aecde66189198b6fe4bc0eab0d4f88d0f1bef2", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -168,7 +168,9 @@ pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     index: uint,\n }\n \n-impl<'a, 'tcx> Iterator<CrateContext<'a, 'tcx>> for CrateContextIterator<'a,'tcx> {\n+impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n+    type Item = CrateContext<'a, 'tcx>;\n+\n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;\n@@ -193,7 +195,9 @@ pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n     origin: uint,\n }\n \n-impl<'a, 'tcx> Iterator<(CrateContext<'a, 'tcx>, bool)> for CrateContextMaybeIterator<'a, 'tcx> {\n+impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n+    type Item = (CrateContext<'a, 'tcx>, bool);\n+\n     fn next(&mut self) -> Option<(CrateContext<'a, 'tcx>, bool)> {\n         if self.index >= self.shared.local_ccxs.len() {\n             return None;"}, {"sha": "f0588b3082ab6fe3a774edcfc2c8b22db3c9ce03", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -727,7 +727,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable<I: Iterator<ValueRef>>(ccx: &CrateContext,\n+pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n                                           drop_glue: ValueRef,\n                                           size: ValueRef,\n                                           align: ValueRef,"}, {"sha": "028e2154303e23db409a03e10eb84ff9ee9859a6", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -155,7 +155,9 @@ pub struct Users {\n     next: Option<Use>\n }\n \n-impl Iterator<Value> for Users {\n+impl Iterator for Users {\n+    type Item = Value;\n+\n     fn next(&mut self) -> Option<Value> {\n         let current = self.next;\n "}, {"sha": "7f1feb9365a8f70f409985285545fe59154010c6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -2543,7 +2543,6 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     let input_ty = fcx.infcx().next_ty_var();\n-    let return_ty = fcx.infcx().next_ty_var();\n \n     // Try `IndexMut` first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.index_mut_trait()) {\n@@ -2555,7 +2554,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              trait_did,\n                                              adjustment.clone(),\n                                              adjusted_ty,\n-                                             Some(vec![input_ty, return_ty]))\n+                                             Some(vec![input_ty]))\n         }\n         _ => None,\n     };\n@@ -2570,17 +2569,17 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                              trait_did,\n                                              adjustment,\n                                              adjusted_ty,\n-                                             Some(vec![input_ty, return_ty]))\n+                                             Some(vec![input_ty]))\n         }\n         (method, _) => method,\n     };\n \n     // If some lookup succeeds, write callee into table and extract index/element\n     // type from the method signature.\n     // If some lookup succeeded, install method in table\n-    method.map(|method| {\n-        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n-        (input_ty, return_ty)\n+    method.and_then(|method| {\n+        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method)).\n+            map(|ret| (input_ty, ret.ty))\n     })\n }\n "}, {"sha": "6b5f08e22ddabf9feb514f23d76df0a8046583ab", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -922,11 +922,11 @@ fn constrain_callee(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n-                                                  call_expr: &ast::Expr,\n-                                                  receiver: Option<&ast::Expr>,\n-                                                  mut arg_exprs: I,\n-                                                  implicitly_ref_args: bool) {\n+fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n+                                                       call_expr: &ast::Expr,\n+                                                       receiver: Option<&ast::Expr>,\n+                                                       mut arg_exprs: I,\n+                                                       implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n     //! in the type of the function. Also constrains the regions that"}, {"sha": "8c2cb557c1c9d545cec51501f633c5d899ab688b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -428,7 +428,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n-                                 where I: Iterator<&'i ast::Method> {\n+                                 where I: Iterator<Item=&'i ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));"}, {"sha": "cc5b1f635e370b2e797521b90c62e0e4ae7e353e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -104,9 +104,6 @@ use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n use syntax::ast_util::local_def;\n \n-#[cfg(stage0)]\n-mod diagnostics;\n-\n mod check;\n mod rscope;\n mod astconv;"}, {"sha": "f0feb8de1cefa87ccd05327c75de00cc37bd43d4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -21,6 +21,7 @@\n #![feature(globs, macro_rules, phase, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "0d6d7a47c857975758f517089bf91878f487f663", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -41,7 +41,9 @@ pub struct Counts {\n     pub unmarked: uint,\n }\n \n-impl Add<Counts, Counts> for Counts {\n+impl Add for Counts {\n+    type Output = Counts;\n+\n     fn add(self, other: Counts) -> Counts {\n         Counts {\n             deprecated:   self.deprecated   + other.deprecated,"}, {"sha": "71117c7fe128fe2cb28e715cd79b45c1ba1289b4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1123,12 +1123,25 @@ impl Json {\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl<'a> ops::Index<&'a str, Json>  for Json {\n     fn index(&self, idx: & &str) -> &Json {\n         self.find(*idx).unwrap()\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl<'a> ops::Index<&'a str>  for Json {\n+    type Output = Json;\n+\n+    fn index(&self, idx: & &str) -> &Json {\n+        self.find(*idx).unwrap()\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n impl ops::Index<uint, Json> for Json {\n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n@@ -1138,6 +1151,18 @@ impl ops::Index<uint, Json> for Json {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+impl ops::Index<uint> for Json {\n+    type Output = Json;\n+\n+    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n+        match self {\n+            &Json::Array(ref v) => v.index(idx),\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[deriving(PartialEq, Clone, Show)]\n pub enum JsonEvent {\n@@ -1324,7 +1349,9 @@ pub struct Parser<T> {\n     state: ParserState,\n }\n \n-impl<T: Iterator<char>> Iterator<JsonEvent> for Parser<T> {\n+impl<T: Iterator<Item=char>> Iterator for Parser<T> {\n+    type Item = JsonEvent;\n+\n     fn next(&mut self) -> Option<JsonEvent> {\n         if self.state == ParseFinished {\n             return None;\n@@ -1345,7 +1372,7 @@ impl<T: Iterator<char>> Iterator<JsonEvent> for Parser<T> {\n     }\n }\n \n-impl<T: Iterator<char>> Parser<T> {\n+impl<T: Iterator<Item=char>> Parser<T> {\n     /// Creates the JSON parser.\n     pub fn new(rdr: T) -> Parser<T> {\n         let mut p = Parser {\n@@ -1867,7 +1894,7 @@ pub struct Builder<T> {\n     token: Option<JsonEvent>,\n }\n \n-impl<T: Iterator<char>> Builder<T> {\n+impl<T: Iterator<Item=char>> Builder<T> {\n     /// Create a JSON Builder.\n     pub fn new(src: T) -> Builder<T> {\n         Builder { parser: Parser::new(src), token: None, }"}, {"sha": "1ec6a2af309a7eaa113c96f21ecedf363ccdac14", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -25,6 +25,7 @@ Core encoding and decoding interfaces.\n #![allow(unknown_features)]\n #![feature(macro_rules, default_type_params, phase, slicing_syntax, globs)]\n #![feature(unboxed_closures)]\n+#![feature(associated_types)]\n \n // test harness access\n #[cfg(test)]"}, {"sha": "16bc6b16598e046c90949dcfde7e6b5d5692a943", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -209,39 +209,49 @@ macro_rules! bitflags {\n             }\n         }\n \n-        impl ::std::ops::BitOr<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitOr for $BitFlags {\n+            type Output = $BitFlags;\n+\n             /// Returns the union of the two sets of flags.\n             #[inline]\n             fn bitor(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits | other.bits }\n             }\n         }\n \n-        impl ::std::ops::BitXor<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitXor for $BitFlags {\n+            type Output = $BitFlags;\n+\n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n             fn bitxor(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits ^ other.bits }\n             }\n         }\n \n-        impl ::std::ops::BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::BitAnd for $BitFlags {\n+            type Output = $BitFlags;\n+\n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n             fn bitand(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits & other.bits }\n             }\n         }\n \n-        impl ::std::ops::Sub<$BitFlags, $BitFlags> for $BitFlags {\n+        impl ::std::ops::Sub for $BitFlags {\n+            type Output = $BitFlags;\n+\n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n             fn sub(self, other: $BitFlags) -> $BitFlags {\n                 $BitFlags { bits: self.bits & !other.bits }\n             }\n         }\n \n-        impl ::std::ops::Not<$BitFlags> for $BitFlags {\n+        impl ::std::ops::Not for $BitFlags {\n+            type Output = $BitFlags;\n+\n             /// Returns the complement of this set of flags.\n             #[inline]\n             fn not(self) -> $BitFlags {"}, {"sha": "834a9f082d03a5bd24be835120bf53f45231a467", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -504,7 +504,9 @@ pub struct CChars<'a> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-impl<'a> Iterator<libc::c_char> for CChars<'a> {\n+impl<'a> Iterator for CChars<'a> {\n+    type Item = libc::c_char;\n+\n     fn next(&mut self) -> Option<libc::c_char> {\n         let ch = unsafe { *self.ptr };\n         if ch == 0 {"}, {"sha": "f246e9df3b9870b4b6f10cf2bbf2baf9aa81feba", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1300,6 +1300,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n     }\n }\n \n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n@@ -1310,6 +1312,21 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q, V> for HashMap<K, V\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, index: &Q) -> &'a V {\n+        self.get(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n+// NOTE(stage0): remove impl after a snapshot\n+#[cfg(stage0)]\n #[stable]\n impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K, V, H>\n     where Q: BorrowFrom<K> + Hash<S> + Eq\n@@ -1320,6 +1337,19 @@ impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q, V> for HashMap<K\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[stable]\n+impl<K: Hash<S> + Eq, Sized? Q, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n+    where Q: BorrowFrom<K> + Hash<S> + Eq\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n+        self.get_mut(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// HashMap iterator\n #[stable]\n pub struct Iter<'a, K: 'a, V: 'a> {\n@@ -1423,37 +1453,49 @@ enum VacantEntryState<K, V, M> {\n }\n \n #[stable]\n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n+impl<'a, K, V> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable]\n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n+impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n+\n     #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable]\n-impl<K, V> Iterator<(K, V)> for IntoIter<K, V> {\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (K, V);\n+\n     #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable]\n-impl<'a, K, V> Iterator<&'a K> for Keys<'a, K, V> {\n+impl<'a, K, V> Iterator for Keys<'a, K, V> {\n+    type Item = &'a K;\n+\n     #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable]\n-impl<'a, K, V> Iterator<&'a V> for Values<'a, K, V> {\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n     #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n     #[inline] fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable]\n-impl<'a, K: 'a, V: 'a> Iterator<(K, V)> for Drain<'a, K, V> {\n+impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n+    type Item = (K, V);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n         self.inner.next()\n@@ -1511,7 +1553,7 @@ impl<'a, K, V> VacantEntry<'a, K, V> {\n \n #[stable]\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n-    fn from_iter<T: Iterator<(K, V)>>(iter: T) -> HashMap<K, V, H> {\n+    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, H> {\n         let lower = iter.size_hint().0;\n         let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n         map.extend(iter);\n@@ -1521,7 +1563,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for Has\n \n #[stable]\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Extend<(K, V)> for HashMap<K, V, H> {\n-    fn extend<T: Iterator<(K, V)>>(&mut self, mut iter: T) {\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }"}, {"sha": "4c6a74a78d5106b9a64bea3f1b84d5e33f35b0d4", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -603,7 +603,7 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n \n #[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n-    fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, H> {\n         let lower = iter.size_hint().0;\n         let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n         set.extend(iter);\n@@ -613,7 +613,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T,\n \n #[stable]\n impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extend<T> for HashSet<T, H> {\n-    fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);\n         }\n@@ -630,7 +630,9 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n \n #[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitOr<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n+BitOr<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n+    type Output = HashSet<T, H>;\n+\n     /// Returns the union of `self` and `rhs` as a new `HashSet<T, H>`.\n     ///\n     /// # Examples\n@@ -658,7 +660,9 @@ BitOr<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n \n #[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitAnd<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n+BitAnd<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n+    type Output = HashSet<T, H>;\n+\n     /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, H>`.\n     ///\n     /// # Examples\n@@ -686,7 +690,9 @@ BitAnd<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n \n #[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitXor<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n+BitXor<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n+    type Output = HashSet<T, H>;\n+\n     /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, H>`.\n     ///\n     /// # Examples\n@@ -714,7 +720,9 @@ BitXor<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n \n #[stable]\n impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-Sub<&'b HashSet<T, H>, HashSet<T, H>> for &'a HashSet<T, H> {\n+Sub<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n+    type Output = HashSet<T, H>;\n+\n     /// Returns the difference of `self` and `rhs` as a new `HashSet<T, H>`.\n     ///\n     /// # Examples\n@@ -789,27 +797,35 @@ pub struct Union<'a, T: 'a, H: 'a> {\n }\n \n #[stable]\n-impl<'a, K> Iterator<&'a K> for Iter<'a, K> {\n+impl<'a, K> Iterator for Iter<'a, K> {\n+    type Item = &'a K;\n+\n     fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n-impl<K> Iterator<K> for IntoIter<K> {\n+impl<K> Iterator for IntoIter<K> {\n+    type Item = K;\n+\n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n-impl<'a, K: 'a> Iterator<K> for Drain<'a, K> {\n+impl<'a, K: 'a> Iterator for Drain<'a, K> {\n+    type Item = K;\n+\n     fn next(&mut self) -> Option<K> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n-impl<'a, T, S, H> Iterator<&'a T> for Intersection<'a, T, H>\n+impl<'a, T, S, H> Iterator for Intersection<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n@@ -828,9 +844,11 @@ impl<'a, T, S, H> Iterator<&'a T> for Intersection<'a, T, H>\n }\n \n #[stable]\n-impl<'a, T, S, H> Iterator<&'a T> for Difference<'a, T, H>\n+impl<'a, T, S, H> Iterator for Difference<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match self.iter.next() {\n@@ -849,17 +867,21 @@ impl<'a, T, S, H> Iterator<&'a T> for Difference<'a, T, H>\n }\n \n #[stable]\n-impl<'a, T, S, H> Iterator<&'a T> for SymmetricDifference<'a, T, H>\n+impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n #[stable]\n-impl<'a, T, S, H> Iterator<&'a T> for Union<'a, T, H>\n+impl<'a, T, S, H> Iterator for Union<'a, T, H>\n     where T: Eq + Hash<S>, H: Hasher<S>\n {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }"}, {"sha": "2b999d83a98c284e5d492aab06ec2a89e8ffe52a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -730,7 +730,9 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n }\n \n \n-impl<'a, K, V> Iterator<RawBucket<K, V>> for RawBuckets<'a, K, V> {\n+impl<'a, K, V> Iterator for RawBuckets<'a, K, V> {\n+    type Item = RawBucket<K, V>;\n+\n     fn next(&mut self) -> Option<RawBucket<K, V>> {\n         while self.raw.hash != self.hashes_end {\n             unsafe {\n@@ -757,7 +759,9 @@ struct RevMoveBuckets<'a, K, V> {\n     marker: marker::ContravariantLifetime<'a>,\n }\n \n-impl<'a, K, V> Iterator<(K, V)> for RevMoveBuckets<'a, K, V> {\n+impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n+    type Item = (K, V);\n+\n     fn next(&mut self) -> Option<(K, V)> {\n         if self.elems_left == 0 {\n             return None;\n@@ -816,7 +820,9 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     iter: RawBuckets<'static, K, V>,\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n+impl<'a, K, V> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n     fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n@@ -832,7 +838,9 @@ impl<'a, K, V> Iterator<(&'a K, &'a V)> for Iter<'a, K, V> {\n     }\n }\n \n-impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n+impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n+\n     fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         self.iter.next().map(|bucket| {\n             self.elems_left -= 1;\n@@ -848,7 +856,9 @@ impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for IterMut<'a, K, V> {\n     }\n }\n \n-impl<K, V> Iterator<(SafeHash, K, V)> for IntoIter<K, V> {\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (SafeHash, K, V);\n+\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n         self.iter.next().map(|bucket| {\n             self.table.size -= 1;\n@@ -870,7 +880,9 @@ impl<K, V> Iterator<(SafeHash, K, V)> for IntoIter<K, V> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Iterator<(SafeHash, K, V)> for Drain<'a, K, V> {\n+impl<'a, K: 'a, V: 'a> Iterator for Drain<'a, K, V> {\n+    type Item = (SafeHash, K, V);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n         self.iter.next().map(|bucket| {"}, {"sha": "8c097a65db7bd45d51aa739567dc22812c982d30", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -52,7 +52,9 @@ impl<'r, R: Reader> Bytes<'r, R> {\n     }\n }\n \n-impl<'r, R: Reader> Iterator<IoResult<u8>> for Bytes<'r, R> {\n+impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n+    type Item = IoResult<u8>;\n+\n     #[inline]\n     fn next(&mut self) -> Option<IoResult<u8>> {\n         match self.reader.read_byte() {"}, {"sha": "1ff54fcb4843201f471da952e485debd793c13c4", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -563,7 +563,9 @@ pub struct Directories {\n     stack: Vec<Path>,\n }\n \n-impl Iterator<Path> for Directories {\n+impl Iterator for Directories {\n+    type Item = Path;\n+\n     fn next(&mut self) -> Option<Path> {\n         match self.stack.pop() {\n             Some(path) => {"}, {"sha": "917ffa4ff76dab5a2dfdd47c22a8bb4598cd2e39", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 8, "deletions": 24, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1036,7 +1036,6 @@ pub trait Writer {\n             error: IoResult<()>,\n         }\n \n-        #[cfg(not(stage0))]\n         impl<'a, Sized? T: Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n                 match self.inner.write(s.as_bytes()) {\n@@ -1049,19 +1048,6 @@ pub trait Writer {\n             }\n         }\n \n-        #[cfg(stage0)]\n-        impl<'a, T: Writer> fmt::Writer for Adaptor<'a, T> {\n-            fn write_str(&mut self, s: &str) -> fmt::Result {\n-                match self.inner.write(s.as_bytes()) {\n-                    Ok(()) => Ok(()),\n-                    Err(e) => {\n-                        self.error = Err(e);\n-                        Err(fmt::Error)\n-                    }\n-                }\n-            }\n-        }\n-\n         let mut output = Adaptor { inner: self, error: Ok(()) };\n         match fmt::write(&mut output, fmt) {\n             Ok(()) => Ok(()),\n@@ -1371,7 +1357,9 @@ pub struct Lines<'r, T:'r> {\n     buffer: &'r mut T,\n }\n \n-impl<'r, T: Buffer> Iterator<IoResult<String>> for Lines<'r, T> {\n+impl<'r, T: Buffer> Iterator for Lines<'r, T> {\n+    type Item = IoResult<String>;\n+\n     fn next(&mut self) -> Option<IoResult<String>> {\n         match self.buffer.read_line() {\n             Ok(x) => Some(Ok(x)),\n@@ -1398,7 +1386,9 @@ pub struct Chars<'r, T:'r> {\n     buffer: &'r mut T\n }\n \n-impl<'r, T: Buffer> Iterator<IoResult<char>> for Chars<'r, T> {\n+impl<'r, T: Buffer> Iterator for Chars<'r, T> {\n+    type Item = IoResult<char>;\n+\n     fn next(&mut self) -> Option<IoResult<char>> {\n         match self.buffer.read_char() {\n             Ok(x) => Some(Ok(x)),\n@@ -1648,15 +1638,9 @@ pub struct IncomingConnections<'a, Sized? A:'a> {\n     inc: &'a mut A,\n }\n \n-#[cfg(stage0)]\n-impl<'a, T, A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n-    fn next(&mut self) -> Option<IoResult<T>> {\n-        Some(self.inc.accept())\n-    }\n-}\n+impl<'a, T, Sized? A: Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n+    type Item = IoResult<T>;\n \n-#[cfg(not(stage0))]\n-impl<'a, T, Sized? A: Acceptor<T>> Iterator<IoResult<T>> for IncomingConnections<'a, A> {\n     fn next(&mut self) -> Option<IoResult<T>> {\n         Some(self.inc.accept())\n     }"}, {"sha": "51d1bacf63b9f28b2a0a61fb2b2ee230835b862f", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -169,15 +169,15 @@ pub struct ChainedReader<I, R> {\n     cur_reader: Option<R>,\n }\n \n-impl<R: Reader, I: Iterator<R>> ChainedReader<I, R> {\n+impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n     /// Creates a new `ChainedReader`\n     pub fn new(mut readers: I) -> ChainedReader<I, R> {\n         let r = readers.next();\n         ChainedReader { readers: readers, cur_reader: r }\n     }\n }\n \n-impl<R: Reader, I: Iterator<R>> Reader for ChainedReader<I, R> {\n+impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         loop {\n             let err = match self.cur_reader {\n@@ -252,15 +252,15 @@ pub struct IterReader<T> {\n     iter: T,\n }\n \n-impl<T: Iterator<u8>> IterReader<T> {\n+impl<T: Iterator<Item=u8>> IterReader<T> {\n     /// Creates a new `IterReader` which will read from the specified\n     /// `Iterator`.\n     pub fn new(iter: T) -> IterReader<T> {\n         IterReader { iter: iter }\n     }\n }\n \n-impl<T: Iterator<u8>> Reader for IterReader<T> {\n+impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         let mut len = 0;"}, {"sha": "007d89a942dcca5ca29528e69639fbd63a848818", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -127,9 +127,9 @@ pub fn abs_sub<T: FloatMath>(x: T, y: T) -> T {\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq + NumCast\n-     + Add<T, T> + Sub<T, T>\n-     + Mul<T, T> + Div<T, T>\n-     + Rem<T, T> + Show\n+     + Add<Output=T> + Sub<Output=T>\n+     + Mul<Output=T> + Div<Output=T>\n+     + Rem<Output=T> + Show\n      + Copy\n {\n     assert_eq!(ten.add(two),  cast(12i).unwrap());"}, {"sha": "39b96ef6aeea0e7ef0346562fdcd890f24a8a642", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -15,7 +15,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use hash;\n use io::Writer;\n-use iter::{DoubleEndedIteratorExt, AdditiveIterator, Extend};\n+use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n use option::Option;\n use option::Option::{None, Some};\n@@ -449,7 +449,7 @@ mod tests {\n     use super::*;\n \n     use clone::Clone;\n-    use iter::{IteratorExt, DoubleEndedIteratorExt};\n+    use iter::IteratorExt;\n     use option::Option::{mod, Some, None};\n     use path::GenericPath;\n     use slice::{AsSlice, SliceExt};"}, {"sha": "f6fb149e82cf68f0201678745e2f8e4ffc26e748", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -20,7 +20,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use hash;\n use io::Writer;\n-use iter::{AdditiveIterator, DoubleEndedIteratorExt, Extend};\n+use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n@@ -1124,7 +1124,7 @@ mod tests {\n     use super::*;\n \n     use clone::Clone;\n-    use iter::{IteratorExt, DoubleEndedIteratorExt};\n+    use iter::IteratorExt;\n     use option::Option::{mod, Some, None};\n     use path::GenericPath;\n     use slice::{AsSlice, SliceExt};"}, {"sha": "1fbd17ede08f2f70a5630b72ba815f48a82c5836", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -35,8 +35,5 @@\n //! pervasive that it would be obnoxious to import for every use, particularly\n //! those that define methods on primitive types.\n \n-#[cfg(stage0)]\n-pub use self::v1::*;\n-\n #[stable]\n pub mod v1;"}, {"sha": "2d2f3f895d0c1f20b86087f4f896c0972ad83640", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -27,11 +27,9 @@\n #[stable] #[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable] #[doc(no_inline)] pub use iter::CloneIteratorExt;\n #[stable] #[doc(no_inline)] pub use iter::DoubleEndedIterator;\n-#[stable] #[doc(no_inline)] pub use iter::DoubleEndedIteratorExt;\n #[stable] #[doc(no_inline)] pub use iter::ExactSizeIterator;\n #[stable] #[doc(no_inline)] pub use iter::{Iterator, IteratorExt, Extend};\n #[stable] #[doc(no_inline)] pub use iter::{IteratorCloneExt, IteratorOrdExt};\n-#[stable] #[doc(no_inline)] pub use iter::IteratorPairExt;\n #[stable] #[doc(no_inline)] pub use option::Option::{mod, Some, None};\n #[stable] #[doc(no_inline)] pub use ptr::{PtrExt, MutPtrExt};\n #[stable] #[doc(no_inline)] pub use result::Result::{mod, Ok, Err};"}, {"sha": "208e4f9e566f42ec74f4ced40517519e91338ed2", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -404,7 +404,7 @@ pub fn random<T: Rand>() -> T {\n /// let sample = sample(&mut rng, range(1i, 100), 5);\n /// println!(\"{}\", sample);\n /// ```\n-pub fn sample<T, I: Iterator<T>, R: Rng>(rng: &mut R,\n+pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n                                          mut iter: I,\n                                          amount: uint) -> Vec<T> {\n     let mut reservoir: Vec<T> = iter.by_ref().take(amount).collect();"}, {"sha": "e9dc3d986ba115940a9b4a521a37f772cddb2885", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -936,7 +936,9 @@ impl<T: Send> select::Packet for Receiver<T> {\n }\n \n #[unstable]\n-impl<'a, T: Send> Iterator<T> for Iter<'a, T> {\n+impl<'a, T: Send> Iterator for Iter<'a, T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n "}, {"sha": "3d9dca7e21cb3d499b0903fe9416e27d1932e303", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -319,7 +319,9 @@ impl<'rx, T: Send> Drop for Handle<'rx, T> {\n     }\n }\n \n-impl Iterator<*mut Handle<'static, ()>> for Packets {\n+impl Iterator for Packets {\n+    type Item = *mut Handle<'static, ()>;\n+\n     fn next(&mut self) -> Option<*mut Handle<'static, ()>> {\n         if self.cur.is_null() {\n             None"}, {"sha": "41a130492c0470601970d74e7c86d8d20016bcc5", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -262,7 +262,9 @@ impl Duration {\n     }\n }\n \n-impl Neg<Duration> for Duration {\n+impl Neg for Duration {\n+    type Output = Duration;\n+\n     #[inline]\n     fn neg(self) -> Duration {\n         if self.nanos == 0 {\n@@ -273,7 +275,9 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n-impl Add<Duration, Duration> for Duration {\n+impl Add for Duration {\n+    type Output = Duration;\n+\n     fn add(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n         let mut nanos = self.nanos + rhs.nanos;\n@@ -285,7 +289,9 @@ impl Add<Duration, Duration> for Duration {\n     }\n }\n \n-impl Sub<Duration, Duration> for Duration {\n+impl Sub for Duration {\n+    type Output = Duration;\n+\n     fn sub(self, rhs: Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n         let mut nanos = self.nanos - rhs.nanos;\n@@ -297,7 +303,9 @@ impl Sub<Duration, Duration> for Duration {\n     }\n }\n \n-impl Mul<i32, Duration> for Duration {\n+impl Mul<i32> for Duration {\n+    type Output = Duration;\n+\n     fn mul(self, rhs: i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n         let total_nanos = self.nanos as i64 * rhs as i64;\n@@ -307,7 +315,9 @@ impl Mul<i32, Duration> for Duration {\n     }\n }\n \n-impl Div<i32, Duration> for Duration {\n+impl Div<i32> for Duration {\n+    type Output = Duration;\n+\n     fn div(self, rhs: i32) -> Duration {\n         let mut secs = self.secs / rhs as i64;\n         let carry = self.secs - secs * rhs as i64;"}, {"sha": "b1799fc2718ff905b093e9243cc970c68bd7d4bc", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -61,7 +61,9 @@ struct LinkedPathNode<'a> {\n \n type LinkedPath<'a> = Option<&'a LinkedPathNode<'a>>;\n \n-impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n+impl<'a> Iterator for LinkedPath<'a> {\n+    type Item = PathElem;\n+\n     fn next(&mut self) -> Option<PathElem> {\n         match *self {\n             Some(node) => {\n@@ -77,7 +79,9 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n #[deriving(Clone)]\n pub struct Values<'a, T:'a>(pub slice::Iter<'a, T>);\n \n-impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n+impl<'a, T: Copy> Iterator for Values<'a, T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         let &Values(ref mut items) = self;\n         items.next().map(|&x| x)\n@@ -87,7 +91,7 @@ impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n /// The type of the iterator used by with_path.\n pub type PathElems<'a, 'b> = iter::Chain<Values<'a, PathElem>, LinkedPath<'b>>;\n \n-pub fn path_to_string<PI: Iterator<PathElem>>(path: PI) -> String {\n+pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n     let itr = token::get_ident_interner();\n \n     path.fold(String::new(), |mut s, e| {\n@@ -629,7 +633,9 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     }\n }\n \n-impl<'a, 'ast> Iterator<NodeId> for NodesMatchingSuffix<'a, 'ast> {\n+impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n+    type Item = NodeId;\n+\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;"}, {"sha": "92818f063416060ff464c668edc14262bdab826c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -359,7 +359,7 @@ pub enum StabilityLevel {\n \n pub fn find_stability_generic<'a,\n                               AM: AttrMetaMethods,\n-                              I: Iterator<&'a AM>>\n+                              I: Iterator<Item=&'a AM>>\n                              (mut attrs: I)\n                              -> Option<(Stability, &'a AM)> {\n     for attr in attrs {"}, {"sha": "eb011faa55dc8e6636da5c47b4ade2fcfe2e6020", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -53,13 +53,17 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n-impl Add<BytePos, BytePos> for BytePos {\n+impl Add for BytePos {\n+    type Output = BytePos;\n+\n     fn add(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n-impl Sub<BytePos, BytePos> for BytePos {\n+impl Sub for BytePos {\n+    type Output = BytePos;\n+\n     fn sub(self, rhs: BytePos) -> BytePos {\n         BytePos((self.to_uint() - rhs.to_uint()) as u32)\n     }\n@@ -70,13 +74,17 @@ impl Pos for CharPos {\n     fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n-impl Add<CharPos, CharPos> for CharPos {\n+impl Add for CharPos {\n+    type Output = CharPos;\n+\n     fn add(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n-impl Sub<CharPos, CharPos> for CharPos {\n+impl Sub for CharPos {\n+    type Output = CharPos;\n+\n     fn sub(self, rhs: CharPos) -> CharPos {\n         CharPos(self.to_uint() - rhs.to_uint())\n     }"}, {"sha": "e56194c95cd5b07f5accacf99beff09ae3b99bd4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -220,7 +220,7 @@ pub struct MacItems {\n }\n \n impl MacItems {\n-    pub fn new<I: Iterator<P<ast::Item>>>(it: I) -> Box<MacResult+'static> {\n+    pub fn new<I: Iterator<Item=P<ast::Item>>>(it: I) -> Box<MacResult+'static> {\n         box MacItems { items: it.collect() } as Box<MacResult+'static>\n     }\n }"}, {"sha": "8af5e952e9a11096ea416ff75506bd1440290fcc", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -106,7 +106,9 @@ enum LockstepIterSize {\n     LisContradiction(String),\n }\n \n-impl Add<LockstepIterSize, LockstepIterSize> for LockstepIterSize {\n+impl Add for LockstepIterSize {\n+    type Output = LockstepIterSize;\n+\n     fn add(self, other: LockstepIterSize) -> LockstepIterSize {\n         match self {\n             LisUnconstrained => other,"}, {"sha": "38c26e8967140c7c353b80eb9ef5e5c63adca9cb", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -77,7 +77,7 @@ impl<T: Clone> Clone for OwnedSlice<T> {\n }\n \n impl<T> FromIterator<T> for OwnedSlice<T> {\n-    fn from_iter<I: Iterator<T>>(iter: I) -> OwnedSlice<T> {\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> OwnedSlice<T> {\n         OwnedSlice::from_vec(iter.collect())\n     }\n }"}, {"sha": "8598571e5c37a7f41cebe2aeb1942da2a1968387", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -598,7 +598,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a, I: Iterator<(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {\n+    fn eat<'a, I: Iterator<Item=(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {"}, {"sha": "b68c9926391d70b2808c113e66e39bc0fd400127", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -30,15 +30,15 @@ enum SmallVectorRepr<T> {\n }\n \n impl<T> FromIterator<T> for SmallVector<T> {\n-    fn from_iter<I: Iterator<T>>(iter: I) -> SmallVector<T> {\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> SmallVector<T> {\n         let mut v = SmallVector::zero();\n         v.extend(iter);\n         v\n     }\n }\n \n impl<T> Extend<T> for SmallVector<T> {\n-    fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n+    fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n         for val in iter {\n             self.push(val);\n         }\n@@ -147,7 +147,9 @@ enum IntoIterRepr<T> {\n     ManyIterator(vec::IntoIter<T>),\n }\n \n-impl<T> Iterator<T> for IntoIter<T> {\n+impl<T> Iterator for IntoIter<T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         match self.repr {\n             ZeroIterator => None,"}, {"sha": "e8ab1b548433bffd63b4ab0e2d9f32ebadfb4f09", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -438,7 +438,7 @@ pub fn write_boxplot<W: Writer, T: Float + Show + FromPrimitive>(\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n-pub fn freq_count<T: Iterator<U>, U: Eq+Hash>(mut iter: T) -> hash_map::HashMap<U, uint> {\n+pub fn freq_count<T: Iterator<Item=U>, U: Eq+Hash>(mut iter: T) -> hash_map::HashMap<U, uint> {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {\n         match map.entry(elem) {"}, {"sha": "7603d84848c9f06abda455d721ee568b24cce4d6", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -24,6 +24,8 @@\n #![allow(unknown_features)]\n #![feature(phase, globs)]\n #![feature(old_orphan_check)]\n+#![feature(associated_types)]\n+#![feature(default_type_params)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n \n@@ -100,7 +102,9 @@ impl Timespec {\n     }\n }\n \n-impl Add<Duration, Timespec> for Timespec {\n+impl Add<Duration> for Timespec {\n+    type Output = Timespec;\n+\n     fn add(self, other: Duration) -> Timespec {\n         let d_sec = other.num_seconds();\n         // It is safe to unwrap the nanoseconds, because there cannot be\n@@ -120,7 +124,9 @@ impl Add<Duration, Timespec> for Timespec {\n     }\n }\n \n-impl Sub<Timespec, Duration> for Timespec {\n+impl Sub for Timespec {\n+    type Output = Duration;\n+\n     fn sub(self, other: Timespec) -> Duration {\n         let sec = self.sec - other.sec;\n         let nsec = self.nsec - other.nsec;"}, {"sha": "eabe044ce3b7178616adb90f2685aabed9d0a975", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -29,6 +29,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![feature(globs, macro_rules, slicing_syntax, unboxed_closures)]\n+#![feature(associated_types)]\n \n extern crate core;\n "}, {"sha": "8ec90acb711f08f1ccef6019b3db39ddb192ee59", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -105,7 +105,9 @@ pub struct GraphemeIndices<'a> {\n     iter: Graphemes<'a>,\n }\n \n-impl<'a> Iterator<(uint, &'a str)> for GraphemeIndices<'a> {\n+impl<'a> Iterator for GraphemeIndices<'a> {\n+    type Item = (uint, &'a str);\n+\n     #[inline]\n     fn next(&mut self) -> Option<(uint, &'a str)> {\n         self.iter.next().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n@@ -117,7 +119,7 @@ impl<'a> Iterator<(uint, &'a str)> for GraphemeIndices<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<(uint, &'a str)> for GraphemeIndices<'a> {\n+impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, &'a str)> {\n         self.iter.next_back().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n@@ -145,7 +147,9 @@ enum GraphemeState {\n     Regional,\n }\n \n-impl<'a> Iterator<&'a str> for Graphemes<'a> {\n+impl<'a> Iterator for Graphemes<'a> {\n+    type Item = &'a str;\n+\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let slen = self.string.len();\n@@ -251,7 +255,7 @@ impl<'a> Iterator<&'a str> for Graphemes<'a> {\n     }\n }\n \n-impl<'a> DoubleEndedIterator<&'a str> for Graphemes<'a> {\n+impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         use tables::grapheme as gr;\n@@ -428,7 +432,9 @@ impl Utf16Item {\n     }\n }\n \n-impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n+impl<'a> Iterator for Utf16Items<'a> {\n+    type Item = Utf16Item;\n+\n     fn next(&mut self) -> Option<Utf16Item> {\n         let u = match self.iter.next() {\n             Some(u) => *u,\n@@ -505,12 +511,14 @@ pub struct Utf16Encoder<I> {\n \n impl<I> Utf16Encoder<I> {\n     /// Create an UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<char> {\n+    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<Item=char> {\n         Utf16Encoder { chars: chars, extra: 0 }\n     }\n }\n \n-impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n+impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n+    type Item = u16;\n+\n     #[inline]\n     fn next(&mut self) -> Option<u16> {\n         if self.extra != 0 {\n@@ -537,9 +545,11 @@ impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n     }\n }\n \n-impl<'a> Iterator<&'a str> for Words<'a> {\n+impl<'a> Iterator for Words<'a> {\n+    type Item = &'a str;\n+\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n }\n-impl<'a> DoubleEndedIterator<&'a str> for Words<'a> {\n+impl<'a> DoubleEndedIterator for Words<'a> {\n     fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n }"}, {"sha": "c72fd7978f88588f4dfcf8e43a1059f7c2a984ea", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-02 c894171\n+  freebsd-x86_64 ea8bcf75eada3539f5cbab51708eecf40d436b77\n+  linux-i386 646ae265721e3cbe19404aae4fea4ffa1f1d90cf\n+  linux-x86_64 85183ce0724af3dfb7616b9e81a4e5510415f351\n+  macos-i386 b3eced7fc5e78f767edb4595dfcde02dad206f3f\n+  macos-x86_64 36418bce8c18f1b49ec6b5aec2bf35ff1cd833a3\n+  winnt-i386 6c7ddf23b389be723d34ab91a9baa4a06c5f9571\n+  winnt-x86_64 d086d4019d603db09166d0609a21da8ee8fe306a\n+\n S 2015-01-01 7d4f487\n   freebsd-x86_64 5dc87adb17bc33abc08f1bf4c092e0b5b92a6ca4\n   linux-i386 63bf82a5b540d8acbbf1e445ce48be0fa0f003fc"}, {"sha": "41572998b58a418ed213fb98e9761f1d629ffdde", "filename": "src/test/auxiliary/issue-16643.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Fissue-16643.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-16643.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_type = \"lib\"]\n+#![feature(associated_types)]\n \n pub struct TreeBuilder<H>;\n \n@@ -20,7 +21,9 @@ impl<H> TreeBuilder<H> {\n     }\n }\n \n-impl<H> Iterator<H> for TreeBuilder<H> {\n+impl<H> Iterator for TreeBuilder<H> {\n+    type Item = H;\n+\n     fn next(&mut self) -> Option<H> {\n         None\n     }"}, {"sha": "1a2f429c9ebc1c31b32d2923d1ec915b304458b9", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -26,7 +26,7 @@ impl<T> Foo {\n \n // issue 8134\n pub struct Parser<T>;\n-impl<T: std::iter::Iterator<char>> Parser<T> {\n+impl<T: std::iter::Iterator<Item=char>> Parser<T> {\n     fn in_doctype(&mut self) {\n         static DOCTYPEPattern: [char; 6] = ['O', 'C', 'T', 'Y', 'P', 'E'];\n     }"}, {"sha": "7394373e9229bb61d5b58befd0b4ea96d590dc51", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,26 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::cmp::PartialEq;\n use std::ops::{Add, Sub, Mul};\n \n-pub trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq + Clone {\n+pub trait MyNum : Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + PartialEq + Clone {\n }\n \n #[derive(Clone, Show)]\n pub struct MyInt {\n     pub val: int\n }\n \n-impl Add<MyInt, MyInt> for MyInt {\n+impl Add for MyInt {\n+    type Output = MyInt;\n+\n     fn add(self, other: MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n-impl Sub<MyInt, MyInt> for MyInt {\n+impl Sub for MyInt {\n+    type Output = MyInt;\n+\n     fn sub(self, other: MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n-impl Mul<MyInt, MyInt> for MyInt {\n+impl Mul for MyInt {\n+    type Output = MyInt;\n+\n     fn mul(self, other: MyInt) -> MyInt { mi(self.val * other.val) }\n }\n "}, {"sha": "4bc45caa170e4eee4e1c46d19db61bd01ffa7c7a", "filename": "src/test/auxiliary/unboxed-closures-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -21,7 +21,7 @@ pub fn has_closures() -> uint {\n     f() + g()\n }\n \n-pub fn has_generic_closures<T: Add<T,T> + Copy>(x: T, y: T) -> T {\n+pub fn has_generic_closures<T: Add<Output=T> + Copy>(x: T, y: T) -> T {\n     let mut f = move |&mut:| x;\n     let g = |:| y;\n     f() + g()"}, {"sha": "eee42af4dbc769db2a476761885218746a588ded", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -38,7 +38,7 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(slicing_syntax)]\n+#![feature(associated_types, slicing_syntax)]\n \n use std::cmp::min;\n use std::io::{BufferedWriter, File};\n@@ -75,7 +75,9 @@ impl<'a> AAGen<'a> {\n         AAGen { rng: rng, data: data }\n     }\n }\n-impl<'a> Iterator<u8> for AAGen<'a> {\n+impl<'a> Iterator for AAGen<'a> {\n+    type Item = u8;\n+\n     fn next(&mut self) -> Option<u8> {\n         let r = self.rng.gen();\n         self.data.iter()\n@@ -85,7 +87,7 @@ impl<'a> Iterator<u8> for AAGen<'a> {\n     }\n }\n \n-fn make_fasta<W: Writer, I: Iterator<u8>>(\n+fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n     wr: &mut W, header: &str, mut it: I, mut n: uint)\n     -> std::io::IoResult<()>\n {"}, {"sha": "df5baac7dbe4e728a762319fc9e8733fadb8cb17", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax)]\n+#![feature(associated_types, slicing_syntax)]\n \n use std::ascii::OwnedAsciiExt;\n use std::slice;\n@@ -194,7 +194,9 @@ impl Table {\n     }\n }\n \n-impl<'a> Iterator<&'a Entry> for Items<'a> {\n+impl<'a> Iterator for Items<'a> {\n+    type Item = &'a Entry;\n+\n     fn next(&mut self) -> Option<&'a Entry> {\n         let ret = match self.cur {\n             None => {"}, {"sha": "94d99b9f118f73bf9f4b98f214fa6340d1cf1ac4", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -40,6 +40,8 @@\n \n // no-pretty-expanded FIXME #15189\n \n+#![feature(associated_types)]\n+\n use std::sync::mpsc::channel;\n use std::sync::Arc;\n use std::thread::Thread;\n@@ -57,7 +59,9 @@ struct Iterate<'a, T> {\n     f: |&T|: 'a -> T,\n     next: T\n }\n-impl<'a, T> Iterator<T> for Iterate<'a, T> {\n+impl<'a, T> Iterator for Iterate<'a, T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         let mut res = (self.f)(&self.next);\n         std::mem::swap(&mut res, &mut self.next);\n@@ -78,7 +82,9 @@ impl<'a, T> List<'a, T> {\n         ListIterator{cur: self}\n     }\n }\n-impl<'a, T> Iterator<&'a T> for ListIterator<'a, T> {\n+impl<'a, T> Iterator for ListIterator<'a, T> {\n+    type Item = &'a T;\n+\n     fn next(&mut self) -> Option<&'a T> {\n         match *self.cur {\n             List::Nil => None,"}, {"sha": "4e60c2bee44469c59fa8f8c5c5ad20384aac4645", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax, unboxed_closures)]\n+#![feature(associated_types, slicing_syntax, unboxed_closures)]\n \n extern crate libc;\n \n@@ -150,7 +150,9 @@ struct MutDnaSeqs<'a> { s: &'a mut [u8] }\n fn mut_dna_seqs<'a>(s: &'a mut [u8]) -> MutDnaSeqs<'a> {\n     MutDnaSeqs { s: s }\n }\n-impl<'a> Iterator<&'a mut [u8]> for MutDnaSeqs<'a> {\n+impl<'a> Iterator for MutDnaSeqs<'a> {\n+    type Item = &'a mut [u8];\n+\n     fn next(&mut self) -> Option<&'a mut [u8]> {\n         let tmp = std::mem::replace(&mut self.s, &mut []);\n         let tmp = match memchr(tmp, b'\\n') {\n@@ -229,7 +231,7 @@ unsafe impl<T: 'static> Send for Racy<T> {}\n /// The closure `f` is run in parallel with an element of `iter`.\n fn parallel<'a, I, T, F>(mut iter: I, f: F)\n         where T: 'a+Send + Sync,\n-              I: Iterator<&'a mut [T]>,\n+              I: Iterator<Item=&'a mut [T]>,\n               F: Fn(&mut [T]) + Sync {\n     use std::mem;\n     use std::raw::Repr;"}, {"sha": "930000e5f0c3746f3733440e8d301219305e5a44", "filename": "src/test/compile-fail/binop-consume-args.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-consume-args.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,63 +10,65 @@\n \n // Test that binary operators consume their arguments\n \n+#![feature(associated_types, default_type_params)]\n+\n use std::ops::{Add, Sub, Mul, Div, Rem, BitAnd, BitXor, BitOr, Shl, Shr};\n \n-fn add<A: Add<B, ()>, B>(lhs: A, rhs: B) {\n+fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs + rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn sub<A: Sub<B, ()>, B>(lhs: A, rhs: B) {\n+fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs - rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn mul<A: Mul<B, ()>, B>(lhs: A, rhs: B) {\n+fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs * rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn div<A: Div<B, ()>, B>(lhs: A, rhs: B) {\n+fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs / rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn rem<A: Rem<B, ()>, B>(lhs: A, rhs: B) {\n+fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs % rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn bitand<A: BitAnd<B, ()>, B>(lhs: A, rhs: B) {\n+fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs & rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn bitor<A: BitOr<B, ()>, B>(lhs: A, rhs: B) {\n+fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs | rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn bitxor<A: BitXor<B, ()>, B>(lhs: A, rhs: B) {\n+fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs ^ rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn shl<A: Shl<B, ()>, B>(lhs: A, rhs: B) {\n+fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs << rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`\n }\n \n-fn shr<A: Shr<B, ()>, B>(lhs: A, rhs: B) {\n+fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n     lhs >> rhs;\n     drop(lhs);  //~ ERROR use of moved value: `lhs`\n     drop(rhs);  //~ ERROR use of moved value: `rhs`"}, {"sha": "e51ca6a70f28b9739c4414b0bf2037aaafa61740", "filename": "src/test/compile-fail/binop-move-semantics.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbinop-move-semantics.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,21 +10,23 @@\n \n // Test that move restrictions are enforced on overloaded binary operations\n \n+#![feature(associated_types, default_type_params)]\n+\n use std::ops::Add;\n \n-fn double_move<T: Add<T, ()>>(x: T) {\n+fn double_move<T: Add<Output=()>>(x: T) {\n     x\n     +\n     x;  //~ ERROR: use of moved value\n }\n \n-fn move_then_borrow<T: Add<T, ()> + Clone>(x: T) {\n+fn move_then_borrow<T: Add<Output=()> + Clone>(x: T) {\n     x\n     +\n     x.clone();  //~ ERROR: use of moved value\n }\n \n-fn move_borrowed<T: Add<T, ()>>(x: T, mut y: T) {\n+fn move_borrowed<T: Add<Output=()>>(x: T, mut y: T) {\n     let m = &x;\n     let n = &mut y;\n \n@@ -33,7 +35,7 @@ fn move_borrowed<T: Add<T, ()>>(x: T, mut y: T) {\n     y;  //~ ERROR: cannot move out of `y` because it is borrowed\n }\n \n-fn illegal_dereference<T: Add<T, ()>>(mut x: T, y: T) {\n+fn illegal_dereference<T: Add<Output=()>>(mut x: T, y: T) {\n     let m = &mut x;\n     let n = &y;\n \n@@ -44,11 +46,15 @@ fn illegal_dereference<T: Add<T, ()>>(mut x: T, y: T) {\n \n struct Foo;\n \n-impl<'a, 'b> Add<&'b Foo, ()> for &'a mut Foo {\n+impl<'a, 'b> Add<&'b Foo> for &'a mut Foo {\n+    type Output = ();\n+\n     fn add(self, _: &Foo) {}\n }\n \n-impl<'a, 'b> Add<&'b mut Foo, ()> for &'a Foo {\n+impl<'a, 'b> Add<&'b mut Foo> for &'a Foo {\n+    type Output = ();\n+\n     fn add(self, _: &mut Foo) {}\n }\n "}, {"sha": "141dd8905bece30cd99e8db1ecc7726d8e18598c", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Add;\n \n #[derive(Clone)]\n struct foo(Box<uint>);\n \n-impl Add<foo, foo> for foo {\n+impl Add for foo {\n+    type Output = foo;\n+\n     fn add(self, f: foo) -> foo {\n         let foo(box i) = self;\n         let foo(box j) = f;"}, {"sha": "e0a961e5cc5fcd4ac7f2e4fa29fbc6bd4f1d2679", "filename": "src/test/compile-fail/borrowck-loan-rcvr-overloaded-op.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr-overloaded-op.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types, default_type_params)]\n+\n use std::ops::Add;\n \n #[derive(Copy)]\n@@ -16,7 +18,9 @@ struct Point {\n     y: int,\n }\n \n-impl Add<int, int> for Point {\n+impl Add<int> for Point {\n+    type Output = int;\n+\n     fn add(self, z: int) -> int {\n         self.x + self.y + z\n     }"}, {"sha": "87e647d16ddf84861910671b4391c30cb41d4647", "filename": "src/test/compile-fail/borrowck-overloaded-index-2.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::Index;\n \n struct MyVec<T> {\n     data: Vec<T>,\n }\n \n-impl<T> Index<uint, T> for MyVec<T> {\n+impl<T> Index<uint> for MyVec<T> {\n+    type Output = T;\n+\n     fn index(&self, &i: &uint) -> &T {\n         &self.data[i]\n     }"}, {"sha": "e7bd7cdf0b79de2be624f24f04589d85aea334f1", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,14 +11,18 @@\n // Test that we still see borrowck errors of various kinds when using\n // indexing and autoderef in combination.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Index, IndexMut};\n \n struct Foo {\n     x: int,\n     y: int,\n }\n \n-impl Index<String,int> for Foo {\n+impl Index<String> for Foo {\n+    type Output = int;\n+\n     fn index<'a>(&'a self, z: &String) -> &'a int {\n         if z.as_slice() == \"x\" {\n             &self.x\n@@ -28,7 +32,9 @@ impl Index<String,int> for Foo {\n     }\n }\n \n-impl IndexMut<String,int> for Foo {\n+impl IndexMut<String> for Foo {\n+    type Output = int;\n+\n     fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut int {\n         if z.as_slice() == \"x\" {\n             &mut self.x"}, {"sha": "532f32ce770a6bbe280ee2e051c626c32d9d96ee", "filename": "src/test/compile-fail/borrowck-overloaded-index.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Index, IndexMut};\n \n struct Foo {\n     x: int,\n     y: int,\n }\n \n-impl Index<String,int> for Foo {\n+impl Index<String> for Foo {\n+    type Output = int;\n+\n     fn index<'a>(&'a self, z: &String) -> &'a int {\n         if z.as_slice() == \"x\" {\n             &self.x\n@@ -25,7 +29,9 @@ impl Index<String,int> for Foo {\n     }\n }\n \n-impl IndexMut<String,int> for Foo {\n+impl IndexMut<String> for Foo {\n+    type Output = int;\n+\n     fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut int {\n         if z.as_slice() == \"x\" {\n             &mut self.x\n@@ -39,7 +45,9 @@ struct Bar {\n     x: int,\n }\n \n-impl Index<int,int> for Bar {\n+impl Index<int> for Bar {\n+    type Output = int;\n+\n     fn index<'a>(&'a self, z: &int) -> &'a int {\n         &self.x\n     }"}, {"sha": "06d20c3361bc96e17c2d2e16383eeac183cc69e9", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,14 +11,18 @@\n // Test that overloaded index expressions with DST result types\n // can't be used as rvalues\n \n+#![feature(associated_types)]\n+\n use std::ops::Index;\n use std::fmt::Show;\n \n struct S;\n \n impl Copy for S {}\n \n-impl Index<uint, str> for S {\n+impl Index<uint> for S {\n+    type Output = str;\n+\n     fn index<'a>(&'a self, _: &uint) -> &'a str {\n         \"hello\"\n     }\n@@ -28,7 +32,9 @@ struct T;\n \n impl Copy for T {}\n \n-impl Index<uint, Show + 'static> for T {\n+impl Index<uint> for T {\n+    type Output = Show + 'static;\n+\n     fn index<'a>(&'a self, idx: &uint) -> &'a (Show + 'static) {\n         static x: uint = 42;\n         &x"}, {"sha": "8dda54efc06af31ba57089d4467604791c3d2ee9", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,7 +10,7 @@\n \n use std::iter::{Range,range};\n \n-trait Itble<'r, T, I: Iterator<T>> { fn iter(&'r self) -> I; }\n+trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n     fn iter(&'r self) -> Range<uint> {\n@@ -19,8 +19,8 @@ impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n     }\n }\n \n-fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool\n-//~^ HELP as shown: fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &'r T) -> bool\n+fn check<'r, I: Iterator<Item=uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool\n+//~^ HELP as shown: fn check<'r, I: Iterator<Item = uint>, T: Itble<'r, uint, I>>(cont: &'r T)\n {\n     let cont_iter = cont.iter();\n //~^ ERROR cannot infer an appropriate lifetime for autoref due to conflicting requirements"}, {"sha": "509ca9b80f81ff3d157680d7614f418617d0f170", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -13,11 +13,11 @@ trait Node {\n }\n \n trait Graph<N: Node> {\n-    fn nodes<'a, I: Iterator<&'a N>>(&'a self) -> I;\n+    fn nodes<'a, I: Iterator<Item=&'a N>>(&'a self) -> I;\n }\n \n impl<N: Node> Graph<N> for Vec<N> {\n-    fn nodes<'a, I: Iterator<&'a N>>(&self) -> I {\n+    fn nodes<'a, I: Iterator<Item=&'a N>>(&self) -> I {\n         self.iter() //~ ERROR mismatched types\n     }\n }"}, {"sha": "b688cafb67459aab05c1701e8eb6968083c9c430", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n trait vec_monad<A> {\n     fn bind<B>(&self, f: |A| -> Vec<B> );\n }"}, {"sha": "7d91b1998bf24b000f4deac8cc9c014c2b0b18ad", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -12,7 +12,7 @@\n \n use std::iter::{Range,range};\n \n-trait Itble<'r, T, I: Iterator<T>> { fn iter(&'r self) -> I; }\n+trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n     fn iter(&'r self) -> Range<uint> {\n@@ -21,8 +21,8 @@ impl<'r> Itble<'r, uint, Range<uint>> for (uint, uint) {\n     }\n }\n \n-fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool {\n-//~^ HELP: consider using an explicit lifetime parameter as shown: fn check<'r, I: Iterator<uint>, T: Itble<'r, uint, I>>(cont: &'r T) -> bool\n+fn check<'r, I: Iterator<Item=uint>, T: Itble<'r, uint, I>>(cont: &T) -> bool {\n+//~^ HELP: consider using an explicit lifetime parameter as shown: fn check<'r, I: Iterator<Item = uint>, T: Itble<'r, uint, I>>(cont: &'r T)\n     let cont_iter = cont.iter(); //~ ERROR: cannot infer\n     let result = cont_iter.fold(Some(0u16), |state, val| {\n         state.map_or(None, |mask| {"}, {"sha": "2bdbdb4fde29596fe38d7dc9b86d80128d85e23f", "filename": "src/test/compile-fail/static-reference-to-fn-2.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-reference-to-fn-2.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n struct StateMachineIter<'a> {\n     statefn: &'a StateMachineFunc<'a>\n }\n \n type StateMachineFunc<'a> = fn(&mut StateMachineIter<'a>) -> Option<&'static str>;\n \n-impl<'a> Iterator<&'static str> for StateMachineIter<'a> {\n+impl<'a> Iterator for StateMachineIter<'a> {\n+    type Item = &'static str;\n+\n     fn next(&mut self) -> Option<&'static str> {\n         return  (*self.statefn)(self);\n     }"}, {"sha": "f8cbdb4e160bf4cc18cfa7fc3eddd1a3f0b4dce2", "filename": "src/test/compile-fail/unop-move-semantics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funop-move-semantics.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -12,13 +12,13 @@\n \n use std::ops::Not;\n \n-fn move_then_borrow<T: Not<T> + Clone>(x: T) {\n+fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n     !x;\n \n     x.clone();  //~ ERROR: use of moved value\n }\n \n-fn move_borrowed<T: Not<T>>(x: T, mut y: T) {\n+fn move_borrowed<T: Not<Output=T>>(x: T, mut y: T) {\n     let m = &x;\n     let n = &mut y;\n \n@@ -27,7 +27,7 @@ fn move_borrowed<T: Not<T>>(x: T, mut y: T) {\n     !y;  //~ ERROR: cannot move out of `y` because it is borrowed\n }\n \n-fn illegal_dereference<T: Not<T>>(mut x: T, y: T) {\n+fn illegal_dereference<T: Not<Output=T>>(mut x: T, y: T) {\n     let m = &mut x;\n     let n = &y;\n "}, {"sha": "7aa6ead89d7e072c87de0ba9b2c7d9fd47dd1c48", "filename": "src/test/compile-fail/wrong-mul-method-signature.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrong-mul-method-signature.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -13,14 +13,18 @@\n // (In this case the mul method should take &f64 and not f64)\n // See: #11450\n \n+#![feature(associated_types, default_type_params)]\n+\n use std::ops::Mul;\n \n struct Vec1 {\n     x: f64\n }\n \n // Expecting value in input signature\n-impl Mul<f64, Vec1> for Vec1 {\n+impl Mul<f64> for Vec1 {\n+    type Output = Vec1;\n+\n     fn mul(self, s: &f64) -> Vec1 {\n     //~^ ERROR: method `mul` has an incompatible type for trait: expected f64, found &-ptr\n         Vec1 {\n@@ -35,7 +39,9 @@ struct Vec2 {\n }\n \n // Wrong type parameter ordering\n-impl Mul<Vec2, f64> for Vec2 {\n+impl Mul<Vec2> for Vec2 {\n+    type Output = f64;\n+\n     fn mul(self, s: f64) -> Vec2 {\n     //~^ ERROR: method `mul` has an incompatible type for trait: expected struct Vec2, found f64\n         Vec2 {\n@@ -52,7 +58,9 @@ struct Vec3 {\n }\n \n // Unexpected return type\n-impl Mul<f64, i32> for Vec3 {\n+impl Mul<f64> for Vec3 {\n+    type Output = i32;\n+\n     fn mul(self, s: f64) -> f64 {\n     //~^ ERROR: method `mul` has an incompatible type for trait: expected i32, found f64\n         s"}, {"sha": "442c330b277863adb57427343e3287b6d68d415f", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ops::Add;\n+#![feature(associated_types)]\n+\n use std::num::Zero;\n+use std::ops::Add;\n \n #[derive(Zero)]\n struct Vector2<T>(T, T);\n \n-impl<T: Add<T, T>> Add<Vector2<T>, Vector2<T>> for Vector2<T> {\n+impl<T: Add<Output=T>> Add for Vector2<T> {\n+    type Output = Vector2<T>;\n+\n     fn add(self, other: Vector2<T>) -> Vector2<T> {\n         match (self, other) {\n             (Vector2(x0, y0), Vector2(x1, y1)) => {\n@@ -29,7 +33,9 @@ struct Vector3<T> {\n     x: T, y: T, z: T,\n }\n \n-impl<T: Add<T, T>> Add<Vector3<T>, Vector3<T>> for Vector3<T> {\n+impl<T: Add<Output=T>> Add for Vector3<T> {\n+    type Output = Vector3<T>;\n+\n     fn add(self, other: Vector3<T>) -> Vector3<T> {\n         Vector3 {\n             x: self.x + other.x,\n@@ -46,7 +52,9 @@ struct Matrix3x2<T> {\n     z: Vector2<T>,\n }\n \n-impl<T: Add<T, T>> Add<Matrix3x2<T>, Matrix3x2<T>> for Matrix3x2<T> {\n+impl<T: Add<Output=T>> Add for Matrix3x2<T> {\n+    type Output = Matrix3x2<T>;\n+\n     fn add(self, other: Matrix3x2<T>) -> Matrix3x2<T> {\n         Matrix3x2 {\n             x: self.x + other.x,"}, {"sha": "6a69bfc248f16ec5794a31073657ebb1487f326c", "filename": "src/test/run-pass/dst-index.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,20 +11,26 @@\n // Test that overloaded index expressions with DST result types\n // work and don't ICE.\n \n+#![feature(associated_types)]\n+\n use std::ops::Index;\n use std::fmt::Show;\n \n struct S;\n \n-impl Index<uint, str> for S {\n+impl Index<uint> for S {\n+    type Output = str;\n+\n     fn index<'a>(&'a self, _: &uint) -> &'a str {\n         \"hello\"\n     }\n }\n \n struct T;\n \n-impl Index<uint, Show + 'static> for T {\n+impl Index<uint> for T {\n+    type Output = Show + 'static;\n+\n     fn index<'a>(&'a self, idx: &uint) -> &'a (Show + 'static) {\n         static x: uint = 42;\n         &x"}, {"sha": "ee556ce2c84595bad3f81337035e1fa0effcdfd6", "filename": "src/test/run-pass/issue-13167.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-13167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13167.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::slice;\n \n pub struct PhfMapEntries<'a, T: 'a> {\n     iter: slice::Iter<'a, (&'static str, T)>,\n }\n \n-impl<'a, T> Iterator<(&'static str, &'a T)> for PhfMapEntries<'a, T> {\n+impl<'a, T> Iterator for PhfMapEntries<'a, T> {\n+    type Item = (&'static str, &'a T);\n+\n     fn next(&mut self) -> Option<(&'static str, &'a T)> {\n         self.iter.by_ref().map(|&(key, ref value)| (key, value)).next()\n     }"}, {"sha": "c29dc4319dc0cb87ed2065414c6c9079c9f270f2", "filename": "src/test/run-pass/issue-13204.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-13204.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-13204.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13204.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -12,7 +12,7 @@\n // lifetime parameters defined on the method bound correctly.\n \n pub trait Foo {\n-    fn bar<'a, I: Iterator<&'a ()>>(&self, it: I) -> uint {\n+    fn bar<'a, I: Iterator<Item=&'a ()>>(&self, it: I) -> uint {\n         let mut xs = it.filter(|_| true);\n         xs.count()\n     }"}, {"sha": "d66bbe9187a289a126bd3165d49af7c24d5ff508", "filename": "src/test/run-pass/issue-14919.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-14919.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-14919.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14919.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n trait Matcher {\n     fn next_match(&mut self) -> Option<(uint, uint)>;\n }\n@@ -40,7 +42,9 @@ struct MatchIndices<M> {\n     matcher: M\n }\n \n-impl<M: Matcher> Iterator<(uint, uint)> for MatchIndices<M> {\n+impl<M: Matcher> Iterator for MatchIndices<M> {\n+    type Item = (uint, uint);\n+\n     fn next(&mut self) -> Option<(uint, uint)> {\n         self.matcher.next_match()\n     }"}, {"sha": "f261098f5381137e684f3faa8ca21af40a4b08bb", "filename": "src/test/run-pass/issue-15734.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,7 +10,8 @@\n \n // If `Index` used an associated type for its output, this test would\n // work more smoothly.\n-#![feature(old_orphan_check)]\n+\n+#![feature(associated_types, old_orphan_check)]\n \n use std::ops::Index;\n \n@@ -25,21 +26,27 @@ impl<T> Mat<T> {\n     }\n }\n \n-impl<T> Index<(uint, uint), T> for Mat<T> {\n+impl<T> Index<(uint, uint)> for Mat<T> {\n+    type Output = T;\n+\n     fn index<'a>(&'a self, &(row, col): &(uint, uint)) -> &'a T {\n         &self.data[row * self.cols + col]\n     }\n }\n \n-impl<'a, T> Index<(uint, uint), T> for &'a Mat<T> {\n+impl<'a, T> Index<(uint, uint)> for &'a Mat<T> {\n+    type Output = T;\n+\n     fn index<'b>(&'b self, index: &(uint, uint)) -> &'b T {\n         (*self).index(index)\n     }\n }\n \n struct Row<M> { mat: M, row: uint, }\n \n-impl<T, M: Index<(uint, uint), T>> Index<uint, T> for Row<M> {\n+impl<T, M: Index<(uint, uint), Output=T>> Index<uint> for Row<M> {\n+    type Output = T;\n+\n     fn index<'a>(&'a self, col: &uint) -> &'a T {\n         &self.mat[(self.row, *col)]\n     }"}, {"sha": "7bc6d989fa75cd5ce680c21c8061f6ff4cd80ad6", "filename": "src/test/run-pass/issue-16596.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-16596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-16596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16596.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n trait MatrixRow {}\n \n struct Mat;\n@@ -18,7 +20,9 @@ struct Rows<M: MatrixRow> {\n     mat: M,\n }\n \n-impl<'a> Iterator<()> for Rows<&'a Mat> {\n+impl<'a> Iterator for Rows<&'a Mat> {\n+    type Item = ();\n+\n     fn next(&mut self) -> Option<()> {\n         unimplemented!()\n     }"}, {"sha": "741f168482da2b11fd589af018de961b5a4d2e2a", "filename": "src/test/run-pass/issue-3743.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-3743.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3743.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,7 +10,7 @@\n \n // If `Mul` used an associated type for its output, this test would\n // work more smoothly.\n-#![feature(old_orphan_check)]\n+#![feature(associated_types, default_type_params, old_orphan_check)]\n \n use std::ops::Mul;\n \n@@ -33,7 +33,9 @@ impl Vec2 {\n trait RhsOfVec2Mul<Result> { fn mul_vec2_by(&self, lhs: &Vec2) -> Result; }\n \n // Vec2's implementation of Mul \"from the other side\" using the above trait\n-impl<Res, Rhs: RhsOfVec2Mul<Res>> Mul<Rhs,Res> for Vec2 {\n+impl<Res, Rhs: RhsOfVec2Mul<Res>> Mul<Rhs> for Vec2 {\n+    type Output = Res;\n+\n     fn mul(self, rhs: Rhs) -> Res { rhs.mul_vec2_by(&self) }\n }\n "}, {"sha": "180bd292f8433152f5ae77367bb1ba45954d2321", "filename": "src/test/run-pass/issue-3979-generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -15,7 +15,7 @@ trait Positioned<S> {\n   fn X(&self) -> S;\n }\n \n-trait Movable<S: Add<S, S>>: Positioned<S> {\n+trait Movable<S: Add<Output=S>>: Positioned<S> {\n   fn translate(&mut self, dx: S) {\n     let x = self.X() + dx;\n     self.SetX(x);"}, {"sha": "882ca00f1dfa6b204af64d32349a7aa35f4854f7", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -12,7 +12,7 @@\n \n use std::ops::Add;\n \n-fn foo<T: Add<T, T> + Clone>([x, y, z]: [T; 3]) -> (T, T, T) {\n+fn foo<T: Add<Output=T> + Clone>([x, y, z]: [T; 3]) -> (T, T, T) {\n     (x.clone(), x.clone() + y.clone(), x + y + z)\n }\n fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {"}, {"sha": "5999840091967a27f825d80ccf825efdb02329ca", "filename": "src/test/run-pass/operator-multidispatch.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-multidispatch.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,6 +11,8 @@\n // Test that we can overload the `+` operator for points so that two\n // points can be added, and a point can be added to an integer.\n \n+#![feature(associated_types, default_type_params)]\n+\n use std::ops;\n \n #[derive(Show,PartialEq,Eq)]\n@@ -19,13 +21,17 @@ struct Point {\n     y: int\n }\n \n-impl ops::Add<Point,Point> for Point {\n+impl ops::Add for Point {\n+    type Output = Point;\n+\n     fn add(self, other: Point) -> Point {\n         Point {x: self.x + other.x, y: self.y + other.y}\n     }\n }\n \n-impl ops::Add<int,Point> for Point {\n+impl ops::Add<int> for Point {\n+    type Output = Point;\n+\n     fn add(self, other: int) -> Point {\n         Point {x: self.x + other,\n                y: self.y + other}"}, {"sha": "41e7586f1e3db33fbe45341dea110152dbb7ccbd", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n \n use std::cmp;\n use std::ops;\n@@ -18,31 +19,41 @@ struct Point {\n     y: int\n }\n \n-impl ops::Add<Point,Point> for Point {\n+impl ops::Add for Point {\n+    type Output = Point;\n+\n     fn add(self, other: Point) -> Point {\n         Point {x: self.x + other.x, y: self.y + other.y}\n     }\n }\n \n-impl ops::Sub<Point,Point> for Point {\n+impl ops::Sub for Point {\n+    type Output = Point;\n+\n     fn sub(self, other: Point) -> Point {\n         Point {x: self.x - other.x, y: self.y - other.y}\n     }\n }\n \n-impl ops::Neg<Point> for Point {\n+impl ops::Neg for Point {\n+    type Output = Point;\n+\n     fn neg(self) -> Point {\n         Point {x: -self.x, y: -self.y}\n     }\n }\n \n-impl ops::Not<Point> for Point {\n+impl ops::Not for Point {\n+    type Output = Point;\n+\n     fn not(self) -> Point {\n         Point {x: !self.x, y: !self.y }\n     }\n }\n \n-impl ops::Index<bool,int> for Point {\n+impl ops::Index<bool> for Point {\n+    type Output = int;\n+\n     fn index(&self, x: &bool) -> &int {\n         if *x {\n             &self.x"}, {"sha": "b3c9ec3dc934e3bee2b9a1bd409d9b5262f2f94a", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,14 +10,14 @@\n \n // Tests that nested vtables work with overloaded calls.\n \n-#![feature(unboxed_closures)]\n+#![feature(default_type_params, unboxed_closures)]\n \n use std::ops::Fn;\n use std::ops::Add;\n \n struct G<A>;\n \n-impl<'a, A: Add<int, int>> Fn<(A,), int> for G<A> {\n+impl<'a, A: Add<int, Output=int>> Fn<(A,), int> for G<A> {\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> int {\n         arg.add(1)\n     }"}, {"sha": "77bb981cfd9b9a3f0fe06d389a9402c4cd4a1197", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,6 +11,8 @@\n // Test overloading of the `[]` operator.  In particular test that it\n // takes its argument *by reference*.\n \n+#![feature(associated_types)]\n+\n use std::ops::Index;\n \n struct AssociationList<K,V> {\n@@ -28,7 +30,9 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K: PartialEq + std::fmt::Show, V:Clone> Index<K,V> for AssociationList<K,V> {\n+impl<K: PartialEq + std::fmt::Show, V:Clone> Index<K> for AssociationList<K,V> {\n+    type Output = V;\n+\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n         for pair in self.pairs.iter() {\n             if pair.key == *index {"}, {"sha": "d141234287d13e8e4452485329b144d22647b29a", "filename": "src/test/run-pass/overloaded-index-autoderef.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -10,14 +10,18 @@\n \n // Test overloaded indexing combined with autoderef.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Index, IndexMut};\n \n struct Foo {\n     x: int,\n     y: int,\n }\n \n-impl Index<int,int> for Foo {\n+impl Index<int> for Foo {\n+    type Output = int;\n+\n     fn index(&self, z: &int) -> &int {\n         if *z == 0 {\n             &self.x\n@@ -27,7 +31,9 @@ impl Index<int,int> for Foo {\n     }\n }\n \n-impl IndexMut<int,int> for Foo {\n+impl IndexMut<int> for Foo {\n+    type Output = int;\n+\n     fn index_mut(&mut self, z: &int) -> &mut int {\n         if *z == 0 {\n             &mut self.x"}, {"sha": "9c6afc0912d0630a471b30bcfb782c30f08fedd9", "filename": "src/test/run-pass/overloaded-index-in-field.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -11,6 +11,8 @@\n // Test using overloaded indexing when the \"map\" is stored in a\n // field. This caused problems at some point.\n \n+#![feature(associated_types)]\n+\n use std::ops::Index;\n \n struct Foo {\n@@ -22,7 +24,9 @@ struct Bar {\n     foo: Foo\n }\n \n-impl Index<int,int> for Foo {\n+impl Index<int> for Foo {\n+    type Output = int;\n+\n     fn index(&self, z: &int) -> &int {\n         if *z == 0 {\n             &self.x"}, {"sha": "fe09b47cf0a789bbb707b2c16d0baf15be8e6ecc", "filename": "src/test/run-pass/overloaded-index.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,14 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::ops::{Index, IndexMut};\n \n struct Foo {\n     x: int,\n     y: int,\n }\n \n-impl Index<int,int> for Foo {\n+impl Index<int> for Foo {\n+    type Output = int;\n+\n     fn index(&self, z: &int) -> &int {\n         if *z == 0 {\n             &self.x\n@@ -25,7 +29,9 @@ impl Index<int,int> for Foo {\n     }\n }\n \n-impl IndexMut<int,int> for Foo {\n+impl IndexMut<int> for Foo {\n+    type Output = int;\n+\n     fn index_mut(&mut self, z: &int) -> &mut int {\n         if *z == 0 {\n             &mut self.x"}, {"sha": "d52c1c0b12c536b0e89b972bdec07c9ff3cda00e", "filename": "src/test/run-pass/regions-no-bound-in-argument-cleanup.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fregions-no-bound-in-argument-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fregions-no-bound-in-argument-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-no-bound-in-argument-cleanup.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unsafe_destructor)]\n+#![feature(associated_types, unsafe_destructor)]\n \n pub struct Foo<T>;\n \n-impl<T> Iterator<T> for Foo<T> {\n+impl<T> Iterator for Foo<T> {\n+    type Item = T;\n+\n     fn next(&mut self) -> Option<T> {\n         None\n     }"}, {"sha": "ceb6b790426812b150d8538264946376991a6e5d", "filename": "src/test/run-pass/simd-generics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fsimd-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-generics.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -9,19 +9,21 @@\n // except according to those terms.\n \n \n-#![feature(simd)]\n+#![feature(associated_types, simd)]\n \n use std::ops;\n \n #[simd] struct f32x4(f32, f32, f32, f32);\n \n impl Copy for f32x4 {}\n \n-fn add<T: ops::Add<T, T>>(lhs: T, rhs: T) -> T {\n+fn add<T: ops::Add<Output=T>>(lhs: T, rhs: T) -> T {\n     lhs + rhs\n }\n \n-impl ops::Add<f32x4, f32x4> for f32x4 {\n+impl ops::Add for f32x4 {\n+    type Output = f32x4;\n+\n     fn add(self, rhs: f32x4) -> f32x4 {\n         self + rhs\n     }"}, {"sha": "f31d9ca186f1efc9bca66703955a433b2359991a", "filename": "src/test/run-pass/supertrait-default-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -17,7 +17,7 @@ trait Positioned<S> {\n   fn X(&self) -> S;\n }\n \n-trait Movable<S: Add<S, S>>: Positioned<S> {\n+trait Movable<S: Add<Output=S>>: Positioned<S> {\n   fn translate(&mut self, dx: S) {\n     let x = self.X() + dx;\n     self.SetX(x);\n@@ -35,7 +35,7 @@ impl<S: Clone> Positioned<S> for Point<S> {\n     }\n }\n \n-impl<S: Clone + Add<S, S>> Movable<S> for Point<S> {}\n+impl<S: Clone + Add<Output=S>> Movable<S> for Point<S> {}\n \n pub fn main() {\n     let mut p = Point{ x: 1i, y: 2i};"}, {"sha": "3e8db61b94044badc065d4313a9a3e8586bca117", "filename": "src/test/run-pass/trait-inheritance-overloading.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-inheritance-overloading.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,23 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(associated_types)]\n+\n use std::cmp::PartialEq;\n use std::ops::{Add, Sub, Mul};\n \n-trait MyNum : Add<Self,Self> + Sub<Self,Self> + Mul<Self,Self> + PartialEq + Clone { }\n+trait MyNum : Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + PartialEq + Clone { }\n \n #[derive(Clone, Show)]\n struct MyInt { val: int }\n \n-impl Add<MyInt, MyInt> for MyInt {\n+impl Add for MyInt {\n+    type Output = MyInt;\n+\n     fn add(self, other: MyInt) -> MyInt { mi(self.val + other.val) }\n }\n \n-impl Sub<MyInt, MyInt> for MyInt {\n+impl Sub for MyInt {\n+    type Output = MyInt;\n+\n     fn sub(self, other: MyInt) -> MyInt { mi(self.val - other.val) }\n }\n \n-impl Mul<MyInt, MyInt> for MyInt {\n+impl Mul for MyInt {\n+    type Output = MyInt;\n+\n     fn mul(self, other: MyInt) -> MyInt { mi(self.val * other.val) }\n }\n "}, {"sha": "237c83c8aa23a63bbc0a87a874a1ea0763fdd7aa", "filename": "src/test/run-pass/where-clauses-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fwhere-clauses-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6c786671d692d7b13c2e5c68a53001327b4b125/src%2Ftest%2Frun-pass%2Fwhere-clauses-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses-lifetimes.rs?ref=c6c786671d692d7b13c2e5c68a53001327b4b125", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo<'a, I>(mut it: I) where I: Iterator<&'a int> {}\n+fn foo<'a, I>(mut it: I) where I: Iterator<Item=&'a int> {}\n \n fn main() {\n     foo([1i, 2].iter());"}]}