{"sha": "bb7945e2fe662c86cb8e9e3a93730f20b7480dca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNzk0NWUyZmU2NjJjODZjYjhlOWUzYTkzNzMwZjIwYjc0ODBkY2E=", "commit": {"author": {"name": "Joshua Lockerman", "email": "j@Js-MacBook-Air.home", "date": "2017-09-29T19:58:11Z"}, "committer": {"name": "Joshua Lockerman", "email": "j@Js-MacBook-Air.home", "date": "2017-10-09T00:20:32Z"}, "message": "Remove Queue::new.", "tree": {"sha": "46abed22e3843e12e388bb51437f0f8f92224934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46abed22e3843e12e388bb51437f0f8f92224934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb7945e2fe662c86cb8e9e3a93730f20b7480dca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb7945e2fe662c86cb8e9e3a93730f20b7480dca", "html_url": "https://github.com/rust-lang/rust/commit/bb7945e2fe662c86cb8e9e3a93730f20b7480dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb7945e2fe662c86cb8e9e3a93730f20b7480dca/comments", "author": null, "committer": null, "parents": [{"sha": "41320fa52e1e4dd85a200a34195ae32d7efd13e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/41320fa52e1e4dd85a200a34195ae32d7efd13e0", "html_url": "https://github.com/rust-lang/rust/commit/41320fa52e1e4dd85a200a34195ae32d7efd13e0"}], "stats": {"total": 34, "additions": 5, "deletions": 29}, "files": [{"sha": "cc4be92276a3b2c3ac4943c00904f77164222d2c", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb7945e2fe662c86cb8e9e3a93730f20b7480dca/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7945e2fe662c86cb8e9e3a93730f20b7480dca/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=bb7945e2fe662c86cb8e9e3a93730f20b7480dca", "patch": "@@ -75,30 +75,6 @@ impl<T> Node<T> {\n     }\n }\n \n-impl<T> Queue<T> {\n-    #[cfg(all(test, not(target_os = \"emscripten\")))]\n-    /// Creates a new queue.\n-    ///\n-    /// This is unsafe as the type system doesn't enforce a single\n-    /// consumer-producer relationship. It also allows the consumer to `pop`\n-    /// items while there is a `peek` active due to all methods having a\n-    /// non-mutable receiver.\n-    ///\n-    /// # Arguments\n-    ///\n-    ///   * `bound` - This queue implementation is implemented with a linked\n-    ///               list, and this means that a push is always a malloc. In\n-    ///               order to amortize this cost, an internal cache of nodes is\n-    ///               maintained to prevent a malloc from always being\n-    ///               necessary. This bound is the limit on the size of the\n-    ///               cache (if desired). If the value is 0, then the cache has\n-    ///               no bound. Otherwise, the cache will never grow larger than\n-    ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn new(bound: usize) -> Queue<T> {\n-        Self::with_additions(bound, (), ())\n-    }\n-}\n-\n impl<T, ProducerAddition, ConsumerAddition> Queue<T, ProducerAddition, ConsumerAddition> {\n \n     /// Creates a new queue. With given additional elements in the producer and\n@@ -275,7 +251,7 @@ mod tests {\n     #[test]\n     fn smoke() {\n         unsafe {\n-            let queue = Queue::new(0);\n+            let queue = Queue::with_additions(0, (), ());\n             queue.push(1);\n             queue.push(2);\n             assert_eq!(queue.pop(), Some(1));\n@@ -292,7 +268,7 @@ mod tests {\n     #[test]\n     fn peek() {\n         unsafe {\n-            let queue = Queue::new(0);\n+            let queue = Queue::with_additions(0, (), ());\n             queue.push(vec![1]);\n \n             // Ensure the borrowchecker works\n@@ -315,7 +291,7 @@ mod tests {\n     #[test]\n     fn drop_full() {\n         unsafe {\n-            let q: Queue<Box<_>> = Queue::new(0);\n+            let q: Queue<Box<_>> = Queue::with_additions(0, (), ());\n             q.push(box 1);\n             q.push(box 2);\n         }\n@@ -324,7 +300,7 @@ mod tests {\n     #[test]\n     fn smoke_bound() {\n         unsafe {\n-            let q = Queue::new(0);\n+            let q = Queue::with_additions(0, (), ());\n             q.push(1);\n             q.push(2);\n             assert_eq!(q.pop(), Some(1));\n@@ -346,7 +322,7 @@ mod tests {\n         }\n \n         unsafe fn stress_bound(bound: usize) {\n-            let q = Arc::new(Queue::new(bound));\n+            let q = Arc::new(Queue::with_additions(bound, (), ()));\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();"}]}