{"sha": "39fbcfb277c45a6f1eeac31c171395173def4bdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZmJjZmIyNzdjNDVhNmYxZWVhYzMxYzE3MTM5NTE3M2RlZjRiZGI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-18T06:23:52Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-09T02:16:33Z"}, "message": "Support ? Kleene operator in 2015.", "tree": {"sha": "2bc17671ecd9e67370d418f14f7a77d5377e5d9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bc17671ecd9e67370d418f14f7a77d5377e5d9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39fbcfb277c45a6f1eeac31c171395173def4bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39fbcfb277c45a6f1eeac31c171395173def4bdb", "html_url": "https://github.com/rust-lang/rust/commit/39fbcfb277c45a6f1eeac31c171395173def4bdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39fbcfb277c45a6f1eeac31c171395173def4bdb/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "053666f9062d71091ea7970dcbad5963097191a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/053666f9062d71091ea7970dcbad5963097191a3", "html_url": "https://github.com/rust-lang/rust/commit/053666f9062d71091ea7970dcbad5963097191a3"}], "stats": {"total": 171, "additions": 4, "deletions": 167}, "files": [{"sha": "61dc39c445942afe564a0249d499479660a40558", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 4, "deletions": 167, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/39fbcfb277c45a6f1eeac31c171395173def4bdb/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39fbcfb277c45a6f1eeac31c171395173def4bdb/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=39fbcfb277c45a6f1eeac31c171395173def4bdb", "patch": "@@ -1,5 +1,4 @@\n use crate::ast::NodeId;\n-use crate::early_buffered_lints::BufferedEarlyLintId;\n use crate::ext::tt::macro_parser;\n use crate::feature_gate::Features;\n use crate::parse::token::{self, Token, TokenKind};\n@@ -287,16 +286,7 @@ where\n                     macro_node_id,\n                 );\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) =\n-                    parse_sep_and_kleene_op(\n-                        trees,\n-                        span.entire(),\n-                        sess,\n-                        features,\n-                        attrs,\n-                        edition,\n-                        macro_node_id,\n-                    );\n+                let (separator, op) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n                 // Count the number of captured \"names\" (i.e., named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n@@ -403,164 +393,11 @@ where\n /// session `sess`. If the next one (or possibly two) tokens in `input` correspond to a Kleene\n /// operator and separator, then a tuple with `(separator, KleeneOp)` is returned. Otherwise, an\n /// error with the appropriate span is emitted to `sess` and a dummy value is returned.\n-///\n-/// N.B., in the 2015 edition, `*` and `+` are the only Kleene operators, and `?` is a separator.\n-/// In the 2018 edition however, `?` is a Kleene operator, and not a separator.\n-fn parse_sep_and_kleene_op<I>(\n-    input: &mut Peekable<I>,\n-    span: Span,\n-    sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    edition: Edition,\n-    macro_node_id: NodeId,\n-) -> (Option<Token>, KleeneOp)\n-where\n-    I: Iterator<Item = tokenstream::TokenTree>,\n-{\n-    match edition {\n-        Edition::Edition2015 => parse_sep_and_kleene_op_2015(\n-            input,\n-            span,\n-            sess,\n-            features,\n-            attrs,\n-            macro_node_id,\n-        ),\n-        Edition::Edition2018 => parse_sep_and_kleene_op_2018(input, span, sess, features, attrs),\n-    }\n-}\n-\n-// `?` is a separator (with a migration warning) and never a KleeneOp.\n-fn parse_sep_and_kleene_op_2015<I>(\n-    input: &mut Peekable<I>,\n-    span: Span,\n-    sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-    macro_node_id: NodeId,\n-) -> (Option<Token>, KleeneOp)\n-where\n-    I: Iterator<Item = tokenstream::TokenTree>,\n-{\n-    // We basically look at two token trees here, denoted as #1 and #2 below\n-    let span = match parse_kleene_op(input, span) {\n-        // #1 is a `+` or `*` KleeneOp\n-        //\n-        // `?` is ambiguous: it could be a separator (warning) or a Kleene::ZeroOrOne (error), so\n-        // we need to look ahead one more token to be sure.\n-        Ok(Ok((op, _))) if op != KleeneOp::ZeroOrOne => return (None, op),\n-\n-        // #1 is `?` token, but it could be a Kleene::ZeroOrOne (error in 2015) without a separator\n-        // or it could be a `?` separator followed by any Kleene operator. We need to look ahead 1\n-        // token to find out which.\n-        Ok(Ok((op, op1_span))) => {\n-            assert_eq!(op, KleeneOp::ZeroOrOne);\n-\n-            // Lookahead at #2. If it is a KleenOp, then #1 is a separator.\n-            let is_1_sep = if let Some(tokenstream::TokenTree::Token(tok2)) = input.peek() {\n-                kleene_op(tok2).is_some()\n-            } else {\n-                false\n-            };\n-\n-            if is_1_sep {\n-                // #1 is a separator and #2 should be a KleepeOp.\n-                // (N.B. We need to advance the input iterator.)\n-                match parse_kleene_op(input, span) {\n-                    // #2 is `?`, which is not allowed as a Kleene op in 2015 edition,\n-                    // but is allowed in the 2018 edition.\n-                    Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n-                        sess.span_diagnostic\n-                            .struct_span_err(op2_span, \"expected `*` or `+`\")\n-                            .note(\"`?` is not a macro repetition operator in the 2015 edition, \\\n-                                 but is accepted in the 2018 edition\")\n-                            .emit();\n-\n-                        // Return a dummy\n-                        return (None, KleeneOp::ZeroOrMore);\n-                    }\n-\n-                    // #2 is a Kleene op, which is the only valid option\n-                    Ok(Ok((op, _))) => {\n-                        // Warn that `?` as a separator will be deprecated\n-                        sess.buffer_lint(\n-                            BufferedEarlyLintId::QuestionMarkMacroSep,\n-                            op1_span,\n-                            macro_node_id,\n-                            \"using `?` as a separator is deprecated and will be \\\n-                             a hard error in an upcoming edition\",\n-                        );\n-\n-                        return (Some(Token::new(token::Question, op1_span)), op);\n-                    }\n-\n-                    // #2 is a random token (this is an error) :(\n-                    Ok(Err(_)) => op1_span,\n-\n-                    // #2 is not even a token at all :(\n-                    Err(_) => op1_span,\n-                }\n-            } else {\n-                // `?` is not allowed as a Kleene op in 2015,\n-                // but is allowed in the 2018 edition\n-                sess.span_diagnostic\n-                    .struct_span_err(op1_span, \"expected `*` or `+`\")\n-                    .note(\"`?` is not a macro repetition operator in the 2015 edition, \\\n-                         but is accepted in the 2018 edition\")\n-                    .emit();\n-\n-                // Return a dummy\n-                return (None, KleeneOp::ZeroOrMore);\n-            }\n-        }\n-\n-        // #1 is a separator followed by #2, a KleeneOp\n-        Ok(Err(token)) => match parse_kleene_op(input, token.span) {\n-            // #2 is a `?`, which is not allowed as a Kleene op in 2015 edition,\n-            // but is allowed in the 2018 edition\n-            Ok(Ok((op, op2_span))) if op == KleeneOp::ZeroOrOne => {\n-                sess.span_diagnostic\n-                    .struct_span_err(op2_span, \"expected `*` or `+`\")\n-                    .note(\"`?` is not a macro repetition operator in the 2015 edition, \\\n-                        but is accepted in the 2018 edition\")\n-                    .emit();\n-\n-                // Return a dummy\n-                return (None, KleeneOp::ZeroOrMore);\n-            }\n-\n-            // #2 is a KleeneOp :D\n-            Ok(Ok((op, _))) => return (Some(token), op),\n-\n-            // #2 is a random token :(\n-            Ok(Err(token)) => token.span,\n-\n-            // #2 is not a token at all :(\n-            Err(span) => span,\n-        },\n-\n-        // #1 is not a token\n-        Err(span) => span,\n-    };\n-\n-    sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");\n-\n-    // Return a dummy\n-    (None, KleeneOp::ZeroOrMore)\n-}\n-\n-// `?` is a Kleene op, not a separator\n-fn parse_sep_and_kleene_op_2018<I>(\n-    input: &mut Peekable<I>,\n+fn parse_sep_and_kleene_op(\n+    input: &mut Peekable<impl Iterator<Item = tokenstream::TokenTree>>,\n     span: Span,\n     sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-) -> (Option<Token>, KleeneOp)\n-where\n-    I: Iterator<Item = tokenstream::TokenTree>,\n-{\n+) -> (Option<Token>, KleeneOp) {\n     // We basically look at two token trees here, denoted as #1 and #2 below\n     let span = match parse_kleene_op(input, span) {\n         // #1 is a `?` (needs feature gate)"}]}