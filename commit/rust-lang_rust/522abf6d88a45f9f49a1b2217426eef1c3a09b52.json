{"sha": "522abf6d88a45f9f49a1b2217426eef1c3a09b52", "node_id": "C_kwDOAAsO6NoAKDUyMmFiZjZkODhhNDVmOWY0OWExYjIyMTc0MjZlZWYxYzNhMDliNTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T06:14:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-15T06:14:51Z"}, "message": "Auto merge of #99267 - Dylan-DPC:rollup-d8l7y1o, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99113 (Simplify [a]rc code a little)\n - #99131 (Add label for generic arg (+ APIT) and RPIT callables in `label_fn_like`)\n - #99237 (removed unused CSS and unused HTML IDs)\n - #99239 (Add myself to the set of people notified when MIR changes.)\n - #99241 (Remove comment referring to constness.rs)\n - #99257 (Add regression test for #89436)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0da8efa518b37a868b431f081c367fec6675964e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0da8efa518b37a868b431f081c367fec6675964e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/522abf6d88a45f9f49a1b2217426eef1c3a09b52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/522abf6d88a45f9f49a1b2217426eef1c3a09b52", "html_url": "https://github.com/rust-lang/rust/commit/522abf6d88a45f9f49a1b2217426eef1c3a09b52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/522abf6d88a45f9f49a1b2217426eef1c3a09b52/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b90a0ede02f122a91b376cb2a8632a370269dd60", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90a0ede02f122a91b376cb2a8632a370269dd60", "html_url": "https://github.com/rust-lang/rust/commit/b90a0ede02f122a91b376cb2a8632a370269dd60"}, {"sha": "7976cd6eb05fc63228398b65ebe9227678c43cc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7976cd6eb05fc63228398b65ebe9227678c43cc9", "html_url": "https://github.com/rust-lang/rust/commit/7976cd6eb05fc63228398b65ebe9227678c43cc9"}], "stats": {"total": 521, "additions": 358, "deletions": 163}, "files": [{"sha": "3039b10373d8cef4fe66f5db44d35874c02c6201", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -132,8 +132,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Some(p) => p,\n         };\n \n-        // Keep the patterns in this match ordered the same as the list in\n-        // `src/librustc_middle/ty/constness.rs`\n         match intrinsic_name {\n             sym::caller_location => {\n                 let span = self.find_closest_untracked_caller_location();"}, {"sha": "8ead05122740e6f9926828f9770d037a0537e6eb", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -128,6 +128,14 @@ impl<'tcx> ClosureKind {\n             None\n         }\n     }\n+\n+    pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            ClosureKind::Fn => tcx.lang_items().fn_once_trait().unwrap(),\n+            ClosureKind::FnMut => tcx.lang_items().fn_mut_trait().unwrap(),\n+            ClosureKind::FnOnce => tcx.lang_items().fn_trait().unwrap(),\n+        }\n+    }\n }\n \n /// A composite describing a `Place` that is captured by a closure."}, {"sha": "ec045d3e70c96d806f5e28b9885673ffc7e003ab", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 179, "deletions": 84, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -21,15 +21,18 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, SelectionContext, StatementAsExpression,\n+};\n \n use std::iter;\n use std::slice;\n@@ -89,7 +92,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n-                None,\n+                method.ok().map(|method| method.def_id),\n             );\n             return self.tcx.ty_error();\n         }\n@@ -393,41 +396,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if !call_appears_satisfied {\n-            // Next, let's construct the error\n-            let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n-                hir::ExprKind::Call(\n-                    hir::Expr {\n-                        span,\n-                        kind:\n-                            hir::ExprKind::Path(hir::QPath::Resolved(\n-                                _,\n-                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n-                            )),\n-                        ..\n-                    },\n-                    _,\n-                ) => (call_span, *span, Some(of)),\n-                hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n-                hir::ExprKind::MethodCall(path_segment, _, span) => {\n-                    let ident_span = path_segment.ident.span;\n-                    let ident_span = if let Some(args) = path_segment.args {\n-                        ident_span.with_hi(args.span_ext.hi())\n-                    } else {\n-                        ident_span\n-                    };\n-                    (\n-                        *span, ident_span, None, // methods are never ctors\n-                    )\n-                }\n-                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n-            let call_name = match ctor_of {\n-                Some(CtorOf::Struct) => \"struct\",\n-                Some(CtorOf::Variant) => \"enum variant\",\n-                None => \"function\",\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -451,13 +419,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 compatibility_diagonal,\n                 formal_and_expected_inputs,\n                 provided_args,\n-                full_call_span,\n-                error_span,\n-                args_span,\n-                call_name,\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n+                call_span,\n+                call_expr,\n             );\n         }\n     }\n@@ -467,14 +433,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         compatibility_diagonal: IndexVec<ProvidedIdx, Compatibility<'tcx>>,\n         formal_and_expected_inputs: IndexVec<ExpectedIdx, (Ty<'tcx>, Ty<'tcx>)>,\n         provided_args: IndexVec<ProvidedIdx, &'tcx hir::Expr<'tcx>>,\n-        full_call_span: Span,\n-        error_span: Span,\n-        args_span: Span,\n-        call_name: &str,\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n+        call_span: Span,\n+        call_expr: &hir::Expr<'tcx>,\n     ) {\n+        // Next, let's construct the error\n+        let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n+            hir::ExprKind::Call(\n+                hir::Expr {\n+                    span,\n+                    kind:\n+                        hir::ExprKind::Path(hir::QPath::Resolved(\n+                            _,\n+                            hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n+                        )),\n+                    ..\n+                },\n+                _,\n+            ) => (call_span, *span, Some(of)),\n+            hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n+            hir::ExprKind::MethodCall(path_segment, _, span) => {\n+                let ident_span = path_segment.ident.span;\n+                let ident_span = if let Some(args) = path_segment.args {\n+                    ident_span.with_hi(args.span_ext.hi())\n+                } else {\n+                    ident_span\n+                };\n+                (\n+                    *span, ident_span, None, // methods are never ctors\n+                )\n+            }\n+            k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n+        };\n+        let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n+        let call_name = match ctor_of {\n+            Some(CtorOf::Struct) => \"struct\",\n+            Some(CtorOf::Variant) => \"enum variant\",\n+            None => \"function\",\n+        };\n+\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n             tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n@@ -495,6 +494,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n+        let callee_expr = match &call_expr.peel_blocks().kind {\n+            hir::ExprKind::Call(callee, _) => Some(*callee),\n+            hir::ExprKind::MethodCall(_, callee, _) => {\n+                if let Some((DefKind::AssocFn, def_id)) =\n+                    self.typeck_results.borrow().type_dependent_def(call_expr.hir_id)\n+                    && let Some(assoc) = tcx.opt_associated_item(def_id)\n+                    && assoc.fn_has_self_parameter\n+                {\n+                    Some(&callee[0])\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        };\n+        let callee_ty = callee_expr\n+            .and_then(|callee_expr| self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr));\n \n         // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n         // and treats error types differently\n@@ -631,7 +647,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     };\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    self.label_fn_like(&mut err, fn_def_id, callee_ty);\n                     err.emit();\n                     return;\n                 }\n@@ -721,7 +737,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n             // Call out where the function is defined\n-            label_fn_like(tcx, &mut err, fn_def_id);\n+            self.label_fn_like(&mut err, fn_def_id, callee_ty);\n             err.emit();\n             return;\n         }\n@@ -1003,7 +1019,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Call out where the function is defined\n-        label_fn_like(tcx, &mut err, fn_def_id);\n+        self.label_fn_like(&mut err, fn_def_id, callee_ty);\n \n         // And add a suggestion block for all of the parameters\n         let suggestion_text = match suggestion_text {\n@@ -1795,47 +1811,126 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-}\n \n-fn label_fn_like<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n-    def_id: Option<DefId>,\n-) {\n-    let Some(def_id) = def_id else {\n-        return;\n-    };\n-\n-    if let Some(def_span) = tcx.def_ident_span(def_id) {\n-        let mut spans: MultiSpan = def_span.into();\n-\n-        let params = tcx\n-            .hir()\n-            .get_if_local(def_id)\n-            .and_then(|node| node.body_id())\n-            .into_iter()\n-            .flat_map(|id| tcx.hir().body(id).params);\n-\n-        for param in params {\n-            spans.push_span_label(param.span, \"\");\n+    fn label_fn_like(\n+        &self,\n+        err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n+        callable_def_id: Option<DefId>,\n+        callee_ty: Option<Ty<'tcx>>,\n+    ) {\n+        let Some(mut def_id) = callable_def_id else {\n+            return;\n+        };\n+\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id)\n+            // Possibly points at either impl or trait item, so try to get it\n+            // to point to trait item, then get the parent.\n+            // This parent might be an impl in the case of an inherent function,\n+            // but the next check will fail.\n+            && let maybe_trait_item_def_id = assoc_item.trait_item_def_id.unwrap_or(def_id)\n+            && let maybe_trait_def_id = self.tcx.parent(maybe_trait_item_def_id)\n+            // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n+            && let Some(call_kind) = ty::ClosureKind::from_def_id(self.tcx, maybe_trait_def_id)\n+            && let Some(callee_ty) = callee_ty\n+        {\n+            let callee_ty = callee_ty.peel_refs();\n+            match *callee_ty.kind() {\n+                ty::Param(param) => {\n+                    let param =\n+                        self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx);\n+                    if param.kind.is_synthetic() {\n+                        // if it's `impl Fn() -> ..` then just fall down to the def-id based logic\n+                        def_id = param.def_id;\n+                    } else {\n+                        // Otherwise, find the predicate that makes this generic callable,\n+                        // and point at that.\n+                        let instantiated = self\n+                            .tcx\n+                            .explicit_predicates_of(self.body_id.owner)\n+                            .instantiate_identity(self.tcx);\n+                        // FIXME(compiler-errors): This could be problematic if something has two\n+                        // fn-like predicates with different args, but callable types really never\n+                        // do that, so it's OK.\n+                        for (predicate, span) in\n+                            std::iter::zip(instantiated.predicates, instantiated.spans)\n+                        {\n+                            if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n+                                && pred.self_ty().peel_refs() == callee_ty\n+                                && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n+                            {\n+                                err.span_note(span, \"callable defined here\");\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                ty::Opaque(new_def_id, _)\n+                | ty::Closure(new_def_id, _)\n+                | ty::FnDef(new_def_id, _) => {\n+                    def_id = new_def_id;\n+                }\n+                _ => {\n+                    // Look for a user-provided impl of a `Fn` trait, and point to it.\n+                    let new_def_id = self.probe(|_| {\n+                        let trait_ref = ty::TraitRef::new(\n+                            call_kind.to_def_id(self.tcx),\n+                            self.tcx.mk_substs([\n+                                ty::GenericArg::from(callee_ty),\n+                                self.next_ty_var(TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                    span: rustc_span::DUMMY_SP,\n+                                })\n+                                .into(),\n+                            ].into_iter()),\n+                        );\n+                        let obligation = traits::Obligation::new(\n+                            traits::ObligationCause::dummy(),\n+                            self.param_env,\n+                            ty::Binder::dummy(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: ty::BoundConstness::NotConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            }),\n+                        );\n+                        match SelectionContext::new(&self).select(&obligation) {\n+                            Ok(Some(traits::ImplSource::UserDefined(impl_source))) => {\n+                                Some(impl_source.impl_def_id)\n+                            }\n+                            _ => None\n+                        }\n+                    });\n+                    if let Some(new_def_id) = new_def_id {\n+                        def_id = new_def_id;\n+                    } else {\n+                        return;\n+                    }\n+                }\n+            }\n         }\n \n-        let def_kind = tcx.def_kind(def_id);\n-        err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-    } else {\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(hir::Closure { fn_decl_span, .. }),\n-                ..\n-            })) => {\n-                let spans: MultiSpan = (*fn_decl_span).into();\n+        if let Some(def_span) = self.tcx.def_ident_span(def_id) && !def_span.is_dummy() {\n+            let mut spans: MultiSpan = def_span.into();\n \n-                // Note: We don't point to param spans here because they overlap\n-                // with the closure span itself\n+            let params = self\n+                .tcx\n+                .hir()\n+                .get_if_local(def_id)\n+                .and_then(|node| node.body_id())\n+                .into_iter()\n+                .flat_map(|id| self.tcx.hir().body(id).params);\n \n-                err.span_note(spans, \"closure defined here\");\n+            for param in params {\n+                spans.push_span_label(param.span, \"\");\n             }\n-            _ => {}\n+\n+            let def_kind = self.tcx.def_kind(def_id);\n+            err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+        } else {\n+            let def_kind = self.tcx.def_kind(def_id);\n+            err.span_note(\n+                self.tcx.def_span(def_id),\n+                &format!(\"{} defined here\", def_kind.descr(def_id)),\n+            );\n         }\n     }\n }"}, {"sha": "541de5c902970a21e89198c8956c55bfee057520", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -124,6 +124,7 @@\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(nonnull_slice_from_raw_parts)]\n #![feature(pattern)]\n+#![feature(pointer_byte_offsets)]\n #![feature(ptr_internals)]\n #![feature(ptr_metadata)]\n #![feature(ptr_sub_ptr)]"}, {"sha": "b89b03683baefc7528fce1d12f158a35fa029850", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -907,8 +907,7 @@ impl<T: ?Sized> Rc<T> {\n         let offset = unsafe { data_offset(ptr) };\n \n         // Reverse the offset to find the original RcBox.\n-        let rc_ptr =\n-            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) };\n+        let rc_ptr = unsafe { ptr.byte_sub(offset) as *mut RcBox<T> };\n \n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n@@ -2331,7 +2330,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut RcBox<T>) }\n+            unsafe { ptr.byte_sub(offset) as *mut RcBox<T> }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n@@ -2684,7 +2683,7 @@ impl<T: ?Sized> Unpin for Rc<T> {}\n ///\n /// The pointer must point to (and have valid metadata for) a previously\n /// valid instance of T, but the T is allowed to be dropped.\n-unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {\n     // Align the unsized value to the end of the RcBox.\n     // Because RcBox is repr(C), it will always be the last field in memory.\n     // SAFETY: since the only unsized types possible are slices, trait objects,\n@@ -2695,7 +2694,7 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n }\n \n #[inline]\n-fn data_offset_align(align: usize) -> isize {\n+fn data_offset_align(align: usize) -> usize {\n     let layout = Layout::new::<RcBox<()>>();\n-    (layout.size() + layout.padding_needed_for(align)) as isize\n+    layout.size() + layout.padding_needed_for(align)\n }"}, {"sha": "4c03cc3ed158addec050422af229d521d566f37e", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -908,8 +908,7 @@ impl<T: ?Sized> Arc<T> {\n             let offset = data_offset(ptr);\n \n             // Reverse the offset to find the original ArcInner.\n-            let arc_ptr =\n-                (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>);\n+            let arc_ptr = ptr.byte_sub(offset) as *mut ArcInner<T>;\n \n             Self::from_ptr(arc_ptr)\n         }\n@@ -1942,7 +1941,7 @@ impl<T: ?Sized> Weak<T> {\n             let offset = unsafe { data_offset(ptr) };\n             // Thus, we reverse the offset to get the whole RcBox.\n             // SAFETY: the pointer originated from a Weak, so this offset is safe.\n-            unsafe { (ptr as *mut u8).offset(-offset).with_metadata_of(ptr as *mut ArcInner<T>) }\n+            unsafe { ptr.byte_sub(offset) as *mut ArcInner<T> }\n         };\n \n         // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.\n@@ -2749,7 +2748,7 @@ impl<T: ?Sized> Unpin for Arc<T> {}\n ///\n /// The pointer must point to (and have valid metadata for) a previously\n /// valid instance of T, but the T is allowed to be dropped.\n-unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {\n     // Align the unsized value to the end of the ArcInner.\n     // Because RcBox is repr(C), it will always be the last field in memory.\n     // SAFETY: since the only unsized types possible are slices, trait objects,\n@@ -2760,7 +2759,7 @@ unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n }\n \n #[inline]\n-fn data_offset_align(align: usize) -> isize {\n+fn data_offset_align(align: usize) -> usize {\n     let layout = Layout::new::<ArcInner<()>>();\n-    (layout.size() + layout.padding_needed_for(align)) as isize\n+    layout.size() + layout.padding_needed_for(align)\n }"}, {"sha": "4170c73b246252314dd4aa6ea24daf03a9159ee8", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -1442,7 +1442,6 @@ static DEFAULT_ID_MAP: Lazy<FxHashMap<Cow<'static, str>, usize>> = Lazy::new(||\n fn init_id_map() -> FxHashMap<Cow<'static, str>, usize> {\n     let mut map = FxHashMap::default();\n     // This is the list of IDs used in Javascript.\n-    map.insert(\"help\".into(), 1);\n     map.insert(\"settings\".into(), 1);\n     map.insert(\"not-displayed\".into(), 1);\n     map.insert(\"alternative-display\".into(), 1);\n@@ -1455,7 +1454,6 @@ fn init_id_map() -> FxHashMap<Cow<'static, str>, usize> {\n     map.insert(\"help-button\".into(), 1);\n     map.insert(\"main-content\".into(), 1);\n     map.insert(\"crate-search\".into(), 1);\n-    map.insert(\"render-detail\".into(), 1);\n     map.insert(\"toggle-all-docs\".into(), 1);\n     map.insert(\"all-types\".into(), 1);\n     map.insert(\"default-settings\".into(), 1);"}, {"sha": "c6933a8254bc2689d2a61813866f8e8dbfe8f24e", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -1733,13 +1733,12 @@ details.rustdoc-toggle[open] > summary.hideme > span {\n \tdisplay: none;\n }\n \n-details.undocumented[open] > summary::before,\n details.rustdoc-toggle[open] > summary::before,\n details.rustdoc-toggle[open] > summary.hideme::before {\n \tbackground-image: /* AUTOREPLACE: */url(\"toggle-minus.svg\");\n }\n \n-details.undocumented > summary::before, details.rustdoc-toggle > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tbackground-image: /* AUTOREPLACE: */url(\"toggle-plus.svg\");\n }\n "}, {"sha": "142ce456c52139419ec012ee89ec5a9f3b41f8c3", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -174,13 +174,11 @@ body.source .example-wrap pre.rust a {\n }\n \n details.rustdoc-toggle > summary.hideme > span,\n-details.rustdoc-toggle > summary::before,\n-details.undocumented > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tcolor: #999;\n }\n \n-details.rustdoc-toggle > summary::before,\n-details.undocumented > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tfilter: invert(100%);\n }\n \n@@ -218,17 +216,6 @@ details.undocumented > summary::before {\n \tbackground: none;\n }\n \n-#help > div {\n-\tbackground: #14191f;\n-\tbox-shadow: 0px 6px 20px 0px black;\n-\tborder: none;\n-\tborder-radius: 4px;\n-}\n-\n-#help span.bottom, #help span.top {\n-\tborder-color: #5c6773;\n-}\n-\n .rightside,\n .out-of-band {\n \tcolor: grey;"}, {"sha": "aeaca7515f962555d25e6787b76779118c740745", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -148,13 +148,11 @@ body.source .example-wrap pre.rust a {\n }\n \n details.rustdoc-toggle > summary.hideme > span,\n-details.rustdoc-toggle > summary::before,\n-details.undocumented > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tcolor: #999;\n }\n \n-details.rustdoc-toggle > summary::before,\n-details.undocumented > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tfilter: invert(100%);\n }\n \n@@ -179,20 +177,6 @@ details.undocumented > summary::before {\n .stab.portability { background: #F3DFFF; border-color: #b07bdb; color: #2f2f2f; }\n .stab.portability > code { background: none; }\n \n-#help > div {\n-\tbackground: #4d4d4d;\n-\tborder-color: #bfbfbf;\n-}\n-\n-#help span.bottom, #help span.top {\n-\tborder-color: #bfbfbf;\n-}\n-\n-#help dt {\n-\tborder-color: #bfbfbf;\n-\tbackground: rgba(0,0,0,0);\n-}\n-\n .rightside,\n .out-of-band {\n \tcolor: grey;"}, {"sha": "54d1a7b65d665002d8a186d27a0ea58950f07b61", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -140,8 +140,7 @@ body.source .example-wrap pre.rust a {\n }\n \n details.rustdoc-toggle > summary.hideme > span,\n-details.rustdoc-toggle > summary::before,\n-details.undocumented > summary::before {\n+details.rustdoc-toggle > summary::before {\n \tcolor: #999;\n }\n \n@@ -161,15 +160,6 @@ details.undocumented > summary::before {\n .stab.portability { background: #F3DFFF; border-color: #b07bdb; }\n .stab.portability > code { background: none; }\n \n-#help > div {\n-\tbackground: #e9e9e9;\n-\tborder-color: #bfbfbf;\n-}\n-\n-#help span.bottom, #help span.top {\n-\tborder-color: #bfbfbf;\n-}\n-\n .rightside,\n .out-of-band {\n \tcolor: grey;"}, {"sha": "a18e967668deff0d7180d45d3731d240900e0252", "filename": "src/test/ui/argument-suggestions/exotic-calls.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -0,0 +1,26 @@\n+fn foo<T: Fn()>(t: T) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn bar(t: impl Fn()) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn baz() -> impl Fn() {\n+    || {}\n+}\n+\n+fn baz2() {\n+    baz()(1i32)\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn qux() {\n+    let x = || {};\n+    x(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn main() {}"}, {"sha": "ca93ecc4e381a9407d27f2b5d2c923e51025cc89", "filename": "src/test/ui/argument-suggestions/exotic-calls.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -0,0 +1,67 @@\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:2:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: callable defined here\n+  --> $DIR/exotic-calls.rs:1:11\n+   |\n+LL | fn foo<T: Fn()>(t: T) {\n+   |           ^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:7:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: type parameter defined here\n+  --> $DIR/exotic-calls.rs:6:11\n+   |\n+LL | fn bar(t: impl Fn()) {\n+   |           ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:16:5\n+   |\n+LL |     baz()(1i32)\n+   |     ^^^^^ ---- argument of type `i32` unexpected\n+   |\n+note: opaque type defined here\n+  --> $DIR/exotic-calls.rs:11:13\n+   |\n+LL | fn baz() -> impl Fn() {\n+   |             ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     baz()()\n+   |\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:22:5\n+   |\n+LL |     x(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: closure defined here\n+  --> $DIR/exotic-calls.rs:21:13\n+   |\n+LL |     let x = || {};\n+   |             ^^\n+help: remove the extra argument\n+   |\n+LL |     x();\n+   |     ~~~\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "f7e467b3786dc66cf88c2b10c7c7bc752b1e8c1e", "filename": "src/test/ui/higher-rank-trait-bounds/normalize-under-binder/issue-89436.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-89436.rs", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-89436.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fnormalize-under-binder%2Fissue-89436.rs?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -0,0 +1,44 @@\n+// check-pass\n+\n+#![allow(unused)]\n+\n+trait MiniYokeable<'a> {\n+    type Output;\n+}\n+\n+struct MiniYoke<Y: for<'a> MiniYokeable<'a>> {\n+    pub yokeable: Y,\n+}\n+\n+fn map_project_broken<Y, P>(\n+    source: MiniYoke<Y>,\n+    f: impl for<'a> FnOnce(\n+        <Y as MiniYokeable<'a>>::Output,\n+        core::marker::PhantomData<&'a ()>,\n+    ) -> <P as MiniYokeable<'a>>::Output,\n+) -> MiniYoke<P>\n+where\n+    Y: for<'a> MiniYokeable<'a>,\n+    P: for<'a> MiniYokeable<'a>\n+{\n+    unimplemented!()\n+}\n+\n+struct Bar<'a> {\n+    string_1: &'a str,\n+    string_2: &'a str,\n+}\n+\n+impl<'a> MiniYokeable<'a> for Bar<'static> {\n+    type Output = Bar<'a>;\n+}\n+\n+impl<'a> MiniYokeable<'a> for &'static str {\n+    type Output = &'a str;\n+}\n+\n+fn demo_broken(bar: MiniYoke<Bar<'static>>) -> MiniYoke<&'static str> {\n+    map_project_broken(bar, |bar, _| bar.string_1)\n+}\n+\n+fn main() {}"}, {"sha": "aaa3c49b3d83ea468b98434656856502c29b824d", "filename": "src/test/ui/issues/issue-16939.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -4,11 +4,11 @@ error[E0057]: this function takes 0 arguments but 1 argument was supplied\n LL |     |t| f(t);\n    |         ^ - argument unexpected\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: callable defined here\n+  --> $DIR/issue-16939.rs:4:12\n    |\n-LL |     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-   |                           ^^^^\n+LL | fn _foo<F: Fn()> (f: F) {\n+   |            ^^^^\n help: remove the extra argument\n    |\n LL |     |t| f();"}, {"sha": "475ea9dfaf1b44d842c3d4dfbe2a11d73df2eea7", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -6,23 +6,23 @@ LL |     let ans = s(\"what\");\n    |               |\n    |               arguments to this function are incorrect\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0057]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:29:15\n    |\n LL |     let ans = s();\n    |               ^-- an argument of type `isize` is missing\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: provide the argument\n    |\n LL |     let ans = s(/* isize */);\n@@ -36,11 +36,11 @@ LL |     let ans = s(\"burma\", \"shave\");\n    |                 |\n    |                 expected `isize`, found `&str`\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: remove the extra argument\n    |\n LL |     let ans = s(/* isize */);"}, {"sha": "f2930b50e3ee87070a2f901912abe25efff19a70", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/522abf6d88a45f9f49a1b2217426eef1c3a09b52/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/522abf6d88a45f9f49a1b2217426eef1c3a09b52/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=522abf6d88a45f9f49a1b2217426eef1c3a09b52", "patch": "@@ -340,4 +340,4 @@ cc = [\"@rust-lang/rustfmt\"]\n \n [mentions.\"compiler/rustc_middle/src/mir/syntax.rs\"]\n message = \"This PR changes MIR\"\n-cc = [\"@oli-obk\", \"@RalfJung\", \"@JakobDegen\", \"@davidtwco\", \"@celinval\"]\n+cc = [\"@oli-obk\", \"@RalfJung\", \"@JakobDegen\", \"@davidtwco\", \"@celinval\", \"@vakaras\"]"}]}