{"sha": "965ea09664c1649ac9bfbd128eda631a41d73dee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NWVhMDk2NjRjMTY0OWFjOWJmYmQxMjhlZGE2MzFhNDFkNzNkZWU=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-02T11:50:24Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-10-04T18:40:14Z"}, "message": "Split ListTactic decision logic from write_list", "tree": {"sha": "9cd3ab98a427dca3decdaa62d5f4cec4955a8fbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd3ab98a427dca3decdaa62d5f4cec4955a8fbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/965ea09664c1649ac9bfbd128eda631a41d73dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/965ea09664c1649ac9bfbd128eda631a41d73dee", "html_url": "https://github.com/rust-lang/rust/commit/965ea09664c1649ac9bfbd128eda631a41d73dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/965ea09664c1649ac9bfbd128eda631a41d73dee/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fff0be2f821847ee8ca9c24d44cca19725034304", "url": "https://api.github.com/repos/rust-lang/rust/commits/fff0be2f821847ee8ca9c24d44cca19725034304", "html_url": "https://github.com/rust-lang/rust/commit/fff0be2f821847ee8ca9c24d44cca19725034304"}], "stats": {"total": 451, "additions": 255, "deletions": 196}, "files": [{"sha": "14d46a76834527c971d066f2414c49a428b7c6eb", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -90,6 +90,7 @@ configuration_option_enum! { LicensePolicy:\n     FileLicense,\n }\n \n+// TODO: this is not necessary any more\n configuration_option_enum! { MultilineStyle:\n     // Use horizontal layout if it fits in one line, fall back to vertical\n     PreferSingle,\n@@ -260,9 +261,9 @@ create_config! {\n     max_width: usize, 100, \"Maximum width of each line\";\n     ideal_width: usize, 80, \"Ideal width of each line\";\n     tab_spaces: usize, 4, \"Number of spaces per tab\";\n-    fn_call_width: usize, 50,\n+    fn_call_width: usize, 55,\n         \"Maximum width of the args of a function call before faling back to vertical formatting\";\n-    struct_lit_width: usize, 12,\n+    struct_lit_width: usize, 16,\n         \"Maximum width in the body of a struct lit before faling back to vertical formatting\";\n     newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n     fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";"}, {"sha": "d51bd256caa5a7c3353161e8cab9a877f33037fc", "filename": "src/expr.rs", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -13,7 +13,8 @@ use std::borrow::Borrow;\n \n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n-use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n+            DefinitiveListTactic, definitive_tactic};\n use string::{StringFormat, rewrite_string};\n use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search};\n use visitor::FmtVisitor;\n@@ -147,7 +148,13 @@ impl Rewrite for ast::Expr {\n                 Some(format!(\"break{}\", id_str))\n             }\n             ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n-                rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n+                rewrite_closure(capture,\n+                                fn_decl,\n+                                body,\n+                                self.span,\n+                                context,\n+                                width,\n+                                offset)\n             }\n             ast::Expr_::ExprField(..) |\n             ast::Expr_::ExprTupField(..) |\n@@ -223,18 +230,17 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                     .collect::<Vec<_>>();\n \n     let tactic = if items.iter().any(|li| li.item.len() > 10 || li.is_multiline()) {\n-        ListTactic::HorizontalVertical\n+        definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n     } else {\n-        ListTactic::Mixed\n+        DefinitiveListTactic::Mixed\n     };\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n         indent: offset + 1,\n-        h_width: max_item_width,\n-        v_width: max_item_width,\n+        width: max_item_width,\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -285,18 +291,25 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                                  },\n                                  span_after(span, \"|\", context.codemap),\n                                  body.span.lo);\n+    let item_vec = arg_items.collect::<Vec<_>>();\n+    let tactic = definitive_tactic(&item_vec,\n+                                   ListTactic::HorizontalVertical,\n+                                   horizontal_budget);\n+    let budget = match tactic {\n+        DefinitiveListTactic::Horizontal => horizontal_budget,\n+        _ => budget,\n+    };\n \n     let fmt = ListFormatting {\n-        tactic: ListTactic::HorizontalVertical,\n+        tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n         indent: argument_offset,\n-        h_width: horizontal_budget,\n-        v_width: budget,\n+        width: budget,\n         ends_with_newline: false,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n+    let list_str = try_opt!(write_list(&item_vec, &fmt));\n     let mut prefix = format!(\"{}|{}|\", mover, list_str);\n \n     if !ret_str.is_empty() {\n@@ -586,7 +599,11 @@ fn rewrite_if_else(context: &RewriteContext,\n \n     // Try to format if-else on single line.\n     if allow_single_line && context.config.single_line_if_else {\n-        let trial = single_line_if_else(context, &pat_expr_string, if_block, else_block_opt, width);\n+        let trial = single_line_if_else(context,\n+                                        &pat_expr_string,\n+                                        if_block,\n+                                        else_block_opt,\n+                                        width);\n \n         if trial.is_some() {\n             return trial;\n@@ -1074,7 +1091,13 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n     where R: Rewrite\n {\n     let closure = |callee_max_width| {\n-        rewrite_call_inner(context, callee, callee_max_width, args, span, width, offset)\n+        rewrite_call_inner(context,\n+                           callee,\n+                           callee_max_width,\n+                           args,\n+                           span,\n+                           width,\n+                           offset)\n     };\n \n     // 2 is for parens\n@@ -1136,8 +1159,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                              span.lo,\n                              span.hi);\n \n-    let fmt = ListFormatting::for_fn(remaining_width, offset, context.config);\n-    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+    let list_str = match ::lists::format_fn_args(items, remaining_width, offset, context.config) {\n         Some(str) => str,\n         None => return Err(Ordering::Less),\n     };\n@@ -1150,9 +1172,7 @@ fn rewrite_paren(context: &RewriteContext,\n                  width: usize,\n                  offset: Indent)\n                  -> Option<String> {\n-    debug!(\"rewrite_paren, width: {}, offset: {:?}\",\n-           width,\n-           offset);\n+    debug!(\"rewrite_paren, width: {}, offset: {:?}\", width, offset);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n     let subexpr_str = subexpr.rewrite(context, try_opt!(width.checked_sub(2)), offset + 1);\n@@ -1248,15 +1268,25 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                              },\n                              span_after(span, \"{\", context.codemap),\n                              span.hi);\n+    let item_vec = items.collect::<Vec<_>>();\n+\n+    let tactic = {\n+        let mut prelim_tactic = match (context.config.struct_lit_style, fields.len()) {\n+            (StructLitStyle::Visual, 1) => ListTactic::HorizontalVertical,\n+            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+        };\n+\n+        if prelim_tactic == ListTactic::HorizontalVertical && fields.len() > 1 {\n+            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n+        };\n \n-    let mut tactic = match (context.config.struct_lit_style, fields.len()) {\n-        (StructLitStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-        _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+        definitive_tactic(&item_vec, prelim_tactic, h_budget)\n     };\n \n-    if tactic == ListTactic::HorizontalVertical && fields.len() > 1 {\n-        tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n-    }\n+    let budget = match tactic {\n+        DefinitiveListTactic::Horizontal => h_budget,\n+        _ => v_budget,\n+    };\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n@@ -1267,12 +1297,11 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n             context.config.struct_lit_trailing_comma\n         },\n         indent: indent,\n-        h_width: h_budget,\n-        v_width: v_budget,\n+        width: budget,\n         ends_with_newline: false,\n         config: context.config,\n     };\n-    let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+    let fields_str = try_opt!(write_list(&item_vec, &fmt));\n \n     let format_on_newline = || {\n         let inner_indent = context.block_indent\n@@ -1340,10 +1369,8 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n-\n     let budget = try_opt!(width.checked_sub(2));\n-    let fmt = ListFormatting::for_fn(budget, indent, context.config);\n-    let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+    let list_str = try_opt!(::lists::format_fn_args(items, budget, indent, context.config));\n \n     Some(format!(\"({})\", list_str))\n }"}, {"sha": "9c29ece623f9639260df0cdb8db2529ceb1ce46c", "filename": "src/imports.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use Indent;\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic};\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n \n@@ -124,20 +124,6 @@ pub fn rewrite_use_list(width: usize,\n     // 1 = }\n     let remaining_width = width.checked_sub(supp_indent + 1).unwrap_or(0);\n \n-    let fmt = ListFormatting {\n-        tactic: ListTactic::Mixed,\n-        separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n-        indent: offset + supp_indent,\n-        h_width: remaining_width,\n-        // FIXME This is too conservative, and will not use all width\n-        // available\n-        // (loose 1 column (\";\"))\n-        v_width: remaining_width,\n-        ends_with_newline: false,\n-        config: context.config,\n-    };\n-\n     let mut items = {\n         // Dummy value, see explanation below.\n         let mut items = vec![ListItem::from_str(\"\")];\n@@ -169,6 +155,21 @@ pub fn rewrite_use_list(width: usize,\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n \n+    let tactic = ::lists::definitive_tactic(&items[first_index..],\n+                                            ::lists::ListTactic::Mixed,\n+                                            remaining_width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset + supp_indent,\n+        // FIXME This is too conservative, and will not use all width\n+        // available\n+        // (loose 1 column (\";\"))\n+        width: remaining_width,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {"}, {"sha": "c2f547162beaca0045e797c92244dd8dcbe43433", "filename": "src/items.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -12,7 +12,8 @@\n \n use Indent;\n use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram, wrap_str};\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic,\n+            DefinitiveListTactic, definitive_tactic};\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n@@ -499,13 +500,20 @@ impl<'a> FmtVisitor<'a> {\n             BlockIndentStyle::Visual => arg_indent,\n         };\n \n+        let tactic = definitive_tactic(&arg_items,\n+                                       self.config.fn_args_density.to_list_tactic(),\n+                                       one_line_budget);\n+        let budget = match tactic {\n+            DefinitiveListTactic::Horizontal => one_line_budget,\n+            _ => multi_line_budget,\n+        };\n+\n         let fmt = ListFormatting {\n-            tactic: self.config.fn_args_density.to_list_tactic(),\n+            tactic: tactic,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: indent,\n-            h_width: one_line_budget,\n-            v_width: multi_line_budget,\n+            width: budget,\n             ends_with_newline: false,\n             config: self.config,\n         };\n@@ -630,6 +638,7 @@ impl<'a> FmtVisitor<'a> {\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n+                    let item_vec = items.collect::<Vec<_>>();\n \n                     result.push('(');\n \n@@ -641,18 +650,20 @@ impl<'a> FmtVisitor<'a> {\n                         0\n                     };\n                     let budget = self.config.max_width - indent.width() - comma_cost - 1; // 1 = )\n+                    let tactic = definitive_tactic(&item_vec,\n+                                                   ListTactic::HorizontalVertical,\n+                                                   budget);\n \n                     let fmt = ListFormatting {\n-                        tactic: ListTactic::HorizontalVertical,\n+                        tactic: tactic,\n                         separator: \",\",\n                         trailing_separator: SeparatorTactic::Never,\n                         indent: indent,\n-                        h_width: budget,\n-                        v_width: budget,\n+                        width: budget,\n                         ends_with_newline: true,\n                         config: self.config,\n                     };\n-                    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+                    let list_str = match write_list(&item_vec, &fmt) {\n                         Some(list_str) => list_str,\n                         None => return,\n                     };\n@@ -766,9 +777,9 @@ impl<'a> FmtVisitor<'a> {\n             result.push('\\n');\n             result.push_str(&indentation);\n \n-            ListTactic::Vertical\n+            DefinitiveListTactic::Vertical\n         } else {\n-            ListTactic::Horizontal\n+            DefinitiveListTactic::Horizontal\n         };\n \n         // 1 = ,\n@@ -778,13 +789,12 @@ impl<'a> FmtVisitor<'a> {\n             separator: \",\",\n             trailing_separator: self.config.struct_trailing_comma,\n             indent: offset.block_indent(self.config),\n-            h_width: self.config.max_width,\n-            v_width: budget,\n+            width: budget,\n             ends_with_newline: true,\n             config: self.config,\n         };\n \n-        let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+        let list_str = try_opt!(write_list(items, &fmt));\n         result.push_str(&list_str);\n \n         if break_line {\n@@ -930,21 +940,15 @@ impl<'a> FmtVisitor<'a> {\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n         let items = itemize_list(self.codemap,\n-                                 lt_spans.chain(ty_spans),\n+                                 lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n                                  \">\",\n-                                 |sp| sp.lo,\n-                                 |sp| sp.hi,\n-                                 |_| String::new(),\n+                                 |&(sp, _)| sp.lo,\n+                                 |&(sp, _)| sp.hi,\n+                                 // FIXME: don't clone\n+                                 |&(_, ref str)| str.clone(),\n                                  span_after(span, \"<\", self.codemap),\n                                  span.hi);\n-        let mut items = items.collect::<Vec<_>>();\n-\n-        for (item, ty) in items.iter_mut().zip(lt_strs.chain(ty_strs)) {\n-            item.item = ty;\n-        }\n-\n-        let fmt = ListFormatting::for_item(h_budget, offset, self.config);\n-        let list_str = try_opt!(write_list(&items, &fmt));\n+        let list_str = try_opt!(::lists::format_item_list(items, h_budget, offset, self.config));\n \n         Some(format!(\"<{}>\", list_str))\n     }\n@@ -990,18 +994,20 @@ impl<'a> FmtVisitor<'a> {\n                                  |pred| pred.rewrite(&context, budget, offset).unwrap(),\n                                  span_start,\n                                  span_end);\n+        let item_vec = items.collect::<Vec<_>>();\n+        // FIXME: we don't need to collect here if the where_layout isnt horizontalVertical\n+        let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n \n         let fmt = ListFormatting {\n-            tactic: self.config.where_layout,\n+            tactic: tactic,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: offset,\n-            h_width: budget,\n-            v_width: budget,\n+            width: budget,\n             ends_with_newline: true,\n             config: self.config,\n         };\n-        let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+        let preds_str = try_opt!(write_list(&item_vec, &fmt));\n \n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||"}, {"sha": "723c603ea3fb1d29b23ff4585be9067335d44486", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -119,8 +119,7 @@ impl Indent {\n \n     pub fn to_string(&self, config: &Config) -> String {\n         let (num_tabs, num_spaces) = if config.hard_tabs {\n-            (self.block_indent / config.tab_spaces,\n-             self.alignment)\n+            (self.block_indent / config.tab_spaces, self.alignment)\n         } else {\n             (0, self.block_indent + self.alignment)\n         };"}, {"sha": "296df76e688e6c4fb0ceedb5571254c7f4810ce7", "filename": "src/lists.rs", "status": "modified", "additions": 131, "deletions": 108, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -14,7 +14,7 @@ use std::iter::Peekable;\n use syntax::codemap::{self, CodeMap, BytePos};\n \n use Indent;\n-use utils::{round_up_to_power_of_two, wrap_str};\n+use utils::wrap_str;\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n use config::Config;\n \n@@ -44,46 +44,69 @@ pub enum SeparatorTactic {\n impl_enum_decodable!(SeparatorTactic, Always, Never, Vertical);\n \n // TODO having some helpful ctors for ListFormatting would be nice.\n+// FIXME: this should have only 1 width param\n pub struct ListFormatting<'a> {\n-    pub tactic: ListTactic,\n+    pub tactic: DefinitiveListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n     pub indent: Indent,\n-    // Available width if we layout horizontally.\n-    pub h_width: usize,\n-    // Available width if we layout vertically\n-    pub v_width: usize,\n+    pub width: usize,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n     pub ends_with_newline: bool,\n     pub config: &'a Config,\n }\n \n-impl<'a> ListFormatting<'a> {\n-    pub fn for_fn(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n-        ListFormatting {\n-            tactic: ListTactic::LimitedHorizontalVertical(config.fn_call_width),\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            h_width: width,\n-            v_width: width,\n-            ends_with_newline: false,\n-            config: config,\n-        }\n-    }\n+pub fn format_fn_args<I>(items: I, width: usize, offset: Indent, config: &Config) -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    list_helper(items,\n+                width,\n+                offset,\n+                config,\n+                ListTactic::LimitedHorizontalVertical(config.fn_call_width))\n+}\n \n-    pub fn for_item(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n-        ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            h_width: width,\n-            v_width: width,\n-            ends_with_newline: false,\n-            config: config,\n-        }\n+pub fn format_item_list<I>(items: I,\n+                           width: usize,\n+                           offset: Indent,\n+                           config: &Config)\n+                           -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    list_helper(items,\n+                width,\n+                offset,\n+                config,\n+                ListTactic::HorizontalVertical)\n+}\n+\n+fn list_helper<I>(items: I,\n+                  width: usize,\n+                  offset: Indent,\n+                  config: &Config,\n+                  tactic: ListTactic)\n+                  -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    let item_vec: Vec<_> = items.collect();\n+    let tactic = definitive_tactic(&item_vec, tactic, width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset,\n+        width: width,\n+        ends_with_newline: false,\n+        config: config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}\n+\n+impl AsRef<ListItem> for ListItem {\n+    fn as_ref(&self) -> &ListItem {\n+        self\n     }\n }\n \n@@ -116,76 +139,67 @@ impl ListItem {\n     }\n }\n \n-// Format a list of commented items into a string.\n-// FIXME: this has grown into a monstrosity\n-// TODO: add unit tests\n-pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Option<String> {\n-    if items.is_empty() {\n-        return Some(String::new());\n-    }\n-\n-    let mut tactic = formatting.tactic;\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum DefinitiveListTactic {\n+    Vertical,\n+    Horizontal,\n+    Mixed,\n+}\n \n-    // Conservatively overestimates because of the changing separator tactic.\n-    let sep_count = if formatting.trailing_separator == SeparatorTactic::Always {\n-        items.len()\n-    } else {\n-        items.len() - 1\n+pub fn definitive_tactic<'t, I, T>(items: I,\n+                                   tactic: ListTactic,\n+                                   width: usize)\n+                                   -> DefinitiveListTactic\n+    where I: IntoIterator<Item = T> + Clone,\n+          T: AsRef<ListItem>\n+{\n+    let pre_line_comments = items.clone()\n+                                 .into_iter()\n+                                 .any(|item| item.as_ref().has_line_pre_comment());\n+\n+    let limit = match tactic {\n+        _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n+        ListTactic::Mixed => return DefinitiveListTactic::Mixed,\n+        ListTactic::Horizontal => return DefinitiveListTactic::Horizontal,\n+        ListTactic::Vertical => return DefinitiveListTactic::Vertical,\n+        ListTactic::LimitedHorizontalVertical(limit) => ::std::cmp::min(width, limit),\n+        ListTactic::HorizontalVertical => width,\n     };\n-    let sep_len = formatting.separator.len();\n-    let total_sep_len = (sep_len + 1) * sep_count;\n-    let total_width = calculate_width(items);\n-    let fits_single = total_width + total_sep_len <= formatting.h_width;\n-\n-    // Check if we need to fallback from horizontal listing, if possible.\n-    if let ListTactic::LimitedHorizontalVertical(limit) = tactic {\n-        if total_width > limit {\n-            tactic = ListTactic::Vertical;\n-        } else {\n-            tactic = ListTactic::HorizontalVertical;\n-        }\n-    }\n-    if tactic == ListTactic::HorizontalVertical {\n-        debug!(\"write_list: total_width: {}, total_sep_len: {}, h_width: {}\",\n-               total_width,\n-               total_sep_len,\n-               formatting.h_width);\n-        tactic = if fits_single && !items.iter().any(ListItem::is_multiline) {\n-            ListTactic::Horizontal\n-        } else {\n-            ListTactic::Vertical\n-        };\n-    }\n \n-    // Check if we can fit everything on a single line in mixed mode.\n-    // The horizontal tactic does not break after v_width columns.\n-    if tactic == ListTactic::Mixed && fits_single {\n-        tactic = ListTactic::Horizontal;\n-    }\n+    let (sep_count, total_width) = calculate_width(items.clone());\n+    let sep_len = \", \".len(); // FIXME: make more generic?\n+    let total_sep_len = sep_len * sep_count.checked_sub(1).unwrap_or(0);\n+    let real_total = total_width + total_sep_len;\n \n-    // Switch to vertical mode if we find non-block comments.\n-    if items.iter().any(ListItem::has_line_pre_comment) {\n-        tactic = ListTactic::Vertical;\n+    if real_total <= limit && !pre_line_comments &&\n+       !items.into_iter().any(|item| item.as_ref().is_multiline()) {\n+        DefinitiveListTactic::Horizontal\n+    } else {\n+        DefinitiveListTactic::Vertical\n     }\n+}\n+\n+// Format a list of commented items into a string.\n+// TODO: add unit tests\n+pub fn write_list<'b, I, T>(items: I, formatting: &ListFormatting<'b>) -> Option<String>\n+    where I: IntoIterator<Item = T>,\n+          T: AsRef<ListItem>\n+{\n+    let tactic = formatting.tactic;\n+    let sep_len = formatting.separator.len();\n \n     // Now that we know how we will layout, we can decide for sure if there\n     // will be a trailing separator.\n     let trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n-\n-    // Create a buffer for the result.\n-    // TODO could use a StringBuffer or rope for this\n-    let alloc_width = if tactic == ListTactic::Horizontal {\n-        total_width + total_sep_len\n-    } else {\n-        total_width + items.len() * (formatting.indent.width() + 1)\n-    };\n-    let mut result = String::with_capacity(round_up_to_power_of_two(alloc_width));\n+    let mut result = String::new();\n+    let mut iter = items.into_iter().enumerate().peekable();\n \n     let mut line_len = 0;\n     let indent_str = &formatting.indent.to_string(formatting.config);\n-    for (i, item) in items.iter().enumerate() {\n+    while let Some((i, item)) = iter.next() {\n+        let item = item.as_ref();\n         let first = i == 0;\n-        let last = i == items.len() - 1;\n+        let last = iter.peek().is_none();\n         let separate = !last || trailing_separator;\n         let item_sep_len = if separate {\n             sep_len\n@@ -195,17 +209,17 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n         let item_width = item.item.len() + item_sep_len;\n \n         match tactic {\n-            ListTactic::Horizontal if !first => {\n+            DefinitiveListTactic::Horizontal if !first => {\n                 result.push(' ');\n             }\n-            ListTactic::Vertical if !first => {\n+            DefinitiveListTactic::Vertical if !first => {\n                 result.push('\\n');\n                 result.push_str(indent_str);\n             }\n-            ListTactic::Mixed => {\n+            DefinitiveListTactic::Mixed => {\n                 let total_width = total_item_width(item) + item_sep_len;\n \n-                if line_len > 0 && line_len + total_width > formatting.v_width {\n+                if line_len > 0 && line_len + total_width > formatting.width {\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n@@ -224,17 +238,17 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n         // Pre-comments\n         if let Some(ref comment) = item.pre_comment {\n             // Block style in non-vertical mode.\n-            let block_mode = tactic != ListTactic::Vertical;\n+            let block_mode = tactic != DefinitiveListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n-            let max_width = formatting.v_width;\n+            let max_width = formatting.width;\n             let comment = try_opt!(rewrite_comment(comment,\n                                                    block_mode,\n                                                    max_width,\n                                                    formatting.indent,\n                                                    formatting.config));\n             result.push_str(&comment);\n \n-            if tactic == ListTactic::Vertical {\n+            if tactic == DefinitiveListTactic::Vertical {\n                 result.push('\\n');\n                 result.push_str(indent_str);\n             } else {\n@@ -244,16 +258,16 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n \n         let item_str = try_opt!(wrap_str(&item.item[..],\n                                          formatting.config.max_width,\n-                                         formatting.v_width,\n+                                         formatting.width,\n                                          formatting.indent));\n         result.push_str(&item_str);\n \n         // Post-comments\n-        if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n+        if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n             let formatted_comment = try_opt!(rewrite_comment(comment,\n                                                              true,\n-                                                             formatting.v_width,\n+                                                             formatting.width,\n                                                              Indent::empty(),\n                                                              formatting.config));\n \n@@ -265,9 +279,9 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             result.push_str(formatting.separator);\n         }\n \n-        if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n+        if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n-            let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n+            let width = formatting.width.checked_sub(item_width + 1).unwrap_or(1);\n             let mut offset = formatting.indent;\n             offset.alignment += item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n@@ -286,7 +300,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             result.push_str(&formatted_comment);\n         }\n \n-        if !last && tactic == ListTactic::Vertical && item.new_lines {\n+        if !last && tactic == DefinitiveListTactic::Vertical && item.new_lines {\n             result.push('\\n');\n         }\n     }\n@@ -449,25 +463,34 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n     }\n }\n \n-fn needs_trailing_separator(separator_tactic: SeparatorTactic, list_tactic: ListTactic) -> bool {\n+fn needs_trailing_separator(separator_tactic: SeparatorTactic,\n+                            list_tactic: DefinitiveListTactic)\n+                            -> bool {\n     match separator_tactic {\n         SeparatorTactic::Always => true,\n-        SeparatorTactic::Vertical => list_tactic == ListTactic::Vertical,\n+        SeparatorTactic::Vertical => list_tactic == DefinitiveListTactic::Vertical,\n         SeparatorTactic::Never => false,\n     }\n }\n \n-fn calculate_width(items: &[ListItem]) -> usize {\n-    items.iter().map(total_item_width).fold(0, |a, l| a + l)\n+/// Returns the count and total width of the list items.\n+fn calculate_width<'li, I, T>(items: I) -> (usize, usize)\n+    where I: IntoIterator<Item = T>,\n+          T: AsRef<ListItem>\n+{\n+    items.into_iter()\n+         .map(|item| total_item_width(item.as_ref()))\n+         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n-    comment_len(&item.pre_comment) + comment_len(&item.post_comment) + item.item.len()\n+    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n+    comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) + item.item.len()\n }\n \n-fn comment_len(comment: &Option<String>) -> usize {\n-    match *comment {\n-        Some(ref s) => {\n+fn comment_len(comment: Option<&str>) -> usize {\n+    match comment {\n+        Some(s) => {\n             let text_len = s.trim().len();\n             if text_len > 0 {\n                 // We'll put \" /*\" before and \" */\" after inline comments."}, {"sha": "51fdd48a2bab9c6a189757304f2671d3c33928d4", "filename": "src/macros.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -89,7 +89,12 @@ pub fn rewrite_macro(mac: &ast::Mac,\n     match style {\n         MacroStyle::Parens => {\n             // Format macro invocation as function call.\n-            rewrite_call(context, &macro_name, &expr_vec, mac.span, width, offset)\n+            rewrite_call(context,\n+                         &macro_name,\n+                         &expr_vec,\n+                         mac.span,\n+                         width,\n+                         offset)\n         }\n         MacroStyle::Brackets => {\n             // Format macro invocation as array literal."}, {"sha": "9fe837fced4515db17091c7500efd0365b733aa0", "filename": "src/types.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/965ea09664c1649ac9bfbd128eda631a41d73dee/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=965ea09664c1649ac9bfbd128eda631a41d73dee", "patch": "@@ -13,7 +13,7 @@ use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n use Indent;\n-use lists::{itemize_list, write_list, ListFormatting};\n+use lists::itemize_list;\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n \n@@ -206,9 +206,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                  .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n-            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi),\n-                                     \"<\",\n-                                     context.codemap);\n+            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n             let separator = get_path_separator(context.codemap, *span_lo, list_lo);\n \n             // 1 for <\n@@ -232,9 +230,10 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      },\n                                      list_lo,\n                                      span_hi);\n-\n-            let fmt = ListFormatting::for_item(list_width, offset + extra_offset, context.config);\n-            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+            let list_str = try_opt!(::lists::format_item_list(items,\n+                                                              list_width,\n+                                                              offset + extra_offset,\n+                                                              context.config));\n \n             // Update position of last bracket.\n             *span_lo = next_span_lo;\n@@ -263,9 +262,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      |ty| ty.rewrite(context, budget, offset).unwrap(),\n                                      list_lo,\n                                      span_hi);\n-\n-            let fmt = ListFormatting::for_fn(budget, offset, context.config);\n-            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+            let list_str = try_opt!(::lists::format_fn_args(items, budget, offset, context.config));\n \n             format!(\"({}){}\", list_str, output)\n         }"}]}