{"sha": "31c12ec282de5e2d4e835f320f8858277b3ba133", "node_id": "C_kwDOAAsO6NoAKDMxYzEyZWMyODJkZTVlMmQ0ZTgzNWYzMjBmODg1ODI3N2IzYmExMzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-06T21:41:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-06T21:41:46Z"}, "message": "Auto merge of #14266 - Veykril:generalize-eager-lazy, r=Veykril\n\nfeature: Make replace_or_with_or_else assists more generally applicable", "tree": {"sha": "1a58ce9670845fd22ce88acde9c151e861eb7d83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a58ce9670845fd22ce88acde9c151e861eb7d83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31c12ec282de5e2d4e835f320f8858277b3ba133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31c12ec282de5e2d4e835f320f8858277b3ba133", "html_url": "https://github.com/rust-lang/rust/commit/31c12ec282de5e2d4e835f320f8858277b3ba133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31c12ec282de5e2d4e835f320f8858277b3ba133/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab", "html_url": "https://github.com/rust-lang/rust/commit/1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab"}, {"sha": "0ce06088f8b79ba53002d6a7254e6bb01b687552", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ce06088f8b79ba53002d6a7254e6bb01b687552", "html_url": "https://github.com/rust-lang/rust/commit/0ce06088f8b79ba53002d6a7254e6bb01b687552"}], "stats": {"total": 937, "additions": 415, "deletions": 522}, "files": [{"sha": "a5df94885f6ea9a8096e29bcc628e04b91a25b70", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -1677,6 +1677,10 @@ impl Function {\n             .collect()\n     }\n \n+    pub fn num_params(self, db: &dyn HirDatabase) -> usize {\n+        db.function_data(self.id).params.len()\n+    }\n+\n     pub fn method_params(self, db: &dyn HirDatabase) -> Option<Vec<Param>> {\n         if self.self_param(db).is_none() {\n             return None;\n@@ -3857,11 +3861,13 @@ impl Type {\n     }\n }\n \n+// FIXME: Document this\n #[derive(Debug)]\n pub struct Callable {\n     ty: Type,\n     sig: CallableSig,\n     callee: Callee,\n+    /// Whether this is a method that was called with method call syntax.\n     pub(crate) is_bound_method: bool,\n }\n \n@@ -3895,14 +3901,14 @@ impl Callable {\n             Other => CallableKind::Other,\n         }\n     }\n-    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {\n+    pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<(ast::SelfParam, Type)> {\n         let func = match self.callee {\n             Callee::Def(CallableDefId::FunctionId(it)) if self.is_bound_method => it,\n             _ => return None,\n         };\n         let src = func.lookup(db.upcast()).source(db.upcast());\n         let param_list = src.value.param_list()?;\n-        param_list.self_param()\n+        Some((param_list.self_param()?, self.ty.derived(self.sig.params()[0].clone())))\n     }\n     pub fn n_params(&self) -> usize {\n         self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }"}, {"sha": "a7e3ed793f1726e8c5d07203cf4c6ad6562be7e9", "filename": "crates/ide-assists/src/handlers/replace_method_eager_lazy.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_method_eager_lazy.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -0,0 +1,310 @@\n+use ide_db::assists::{AssistId, AssistKind};\n+use syntax::{\n+    ast::{self, make, Expr, HasArgList},\n+    AstNode,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: replace_with_lazy_method\n+//\n+// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n+//\n+// ```\n+// # //- minicore:option, fn\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or(2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or_else(|| 2);\n+// }\n+// ```\n+pub(crate) fn replace_with_lazy_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let scope = ctx.sema.scope(call.syntax())?;\n+\n+    let last_arg = call.arg_list()?.args().next()?;\n+    let method_name = call.name_ref()?;\n+\n+    let callable = ctx.sema.resolve_method_call_as_callable(&call)?;\n+    let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;\n+    let n_params = callable.n_params() + 1;\n+\n+    let method_name_lazy = format!(\n+        \"{method_name}{}\",\n+        if method_name.text().ends_with(\"or\") { \"_else\" } else { \"_with\" }\n+    );\n+\n+    receiver_ty.iterate_method_candidates_with_traits(\n+        ctx.sema.db,\n+        &scope,\n+        &scope.visible_traits().0,\n+        None,\n+        None,\n+        |func| {\n+            let valid = func.name(ctx.sema.db).as_str() == Some(&*method_name_lazy)\n+                && func.num_params(ctx.sema.db) == n_params\n+                && {\n+                    let params = func.params_without_self(ctx.sema.db);\n+                    let last_p = params.first()?;\n+                    // FIXME: Check that this has the form of `() -> T` where T is the current type of the argument\n+                    last_p.ty().impls_fnonce(ctx.sema.db)\n+                };\n+            valid.then_some(func)\n+        },\n+    )?;\n+\n+    acc.add(\n+        AssistId(\"replace_with_lazy_method\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {method_name} with {method_name_lazy}\"),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(method_name.syntax().text_range(), method_name_lazy);\n+            let closured = into_closure(&last_arg);\n+            builder.replace_ast(last_arg, closured);\n+        },\n+    )\n+}\n+\n+fn into_closure(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::CallExpr(call) = param {\n+            if call.arg_list()?.args().count() == 0 {\n+                Some(call.expr()?)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n+}\n+\n+// Assist: replace_with_eager_method\n+//\n+// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n+//\n+// ```\n+// # //- minicore:option, fn\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or_else(|| 2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or(2);\n+// }\n+// ```\n+pub(crate) fn replace_with_eager_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+    let scope = ctx.sema.scope(call.syntax())?;\n+\n+    let last_arg = call.arg_list()?.args().next()?;\n+    let method_name = call.name_ref()?;\n+\n+    let callable = ctx.sema.resolve_method_call_as_callable(&call)?;\n+    let (_, receiver_ty) = callable.receiver_param(ctx.sema.db)?;\n+    let n_params = callable.n_params() + 1;\n+    let params = callable.params(ctx.sema.db);\n+\n+    // FIXME: Check that the arg is of the form `() -> T`\n+    if !params.first()?.1.impls_fnonce(ctx.sema.db) {\n+        return None;\n+    }\n+\n+    let method_name_text = method_name.text();\n+    let method_name_eager = method_name_text\n+        .strip_suffix(\"_else\")\n+        .or_else(|| method_name_text.strip_suffix(\"_with\"))?;\n+\n+    receiver_ty.iterate_method_candidates_with_traits(\n+        ctx.sema.db,\n+        &scope,\n+        &scope.visible_traits().0,\n+        None,\n+        None,\n+        |func| {\n+            let valid = func.name(ctx.sema.db).as_str() == Some(&*method_name_eager)\n+                && func.num_params(ctx.sema.db) == n_params;\n+            valid.then_some(func)\n+        },\n+    )?;\n+\n+    acc.add(\n+        AssistId(\"replace_with_eager_method\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {method_name} with {method_name_eager}\"),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(method_name.syntax().text_range(), method_name_eager);\n+            let called = into_call(&last_arg);\n+            builder.replace_ast(last_arg, called);\n+        },\n+    )\n+}\n+\n+fn into_call(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::ClosureExpr(closure) = param {\n+            if closure.param_list()?.params().count() == 0 {\n+                Some(closure.body()?)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn replace_or_with_or_else_simple() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| 2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_call() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(x());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_block() {\n+        check_assist(\n+            replace_with_lazy_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or({\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| {\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_simple() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(|| 2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_call() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\n+fn x() -> i32 { 0 }\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(x());\n+}\n+\n+fn x() -> i32 { 0 }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_map() {\n+        check_assist(\n+            replace_with_eager_method,\n+            r#\"\n+//- minicore: option, fn\n+fn foo() {\n+    let foo = Some(\"foo\");\n+    return foo.map$0_or_else(|| 42, |v| v.len());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(\"foo\");\n+    return foo.map_or(42, |v| v.len());\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "f0ed3c4fe6f50f397168365a2a0afe876e6a84b7", "filename": "crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=1bfe96ec667c9acafa52c5d4bb43ad1bc2e9c3ab", "patch": "@@ -1,364 +0,0 @@\n-use ide_db::{\n-    assists::{AssistId, AssistKind},\n-    famous_defs::FamousDefs,\n-};\n-use syntax::{\n-    ast::{self, make, Expr, HasArgList},\n-    AstNode,\n-};\n-\n-use crate::{AssistContext, Assists};\n-\n-// Assist: replace_or_with_or_else\n-//\n-// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n-//\n-// ```\n-// # //- minicore:option\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwra$0p_or(2);\n-// }\n-// ```\n-// ->\n-// ```\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwrap_or_else(|| 2);\n-// }\n-// ```\n-pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n-\n-    let kind = is_option_or_result(call.receiver()?, ctx)?;\n-\n-    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n-\n-    let mut map_or = false;\n-\n-    let replace = match &*name.text() {\n-        \"unwrap_or\" => \"unwrap_or_else\".to_string(),\n-        \"or\" => \"or_else\".to_string(),\n-        \"ok_or\" if kind == Kind::Option => \"ok_or_else\".to_string(),\n-        \"map_or\" => {\n-            map_or = true;\n-            \"map_or_else\".to_string()\n-        }\n-        _ => return None,\n-    };\n-\n-    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n-        [] => make::arg_list(Vec::new()),\n-        [first] => {\n-            let param = into_closure(first);\n-            make::arg_list(vec![param])\n-        }\n-        [first, second] if map_or => {\n-            let param = into_closure(first);\n-            make::arg_list(vec![param, second.clone()])\n-        }\n-        _ => return None,\n-    };\n-\n-    acc.add(\n-        AssistId(\"replace_or_with_or_else\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {name} with {replace}\"),\n-        call.syntax().text_range(),\n-        |builder| {\n-            builder.replace(name.syntax().text_range(), replace);\n-            builder.replace_ast(arg_list, arg)\n-        },\n-    )\n-}\n-\n-fn into_closure(param: &Expr) -> Expr {\n-    (|| {\n-        if let ast::Expr::CallExpr(call) = param {\n-            if call.arg_list()?.args().count() == 0 {\n-                Some(call.expr()?)\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    })()\n-    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n-}\n-\n-// Assist: replace_or_else_with_or\n-//\n-// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n-//\n-// ```\n-// # //- minicore:option\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwra$0p_or_else(|| 2);\n-// }\n-// ```\n-// ->\n-// ```\n-// fn foo() {\n-//     let a = Some(1);\n-//     a.unwrap_or(2);\n-// }\n-// ```\n-pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n-\n-    let kind = is_option_or_result(call.receiver()?, ctx)?;\n-\n-    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n-\n-    let mut map_or = false;\n-    let replace = match &*name.text() {\n-        \"unwrap_or_else\" => \"unwrap_or\".to_string(),\n-        \"or_else\" => \"or\".to_string(),\n-        \"ok_or_else\" if kind == Kind::Option => \"ok_or\".to_string(),\n-        \"map_or_else\" => {\n-            map_or = true;\n-            \"map_or\".to_string()\n-        }\n-        _ => return None,\n-    };\n-\n-    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n-        [] => make::arg_list(Vec::new()),\n-        [first] => {\n-            let param = into_call(first);\n-            make::arg_list(vec![param])\n-        }\n-        [first, second] if map_or => {\n-            let param = into_call(first);\n-            make::arg_list(vec![param, second.clone()])\n-        }\n-        _ => return None,\n-    };\n-\n-    acc.add(\n-        AssistId(\"replace_or_else_with_or\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {name} with {replace}\"),\n-        call.syntax().text_range(),\n-        |builder| {\n-            builder.replace(name.syntax().text_range(), replace);\n-            builder.replace_ast(arg_list, arg)\n-        },\n-    )\n-}\n-\n-fn into_call(param: &Expr) -> Expr {\n-    (|| {\n-        if let ast::Expr::ClosureExpr(closure) = param {\n-            if closure.param_list()?.params().count() == 0 {\n-                Some(closure.body()?)\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    })()\n-    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n-}\n-\n-#[derive(PartialEq, Eq)]\n-enum Kind {\n-    Option,\n-    Result,\n-}\n-\n-fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<Kind> {\n-    let ty = ctx.sema.type_of_expr(&receiver)?.adjusted().as_adt()?.as_enum()?;\n-    let option_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_option_Option();\n-\n-    if let Some(option_enum) = option_enum {\n-        if ty == option_enum {\n-            return Some(Kind::Option);\n-        }\n-    }\n-\n-    let result_enum =\n-        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_result_Result();\n-\n-    if let Some(result_enum) = result_enum {\n-        if ty == result_enum {\n-            return Some(Kind::Result);\n-        }\n-    }\n-\n-    None\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn replace_or_with_or_else_simple() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or(2);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(|| 2);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_with_or_else_call() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or(x());\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(x);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_with_or_else_block() {\n-        check_assist(\n-            replace_or_with_or_else,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or({\n-        let mut x = bar();\n-        for i in 0..10 {\n-            x += i;\n-        }\n-        x\n-    });\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or_else(|| {\n-        let mut x = bar();\n-        for i in 0..10 {\n-            x += i;\n-        }\n-        x\n-    });\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_simple() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or_else(|| 2);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or(2);\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_call() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: option\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Some(1);\n-    return foo.unwrap_or(x());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_result() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: result\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_or(x());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_map() {\n-        check_assist(\n-            replace_or_else_with_or,\n-            r#\"\n-//- minicore: result\n-fn foo() {\n-    let foo = Ok(\"foo\");\n-    return foo.map$0_or_else(|| 42, |v| v.len());\n-}\n-\"#,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(\"foo\");\n-    return foo.map_or(42, |v| v.len());\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn replace_or_else_with_or_not_applicable() {\n-        check_assist_not_applicable(\n-            replace_or_else_with_or,\n-            r#\"\n-fn foo() {\n-    let foo = Ok(1);\n-    return foo.unwrap_$0or_else(x);\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "4d489b62b5c88ccca7032bc00bedc9098b5a7cc3", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -188,7 +188,7 @@ mod handlers {\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n-    mod replace_or_with_or_else;\n+    mod replace_method_eager_lazy;\n     mod replace_arith_op;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n@@ -297,8 +297,8 @@ mod handlers {\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_if_let_with_match::replace_match_with_if_let,\n             replace_let_with_if_let::replace_let_with_if_let,\n-            replace_or_with_or_else::replace_or_else_with_or,\n-            replace_or_with_or_else::replace_or_with_or_else,\n+            replace_method_eager_lazy::replace_with_eager_method,\n+            replace_method_eager_lazy::replace_with_lazy_method,\n             replace_turbofish_with_explicit_type::replace_turbofish_with_explicit_type,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_arith_op::replace_arith_with_wrapping,"}, {"sha": "e5a8d675a9ead0e924909c82538580381a52e26c", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -2313,46 +2313,6 @@ fn handle(action: Action) {\n     )\n }\n \n-#[test]\n-fn doctest_replace_or_else_with_or() {\n-    check_doc_test(\n-        \"replace_or_else_with_or\",\n-        r#####\"\n-//- minicore:option\n-fn foo() {\n-    let a = Some(1);\n-    a.unwra$0p_or_else(|| 2);\n-}\n-\"#####,\n-        r#####\"\n-fn foo() {\n-    let a = Some(1);\n-    a.unwrap_or(2);\n-}\n-\"#####,\n-    )\n-}\n-\n-#[test]\n-fn doctest_replace_or_with_or_else() {\n-    check_doc_test(\n-        \"replace_or_with_or_else\",\n-        r#####\"\n-//- minicore:option\n-fn foo() {\n-    let a = Some(1);\n-    a.unwra$0p_or(2);\n-}\n-\"#####,\n-        r#####\"\n-fn foo() {\n-    let a = Some(1);\n-    a.unwrap_or_else(|| 2);\n-}\n-\"#####,\n-    )\n-}\n-\n #[test]\n fn doctest_replace_qualified_name_with_use() {\n     check_doc_test(\n@@ -2427,6 +2387,46 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_replace_with_eager_method() {\n+    check_doc_test(\n+        \"replace_with_eager_method\",\n+        r#####\"\n+//- minicore:option, fn\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or_else(|| 2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_with_lazy_method() {\n+    check_doc_test(\n+        \"replace_with_lazy_method\",\n+        r#####\"\n+//- minicore:option, fn\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or(2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or_else(|| 2);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_sort_items() {\n     check_doc_test("}, {"sha": "a8e883690883751813ebd656edc87a50f8205685", "filename": "crates/ide-ssr/src/matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide-ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Fmatching.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -561,7 +561,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                             .sema\n                             .resolve_method_call_as_callable(code)\n                             .and_then(|callable| callable.receiver_param(self.sema.db))\n-                            .map(|self_param| self_param.kind())\n+                            .map(|(self_param, _)| self_param.kind())\n                             .unwrap_or(ast::SelfParamKind::Owned);\n                     }\n                 }"}, {"sha": "6a50927333d4f6b47433cbb701cb4b54145536f1", "filename": "crates/ide/src/inlay_hints/bind_pat.rs", "status": "modified", "additions": 12, "deletions": 105, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fbind_pat.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -176,15 +176,12 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir\n mod tests {\n     // This module also contains tests for super::closure_ret\n \n-    use expect_test::expect;\n     use syntax::{TextRange, TextSize};\n     use test_utils::extract_annotations;\n \n     use crate::{fixture, inlay_hints::InlayHintsConfig};\n \n-    use crate::inlay_hints::tests::{\n-        check, check_expect, check_with_config, DISABLED_CONFIG, TEST_CONFIG,\n-    };\n+    use crate::inlay_hints::tests::{check, check_with_config, DISABLED_CONFIG, TEST_CONFIG};\n     use crate::ClosureReturnTypeHints;\n \n     #[track_caller]\n@@ -278,8 +275,7 @@ fn main() {\n     #[test]\n     fn iterator_hint_regression_issue_12674() {\n         // Ensure we don't crash while solving the projection type of iterators.\n-        check_expect(\n-            InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+        let (analysis, file_id) = fixture::file(\n             r#\"\n //- minicore: iterators\n struct S<T>(T);\n@@ -302,107 +298,18 @@ impl<'a, T> Iterator for SliceIter<'a, T> {\n \n fn main(a: SliceIter<'_, Container>) {\n     a\n-    .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n-    .map(|e| e);\n+        .filter_map(|c| Some(c.elements.iter().filter_map(|v| Some(v))))\n+        .map(|e| e);\n }\n-            \"#,\n-            expect![[r#\"\n-                [\n-                    InlayHint {\n-                        range: 484..554,\n-                        kind: Chaining,\n-                        label: [\n-                            \"impl \",\n-                            InlayHintLabelPart {\n-                                text: \"Iterator\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2611..2619,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Item\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2643..2647,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \" = impl \",\n-                            InlayHintLabelPart {\n-                                text: \"Iterator\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2611..2619,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Item\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            1,\n-                                        ),\n-                                        range: 2643..2647,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \" = &&str>>\",\n-                        ],\n-                    },\n-                    InlayHint {\n-                        range: 484..485,\n-                        kind: Chaining,\n-                        label: [\n-                            \"\",\n-                            InlayHintLabelPart {\n-                                text: \"SliceIter\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            0,\n-                                        ),\n-                                        range: 289..298,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \"<\",\n-                            InlayHintLabelPart {\n-                                text: \"Container\",\n-                                linked_location: Some(\n-                                    FileRange {\n-                                        file_id: FileId(\n-                                            0,\n-                                        ),\n-                                        range: 238..247,\n-                                    },\n-                                ),\n-                                tooltip: \"\",\n-                            },\n-                            \">\",\n-                        ],\n-                    },\n-                ]\n-            \"#]],\n+\"#,\n         );\n+        analysis\n+            .inlay_hints(\n+                &InlayHintsConfig { chaining_hints: true, ..DISABLED_CONFIG },\n+                file_id,\n+                None,\n+            )\n+            .unwrap();\n     }\n \n     #[test]"}, {"sha": "0a7513e465a57766be3db556ad41512d61ed4746", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2611..2619,\n+                                        range: 3386..3394,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 2643..2647,\n+                                        range: 3418..3422,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "2c08c457b338c513281f4291dbaf63e1bccaa5ba", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -172,7 +172,7 @@ fn signature_help_for_call(\n \n     res.signature.push('(');\n     {\n-        if let Some(self_param) = callable.receiver_param(db) {\n+        if let Some((self_param, _)) = callable.receiver_param(db) {\n             format_to!(res.signature, \"{}\", self_param)\n         }\n         let mut buf = String::new();"}, {"sha": "b6336e2216f1a76a465ce0dc05eecf41a24b3dfa", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c12ec282de5e2d4e835f320f8858277b3ba133/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=31c12ec282de5e2d4e835f320f8858277b3ba133", "patch": "@@ -534,6 +534,40 @@ pub mod option {\n                 None => panic!(\"called `Option::unwrap()` on a `None` value\"),\n             }\n         }\n+\n+        pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n+            loop {}\n+        }\n+        pub fn unwrap_or(self, default: T) -> T {\n+            loop {}\n+        }\n+        // region:fn\n+        pub fn and_then<U, F>(self, f: F) -> Option<U>\n+        where\n+            F: FnOnce(T) -> Option<U>,\n+        {\n+            loop {}\n+        }\n+        pub fn unwrap_or_else<F>(self, f: F) -> T\n+        where\n+            F: FnOnce() -> T,\n+        {\n+            loop {}\n+        }\n+        pub fn map_or<U, F>(self, default: U, f: F) -> U\n+        where\n+            F: FnOnce(T) -> U,\n+        {\n+            loop {}\n+        }\n+        pub fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n+        where\n+            D: FnOnce() -> U,\n+            F: FnOnce(T) -> U,\n+        {\n+            loop {}\n+        }\n+        // endregion:fn\n     }\n }\n // endregion:option"}]}