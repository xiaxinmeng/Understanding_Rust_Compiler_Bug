{"sha": "6d24b37a70de0afc2b145aff72964162ec8a4291", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjRiMzdhNzBkZTBhZmMyYjE0NWFmZjcyOTY0MTYyZWM4YTQyOTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-01T12:53:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-05T08:17:48Z"}, "message": "let the Value handle enum projections, so the visitor does not have to care", "tree": {"sha": "199d68820b027e763b6767420006807aa269091d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/199d68820b027e763b6767420006807aa269091d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d24b37a70de0afc2b145aff72964162ec8a4291", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d24b37a70de0afc2b145aff72964162ec8a4291", "html_url": "https://github.com/rust-lang/rust/commit/6d24b37a70de0afc2b145aff72964162ec8a4291", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d24b37a70de0afc2b145aff72964162ec8a4291/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0f1b1a73ee1c5be48d3a288eff50a46b773a9df", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f1b1a73ee1c5be48d3a288eff50a46b773a9df", "html_url": "https://github.com/rust-lang/rust/commit/b0f1b1a73ee1c5be48d3a288eff50a46b773a9df"}], "stats": {"total": 86, "additions": 56, "deletions": 30}, "files": [{"sha": "f7ba92c40ebf1cfc9732bd56356e72d10eb48e54", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6d24b37a70de0afc2b145aff72964162ec8a4291/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d24b37a70de0afc2b145aff72964162ec8a4291/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=6d24b37a70de0afc2b145aff72964162ec8a4291", "patch": "@@ -173,11 +173,15 @@ impl<'rt, 'a, 'tcx, Tag> ValidityVisitor<'rt, 'a, 'tcx, Tag> {\n \n             // enums\n             ty::Adt(def, ..) if def.is_enum() => {\n-                let variant = match layout.variants {\n-                    layout::Variants::Single { index } => &def.variants[index],\n-                    _ => bug!(\"aggregate_field_path_elem: got enum but not in a specific variant\"),\n-                };\n-                PathElem::Field(variant.fields[field].ident.name)\n+                // we might be projecting *to* a variant, or to a field *in*a variant.\n+                match layout.variants {\n+                    layout::Variants::Single { index } =>\n+                        // Inside a variant\n+                        PathElem::Field(def.variants[index].fields[field].ident.name),\n+                    _ =>\n+                        // To a variant\n+                        PathElem::Field(def.variants[field].name)\n+                }\n             }\n \n             // other ADTs\n@@ -226,30 +230,21 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         Ok(())\n     }\n \n-    fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n+    #[inline]\n+    fn visit(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)\n         -> EvalResult<'tcx>\n     {\n-        let variant = match ectx.read_discriminant(self.op) {\n-            Ok(res) => res.1,\n-            Err(err) => return match err.kind {\n+        // Translate enum discriminant errors to something nicer.\n+        match ectx.walk_value(self) {\n+            Ok(()) => Ok(()),\n+            Err(err) => match err.kind {\n                 EvalErrorKind::InvalidDiscriminant(val) =>\n                     validation_failure!(\n                         format!(\"invalid enum discriminant {}\", val), self.path\n                     ),\n-                _ =>\n-                    validation_failure!(\n-                        format!(\"non-integer enum discriminant\"), self.path\n-                    ),\n+                _ => Err(err),\n             }\n-        };\n-        // Put the variant projection onto the path, as a field\n-        self.path.push(PathElem::Field(self.op.layout.ty\n-                                    .ty_adt_def()\n-                                    .unwrap()\n-                                    .variants[variant].name));\n-        // Proceed with this variant\n-        self.op = ectx.operand_downcast(self.op, variant)?;\n-        Ok(())\n+        }\n     }\n \n     fn visit_primitive(&mut self, ectx: &mut EvalContext<'a, 'mir, 'tcx, M>)"}, {"sha": "863eeb3b250020307ca512bc4d651b469e66a328", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 39, "deletions": 8, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6d24b37a70de0afc2b145aff72964162ec8a4291/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d24b37a70de0afc2b145aff72964162ec8a4291/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=6d24b37a70de0afc2b145aff72964162ec8a4291", "patch": "@@ -30,6 +30,13 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     // Create this from an `MPlaceTy`.\n     fn from_mem_place(MPlaceTy<'tcx, M::PointerTag>) -> Self;\n \n+    // Read the current enum discriminant, and downcast to that.  Also return the\n+    // variant index.\n+    fn project_downcast(\n+        self,\n+        ectx: &EvalContext<'a, 'mir, 'tcx, M>\n+    ) -> EvalResult<'tcx, (Self, usize)>;\n+\n     // Project to the n-th field.\n     fn project_field(\n         self,\n@@ -60,6 +67,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         mplace.into()\n     }\n \n+    #[inline(always)]\n+    fn project_downcast(\n+        self,\n+        ectx: &EvalContext<'a, 'mir, 'tcx, M>\n+    ) -> EvalResult<'tcx, (Self, usize)> {\n+        let idx = ectx.read_discriminant(self)?.1;\n+        Ok((ectx.operand_downcast(self, idx)?, idx))\n+    }\n+\n     #[inline(always)]\n     fn project_field(\n         self,\n@@ -90,6 +106,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         mplace\n     }\n \n+    #[inline(always)]\n+    fn project_downcast(\n+        self,\n+        ectx: &EvalContext<'a, 'mir, 'tcx, M>\n+    ) -> EvalResult<'tcx, (Self, usize)> {\n+        let idx = ectx.read_discriminant(self.into())?.1;\n+        Ok((ectx.mplace_downcast(self, idx)?, idx))\n+    }\n+\n     #[inline(always)]\n     fn project_field(\n         self,\n@@ -120,6 +145,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n         mplace.into()\n     }\n \n+    #[inline(always)]\n+    fn project_downcast(\n+        self,\n+        ectx: &EvalContext<'a, 'mir, 'tcx, M>\n+    ) -> EvalResult<'tcx, (Self, usize)> {\n+        let idx = ectx.read_discriminant(ectx.place_to_op(self)?)?.1;\n+        Ok((ectx.place_downcast(self, idx)?, idx))\n+    }\n+\n     #[inline(always)]\n     fn project_field(\n         self,\n@@ -155,12 +189,6 @@ pub trait ValueVisitor<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: fmt::Debug +\n         field: usize,\n     ) -> EvalResult<'tcx>;\n \n-    // This is an enum, downcast it to whatever the current variant is.\n-    // (We do this here and not in `Value` to keep error handling\n-    // under control of th visitor.)\n-    fn downcast_enum(&mut self, ectx: &EvalContext<'a, 'mir, 'tcx, M>)\n-        -> EvalResult<'tcx>;\n-\n     // A chance for the visitor to do special (different or more efficient) handling for some\n     // array types.  Return `true` if the value was handled and we should return.\n     #[inline]\n@@ -202,8 +230,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         match v.layout().variants {\n             layout::Variants::NicheFilling { .. } |\n             layout::Variants::Tagged { .. } => {\n-                v.downcast_enum(self)?;\n-                trace!(\"variant layout: {:#?}\", v.layout());\n+                let (inner, idx) = v.value().project_downcast(self)?;\n+                trace!(\"variant layout: {:#?}\", inner.layout());\n+                // recurse with the inner type\n+                return v.visit_field(self, inner, idx);\n             }\n             layout::Variants::Single { .. } => {}\n         }\n@@ -215,6 +245,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // immediate trait objects are not a thing\n                 let dest = v.value().force_allocation(self)?;\n                 let inner = self.unpack_dyn_trait(dest)?.1;\n+                trace!(\"dyn object layout: {:#?}\", inner.layout);\n                 // recurse with the inner type\n                 return v.visit_field(self, Value::from_mem_place(inner), 0);\n             },"}]}