{"sha": "cd440d338efa935713c92a56dc8eec67a703e521", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNDQwZDMzOGVmYTkzNTcxM2M5MmE1NmRjOGVlYzY3YTcwM2U1MjE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-18T08:01:39Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-18T08:02:13Z"}, "message": "Remove or _-prefix all unused function arguments\n\nThis should make the compilation process a bit less noisy.", "tree": {"sha": "810da73f6b98235c7dda573829201c77dbf38597", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/810da73f6b98235c7dda573829201c77dbf38597"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd440d338efa935713c92a56dc8eec67a703e521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd440d338efa935713c92a56dc8eec67a703e521", "html_url": "https://github.com/rust-lang/rust/commit/cd440d338efa935713c92a56dc8eec67a703e521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd440d338efa935713c92a56dc8eec67a703e521/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2885c67d473b4522441f118149945b516d5ca658", "url": "https://api.github.com/repos/rust-lang/rust/commits/2885c67d473b4522441f118149945b516d5ca658", "html_url": "https://github.com/rust-lang/rust/commit/2885c67d473b4522441f118149945b516d5ca658"}], "stats": {"total": 379, "additions": 187, "deletions": 192}, "files": [{"sha": "11df59a7f43465d97f2a3ff7340afcec051a309f", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -313,7 +313,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(sha: sha1, crate: &ast::crate,\n+    fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n                               metas: &provided_metas) -> str {\n         fn len_and_str(s: &str) -> str {\n             ret #fmt(\"%u_%s\", str::byte_len(s), s);\n@@ -349,7 +349,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n                        name, default));\n     }\n \n-    fn crate_meta_name(sess: &session::session, crate: &ast::crate,\n+    fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n                        output: &str, metas: &provided_metas) -> str {\n         ret alt metas.name {\n               some(v) { v }\n@@ -368,7 +368,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n             };\n     }\n \n-    fn crate_meta_vers(sess: &session::session, crate: &ast::crate,\n+    fn crate_meta_vers(sess: &session::session, _crate: &ast::crate,\n                        metas: &provided_metas) -> str {\n         ret alt metas.vers {\n               some(v) { v }\n@@ -435,7 +435,7 @@ fn mangle(ss: &[str]) -> str {\n     ret n;\n }\n \n-fn exported_name(path: &[str], hash: &str, vers: &str) -> str {\n+fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + ~[hash]); //  + \"@\" + vers;\n@@ -459,7 +459,7 @@ fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n     ret mangle(path + ~[ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(ccx: &@crate_ctxt, path: &[str]) -> str {\n+fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[str]) -> str {\n     ret mangle(path);\n }\n "}, {"sha": "2edc027811cfa98fa264acf99a88b696da99bfc2", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -50,23 +50,23 @@ type upcalls =\n      dynastack_alloc: ValueRef,\n      dynastack_free: ValueRef};\n \n-fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n+fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n-    fn decl(tn: type_names, llmod: ModuleRef, name: str, tys: [TypeRef],\n+    fn decl(llmod: ModuleRef, name: str, tys: [TypeRef],\n           rv: TypeRef) -> ValueRef {\n         let arg_tys: [TypeRef] = ~[];\n         for t: TypeRef in tys { arg_tys += ~[t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    fn decl_with_taskptr(taskptr_type: TypeRef, tn: type_names,\n+    fn decl_with_taskptr(taskptr_type: TypeRef,\n                          llmod: ModuleRef, name: str, tys: [TypeRef],\n                          rv: TypeRef) -> ValueRef {\n-        ret decl(tn, llmod, name, ~[taskptr_type] + tys, rv);\n+        ret decl(llmod, name, ~[taskptr_type] + tys, rv);\n     }\n-    let dv = bind decl_with_taskptr(taskptr_type, tn, llmod, _, _, T_void());\n-    let d = bind decl_with_taskptr(taskptr_type, tn, llmod, _, _, _);\n-    let dr = bind decl(tn, llmod, _, _, _);\n+    let dv = bind decl_with_taskptr(taskptr_type, llmod, _, _, T_void());\n+    let d = bind decl_with_taskptr(taskptr_type, llmod, _, _, _);\n+    let dr = bind decl(llmod, _, _, _);\n \n     let empty_vec: [TypeRef] = ~[];\n     ret @{grow_task: dv(\"grow_task\", ~[T_size_t()]),"}, {"sha": "ce172c0062f616239a840c4b43cc336e08bff66d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -51,7 +51,8 @@ fn modify_for_testing(crate: @ast::crate) -> @ast::crate {\n     ret res;\n }\n \n-fn fold_mod(cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n+fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold)\n+    -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should"}, {"sha": "9d80972ffb5f869c6285b9d6073d5de9445a91d5", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -1264,7 +1264,7 @@ obj builder(B: BuilderRef, terminated: @mutable bool,\n         ret llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, str::buf(\"\"));\n     }\n \n-    fn Cast(Op: Opcode, Val: ValueRef, DestTy: TypeRef, Name: sbuf) ->\n+    fn Cast(Op: Opcode, Val: ValueRef, DestTy: TypeRef, _Name: sbuf) ->\n        ValueRef {\n         assert (!*terminated);\n         ret llvm::LLVMBuildCast(B, Op, Val, DestTy, str::buf(\"\"));"}, {"sha": "dcb5fa2488d76c3a8f4ec07f947c0a32d68a297d", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -224,7 +224,7 @@ fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n+fn get_tag_variants(_data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n                     extres: &external_resolver) -> [ty::variant_info] {\n     let external_crate_id = def.crate;\n     let data ="}, {"sha": "c753760e0a46414d3aea4f9b4bf13a1cf195990b", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -39,7 +39,7 @@ fn parse_ident(st: @pstate, sd: str_def, last: char) -> ast::ident {\n     ret parse_ident_(st, sd, bind is_last(last, _));\n }\n \n-fn parse_ident_(st: @pstate, sd: str_def, is_last: fn(char) -> bool ) ->\n+fn parse_ident_(st: @pstate, _sd: str_def, is_last: fn(char) -> bool ) ->\n    ast::ident {\n     let rslt = \"\";\n     while !is_last(peek(st) as char) {\n@@ -117,7 +117,7 @@ fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n \n type arg_parser<T> = fn(@pstate, str_def) -> ast::constr_arg_general_<T> ;\n \n-fn parse_constr_arg(st: @pstate, sd: str_def) -> ast::fn_constr_arg {\n+fn parse_constr_arg(st: @pstate, _sd: str_def) -> ast::fn_constr_arg {\n     alt peek(st) as char {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n       c {"}, {"sha": "9edd0f14ba325dd3ec198f55ed97477fdc4f794e", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -51,8 +51,8 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n-            name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt<scope>) {\n+fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n+            _name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for arg_: ast::arg in f.decl.inputs {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));"}, {"sha": "cca7667a691925696dbfbd47acb6d095c870426d", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -87,7 +87,7 @@ fn new_smallintmap_adapter<@K,\n             ret smallintmap::find(map, key_idx(key));\n         }\n \n-        fn remove(key: &K) -> option::t<V> { fail }\n+        fn remove(_key: &K) -> option::t<V> { fail }\n \n         fn rehash() { fail }\n "}, {"sha": "2822e404e509421275019b471595b20e8ab3841c", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -44,8 +44,8 @@ fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n     for decl: ast::node_id in initial_decls { set_add(decls, decl); }\n     let refs = @mutable ~[];\n \n-    let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n-                         i: &ast::fn_ident, nid: ast::node_id) {\n+    let walk_fn = lambda(f: &ast::_fn, _tps: &[ast::ty_param], _sp: &span,\n+                         _i: &ast::fn_ident, _nid: ast::node_id) {\n         for a: ast::arg in f.decl.inputs { set_add(decls, a.id); }\n     };\n     let walk_expr = lambda(expr: &@ast::expr) {"}, {"sha": "8009100c68f08cf6272e147d9d62b8ef366f5e52", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -169,7 +169,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: ~[],\n                        glob_imported_names: new_str_hash::<import_state>()});\n-    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n+    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, _v: &vt<scopes>) {\n         alt i.node {\n           ast::view_item_import(name, ids, id) {\n             e.imports.insert(id, todo(id, name, ids, i.span, sc));\n@@ -215,7 +215,8 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n              with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n-    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n+    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes,\n+                 _v: &vt<scopes>) {\n         fn find_mod(e: @env, sc: scopes) -> @indexed_mod {\n             alt sc {\n               cons(scope_item(i), tl) {\n@@ -267,7 +268,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n           visit_item: visit_item_with_scope,\n           visit_block: visit_block_with_scope,\n           visit_decl: visit_decl_with_scope,\n-          visit_arm: bind walk_arm(e, _, _, _),\n+          visit_arm: walk_arm,\n           visit_pat: bind walk_pat(e, _, _, _),\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n@@ -299,10 +300,10 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n         }\n     }\n     fn walk_constr(e: @env, p: &ast::path, sp: &span, id: node_id,\n-                   sc: &scopes, v: &vt<scopes>) {\n+                   sc: &scopes, _v: &vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n-    fn walk_arm(e: @env, a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n+    fn walk_arm(a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n         visit_arm_with_scope(a, sc, v);\n     }\n     fn walk_pat(e: &@env, pat: &@ast::pat, sc: &scopes, v: &vt<scopes>) {\n@@ -359,7 +360,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n     // for f's constrs in the table.\n \n     for c: @ast::constr in f.decl.constraints {\n-        resolve_constr(e, id, c, sc, v);\n+        resolve_constr(e, c, sc, v);\n     }\n     visit::visit_fn(f, tp, sp, name, id,\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n@@ -436,8 +437,7 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n     } else { ret none; }\n }\n \n-fn resolve_constr(e: @env, id: node_id, c: &@ast::constr, sc: &scopes,\n-                  v: &vt<scopes>) {\n+fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n     let new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n     if option::is_some(new_def) {\n@@ -921,7 +921,7 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n     }\n }\n \n-fn found_view_item(e: &env, vi: @ast::view_item, ns: namespace) ->\n+fn found_view_item(e: &env, vi: @ast::view_item) ->\n    option::t<def> {\n     alt vi.node {\n       ast::view_item_use(_, _, id) {\n@@ -1040,7 +1040,9 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n    option::t<def> {\n     alt mie {\n-      mie_view_item(view_item) { ret found_view_item(e, view_item, ns); }\n+      mie_view_item(view_item) {\n+        if ns == ns_module { ret found_view_item(e, view_item); }\n+      }\n       mie_import_ident(id, _) { ret lookup_import(e, local_def(id), ns); }\n       mie_item(item) { ret found_def_item(item, ns); }\n       mie_tag_variant(item, variant_idx) {"}, {"sha": "9c3c917603903c018a162cf52b0dd9b5278cf084", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -231,15 +231,15 @@ fn tag_kind(ccx : &@crate_ctxt, did : &ast::def_id) -> tag_kind {\n \n \n // Returns the code corresponding to the pointer size on this architecture.\n-fn s_int(tcx : &ty_ctxt) -> u8 {\n+fn s_int(_tcx : &ty_ctxt) -> u8 {\n     ret shape_i32;      // TODO: x86-64\n }\n \n-fn s_uint(tcx : &ty_ctxt) -> u8 {\n+fn s_uint(_tcx : &ty_ctxt) -> u8 {\n     ret shape_u32;      // TODO: x86-64\n }\n \n-fn s_float(tcx : &ty_ctxt) -> u8 {\n+fn s_float(_tcx : &ty_ctxt) -> u8 {\n     ret shape_f64;      // TODO: x86-64\n }\n "}, {"sha": "a18b495a7bbd9fb946aaad8228c645c6ccc75658", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -387,9 +387,8 @@ fn get_simple_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n     ret get_extern_fn(externs, llmod, name, lib::llvm::LLVMCCallConv, t);\n }\n \n-fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n-                     externs: &hashmap<str, ValueRef>, tn: &type_names,\n-                     llmod: ModuleRef, name: &str, pass_task: bool,\n+fn trans_native_call(b: &builder, externs: &hashmap<str, ValueRef>,\n+                     llmod: ModuleRef, name: &str,\n                      args: &[ValueRef]) -> ValueRef {\n     let n: int = std::vec::len::<ValueRef>(args) as int;\n     let llnative: ValueRef = get_simple_extern_fn(externs, llmod, name, n);\n@@ -1933,7 +1932,7 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n                        elt_ty: & // elt*\n                            ty::t, f: &val_and_ty_fn) -> result {\n     fn adaptor_fn(f: val_and_ty_fn, elt_ty: ty::t, cx: &@block_ctxt,\n-                  dst: ValueRef, src: ValueRef) -> result {\n+                  _dst: ValueRef, src: ValueRef) -> result {\n         let llptrty;\n         if !ty::type_has_dynamic_size(bcx_tcx(cx), elt_ty) {\n             let llty = type_of(bcx_ccx(cx), cx.sp, elt_ty);\n@@ -2537,7 +2536,7 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n }\n \n fn trans_compare(cx: &@block_ctxt, op: ast::binop,\n-                 lhs: ValueRef, lhs_t: ty::t, rhs: ValueRef,\n+                 lhs: ValueRef, _lhs_t: ty::t, rhs: ValueRef,\n                  rhs_t: ty::t) -> result {\n     // Determine the operation we need.\n     let llop;\n@@ -3398,8 +3397,8 @@ fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n tag out_method { return; save_in(ValueRef); }\n \n fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n-            els: &option::t<@ast::expr>, id: ast::node_id,\n-            output: &out_method) -> result {\n+            els: &option::t<@ast::expr>, output: &out_method)\n+    -> result {\n     let cond_res = trans_expr(cx, cond);\n \n     if (ty::type_is_bot(bcx_tcx(cx), ty::expr_ty(bcx_tcx(cx), cond))) {\n@@ -3866,8 +3865,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n     ret lv;\n }\n \n-fn lookup_discriminant(lcx: &@local_ctxt, tid: &ast::def_id,\n-                       vid: &ast::def_id) -> ValueRef {\n+fn lookup_discriminant(lcx: &@local_ctxt, vid: &ast::def_id) -> ValueRef {\n     alt lcx.ccx.discrims.find(vid.node) {\n       none. {\n         // It's an external discriminant that we haven't seen yet.\n@@ -3929,7 +3927,7 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) ->\n             let bcx = alloc_result.bcx;\n             let lltagptr = bcx.build.PointerCast(lltagblob, T_ptr(lltagty));\n             if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n-                let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, tid, vid);\n+                let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n                 let lldiscrim = bcx.build.Load(lldiscrim_gv);\n                 let lldiscrimptr =\n                     bcx.build.GEP(lltagptr, ~[C_int(0), C_int(0)]);\n@@ -3968,7 +3966,7 @@ fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n }\n \n fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: &ty::t,\n-               field: &ast::ident, id: ast::node_id) -> lval_result {\n+               field: &ast::ident) -> lval_result {\n     let r = autoderef(cx, v, t0);\n     let t = r.ty;\n     alt ty::struct(bcx_tcx(cx), t) {\n@@ -4085,7 +4083,7 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n       ast::expr_field(base, ident) {\n         let r = trans_expr(cx, base);\n         let t = ty::expr_ty(bcx_tcx(cx), base);\n-        ret trans_field(r.bcx, e.span, r.val, t, ident, e.id);\n+        ret trans_field(r.bcx, e.span, r.val, t, ident);\n       }\n       ast::expr_index(base, idx) {\n         ret trans_index(cx, e.span, base, idx, e.id);\n@@ -4123,7 +4121,7 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n           some(pair) {\n             let r = pair.v;\n             let t = pair.t;\n-            ret trans_field(cx, e.span, r, t, ident, e.id);\n+            ret trans_field(cx, e.span, r, t, ident);\n           }\n           _ {\n             // Shouldn't happen.\n@@ -4237,8 +4235,7 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n \n fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n                     outgoing_fty: &ty::t, args: &[option::t<@ast::expr>],\n-                    env_ty: &ty::t, bound_tys: &[ty::t],\n-                    ty_param_count: uint,\n+                    env_ty: &ty::t, ty_param_count: uint,\n                     target_fn: &option::t<ValueRef>) ->\n     {val: ValueRef, ty: TypeRef} {\n \n@@ -4494,7 +4491,7 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     let pair_ty = node_id_type(bcx_ccx(cx), id);\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real,\n-                         args, closure.ptrty, bound_tys, ty_param_count,\n+                         args, closure.ptrty, ty_param_count,\n                          target_res);\n \n     // Construct the function pair\n@@ -4994,11 +4991,11 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       }\n       ast::expr_binary(op, x, y) { ret trans_binary(cx, op, x, y); }\n       ast::expr_if(cond, thn, els) {\n-        ret with_out_method(bind trans_if(cx, cond, thn, els, e.id, _), cx,\n+        ret with_out_method(bind trans_if(cx, cond, thn, els, _), cx,\n                             e.id, output);\n       }\n       ast::expr_if_check(cond, thn, els) {\n-        ret with_out_method(bind trans_if(cx, cond, thn, els, e.id, _), cx,\n+        ret with_out_method(bind trans_if(cx, cond, thn, els, _), cx,\n                             e.id, output);\n       }\n       ast::expr_ternary(_, _, _) {\n@@ -5011,8 +5008,8 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n       ast::expr_while(cond, body) { ret trans_while(cx, cond, body); }\n       ast::expr_do_while(body, cond) { ret trans_do_while(cx, body, cond); }\n       ast::expr_alt(expr, arms) {\n-        ret with_out_method(bind trans_alt::trans_alt(cx, expr, arms, e.id,\n-                                                      _), cx, e.id, output);\n+        ret with_out_method(bind trans_alt::trans_alt(cx, expr, arms, _),\n+                            cx, e.id, output);\n       }\n       ast::expr_fn(f) {\n         let ccx = bcx_ccx(cx);\n@@ -5911,8 +5908,7 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n     }\n }\n \n-fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg],\n-                        arg_tys: &[ty::arg]) {\n+fn copy_args_to_allocas(fcx: @fn_ctxt, args: &[ast::arg]) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n@@ -6050,7 +6046,7 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n       _ { }\n     }\n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n+    copy_args_to_allocas(fcx, f.decl.inputs);\n \n     // Figure out if we need to build a closure and act accordingly\n     let res = alt f.proto {\n@@ -6203,7 +6199,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         i += 1u;\n     }\n     let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n-    copy_args_to_allocas(fcx, fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, fn_args);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n \n@@ -6356,7 +6352,7 @@ fn decl_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str], flav: str,\n }\n \n fn decl_fn_and_pair_full(ccx: &@crate_ctxt, sp: &span, path: &[str],\n-                         flav: str, ty_params: &[ast::ty_param],\n+                         _flav: str, ty_params: &[ast::ty_param],\n                          node_id: ast::node_id, node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n                                    std::vec::len(ty_params));\n@@ -6690,7 +6686,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n \n     fn trans_simple_native_abi(bcx: &@block_ctxt, name: str,\n                                call_args: &mutable [ValueRef], fn_type: ty::t,\n-                               first_arg_n: uint, uses_retptr: bool, cc: uint)\n+                               uses_retptr: bool, cc: uint)\n        -> {val: ValueRef, rptr: ValueRef} {\n         let call_arg_tys: [TypeRef] = ~[];\n         for arg: ValueRef in call_args { call_arg_tys += ~[val_ty(arg)]; }\n@@ -6738,7 +6734,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     alt abi {\n       ast::native_abi_llvm. {\n         let result =\n-            trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n,\n+            trans_simple_native_abi(bcx, name, call_args, fn_type,\n                                     uses_retptr, lib::llvm::LLVMCCallConv);\n         r = result.val;\n         rptr = result.rptr;\n@@ -6747,23 +6743,22 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n         let external_name = \"rust_intrinsic_\" + name;\n         let result =\n             trans_simple_native_abi(bcx, external_name, call_args, fn_type,\n-                                    arg_n, uses_retptr,\n-                                    lib::llvm::LLVMCCallConv);\n+                                    uses_retptr, lib::llvm::LLVMCCallConv);\n         r = result.val;\n         rptr = result.rptr;\n       }\n       ast::native_abi_x86stdcall. {\n         let result =\n-            trans_simple_native_abi(bcx, name, call_args, fn_type, arg_n,\n+            trans_simple_native_abi(bcx, name, call_args, fn_type,\n                                     uses_retptr,\n                                     lib::llvm::LLVMX86StdcallCallConv);\n         r = result.val;\n         rptr = result.rptr;\n       }\n       _ {\n         r =\n-            trans_native_call(bcx.build, ccx.glues, lltaskptr, ccx.externs,\n-                              ccx.tn, ccx.llmod, name, pass_task, call_args);\n+            trans_native_call(bcx.build, ccx.externs,\n+                              ccx.llmod, name, call_args);\n         rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n       }\n     }\n@@ -6783,7 +6778,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n fn item_path(item: &@ast::item) -> [str] { ret ~[item.ident]; }\n \n fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n-                       v: &vt<[str]>) {\n+                       _v: &vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {"}, {"sha": "ec029e6dd98707fa86302a7ae5208d1cd971c7a0", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -460,7 +460,7 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n }\n \n fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n-             id: ast::node_id, output: &trans::out_method) -> result {\n+             output: &trans::out_method) -> result {\n     let bodies = ~[];\n     let match: match = ~[];\n     let er = trans::trans_expr(cx, expr);"}, {"sha": "8323d1d573744bf1a5468741f25d58b2ffa20194", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -692,12 +692,12 @@ fn T_str() -> TypeRef { ret T_vec(T_i8()); }\n \n fn T_box(t: TypeRef) -> TypeRef { ret T_struct(~[T_int(), t]); }\n \n-fn T_port(t: TypeRef) -> TypeRef {\n+fn T_port(_t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int()]); // Refcount\n \n }\n \n-fn T_chan(t: TypeRef) -> TypeRef {\n+fn T_chan(_t: TypeRef) -> TypeRef {\n     ret T_struct(~[T_int()]); // Refcount\n \n }"}, {"sha": "8a95fb903345a095d06cbf938e5d77e387877769", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -55,7 +55,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, fn_args);\n \n     //  Create the first block context in the function and keep a handle on it\n     //  to pass to finish_fn later.\n@@ -601,7 +601,7 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str)\n // returns the value returned from that call.\n fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n                        ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n-                       additional_field_tys: &[ty::t]) -> ValueRef {\n+                       _additional_field_tys: &[ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating."}, {"sha": "3e5b25ec5eedd933fd887b039997f5b117dffd0d", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -740,7 +740,7 @@ fn find_instance_(pattern: &[constr_arg_general_<inst>],\n type inst = {ident: ident, node: node_id};\n type subst = [{from: inst, to: inst}];\n \n-fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n+fn find_instances(_fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n    [{from: uint, to: uint}] {\n \n     let rslt = ~[];\n@@ -996,15 +996,15 @@ fn any_eq(v: &[node_id], d: node_id) -> bool {\n     false\n }\n \n-fn constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint, v: node_id) ->\n+fn constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint, v: node_id) ->\n    bool {\n     ret alt c.c.node {\n           ninit(id, _) { v == id }\n           npred(_, _, args) { args_mention(args, any_eq, ~[v]) }\n         };\n }\n \n-fn non_init_constraint_mentions(fcx: &fn_ctxt, c: &norm_constraint,\n+fn non_init_constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint,\n                                 v: &node_id) -> bool {\n     ret alt c.c.node {\n           ninit(_, _) { false }\n@@ -1051,8 +1051,8 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing<T>(f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n-                 iid: node_id, cx: &T, v: &visit::vt<T>) {\n+fn do_nothing<T>(_f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n+                 _iid: node_id, _cx: &T, _v: &visit::vt<T>) {\n }\n \n "}, {"sha": "6e45902dfcf8ae622022fa1780fa0cc8cdabffba", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -165,8 +165,8 @@ fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b:&blk) {\n         @{visit_block: relax_precond_block_inner,\n           visit_expr: relax_precond_expr,\n           visit_stmt: relax_precond_stmt,\n-          visit_item: (fn (i: &@item, cx: &relax_ctxt,\n-                           vt: &visit::vt<relax_ctxt>) {})\n+          visit_item: (fn (_i: &@item, _cx: &relax_ctxt,\n+                           _vt: &visit::vt<relax_ctxt>) {})\n           with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);"}, {"sha": "958687bfb00d5ff0df456199785ac18361e809ed", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -45,12 +45,12 @@ import util::common::log_block;\n import syntax::codemap::span;\n import util::ppaux::fn_ident_to_string;\n \n-fn find_pre_post_mod(m: &_mod) -> _mod {\n+fn find_pre_post_mod(_m: &_mod) -> _mod {\n     log \"implement find_pre_post_mod!\";\n     fail;\n }\n \n-fn find_pre_post_native_mod(m: &native_mod) -> native_mod {\n+fn find_pre_post_native_mod(_m: &native_mod) -> native_mod {\n     log \"implement find_pre_post_native_mod\";\n     fail;\n }"}, {"sha": "ca2bfe9ca9c322a9e848d383cee0041376e75f54", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -421,7 +421,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n \n \n // Type constructors\n-fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t<str>) -> @raw_t {\n+fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n     let cname = none;\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n@@ -516,19 +516,19 @@ fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<str>) -> t {\n // use the mk_foo() functions below.\n fn gen_ty(cx: &ctxt, st: &sty) -> t { ret gen_ty_full(cx, st, none); }\n \n-fn mk_nil(cx: &ctxt) -> t { ret idx_nil; }\n+fn mk_nil(_cx: &ctxt) -> t { ret idx_nil; }\n \n-fn mk_bot(cx: &ctxt) -> t { ret idx_bot; }\n+fn mk_bot(_cx: &ctxt) -> t { ret idx_bot; }\n \n-fn mk_bool(cx: &ctxt) -> t { ret idx_bool; }\n+fn mk_bool(_cx: &ctxt) -> t { ret idx_bool; }\n \n-fn mk_int(cx: &ctxt) -> t { ret idx_int; }\n+fn mk_int(_cx: &ctxt) -> t { ret idx_int; }\n \n-fn mk_float(cx: &ctxt) -> t { ret idx_float; }\n+fn mk_float(_cx: &ctxt) -> t { ret idx_float; }\n \n-fn mk_uint(cx: &ctxt) -> t { ret idx_uint; }\n+fn mk_uint(_cx: &ctxt) -> t { ret idx_uint; }\n \n-fn mk_mach(cx: &ctxt, tm: &ast::ty_mach) -> t {\n+fn mk_mach(_cx: &ctxt, tm: &ast::ty_mach) -> t {\n     alt tm {\n       ast::ty_u8. { ret idx_u8; }\n       ast::ty_u16. { ret idx_u16; }\n@@ -543,11 +543,11 @@ fn mk_mach(cx: &ctxt, tm: &ast::ty_mach) -> t {\n     }\n }\n \n-fn mk_char(cx: &ctxt) -> t { ret idx_char; }\n+fn mk_char(_cx: &ctxt) -> t { ret idx_char; }\n \n-fn mk_str(cx: &ctxt) -> t { ret idx_str; }\n+fn mk_str(_cx: &ctxt) -> t { ret idx_str; }\n \n-fn mk_istr(cx: &ctxt) -> t { ret idx_istr; }\n+fn mk_istr(_cx: &ctxt) -> t { ret idx_istr; }\n \n fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &[t]) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n@@ -604,7 +604,7 @@ fn mk_param(cx: &ctxt, n: uint, k: ast::kind) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n \n-fn mk_type(cx: &ctxt) -> t { ret idx_type; }\n+fn mk_type(_cx: &ctxt) -> t { ret idx_type; }\n \n fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n@@ -2208,7 +2208,7 @@ mod unify {\n         fn_common_res_err(result);\n         fn_common_res_ok([arg], t);\n     }\n-    fn unify_fn_common(cx: &@ctxt, expected: &t, actual: &t,\n+    fn unify_fn_common(cx: &@ctxt, _expected: &t, _actual: &t,\n                        expected_inputs: &[arg], expected_output: &t,\n                        actual_inputs: &[arg], actual_output: &t) ->\n        fn_common_res {\n@@ -2251,7 +2251,7 @@ mod unify {\n                 expected: &t, actual: &t, expected_inputs: &[arg],\n                 expected_output: &t, actual_inputs: &[arg], actual_output: &t,\n                 expected_cf: &controlflow, actual_cf: &controlflow,\n-                expected_constrs: &[@constr], actual_constrs: &[@constr])\n+                _expected_constrs: &[@constr], actual_constrs: &[@constr])\n        -> result {\n         if e_proto != a_proto { ret ures_err(terr_mismatch); }\n         alt expected_cf {\n@@ -2858,7 +2858,7 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n     let i = 0u;\n     while i < ty_param_count { *param_var_ids += ~[next_ty_var()]; i += 1u; }\n     fn binder(sp: span, cx: ctxt, param_var_ids: @mutable [int],\n-              next_ty_var: fn() -> int , index: uint, kind: ast::kind) -> t {\n+              _next_ty_var: fn() -> int , index: uint, _kind: ast::kind) -> t {\n         if index < vec::len(*param_var_ids) {\n             ret mk_var(cx, param_var_ids.(index));\n         } else {\n@@ -2878,8 +2878,8 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int ,\n // substitions.\n fn substitute_type_params(cx: &ctxt, substs: &[ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n-    fn substituter(cx: ctxt, substs: @[ty::t], idx: uint,\n-                   kind: ast::kind) -> t {\n+    fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint,\n+                   _kind: ast::kind) -> t {\n         // FIXME: bounds check can fail\n         ret substs.(idx);\n     }"}, {"sha": "901edf3b3722b004a8db94002adbbb92e8160920", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -234,7 +234,7 @@ fn structure_of(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> ty::sty {\n \n // Returns the one-level-deep structure of the given type or none if it\n // is not known yet.\n-fn structure_of_maybe(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n+fn structure_of_maybe(fcx: &@fn_ctxt, _sp: &span, typ: ty::t) ->\n    option::t<ty::sty> {\n     let r =\n         ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n@@ -1040,7 +1040,7 @@ fn are_compatible(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) -> bool {\n \n \n // Returns the types of the arguments to a tag variant.\n-fn variant_arg_types(ccx: &@crate_ctxt, sp: &span, vid: &ast::def_id,\n+fn variant_arg_types(ccx: &@crate_ctxt, _sp: &span, vid: &ast::def_id,\n                      tag_ty_params: &[ty::t]) -> [ty::t] {\n     let result: [ty::t] = ~[];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n@@ -1160,7 +1160,7 @@ mod writeback {\n         }\n         visit::visit_local(l, wbcx, v);\n     }\n-    fn visit_item(item: &@ast::item, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_item(_item: &@ast::item, _wbcx: &wb_ctxt, _v: &wb_vt) {\n         // Ignore items\n     }\n \n@@ -1282,10 +1282,10 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     };\n \n     // Don't descend into fns and items\n-    fn visit_fn<E>(f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n-                   i: &ast::fn_ident, id: ast::node_id, e: &E,\n-                   v: &visit::vt<E>) { }\n-    fn visit_item<E>(i: &@ast::item, e: &E, v: &visit::vt<E>) { }\n+    fn visit_fn<E>(_f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n+                   _i: &ast::fn_ident, _id: ast::node_id, _e: &E,\n+                   _v: &visit::vt<E>) { }\n+    fn visit_item<E>(_i: &@ast::item, _e: &E, _v: &visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,\n@@ -1521,8 +1521,8 @@ type unifier = fn(fcx: &@fn_ctxt, sp: &span,\n                   expected: &ty::t, actual: &ty::t) -> ty::t;\n \n fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n-    fn dummy_unify(fcx: &@fn_ctxt, sp: &span,\n-                   expected: &ty::t, actual: &ty::t) -> ty::t {\n+    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span,\n+                   _expected: &ty::t, actual: &ty::t) -> ty::t {\n         actual\n     }\n     ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n@@ -1639,7 +1639,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: &@fn_ctxt, sp: &span, lhs: &@ast::expr,\n+    fn check_assignment(fcx: &@fn_ctxt, _sp: &span, lhs: &@ast::expr,\n                         rhs: &@ast::expr, id: &ast::node_id) -> bool {\n         let t = next_ty_var(fcx);\n         let bot = check_expr_with(fcx, lhs, t) | check_expr_with(fcx, rhs, t);\n@@ -1749,7 +1749,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     // or if-check\n     fn check_then_else(fcx: &@fn_ctxt, thn: &ast::blk,\n                        elsopt: &option::t<@ast::expr>, id: ast::node_id,\n-                       sp: &span) -> bool {\n+                       _sp: &span) -> bool {\n         let then_bot = check_block(fcx, thn);\n         let els_bot = false;\n         let if_t =\n@@ -2561,7 +2561,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n     ret bot;\n }\n \n-fn check_const(ccx: &@crate_ctxt, sp: &span, e: &@ast::expr,\n+fn check_const(ccx: &@crate_ctxt, _sp: &span, e: &@ast::expr,\n                id: &ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression."}, {"sha": "61eb791f6e0591cf2ccec8eb37d1368404fe9714", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -3,7 +3,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t<str>) -> @ast::expr {\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#concat_idents requires a vector argument .\") }"}, {"sha": "142bff8f7dc4c6c1b327e37fa13d987e9fadcfa0", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -11,7 +11,7 @@ import base::*;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t<str>) -> @ast::expr {\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }"}, {"sha": "33c8cebb183ed9f9aa4841f6243ae91eb0af3b92", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -16,7 +16,7 @@ import codemap::span;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n-                     body: option::t<str>) -> @ast::expr {\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }"}, {"sha": "2681228976de11ccbefec8b38528a51ac0919efb", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -4,7 +4,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t<str>) -> @ast::expr {\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }"}, {"sha": "f0834f4f079afea3308bb96339c5fb64c7a903a8", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -3,7 +3,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t<str>) -> @ast::expr {\n+                     _body: option::t<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n     std::io::stdout().write_line(print::pprust::expr_to_str(arg));"}, {"sha": "dbe3920f4e8b01d18eb19040b9483c8005fff8f5", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -159,7 +159,7 @@ type binders =\n      mutable literal_ast_matchers: [selector]};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n-fn acumm_bindings(cx: &ext_ctxt, b_dest: &bindings, b_src: &bindings) { }\n+fn acumm_bindings(_cx: &ext_ctxt, _b_dest: &bindings, _b_src: &bindings) { }\n \n /* these three functions are the big moving parts */\n \n@@ -204,7 +204,7 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n \n fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n     let idx_path: @mutable [uint] = @mutable ~[];\n-    fn new_id(old: node_id, cx: &ext_ctxt) -> node_id { ret cx.next_id(); }\n+    fn new_id(_old: node_id, cx: &ext_ctxt) -> node_id { ret cx.next_id(); }\n     fn new_span(cx: &ext_ctxt, sp: &span) -> span {\n         /* this discards information in the case of macro-defining macros */\n         ret {lo: sp.lo, hi: sp.hi, expanded_from: cx.backtrace()};\n@@ -263,7 +263,7 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n iter free_vars(b: &bindings, e: @expr) -> ident {\n     let idents: hashmap<ident, ()> = new_str_hash::<()>();\n-    fn mark_ident(i: &ident, fld: ast_fold, b: &bindings,\n+    fn mark_ident(i: &ident, _fld: ast_fold, b: &bindings,\n                   idents: &hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n         ret i;\n@@ -344,7 +344,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n // substitute, in a position that's required to be an ident\n fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                    i: &ident, fld: ast_fold) -> ident {\n+                    i: &ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, \"an identifier\") }\n@@ -354,7 +354,7 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n \n fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                   p: &path_, fld: ast_fold) -> path_ {\n+                   p: &path_, _fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n     ret alt follow_for_trans(cx, b.find(p.idents.(0)), idx_path) {\n@@ -631,7 +631,7 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n \n fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n                   b: &binders) {\n-    fn len_select(cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint)\n+    fn len_select(_cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint)\n         -> match_result {\n         ret alt m {\n               match_expr(e) {\n@@ -652,7 +652,7 @@ fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n         ~[compose_sels(s, bind len_select(cx, _, at_least, len))];\n }\n \n-fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n+fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n                          s: &selector, b: &binders) {\n     let idx: uint = 0u;\n     while idx < vec::len(elts) {\n@@ -676,7 +676,7 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n }\n \n fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                     body: option::t<str>) -> base::macro_def {\n+                     _body: option::t<str>) -> base::macro_def {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ {\n@@ -753,7 +753,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n          ext: normal(ext)};\n \n     fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                         body: option::t<str>, clauses: [@clause]) -> @expr {\n+                         _body: option::t<str>, clauses: [@clause]) -> @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) {"}, {"sha": "b81a56c576f837939db165dbff7c6768fa4a3ac8", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -76,31 +76,31 @@ type a_f =\n \n \n //fn nf_dummy<T>(&T node) -> T { fail; }\n-fn nf_crate_dummy(c: &crate) -> crate { fail; }\n-fn nf_crate_directive_dummy(c: &@crate_directive) -> @crate_directive {\n+fn nf_crate_dummy(_c: &crate) -> crate { fail; }\n+fn nf_crate_directive_dummy(_c: &@crate_directive) -> @crate_directive {\n     fail;\n }\n-fn nf_view_item_dummy(v: &@view_item) -> @view_item { fail; }\n-fn nf_native_item_dummy(n: &@native_item) -> @native_item { fail; }\n-fn nf_item_dummy(i: &@item) -> @item { fail; }\n-fn nf_item_underscore_dummy(i: &item_) -> item_ { fail; }\n-fn nf_method_dummy(m: &@method) -> @method { fail; }\n-fn nf_blk_dummy(b: &blk) -> blk { fail; }\n-fn nf_stmt_dummy(s: &@stmt) -> @stmt { fail; }\n-fn nf_arm_dummy(a: &arm) -> arm { fail; }\n-fn nf_pat_dummy(p: &@pat) -> @pat { fail; }\n-fn nf_decl_dummy(d: &@decl) -> @decl { fail; }\n-fn nf_expr_dummy(e: &@expr) -> @expr { fail; }\n-fn nf_ty_dummy(t: &@ty) -> @ty { fail; }\n-fn nf_constr_dummy(c: &@constr) -> @constr { fail; }\n-fn nf_fn_dummy(f: &_fn) -> _fn { fail; }\n-fn nf_mod_dummy(m: &_mod) -> _mod { fail; }\n-fn nf_native_mod_dummy(n: &native_mod) -> native_mod { fail; }\n-fn nf_variant_dummy(v: &variant) -> variant { fail; }\n-fn nf_ident_dummy(i: &ident) -> ident { fail; }\n-fn nf_path_dummy(p: &path) -> path { fail; }\n-fn nf_obj_field_dummy(o: &obj_field) -> obj_field { fail; }\n-fn nf_local_dummy(o: &@local) -> @local { fail; }\n+fn nf_view_item_dummy(_v: &@view_item) -> @view_item { fail; }\n+fn nf_native_item_dummy(_n: &@native_item) -> @native_item { fail; }\n+fn nf_item_dummy(_i: &@item) -> @item { fail; }\n+fn nf_item_underscore_dummy(_i: &item_) -> item_ { fail; }\n+fn nf_method_dummy(_m: &@method) -> @method { fail; }\n+fn nf_blk_dummy(_b: &blk) -> blk { fail; }\n+fn nf_stmt_dummy(_s: &@stmt) -> @stmt { fail; }\n+fn nf_arm_dummy(_a: &arm) -> arm { fail; }\n+fn nf_pat_dummy(_p: &@pat) -> @pat { fail; }\n+fn nf_decl_dummy(_d: &@decl) -> @decl { fail; }\n+fn nf_expr_dummy(_e: &@expr) -> @expr { fail; }\n+fn nf_ty_dummy(_t: &@ty) -> @ty { fail; }\n+fn nf_constr_dummy(_c: &@constr) -> @constr { fail; }\n+fn nf_fn_dummy(_f: &_fn) -> _fn { fail; }\n+fn nf_mod_dummy(_m: &_mod) -> _mod { fail; }\n+fn nf_native_mod_dummy(_n: &native_mod) -> native_mod { fail; }\n+fn nf_variant_dummy(_v: &variant) -> variant { fail; }\n+fn nf_ident_dummy(_i: &ident) -> ident { fail; }\n+fn nf_path_dummy(_p: &path) -> path { fail; }\n+fn nf_obj_field_dummy(_o: &obj_field) -> obj_field { fail; }\n+fn nf_local_dummy(_o: &@local) -> @local { fail; }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n@@ -176,7 +176,7 @@ fn noop_fold_crate_directive(cd: &crate_directive_, fld: ast_fold) ->\n         }\n }\n \n-fn noop_fold_view_item(vi: &view_item_, fld: ast_fold) -> view_item_ {\n+fn noop_fold_view_item(vi: &view_item_, _fld: ast_fold) -> view_item_ {\n     ret vi;\n }\n \n@@ -431,7 +431,7 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n         }\n }\n \n-fn noop_fold_ty(t: &ty_, fld: ast_fold) -> ty_ {\n+fn noop_fold_ty(t: &ty_, _fld: ast_fold) -> ty_ {\n     //drop in ty::fold_ty here if necessary\n     ret t;\n }\n@@ -476,7 +476,7 @@ fn noop_fold_variant(v: &variant_, fld: ast_fold) -> variant_ {\n     ret {name: v.name, args: vec::map(fold_variant_arg, v.args), id: v.id};\n }\n \n-fn noop_fold_ident(i: &ident, fld: ast_fold) -> ident { ret i; }\n+fn noop_fold_ident(i: &ident, _fld: ast_fold) -> ident { ret i; }\n \n fn noop_fold_path(p: &path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,"}, {"sha": "da033bd9f1fb043f43fa62392da68edf09b7fb30", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -282,7 +282,7 @@ fn check_bad_word(p: &parser) {\n     }\n }\n \n-fn parse_ty_fn(proto: ast::proto, p: &parser, lo: uint) -> ast::ty_ {\n+fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n     fn parse_fn_input_ty(p: &parser) -> ast::ty_arg {\n         let lo = p.get_lo_pos();\n         // Ignore arg name, if present\n@@ -338,7 +338,7 @@ fn parse_ty_obj(p: &parser, hi: &mutable uint) -> ast::ty_ {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_proto(p);\n         let ident = parse_value_ident(p);\n-        let f = parse_ty_fn(proto, p, flo);\n+        let f = parse_ty_fn(proto, p);\n         expect(p, token::SEMI);\n         alt f {\n           ast::ty_fn(proto, inputs, output, cf, constrs) {\n@@ -574,16 +574,13 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"fn\")) {\n-        let flo = p.get_last_lo_pos();\n-        t = parse_ty_fn(ast::proto_fn, p, flo);\n+        t = parse_ty_fn(ast::proto_fn, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"block\")) {\n-        let flo = p.get_last_lo_pos();\n-        t = parse_ty_fn(ast::proto_block, p, flo);\n+        t = parse_ty_fn(ast::proto_block, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"iter\")) {\n-        let flo = p.get_last_lo_pos();\n-        t = parse_ty_fn(ast::proto_iter, p, flo);\n+        t = parse_ty_fn(ast::proto_iter, p);\n         alt t { ast::ty_fn(_, _, out, _, _) { hi = out.span.hi; } }\n     } else if (eat_word(p, \"obj\")) {\n         t = parse_ty_obj(p, hi);\n@@ -2427,7 +2424,7 @@ fn parse_native_view(p: &parser) -> [@ast::view_item] {\n fn parse_crate_from_source_file(input: &str, cfg: &ast::crate_cfg,\n                                 sess: &parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, 0u, 0u, SOURCE_FILE);\n-    ret parse_crate_mod(p, cfg, sess);\n+    ret parse_crate_mod(p, cfg);\n }\n \n fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n@@ -2438,11 +2435,11 @@ fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n     let itr = @interner::mk(str::hash, str::eq);\n     let rdr = lexer::new_reader(sess.cm, source, filemap, itr);\n     let p = new_parser(sess, cfg, rdr, ftype);\n-    ret parse_crate_mod(p, cfg, sess);\n+    ret parse_crate_mod(p, cfg);\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(p: &parser, cfg: &ast::crate_cfg, sess: parse_sess) ->\n+fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) ->\n    @ast::crate {\n     let lo = p.get_lo_pos();\n     let crate_attrs = parse_inner_attrs_and_next(p);"}, {"sha": "6353751be273d68f4fea39557cab0c2ed81417eb", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -34,7 +34,7 @@ tag ann_node {\n type pp_ann = {pre: fn(&ann_node) , post: fn(&ann_node) };\n \n fn no_ann() -> pp_ann {\n-    fn ignore(node: &ann_node) { }\n+    fn ignore(_node: &ann_node) { }\n     ret {pre: ignore, post: ignore};\n }\n "}, {"sha": "ee271231d18f5b51412cbbc48bc09d944ee49a6d", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -70,12 +70,12 @@ fn visit_crate_directive<E>(cd: &@crate_directive, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_mod<E>(m: &_mod, sp: &span, e: &E, v: &vt<E>) {\n+fn visit_mod<E>(m: &_mod, _sp: &span, e: &E, v: &vt<E>) {\n     for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n     for i: @item in m.items { v.visit_item(i, e, v); }\n }\n \n-fn visit_view_item<E>(vi: &@view_item, e: &E, v: &vt<E>) { }\n+fn visit_view_item<E>(_vi: &@view_item, _e: &E, _v: &vt<E>) { }\n \n fn visit_local<E>(loc: &@local, e: &E, v: &vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n@@ -161,8 +161,8 @@ fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_constr<E>(operator: &path, sp: &span, id: node_id, e: &E,\n-                   v: &vt<E>) {\n+fn visit_constr<E>(_operator: &path, _sp: &span, _id: node_id, _e: &E,\n+                   _v: &vt<E>) {\n     // default\n }\n \n@@ -198,8 +198,8 @@ fn visit_fn_decl<E>(fd: &fn_decl, e: &E, v: &vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn<E>(f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n-               e: &E, v: &vt<E>) {\n+fn visit_fn<E>(f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n+               _id: node_id, e: &E, v: &vt<E>) {\n     visit_fn_decl(f.decl, e, v);\n     v.visit_block(f.body, e, v);\n }\n@@ -365,22 +365,22 @@ type simple_visitor =\n       visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) };\n \n fn default_simple_visitor() -> simple_visitor {\n-    ret @{visit_mod: fn (m: &_mod, sp: &span) { },\n-          visit_view_item: fn (vi: &@view_item) { },\n-          visit_native_item: fn (ni: &@native_item) { },\n-          visit_item: fn (i: &@item) { },\n-          visit_local: fn (l: &@local) { },\n-          visit_block: fn (b: &ast::blk) { },\n-          visit_stmt: fn (s: &@stmt) { },\n-          visit_arm: fn (a: &arm) { },\n-          visit_pat: fn (p: &@pat) { },\n-          visit_decl: fn (d: &@decl) { },\n-          visit_expr: fn (e: &@expr) { },\n-          visit_ty: fn (t: &@ty) { },\n-          visit_constr: fn (p: &path, sp: &span, id: node_id) { },\n+    ret @{visit_mod: fn (_m: &_mod, _sp: &span) { },\n+          visit_view_item: fn (_vi: &@view_item) { },\n+          visit_native_item: fn (_ni: &@native_item) { },\n+          visit_item: fn (_i: &@item) { },\n+          visit_local: fn (_l: &@local) { },\n+          visit_block: fn (_b: &ast::blk) { },\n+          visit_stmt: fn (_s: &@stmt) { },\n+          visit_arm: fn (_a: &arm) { },\n+          visit_pat: fn (_p: &@pat) { },\n+          visit_decl: fn (_d: &@decl) { },\n+          visit_expr: fn (_e: &@expr) { },\n+          visit_ty: fn (_t: &@ty) { },\n+          visit_constr: fn (_p: &path, _sp: &span, _id: node_id) { },\n           visit_fn:\n-              fn (f: &_fn, tps: &[ty_param], sp: &span, ident: &fn_ident,\n-                  id: node_id) {\n+              fn (_f: &_fn, _tps: &[ty_param], _sp: &span, _ident: &fn_ident,\n+                  _id: node_id) {\n               }};\n }\n "}, {"sha": "3e31dc4b34a6f7c56bc427979ca682b8913c199c", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -61,7 +61,7 @@ fn intersect(v0: &t, v1: &t) -> bool {\n     ret process(sub, v0, v1);\n }\n \n-fn right(w0: uint, w1: uint) -> uint { ret w1; }\n+fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n fn assign(v0: &t, v1: t) -> bool {\n     let sub = right;"}, {"sha": "22628f8aa6ed5e5d12525735951468643ed9b507", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -108,7 +108,7 @@ tag result { success(match); failure(fail_); }\n \n fn getopts(args: &[str], opts: &[opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n-    fn f(x: uint) -> [optval] { ret ~[]; }\n+    fn f(_x: uint) -> [optval] { ret ~[]; }\n     let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n     let free: [str] = ~[];\n     let l = vec::len::<str>(args);"}, {"sha": "10a59334f62e4731b6cc0645b29144f21c76990b", "filename": "src/lib/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -209,7 +209,7 @@ obj byte_buf_reader(bbuf: byte_buf) {\n         bbuf.pos += 1u;\n         ret b as int;\n     }\n-    fn unread_byte(byte: int) { log_err \"TODO: unread_byte\"; fail; }\n+    fn unread_byte(_byte: int) { log_err \"TODO: unread_byte\"; fail; }\n     fn eof() -> bool { ret bbuf.pos == vec::len::<u8>(bbuf.buf); }\n     fn seek(offset: int, whence: seek_style) {\n         let pos = bbuf.pos;\n@@ -278,7 +278,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n             count += nout as uint;\n         }\n     }\n-    fn seek(offset: int, whence: seek_style) {\n+    fn seek(_offset: int, _whence: seek_style) {\n         log_err \"need 64-bit native calls for seek, sorry\";\n         fail;\n     }"}, {"sha": "ee25f7cd3bbd4dcb4f8e9caadc3a821acd4f39ac", "filename": "src/lib/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -51,7 +51,7 @@ fn has<@T>(ls_: &list<T>, elt: &T) -> bool {\n }\n \n fn length<@T>(ls: &list<T>) -> uint {\n-    fn count<T>(t: &T, u: &uint) -> uint { ret u + 1u; }\n+    fn count<T>(_t: &T, u: &uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, count);\n }\n "}, {"sha": "4590fd8c63d4ba09c66f6ee5064dd3a3d29a0e1e", "filename": "src/lib/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd440d338efa935713c92a56dc8eec67a703e521/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=cd440d338efa935713c92a56dc8eec67a703e521", "patch": "@@ -43,8 +43,8 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n     // is always a power of 2), so that all buckets are probed for a\n     // fixed key.\n \n-    fn hashl(n: uint, nbkts: uint) -> uint { ret (n >>> 16u) * 2u + 1u; }\n-    fn hashr(n: uint, nbkts: uint) -> uint { ret 0x0000_ffff_u & n; }\n+    fn hashl(n: uint, _nbkts: uint) -> uint { ret (n >>> 16u) * 2u + 1u; }\n+    fn hashr(n: uint, _nbkts: uint) -> uint { ret 0x0000_ffff_u & n; }\n     fn hash(h: uint, nbkts: uint, i: uint) -> uint {\n         ret (hashl(h, nbkts) * i + hashr(h, nbkts)) % nbkts;\n     }\n@@ -98,7 +98,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         ret option::none;\n     }\n     fn rehash<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                      oldbkts: &[mutable bucket<K, V>], noldbkts: uint,\n+                      oldbkts: &[mutable bucket<K, V>], _noldbkts: uint,\n                       newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n             alt b {"}]}