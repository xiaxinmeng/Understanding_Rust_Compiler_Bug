{"sha": "07fecf80980c8df846bc63a29ca712b18fdbcfa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZmVjZjgwOTgwYzhkZjg0NmJjNjNhMjljYTcxMmIxOGZkYmNmYTc=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-12T04:49:25Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-26T18:22:41Z"}, "message": "Replace uses of `DefLike` with `Def` (only the `DlDef` variant of `DefLike` was being used)", "tree": {"sha": "01c99d08102c3e34e7c429dd44c4fa40006e7e3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01c99d08102c3e34e7c429dd44c4fa40006e7e3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07fecf80980c8df846bc63a29ca712b18fdbcfa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07fecf80980c8df846bc63a29ca712b18fdbcfa7", "html_url": "https://github.com/rust-lang/rust/commit/07fecf80980c8df846bc63a29ca712b18fdbcfa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07fecf80980c8df846bc63a29ca712b18fdbcfa7/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1744f55ad7452e72cea2b875e4f53387575ce461", "url": "https://api.github.com/repos/rust-lang/rust/commits/1744f55ad7452e72cea2b875e4f53387575ce461", "html_url": "https://github.com/rust-lang/rust/commit/1744f55ad7452e72cea2b875e4f53387575ce461"}], "stats": {"total": 50, "additions": 16, "deletions": 34}, "files": [{"sha": "df2caa0281212a244223f6387a793bbfff8fdeb9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/07fecf80980c8df846bc63a29ca712b18fdbcfa7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07fecf80980c8df846bc63a29ca712b18fdbcfa7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=07fecf80980c8df846bc63a29ca712b18fdbcfa7", "patch": "@@ -51,7 +51,7 @@ use rustc::dep_graph::DepNode;\n use rustc::front::map as hir_map;\n use rustc::session::Session;\n use rustc::lint;\n-use rustc::middle::cstore::{CrateStore, DefLike, DlDef};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::pat_util::pat_bindings;\n@@ -756,7 +756,7 @@ enum BareIdentifierPatternResolution {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: HashMap<Name, DefLike>,\n+    bindings: HashMap<Name, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -1594,7 +1594,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, name: Name) -> Option<DefLike> {\n+    fn search_label(&self, name: Name) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n@@ -1753,13 +1753,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     seen_bindings.insert(name);\n \n                     // plain insert (no renaming)\n-                    function_type_rib.bindings\n-                                     .insert(name,\n-                                             DlDef(Def::TyParam(space,\n-                                                              index as u32,\n-                                                              self.ast_map\n-                                                                  .local_def_id(type_parameter.id),\n-                                                              name)));\n+                    let def_id = self.ast_map.local_def_id(type_parameter.id);\n+                    let def = Def::TyParam(space, index as u32, def_id, name);\n+                    function_type_rib.bindings.insert(name, def);\n                 }\n                 self.type_ribs.push(function_type_rib);\n             }\n@@ -1948,7 +1944,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // plain insert (no renaming, types are not currently hygienic....)\n         let name = special_names::type_self;\n-        self_type_rib.bindings.insert(name, DlDef(self_def));\n+        self_type_rib.bindings.insert(name, self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n         if !self.resolved {\n@@ -2328,7 +2324,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             if !bindings_list.contains_key(&renamed) {\n                                 let this = &mut *self;\n                                 let last_rib = this.value_ribs.last_mut().unwrap();\n-                                last_rib.bindings.insert(renamed, DlDef(def));\n+                                last_rib.bindings.insert(renamed, def);\n                                 bindings_list.insert(renamed, pat_id);\n                             } else if mode == ArgumentIrrefutableMode &&\n                                bindings_list.contains_key(&renamed) {\n@@ -2869,25 +2865,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = match namespace { ValueNS => ident.name, TypeNS => ident.unhygienic_name };\n \n         for i in (0 .. self.get_ribs(namespace).len()).rev() {\n-            if let Some(def_like) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n-                match def_like {\n-                    DlDef(def) => {\n-                        debug!(\"(resolving path in local ribs) resolved `{}` to {:?} at {}\",\n-                               name,\n-                               def,\n-                               i);\n-                        return Some(LocalDef {\n-                            ribs: Some((namespace, i)),\n-                            def: def,\n-                        });\n-                    }\n-                    def_like => {\n-                        debug!(\"(resolving path in local ribs) resolved `{}` to pseudo-def {:?}\",\n-                               name,\n-                               def_like);\n-                        return None;\n-                    }\n-                }\n+            if let Some(def) = self.get_ribs(namespace)[i].bindings.get(&name).cloned() {\n+                return Some(LocalDef {\n+                    ribs: Some((namespace, i)),\n+                    def: def,\n+                });\n             }\n \n             if let ModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n@@ -3230,11 +3212,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n                 self.with_label_rib(|this| {\n-                    let def_like = DlDef(Def::Label(expr.id));\n+                    let def = Def::Label(expr.id);\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n-                        rib.bindings.insert(label.name, def_like);\n+                        rib.bindings.insert(label.name, def);\n                     }\n \n                     intravisit::walk_expr(this, expr);\n@@ -3249,7 +3231,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                       label.span,\n                                       ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n                     }\n-                    Some(DlDef(def @ Def::Label(_))) => {\n+                    Some(def @ Def::Label(_)) => {\n                         // Since this def is a label, it is never read.\n                         self.record_def(expr.id,\n                                         PathResolution {"}]}