{"sha": "b0aefe31f41d2a272f8f388d4be72c1754165fa7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYWVmZTMxZjQxZDJhMjcyZjhmMzg4ZDRiZTcyYzE3NTQxNjVmYTc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-05T16:44:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-05T16:44:27Z"}, "message": "Rollup merge of #40981 - Technius:master, r=steveklabnik\n\nAdd links and some examples to std::sync::mpsc docs\n\nAddresses part of #29377\nr? @steveklabnik\n\nI took a stab at adding links to the `std::sync::mpsc` docs, and I also wrote a few examples.\n\nEdit: Whoops, typed in `?r` instead of `r?`.", "tree": {"sha": "5e26fa462555d74c1e2bc40088cf51aff98fb26e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e26fa462555d74c1e2bc40088cf51aff98fb26e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0aefe31f41d2a272f8f388d4be72c1754165fa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aefe31f41d2a272f8f388d4be72c1754165fa7", "html_url": "https://github.com/rust-lang/rust/commit/b0aefe31f41d2a272f8f388d4be72c1754165fa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0aefe31f41d2a272f8f388d4be72c1754165fa7/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9f415bfbf95697ddbd4d34f60e384303c0cc16", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9f415bfbf95697ddbd4d34f60e384303c0cc16", "html_url": "https://github.com/rust-lang/rust/commit/1a9f415bfbf95697ddbd4d34f60e384303c0cc16"}, {"sha": "ab4f4428e778d45e0e8db2a254e55f5ec786410c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab4f4428e778d45e0e8db2a254e55f5ec786410c", "html_url": "https://github.com/rust-lang/rust/commit/ab4f4428e778d45e0e8db2a254e55f5ec786410c"}], "stats": {"total": 218, "additions": 172, "deletions": 46}, "files": [{"sha": "0da65a4f2e12f2c9ed8d256d583515612a888092", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 172, "deletions": 46, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/b0aefe31f41d2a272f8f388d4be72c1754165fa7/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0aefe31f41d2a272f8f388d4be72c1754165fa7/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b0aefe31f41d2a272f8f388d4be72c1754165fa7", "patch": "@@ -13,40 +13,50 @@\n //! This module provides message-based communication over channels, concretely\n //! defined among three types:\n //!\n-//! * `Sender`\n-//! * `SyncSender`\n-//! * `Receiver`\n+//! * [`Sender`]\n+//! * [`SyncSender`]\n+//! * [`Receiver`]\n //!\n-//! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n+//! A [`Sender`] or [`SyncSender`] is used to send data to a [`Receiver`]. Both\n //! senders are clone-able (multi-producer) such that many threads can send\n //! simultaneously to one receiver (single-consumer).\n //!\n //! These channels come in two flavors:\n //!\n-//! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n+//! 1. An asynchronous, infinitely buffered channel. The [`channel`] function\n //!    will return a `(Sender, Receiver)` tuple where all sends will be\n //!    **asynchronous** (they never block). The channel conceptually has an\n //!    infinite buffer.\n //!\n-//! 2. A synchronous, bounded channel. The `sync_channel()` function will return\n-//!    a `(SyncSender, Receiver)` tuple where the storage for pending messages\n-//!    is a pre-allocated buffer of a fixed size. All sends will be\n+//! 2. A synchronous, bounded channel. The [`sync_channel`] function will\n+//!    return a `(SyncSender, Receiver)` tuple where the storage for pending\n+//!    messages is a pre-allocated buffer of a fixed size. All sends will be\n //!    **synchronous** by blocking until there is buffer space available. Note\n-//!    that a bound of 0 is allowed, causing the channel to become a\n-//!    \"rendezvous\" channel where each sender atomically hands off a message to\n-//!    a receiver.\n+//!    that a bound of 0 is allowed, causing the channel to become a \"rendezvous\"\n+//!    channel where each sender atomically hands off a message to a receiver.\n+//!\n+//! [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+//! [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n+//! [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+//! [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+//! [`channel`]: ../../../std/sync/mpsc/fn.channel.html\n+//! [`sync_channel`]: ../../../std/sync/mpsc/fn.sync_channel.html\n //!\n //! ## Disconnection\n //!\n-//! The send and receive operations on channels will all return a `Result`\n+//! The send and receive operations on channels will all return a [`Result`]\n //! indicating whether the operation succeeded or not. An unsuccessful operation\n //! is normally indicative of the other half of a channel having \"hung up\" by\n //! being dropped in its corresponding thread.\n //!\n //! Once half of a channel has been deallocated, most operations can no longer\n-//! continue to make progress, so `Err` will be returned. Many applications will\n-//! continue to `unwrap()` the results returned from this module, instigating a\n-//! propagation of failure among threads if one unexpectedly dies.\n+//! continue to make progress, so [`Err`] will be returned. Many applications\n+//! will continue to [`unwrap`] the results returned from this module,\n+//! instigating a propagation of failure among threads if one unexpectedly dies.\n+//!\n+//! [`Result`]: ../../../std/result/enum.Result.html\n+//! [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+//! [`unwrap`]: ../../../std/result/enum.Result.html#method.unwrap\n //!\n //! # Examples\n //!\n@@ -288,7 +298,31 @@ mod mpsc_queue;\n mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one thread\n+/// one thread.\n+///\n+/// Messages sent to the channel can be retrieved using [`recv`].\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+/// use std::time::Duration;\n+///\n+/// let (send, recv) = channel();\n+///\n+/// thread::spawn(move || {\n+///     send.send(\"Hello world!\").unwrap();\n+///     thread::sleep(Duration::from_secs(2)); // block for two seconds\n+///     send.send(\"Delayed for 2 seconds\").unwrap();\n+/// });\n+///\n+/// println!(\"{}\", recv.recv().unwrap()); // Received immediately\n+/// println!(\"Waiting...\");\n+/// println!(\"{}\", recv.recv().unwrap()); // Received after 2 seconds\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -302,30 +336,39 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for Receiver<T> { }\n \n-/// An iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n-/// returned when the corresponding channel has hung up.\n+/// An iterator over messages on a receiver, this iterator will block whenever\n+/// [`next`] is called, waiting for a new message, and [`None`] will be returned\n+/// when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Iter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An iterator that attempts to yield all pending values for a receiver.\n-/// `None` will be returned when there are no pending values remaining or\n-/// if the corresponding channel has hung up.\n+/// [`None`] will be returned when there are no pending values remaining or if\n+/// the corresponding channel has hung up.\n ///\n /// This Iterator will never block the caller in order to wait for data to\n-/// become available. Instead, it will return `None`.\n+/// become available. Instead, it will return [`None`].\n+///\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n #[derive(Debug)]\n pub struct TryIter<'a, T: 'a> {\n     rx: &'a Receiver<T>\n }\n \n /// An owning iterator over messages on a receiver, this iterator will block\n-/// whenever `next` is called, waiting for a new message, and `None` will be\n+/// whenever [`next`] is called, waiting for a new message, and [`None`] will be\n /// returned when the corresponding channel has hung up.\n+///\n+/// [`next`]: ../../../std/iter/trait.Iterator.html#tymethod.next\n+/// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+///\n #[stable(feature = \"receiver_into_iter\", since = \"1.1.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n@@ -334,6 +377,35 @@ pub struct IntoIter<T> {\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// Messages can be sent through this channel with [`send`].\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use std::sync::mpsc::channel;\n+/// use std::thread;\n+///\n+/// let (sender, receiver) = channel();\n+/// let sender2 = sender.clone();\n+///\n+/// // First thread owns sender\n+/// thread::spawn(move || {\n+///     sender.send(1).unwrap();\n+/// });\n+///\n+/// // Second thread owns sender2\n+/// thread::spawn(move || {\n+///     sender2.send(2).unwrap();\n+/// });\n+///\n+/// let msg = receiver.recv().unwrap();\n+/// let msg2 = receiver.recv().unwrap();\n+///\n+/// assert_eq!(3, msg + msg2);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -349,6 +421,10 @@ impl<T> !Sync for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one thread, but it can be cloned to send to other threads.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n+///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<sync::Packet<T>>,\n@@ -360,25 +436,32 @@ unsafe impl<T: Send> Send for SyncSender<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for SyncSender<T> {}\n \n-/// An error returned from the `send` function on channels.\n+/// An error returned from the [`send`] function on channels.\n ///\n-/// A `send` operation can only fail if the receiving end of a channel is\n+/// A [`send`] operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n+///\n+/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n-/// An error returned from the `recv` function on a `Receiver`.\n+/// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n-/// The `recv` operation can only fail if the sending half of a channel is\n+/// The [`recv`] operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n+///\n+/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n+/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n-/// This enumeration is the list of the possible reasons that `try_recv` could\n+/// This enumeration is the list of the possible reasons that [`try_recv`] could\n /// not return data when called.\n+///\n+/// [`try_recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.try_recv\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n@@ -393,8 +476,10 @@ pub enum TryRecvError {\n     Disconnected,\n }\n \n-/// This enumeration is the list of possible errors that `recv_timeout` could\n+/// This enumeration is the list of possible errors that [`recv_timeout`] could\n /// not return data when called.\n+///\n+/// [`recv_timeout`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv_timeout\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n pub enum RecvTimeoutError {\n@@ -409,7 +494,9 @@ pub enum RecvTimeoutError {\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n-/// `SyncSender::try_send` method.\n+/// [`SyncSender::try_send`] method.\n+///\n+/// [`SyncSender::try_send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.try_send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n@@ -556,10 +643,13 @@ impl<T> Sender<T> {\n     /// A successful send occurs when it is determined that the other end of\n     /// the channel has not hung up already. An unsuccessful send would be one\n     /// where the corresponding receiver has already been deallocated. Note\n-    /// that a return value of `Err` means that the data will never be\n-    /// received, but a return value of `Ok` does *not* mean that the data\n+    /// that a return value of [`Err`] means that the data will never be\n+    /// received, but a return value of [`Ok`] does *not* mean that the data\n     /// will be received.  It is possible for the corresponding receiver to\n-    /// hang up immediately after this function returns `Ok`.\n+    /// hang up immediately after this function returns [`Ok`].\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Ok`]: ../../../std/result/enum.Result.html#variant.Ok\n     ///\n     /// This method will never block the current thread.\n     ///\n@@ -702,23 +792,29 @@ impl<T> SyncSender<T> {\n     /// time. If the buffer size is 0, however, it can be guaranteed that the\n     /// receiver has indeed received the data if this function returns success.\n     ///\n-    /// This function will never panic, but it may return `Err` if the\n-    /// `Receiver` has disconnected and is no longer able to receive\n+    /// This function will never panic, but it may return [`Err`] if the\n+    /// [`Receiver`] has disconnected and is no longer able to receive\n     /// information.\n+    ///\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    /// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n         self.inner.send(t).map_err(SendError)\n     }\n \n     /// Attempts to send a value on this channel without blocking.\n     ///\n-    /// This method differs from `send` by returning immediately if the\n+    /// This method differs from [`send`] by returning immediately if the\n     /// channel's buffer is full or no receiver is waiting to acquire some\n-    /// data. Compared with `send`, this function has two failure cases\n+    /// data. Compared with [`send`], this function has two failure cases\n     /// instead of one (one for disconnection, one for a full buffer).\n     ///\n-    /// See `SyncSender::send` for notes about guarantees of whether the\n+    /// See [`SyncSender::send`] for notes about guarantees of whether the\n     /// receiver has received the data or not if this function is successful.\n+    ///\n+    /// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+    /// [`SyncSender::send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         self.inner.try_send(t)\n@@ -819,15 +915,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -907,15 +1006,18 @@ impl<T> Receiver<T> {\n     ///\n     /// This function will always block the current thread if there is no data\n     /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding `Sender`, then this receiver will wake up and\n+    /// sent to the corresponding [`Sender`], then this receiver will wake up and\n     /// return that message.\n     ///\n-    /// If the corresponding `Sender` has disconnected, or it disconnects while\n-    /// this call is blocking, this call will wake up and return `Err` to\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n     /// indicate that no more messages can ever be received on this channel.\n     /// However, since channels are buffered, messages sent before the disconnect\n     /// will still be properly received.\n     ///\n+    /// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -993,16 +1095,40 @@ impl<T> Receiver<T> {\n     }\n \n     /// Returns an iterator that will block waiting for messages, but never\n-    /// `panic!`. It will return `None` when the channel has hung up.\n+    /// [`panic!`]. It will return [`None`] when the channel has hung up.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n+    /// [`None`]: ../../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::sync::mpsc::channel;\n+    /// use std::thread;\n+    ///\n+    /// let (send, recv) = channel();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     send.send(1u8).unwrap();\n+    ///     send.send(2u8).unwrap();\n+    ///     send.send(3u8).unwrap();\n+    /// });\n+    ///\n+    /// for x in recv.iter() {\n+    ///     println!(\"Got: {}\", x);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n         Iter { rx: self }\n     }\n \n     /// Returns an iterator that will attempt to yield all pending values.\n     /// It will return `None` if there are no more pending values or if the\n-    /// channel has hung up. The iterator will never `panic!` or block the\n+    /// channel has hung up. The iterator will never [`panic!`] or block the\n     /// user by waiting for values.\n+    ///\n+    /// [`panic!`]: ../../../std/macro.panic.html\n     #[stable(feature = \"receiver_try_iter\", since = \"1.15.0\")]\n     pub fn try_iter(&self) -> TryIter<T> {\n         TryIter { rx: self }"}]}