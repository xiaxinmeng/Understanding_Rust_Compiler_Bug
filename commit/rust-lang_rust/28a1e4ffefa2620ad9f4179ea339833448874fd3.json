{"sha": "28a1e4ffefa2620ad9f4179ea339833448874fd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YTFlNGZmZWZhMjYyMGFkOWY0MTc5ZWEzMzk4MzM0NDg4NzRmZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-24T20:48:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-24T20:48:24Z"}, "message": "Auto merge of #48510 - Manishearth:rollup, r=Manishearth\n\nRollup of 15 pull requests\n\n- Successful merges: #47987, #48056, #48061, #48084, #48143, #48185, #48206, #48208, #48232, #48246, #48258, #48317, #48353, #48356, #48402\n- Failed merges:", "tree": {"sha": "18a432b954cebc1cfdddc8f699e4be8e86bcac86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18a432b954cebc1cfdddc8f699e4be8e86bcac86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28a1e4ffefa2620ad9f4179ea339833448874fd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28a1e4ffefa2620ad9f4179ea339833448874fd3", "html_url": "https://github.com/rust-lang/rust/commit/28a1e4ffefa2620ad9f4179ea339833448874fd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28a1e4ffefa2620ad9f4179ea339833448874fd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6070d3e47e5e9f15575a3bd33583358b52bc6eda", "url": "https://api.github.com/repos/rust-lang/rust/commits/6070d3e47e5e9f15575a3bd33583358b52bc6eda", "html_url": "https://github.com/rust-lang/rust/commit/6070d3e47e5e9f15575a3bd33583358b52bc6eda"}, {"sha": "182f8820c4b53f811c140478a0105b2a7b77c5c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/182f8820c4b53f811c140478a0105b2a7b77c5c3", "html_url": "https://github.com/rust-lang/rust/commit/182f8820c4b53f811c140478a0105b2a7b77c5c3"}], "stats": {"total": 2831, "additions": 1607, "deletions": 1224}, "files": [{"sha": "aa678ba788a5bb9e8d3220d13a4f039638c99beb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -625,7 +625,7 @@ define_dep_nodes!( <'tcx>\n     [eval_always] CollectAndPartitionTranslationItems,\n     [] ExportName(DefId),\n     [] ContainsExternIndicator(DefId),\n-    [] IsTranslatedFunction(DefId),\n+    [] IsTranslatedItem(DefId),\n     [] CodegenUnit(InternedString),\n     [] CompileCodegenUnit(InternedString),\n     [input] OutputFilenames,"}, {"sha": "b77431e806a6d0ef48221b54dee73c4b00ec2397", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 104, "deletions": 44, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -74,7 +74,7 @@ struct DepGraphData {\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n     previous: PreviousDepGraph,\n \n-    colors: RefCell<FxHashMap<DepNode, DepNodeColor>>,\n+    colors: RefCell<DepNodeColorMap>,\n \n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n@@ -97,16 +97,18 @@ impl DepGraph {\n         // Pre-allocate the fingerprints array. We over-allocate a little so\n         // that we hopefully don't have to re-allocate during this compilation\n         // session.\n+        let prev_graph_node_count = prev_graph.node_count();\n+\n         let fingerprints = IndexVec::from_elem_n(Fingerprint::ZERO,\n-                                                 (prev_graph.node_count() * 115) / 100);\n+                                                 (prev_graph_node_count * 115) / 100);\n         DepGraph {\n             data: Some(Rc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n                 dep_node_debug: RefCell::new(FxHashMap()),\n                 current: RefCell::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n-                colors: RefCell::new(FxHashMap()),\n+                colors: RefCell::new(DepNodeColorMap::new(prev_graph_node_count)),\n                 loaded_from_cache: RefCell::new(FxHashMap()),\n             })),\n             fingerprints: Rc::new(RefCell::new(fingerprints)),\n@@ -213,8 +215,6 @@ impl DepGraph {\n               R: HashStable<HCX>,\n     {\n         if let Some(ref data) = self.data {\n-            debug_assert!(!data.colors.borrow().contains_key(&key));\n-\n             push(&data.current, key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n@@ -254,19 +254,21 @@ impl DepGraph {\n             }\n \n             // Determine the color of the new DepNode.\n-            {\n-                let prev_fingerprint = data.previous.fingerprint_of(&key);\n+            if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n+                let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if Some(current_fingerprint) == prev_fingerprint {\n+                let color = if current_fingerprint == prev_fingerprint {\n                     DepNodeColor::Green(dep_node_index)\n                 } else {\n                     DepNodeColor::Red\n                 };\n \n-                let old_value = data.colors.borrow_mut().insert(key, color);\n-                debug_assert!(old_value.is_none(),\n+                let mut colors = data.colors.borrow_mut();\n+                debug_assert!(colors.get(prev_index).is_none(),\n                               \"DepGraph::with_task() - Duplicate DepNodeColor \\\n                                insertion for {:?}\", key);\n+\n+                colors.insert(prev_index, color);\n             }\n \n             (result, dep_node_index)\n@@ -281,9 +283,11 @@ impl DepGraph {\n                 let mut fingerprints = self.fingerprints.borrow_mut();\n                 let dep_node_index = DepNodeIndex::new(fingerprints.len());\n                 fingerprints.push(fingerprint);\n+\n                 debug_assert!(fingerprints[dep_node_index] == fingerprint,\n                               \"DepGraph::with_task() - Assigned fingerprint to \\\n                                unexpected index for {:?}\", key);\n+\n                 (result, dep_node_index)\n             } else {\n                 (task(cx, arg), DepNodeIndex::INVALID)\n@@ -356,6 +360,15 @@ impl DepGraph {\n             .unwrap()\n     }\n \n+    #[inline]\n+    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+        if let Some(ref data) = self.data {\n+            data.current.borrow_mut().node_to_node_index.contains_key(dep_node)\n+        } else {\n+            false\n+        }\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n         match self.fingerprints.borrow().get(dep_node_index) {\n@@ -495,7 +508,17 @@ impl DepGraph {\n     }\n \n     pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n-        self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n+        if let Some(ref data) = self.data {\n+            if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n+                return data.colors.borrow().get(prev_index)\n+            } else {\n+                // This is a node that did not exist in the previous compilation\n+                // session, so we consider it to be red.\n+                return Some(DepNodeColor::Red)\n+            }\n+        }\n+\n+        None\n     }\n \n     pub fn try_mark_green<'tcx>(&self,\n@@ -505,7 +528,6 @@ impl DepGraph {\n         debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n         let data = self.data.as_ref().unwrap();\n \n-        debug_assert!(!data.colors.borrow().contains_key(dep_node));\n         debug_assert!(!data.current.borrow().node_to_node_index.contains_key(dep_node));\n \n         if dep_node.kind.is_input() {\n@@ -535,19 +557,22 @@ impl DepGraph {\n             }\n         };\n \n+        debug_assert!(data.colors.borrow().get(prev_dep_node_index).is_none());\n+\n         let mut current_deps = Vec::new();\n \n         for &dep_dep_node_index in prev_deps {\n-            let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n \n-            let dep_dep_node_color = data.colors.borrow().get(dep_dep_node).cloned();\n             match dep_dep_node_color {\n                 Some(DepNodeColor::Green(node_index)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n                     debug!(\"try_mark_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\", dep_node, dep_dep_node);\n+                            be immediately green\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n@@ -556,10 +581,14 @@ impl DepGraph {\n                     // mark the DepNode as green and also don't need to bother\n                     // with checking any of the other dependencies.\n                     debug!(\"try_mark_green({:?}) - END - dependency {:?} was \\\n-                            immediately red\", dep_node, dep_dep_node);\n+                            immediately red\",\n+                            dep_node,\n+                            data.previous.index_to_node(dep_dep_node_index));\n                     return None\n                 }\n                 None => {\n+                    let dep_dep_node = &data.previous.index_to_node(dep_dep_node_index);\n+\n                     // We don't know the state of this dependency. If it isn't\n                     // an input node, let's try to mark it green recursively.\n                     if !dep_dep_node.kind.is_input() {\n@@ -601,10 +630,8 @@ impl DepGraph {\n                     debug!(\"try_mark_green({:?}) --- trying to force \\\n                             dependency {:?}\", dep_node, dep_dep_node);\n                     if ::ty::maps::force_from_dep_node(tcx, dep_dep_node) {\n-                        let dep_dep_node_color = data.colors\n-                                                     .borrow()\n-                                                     .get(dep_dep_node)\n-                                                     .cloned();\n+                        let dep_dep_node_color = data.colors.borrow().get(dep_dep_node_index);\n+\n                         match dep_dep_node_color {\n                             Some(DepNodeColor::Green(node_index)) => {\n                                 debug!(\"try_mark_green({:?}) --- managed to \\\n@@ -681,26 +708,21 @@ impl DepGraph {\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n-        let old_color = data.colors\n-                            .borrow_mut()\n-                            .insert(*dep_node, DepNodeColor::Green(dep_node_index));\n-        debug_assert!(old_color.is_none(),\n+        let mut colors = data.colors.borrow_mut();\n+        debug_assert!(colors.get(prev_dep_node_index).is_none(),\n                       \"DepGraph::try_mark_green() - Duplicate DepNodeColor \\\n                       insertion for {:?}\", dep_node);\n \n+        colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n+\n         debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node);\n         Some(dep_node_index)\n     }\n \n-    // Used in various assertions\n-    pub fn is_green(&self, dep_node_index: DepNodeIndex) -> bool {\n-        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index];\n-        self.data.as_ref().unwrap().colors.borrow().get(&dep_node).map(|&color| {\n-            match color {\n-                DepNodeColor::Red => false,\n-                DepNodeColor::Green(_) => true,\n-            }\n-        }).unwrap_or(false)\n+    // Returns true if the given node has been marked as green during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+        self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n     // This method loads all on-disk cacheable query results into memory, so\n@@ -714,20 +736,25 @@ impl DepGraph {\n     pub fn exec_cache_promotions<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         let green_nodes: Vec<DepNode> = {\n             let data = self.data.as_ref().unwrap();\n-            data.colors.borrow().iter().filter_map(|(dep_node, color)| match color {\n-                DepNodeColor::Green(_) => {\n-                    if dep_node.cache_on_disk(tcx) {\n-                        Some(*dep_node)\n-                    } else {\n+            let colors = data.colors.borrow();\n+            colors.values.indices().filter_map(|prev_index| {\n+                match colors.get(prev_index) {\n+                    Some(DepNodeColor::Green(_)) => {\n+                        let dep_node = data.previous.index_to_node(prev_index);\n+                        if dep_node.cache_on_disk(tcx) {\n+                            Some(dep_node)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    None |\n+                    Some(DepNodeColor::Red) => {\n+                        // We can skip red nodes because a node can only be marked\n+                        // as red if the query result was recomputed and thus is\n+                        // already in memory.\n                         None\n                     }\n                 }\n-                DepNodeColor::Red => {\n-                    // We can skip red nodes because a node can only be marked\n-                    // as red if the query result was recomputed and thus is\n-                    // already in memory.\n-                    None\n-                }\n             }).collect()\n         };\n \n@@ -1052,3 +1079,36 @@ enum OpenTask {\n         node: DepNode,\n     },\n }\n+\n+// A data structure that stores Option<DepNodeColor> values as a contiguous\n+// array, using one u32 per entry.\n+struct DepNodeColorMap {\n+    values: IndexVec<SerializedDepNodeIndex, u32>,\n+}\n+\n+const COMPRESSED_NONE: u32 = 0;\n+const COMPRESSED_RED: u32 = 1;\n+const COMPRESSED_FIRST_GREEN: u32 = 2;\n+\n+impl DepNodeColorMap {\n+    fn new(size: usize) -> DepNodeColorMap {\n+        DepNodeColorMap {\n+            values: IndexVec::from_elem_n(COMPRESSED_NONE, size)\n+        }\n+    }\n+\n+    fn get(&self, index: SerializedDepNodeIndex) -> Option<DepNodeColor> {\n+        match self.values[index] {\n+            COMPRESSED_NONE => None,\n+            COMPRESSED_RED => Some(DepNodeColor::Red),\n+            value => Some(DepNodeColor::Green(DepNodeIndex(value - COMPRESSED_FIRST_GREEN)))\n+        }\n+    }\n+\n+    fn insert(&mut self, index: SerializedDepNodeIndex, color: DepNodeColor) {\n+        self.values[index] = match color {\n+            DepNodeColor::Red => COMPRESSED_RED,\n+            DepNodeColor::Green(index) => index.0 + COMPRESSED_FIRST_GREEN,\n+        }\n+    }\n+}"}, {"sha": "504b60e763e23543fc9e5663acbe5bbf6a842429", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -49,6 +49,11 @@ impl PreviousDepGraph {\n         self.index[dep_node]\n     }\n \n+    #[inline]\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+        self.index.get(dep_node).cloned()\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index"}, {"sha": "3799bdada888e84821e8c4a9a8a163cb8cf4a9a1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -22,6 +22,7 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n+use syntax::ext::base::MacroKind;\n use syntax_pos::Span;\n \n use hir::*;\n@@ -32,13 +33,15 @@ use util::nodemap::{DefIdMap, FxHashMap};\n use arena::TypedArena;\n use std::cell::RefCell;\n use std::io;\n+use ty::TyCtxt;\n \n pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n+\n pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n@@ -373,6 +376,92 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n     }\n \n+    pub fn describe_def(&self, node_id: NodeId) -> Option<Def> {\n+        let node = if let Some(node) = self.find(node_id) {\n+            node\n+        } else {\n+            return None\n+        };\n+\n+        match node {\n+            NodeItem(item) => {\n+                let def_id = || {\n+                    self.local_def_id(item.id)\n+                };\n+\n+                match item.node {\n+                    ItemStatic(_, m, _) => Some(Def::Static(def_id(),\n+                                                            m == MutMutable)),\n+                    ItemConst(..) => Some(Def::Const(def_id())),\n+                    ItemFn(..) => Some(Def::Fn(def_id())),\n+                    ItemMod(..) => Some(Def::Mod(def_id())),\n+                    ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemTy(..) => Some(Def::TyAlias(def_id())),\n+                    ItemEnum(..) => Some(Def::Enum(def_id())),\n+                    ItemStruct(..) => Some(Def::Struct(def_id())),\n+                    ItemUnion(..) => Some(Def::Union(def_id())),\n+                    ItemTrait(..) => Some(Def::Trait(def_id())),\n+                    ItemTraitAlias(..) => {\n+                        bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n+                    },\n+                    ItemExternCrate(_) |\n+                    ItemUse(..) |\n+                    ItemForeignMod(..) |\n+                    ItemImpl(..) => None,\n+                }\n+            }\n+            NodeForeignItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ForeignItemFn(..) => Some(Def::Fn(def_id)),\n+                    ForeignItemStatic(_, m) => Some(Def::Static(def_id, m)),\n+                    ForeignItemType => Some(Def::TyForeign(def_id)),\n+                }\n+            }\n+            NodeTraitItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeImplItem(item) => {\n+                let def_id = self.local_def_id(item.id);\n+                match item.node {\n+                    ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n+                    ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n+                    ImplItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                }\n+            }\n+            NodeVariant(variant) => {\n+                let def_id = self.local_def_id(variant.node.data.id());\n+                Some(Def::Variant(def_id))\n+            }\n+            NodeField(_) |\n+            NodeExpr(_) |\n+            NodeStmt(_) |\n+            NodeTy(_) |\n+            NodeTraitRef(_) |\n+            NodePat(_) |\n+            NodeBinding(_) |\n+            NodeStructCtor(_) |\n+            NodeLifetime(_) |\n+            NodeVisibility(_) |\n+            NodeBlock(_) => None,\n+            NodeLocal(local) => {\n+                Some(Def::Local(local.id))\n+            }\n+            NodeMacroDef(macro_def) => {\n+                Some(Def::Macro(self.local_def_id(macro_def.id),\n+                                MacroKind::Bang))\n+            }\n+            NodeTyParam(param) => {\n+                Some(Def::TyParam(self.local_def_id(param.id)))\n+            }\n+        }\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }\n@@ -1275,3 +1364,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n     }\n }\n+\n+pub fn describe_def(tcx: TyCtxt, def_id: DefId) -> Option<Def> {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n+        tcx.hir.describe_def(node_id)\n+    } else {\n+        bug!(\"Calling local describe_def query provider for upstream DefId: {:?}\",\n+             def_id)\n+    }\n+}"}, {"sha": "0fa1b95d8e7776955bd1923738ac8a2edf2b1b86", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -43,6 +43,7 @@ use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n use syntax::util::parser::ExprPrecedence;\n use ty::AdtKind;\n+use ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec;\n \n@@ -2204,3 +2205,8 @@ pub type TraitMap = NodeMap<Vec<TraitCandidate>>;\n // Map from the NodeId of a glob import to a list of items which are actually\n // imported.\n pub type GlobMap = NodeMap<FxHashSet<Name>>;\n+\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.describe_def = map::describe_def;\n+}"}, {"sha": "7f8f2e9b90603f4a339b91cc96bf74a2bedaed89", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use hir::def_id::DefId;\n use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n use ty::{Instance, TyCtxt};\n@@ -21,7 +22,7 @@ use std::hash::Hash;\n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum MonoItem<'tcx> {\n     Fn(Instance<'tcx>),\n-    Static(NodeId),\n+    Static(DefId),\n     GlobalAsm(NodeId),\n }\n \n@@ -50,7 +51,9 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n             MonoItem::Fn(ref instance) => {\n                 instance.hash_stable(hcx, hasher);\n             }\n-            MonoItem::Static(node_id)    |\n+            MonoItem::Static(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n             MonoItem::GlobalAsm(node_id) => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     node_id.hash_stable(hcx, hasher);"}, {"sha": "118d4ddd4457b0daf706ea32362bf589ce022804", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -756,7 +756,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }).collect(),\n                     ref sty => vec![ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", sty))],\n                 };\n-                if found.len()== expected.len() {\n+                if found.len() == expected.len() {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n                                                      found_trait_ref,\n@@ -874,6 +874,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n                 }).collect::<Vec<ArgKind>>())\n             }\n+            hir::map::NodeVariant(&hir::Variant {\n+                span,\n+                node: hir::Variant_ {\n+                    data: hir::VariantData::Tuple(ref fields, _),\n+                    ..\n+                },\n+                ..\n+            }) => {\n+                (self.tcx.sess.codemap().def_span(span),\n+                 fields.iter().map(|field| {\n+                     ArgKind::Arg(format!(\"{}\", field.name), \"_\".to_string())\n+                 }).collect::<Vec<_>>())\n+            }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n     }"}, {"sha": "be1d255afa1913eb87513881e19a03422671b5f5", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -349,7 +349,7 @@ define_maps! { <'tcx>\n     [] fn export_name: ExportName(DefId) -> Option<Symbol>,\n     [] fn contains_extern_indicator: ContainsExternIndicator(DefId) -> bool,\n     [] fn symbol_export_level: GetSymbolExportLevel(DefId) -> SymbolExportLevel,\n-    [] fn is_translated_function: IsTranslatedFunction(DefId) -> bool,\n+    [] fn is_translated_item: IsTranslatedItem(DefId) -> bool,\n     [] fn codegen_unit: CodegenUnit(InternedString) -> Arc<CodegenUnit<'tcx>>,\n     [] fn compile_codegen_unit: CompileCodegenUnit(InternedString) -> Stats,\n     [] fn output_filenames: output_filenames_node(CrateNum)"}, {"sha": "17b44f6959f2f88f97dcf278ba139fa1d7e8e881", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -347,22 +347,21 @@ impl<'sess> OnDiskCache<'sess> {\n             return None\n         };\n \n-        let mut cnum_map = self.cnum_map.borrow_mut();\n-        if cnum_map.is_none() {\n+        // Initialize the cnum_map if it is not initialized yet.\n+        if self.cnum_map.borrow().is_none() {\n+            let mut cnum_map = self.cnum_map.borrow_mut();\n             *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n         }\n-\n-        let mut synthetic_expansion_infos = self.synthetic_expansion_infos.borrow_mut();\n-        let mut file_index_to_file = self.file_index_to_file.borrow_mut();\n+        let cnum_map = self.cnum_map.borrow();\n \n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             codemap: self.codemap,\n             cnum_map: cnum_map.as_ref().unwrap(),\n-            file_index_to_file: &mut file_index_to_file,\n+            file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &mut synthetic_expansion_infos,\n+            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n@@ -421,21 +420,21 @@ struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n     opaque: opaque::Decoder<'x>,\n     codemap: &'x CodeMap,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'x mut FxHashMap<AbsoluteBytePos, SyntaxContext>,\n-    file_index_to_file: &'x mut FxHashMap<FileMapIndex, Rc<FileMap>>,\n+    synthetic_expansion_infos: &'x RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    file_index_to_file: &'x RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n     file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn file_index_to_file(&mut self, index: FileMapIndex) -> Rc<FileMap> {\n+    fn file_index_to_file(&self, index: FileMapIndex) -> Rc<FileMap> {\n         let CacheDecoder {\n-            ref mut file_index_to_file,\n+            ref file_index_to_file,\n             ref file_index_to_stable_id,\n             ref codemap,\n             ..\n         } = *self;\n \n-        file_index_to_file.entry(index).or_insert_with(|| {\n+        file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             codemap.filemap_by_stable_id(stable_id)\n                    .expect(\"Failed to lookup FileMap in new context.\")\n@@ -572,19 +571,24 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n                 let pos = AbsoluteBytePos::new(self.opaque.position());\n                 let expn_info: ExpnInfo = Decodable::decode(self)?;\n                 let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                self.synthetic_expansion_infos.insert(pos, ctxt);\n+                self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n                 ctxt\n             }\n             TAG_EXPANSION_INFO_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n+                let cached_ctxt = self.synthetic_expansion_infos\n+                                      .borrow()\n+                                      .get(&pos)\n+                                      .cloned();\n+\n+                if let Some(ctxt) = cached_ctxt {\n                     ctxt\n                 } else {\n                     let expn_info = self.with_position(pos.to_usize(), |this| {\n                          ExpnInfo::decode(this)\n                     })?;\n                     let ctxt = SyntaxContext::allocate_directly(expn_info);\n-                    self.synthetic_expansion_infos.insert(pos, ctxt);\n+                    self.synthetic_expansion_infos.borrow_mut().insert(pos, ctxt);\n                     ctxt\n                 }\n             }"}, {"sha": "b654b6bc42a122896c018319b39efcaf5c0e07da", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let span = self.sess.codemap().def_span(span);\n             let mut err =\n                 struct_span_err!(self.sess, span, E0391,\n-                                 \"unsupported cyclic reference between types/traits detected\");\n+                                 \"cyclic dependency detected\");\n             err.span_label(span, \"cyclic reference\");\n \n             err.span_note(self.sess.codemap().def_span(stack[0].0),\n@@ -147,7 +147,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 match self.dep_graph.try_mark_green(self.global_tcx(), &dep_node) {\n                     Some(dep_node_index) => {\n-                        debug_assert!(self.dep_graph.is_green(dep_node_index));\n+                        debug_assert!(self.dep_graph.is_green(&dep_node));\n                         self.dep_graph.read_index(dep_node_index);\n                         Some(dep_node_index)\n                     }\n@@ -403,7 +403,7 @@ macro_rules! define_maps {\n                                                   dep_node: &DepNode)\n                                                   -> Result<$V, CycleError<'a, $tcx>>\n             {\n-                debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n+                debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                 // First we try to load the result from the on-disk cache\n                 let result = if Self::cache_on_disk(key) &&\n@@ -491,7 +491,7 @@ macro_rules! define_maps {\n                      span: Span,\n                      dep_node: DepNode)\n                      -> Result<($V, DepNodeIndex), CycleError<'a, $tcx>> {\n-                debug_assert!(tcx.dep_graph.node_color(&dep_node).is_none());\n+                debug_assert!(!tcx.dep_graph.dep_node_exists(&dep_node));\n \n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n                 let res = tcx.cycle_check(span, Query::$name(key), || {\n@@ -929,7 +929,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ContainsExternIndicator => {\n             force!(contains_extern_indicator, def_id!());\n         }\n-        DepKind::IsTranslatedFunction => { force!(is_translated_function, def_id!()); }\n+        DepKind::IsTranslatedItem => { force!(is_translated_item, def_id!()); }\n         DepKind::OutputFilenames => { force!(output_filenames, LOCAL_CRATE); }\n \n         DepKind::TargetFeaturesWhitelist => { force!(target_features_whitelist, LOCAL_CRATE); }"}, {"sha": "2678861be0634e3588510406bc2f403ac40a5c6e", "filename": "src/librustc_data_structures/bitslice.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -24,6 +24,7 @@ pub trait BitSlice {\n \n impl BitSlice for [Word] {\n     /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n+    #[inline]\n     fn clear_bit(&mut self, idx: usize) -> bool {\n         let words = self;\n         debug!(\"clear_bit: words={} idx={}\",\n@@ -37,6 +38,7 @@ impl BitSlice for [Word] {\n     }\n \n     /// Sets bit at `idx` to 1; returns true iff this changed `self.`\n+    #[inline]\n     fn set_bit(&mut self, idx: usize) -> bool {\n         let words = self;\n         debug!(\"set_bit: words={} idx={}\",\n@@ -50,6 +52,7 @@ impl BitSlice for [Word] {\n     }\n \n     /// Extracts value of bit at `idx` in `self`.\n+    #[inline]\n     fn get_bit(&self, idx: usize) -> bool {\n         let words = self;\n         let BitLookup { word, bit_mask, .. } = bit_lookup(idx);"}, {"sha": "11c2bd7368760b90f99fa8d98a1ebcf945376735", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -29,12 +29,16 @@ pub trait Idx: Copy + 'static + Eq + Debug {\n }\n \n impl Idx for usize {\n+    #[inline]\n     fn new(idx: usize) -> Self { idx }\n+    #[inline]\n     fn index(self) -> usize { self }\n }\n \n impl Idx for u32 {\n+    #[inline]\n     fn new(idx: usize) -> Self { assert!(idx <= u32::MAX as usize); idx as u32 }\n+    #[inline]\n     fn index(self) -> usize { self as usize }\n }\n \n@@ -73,11 +77,13 @@ macro_rules! newtype_index {\n         pub struct $type($($pub)* u32);\n \n         impl Idx for $type {\n+            #[inline]\n             fn new(value: usize) -> Self {\n                 assert!(value < ($max) as usize);\n                 $type(value as u32)\n             }\n \n+            #[inline]\n             fn index(self) -> usize {\n                 self.0 as usize\n             }"}, {"sha": "b03108ed807da0060ecf67e8c37db32cf901ef0f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -36,7 +36,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{self, ast_validation, loops, consts, static_recursion, hir_stats};\n+use rustc_passes::{self, ast_validation, loops, consts, hir_stats};\n use rustc_const_eval::{self, check_match};\n use super::Compilation;\n \n@@ -818,7 +818,8 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n                                          &mut resolver,\n                                          sess.opts.test,\n                                          krate,\n-                                         sess.diagnostic())\n+                                         sess.diagnostic(),\n+                                         &sess.features.borrow())\n     });\n \n     // If we're actually rustdoc then there's no need to actually compile\n@@ -931,6 +932,7 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n }\n \n pub fn default_provide(providers: &mut ty::maps::Providers) {\n+    hir::provide(providers);\n     borrowck::provide(providers);\n     mir::provide(providers);\n     reachable::provide(providers);\n@@ -990,10 +992,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n          \"loop checking\",\n          || loops::check_crate(sess, &hir_map));\n \n-    time(time_passes,\n-              \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &hir_map))?;\n-\n     let mut local_providers = ty::maps::Providers::default();\n     default_provide(&mut local_providers);\n     trans.provide(&mut local_providers);"}, {"sha": "d57b8e78f18a9b1ebbfd090ecfd1798096514a74", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1585,6 +1585,12 @@ impl MirPass for TypeckMir {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         debug!(\"run_pass: {:?}\", def_id);\n \n+        // When NLL is enabled, the borrow checker runs the typeck\n+        // itself, so we don't need this MIR pass anymore.\n+        if tcx.sess.nll() {\n+            return;\n+        }\n+\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors."}, {"sha": "d6f419f6cfb41d5eb68ac5428fbd62aaf95d9263", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -353,9 +353,12 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 self.gather_move(&Place::Local(RETURN_PLACE));\n             }\n \n-            TerminatorKind::Assert { .. } |\n-            TerminatorKind::SwitchInt { .. } => {\n-                // branching terminators - these don't move anything\n+            TerminatorKind::Assert { ref cond, .. } => {\n+                self.gather_operand(cond);\n+            }\n+\n+            TerminatorKind::SwitchInt { ref discr, .. } => {\n+                self.gather_operand(discr);\n             }\n \n             TerminatorKind::Yield { ref value, .. } => {"}, {"sha": "eb4ba21489c3dc310d66eeae8b7c00bfbaf0190d", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -368,8 +368,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let recursion_depth_reset;\n \n     match starting_point {\n-        MonoItem::Static(node_id) => {\n-            let def_id = tcx.hir.local_def_id(node_id);\n+        MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n \n             // Sanity check whether this ended up being collected accidentally\n@@ -652,8 +651,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let tcx = self.tcx;\n         let instance = Instance::mono(tcx, static_.def_id);\n         if should_monomorphize_locally(tcx, &instance) {\n-            let node_id = tcx.hir.as_local_node_id(static_.def_id).unwrap();\n-            self.output.push(MonoItem::Static(node_id));\n+            self.output.push(MonoItem::Static(static_.def_id));\n         }\n \n         self.super_static(static_, context, location);\n@@ -946,10 +944,10 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n             hir::ItemStatic(..) => {\n+                let def_id = self.tcx.hir.local_def_id(item.id);\n                 debug!(\"RootCollector: ItemStatic({})\",\n-                       def_id_to_string(self.tcx,\n-                                        self.tcx.hir.local_def_id(item.id)));\n-                self.output.push(MonoItem::Static(item.id));\n+                       def_id_to_string(self.tcx, def_id));\n+                self.output.push(MonoItem::Static(def_id));\n             }\n             hir::ItemConst(..) => {\n                 // const items only generate mono items if they are"}, {"sha": "549919a2c891925d620aae621f8a85ae2ed80a56", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -97,8 +97,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::SymbolName {\n         match *self.as_mono_item() {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n-            MonoItem::Static(node_id) => {\n-                let def_id = tcx.hir.local_def_id(node_id);\n+            MonoItem::Static(def_id) => {\n                 tcx.symbol_name(Instance::mono(tcx, def_id))\n             }\n             MonoItem::GlobalAsm(node_id) => {\n@@ -159,7 +158,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Linkage> {\n         let def_id = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => instance.def_id(),\n-            MonoItem::Static(node_id) => tcx.hir.local_def_id(node_id),\n+            MonoItem::Static(def_id) => def_id,\n             MonoItem::GlobalAsm(..) => return None,\n         };\n \n@@ -209,7 +208,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n         debug!(\"is_instantiable({:?})\", self);\n         let (def_id, substs) = match *self.as_mono_item() {\n             MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            MonoItem::Static(node_id) => (tcx.hir.local_def_id(node_id), Substs::empty()),\n+            MonoItem::Static(def_id) => (def_id, Substs::empty()),\n             // global asm never has predicates\n             MonoItem::GlobalAsm(..) => return true\n         };\n@@ -218,14 +217,11 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n     }\n \n     fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.hir;\n-\n         return match *self.as_mono_item() {\n             MonoItem::Fn(instance) => {\n                 to_string_internal(tcx, \"fn \", instance)\n             },\n-            MonoItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n+            MonoItem::Static(def_id) => {\n                 let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n                 to_string_internal(tcx, \"static \", instance)\n             },\n@@ -251,7 +247,9 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug {\n             MonoItem::Fn(Instance { def, .. }) => {\n                 tcx.hir.as_local_node_id(def.def_id())\n             }\n-            MonoItem::Static(node_id) |\n+            MonoItem::Static(def_id) => {\n+                tcx.hir.as_local_node_id(def_id)\n+            }\n             MonoItem::GlobalAsm(node_id) => {\n                 Some(node_id)\n             }"}, {"sha": "2b558e71483c67e893317c7130ab220066ff0f62", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -180,7 +180,9 @@ pub trait CodegenUnitExt<'tcx> {\n                         }\n                     }\n                 }\n-                MonoItem::Static(node_id) |\n+                MonoItem::Static(def_id) => {\n+                    tcx.hir.as_local_node_id(def_id)\n+                }\n                 MonoItem::GlobalAsm(node_id) => {\n                     Some(node_id)\n                 }\n@@ -382,7 +384,15 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         };\n                         (Linkage::External, visibility)\n                     }\n-                    MonoItem::Static(node_id) |\n+                    MonoItem::Static(def_id) => {\n+                        let visibility = if tcx.is_exported_symbol(def_id) {\n+                            can_be_internalized = false;\n+                            default_visibility(def_id)\n+                        } else {\n+                            Visibility::Hidden\n+                        };\n+                        (Linkage::External, visibility)\n+                    }\n                     MonoItem::GlobalAsm(node_id) => {\n                         let def_id = tcx.hir.local_def_id(node_id);\n                         let visibility = if tcx.is_exported_symbol(def_id) {\n@@ -643,7 +653,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             Some(def_id)\n         }\n-        MonoItem::Static(node_id) |\n+        MonoItem::Static(def_id) => Some(def_id),\n         MonoItem::GlobalAsm(node_id) => Some(tcx.hir.local_def_id(node_id)),\n     }\n }"}, {"sha": "3524255e03772328311120212f8c7fee12933e11", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -386,10 +386,13 @@ fn is_enclosed(tcx: TyCtxt,\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(hir::map::NodeItem(&hir::Item {\n-            node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n+            node: hir::ItemFn(_, fn_unsafety, _, _, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {\n-            Some((\"fn\".to_string(), parent_id))\n+            match fn_unsafety {\n+                hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n+                hir::Unsafety::Normal => None,\n+            }\n         } else {\n             is_enclosed(tcx, used_unsafe, parent_id)\n         }"}, {"sha": "a5dd8f1558e4392b8e59c5d9a045bbc44803fe79", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -419,6 +419,141 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n+// Bans nested `impl Trait`, e.g. `impl Into<impl Debug>`.\n+// Nested `impl Trait` _is_ allowed in associated type position,\n+// e.g `impl Iterator<Item=impl Debug>`\n+struct NestedImplTraitVisitor<'a> {\n+    session: &'a Session,\n+    outer_impl_trait: Option<Span>,\n+}\n+\n+impl<'a> NestedImplTraitVisitor<'a> {\n+    fn with_impl_trait<F>(&mut self, outer_impl_trait: Option<Span>, f: F)\n+        where F: FnOnce(&mut NestedImplTraitVisitor<'a>)\n+    {\n+        let old_outer_impl_trait = self.outer_impl_trait;\n+        self.outer_impl_trait = outer_impl_trait;\n+        f(self);\n+        self.outer_impl_trait = old_outer_impl_trait;\n+    }\n+}\n+\n+\n+impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n+    fn visit_ty(&mut self, t: &'a Ty) {\n+        if let TyKind::ImplTrait(_) = t.node {\n+            if let Some(outer_impl_trait) = self.outer_impl_trait {\n+                struct_span_err!(self.session, t.span, E0666,\n+                                 \"nested `impl Trait` is not allowed\")\n+                    .span_label(outer_impl_trait, \"outer `impl Trait`\")\n+                    .span_label(t.span, \"nested `impl Trait` here\")\n+                    .emit();\n+\n+            }\n+            self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t));\n+        } else {\n+            visit::walk_ty(self, t);\n+        }\n+    }\n+    fn visit_path_parameters(&mut self, _: Span, path_parameters: &'a PathParameters) {\n+        match *path_parameters {\n+            PathParameters::AngleBracketed(ref params) => {\n+                for type_ in &params.types {\n+                    self.visit_ty(type_);\n+                }\n+                for type_binding in &params.bindings {\n+                    // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n+                    // are allowed to contain nested `impl Trait`.\n+                    self.with_impl_trait(None, |this| visit::walk_ty(this, &type_binding.ty));\n+                }\n+            }\n+            PathParameters::Parenthesized(ref params) => {\n+                for type_ in &params.inputs {\n+                    self.visit_ty(type_);\n+                }\n+                if let Some(ref type_) = params.output {\n+                    // `-> Foo` syntax is essentially an associated type binding,\n+                    // so it is also allowed to contain nested `impl Trait`.\n+                    self.with_impl_trait(None, |this| visit::walk_ty(this, type_));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Bans `impl Trait` in path projections like `<impl Iterator>::Item` or `Foo::Bar<impl Trait>`.\n+struct ImplTraitProjectionVisitor<'a> {\n+    session: &'a Session,\n+    is_banned: bool,\n+}\n+\n+impl<'a> ImplTraitProjectionVisitor<'a> {\n+    fn with_ban<F>(&mut self, f: F)\n+        where F: FnOnce(&mut ImplTraitProjectionVisitor<'a>)\n+    {\n+        let old_is_banned = self.is_banned;\n+        self.is_banned = true;\n+        f(self);\n+        self.is_banned = old_is_banned;\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n+    fn visit_ty(&mut self, t: &'a Ty) {\n+        match t.node {\n+            TyKind::ImplTrait(_) => {\n+                if self.is_banned {\n+                    struct_span_err!(self.session, t.span, E0667,\n+                                 \"`impl Trait` is not allowed in path parameters\")\n+                        .emit();\n+                }\n+            }\n+            TyKind::Path(ref qself, ref path) => {\n+                // We allow these:\n+                //  - `Option<impl Trait>`\n+                //  - `option::Option<impl Trait>`\n+                //  - `option::Option<T>::Foo<impl Trait>\n+                //\n+                // But not these:\n+                //  - `<impl Trait>::Foo`\n+                //  - `option::Option<impl Trait>::Foo`.\n+                //\n+                // To implement this, we disallow `impl Trait` from `qself`\n+                // (for cases like `<impl Trait>::Foo>`)\n+                // but we allow `impl Trait` in `PathParameters`\n+                // iff there are no more PathSegments.\n+                if let Some(ref qself) = *qself {\n+                    // `impl Trait` in `qself` is always illegal\n+                    self.with_ban(|this| this.visit_ty(&qself.ty));\n+                }\n+\n+                for (i, segment) in path.segments.iter().enumerate() {\n+                    // Allow `impl Trait` iff we're on the final path segment\n+                    if i == (path.segments.len() - 1) {\n+                        visit::walk_path_segment(self, path.span, segment);\n+                    } else {\n+                        self.with_ban(|this|\n+                            visit::walk_path_segment(this, path.span, segment));\n+                    }\n+                }\n+            }\n+            _ => visit::walk_ty(self, t),\n+        }\n+    }\n+}\n+\n pub fn check_crate(session: &Session, krate: &Crate) {\n+    visit::walk_crate(\n+        &mut NestedImplTraitVisitor {\n+            session,\n+            outer_impl_trait: None,\n+        }, krate);\n+\n+    visit::walk_crate(\n+        &mut ImplTraitProjectionVisitor {\n+            session,\n+            is_banned: false,\n+        }, krate);\n+\n     visit::walk_crate(&mut AstValidator { session: session }, krate)\n }"}, {"sha": "184fab778c60191d13dea1b8c3ba404188cde694", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -128,22 +128,6 @@ impl !Enterprise for Foo { }\n Please note that negative impls are only allowed for auto traits.\n \"##,\n \n-E0265: r##\"\n-This error indicates that a static or constant references itself.\n-All statics and constants need to resolve to a value in an acyclic manner.\n-\n-For example, neither of the following can be sensibly compiled:\n-\n-```compile_fail,E0265\n-const X: u32 = X;\n-```\n-\n-```compile_fail,E0265\n-const X: u32 = Y;\n-const Y: u32 = X;\n-```\n-\"##,\n-\n E0267: r##\"\n This error indicates the use of a loop keyword (`break` or `continue`) inside a\n closure but outside of any loop. Erroneous code example:\n@@ -320,4 +304,6 @@ register_diagnostics! {\n     E0567, // auto traits can not have generic parameters\n     E0568, // auto traits can not have super traits\n     E0642, // patterns aren't allowed in methods without bodies\n+    E0666, // nested `impl Trait` is illegal\n+    E0667, // `impl Trait` in projections\n }"}, {"sha": "6b9f407cbdb4da742317383d34db0adff6c30d57", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -42,7 +42,6 @@ pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n mod mir_stats;\n-pub mod static_recursion;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }\n "}, {"sha": "987243b523473054a966f0efca0d3724389e56c5", "filename": "src/librustc_passes/static_recursion.rs", "status": "removed", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1,280 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This compiler pass detects constants that refer to themselves\n-// recursively.\n-\n-use rustc::hir::map as hir_map;\n-use rustc::session::Session;\n-use rustc::hir::def::{Def, CtorKind};\n-use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::{NodeMap, NodeSet};\n-\n-use syntax::ast;\n-use syntax_pos::Span;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir;\n-\n-struct CheckCrateVisitor<'a, 'hir: 'a> {\n-    sess: &'a Session,\n-    hir_map: &'a hir_map::Map<'hir>,\n-    // `discriminant_map` is a cache that associates the `NodeId`s of local\n-    // variant definitions with the discriminant expression that applies to\n-    // each one. If the variant uses the default values (starting from `0`),\n-    // then `None` is stored.\n-    discriminant_map: NodeMap<Option<hir::BodyId>>,\n-    detected_recursive_ids: NodeSet,\n-}\n-\n-impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_item(&mut self, it: &'hir hir::Item) {\n-        match it.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                recursion_visitor.visit_item(it);\n-            }\n-            hir::ItemEnum(ref enum_def, ref generics) => {\n-                // We could process the whole enum, but handling the variants\n-                // with discriminant expressions one by one gives more specific,\n-                // less redundant output.\n-                for variant in &enum_def.variants {\n-                    if let Some(_) = variant.node.disr_expr {\n-                        let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                        recursion_visitor.populate_enum_discriminants(enum_def);\n-                        recursion_visitor.visit_variant(variant, generics, it.id);\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, it)\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        match ti.node {\n-            hir::TraitItemKind::Const(_, ref default) => {\n-                if let Some(_) = *default {\n-                    let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                    recursion_visitor.visit_trait_item(ti);\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_trait_item(self, ti)\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        match ii.node {\n-            hir::ImplItemKind::Const(..) => {\n-                let mut recursion_visitor = CheckItemRecursionVisitor::new(self);\n-                recursion_visitor.visit_impl_item(ii);\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_impl_item(self, ii)\n-    }\n-}\n-\n-pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>)\n-                         -> Result<(), ErrorReported>\n-{\n-    let mut visitor = CheckCrateVisitor {\n-        sess,\n-        hir_map,\n-        discriminant_map: NodeMap(),\n-        detected_recursive_ids: NodeSet(),\n-    };\n-    sess.track_errors(|| {\n-        // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n-        hir_map.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-    })\n-}\n-\n-struct CheckItemRecursionVisitor<'a, 'b: 'a, 'hir: 'b> {\n-    sess: &'b Session,\n-    hir_map: &'b hir_map::Map<'hir>,\n-    discriminant_map: &'a mut NodeMap<Option<hir::BodyId>>,\n-    idstack: Vec<ast::NodeId>,\n-    detected_recursive_ids: &'a mut NodeSet,\n-}\n-\n-impl<'a, 'b: 'a, 'hir: 'b> CheckItemRecursionVisitor<'a, 'b, 'hir> {\n-    fn new(v: &'a mut CheckCrateVisitor<'b, 'hir>) -> Self {\n-        CheckItemRecursionVisitor {\n-            sess: v.sess,\n-            hir_map: v.hir_map,\n-            discriminant_map: &mut v.discriminant_map,\n-            idstack: Vec::new(),\n-            detected_recursive_ids: &mut v.detected_recursive_ids,\n-        }\n-    }\n-    fn with_item_id_pushed<F>(&mut self, id: ast::NodeId, f: F, span: Span)\n-        where F: Fn(&mut Self)\n-    {\n-        if self.idstack.iter().any(|&x| x == id) {\n-            if self.detected_recursive_ids.contains(&id) {\n-                return;\n-            }\n-            self.detected_recursive_ids.insert(id);\n-            let any_static = self.idstack.iter().any(|&x| {\n-                if let hir_map::NodeItem(item) = self.hir_map.get(x) {\n-                    if let hir::ItemStatic(..) = item.node {\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                } else {\n-                    false\n-                }\n-            });\n-            if !any_static {\n-                struct_span_err!(self.sess, span, E0265, \"recursive constant\")\n-                    .span_label(span, \"recursion not allowed in constant\")\n-                    .emit();\n-            }\n-            return;\n-        }\n-        self.idstack.push(id);\n-        f(self);\n-        self.idstack.pop();\n-    }\n-    // If a variant has an expression specifying its discriminant, then it needs\n-    // to be checked just like a static or constant. However, if there are more\n-    // variants with no explicitly specified discriminant, those variants will\n-    // increment the same expression to get their values.\n-    //\n-    // So for every variant, we need to track whether there is an expression\n-    // somewhere in the enum definition that controls its discriminant. We do\n-    // this by starting from the end and searching backward.\n-    fn populate_enum_discriminants(&mut self, enum_definition: &'hir hir::EnumDef) {\n-        // Get the map, and return if we already processed this enum or if it\n-        // has no variants.\n-        match enum_definition.variants.first() {\n-            None => {\n-                return;\n-            }\n-            Some(variant) if self.discriminant_map.contains_key(&variant.node.data.id()) => {\n-                return;\n-            }\n-            _ => {}\n-        }\n-\n-        // Go through all the variants.\n-        let mut variant_stack: Vec<ast::NodeId> = Vec::new();\n-        for variant in enum_definition.variants.iter().rev() {\n-            variant_stack.push(variant.node.data.id());\n-            // When we find an expression, every variant currently on the stack\n-            // is affected by that expression.\n-            if let Some(expr) = variant.node.disr_expr {\n-                for id in &variant_stack {\n-                    self.discriminant_map.insert(*id, Some(expr));\n-                }\n-                variant_stack.clear()\n-            }\n-        }\n-        // If we are at the top, that always starts at 0, so any variant on the\n-        // stack has a default value and does not need to be checked.\n-        for id in &variant_stack {\n-            self.discriminant_map.insert(*id, None);\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'hir: 'b> Visitor<'hir> for CheckItemRecursionVisitor<'a, 'b, 'hir> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n-    }\n-    fn visit_item(&mut self, it: &'hir hir::Item) {\n-        self.with_item_id_pushed(it.id, |v| intravisit::walk_item(v, it), it.span);\n-    }\n-\n-    fn visit_enum_def(&mut self,\n-                      enum_definition: &'hir hir::EnumDef,\n-                      generics: &'hir hir::Generics,\n-                      item_id: ast::NodeId,\n-                      _: Span) {\n-        self.populate_enum_discriminants(enum_definition);\n-        intravisit::walk_enum_def(self, enum_definition, generics, item_id);\n-    }\n-\n-    fn visit_variant(&mut self,\n-                     variant: &'hir hir::Variant,\n-                     _: &'hir hir::Generics,\n-                     _: ast::NodeId) {\n-        let variant_id = variant.node.data.id();\n-        let maybe_expr = *self.discriminant_map.get(&variant_id).unwrap_or_else(|| {\n-            span_bug!(variant.span,\n-                      \"`check_static_recursion` attempted to visit \\\n-                      variant with unknown discriminant\")\n-        });\n-        // If `maybe_expr` is `None`, that's because no discriminant is\n-        // specified that affects this variant. Thus, no risk of recursion.\n-        if let Some(expr) = maybe_expr {\n-            let expr = &self.hir_map.body(expr).value;\n-            self.with_item_id_pushed(expr.id, |v| intravisit::walk_expr(v, expr), expr.span);\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'hir hir::TraitItem) {\n-        self.with_item_id_pushed(ti.id, |v| intravisit::walk_trait_item(v, ti), ti.span);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'hir hir::ImplItem) {\n-        self.with_item_id_pushed(ii.id, |v| intravisit::walk_impl_item(v, ii), ii.span);\n-    }\n-\n-    fn visit_path(&mut self, path: &'hir hir::Path, _: ast::NodeId) {\n-        match path.def {\n-            Def::Static(def_id, _) |\n-            Def::AssociatedConst(def_id) |\n-            Def::Const(def_id) => {\n-                if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n-                    match self.hir_map.get(node_id) {\n-                        hir_map::NodeItem(item) => self.visit_item(item),\n-                        hir_map::NodeTraitItem(item) => self.visit_trait_item(item),\n-                        hir_map::NodeImplItem(item) => self.visit_impl_item(item),\n-                        hir_map::NodeForeignItem(_) => {}\n-                        _ => {\n-                            span_bug!(path.span,\n-                                      \"expected item, found {}\",\n-                                      self.hir_map.node_to_string(node_id));\n-                        }\n-                    }\n-                }\n-            }\n-            // For variants, we only want to check expressions that\n-            // affect the specific variant used, but we need to check\n-            // the whole enum definition to see what expression that\n-            // might be (if any).\n-            Def::VariantCtor(variant_id, CtorKind::Const) => {\n-                if let Some(variant_id) = self.hir_map.as_local_node_id(variant_id) {\n-                    let variant = self.hir_map.expect_variant(variant_id);\n-                    let enum_id = self.hir_map.get_parent(variant_id);\n-                    let enum_item = self.hir_map.expect_item(enum_id);\n-                    if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n-                        self.populate_enum_discriminants(enum_def);\n-                        self.visit_variant(variant, generics, enum_id);\n-                    } else {\n-                        span_bug!(path.span,\n-                                  \"`check_static_recursion` found \\\n-                                    non-enum in Def::VariantCtor\");\n-                    }\n-                }\n-            }\n-            _ => (),\n-        }\n-        intravisit::walk_path(self, path);\n-    }\n-}"}, {"sha": "d5a58c08cbe5a0d950c2ae9bb89b94ea5f5d3737", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -115,7 +115,7 @@ impl<'a> SpanUtils<'a> {\n         // We keep track of the following two counts - the depth of nesting of\n         // angle brackets, and the depth of nesting of square brackets. For the\n         // angle bracket count, we only count tokens which occur outside of any\n-        // square brackets (i.e. bracket_count == 0). The intutition here is\n+        // square brackets (i.e. bracket_count == 0). The intuition here is\n         // that we want to count angle brackets in the type, but not any which\n         // could be in expression context (because these could mean 'less than',\n         // etc.).\n@@ -151,18 +151,20 @@ impl<'a> SpanUtils<'a> {\n             }\n             prev = next;\n         }\n-        if angle_count != 0 || bracket_count != 0 {\n-            let loc = self.sess.codemap().lookup_char_pos(span.lo());\n-            span_bug!(\n-                span,\n-                \"Mis-counted brackets when breaking path? Parsing '{}' \\\n-                 in {}, line {}\",\n-                self.snippet(span),\n-                loc.file.name,\n-                loc.line\n-            );\n+        #[cfg(debug_assertions)] {\n+            if angle_count != 0 || bracket_count != 0 {\n+                let loc = self.sess.codemap().lookup_char_pos(span.lo());\n+                span_bug!(\n+                    span,\n+                    \"Mis-counted brackets when breaking path? Parsing '{}' \\\n+                     in {}, line {}\",\n+                    self.snippet(span),\n+                    loc.file.name,\n+                    loc.line\n+                );\n+            }\n         }\n-        if result.is_none() && prev.tok.is_ident() && angle_count == 0 {\n+        if result.is_none() && prev.tok.is_ident() {\n             return Some(prev.sp);\n         }\n         result"}, {"sha": "c0785f5393716a7d7b9e90b70a3f4f506b80a017", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1004,6 +1004,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(\n     let translation_items: DefIdSet = items.iter().filter_map(|trans_item| {\n         match *trans_item {\n             MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n             _ => None,\n         }\n     }).collect();\n@@ -1107,7 +1108,7 @@ impl CrateInfo {\n     }\n }\n \n-fn is_translated_function(tcx: TyCtxt, id: DefId) -> bool {\n+fn is_translated_item(tcx: TyCtxt, id: DefId) -> bool {\n     let (all_trans_items, _) =\n         tcx.collect_and_partition_translation_items(LOCAL_CRATE);\n     all_trans_items.contains(&id)\n@@ -1222,7 +1223,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.collect_and_partition_translation_items =\n         collect_and_partition_translation_items;\n \n-    providers.is_translated_function = is_translated_function;\n+    providers.is_translated_item = is_translated_item;\n \n     providers.codegen_unit = |tcx, name| {\n         let (_, all) = tcx.collect_and_partition_translation_items(LOCAL_CRATE);"}, {"sha": "8c40aa6a2acba5d2e374ce86304ed7cac5b77930", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -149,7 +149,7 @@ pub fn get_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n \n-            if cx.tcx.is_translated_function(instance_def_id) {\n+            if cx.tcx.is_translated_item(instance_def_id) {\n                 if instance_def_id.is_local() {\n                     if !cx.tcx.is_exported_symbol(instance_def_id) {\n                         llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);"}, {"sha": "1608c4a87bf5c16ca3eab8df49129cb5b5685f56", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::map as hir_map;\n use rustc::middle::const_val::ConstEvalErr;\n use debuginfo;\n use base;\n-use monomorphize::{MonoItem, MonoItemExt};\n+use monomorphize::MonoItem;\n use common::{CodegenCx, val_ty};\n use declare;\n use monomorphize::Instance;\n@@ -110,21 +110,24 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n+    let defined_in_current_codegen_unit = cx.codegen_unit\n+                                            .items()\n+                                            .contains_key(&MonoItem::Static(def_id));\n+    assert!(!defined_in_current_codegen_unit,\n+            \"consts::get_static() should always hit the cache for \\\n+             statics defined in the same CGU, but did not for `{:?}`\",\n+             def_id);\n+\n     let ty = instance.ty(cx.tcx);\n+    let sym = cx.tcx.symbol_name(instance);\n+\n     let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = MonoItem::Static(id).symbol_name(cx.tcx);\n-\n-                let defined_in_current_codegen_unit = cx.codegen_unit\n-                                                         .items()\n-                                                         .contains_key(&MonoItem::Static(id));\n-                assert!(!defined_in_current_codegen_unit);\n-\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n@@ -143,7 +146,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = cx.tcx.symbol_name(instance);\n+\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -203,8 +206,6 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = cx.tcx.symbol_name(instance);\n-\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n         let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n@@ -225,8 +226,15 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             // statically in the final application, we always mark such symbols as 'dllimport'.\n             // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs to\n             // make things work.\n-            unsafe {\n-                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            //\n+            // However, in some scenarios we defer emission of statics to downstream\n+            // crates, so there are cases where a static with an upstream DefId\n+            // is actually present in the current crate. We can find out via the\n+            // is_translated_item query.\n+            if !cx.tcx.is_translated_item(def_id) {\n+                unsafe {\n+                    llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+                }\n             }\n         }\n         g\n@@ -245,12 +253,11 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n }\n \n pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                              m: hir::Mutability,\n-                              id: ast::NodeId,\n+                              def_id: DefId,\n+                              is_mutable: bool,\n                               attrs: &[ast::Attribute])\n                               -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n-        let def_id = cx.tcx.hir.local_def_id(id);\n         let g = get_static(cx, def_id);\n \n         let v = ::mir::trans_static_initializer(cx, def_id)?;\n@@ -298,13 +305,13 @@ pub fn trans_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n-        if m != hir::MutMutable {\n+        if !is_mutable {\n             if cx.type_is_freeze(ty) {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n \n-        debuginfo::create_global_var_metadata(cx, id, g);\n+        debuginfo::create_global_var_metadata(cx, def_id, g);\n \n         if attr::contains_name(attrs, \"thread_local\") {\n             llvm::set_thread_local_mode(g, cx.tls_model);"}, {"sha": "2c430d03c968ec02d46b05ff75b5513c3dd06200", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -14,7 +14,7 @@ use self::EnumDiscriminantInfo::*;\n \n use super::utils::{debug_context, DIB, span_start,\n                    get_namespace_for_item, create_DIArray, is_node_local_to_unit};\n-use super::namespace::mangled_name_of_item;\n+use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n@@ -1634,19 +1634,18 @@ fn create_union_stub<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_global_var_metadata(cx: &CodegenCx,\n-                                  node_id: ast::NodeId,\n+                                  def_id: DefId,\n                                   global: ValueRef) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n \n     let tcx = cx.tcx;\n-    let node_def_id = tcx.hir.local_def_id(node_id);\n-    let no_mangle = attr::contains_name(&tcx.get_attrs(node_def_id), \"no_mangle\");\n+    let no_mangle = attr::contains_name(&tcx.get_attrs(def_id), \"no_mangle\");\n     // We may want to remove the namespace scope if we're in an extern block, see:\n     // https://github.com/rust-lang/rust/pull/46457#issuecomment-351750952\n-    let var_scope = get_namespace_for_item(cx, node_def_id);\n-    let span = cx.tcx.def_span(node_def_id);\n+    let var_scope = get_namespace_for_item(cx, def_id);\n+    let span = cx.tcx.def_span(def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n         let loc = span_start(cx, span);\n@@ -1655,15 +1654,15 @@ pub fn create_global_var_metadata(cx: &CodegenCx,\n         (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n \n-    let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = Instance::mono(cx.tcx, node_def_id).ty(cx.tcx);\n+    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n+    let variable_type = Instance::mono(cx.tcx, def_id).ty(cx.tcx);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = tcx.item_name(node_def_id).to_string();\n+    let var_name = tcx.item_name(def_id).to_string();\n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = if no_mangle {\n         None\n     } else {\n-        let linkage_name = mangled_name_of_item(cx, node_id);\n+        let linkage_name = mangled_name_of_instance(cx, Instance::mono(tcx, def_id));\n         Some(CString::new(linkage_name.to_string()).unwrap())\n     };\n "}, {"sha": "16279f31836a984c2e6cd78ae7ff278310ea1b15", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -254,14 +254,14 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n     let linkage_name = mangled_name_of_instance(cx, instance);\n \n     let scope_line = span_start(cx, span).line;\n-\n-    let local_id = cx.tcx.hir.as_local_node_id(instance.def_id());\n-    let is_local_to_unit = local_id.map_or(false, |id| is_node_local_to_unit(cx, id));\n+    let is_local_to_unit = is_node_local_to_unit(cx, def_id);\n \n     let function_name = CString::new(name).unwrap();\n     let linkage_name = CString::new(linkage_name.to_string()).unwrap();\n \n     let mut flags = DIFlags::FlagPrototyped;\n+\n+    let local_id = cx.tcx.hir.as_local_node_id(def_id);\n     match *cx.sess().entry_fn.borrow() {\n         Some((id, _)) => {\n             if local_id == Some(id) {"}, {"sha": "891bf649c388a02aa7a6549408cf0113f5817439", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -14,7 +14,6 @@ use super::metadata::{unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n use super::utils::{DIB, debug_context};\n use monomorphize::Instance;\n use rustc::ty;\n-use syntax::ast;\n \n use llvm;\n use llvm::debuginfo::DIScope;\n@@ -33,16 +32,6 @@ pub fn mangled_name_of_instance<'a, 'tcx>(\n      tcx.symbol_name(instance)\n }\n \n-pub fn mangled_name_of_item<'a, 'tcx>(\n-    cx: &CodegenCx<'a, 'tcx>,\n-    node_id: ast::NodeId,\n-) -> ty::SymbolName {\n-    let tcx = cx.tcx;\n-    let node_def_id = tcx.hir.local_def_id(node_id);\n-    let instance = Instance::mono(tcx, node_def_id);\n-    tcx.symbol_name(instance)\n-}\n-\n pub fn item_namespace(cx: &CodegenCx, def_id: DefId) -> DIScope {\n     if let Some(&scope) = debug_context(cx).namespace_map.borrow().get(&def_id) {\n         return scope;"}, {"sha": "9559cd4d9ea2d52e2088bc147eb27446cb0b65d9", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -21,9 +21,8 @@ use llvm::debuginfo::{DIScope, DIBuilderRef, DIDescriptor, DIArray};\n use common::{CodegenCx};\n \n use syntax_pos::{self, Span};\n-use syntax::ast;\n \n-pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n+pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n     // current compilation unit (i.e. if it is *static* in the C-sense). The\n@@ -33,7 +32,6 @@ pub fn is_node_local_to_unit(cx: &CodegenCx, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    let def_id = cx.tcx.hir.local_def_id(node_id);\n     !cx.tcx.is_exported_symbol(def_id)\n }\n "}, {"sha": "91c1097fc7f8a5dc733384495effaf6c587440ca", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -24,10 +24,11 @@ use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::ty::TypeFoldable;\n use rustc::ty::layout::LayoutOf;\n-use syntax::ast;\n use syntax::attr;\n use std::fmt;\n \n@@ -44,19 +45,25 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n                cx.codegen_unit.name());\n \n         match *self.as_mono_item() {\n-            MonoItem::Static(node_id) => {\n+            MonoItem::Static(def_id) => {\n                 let tcx = cx.tcx;\n-                let item = tcx.hir.expect_item(node_id);\n-                if let hir::ItemStatic(_, m, _) = item.node {\n-                    match consts::trans_static(&cx, m, item.id, &item.attrs) {\n-                        Ok(_) => { /* Cool, everything's alright. */ },\n-                        Err(err) => {\n-                            err.report(tcx, item.span, \"static\");\n-                        }\n-                    };\n-                } else {\n-                    span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")\n-                }\n+                let is_mutable = match tcx.describe_def(def_id) {\n+                    Some(Def::Static(_, is_mutable)) => is_mutable,\n+                    Some(other) => {\n+                        bug!(\"Expected Def::Static, found {:?}\", other)\n+                    }\n+                    None => {\n+                        bug!(\"Expected Def::Static for {:?}, found nothing\", def_id)\n+                    }\n+                };\n+                let attrs = tcx.get_attrs(def_id);\n+\n+                match consts::trans_static(&cx, def_id, is_mutable, &attrs) {\n+                    Ok(_) => { /* Cool, everything's alright. */ },\n+                    Err(err) => {\n+                        err.report(tcx, tcx.def_span(def_id), \"static\");\n+                    }\n+                };\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n@@ -91,8 +98,8 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n         debug!(\"symbol {}\", &symbol_name);\n \n         match *self.as_mono_item() {\n-            MonoItem::Static(node_id) => {\n-                predefine_static(cx, node_id, linkage, visibility, &symbol_name);\n+            MonoItem::Static(def_id) => {\n+                predefine_static(cx, def_id, linkage, visibility, &symbol_name);\n             }\n             MonoItem::Fn(instance) => {\n                 predefine_fn(cx, instance, linkage, visibility, &symbol_name);\n@@ -126,17 +133,16 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n impl<'a, 'tcx> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {}\n \n fn predefine_static<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                              node_id: ast::NodeId,\n+                              def_id: DefId,\n                               linkage: Linkage,\n                               visibility: Visibility,\n                               symbol_name: &str) {\n-    let def_id = cx.tcx.hir.local_def_id(node_id);\n     let instance = Instance::mono(cx.tcx, def_id);\n     let ty = instance.ty(cx.tcx);\n     let llty = cx.layout_of(ty).llvm_type(cx);\n \n     let g = declare::define_global(cx, symbol_name, llty).unwrap_or_else(|| {\n-        cx.sess().span_fatal(cx.tcx.hir.span(node_id),\n+        cx.sess().span_fatal(cx.tcx.def_span(def_id),\n             &format!(\"symbol `{}` is already defined\", symbol_name))\n     });\n "}, {"sha": "d7d856fe3ad068e096ce60ab329f9bcca3c4e327", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -500,11 +500,6 @@ mod memchr;\n // The runtime entry point and a few unstable public functions used by the\n // compiler\n pub mod rt;\n-// The trait to support returning arbitrary types in the main function\n-mod termination;\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-pub use self::termination::Termination;\n \n // Include a number of private modules that exist solely to provide\n // the rustdoc documentation for primitive types. Using `include!`"}, {"sha": "e25599b8bd8712e6c13fafbf9ec27fe93509d329", "filename": "src/libstd/process.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1392,6 +1392,73 @@ pub fn id() -> u32 {\n     ::sys::os::getpid()\n }\n \n+#[cfg(target_arch = \"wasm32\")]\n+mod exit {\n+    pub const SUCCESS: i32 = 0;\n+    pub const FAILURE: i32 = 1;\n+}\n+#[cfg(not(target_arch = \"wasm32\"))]\n+mod exit {\n+    use libc;\n+    pub const SUCCESS: i32 = libc::EXIT_SUCCESS;\n+    pub const FAILURE: i32 = libc::EXIT_FAILURE;\n+}\n+\n+/// A trait for implementing arbitrary return types in the `main` function.\n+///\n+/// The c-main function only supports to return integers as return type.\n+/// So, every type implementing the `Termination` trait has to be converted\n+/// to an integer.\n+///\n+/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n+/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n+#[cfg_attr(not(test), lang = \"termination\")]\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+#[rustc_on_unimplemented =\n+  \"`main` can only return types that implement {Termination}, not `{Self}`\"]\n+pub trait Termination {\n+    /// Is called to get the representation of the value as status code.\n+    /// This status code is returned to the operating system.\n+    fn report(self) -> i32;\n+}\n+\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+impl Termination for () {\n+    fn report(self) -> i32 { exit::SUCCESS }\n+}\n+\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+impl<T: Termination, E: fmt::Debug> Termination for Result<T, E> {\n+    fn report(self) -> i32 {\n+        match self {\n+            Ok(val) => val.report(),\n+            Err(err) => {\n+                eprintln!(\"Error: {:?}\", err);\n+                exit::FAILURE\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+impl Termination for ! {\n+    fn report(self) -> i32 { unreachable!(); }\n+}\n+\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+impl Termination for bool {\n+    fn report(self) -> i32 {\n+        if self { exit::SUCCESS } else { exit::FAILURE }\n+    }\n+}\n+\n+#[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n+impl Termination for i32 {\n+    fn report(self) -> i32 {\n+        self\n+    }\n+}\n+\n #[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use io::prelude::*;"}, {"sha": "e1392762a59dc7c76e5b73142b11b05a9702bae7", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -68,7 +68,7 @@ fn lang_start_internal(main: &(Fn() -> i32 + Sync + ::panic::RefUnwindSafe),\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n-fn lang_start<T: ::termination::Termination + 'static>\n+fn lang_start<T: ::process::Termination + 'static>\n     (main: fn() -> T, argc: isize, argv: *const *const u8) -> isize\n {\n     lang_start_internal(&move || main().report(), argc, argv)"}, {"sha": "dc7fa53aab63253110945b97a52c82b5b87c2553", "filename": "src/libstd/termination.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibstd%2Ftermination.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Flibstd%2Ftermination.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftermination.rs?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use fmt::Debug;\n-#[cfg(target_arch = \"wasm32\")]\n-mod exit {\n-    pub const SUCCESS: i32 = 0;\n-    pub const FAILURE: i32 = 1;\n-}\n-#[cfg(not(target_arch = \"wasm32\"))]\n-mod exit {\n-    use libc;\n-    pub const SUCCESS: i32 = libc::EXIT_SUCCESS;\n-    pub const FAILURE: i32 = libc::EXIT_FAILURE;\n-}\n-\n-/// A trait for implementing arbitrary return types in the `main` function.\n-///\n-/// The c-main function only supports to return integers as return type.\n-/// So, every type implementing the `Termination` trait has to be converted\n-/// to an integer.\n-///\n-/// The default implementations are returning `libc::EXIT_SUCCESS` to indicate\n-/// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n-#[cfg_attr(not(test), lang = \"termination\")]\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-#[rustc_on_unimplemented =\n-  \"`main` can only return types that implement {Termination}, not `{Self}`\"]\n-pub trait Termination {\n-    /// Is called to get the representation of the value as status code.\n-    /// This status code is returned to the operating system.\n-    fn report(self) -> i32;\n-}\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-impl Termination for () {\n-    fn report(self) -> i32 { exit::SUCCESS }\n-}\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-impl<T: Termination, E: Debug> Termination for Result<T, E> {\n-    fn report(self) -> i32 {\n-        match self {\n-            Ok(val) => val.report(),\n-            Err(err) => {\n-                eprintln!(\"Error: {:?}\", err);\n-                exit::FAILURE\n-            }\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-impl Termination for ! {\n-    fn report(self) -> i32 { unreachable!(); }\n-}\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-impl Termination for bool {\n-    fn report(self) -> i32 {\n-        if self { exit::SUCCESS } else { exit::FAILURE }\n-    }\n-}\n-\n-#[unstable(feature = \"termination_trait\", issue = \"43301\")]\n-impl Termination for i32 {\n-    fn report(self) -> i32 {\n-        self\n-    }\n-}"}, {"sha": "b88e064e7e56dd059c8d54290a9cd005c3a9d6f7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -319,14 +319,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 types: Vec<P<ast::Ty>>,\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n-        use syntax::parse::token;\n-\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = Vec::new();\n-        if global &&\n-           !idents.first().map_or(false, |&ident| token::Ident(ident).is_path_segment_keyword()) {\n-            segments.push(ast::PathSegment::crate_root(span));\n-        }\n \n         segments.extend(idents.into_iter().map(|i| ast::PathSegment::from_ident(i, span)));\n         let parameters = if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n@@ -335,7 +329,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             None\n         };\n         segments.push(ast::PathSegment { identifier: last_identifier, span, parameters });\n-        ast::Path { span, segments }\n+        let path = ast::Path { span, segments };\n+\n+        if global { path.default_to_global() } else { path }\n     }\n \n     /// Constructs a qualified path."}, {"sha": "ba24d7f914be11c62bc4288437952d93fe19d165", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -432,9 +432,6 @@ declare_features! (\n     // `foo.rs` as an alternative to `foo/mod.rs`\n     (active, non_modrs_mods, \"1.24.0\", Some(44660)),\n \n-    // Nested `impl Trait`\n-    (active, nested_impl_trait, \"1.24.0\", Some(34511)),\n-\n     // Termination trait in main (RFC 1937)\n     (active, termination_trait, \"1.24.0\", Some(43301)),\n \n@@ -1352,73 +1349,8 @@ fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n     }\n }\n \n-// Bans nested `impl Trait`, e.g. `impl Into<impl Debug>`.\n-// Nested `impl Trait` _is_ allowed in associated type position,\n-// e.g `impl Iterator<Item=impl Debug>`\n-struct NestedImplTraitVisitor<'a> {\n-    context: &'a Context<'a>,\n-    is_in_impl_trait: bool,\n-}\n-\n-impl<'a> NestedImplTraitVisitor<'a> {\n-    fn with_impl_trait<F>(&mut self, is_in_impl_trait: bool, f: F)\n-        where F: FnOnce(&mut NestedImplTraitVisitor<'a>)\n-    {\n-        let old_is_in_impl_trait = self.is_in_impl_trait;\n-        self.is_in_impl_trait = is_in_impl_trait;\n-        f(self);\n-        self.is_in_impl_trait = old_is_in_impl_trait;\n-    }\n-}\n-\n-\n-impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n-    fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        if let ast::TyKind::ImplTrait(_) = t.node {\n-            if self.is_in_impl_trait {\n-                gate_feature_post!(&self, nested_impl_trait, t.span,\n-                    \"nested `impl Trait` is experimental\"\n-                );\n-            }\n-            self.with_impl_trait(true, |this| visit::walk_ty(this, t));\n-        } else {\n-            visit::walk_ty(self, t);\n-        }\n-    }\n-    fn visit_path_parameters(&mut self, _: Span, path_parameters: &'a ast::PathParameters) {\n-        match *path_parameters {\n-            ast::PathParameters::AngleBracketed(ref params) => {\n-                for type_ in &params.types {\n-                    self.visit_ty(type_);\n-                }\n-                for type_binding in &params.bindings {\n-                    // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n-                    // are allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(false, |this| visit::walk_ty(this, &type_binding.ty));\n-                }\n-            }\n-            ast::PathParameters::Parenthesized(ref params) => {\n-                for type_ in &params.inputs {\n-                    self.visit_ty(type_);\n-                }\n-                if let Some(ref type_) = params.output {\n-                    // `-> Foo` syntax is essentially an associated type binding,\n-                    // so it is also allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(false, |this| visit::walk_ty(this, type_));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> PostExpansionVisitor<'a> {\n-    fn whole_crate_feature_gates(&mut self, krate: &ast::Crate) {\n-        visit::walk_crate(\n-            &mut NestedImplTraitVisitor {\n-                context: self.context,\n-                is_in_impl_trait: false,\n-            }, krate);\n-\n+    fn whole_crate_feature_gates(&mut self, _krate: &ast::Crate) {\n         for &(ident, span) in &*self.context.parse_sess.non_modrs_mods.borrow() {\n             if !span.allows_unstable() {\n                 let cx = &self.context;"}, {"sha": "efc191f24ac6f2470628bff51349056c3d0a8a4d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -6482,6 +6482,8 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| *t != token::OpenDelim(token::Brace)) {\n             // UNSAFE FUNCTION ITEM\n             self.bump(); // `unsafe`\n+            // `{` is also expected after `unsafe`, in case of error, include it in the diagnostic\n+            self.check(&token::OpenDelim(token::Brace));\n             let abi = if self.eat_keyword(keywords::Extern) {\n                 self.parse_opt_abi()?.unwrap_or(Abi::C)\n             } else {"}, {"sha": "e732ac3a635ba1475de4d3a41c4ad5da2ccd7fbb", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 146, "deletions": 45, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -32,6 +32,7 @@ use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n use ext::hygiene::{Mark, SyntaxContext};\n use fold::Folder;\n+use feature_gate::Features;\n use util::move_map::MoveMap;\n use fold;\n use parse::{token, ParseSess};\n@@ -63,6 +64,7 @@ struct TestCtxt<'a> {\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n     ctxt: SyntaxContext,\n+    features: &'a Features,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -74,7 +76,8 @@ pub fn modify_for_testing(sess: &ParseSess,\n                           resolver: &mut Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n-                          span_diagnostic: &errors::Handler) -> ast::Crate {\n+                          span_diagnostic: &errors::Handler,\n+                          features: &Features) -> ast::Crate {\n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n@@ -84,7 +87,8 @@ pub fn modify_for_testing(sess: &ParseSess,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n-        generate_test_harness(sess, resolver, reexport_test_harness_main, krate, span_diagnostic)\n+        generate_test_harness(sess, resolver, reexport_test_harness_main,\n+                              krate, span_diagnostic, features)\n     } else {\n         krate\n     }\n@@ -265,23 +269,28 @@ fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n-                         sd: &errors::Handler) -> ast::Crate {\n+                         sd: &errors::Handler,\n+                         features: &Features) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n \n     let mark = Mark::fresh(Mark::root());\n \n+    let mut econfig = ExpansionConfig::default(\"test\".to_string());\n+    econfig.features = Some(features);\n+\n     let cx = TestCtxt {\n         span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, ExpansionConfig::default(\"test\".to_string()), resolver),\n+        ext_cx: ExtCtxt::new(sess, econfig, resolver),\n         path: Vec::new(),\n         testfns: Vec::new(),\n         reexport_test_harness_main,\n         // NB: doesn't consider the value of `--crate-name` passed on the command line.\n         is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n+        features,\n     };\n \n     mark.set_expn_info(ExpnInfo {\n@@ -318,71 +327,105 @@ enum HasTestSignature {\n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n-    fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n+    fn has_test_signature(cx: &TestCtxt, i: &ast::Item) -> HasTestSignature {\n         match i.node {\n-          ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n-            let no_output = match decl.output {\n-                ast::FunctionRetTy::Default(..) => true,\n-                ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n-                _ => false\n-            };\n-            if decl.inputs.is_empty()\n-                   && no_output\n-                   && !generics.is_parameterized() {\n-                Yes\n-            } else {\n-                No\n+            ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n+                // If the termination trait is active, the compiler will check that the output\n+                // type implements the `Termination` trait as `libtest` enforces that.\n+                let output_matches = if cx.features.termination_trait {\n+                    true\n+                } else {\n+                    let no_output = match decl.output {\n+                        ast::FunctionRetTy::Default(..) => true,\n+                        ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n+                        _ => false\n+                    };\n+\n+                    no_output && !generics.is_parameterized()\n+                };\n+\n+                if decl.inputs.is_empty() && output_matches {\n+                    Yes\n+                } else {\n+                    No\n+                }\n             }\n-          }\n-          _ => NotEvenAFunction,\n+            _ => NotEvenAFunction,\n         }\n     }\n \n-    if has_test_attr {\n+    let has_test_signature = if has_test_attr {\n         let diag = cx.span_diagnostic;\n-        match has_test_signature(i) {\n-            Yes => {},\n-            No => diag.span_err(i.span, \"functions used as tests must have signature fn() -> ()\"),\n-            NotEvenAFunction => diag.span_err(i.span,\n-                                              \"only functions may be used as tests\"),\n+        match has_test_signature(cx, i) {\n+            Yes => true,\n+            No => {\n+                if cx.features.termination_trait {\n+                    diag.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                } else {\n+                    diag.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+                }\n+                false\n+            },\n+            NotEvenAFunction => {\n+                diag.span_err(i.span, \"only functions may be used as tests\");\n+                false\n+            },\n         }\n-    }\n+    } else {\n+        false\n+    };\n \n-    has_test_attr && has_test_signature(i) == Yes\n+    has_test_attr && has_test_signature\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n \n-    fn has_test_signature(i: &ast::Item) -> bool {\n+    fn has_bench_signature(cx: &TestCtxt, i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n-                let no_output = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => true,\n-                    ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n-                    _ => false\n+\n+                // If the termination trait is active, the compiler will check that the output\n+                // type implements the `Termination` trait as `libtest` enforces that.\n+                let output_matches = if cx.features.termination_trait {\n+                    true\n+                } else {\n+                    let no_output = match decl.output {\n+                        ast::FunctionRetTy::Default(..) => true,\n+                        ast::FunctionRetTy::Ty(ref t) if t.node == ast::TyKind::Tup(vec![]) => true,\n+                        _ => false\n+                    };\n+                    let tparm_cnt = generics.params.iter()\n+                        .filter(|param| param.is_type_param())\n+                        .count();\n+\n+                    no_output && tparm_cnt == 0\n                 };\n-                let tparm_cnt = generics.params.iter()\n-                    .filter(|param| param.is_type_param())\n-                    .count();\n \n                 // NB: inadequate check, but we're running\n                 // well before resolve, can't get too deep.\n-                input_cnt == 1\n-                    && no_output && tparm_cnt == 0\n+                input_cnt == 1 && output_matches\n             }\n           _ => false\n         }\n     }\n \n-    if has_bench_attr && !has_test_signature(i) {\n+    let has_bench_signature = has_bench_signature(cx, i);\n+\n+    if has_bench_attr && !has_bench_signature {\n         let diag = cx.span_diagnostic;\n-        diag.span_err(i.span, \"functions used as benches must have signature \\\n-                      `fn(&mut Bencher) -> ()`\");\n+\n+        if cx.features.termination_trait {\n+            diag.span_err(i.span, \"functions used as benches must have signature \\\n+                                   `fn(&mut Bencher) -> impl Termination`\");\n+        } else {\n+            diag.span_err(i.span, \"functions used as benches must have signature \\\n+                                   `fn(&mut Bencher) -> ()`\");\n+        }\n     }\n \n-    has_bench_attr && has_test_signature(i)\n+    has_bench_attr && has_bench_signature\n }\n \n fn is_ignored(i: &ast::Item) -> bool {\n@@ -690,19 +733,77 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n              field(\"should_panic\", fail_expr),\n              field(\"allow_fail\", allow_fail_expr)]);\n \n-\n-    let mut visible_path = match cx.toplevel_reexport {\n-        Some(id) => vec![id],\n+    let mut visible_path = vec![];\n+    if cx.features.extern_absolute_paths {\n+        visible_path.push(keywords::Crate.ident());\n+    }\n+    match cx.toplevel_reexport {\n+        Some(id) => visible_path.push(id),\n         None => {\n             let diag = cx.span_diagnostic;\n             diag.bug(\"expected to find top-level re-export name, but found None\");\n         }\n     };\n     visible_path.extend(path);\n \n-    let fn_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n+    // Rather than directly give the test function to the test\n+    // harness, we create a wrapper like one of the following:\n+    //\n+    //     || test::assert_test_result(real_function()) // for test\n+    //     |b| test::assert_test_result(real_function(b)) // for bench\n+    //\n+    // this will coerce into a fn pointer that is specialized to the\n+    // actual return type of `real_function` (Typically `()`, but not always).\n+    let fn_expr = {\n+        // construct `real_function()` (this will be inserted into the overall expr)\n+        let real_function_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n+        // construct path `test::assert_test_result`\n+        let assert_test_result = test_path(\"assert_test_result\");\n+        if test.bench {\n+            // construct `|b| {..}`\n+            let b_ident = Ident::with_empty_ctxt(Symbol::gensym(\"b\"));\n+            let b_expr = ecx.expr_ident(span, b_ident);\n+            ecx.lambda(\n+                span,\n+                vec![b_ident],\n+                // construct `assert_test_result(..)`\n+                ecx.expr_call(\n+                    span,\n+                    ecx.expr_path(assert_test_result),\n+                    vec![\n+                        // construct `real_function(b)`\n+                        ecx.expr_call(\n+                            span,\n+                            real_function_expr,\n+                            vec![b_expr],\n+                        )\n+                    ],\n+                ),\n+            )\n+        } else {\n+            // construct `|| {..}`\n+            ecx.lambda(\n+                span,\n+                vec![],\n+                // construct `assert_test_result(..)`\n+                ecx.expr_call(\n+                    span,\n+                    ecx.expr_path(assert_test_result),\n+                    vec![\n+                        // construct `real_function()`\n+                        ecx.expr_call(\n+                            span,\n+                            real_function_expr,\n+                            vec![],\n+                        )\n+                    ],\n+                ),\n+            )\n+        }\n+    };\n \n     let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+\n     // self::test::$variant_name($fn_expr)\n     let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n "}, {"sha": "82077bc4cd4822319346c0632df8a1bc941ecad3", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -40,6 +40,7 @@\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n+#![feature(termination_trait_lib)]\n \n extern crate getopts;\n extern crate term;\n@@ -67,6 +68,7 @@ use std::io::prelude::*;\n use std::io;\n use std::iter::repeat;\n use std::path::PathBuf;\n+use std::process::Termination;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -81,8 +83,8 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n pub mod test {\n     pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n              TrFailedMsg, TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName,\n-             DynTestName, DynTestFn, run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn, ShouldPanic, Options};\n+             DynTestName, DynTestFn, assert_test_result, run_test, test_main, test_main_static,\n+             filter_tests, parse_opts, StaticBenchFn, ShouldPanic, Options};\n }\n \n pub mod stats;\n@@ -322,6 +324,13 @@ pub fn test_main_static(tests: &[TestDescAndFn]) {\n     test_main(&args, owned_tests, Options::new())\n }\n \n+/// Invoked when unit tests terminate. Should panic if the unit\n+/// test is considered a failure. By default, invokes `report()`\n+/// and checks for a `0` result.\n+pub fn assert_test_result<T: Termination>(result: T) {\n+    assert_eq!(result.report(), 0);\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum ColorConfig {\n     AutoColor,"}, {"sha": "c425ed554a6f8c2434fd269237a29622b6ddf558", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -105,14 +105,10 @@ fn overloaded_call_traits() {\n         //[lxl]~^^^           ERROR use of moved value: `*f`\n         //[nll]~^^^^          ERROR cannot move a value of type\n         //[nll]~^^^^^         ERROR cannot move a value of type\n-        //[nll]~^^^^^^        ERROR cannot move a value of type\n-        //[nll]~^^^^^^^       ERROR cannot move a value of type\n-        //[nll]~^^^^^^^^      ERROR use of moved value: `*f`\n-        //[g2p]~^^^^^^^^^     ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^^^    ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^^^^   ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^^^^^  ERROR cannot move a value of type\n-        //[g2p]~^^^^^^^^^^^^^ ERROR use of moved value: `*f`\n+        //[nll]~^^^^^^        ERROR use of moved value: `*f`\n+        //[g2p]~^^^^^^^       ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^      ERROR cannot move a value of type\n+        //[g2p]~^^^^^^^^^     ERROR use of moved value: `*f`\n     }\n \n     twice_ten_sm(&mut |x| x + 1);"}, {"sha": "2f4d82e2ef514a43868df734d9ebf23677f7d675", "filename": "src/test/compile-fail/coherence-inherited-assoc-ty-cycle-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -17,7 +17,7 @@\n #![feature(specialization)]\n \n trait Trait<T> { type Assoc; }\n-//~^ unsupported cyclic reference between types/traits detected [E0391]\n+//~^ cyclic dependency detected [E0391]\n \n impl<T> Trait<T> for Vec<T> {\n     type Assoc = ();"}, {"sha": "6218dcbf5f2c54ec5f86e5cd27db7fd5c105a372", "filename": "src/test/compile-fail/const-size_of-cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-size_of-cycle.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unsupported cyclic reference between types/traits detected\n+// error-pattern: cyclic dependency detected\n \n #![feature(const_fn)]\n "}, {"sha": "ee4722c010f1660fe8e01555649da6c38e99cfef", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -25,7 +25,7 @@ trait Trait { type Item; }\n struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n-    //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~^ ERROR cyclic dependency detected\n     //~| ERROR associated type `Item` not found for `T`\n {\n     data: T"}, {"sha": "88672088bcb4c279eb412c6a77f9ed3c77ff7bb5", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -12,7 +12,7 @@\n // again references the trait.\n \n trait Foo<X = Box<Foo>> {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ ERROR cyclic dependency detected\n }\n \n fn main() { }"}, {"sha": "626567ccc0ead54616644092ad8e295411cd9153", "filename": "src/test/compile-fail/cycle-trait-supertrait-direct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -11,7 +11,7 @@\n // Test a supertrait cycle where a trait extends itself.\n \n trait Chromosome: Chromosome {\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ ERROR cyclic dependency detected\n }\n \n fn main() { }"}, {"sha": "52c5471681df300eef53c500bc6cb6a07df7b90e", "filename": "src/test/compile-fail/impl-trait/where-allowed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -10,7 +10,7 @@\n \n //! A simple test for testing many permutations of allowedness of\n //! impl Trait\n-#![feature(conservative_impl_trait, nested_impl_trait, universal_impl_trait, dyn_trait)]\n+#![feature(conservative_impl_trait, universal_impl_trait, dyn_trait)]\n use std::fmt::Debug;\n \n // Allowed\n@@ -60,6 +60,7 @@ fn in_dyn_Fn_return_in_return() -> &'static dyn Fn() -> impl Debug { panic!() }\n // Disallowed\n fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+//~^^ ERROR nested `impl Trait` is not allowed\n \n // Disallowed\n fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n@@ -68,6 +69,7 @@ fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n // Disallowed\n fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+//~^^ ERROR nested `impl Trait` is not allowed\n \n // Disallowed\n fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }"}, {"sha": "25d0590db1b75dbd296bf1e91bf61692346a6639", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n type x = Vec<x>;\n-//~^ ERROR unsupported cyclic reference\n+//~^ ERROR cyclic dependency detected\n \n fn main() { let b: x = Vec::new(); }"}, {"sha": "8d3df68577bab14f1d2518d02fd495acf220e63c", "filename": "src/test/compile-fail/issue-12997-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12997-2.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -15,6 +15,3 @@\n #[bench]\n fn bar(x: isize) { }\n //~^ ERROR mismatched types\n-//~| expected type `for<'r> fn(&'r mut __test::test::Bencher)`\n-//~| found type `fn(isize) {bar}`\n-//~| expected mutable reference, found isize"}, {"sha": "1c3e6890c8e2e17ea112daa8dff4ea0f0be348fc", "filename": "src/test/compile-fail/issue-17252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const FOO: usize = FOO; //~ ERROR recursive constant\n+const FOO: usize = FOO; //~ ERROR E0391\n \n fn main() {\n     let _x: [u8; FOO]; // caused stack overflow prior to fix\n     let _y: usize = 1 + {\n-        const BAR: usize = BAR; //~ ERROR recursive constant\n+        const BAR: usize = BAR;\n         let _z: [u8; BAR]; // caused stack overflow prior to fix\n         1\n     };"}, {"sha": "88395e5f1eafa1240f99b1bf099a20829fa82538", "filename": "src/test/compile-fail/issue-20772.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20772.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait T : Iterator<Item=Self::Item>\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~^ ERROR cyclic dependency detected\n //~| ERROR associated type `Item` not found for `Self`\n {}\n "}, {"sha": "aeb798b382875a5a740297723b9160282a405498", "filename": "src/test/compile-fail/issue-20825.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-20825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-20825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20825.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -13,7 +13,7 @@ pub trait Subscriber {\n }\n \n pub trait Processor: Subscriber<Input = Self::Input> {\n-    //~^ ERROR unsupported cyclic reference between types/traits detected [E0391]\n+    //~^ ERROR cyclic dependency detected [E0391]\n     type Input;\n }\n "}, {"sha": "40c95b98f1264d4f9311cf5364a414c8e8b72a89", "filename": "src/test/compile-fail/issue-21177.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21177.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -14,7 +14,7 @@ trait Trait {\n }\n \n fn foo<T: Trait<A = T::B>>() { }\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~^ ERROR cyclic dependency detected\n //~| ERROR associated type `B` not found for `T`\n \n fn main() { }"}, {"sha": "fde2d001542b84a1eda160b7fb62488440189fdb", "filename": "src/test/compile-fail/issue-22673.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-22673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-22673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22673.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n trait Expr : PartialEq<Self::Item> {\n-    //~^ ERROR: unsupported cyclic reference between types/traits detected\n+    //~^ ERROR: cyclic dependency detected\n     type Item;\n }\n "}, {"sha": "16a650cc6d88632ed57d1c809377e756036f8773", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: unsupported cyclic reference between types/traits detected\n+// error-pattern: cyclic dependency detected\n // note-pattern: the cycle begins when computing layout of\n // note-pattern: ...which then requires computing layout of\n // note-pattern: ...which then again requires computing layout of"}, {"sha": "b18e05af47c97266521065b5711c08e234b64aee", "filename": "src/test/compile-fail/issue-34373.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-34373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-34373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34373.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -15,7 +15,7 @@ trait Trait<T> {\n }\n \n pub struct Foo<T = Box<Trait<DefaultFoo>>>;\n-type DefaultFoo = Foo; //~ ERROR unsupported cyclic reference\n+type DefaultFoo = Foo; //~ ERROR cyclic dependency detected\n \n fn main() {\n }"}, {"sha": "930a427e9a5e0ec7c58261bfb7516de5bb442b23", "filename": "src/test/compile-fail/issue-44415.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-44415.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -15,7 +15,7 @@ use std::intrinsics;\n \n struct Foo {\n     bytes: [u8; unsafe { intrinsics::size_of::<Foo>() }],\n-    //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~^ ERROR cyclic dependency detected\n     x: usize,\n }\n "}, {"sha": "9eb567a5d3eb09feb10951f5cbdc139d0da7854c", "filename": "src/test/compile-fail/issue-48131.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-48131.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fissue-48131.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-48131.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This note is annotated because the purpose of the test\n+// is to ensure that certain other notes are not generated.\n+#![deny(unused_unsafe)] //~ NOTE\n+\n+// (test that no note is generated on this unsafe fn)\n+pub unsafe fn a() {\n+    fn inner() {\n+        unsafe { /* unnecessary */ } //~ ERROR unnecessary `unsafe`\n+                                     //~^ NOTE\n+    }\n+\n+    inner()\n+}\n+\n+pub fn b() {\n+    // (test that no note is generated on this unsafe block)\n+    unsafe {\n+        fn inner() {\n+            unsafe { /* unnecessary */ } //~ ERROR unnecessary `unsafe`\n+                                         //~^ NOTE\n+        }\n+\n+        let () = ::std::mem::uninitialized();\n+\n+        inner()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7210c857125d6d9e026acdc9273fed733dc26d95", "filename": "src/test/compile-fail/resolve-self-in-impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-self-in-impl.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -21,10 +21,10 @@ impl Tr for S where Self: Copy {} // OK\n impl Tr for S where S<Self>: Copy {} // OK\n impl Tr for S where Self::A: Copy {} // OK\n \n-impl Tr for Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n-impl Tr for S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n-impl Self {} //~ ERROR unsupported cyclic reference between types/traits detected\n-impl S<Self> {} //~ ERROR unsupported cyclic reference between types/traits detected\n-impl Tr<Self::A> for S {} //~ ERROR unsupported cyclic reference between types/traits detected\n+impl Tr for Self {} //~ ERROR cyclic dependency detected\n+impl Tr for S<Self> {} //~ ERROR cyclic dependency detected\n+impl Self {} //~ ERROR cyclic dependency detected\n+impl S<Self> {} //~ ERROR cyclic dependency detected\n+impl Tr<Self::A> for S {} //~ ERROR cyclic dependency detected\n \n fn main() {}"}, {"sha": "93e2561adf753fed810ab5ffddeb9295130ecac0", "filename": "src/test/compile-fail/rfc-1937-termination-trait/termination-trait-main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -10,6 +10,6 @@\n #![feature(termination_trait)]\n \n fn main() -> char {\n-//~^ ERROR: the trait bound `char: std::Termination` is not satisfied\n+//~^ ERROR: the trait bound `char: std::process::Termination` is not satisfied\n     ' '\n }"}, {"sha": "e87e0ceebf1b1a1263bcca8da59dba65d40919a7", "filename": "src/test/compile-fail/rfc-1937-termination-trait/termination-trait-not-satisfied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -12,6 +12,6 @@\n \n struct ReturnType {}\n \n-fn main() -> ReturnType { //~ ERROR `ReturnType: std::Termination` is not satisfied\n+fn main() -> ReturnType { //~ ERROR `ReturnType: std::process::Termination` is not satisfied\n     ReturnType {}\n }"}, {"sha": "c1dd44a91765e917f64f44dcea4cce6283717879", "filename": "src/test/run-fail/rfc-1937-termination-trait/termination-trait-for-never.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,8 +10,8 @@\n \n #![feature(termination_trait)]\n \n-use std::io::Error;\n+// error-pattern:oh, dear\n \n-fn main() -> Result<(), Box<Error>> {\n-    Ok(())\n+fn main() -> ! {\n+    panic!(\"oh, dear\");\n }", "previous_filename": "src/test/run-pass/termination-trait-for-result-box-error_ok.rs"}, {"sha": "2d5dfb045dbac32ca8e2dec32432135b514dc5c9", "filename": "src/test/run-pass/impl-trait/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Flifetimes.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(conservative_impl_trait, underscore_lifetimes, universal_impl_trait, nested_impl_trait)]\n+#![feature(conservative_impl_trait, underscore_lifetimes, universal_impl_trait)]\n #![allow(warnings)]\n \n use std::fmt::Debug;\n@@ -63,12 +63,11 @@ fn pass_through_elision_with_fn_ptr(x: &fn(&u32) -> &u32) -> impl Into<&fn(&u32)\n \n fn pass_through_elision_with_fn_path<T: Fn(&u32) -> &u32>(\n     x: &T\n-) -> impl Into<&impl Fn(&u32) -> &u32> { x }\n+) -> &impl Fn(&u32) -> &u32 { x }\n \n-fn foo(x: &impl Debug) -> impl Into<&impl Debug> { x }\n-fn foo_explicit_lifetime<'a>(x: &'a impl Debug) -> impl Into<&'a impl Debug> { x }\n-fn foo_no_outer_impl(x: &impl Debug) -> &impl Debug { x }\n-fn foo_explicit_arg<T: Debug>(x: &T) -> impl Into<&impl Debug> { x }\n+fn foo(x: &impl Debug) -> &impl Debug { x }\n+fn foo_explicit_lifetime<'a>(x: &'a impl Debug) -> &'a impl Debug { x }\n+fn foo_explicit_arg<T: Debug>(x: &T) -> &impl Debug { x }\n \n fn mixed_lifetimes<'a>() -> impl for<'b: 'a> Fn(&'b u32) { |_| () }\n fn mixed_as_static() -> impl Fn(&'static u32) { mixed_lifetimes() }"}, {"sha": "494500d522abe23fba10be78e3e3d7587e0893f7", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-in-test.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+\n+#![feature(termination_trait)]\n+#![feature(test)]\n+\n+extern crate test;\n+use std::num::ParseIntError;\n+use test::Bencher;\n+\n+#[test]\n+fn is_a_num() -> Result<(), ParseIntError> {\n+    let _: u32 = \"22\".parse()?;\n+    Ok(())\n+}\n+\n+#[test]\n+#[should_panic]\n+fn not_a_num() -> Result<(), ParseIntError> {\n+    let _: u32 = \"abc\".parse()?;\n+    Ok(())\n+}\n+\n+#[bench]\n+fn test_a_positive_bench(_: &mut Bencher) -> Result<(), ParseIntError> {\n+    Ok(())\n+}\n+\n+#[bench]\n+#[should_panic]\n+fn test_a_neg_bench(_: &mut Bencher) -> Result<(), ParseIntError> {\n+    let _: u32 = \"abc\".parse()?;\n+    Ok(())\n+}"}, {"sha": "796f652d6b57ba05aebf395e102307cbb8536842", "filename": "src/test/run-pass/rfc-2126-extern-absolute-paths/test.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2126-extern-absolute-paths%2Ftest.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that `#[test]` works with extern-absolute-paths enabled.\n+//\n+// Regression test for #47075.\n+\n+// compile-flags: --test\n+\n+#![feature(extern_absolute_paths)]\n+\n+#[test]\n+fn test() {\n+}"}, {"sha": "447505e886f81ef07a4684d351d78167fa6f9686", "filename": "src/test/ui/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -18,7 +18,7 @@ trait B: C {\n }\n \n trait C: B { }\n-    //~^ ERROR unsupported cyclic reference\n+    //~^ ERROR cyclic dependency detected\n     //~| cyclic reference\n \n fn main() { }"}, {"sha": "a01565546462d3463b106d8246ad4a97d3123fb3", "filename": "src/test/ui/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait-supertrait-indirect.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: unsupported cyclic reference between types/traits detected\n+error[E0391]: cyclic dependency detected\n   --> $DIR/cycle-trait-supertrait-indirect.rs:20:1\n    |\n 20 | trait C: B { }"}, {"sha": "31b3acd86ef555b25070599d051d8a46ab388eb0", "filename": "src/test/ui/error-codes/E0657.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Ferror-codes%2FE0657.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Ferror-codes%2FE0657.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0657.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![allow(warnings)]\n-#![feature(conservative_impl_trait, nested_impl_trait)]\n+#![feature(conservative_impl_trait)]\n \n trait Id<T> {}\n trait Lt<'a> {}\n@@ -17,7 +17,7 @@ impl<'a> Lt<'a> for () {}\n impl<T> Id<T> for T {}\n \n fn free_fn_capture_hrtb_in_impl_trait()\n-    -> impl for<'a> Id<impl Lt<'a>>\n+    -> Box<for<'a> Id<impl Lt<'a>>>\n         //~^ ERROR `impl Trait` can only capture lifetimes bound at the fn or impl level [E0657]\n {\n     ()\n@@ -26,7 +26,7 @@ fn free_fn_capture_hrtb_in_impl_trait()\n struct Foo;\n impl Foo {\n     fn impl_fn_capture_hrtb_in_impl_trait()\n-        -> impl for<'a> Id<impl Lt<'a>>\n+        -> Box<for<'a> Id<impl Lt<'a>>>\n             //~^ ERROR `impl Trait` can only capture lifetimes bound at the fn or impl level\n     {\n         ()"}, {"sha": "e039d645fa6dbab51778fb1f2660c22ee0ad9aae", "filename": "src/test/ui/error-codes/E0657.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Ferror-codes%2FE0657.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Ferror-codes%2FE0657.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0657.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,14 +1,14 @@\n error[E0657]: `impl Trait` can only capture lifetimes bound at the fn or impl level\n-  --> $DIR/E0657.rs:20:32\n+  --> $DIR/E0657.rs:20:31\n    |\n-20 |     -> impl for<'a> Id<impl Lt<'a>>\n-   |                                ^^\n+20 |     -> Box<for<'a> Id<impl Lt<'a>>>\n+   |                               ^^\n \n error[E0657]: `impl Trait` can only capture lifetimes bound at the fn or impl level\n-  --> $DIR/E0657.rs:29:36\n+  --> $DIR/E0657.rs:29:35\n    |\n-29 |         -> impl for<'a> Id<impl Lt<'a>>\n-   |                                    ^^\n+29 |         -> Box<for<'a> Id<impl Lt<'a>>>\n+   |                                   ^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5a6aac43ec770d26655b1c7e411f2ebf33cc433f", "filename": "src/test/ui/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -42,7 +42,7 @@ fn after() -> impl Fn(i32) {\n // independently resolved and only require the concrete\n // return type, which can't depend on the obligation.\n fn cycle1() -> impl Clone {\n-    //~^ ERROR unsupported cyclic reference between types/traits detected\n+    //~^ ERROR cyclic dependency detected\n     //~| cyclic reference\n     send(cycle2().clone());\n "}, {"sha": "d6e31ba1e1f9c67ee0a99b75625209250fda65bd", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -28,7 +28,7 @@ note: required by `send`\n 24 | fn send<T: Send>(_: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: unsupported cyclic reference between types/traits detected\n+error[E0391]: cyclic dependency detected\n   --> $DIR/auto-trait-leak.rs:44:1\n    |\n 44 | fn cycle1() -> impl Clone {"}, {"sha": "f69a78b1450f14eef07f5862c75f66a5480556ab", "filename": "src/test/ui/impl_trait_projections.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl_trait_projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl_trait_projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl_trait_projections.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(dyn_trait, conservative_impl_trait, universal_impl_trait)]\n+\n+use std::fmt::Debug;\n+use std::option;\n+\n+fn parametrized_type_is_allowed() -> Option<impl Debug> {\n+    Some(5i32)\n+}\n+\n+fn path_parametrized_type_is_allowed() -> option::Option<impl Debug> {\n+    Some(5i32)\n+}\n+\n+fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n+//~^ ERROR `impl Trait` is not allowed in path parameters\n+//~^^ ERROR ambiguous associated type\n+    x.next().unwrap()\n+}\n+\n+fn projection_with_named_trait_is_disallowed(x: impl Iterator)\n+    -> <impl Iterator as Iterator>::Item\n+//~^ ERROR `impl Trait` is not allowed in path parameters\n+{\n+    x.next().unwrap()\n+}\n+\n+fn projection_with_named_trait_inside_path_is_disallowed()\n+    -> <::std::ops::Range<impl Debug> as Iterator>::Item\n+//~^ ERROR `impl Trait` is not allowed in path parameters\n+{\n+    (1i32..100).next().unwrap()\n+}\n+\n+fn projection_from_impl_trait_inside_dyn_trait_is_disallowed()\n+    -> <dyn Iterator<Item = impl Debug> as Iterator>::Item\n+//~^ ERROR `impl Trait` is not allowed in path parameters\n+{\n+    panic!()\n+}\n+\n+fn main() {}"}, {"sha": "08de0eb99a307c5dca10f7327d6b76c89f17b4cc", "filename": "src/test/ui/impl_trait_projections.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl_trait_projections.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fimpl_trait_projections.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl_trait_projections.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,34 @@\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:23:51\n+   |\n+23 | fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n+   |                                                   ^^^^^^^^^^^^^\n+\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:30:9\n+   |\n+30 |     -> <impl Iterator as Iterator>::Item\n+   |         ^^^^^^^^^^^^^\n+\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:37:27\n+   |\n+37 |     -> <::std::ops::Range<impl Debug> as Iterator>::Item\n+   |                           ^^^^^^^^^^\n+\n+error[E0667]: `impl Trait` is not allowed in path parameters\n+  --> $DIR/impl_trait_projections.rs:44:29\n+   |\n+44 |     -> <dyn Iterator<Item = impl Debug> as Iterator>::Item\n+   |                             ^^^^^^^^^^\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/impl_trait_projections.rs:23:50\n+   |\n+23 | fn projection_is_disallowed(x: impl Iterator) -> <impl Iterator>::Item {\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^^ ambiguous associated type\n+   |\n+   = note: specify the type using the syntax `<impl std::iter::Iterator as Trait>::Item`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "e4d6076868717f0678b6b31924327cae4b2a0e50", "filename": "src/test/ui/issue-12511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-12511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-12511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12511.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -12,7 +12,7 @@ trait t1 : t2 {\n }\n \n trait t2 : t1 {\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n+//~^ ERROR cyclic dependency detected\n //~| cyclic reference\n }\n "}, {"sha": "aec828a90d1a7c6958ef561656aaa24d7e225eb2", "filename": "src/test/ui/issue-12511.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12511.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: unsupported cyclic reference between types/traits detected\n+error[E0391]: cyclic dependency detected\n   --> $DIR/issue-12511.rs:14:1\n    |\n 14 | trait t2 : t1 {"}, {"sha": "10a538301162c688ce60c4041838606db2848d69", "filename": "src/test/ui/issue-23302-1.rs", "status": "renamed", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -11,18 +11,7 @@\n // Check that an enum with recursion in the discriminant throws\n // the appropriate error (rather than, say, blowing the stack).\n enum X {\n-    A = X::A as isize, //~ ERROR E0265\n+    A = X::A as isize, //~ ERROR E0391\n }\n \n-// Since `Y::B` here defaults to `Y::A+1`, this is also a\n-// recursive definition.\n-enum Y {\n-    A = Y::B as isize, //~ ERROR E0265\n-    B,\n-}\n-\n-const A: i32 = B; //~ ERROR E0265\n-\n-const B: i32 = A; //~ ERROR E0265\n-\n fn main() { }", "previous_filename": "src/test/ui/issue-23302.rs"}, {"sha": "0658c07fb1dbe2e06947626d63a73ff4f8a49ed0", "filename": "src/test/ui/issue-23302-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-1.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,15 @@\n+error[E0391]: cyclic dependency detected\n+  --> $DIR/issue-23302-1.rs:14:9\n+   |\n+14 |     A = X::A as isize, //~ ERROR E0391\n+   |         ^^^^^^^^^^^^^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `X::A::{{initializer}}`...\n+  --> $DIR/issue-23302-1.rs:14:5\n+   |\n+14 |     A = X::A as isize, //~ ERROR E0391\n+   |     ^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires const-evaluating `X::A::{{initializer}}`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "d1af19eb579f524b6f42f2d98050ce5dcb718f47", "filename": "src/test/ui/issue-23302-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Since `Y::B` here defaults to `Y::A+1`, this is also a\n+// recursive definition.\n+enum Y {\n+    A = Y::B as isize, //~ ERROR E0391\n+    B,\n+}\n+\n+fn main() { }"}, {"sha": "c4a1c4f80c82c4f52ec7d51a6e23556e1b56f5e4", "filename": "src/test/ui/issue-23302-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-2.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,15 @@\n+error[E0391]: cyclic dependency detected\n+  --> $DIR/issue-23302-2.rs:14:9\n+   |\n+14 |     A = Y::B as isize, //~ ERROR E0391\n+   |         ^^^^^^^^^^^^^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `Y::A::{{initializer}}`...\n+  --> $DIR/issue-23302-2.rs:14:5\n+   |\n+14 |     A = Y::B as isize, //~ ERROR E0391\n+   |     ^^^^^^^^^^^^^^^^^\n+   = note: ...which then again requires const-evaluating `Y::A::{{initializer}}`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d750b09025b993b5d62bad43164b2129273ae4a", "filename": "src/test/ui/issue-23302-3.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const a: isize = b; //~ ERROR recursive constant\n-const b: isize = a; //~ ERROR recursive constant\n+const A: i32 = B; //~ ERROR E0391\n \n-fn main() {\n-}\n+const B: i32 = A;\n+\n+fn main() { }", "previous_filename": "src/test/compile-fail/const-recursive.rs"}, {"sha": "76f543cff791390c28365338f70c39c87520da86", "filename": "src/test/ui/issue-23302-3.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-23302-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302-3.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,20 @@\n+error[E0391]: cyclic dependency detected\n+  --> $DIR/issue-23302-3.rs:11:16\n+   |\n+11 | const A: i32 = B; //~ ERROR E0391\n+   |                ^ cyclic reference\n+   |\n+note: the cycle begins when processing `B`...\n+  --> $DIR/issue-23302-3.rs:13:1\n+   |\n+13 | const B: i32 = A;\n+   | ^^^^^^^^^^^^^^^^^\n+note: ...which then requires processing `A`...\n+  --> $DIR/issue-23302-3.rs:13:16\n+   |\n+13 | const B: i32 = A;\n+   |                ^\n+   = note: ...which then again requires processing `B`, completing the cycle.\n+\n+error: aborting due to previous error\n+"}, {"sha": "4e93809fac3741cc925a8d46c914a0f095aaca65", "filename": "src/test/ui/issue-23302.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fissue-23302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6070d3e47e5e9f15575a3bd33583358b52bc6eda/src%2Ftest%2Fui%2Fissue-23302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23302.stderr?ref=6070d3e47e5e9f15575a3bd33583358b52bc6eda", "patch": "@@ -1,26 +0,0 @@\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:14:9\n-   |\n-14 |     A = X::A as isize, //~ ERROR E0265\n-   |         ^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:20:9\n-   |\n-20 |     A = Y::B as isize, //~ ERROR E0265\n-   |         ^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:24:1\n-   |\n-24 | const A: i32 = B; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-23302.rs:26:1\n-   |\n-26 | const B: i32 = A; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "4c74d9d9173d8c3e5906f7c4f2f082768928e052", "filename": "src/test/ui/issue-36163.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-36163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-36163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: i32 = Foo::B; //~ ERROR E0265\n+const A: isize = Foo::B as isize;\n \n enum Foo {\n-    B = A, //~ ERROR E0265\n+    B = A, //~ ERROR E0391\n }\n \n-enum Bar {\n-    C = Bar::C, //~ ERROR E0265\n-}\n-\n-const D: i32 = A;\n-\n fn main() {}"}, {"sha": "d0337fc32b03e1a2a64b41d9b8e690bd078fad50", "filename": "src/test/ui/issue-36163.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-36163.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-36163.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36163.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,20 +1,20 @@\n-error[E0265]: recursive constant\n-  --> $DIR/issue-36163.rs:11:1\n-   |\n-11 | const A: i32 = Foo::B; //~ ERROR E0265\n-   | ^^^^^^^^^^^^^^^^^^^^^^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n+error[E0391]: cyclic dependency detected\n   --> $DIR/issue-36163.rs:14:9\n    |\n-14 |     B = A, //~ ERROR E0265\n-   |         ^ recursion not allowed in constant\n-\n-error[E0265]: recursive constant\n-  --> $DIR/issue-36163.rs:18:9\n+14 |     B = A, //~ ERROR E0391\n+   |         ^ cyclic reference\n+   |\n+note: the cycle begins when const-evaluating `Foo::B::{{initializer}}`...\n+  --> $DIR/issue-36163.rs:14:5\n+   |\n+14 |     B = A, //~ ERROR E0391\n+   |     ^^^^^\n+note: ...which then requires const-evaluating `A`...\n+  --> $DIR/issue-36163.rs:14:9\n    |\n-18 |     C = Bar::C, //~ ERROR E0265\n-   |         ^^^^^^ recursion not allowed in constant\n+14 |     B = A, //~ ERROR E0391\n+   |         ^\n+   = note: ...which then again requires const-evaluating `Foo::B::{{initializer}}`, completing the cycle.\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}, {"sha": "9c521dd6479636a8cf0ae29352d4e6a685040060", "filename": "src/test/ui/issue-47706.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-47706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-47706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -22,3 +22,18 @@ impl Foo {\n     }\n     //~^^ ERROR function is expected to take 1 argument, but it takes 2 arguments [E0593]\n }\n+\n+enum Qux {\n+    Bar(i32),\n+}\n+\n+fn foo<F>(f: F)\n+where\n+    F: Fn(),\n+{\n+}\n+\n+fn main() {\n+    foo(Qux::Bar);\n+}\n+//~^^ ERROR function is expected to take 0 arguments, but it takes 1 argument [E0593]"}, {"sha": "e197c09062d1c904048ffebc9bc530c23eea78f2", "filename": "src/test/ui/issue-47706.stderr", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-47706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fissue-47706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47706.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,5 +1,3 @@\n-error[E0601]: main function not found\n-\n error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n   --> $DIR/issue-47706.rs:21:18\n    |\n@@ -9,5 +7,24 @@ error[E0593]: function is expected to take 1 argument, but it takes 2 arguments\n 21 |         self.foo.map(Foo::new)\n    |                  ^^^ expected function that takes 1 argument\n \n+error[E0593]: function is expected to take 0 arguments, but it takes 1 argument\n+  --> $DIR/issue-47706.rs:37:5\n+   |\n+27 |     Bar(i32),\n+   |     -------- takes 1 argument\n+...\n+37 |     foo(Qux::Bar);\n+   |     ^^^ expected function that takes 0 arguments\n+   |\n+note: required by `foo`\n+  --> $DIR/issue-47706.rs:30:1\n+   |\n+30 | / fn foo<F>(f: F)\n+31 | | where\n+32 | |     F: Fn(),\n+33 | | {\n+34 | | }\n+   | |_^\n+\n error: aborting due to 2 previous errors\n "}, {"sha": "f6302c0f3b3e2f0e1b43fe00db886ae30a2e2bac", "filename": "src/test/ui/nested_impl_trait.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnested_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnested_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnested_impl_trait.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -14,25 +14,27 @@ use std::fmt::Debug;\n fn fine(x: impl Into<u32>) -> impl Into<u32> { x }\n \n fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n-//~^ ERROR nested `impl Trait` is experimental\n+//~^ ERROR nested `impl Trait` is not allowed\n \n fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n-//~^ ERROR nested `impl Trait` is experimental\n+//~^ ERROR nested `impl Trait` is not allowed\n+//~^^ `impl Trait` not allowed\n \n fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n-//~^ ERROR nested `impl Trait` is experimental\n+//~^ ERROR nested `impl Trait` is not allowed\n \n struct X;\n impl X {\n     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n-    //~^ ERROR nested `impl Trait` is experimental\n+    //~^ ERROR nested `impl Trait` is not allowed\n }\n \n fn allowed_in_assoc_type() -> impl Iterator<Item=impl Fn()> {\n     vec![|| println!(\"woot\")].into_iter()\n }\n \n fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n+//~^ `impl Trait` not allowed\n     || 5\n }\n ", "previous_filename": "src/test/compile-fail/feature-gate-nested_impl_trait.rs"}, {"sha": "094926120cdeee0c447961d963e079b797f56bfe", "filename": "src/test/ui/nested_impl_trait.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnested_impl_trait.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,50 @@\n+error[E0666]: nested `impl Trait` is not allowed\n+  --> $DIR/nested_impl_trait.rs:16:56\n+   |\n+16 | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                              ----------^^^^^^^^^^-\n+   |                                              |         |\n+   |                                              |         nested `impl Trait` here\n+   |                                              outer `impl Trait`\n+\n+error[E0666]: nested `impl Trait` is not allowed\n+  --> $DIR/nested_impl_trait.rs:19:42\n+   |\n+19 | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n+   |                                ----------^^^^^^^^^^-\n+   |                                |         |\n+   |                                |         nested `impl Trait` here\n+   |                                outer `impl Trait`\n+\n+error[E0666]: nested `impl Trait` is not allowed\n+  --> $DIR/nested_impl_trait.rs:23:37\n+   |\n+23 | fn bad_in_arg_position(_: impl Into<impl Debug>) { }\n+   |                           ----------^^^^^^^^^^-\n+   |                           |         |\n+   |                           |         nested `impl Trait` here\n+   |                           outer `impl Trait`\n+\n+error[E0666]: nested `impl Trait` is not allowed\n+  --> $DIR/nested_impl_trait.rs:28:44\n+   |\n+28 |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n+   |                                  ----------^^^^^^^^^^-\n+   |                                  |         |\n+   |                                  |         nested `impl Trait` here\n+   |                                  outer `impl Trait`\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/nested_impl_trait.rs:19:32\n+   |\n+19 | fn bad_in_fn_syntax(x: fn() -> impl Into<impl Debug>) {}\n+   |                                ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/nested_impl_trait.rs:36:42\n+   |\n+36 | fn allowed_in_ret_type() -> impl Fn() -> impl Into<u32> {\n+   |                                          ^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "30669dc4c2f8c1e9e5b2b772d5974e7d6cf7741c", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -25,53 +25,6 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where <T as std::iter::Iterator>::Item: '_#2r\n \n-note: External requirements\n-  --> $DIR/projection-no-regions-closure.rs:46:23\n-   |\n-46 |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:18 ~ projection_no_regions_closure[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n-           ]\n-   = note: number of external vids: 3\n-   = note: where <T as std::iter::Iterator>::Item: '_#2r\n-\n-note: External requirements\n-  --> $DIR/projection-no-regions-closure.rs:54:23\n-   |\n-54 |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:22 ~ projection_no_regions_closure[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n-           ]\n-   = note: number of external vids: 4\n-   = note: where <T as std::iter::Iterator>::Item: '_#3r\n-\n-note: External requirements\n-  --> $DIR/projection-no-regions-closure.rs:65:23\n-   |\n-65 |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:26 ~ projection_no_regions_closure[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n-           ]\n-   = note: number of external vids: 4\n-   = note: where <T as std::iter::Iterator>::Item: '_#3r\n-\n error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-closure.rs:36:23\n    |\n@@ -97,6 +50,21 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:46:23\n+   |\n+46 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:18 ~ projection_no_regions_closure[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#2r>\n+           ]\n+   = note: number of external vids: 3\n+   = note: where <T as std::iter::Iterator>::Item: '_#2r\n+\n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:42:1\n    |\n@@ -113,6 +81,22 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:54:23\n+   |\n+54 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:22 ~ projection_no_regions_closure[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n   --> $DIR/projection-no-regions-closure.rs:54:23\n    |\n@@ -139,6 +123,22 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-no-regions-closure.rs:65:23\n+   |\n+65 |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:26 ~ projection_no_regions_closure[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::boxed::Box<T>,)) -> std::boxed::Box<Anything + '_#3r>\n+           ]\n+   = note: number of external vids: 4\n+   = note: where <T as std::iter::Iterator>::Item: '_#3r\n+\n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:60:1\n    |"}, {"sha": "946c1a8f3723503517e078a9c5a806f65a3663d3", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -32,57 +32,6 @@ note: External requirements\n    = note: where T: '_#2r\n    = note: where '_#1r: '_#2r\n \n-note: External requirements\n-  --> $DIR/projection-one-region-closure.rs:68:29\n-   |\n-68 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:23 ~ projection_one_region_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where T: '_#3r\n-   = note: where '_#2r: '_#3r\n-\n-note: External requirements\n-  --> $DIR/projection-one-region-closure.rs:90:29\n-   |\n-90 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:27 ~ projection_one_region_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where T: '_#3r\n-   = note: where '_#2r: '_#3r\n-\n-note: External requirements\n-   --> $DIR/projection-one-region-closure.rs:103:29\n-    |\n-103 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:31 ~ projection_one_region_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                '_#2r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-            ]\n-    = note: number of external vids: 4\n-    = note: where T: '_#3r\n-    = note: where '_#2r: '_#3r\n-\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:56:29\n    |\n@@ -114,6 +63,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:68:29\n+   |\n+68 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:68:29\n    |\n@@ -146,6 +112,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-one-region-closure.rs:90:29\n+   |\n+90 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+   = note: where '_#2r: '_#3r\n+\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/projection-one-region-closure.rs:90:29\n    |\n@@ -178,6 +161,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+   --> $DIR/projection-one-region-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:31 ~ projection_one_region_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where T: '_#3r\n+    = note: where '_#2r: '_#3r\n+\n note: No external requirements\n    --> $DIR/projection-one-region-closure.rs:97:1\n     |"}, {"sha": "b26fa96fe638902dc74c7533e07b27966026ae2b", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -31,69 +31,6 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n-note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:59:29\n-   |\n-59 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where '_#2r: '_#3r\n-\n-note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:80:29\n-   |\n-80 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where '_#2r: '_#3r\n-\n-note: External requirements\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:91:29\n-   |\n-91 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where '_#2r: '_#3r\n-\n-note: External requirements\n-   --> $DIR/projection-one-region-trait-bound-closure.rs:103:29\n-    |\n-103 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-            ]\n-    = note: number of external vids: 3\n-    = note: where '_#1r: '_#2r\n-\n error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:8 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`\n   --> $DIR/projection-one-region-trait-bound-closure.rs:48:20\n    |\n@@ -117,6 +54,22 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:59:29\n+   |\n+59 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n   --> $DIR/projection-one-region-trait-bound-closure.rs:59:20\n    |\n@@ -141,6 +94,22 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:80:29\n+   |\n+80 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n error: free region `ReEarlyBound(1, 'b)` does not outlive free region `ReEarlyBound(0, 'a)`\n   --> $DIR/projection-one-region-trait-bound-closure.rs:80:20\n    |\n@@ -165,6 +134,22 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:91:29\n+   |\n+91 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where '_#2r: '_#3r\n+\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:86:1\n    |\n@@ -183,6 +168,21 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+   --> $DIR/projection-one-region-trait-bound-closure.rs:103:29\n+    |\n+103 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where '_#1r: '_#2r\n+\n note: No external requirements\n    --> $DIR/projection-one-region-trait-bound-closure.rs:95:1\n     |"}, {"sha": "98b033b6a06725b134c06eed63d3417d3340c4d3", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-static-closure.stderr", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-static-closure.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -12,76 +12,35 @@ note: No external requirements\n            ]\n \n note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-static-closure.rs:56:29\n-   |\n-56 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-\n-note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-static-closure.rs:75:29\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:43:1\n    |\n-75 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+43 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n+44 | | where\n+45 | |     T: Anything<'b>,\n+46 | | {\n+47 | |     with_signature(cell, t, |cell, t| require(cell, t));\n+48 | | }\n+   | |_^\n    |\n-   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]) with substs [\n                '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+               T\n            ]\n \n note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-static-closure.rs:84:29\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:56:29\n    |\n-84 |     with_signature(cell, t, |cell, t| require(cell, t));\n+56 |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+   = note: defining type: DefId(0/1:23 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n                '_#1r,\n                '_#2r,\n                T,\n                i32,\n                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n            ]\n \n-note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-static-closure.rs:96:29\n-   |\n-96 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-           ]\n-\n-note: No external requirements\n-  --> $DIR/projection-one-region-trait-bound-static-closure.rs:43:1\n-   |\n-43 | / fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n-44 | | where\n-45 | |     T: Anything<'b>,\n-46 | | {\n-47 | |     with_signature(cell, t, |cell, t| require(cell, t));\n-48 | | }\n-   | |_^\n-   |\n-   = note: defining type: DefId(0/0:8 ~ projection_one_region_trait_bound_static_closure[317d]::no_relationships_late[0]) with substs [\n-               '_#1r,\n-               T\n-           ]\n-\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-static-closure.rs:51:1\n    |\n@@ -100,6 +59,20 @@ note: No external requirements\n                T\n            ]\n \n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:75:29\n+   |\n+75 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_one_region_trait_bound_static_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-static-closure.rs:60:1\n    |\n@@ -118,6 +91,20 @@ note: No external requirements\n                T\n            ]\n \n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:84:29\n+   |\n+84 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:31 ~ projection_one_region_trait_bound_static_closure[317d]::elements_outlive[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-static-closure.rs:79:1\n    |\n@@ -136,6 +123,19 @@ note: No external requirements\n                T\n            ]\n \n+note: No external requirements\n+  --> $DIR/projection-one-region-trait-bound-static-closure.rs:96:29\n+   |\n+96 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:34 ~ projection_one_region_trait_bound_static_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-static-closure.rs:88:1\n    |"}, {"sha": "78775ce94adddfd6dd806f794bc7ed927a91a9c7", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -38,120 +38,6 @@ note: External requirements\n    = note: number of external vids: 4\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n \n-note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n-   |\n-60 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:27 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               '_#3r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n-           ]\n-   = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n-\n-note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n-   |\n-81 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:32 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               '_#3r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n-           ]\n-   = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n-\n-note: External requirements\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:92:29\n-   |\n-92 |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:37 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               '_#3r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n-           ]\n-   = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n-\n-note: External requirements\n-   --> $DIR/projection-two-region-trait-bound-closure.rs:101:29\n-    |\n-101 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:42 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                '_#2r,\n-                '_#3r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n-            ]\n-    = note: number of external vids: 5\n-    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n-\n-note: External requirements\n-   --> $DIR/projection-two-region-trait-bound-closure.rs:109:29\n-    |\n-109 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:46 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-            ]\n-    = note: number of external vids: 3\n-    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n-\n-note: External requirements\n-   --> $DIR/projection-two-region-trait-bound-closure.rs:120:29\n-    |\n-120 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:50 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                '_#2r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-            ]\n-    = note: number of external vids: 4\n-    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n-\n-note: External requirements\n-   --> $DIR/projection-two-region-trait-bound-closure.rs:132:29\n-    |\n-132 |     with_signature(cell, t, |cell, t| require(cell, t));\n-    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-    |\n-    = note: defining type: DefId(0/1:53 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n-                '_#1r,\n-                T,\n-                i32,\n-                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-            ]\n-    = note: number of external vids: 3\n-    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n-\n error[E0309]: the associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:49:29\n    |\n@@ -178,6 +64,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n+   |\n+60 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_early[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:60:29\n    |\n@@ -205,6 +108,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n+   |\n+81 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:32 ~ projection_two_region_trait_bound_closure[317d]::projection_outlives[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:81:29\n    |\n@@ -232,6 +152,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:92:29\n+   |\n+92 |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:37 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive1[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               '_#3r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+           ]\n+   = note: number of external vids: 5\n+   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:87:1\n    |\n@@ -251,6 +188,23 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:101:29\n+    |\n+101 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:42 ~ projection_two_region_trait_bound_closure[317d]::elements_outlive2[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                '_#3r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#4r ()>, T))\n+            ]\n+    = note: number of external vids: 5\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+\n note: No external requirements\n    --> $DIR/projection-two-region-trait-bound-closure.rs:96:1\n     |\n@@ -270,6 +224,21 @@ note: No external requirements\n                 T\n             ]\n \n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:109:29\n+    |\n+109 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:46 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n error: free region `ReEarlyBound(0, 'b)` does not outlive free region `ReFree(DefId(0/0:13 ~ projection_two_region_trait_bound_closure[317d]::two_regions[0]), BrNamed(crate0:DefIndex(1:43), 'a))`\n    --> $DIR/projection-two-region-trait-bound-closure.rs:109:20\n     |\n@@ -293,6 +262,22 @@ note: No external requirements\n                 T\n             ]\n \n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:120:29\n+    |\n+120 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:50 ~ projection_two_region_trait_bound_closure[317d]::two_regions_outlive[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                '_#2r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+            ]\n+    = note: number of external vids: 4\n+    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+\n note: No external requirements\n    --> $DIR/projection-two-region-trait-bound-closure.rs:115:1\n     |\n@@ -311,6 +296,21 @@ note: No external requirements\n                 T\n             ]\n \n+note: External requirements\n+   --> $DIR/projection-two-region-trait-bound-closure.rs:132:29\n+    |\n+132 |     with_signature(cell, t, |cell, t| require(cell, t));\n+    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: defining type: DefId(0/1:53 ~ projection_two_region_trait_bound_closure[317d]::one_region[0]::{{closure}}[0]) with closure substs [\n+                '_#1r,\n+                T,\n+                i32,\n+                extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+            ]\n+    = note: number of external vids: 3\n+    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+\n note: No external requirements\n    --> $DIR/projection-two-region-trait-bound-closure.rs:124:1\n     |"}, {"sha": "f68a76c3d0de5790d2411abbbf6980efd52c0ccf", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -30,20 +30,6 @@ note: External requirements\n    = note: number of external vids: 2\n    = note: where T: '_#1r\n \n-note: External requirements\n-  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:24\n-   |\n-43 |     twice(cell, value, |a, b| invoke(a, b));\n-   |                        ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: defining type: DefId(0/1:17 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]::{{closure}}[0]) with closure substs [\n-               T,\n-               i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) ()>>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) T))\n-           ]\n-   = note: number of external vids: 2\n-   = note: where T: '_#1r\n-\n note: No external requirements\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:33:1\n    |\n@@ -60,6 +46,20 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:24\n+   |\n+43 |     twice(cell, value, |a, b| invoke(a, b));\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: DefId(0/1:17 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]::{{closure}}[0]) with closure substs [\n+               T,\n+               i16,\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 'r)) ()>>, &ReLateBound(DebruijnIndex { depth: 1 }, BrNamed(crate0:DefIndex(0:0), 's)) T))\n+           ]\n+   = note: number of external vids: 2\n+   = note: where T: '_#1r\n+\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:43:24\n    |"}, {"sha": "ed4d4b1e68f7f81070f9314a0b8155d13300df55", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -31,69 +31,6 @@ note: External requirements\n    = note: number of external vids: 2\n    = note: where T: '_#1r\n \n-note: External requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:55:26\n-   |\n-55 |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-56 | |         // Key point of this test:\n-57 | |         //\n-58 | |         // The *closure* is being type-checked with all of its free\n-...  |\n-67 | |         require(&x, &y)\n-68 | |     })\n-   | |_____^\n-   |\n-   = note: defining type: DefId(0/1:19 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-           ]\n-   = note: number of external vids: 3\n-   = note: where T: '_#2r\n-\n-note: External requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n-   |\n-76 |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-77 | |         //~^ ERROR the parameter type `T` may not live long enough\n-78 | |         // See `correct_region`\n-79 | |         require(&x, &y)\n-80 | |         //~^ WARNING not reporting region error due to -Znll\n-81 | |     })\n-   | |_____^\n-   |\n-   = note: defining type: DefId(0/1:23 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n-           ]\n-   = note: number of external vids: 3\n-   = note: where T: '_#2r\n-\n-note: External requirements\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:90:26\n-   |\n-90 |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-91 | |         // See `correct_region`\n-92 | |         require(&x, &y)\n-93 | |     })\n-   | |_____^\n-   |\n-   = note: defining type: DefId(0/1:27 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n-               '_#1r,\n-               '_#2r,\n-               T,\n-               i32,\n-               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n-           ]\n-   = note: number of external vids: 4\n-   = note: where T: '_#3r\n-\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:38:26\n    |\n@@ -125,6 +62,28 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:55:26\n+   |\n+55 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+56 | |         // Key point of this test:\n+57 | |         //\n+58 | |         // The *closure* is being type-checked with all of its free\n+...  |\n+67 | |         require(&x, &y)\n+68 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:19 ~ ty_param_closure_outlives_from_where_clause[317d]::correct_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:51:1\n    |\n@@ -142,6 +101,27 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n+   |\n+76 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+77 | |         //~^ ERROR the parameter type `T` may not live long enough\n+78 | |         // See `correct_region`\n+79 | |         require(&x, &y)\n+80 | |         //~^ WARNING not reporting region error due to -Znll\n+81 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:23 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#2r ()>, T))\n+           ]\n+   = note: number of external vids: 3\n+   = note: where T: '_#2r\n+\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:76:26\n    |\n@@ -173,6 +153,26 @@ note: No external requirements\n                T\n            ]\n \n+note: External requirements\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:90:26\n+   |\n+90 |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+91 | |         // See `correct_region`\n+92 | |         require(&x, &y)\n+93 | |     })\n+   | |_____^\n+   |\n+   = note: defining type: DefId(0/1:27 ~ ty_param_closure_outlives_from_where_clause[317d]::outlives_region[0]::{{closure}}[0]) with closure substs [\n+               '_#1r,\n+               '_#2r,\n+               T,\n+               i32,\n+               extern \"rust-call\" fn((std::cell::Cell<&'_#3r ()>, T))\n+           ]\n+   = note: number of external vids: 4\n+   = note: where T: '_#3r\n+\n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:85:1\n    |"}, {"sha": "34f8a0a48431c8f36d3205dcf617ad86e36d6973", "filename": "src/test/ui/resolve/issue-23305.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -13,6 +13,6 @@ pub trait ToNbt<T> {\n }\n \n impl ToNbt<Self> {}\n-//~^ ERROR unsupported cyclic reference\n+//~^ ERROR cyclic dependency detected\n \n fn main() {}"}, {"sha": "a0b4d424ec968b409d332c6273472d2248bf24ee", "filename": "src/test/ui/resolve/issue-23305.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-23305.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: unsupported cyclic reference between types/traits detected\n+error[E0391]: cyclic dependency detected\n   --> $DIR/issue-23305.rs:15:12\n    |\n 15 | impl ToNbt<Self> {}"}, {"sha": "b6fb3ec5c44cfd5b34667228af505b9febc59d07", "filename": "src/test/ui/unsafe-block-without-braces.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Funsafe-block-without-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Funsafe-block-without-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe-block-without-braces.rs?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const A: usize = B; //~ ERROR: recursive constant\n-const B: usize = A; //~ ERROR: recursive constant\n-\n-fn main() {}\n+fn main() {\n+    unsafe //{\n+        std::mem::transmute::<f32, u32>(1.0);\n+    //}\n+}\n+//~^^^ ERROR expected one of `extern`, `fn`, or `{`, found `std`", "previous_filename": "src/test/compile-fail/issue-17718-recursive.rs"}, {"sha": "fc6ddba382395d5cc3d3337165433f910c1f4df2", "filename": "src/test/ui/unsafe-block-without-braces.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Funsafe-block-without-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/28a1e4ffefa2620ad9f4179ea339833448874fd3/src%2Ftest%2Fui%2Funsafe-block-without-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe-block-without-braces.stderr?ref=28a1e4ffefa2620ad9f4179ea339833448874fd3", "patch": "@@ -0,0 +1,10 @@\n+error: expected one of `extern`, `fn`, or `{`, found `std`\n+  --> $DIR/unsafe-block-without-braces.rs:13:9\n+   |\n+12 |     unsafe //{\n+   |           - expected one of `extern`, `fn`, or `{` here\n+13 |         std::mem::transmute::<f32, u32>(1.0);\n+   |         ^^^ unexpected token\n+\n+error: aborting due to previous error\n+"}]}