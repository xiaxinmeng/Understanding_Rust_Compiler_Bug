{"sha": "2839f4f0e8d58c295e146999961b78e2cc47354f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4MzlmNGYwZThkNThjMjk1ZTE0Njk5OTk2MWI3OGUyY2M0NzM1NGY=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-31T09:47:45Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-08-31T09:49:29Z"}, "message": "Get rid of token passing", "tree": {"sha": "732aa2aa0f2f3a924b1f8ececa88fafde762f768", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732aa2aa0f2f3a924b1f8ececa88fafde762f768"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2839f4f0e8d58c295e146999961b78e2cc47354f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2839f4f0e8d58c295e146999961b78e2cc47354f", "html_url": "https://github.com/rust-lang/rust/commit/2839f4f0e8d58c295e146999961b78e2cc47354f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2839f4f0e8d58c295e146999961b78e2cc47354f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68bb636c7f238dbf94f1cbf301eafac0d308393", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68bb636c7f238dbf94f1cbf301eafac0d308393", "html_url": "https://github.com/rust-lang/rust/commit/b68bb636c7f238dbf94f1cbf301eafac0d308393"}], "stats": {"total": 90, "additions": 35, "deletions": 55}, "files": [{"sha": "56e32ea5d1a23b3eb71ab6c147e182fb1370b856", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 35, "deletions": 55, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2839f4f0e8d58c295e146999961b78e2cc47354f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2839f4f0e8d58c295e146999961b78e2cc47354f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=2839f4f0e8d58c295e146999961b78e2cc47354f", "patch": "@@ -5,17 +5,7 @@ use rustc::ty::{self, Predicate, TyCtxt};\n use std::borrow::Cow;\n use syntax_pos::Span;\n \n-mod helper {\n-    pub struct IsMinConstFn(());\n-    /// This should only ever be used *once* and then passed around as a token.\n-    pub fn ensure_that_you_really_intended_to_create_an_instance_of_this() -> IsMinConstFn {\n-        IsMinConstFn(())\n-    }\n-}\n-\n-use self::helper::*;\n-\n-type McfResult = Result<IsMinConstFn, (Span, Cow<'static, str>)>;\n+type McfResult = Result<(), (Span, Cow<'static, str>)>;\n \n pub fn is_min_const_fn(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -74,39 +64,35 @@ pub fn is_min_const_fn(\n         }\n     }\n \n-    let mut token = ensure_that_you_really_intended_to_create_an_instance_of_this();\n-\n     for local in mir.vars_iter() {\n         return Err((\n             mir.local_decls[local].source_info.span,\n             \"local variables in const fn are unstable\".into(),\n         ));\n     }\n     for local in &mir.local_decls {\n-        token = check_ty(tcx, local.ty, local.source_info.span, token)?;\n+        check_ty(tcx, local.ty, local.source_info.span)?;\n     }\n     // impl trait is gone in MIR, so check the return type manually\n-    token = check_ty(\n+    check_ty(\n         tcx,\n         tcx.fn_sig(def_id).output().skip_binder(),\n         mir.local_decls.iter().next().unwrap().source_info.span,\n-        token,\n     )?;\n \n     for bb in mir.basic_blocks() {\n-        token = check_terminator(tcx, mir, bb.terminator(), token)?;\n+        check_terminator(tcx, mir, bb.terminator())?;\n         for stmt in &bb.statements {\n-            token = check_statement(tcx, mir, stmt, token)?;\n+            check_statement(tcx, mir, stmt)?;\n         }\n     }\n-    Ok(token)\n+    Ok(())\n }\n \n fn check_ty(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    token: IsMinConstFn,\n ) -> McfResult {\n     for ty in ty.walk() {\n         match ty.sty {\n@@ -146,22 +132,21 @@ fn check_ty(\n             _ => {}\n         }\n     }\n-    Ok(token)\n+    Ok(())\n }\n \n fn check_rvalue(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n-    token: IsMinConstFn,\n ) -> McfResult {\n     match rvalue {\n         Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n-            check_operand(tcx, mir, operand, span, token)\n+            check_operand(tcx, mir, operand, span)\n         }\n         Rvalue::Len(place) | Rvalue::Discriminant(place) | Rvalue::Ref(_, _, place) => {\n-            check_place(tcx, mir, place, span, token, PlaceMode::Read)\n+            check_place(tcx, mir, place, span, PlaceMode::Read)\n         }\n         Rvalue::Cast(_, operand, cast_ty) => {\n             use rustc::ty::cast::CastTy;\n@@ -175,16 +160,16 @@ fn check_rvalue(\n                 (CastTy::RPtr(_), CastTy::Float) => bug!(),\n                 (CastTy::RPtr(_), CastTy::Int(_)) => bug!(),\n                 (CastTy::Ptr(_), CastTy::RPtr(_)) => bug!(),\n-                _ => check_operand(tcx, mir, operand, span, token),\n+                _ => check_operand(tcx, mir, operand, span),\n             }\n         }\n         // binops are fine on integers\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n-            let token = check_operand(tcx, mir, lhs, span, token)?;\n-            let token = check_operand(tcx, mir, rhs, span, token)?;\n+            check_operand(tcx, mir, lhs, span)?;\n+            check_operand(tcx, mir, rhs, span)?;\n             let ty = lhs.ty(mir, tcx);\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n-                Ok(token)\n+                Ok(())\n             } else {\n                 Err((\n                     span,\n@@ -193,11 +178,11 @@ fn check_rvalue(\n             }\n         }\n         // checked by regular const fn checks\n-        Rvalue::NullaryOp(..) => Ok(token),\n+        Rvalue::NullaryOp(..) => Ok(()),\n         Rvalue::UnaryOp(_, operand) => {\n             let ty = operand.ty(mir, tcx);\n             if ty.is_integral() || ty.is_bool() {\n-                check_operand(tcx, mir, operand, span, token)\n+                check_operand(tcx, mir, operand, span)\n             } else {\n                 Err((\n                     span,\n@@ -206,11 +191,10 @@ fn check_rvalue(\n             }\n         }\n         Rvalue::Aggregate(_, operands) => {\n-            let mut token = token;\n             for operand in operands {\n-                token = check_operand(tcx, mir, operand, span, token)?;\n+                check_operand(tcx, mir, operand, span)?;\n             }\n-            Ok(token)\n+            Ok(())\n         }\n     }\n }\n@@ -224,19 +208,18 @@ fn check_statement(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     statement: &Statement<'tcx>,\n-    token: IsMinConstFn,\n ) -> McfResult {\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(place, rval) => {\n-            let token = check_place(tcx, mir, place, span, token, PlaceMode::Assign)?;\n-            check_rvalue(tcx, mir, rval, span, token)\n+            check_place(tcx, mir, place, span, PlaceMode::Assign)?;\n+            check_rvalue(tcx, mir, rval, span)\n         }\n \n         StatementKind::ReadForMatch(_) => Err((span, \"match in const fn is unstable\".into())),\n \n         // just an assignment\n-        StatementKind::SetDiscriminant { .. } => Ok(token),\n+        StatementKind::SetDiscriminant { .. } => Ok(()),\n \n         | StatementKind::InlineAsm { .. } => {\n             Err((span, \"cannot use inline assembly in const fn\".into()))\n@@ -248,7 +231,7 @@ fn check_statement(\n         | StatementKind::Validate(..)\n         | StatementKind::EndRegion(_)\n         | StatementKind::UserAssertTy(..)\n-        | StatementKind::Nop => Ok(token),\n+        | StatementKind::Nop => Ok(()),\n     }\n }\n \n@@ -257,13 +240,12 @@ fn check_operand(\n     mir: &'a Mir<'tcx>,\n     operand: &Operand<'tcx>,\n     span: Span,\n-    token: IsMinConstFn,\n ) -> McfResult {\n     match operand {\n         Operand::Move(place) | Operand::Copy(place) => {\n-            check_place(tcx, mir, place, span, token, PlaceMode::Read)\n+            check_place(tcx, mir, place, span, PlaceMode::Read)\n         }\n-        Operand::Constant(_) => Ok(token),\n+        Operand::Constant(_) => Ok(()),\n     }\n }\n \n@@ -272,26 +254,25 @@ fn check_place(\n     mir: &'a Mir<'tcx>,\n     place: &Place<'tcx>,\n     span: Span,\n-    token: IsMinConstFn,\n     mode: PlaceMode,\n ) -> McfResult {\n     match place {\n         Place::Local(l) => match mode {\n             PlaceMode::Assign => match mir.local_kind(*l) {\n-                LocalKind::Temp | LocalKind::ReturnPointer => Ok(token),\n+                LocalKind::Temp | LocalKind::ReturnPointer => Ok(()),\n                 LocalKind::Arg | LocalKind::Var => {\n                     Err((span, \"assignments in const fn are unstable\".into()))\n                 }\n             },\n-            PlaceMode::Read => Ok(token),\n+            PlaceMode::Read => Ok(()),\n         },\n         // promoteds are always fine, they are essentially constants\n-        Place::Promoted(_) => Ok(token),\n+        Place::Promoted(_) => Ok(()),\n         Place::Static(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n         Place::Projection(proj) => {\n             match proj.elem {\n                 | ProjectionElem::Deref | ProjectionElem::Field(..) | ProjectionElem::Index(_) => {\n-                    check_place(tcx, mir, &proj.base, span, token, mode)\n+                    check_place(tcx, mir, &proj.base, span, mode)\n                 }\n                 // slice patterns are unstable\n                 | ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. } => {\n@@ -309,20 +290,19 @@ fn check_terminator(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     terminator: &Terminator<'tcx>,\n-    token: IsMinConstFn,\n ) -> McfResult {\n     let span = terminator.source_info.span;\n     match &terminator.kind {\n         | TerminatorKind::Goto { .. }\n         | TerminatorKind::Return\n-        | TerminatorKind::Resume => Ok(token),\n+        | TerminatorKind::Resume => Ok(()),\n \n         TerminatorKind::Drop { location, .. } => {\n-            check_place(tcx, mir, location, span, token, PlaceMode::Read)\n+            check_place(tcx, mir, location, span, PlaceMode::Read)\n         }\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n-            let token = check_place(tcx, mir, location, span, token, PlaceMode::Read)?;\n-            check_operand(tcx, mir, value, span, token)\n+            check_place(tcx, mir, location, span, PlaceMode::Read)?;\n+            check_operand(tcx, mir, value, span)\n         },\n         TerminatorKind::SwitchInt { .. } => Err((\n             span,\n@@ -344,12 +324,12 @@ fn check_terminator(\n             let fn_ty = func.ty(mir, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.sty {\n                 if tcx.is_min_const_fn(def_id) {\n-                    let mut token = check_operand(tcx, mir, func, span, token)?;\n+                    check_operand(tcx, mir, func, span)?;\n \n                     for arg in args {\n-                        token = check_operand(tcx, mir, arg, span, token)?;\n+                        check_operand(tcx, mir, arg, span)?;\n                     }\n-                    Ok(token)\n+                    Ok(())\n                 } else {\n                     Err((\n                         span,\n@@ -367,7 +347,7 @@ fn check_terminator(\n             msg: _,\n             target: _,\n             cleanup: _,\n-        } => check_operand(tcx, mir, cond, span, token),\n+        } => check_operand(tcx, mir, cond, span),\n \n         | TerminatorKind::FalseEdges { .. } | TerminatorKind::FalseUnwind { .. } => span_bug!(\n             terminator.source_info.span,"}]}