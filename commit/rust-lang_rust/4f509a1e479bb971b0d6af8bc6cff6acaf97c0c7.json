{"sha": "4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNTA5YTFlNDc5YmI5NzFiMGQ2YWY4YmM2Y2ZmNmFjYWY5N2MwYzc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-09-22T23:23:00Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-09-26T00:46:03Z"}, "message": "Stabilize mutable slice API\n\nThis commit is another in the series of vector slice API\nstabilization. The focus here is the *mutable* slice API.\n\nLargely, this API inherits the stability attributes [previously\nassigned](https://github.com/rust-lang/rust/pull/16332) to the analogous\nmethods on immutable slides. It also adds comments to a few `unstable`\nattributes that were previously missing them.\n\nIn addition, the commit adds several `_mut` variants of APIs that were\nmissing:\n\n- `init_mut`\n- `head_mut`\n- `tail_mut`\n- `splitn_mut`\n- `rsplitn_mut`\n\nSome of the unsafe APIs -- `unsafe_set`, `init_elem`, and `copy_memory`\n-- were deprecated in favor of working through `as_mut_ptr`, to simplify\nthe API surface.\n\nDue to deprecations, this is a:\n\n[breaking-change]", "tree": {"sha": "6b817476a32798bff01ef121c1619bdbe93f1a2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b817476a32798bff01ef121c1619bdbe93f1a2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7", "html_url": "https://github.com/rust-lang/rust/commit/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2550243b4183783e463fbb0bc141ab77f2898e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/2550243b4183783e463fbb0bc141ab77f2898e64", "html_url": "https://github.com/rust-lang/rust/commit/2550243b4183783e463fbb0bc141ab77f2898e64"}], "stats": {"total": 505, "additions": 266, "deletions": 239}, "files": [{"sha": "c4cb4f1d64e352ca82437b045c8eba6c409eb4b5", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 266, "deletions": 239, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4f509a1e479bb971b0d6af8bc6cff6acaf97c0c7", "patch": "@@ -67,23 +67,23 @@ pub trait ImmutableSlice<'a, T> {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable]\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /// Returns a subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable]\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice_from(&self, start: uint) -> &'a [T];\n \n     /// Returns a subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable]\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice_to(&self, end: uint) -> &'a [T];\n \n     /// Divides one slice into two at an index.\n@@ -93,102 +93,102 @@ pub trait ImmutableSlice<'a, T> {\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n     /// Fails if `mid > len`.\n-    #[unstable]\n+    #[unstable = \"waiting on final error conventions\"]\n     fn split_at(&self, mid: uint) -> (&'a [T], &'a [T]);\n \n-    /// Returns an iterator over the vector\n+    /// Returns an iterator over the slice\n     #[unstable = \"iterator type may change\"]\n     fn iter(self) -> Items<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`.  The matched element\n-    /// is not contained in the subslices.\n-    #[unstable = \"iterator type may change\"]\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"iterator type may change, waiting on unboxed closures\"]\n     fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`, limited to splitting\n-    /// at most `n` times.  The matched element is not contained in\n-    /// the subslices.\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred` limited to splitting\n-    /// at most `n` times. This starts at the end of the vector and\n-    /// works backwards.  The matched element is not contained in the\n-    /// subslices.\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n     #[unstable = \"iterator type may change\"]\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>>;\n \n-    /**\n-     * Returns an iterator over all contiguous windows of length\n-     * `size`. The windows overlap. If the vector is shorter than\n-     * `size`, the iterator returns no values.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n-     * `[3,4]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4];\n-     * for win in v.windows(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n+    /// Returns an iterator over all contiguous windows of length\n+    /// `size`. The windows overlap. If the slice is shorter than\n+    /// `size`, the iterator returns no values.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the adjacent pairs of a slice (i.e. `[1,2]`, `[2,3]`,\n+    /// `[3,4]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4];\n+    /// for win in v.windows(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n     #[unstable = \"iterator type may change\"]\n     fn windows(self, size: uint) -> Windows<'a, T>;\n-    /**\n-     *\n-     * Returns an iterator over `size` elements of the vector at a\n-     * time. The chunks do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the vector two elements at a time (i.e. `[1,2]`,\n-     * `[3,4]`, `[5]`):\n-     *\n-     * ```rust\n-     * let v = &[1i, 2, 3, 4, 5];\n-     * for win in v.chunks(2) {\n-     *     println!(\"{}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n+\n+    /// Returns an iterator over `size` elements of the slice at a\n+    /// time. The chunks do not overlap. If `size` does not divide the\n+    /// length of the slice, then the last chunk will not have length\n+    /// `size`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `size` is 0.\n+    ///\n+    /// # Example\n+    ///\n+    /// Print the slice two elements at a time (i.e. `[1,2]`,\n+    /// `[3,4]`, `[5]`):\n+    ///\n+    /// ```rust\n+    /// let v = &[1i, 2, 3, 4, 5];\n+    /// for win in v.chunks(2) {\n+    ///     println!(\"{}\", win);\n+    /// }\n+    /// ```\n     #[unstable = \"iterator type may change\"]\n     fn chunks(self, size: uint) -> Chunks<'a, T>;\n \n-    /// Returns the element of a vector at the given index, or `None` if the\n-    /// index is out of bounds\n-    #[unstable]\n+    /// Returns the element of a slice at the given index, or `None` if the\n+    /// index is out of bounds.\n+    #[unstable = \"waiting on final collection conventions\"]\n     fn get(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, or `None` if it is empty\n+\n+    /// Returns the first element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n     fn head(&self) -> Option<&'a T>;\n-    /// Returns all but the first element of a vector\n+\n+    /// Returns all but the first element of a slice.\n     #[unstable = \"name may change\"]\n     fn tail(&self) -> &'a [T];\n-    /// Returns all but the first `n' elements of a vector\n+\n+    /// Returns all but the first `n' elements of a slice.\n     #[deprecated = \"use slice_from\"]\n     fn tailn(&self, n: uint) -> &'a [T];\n-    /// Returns all but the last element of a vector\n+\n+    /// Returns all but the last element of a slice.\n     #[unstable = \"name may change\"]\n     fn init(&self) -> &'a [T];\n-    /// Returns all but the last `n' elements of a vector\n+\n+    /// Returns all but the last `n' elements of a slice.\n     #[deprecated = \"use slice_to but note the arguments are different\"]\n     fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, or `None` if it is empty.\n+\n+    /// Returns the last element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n     fn last(&self) -> Option<&'a T>;\n \n@@ -202,44 +202,32 @@ pub trait ImmutableSlice<'a, T> {\n     #[unstable]\n     unsafe fn unsafe_get(self, index: uint) -> &'a T;\n \n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n+    /// Returns an unsafe pointer to the slice's buffer\n+    ///\n+    /// The caller must ensure that the slice outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n     #[unstable]\n     fn as_ptr(&self) -> *const T;\n \n-    /**\n-     * Binary search a sorted vector with a comparator function.\n-     *\n-     * The comparator function should implement an order consistent\n-     * with the sort order of the underlying vector, returning an\n-     * order code that indicates whether its argument is `Less`,\n-     * `Equal` or `Greater` the desired target.\n-     *\n-     * Returns the index where the comparator returned `Equal`, or `None` if\n-     * not found.\n-     */\n+    /// Deprecated: use `binary_search`.\n     #[deprecated = \"use binary_search\"]\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n-    /// Binary search a sorted vector with a comparator function.\n+    /// Binary search a sorted slice with a comparator function.\n     ///\n     /// The comparator function should implement an order consistent\n-    /// with the sort order of the underlying vector, returning an\n+    /// with the sort order of the underlying slice, returning an\n     /// order code that indicates whether its argument is `Less`,\n     /// `Equal` or `Greater` the desired target.\n     ///\n     /// If the value is found then `Found` is returned, containing the\n     /// index of the matching element; if the value is not found then\n     /// `NotFound` is returned, containing the index where a matching\n     /// element could be inserted while maintaining sorted order.\n-    #[unstable]\n+    #[unstable = \"waiting on unboxed closures\"]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n \n     /**\n@@ -336,7 +324,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -345,7 +333,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<Splits<'a, T>> {\n         SplitsN {\n             iter: self.split(pred),\n             count: n,\n@@ -395,7 +383,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n \n     #[inline]\n     fn last(&self) -> Option<&'a T> {\n-            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+        if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     #[inline]\n@@ -533,12 +521,13 @@ impl<T> ops::SliceMut<uint, [T]> for [T] {\n     }\n }\n \n-/// Extension methods for vectors such that their elements are\n+/// Extension methods for slices such that their elements are\n /// mutable.\n #[experimental = \"may merge with other traits; may lose region param; needs review\"]\n pub trait MutableSlice<'a, T> {\n     /// Returns a mutable reference to the element at the given index,\n     /// or `None` if the index is out of bounds\n+    #[unstable = \"waiting on final error conventions\"]\n     fn get_mut(self, index: uint) -> Option<&'a mut T>;\n     /// Work with `self` as a mut slice.\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n@@ -556,6 +545,7 @@ pub trait MutableSlice<'a, T> {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n \n     /// Deprecated: use `slice_from_mut`.\n@@ -569,6 +559,7 @@ pub trait MutableSlice<'a, T> {\n     /// Fails when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice_from_mut(self, start: uint) -> &'a mut [T];\n \n     /// Deprecated: use `slice_to_mut`.\n@@ -582,6 +573,7 @@ pub trait MutableSlice<'a, T> {\n     /// Fails when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n+    #[unstable = \"waiting on final error conventions\"]\n     fn slice_to_mut(self, end: uint) -> &'a mut [T];\n \n     /// Deprecated: use `iter_mut`.\n@@ -591,15 +583,29 @@ pub trait MutableSlice<'a, T> {\n     }\n \n     /// Returns an iterator that allows modifying each value\n+    #[unstable = \"waiting on iterator type name conventions\"]\n     fn iter_mut(self) -> MutItems<'a, T>;\n \n+    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty\n+    #[unstable = \"name may change\"]\n+    fn head_mut(self) -> Option<&'a mut T>;\n+\n+    /// Returns all but the first element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn tail_mut(self) -> &'a mut [T];\n+\n+    /// Returns all but the last element of a mutable slice\n+    #[unstable = \"name may change\"]\n+    fn init_mut(self) -> &'a mut [T];\n+\n     /// Deprecated: use `last_mut`.\n     #[deprecated = \"use last_mut\"]\n     fn mut_last(self) -> Option<&'a mut T> {\n         self.last_mut()\n     }\n \n-    /// Returns a mutable pointer to the last item in the vector.\n+    /// Returns a mutable pointer to the last item in the slice.\n+    #[unstable = \"name may change\"]\n     fn last_mut(self) -> Option<&'a mut T>;\n \n     /// Deprecated: use `split_mut`.\n@@ -608,27 +614,39 @@ pub trait MutableSlice<'a, T> {\n         self.split_mut(pred)\n     }\n \n-    /// Returns an iterator over the mutable subslices of the vector\n-    /// which are separated by elements that match `pred`.  The\n-    /// matched element is not contained in the subslices.\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`.  The matched element is not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n     fn split_mut(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// not contained in the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn splitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+\n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// the slice and works backwards.  The matched element is not contained in\n+    /// the subslices.\n+    #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n+    fn rsplitn_mut(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n+\n     /// Deprecated: use `chunks_mut`.\n     #[deprecated = \"use chunks_mut\"]\n     fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n         self.chunks_mut(chunk_size)\n     }\n \n-    /**\n-     * Returns an iterator over `chunk_size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `chunk_size` does\n-     * not divide the length of the vector, then the last chunk will not\n-     * have length `chunk_size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `chunk_size` is 0.\n-     */\n+    /// Returns an iterator over `chunk_size` elements of the slice at a time.\n+    /// The chunks are mutable and do not overlap. If `chunk_size` does\n+    /// not divide the length of the slice, then the last chunk will not\n+    /// have length `chunk_size`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if `chunk_size` is 0.\n+    #[unstable = \"waiting on iterator type name conventions\"]\n     fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n     /**\n@@ -647,7 +665,7 @@ pub trait MutableSlice<'a, T> {\n      *\n      * Returns `None` if slice is empty\n      */\n-    #[deprecated = \"find some other way. sorry\"]\n+    #[deprecated = \"use iter_mut\"]\n     fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n \n     /**\n@@ -666,10 +684,10 @@ pub trait MutableSlice<'a, T> {\n      *\n      * Returns `None` if slice is empty.\n      */\n-    #[deprecated = \"find some other way. sorry\"]\n+    #[deprecated = \"use iter_mut\"]\n     fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n \n-    /// Swaps two elements in a vector.\n+    /// Swaps two elements in a slice.\n     ///\n     /// Fails if `a` or `b` are out of bounds.\n     ///\n@@ -685,6 +703,7 @@ pub trait MutableSlice<'a, T> {\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n     /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n     fn swap(self, a: uint, b: uint);\n \n     /// Deprecated: use `split_at_mut`.\n@@ -725,9 +744,10 @@ pub trait MutableSlice<'a, T> {\n     ///     assert!(right == &mut []);\n     /// }\n     /// ```\n+    #[unstable = \"waiting on final error conventions\"]\n     fn split_at_mut(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n \n-    /// Reverse the order of elements in a vector, in place.\n+    /// Reverse the order of elements in a slice, in place.\n     ///\n     /// # Example\n     ///\n@@ -736,6 +756,7 @@ pub trait MutableSlice<'a, T> {\n     /// v.reverse();\n     /// assert!(v == [3i, 2, 1]);\n     /// ```\n+    #[experimental = \"may be moved to iterators instead\"]\n     fn reverse(self);\n \n     /// Deprecated: use `unsafe_mut`.\n@@ -745,60 +766,30 @@ pub trait MutableSlice<'a, T> {\n     }\n \n     /// Returns an unsafe mutable pointer to the element in index\n+    #[experimental = \"waiting on unsafe conventions\"]\n     unsafe fn unsafe_mut(self, index: uint) -> &'a mut T;\n \n-    /// Return an unsafe mutable pointer to the vector's buffer.\n+    /// Return an unsafe mutable pointer to the slice's buffer.\n     ///\n-    /// The caller must ensure that the vector outlives the pointer this\n+    /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n     ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// Modifying the slice may cause its buffer to be reallocated, which\n     /// would also make any pointers to it invalid.\n     #[inline]\n+    #[unstable]\n     fn as_mut_ptr(self) -> *mut T;\n \n-    /// Unsafely sets the element in index to the value.\n-    ///\n-    /// This performs no bounds checks, and it is undefined behaviour\n-    /// if `index` is larger than the length of `self`. However, it\n-    /// does run the destructor at `index`. It is equivalent to\n-    /// `self[index] = val`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string(), \"baz\".to_string()];\n-    ///\n-    /// unsafe {\n-    ///     // `\"baz\".to_string()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_string());\n-    ///\n-    ///     // Out of bounds: could cause a crash, or overwriting\n-    ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_string());\n-    /// }\n-    /// ```\n+    /// Deprecated: use `*foo.as_mut_ptr().offset(index) = val` instead.\n+    #[deprecated = \"use `*foo.as_mut_ptr().offset(index) = val`\"]\n     unsafe fn unsafe_set(self, index: uint, val: T);\n \n-    /// Unchecked vector index assignment.  Does not drop the\n-    /// old value and hence is only suitable when the vector\n-    /// is newly allocated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_string(), \"bar\".to_string()];\n-    ///\n-    /// // memory leak! `\"bar\".to_string()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_string()); }\n-    /// ```\n+    /// Deprecated: use `ptr::write(foo.as_mut_ptr().offset(i), val)` instead.\n+    #[deprecated = \"use `ptr::write(foo.as_mut_ptr().offset(i), val)`\"]\n     unsafe fn init_elem(self, i: uint, val: T);\n \n-    /// Copies raw bytes from `src` to `self`.\n-    ///\n-    /// This does not run destructors on the overwritten elements, and\n-    /// ignores move semantics. `self` and `src` must not\n-    /// overlap. Fails if `self` is shorter than `src`.\n+    /// Deprecated: use `as_mut_ptr` and `ptr::copy_memory` instead.\n+    #[deprecated = \"use as_mut_ptr and ptr::copy_memory\"]\n     unsafe fn copy_memory(self, src: &[T]);\n }\n \n@@ -868,11 +859,46 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         Some(&mut self[len - 1])\n     }\n \n+    #[inline]\n+    fn head_mut(self) -> Option<&'a mut T> {\n+        if self.len() == 0 { None } else { Some(&mut self[0]) }\n+    }\n+\n+    #[inline]\n+    fn tail_mut(self) -> &'a mut [T] {\n+        let len = self.len();\n+        self.slice_mut(1, len)\n+    }\n+\n+    #[inline]\n+    fn init_mut(self) -> &'a mut [T] {\n+        let len = self.len();\n+        self.slice_mut(0, len - 1)\n+    }\n+\n     #[inline]\n     fn split_mut(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n         MutSplits { v: self, pred: pred, finished: false }\n     }\n \n+    #[inline]\n+    fn splitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+        SplitsN {\n+            iter: self.split_mut(pred),\n+            count: n,\n+            invert: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn rsplitn_mut(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>> {\n+        SplitsN {\n+            iter: self.split_mut(pred),\n+            count: n,\n+            invert: true\n+        }\n+   }\n+\n     #[inline]\n     fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T> {\n         assert!(chunk_size > 0);\n@@ -955,22 +981,22 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     }\n }\n \n-/// Extension methods for vectors contain `PartialEq` elements.\n+/// Extension methods for slices containing `PartialEq` elements.\n #[unstable = \"may merge with other traits\"]\n pub trait ImmutablePartialEqSlice<T:PartialEq> {\n-    /// Find the first index containing a matching value\n+    /// Find the first index containing a matching value.\n     fn position_elem(&self, t: &T) -> Option<uint>;\n \n-    /// Find the last index containing a matching value\n+    /// Find the last index containing a matching value.\n     fn rposition_elem(&self, t: &T) -> Option<uint>;\n \n-    /// Return true if a vector contains an element with the given value\n+    /// Return true if the slice contains an element with the given value.\n     fn contains(&self, x: &T) -> bool;\n \n-    /// Returns true if `needle` is a prefix of the vector.\n+    /// Returns true if `needle` is a prefix of the slice.\n     fn starts_with(&self, needle: &[T]) -> bool;\n \n-    /// Returns true if `needle` is a suffix of the vector.\n+    /// Returns true if `needle` is a suffix of the slice.\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n@@ -1004,26 +1030,20 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n     }\n }\n \n-/// Extension methods for vectors containing `Ord` elements.\n+/// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n pub trait ImmutableOrdSlice<T: Ord> {\n-    /**\n-     * Binary search a sorted vector for a given element.\n-     *\n-     * Returns the index of the element or None if not found.\n-     */\n+    /// Deprecated: use `binary_search_elem`.\n     #[deprecated = \"use binary_search_elem\"]\n     fn bsearch_elem(&self, x: &T) -> Option<uint>;\n \n-    /**\n-     * Binary search a sorted vector for a given element.\n-     *\n-     * If the value is found then `Found` is returned, containing the\n-     * index of the matching element; if the value is not found then\n-     * `NotFound` is returned, containing the index where a matching\n-     * element could be inserted while maintaining sorted order.\n-     */\n-    #[unstable]\n+    /// Binary search a sorted slice for a given element.\n+    ///\n+    /// If the value is found then `Found` is returned, containing the\n+    /// index of the matching element; if the value is not found then\n+    /// `NotFound` is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    #[unstable = \"name likely to change\"]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n }\n \n@@ -1090,7 +1110,7 @@ impl<'a, T:Clone> MutableCloneableSlice<T> for &'a mut [T] {\n // Common traits\n //\n \n-/// Any vector that can be represented as a slice.\n+/// Data that is viewable as a slice.\n #[unstable = \"may merge with other traits\"]\n pub trait Slice<T> {\n     /// Work with `self` as a slice.\n@@ -1105,7 +1125,7 @@ impl<'a,T> Slice<T> for &'a [T] {\n \n #[experimental = \"trait is experimental\"]\n impl<'a, T> Collection for &'a [T] {\n-    /// Returns the length of a vector\n+    /// Returns the length of a slice.\n     #[inline]\n     fn len(&self) -> uint {\n         self.repr().len\n@@ -1114,7 +1134,7 @@ impl<'a, T> Collection for &'a [T] {\n \n #[experimental = \"trait is experimental\"]\n impl<'a, T> Collection for &'a mut [T] {\n-    /// Returns the length of a vector\n+    /// Returns the length of a slice.\n     #[inline]\n     fn len(&self) -> uint {\n         self.repr().len\n@@ -1239,7 +1259,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n     }\n }\n \n-/// Mutable slice iterator\n+/// Mutable slice iterator.\n #[experimental = \"needs review\"]\n pub struct MutItems<'a, T> {\n     ptr: *mut T,\n@@ -1253,8 +1273,16 @@ iterator!{struct MutItems -> *mut T, &'a mut T}\n #[experimental = \"needs review\"]\n impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function.\n+/// An abstraction over the splitting iterators, so that splitn, splitn_mut etc\n+/// can be implemented once.\n+trait SplitsIter<E>: DoubleEndedIterator<E> {\n+    /// Mark the underlying iterator as complete, extracting the remaining\n+    /// portion of the slice.\n+    fn finish(&mut self) -> Option<E>;\n+}\n+\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function.\n #[experimental = \"needs review\"]\n pub struct Splits<'a, T:'a> {\n     v: &'a [T],\n@@ -1269,10 +1297,7 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n         if self.finished { return None; }\n \n         match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n+            None => self.finish(),\n             Some(idx) => {\n                 let ret = Some(self.v.slice(0, idx));\n                 self.v = self.v.slice(idx + 1, self.v.len());\n@@ -1298,10 +1323,7 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n         if self.finished { return None; }\n \n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n+            None => self.finish(),\n             Some(idx) => {\n                 let ret = Some(self.v.slice(idx + 1, self.v.len()));\n                 self.v = self.v.slice(0, idx);\n@@ -1311,6 +1333,13 @@ impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     }\n }\n \n+impl<'a, T> SplitsIter<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        if self.finished { None } else { self.finished = true; Some(self.v) }\n+    }\n+}\n+\n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n #[experimental = \"needs review\"]\n@@ -1320,22 +1349,30 @@ pub struct MutSplits<'a, T:'a> {\n     finished: bool\n }\n \n+impl<'a, T> SplitsIter<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            None\n+        } else {\n+            self.finished = true;\n+            Some(mem::replace(&mut self.v, &mut []))\n+        }\n+    }\n+}\n+\n #[experimental = \"needs review\"]\n impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().position(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.split_at_mut(len);\n-                self.v = tail;\n-                Some(head)\n-            }\n+        let idx_opt = { // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n@@ -1363,13 +1400,12 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                Some(tmp)\n-            }\n+        let idx_opt = { // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().rposition(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n@@ -1380,26 +1416,21 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n     }\n }\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, splitting at most a fixed number of times.\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function, splitting at most a fixed number of times.\n #[experimental = \"needs review\"]\n-pub struct SplitsN<'a, T:'a> {\n-    iter: Splits<'a, T>,\n+pub struct SplitsN<I> {\n+    iter: I,\n     count: uint,\n     invert: bool\n }\n \n #[experimental = \"needs review\"]\n-impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n+impl<E, I: SplitsIter<E>> Iterator<E> for SplitsN<I> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n+    fn next(&mut self) -> Option<E> {\n         if self.count == 0 {\n-            if self.iter.finished {\n-                None\n-            } else {\n-                self.iter.finished = true;\n-                Some(self.iter.v)\n-            }\n+            self.iter.finish()\n         } else {\n             self.count -= 1;\n             if self.invert { self.iter.next_back() } else { self.iter.next() }\n@@ -1408,16 +1439,12 @@ impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.iter.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n-        }\n+        let (lower, upper_opt) = self.iter.size_hint();\n+        (lower, upper_opt.map(|upper| cmp::min(self.count + 1, upper)))\n     }\n }\n \n-/// An iterator over the (overlapping) slices of length `size` within\n-/// a vector.\n+/// An iterator over overlapping subslices of length `size`.\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n pub struct Windows<'a, T:'a> {\n@@ -1448,11 +1475,11 @@ impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n     }\n }\n \n-/// An iterator over a vector in (non-overlapping) chunks (`size`\n-/// elements at a time).\n+/// An iterator over a slice in (non-overlapping) chunks (`size` elements at a\n+/// time).\n ///\n-/// When the vector len is not evenly divided by the chunk size,\n-/// the last slice of the iteration will be the remainder.\n+/// When the slice len is not evenly divided by the chunk size, the last slice\n+/// of the iteration will be the remainder.\n #[deriving(Clone)]\n #[experimental = \"needs review\"]\n pub struct Chunks<'a, T:'a> {\n@@ -1523,9 +1550,9 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n     }\n }\n \n-/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n-/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n-/// the remainder.\n+/// An iterator over a slice in (non-overlapping) mutable chunks (`size`\n+/// elements at a time). When the slice len is not evenly divided by the chunk\n+/// size, the last slice of the iteration will be the remainder.\n #[experimental = \"needs review\"]\n pub struct MutChunks<'a, T:'a> {\n     v: &'a mut [T],"}]}