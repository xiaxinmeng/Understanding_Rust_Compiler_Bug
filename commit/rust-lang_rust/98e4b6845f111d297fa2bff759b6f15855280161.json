{"sha": "98e4b6845f111d297fa2bff759b6f15855280161", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZTRiNjg0NWYxMTFkMjk3ZmEyYmZmNzU5YjZmMTU4NTUyODAxNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-04T15:30:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-04T15:30:20Z"}, "message": "Auto merge of #45709 - nrc:rls-bugs-2, r=eddyb\n\nFix a bunch of minor save-analysis bugs\n\nr? @eddyb", "tree": {"sha": "939511e7f4a32727549009fe8d918030954cf11e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939511e7f4a32727549009fe8d918030954cf11e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98e4b6845f111d297fa2bff759b6f15855280161", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98e4b6845f111d297fa2bff759b6f15855280161", "html_url": "https://github.com/rust-lang/rust/commit/98e4b6845f111d297fa2bff759b6f15855280161", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98e4b6845f111d297fa2bff759b6f15855280161/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd343bfbca0a54ce861e7f4e9bcad0ac5ed2b4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd343bfbca0a54ce861e7f4e9bcad0ac5ed2b4f", "html_url": "https://github.com/rust-lang/rust/commit/dcd343bfbca0a54ce861e7f4e9bcad0ac5ed2b4f"}, {"sha": "5d3be12a4d43b73c79e81adc964766a706bb5a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d3be12a4d43b73c79e81adc964766a706bb5a07", "html_url": "https://github.com/rust-lang/rust/commit/5d3be12a4d43b73c79e81adc964766a706bb5a07"}], "stats": {"total": 177, "additions": 112, "deletions": 65}, "files": [{"sha": "23f6e6b46bad5a883785a7907996f59ee092453c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 60, "deletions": 47, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/98e4b6845f111d297fa2bff759b6f15855280161/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e4b6845f111d297fa2bff759b6f15855280161/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=98e4b6845f111d297fa2bff759b6f15855280161", "patch": "@@ -322,25 +322,24 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             let mut collector = PathCollector::new();\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n-            for &(id, ref p, ..) in &collector.collected_paths {\n+\n+            for (id, i, sp, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                // get the span only for the name of the variable (I hope the path is only ever a\n-                // variable name, but who knows?)\n-                let sub_span = span_utils.span_for_last_ident(p.span);\n-                if !self.span.filter_generated(sub_span, p.span) {\n+                let sub_span = span_utils.span_for_last_ident(sp);\n+                if !self.span.filter_generated(sub_span, sp) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                     self.dumper.dump_def(false, Def {\n                         kind: DefKind::Local,\n                         id,\n                         span,\n-                        name: path_to_string(p),\n-                        qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n+                        name: i.to_string(),\n+                        qualname: format!(\"{}::{}\", qualname, i.to_string()),\n                         value: typ,\n                         parent: None,\n                         children: vec![],\n@@ -395,14 +394,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_trait_ref(&mut self, trait_ref: &'l ast::TraitRef) {\n-        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref);\n-        if let Some(trait_ref_data) = trait_ref_data {\n-            self.dumper.dump_ref(trait_ref_data);\n-        }\n-        self.process_path(trait_ref.ref_id, &trait_ref.path);\n-    }\n-\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n@@ -792,7 +783,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_path(&mut self, id: NodeId, path: &ast::Path) {\n+    fn process_path(&mut self, id: NodeId, path: &'l ast::Path) {\n+        debug!(\"process_path {:?}\", path);\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if generated_code(path.span) && path_data.is_none() {\n             return;\n@@ -807,6 +799,27 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         self.dumper.dump_ref(path_data);\n \n+        // Type parameters\n+        for seg in &path.segments {\n+            if let Some(ref params) = seg.parameters {\n+                match **params {\n+                    ast::PathParameters::AngleBracketed(ref data) => {\n+                        for t in &data.types {\n+                            self.visit_ty(t);\n+                        }\n+                    }\n+                    ast::PathParameters::Parenthesized(ref data) => {\n+                        for t in &data.inputs {\n+                            self.visit_ty(t);\n+                        }\n+                        if let Some(ref t) = data.output {\n+                            self.visit_ty(t);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         // Modules or types in the path prefix.\n         match self.save_ctxt.get_path_def(id) {\n             HirDef::Method(did) => {\n@@ -859,14 +872,26 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         walk_list!(self, visit_expr, base);\n     }\n \n-    fn process_method_call(&mut self, ex: &'l ast::Expr, args: &'l [P<ast::Expr>]) {\n+    fn process_method_call(&mut self,\n+                           ex: &'l ast::Expr,\n+                           seg: &'l ast::PathSegment,\n+                           args: &'l [P<ast::Expr>]) {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(mcd, RefData, ex.span);\n             if !generated_code(ex.span) {\n                 self.dumper.dump_ref(mcd);\n             }\n         }\n \n+        // Explicit types in the turbo-fish.\n+        if let Some(ref params) = seg.parameters {\n+            if let ast::PathParameters::AngleBracketed(ref data) = **params {\n+                for t in &data.types {\n+                    self.visit_ty(t);\n+                }\n+            }\n+        }\n+\n         // walk receiver and args\n         walk_list!(self, visit_expr, args);\n     }\n@@ -913,7 +938,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         collector.visit_pat(&p);\n         self.visit_pat(&p);\n \n-        for &(id, ref p, immut) in &collector.collected_paths {\n+        for (id, i, sp, immut) in collector.collected_idents {\n             let mut value = match immut {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n@@ -933,18 +958,18 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(p.span);\n+            let sub_span = self.span.span_for_last_ident(sp);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, p.span) {\n-                let qualname = format!(\"{}${}\", path_to_string(p), id);\n+            if !self.span.filter_generated(sub_span, sp) {\n+                let qualname = format!(\"{}${}\", i.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                 self.dumper.dump_def(false, Def {\n                     kind: DefKind::Local,\n                     id,\n                     span,\n-                    name: path_to_string(p),\n+                    name: i.to_string(),\n                     qualname,\n                     value: typ,\n                     parent: None,\n@@ -1274,7 +1299,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_trait_ref(&trait_ref.trait_ref);\n+                    self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n                 }\n             }\n             if let Some(ref ty) = param.default {\n@@ -1329,7 +1354,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 let def = self.save_ctxt.get_path_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n-            ast::ExprKind::MethodCall(.., ref args) => self.process_method_call(ex, args),\n+            ast::ExprKind::MethodCall(ref seg, ref args) => self.process_method_call(ex, seg, args),\n             ast::ExprKind::Field(ref sub_ex, _) => {\n                 self.visit_expr(&sub_ex);\n \n@@ -1401,15 +1426,15 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n                 debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n-                visit::walk_expr(self, subexpression);\n+                self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n             ast::ExprKind::IfLet(ref pattern, ref subexpression, ref block, ref opt_else) => {\n                 let value = self.span.snippet(subexpression.span);\n                 self.process_var_decl(pattern, value);\n-                visit::walk_expr(self, subexpression);\n+                self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n-                opt_else.as_ref().map(|el| visit::walk_expr(self, el));\n+                opt_else.as_ref().map(|el| self.visit_expr(el));\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);\n@@ -1441,15 +1466,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             self.visit_pat(&pattern);\n         }\n \n-        // This is to get around borrow checking, because we need mut self to call process_path.\n-        let mut paths_to_process = vec![];\n-\n         // process collected paths\n-        for &(id, ref p, immut) in &collector.collected_paths {\n+        for (id, i, sp, immut) in collector.collected_idents {\n             match self.save_ctxt.get_path_def(id) {\n                 HirDef::Local(id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(p.span).to_string()\n+                        self.span.snippet(sp).to_string()\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n@@ -1462,18 +1484,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    assert!(p.segments.len() == 1,\n-                            \"qualified path for local variable def in arm\");\n-                    if !self.span.filter_generated(Some(p.span), p.span) {\n-                        let qualname = format!(\"{}${}\", path_to_string(p), id);\n+                    if !self.span.filter_generated(Some(sp), sp) {\n+                        let qualname = format!(\"{}${}\", i.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(p.span);\n+                        let span = self.span_from_span(sp);\n \n                         self.dumper.dump_def(false, Def {\n                             kind: DefKind::Local,\n                             id,\n                             span,\n-                            name: path_to_string(p),\n+                            name: i.to_string(),\n                             qualname,\n                             value: typ,\n                             parent: None,\n@@ -1485,19 +1505,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         });\n                     }\n                 }\n-                HirDef::StructCtor(..) | HirDef::VariantCtor(..) |\n-                HirDef::Const(..) | HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) | HirDef::Variant(..) |\n-                HirDef::TyAlias(..) | HirDef::AssociatedTy(..) |\n-                HirDef::SelfTy(..) => {\n-                    paths_to_process.push((id, p.clone()))\n-                }\n-                def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                def => error!(\"unexpected definition kind when processing collected idents: {:?}\",\n                               def),\n             }\n         }\n \n-        for &(id, ref path) in &paths_to_process {\n+        for (id, ref path) in collector.collected_paths {\n             self.process_path(id, path);\n         }\n         walk_list!(self, visit_expr, &arm.guard);"}, {"sha": "5ae1ba92262f5cc0e8202e024943de961076e7c5", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 52, "deletions": 18, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/98e4b6845f111d297fa2bff759b6f15855280161/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98e4b6845f111d297fa2bff759b6f15855280161/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=98e4b6845f111d297fa2bff759b6f15855280161", "patch": "@@ -579,8 +579,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodeItem(&hir::Item { node: hir::ItemUse(ref path, _), .. }) |\n             Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n \n-            Node::NodeExpr(&hir::Expr { node: hir::ExprPath(ref qpath), .. }) |\n             Node::NodeExpr(&hir::Expr { node: hir::ExprStruct(ref qpath, ..), .. }) |\n+            Node::NodeExpr(&hir::Expr { node: hir::ExprPath(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n@@ -614,6 +614,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n+        // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n+        fn fn_type(path: &ast::Path) -> bool {\n+            if path.segments.len() != 1 {\n+                return false;\n+            }\n+            if let Some(ref params) = path.segments[0].parameters {\n+                if let ast::PathParameters::Parenthesized(_) = **params {\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n+\n         let def = self.get_path_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n@@ -630,7 +643,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::Static(..) |\n             HirDef::Const(..) |\n             HirDef::AssociatedConst(..) |\n-            HirDef::StructCtor(..) |\n             HirDef::VariantCtor(..) => {\n                 let span = self.span_from_span(sub_span.unwrap());\n                 Some(Ref {\n@@ -639,6 +651,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def.def_id()),\n                 })\n             }\n+            HirDef::Trait(def_id) if fn_type(path) => {\n+                // Function type bounds are desugared in the parser, so we have to\n+                // special case them here.\n+                let fn_span = self.span_utils.span_for_first_ident(path.span);\n+                fn_span.map(|span| Ref {\n+                    kind: RefKind::Type,\n+                    span: self.span_from_span(span),\n+                    ref_id: id_from_def_id(def_id),\n+                })\n+            }\n             HirDef::Struct(def_id) |\n             HirDef::Variant(def_id, ..) |\n             HirDef::Union(def_id) |\n@@ -655,6 +677,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n+            HirDef::StructCtor(def_id, _) => {\n+                // This is a reference to a tuple struct where the def_id points\n+                // to an invisible constructor function. That is not a very useful\n+                // def, so adjust to point to the tuple struct itself.\n+                let span = self.span_from_span(sub_span.unwrap());\n+                let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n+                Some(Ref {\n+                    kind: RefKind::Type,\n+                    span,\n+                    ref_id: id_from_def_id(parent_def_id),\n+                })\n+            }\n             HirDef::Method(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 filter!(self.span_utils, sub_span, path.span, None);\n@@ -818,29 +852,31 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig\n }\n \n-// An AST visitor for collecting paths from patterns.\n-struct PathCollector {\n-    // The Row field identifies the kind of pattern.\n-    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability)>,\n+// An AST visitor for collecting paths (e.g., the names of structs) and formal\n+// variables (idents) from patterns.\n+struct PathCollector<'l> {\n+    collected_paths: Vec<(NodeId, &'l ast::Path)>,\n+    collected_idents: Vec<(NodeId, ast::Ident, Span, ast::Mutability)>,\n }\n \n-impl PathCollector {\n-    fn new() -> PathCollector {\n-        PathCollector { collected_paths: vec![] }\n+impl<'l> PathCollector<'l> {\n+    fn new() -> PathCollector<'l> {\n+        PathCollector {\n+            collected_paths: vec![],\n+            collected_idents: vec![],\n+        }\n     }\n }\n \n-impl<'a> Visitor<'a> for PathCollector {\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, ..) => {\n-                self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable));\n+                self.collected_paths.push((p.id, path));\n             }\n             PatKind::TupleStruct(ref path, ..) |\n             PatKind::Path(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable));\n+                self.collected_paths.push((p.id, path));\n             }\n             PatKind::Ident(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n@@ -854,9 +890,7 @@ impl<'a> Visitor<'a> for PathCollector {\n                     ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n-                // collect path for either visit_local or visit_arm\n-                let path = ast::Path::from_ident(path1.span, path1.node);\n-                self.collected_paths.push((p.id, path, immut));\n+                self.collected_idents.push((p.id, path1.node, path1.span, immut));\n             }\n             _ => {}\n         }"}]}