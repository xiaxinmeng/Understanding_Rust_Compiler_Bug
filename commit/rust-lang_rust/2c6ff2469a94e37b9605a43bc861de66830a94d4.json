{"sha": "2c6ff2469a94e37b9605a43bc861de66830a94d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNmZmMjQ2OWE5NGUzN2I5NjA1YTQzYmM4NjFkZTY2ODMwYTk0ZDQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-26T18:16:21Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:21:08Z"}, "message": "Refactor ast::GenericParam as a struct", "tree": {"sha": "36c1ad6aed0cceb2980e97878c48436fe2d9d757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36c1ad6aed0cceb2980e97878c48436fe2d9d757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c6ff2469a94e37b9605a43bc861de66830a94d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c6ff2469a94e37b9605a43bc861de66830a94d4", "html_url": "https://github.com/rust-lang/rust/commit/2c6ff2469a94e37b9605a43bc861de66830a94d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c6ff2469a94e37b9605a43bc861de66830a94d4/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b", "html_url": "https://github.com/rust-lang/rust/commit/fba1fe21084bf248334ad46b0b0a8c40a6d5ee7b"}], "stats": {"total": 693, "additions": 338, "deletions": 355}, "files": [{"sha": "68ceb39d575d66c7b7617eedc16b1654ec70a1a9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -759,20 +759,20 @@ impl<'a> LoweringContext<'a> {\n         hir_name\n     }\n \n-    // Evaluates `f` with the lifetimes in `lt_defs` in-scope.\n+    // Evaluates `f` with the lifetimes in `params` in-scope.\n     // This is used to track which lifetimes have already been defined, and\n     // which are new in-band lifetimes that need to have a definition created\n     // for them.\n     fn with_in_scope_lifetime_defs<'l, T, F>(\n         &mut self,\n-        lt_defs: impl Iterator<Item = &'l LifetimeDef>,\n+        params: impl Iterator<Item = &'l GenericParamAST>,\n         f: F,\n     ) -> T\n     where\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = lt_defs.map(|lt_def| lt_def.lifetime.ident.name);\n+        let lt_def_names = params.map(|param| param.ident.name);\n         self.in_scope_lifetimes.extend(lt_def_names);\n \n         let res = f(self);\n@@ -781,8 +781,8 @@ impl<'a> LoweringContext<'a> {\n         res\n     }\n \n-    // Same as the method above, but accepts `hir::LifetimeDef`s\n-    // instead of `ast::LifetimeDef`s.\n+    // Same as the method above, but accepts `hir::GenericParam`s\n+    // instead of `ast::GenericParam`s.\n     // This should only be used with generics that have already had their\n     // in-band lifetimes added. In practice, this means that this function is\n     // only used when lowering a child item of a trait or impl.\n@@ -817,8 +817,8 @@ impl<'a> LoweringContext<'a> {\n         F: FnOnce(&mut LoweringContext) -> T,\n     {\n         let (in_band_defs, (mut lowered_generics, res)) = self.with_in_scope_lifetime_defs(\n-            generics.params.iter().filter_map(|p| match p {\n-                GenericParamAST::Lifetime(ld) => Some(ld),\n+            generics.params.iter().filter_map(|param| match param.kind {\n+                GenericParamKindAST::Lifetime { .. } => Some(param),\n                 _ => None,\n             }),\n             |this| {\n@@ -1076,8 +1076,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(\n-                f.generic_params.iter().filter_map(|p| match p {\n-                    GenericParamAST::Lifetime(ld) => Some(ld),\n+                f.generic_params.iter().filter_map(|param| match param.kind {\n+                    GenericParamKindAST::Lifetime { .. } => Some(param),\n                     _ => None,\n                 }),\n                 |this| {\n@@ -1940,21 +1940,19 @@ impl<'a> LoweringContext<'a> {\n                            add_bounds: &NodeMap<Vec<TyParamBound>>,\n                            itctx: ImplTraitContext)\n                            -> hir::GenericParam {\n-        match param {\n-            GenericParamAST::Lifetime(ref lifetime_def) => {\n+        match param.kind {\n+            GenericParamKindAST::Lifetime { ref bounds, ref lifetime, .. } => {\n                 let was_collecting_in_band = self.is_collecting_in_band_lifetimes;\n                 self.is_collecting_in_band_lifetimes = false;\n \n-                let lifetime = self.lower_lifetime(&lifetime_def.lifetime);\n+                let lifetime = self.lower_lifetime(lifetime);\n                 let param = hir::GenericParam {\n                     id: lifetime.id,\n                     span: lifetime.span,\n-                    pure_wrt_drop: attr::contains_name(&lifetime_def.attrs, \"may_dangle\"),\n+                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     kind: hir::GenericParamKind::Lifetime {\n                         name: lifetime.name,\n-                        bounds: lifetime_def.bounds\n-                                            .iter()\n-                                            .map(|lt| self.lower_lifetime(lt)).collect(),\n+                        bounds: bounds.iter().map(|lt| self.lower_lifetime(lt)).collect(),\n                         in_band: false,\n                         lifetime_deprecated: lifetime,\n                     }\n@@ -1964,8 +1962,8 @@ impl<'a> LoweringContext<'a> {\n \n                 param\n             }\n-            GenericParamAST::Type(ref ty_param) => {\n-                let mut name = self.lower_ident(ty_param.ident);\n+            GenericParamKindAST::Type { ref bounds, ref default } => {\n+                let mut name = self.lower_ident(param.ident);\n \n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n@@ -1974,8 +1972,8 @@ impl<'a> LoweringContext<'a> {\n                     name = Symbol::gensym(\"Self\");\n                 }\n \n-                let mut bounds = self.lower_bounds(&ty_param.bounds, itctx);\n-                let add_bounds = add_bounds.get(&ty_param.id).map_or(&[][..], |x| &x);\n+                let mut bounds = self.lower_bounds(bounds, itctx);\n+                let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n                     bounds = bounds\n                         .into_iter()\n@@ -1984,22 +1982,20 @@ impl<'a> LoweringContext<'a> {\n                 }\n \n                 hir::GenericParam {\n-                    id: self.lower_node_id(ty_param.id).node_id,\n-                    span: ty_param.ident.span,\n-                    pure_wrt_drop: attr::contains_name(&ty_param.attrs, \"may_dangle\"),\n+                    id: self.lower_node_id(param.id).node_id,\n+                    span: param.ident.span,\n+                    pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     kind: hir::GenericParamKind::Type {\n                         name,\n                         bounds,\n-                        default: ty_param.default.as_ref()\n-                                         .map(|x| {\n-                                             self.lower_ty(x, ImplTraitContext::Disallowed)\n-                                         }),\n-                        synthetic: ty_param.attrs\n-                                           .iter()\n-                                           .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n-                                           .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n-                                           .nth(0),\n-                        attrs: self.lower_attrs(&ty_param.attrs),\n+                        default: default.as_ref().map(|x| {\n+                            self.lower_ty(x, ImplTraitContext::Disallowed)\n+                        }),\n+                        synthetic: param.attrs.iter()\n+                                              .filter(|attr| attr.check_name(\"rustc_synthetic\"))\n+                                              .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                                              .nth(0),\n+                        attrs: self.lower_attrs(&param.attrs),\n                     }\n                 }\n             }\n@@ -2015,13 +2011,18 @@ impl<'a> LoweringContext<'a> {\n         params.iter().map(|param| self.lower_generic_param(param, add_bounds, itctx)).collect()\n     }\n \n-    fn lower_generics(&mut self, g: &Generics, itctx: ImplTraitContext) -> hir::Generics {\n+    fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext)\n+        -> hir::Generics\n+    {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: This could probably be done with less rightward drift. Also looks like two control\n         //        paths where report_error is called are also the only paths that advance to after\n         //        the match statement, so the error reporting could probably just be moved there.\n         let mut add_bounds = NodeMap();\n-        for pred in &g.where_clause.predicates {\n+        for pred in &generics.where_clause.predicates {\n             if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n                 'next_bound: for bound in &bound_pred.bounds {\n                     if let TraitTyParamBound(_, TraitBoundModifier::Maybe) = *bound {\n@@ -2045,15 +2046,17 @@ impl<'a> LoweringContext<'a> {\n                                     if let Some(node_id) =\n                                         self.resolver.definitions().as_local_node_id(def_id)\n                                     {\n-                                        for param in &g.params {\n-                                            if let GenericParamAST::Type(ref ty_param) = *param {\n-                                                if node_id == ty_param.id {\n-                                                    add_bounds\n-                                                        .entry(ty_param.id)\n-                                                        .or_insert(Vec::new())\n-                                                        .push(bound.clone());\n-                                                    continue 'next_bound;\n+                                        for param in &generics.params {\n+                                            match param.kind {\n+                                                GenericParamKindAST::Type { .. } => {\n+                                                    if node_id == param.id {\n+                                                        add_bounds.entry(param.id)\n+                                                            .or_insert(Vec::new())\n+                                                            .push(bound.clone());\n+                                                        continue 'next_bound;\n+                                                    }\n                                                 }\n+                                                _ => {}\n                                             }\n                                         }\n                                     }\n@@ -2068,9 +2071,9 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::Generics {\n-            params: self.lower_generic_params(&g.params, &add_bounds, itctx),\n-            where_clause: self.lower_where_clause(&g.where_clause),\n-            span: g.span,\n+            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n+            where_clause: self.lower_where_clause(&generics.where_clause),\n+            span: generics.span,\n         }\n     }\n \n@@ -2093,8 +2096,8 @@ impl<'a> LoweringContext<'a> {\n                 span,\n             }) => {\n                 self.with_in_scope_lifetime_defs(\n-                    bound_generic_params.iter().filter_map(|p| match p {\n-                        GenericParamAST::Lifetime(ld) => Some(ld),\n+                    bound_generic_params.iter().filter_map(|param| match param.kind {\n+                        GenericParamKindAST::Lifetime { .. } => Some(param),\n                         _ => None,\n                     }),\n                     |this| {\n@@ -2412,8 +2415,8 @@ impl<'a> LoweringContext<'a> {\n                 );\n \n                 let new_impl_items = self.with_in_scope_lifetime_defs(\n-                    ast_generics.params.iter().filter_map(|p| match p {\n-                        GenericParamAST::Lifetime(ld) => Some(ld),\n+                    ast_generics.params.iter().filter_map(|param| match param.kind {\n+                        GenericParamKindAST::Lifetime { .. } => Some(param),\n                         _ => None,\n                     }),\n                     |this| {"}, {"sha": "6015063aa821f8e873743d50ee26bceb301648c9", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -171,24 +171,17 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParamAST) {\n-        match *param {\n-            GenericParamAST::Lifetime(ref lifetime_def) => {\n-                self.create_def(\n-                    lifetime_def.lifetime.id,\n-                    DefPathData::LifetimeDef(lifetime_def.lifetime.ident.name.as_interned_str()),\n-                    REGULAR_SPACE,\n-                    lifetime_def.lifetime.ident.span\n-                );\n-            }\n-            GenericParamAST::Type(ref ty_param) => {\n-                self.create_def(\n-                    ty_param.id,\n-                    DefPathData::TypeParam(ty_param.ident.name.as_interned_str()),\n-                    REGULAR_SPACE,\n-                    ty_param.ident.span\n-                );\n-            }\n-        }\n+        let name = param.ident.name.as_interned_str();\n+        let def_path_data = match param.kind {\n+            GenericParamKindAST::Lifetime { .. } => DefPathData::LifetimeDef(name),\n+            GenericParamKindAST::Type { .. } => DefPathData::TypeParam(name),\n+        };\n+        self.create_def(\n+            param.id,\n+            def_path_data,\n+            REGULAR_SPACE,\n+            param.ident.span\n+        );\n \n         visit::walk_generic_param(self, param);\n     }"}, {"sha": "d7ebd40f49b44a29b77a4e0efa075bac77608b44", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 40, "deletions": 48, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -139,29 +139,23 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_late_bound_lifetime_defs(&self, params: &Vec<GenericParamAST>) {\n-        // Check: Only lifetime parameters\n-        let non_lifetime_param_spans : Vec<_> = params.iter()\n-            .filter_map(|param| match *param {\n-                GenericParamAST::Lifetime(_) => None,\n-                GenericParamAST::Type(ref t) => Some(t.ident.span),\n-            }).collect();\n-        if !non_lifetime_param_spans.is_empty() {\n-            self.err_handler().span_err(non_lifetime_param_spans,\n-                \"only lifetime parameters can be used in this context\");\n-        }\n-\n-        // Check: No bounds on lifetime parameters\n-        for param in params.iter() {\n-            match *param {\n-                GenericParamAST::Lifetime(ref l) => {\n-                    if !l.bounds.is_empty() {\n-                        let spans: Vec<_> = l.bounds.iter().map(|b| b.ident.span).collect();\n+        // Check only lifetime parameters are present and that the lifetime\n+        // parameters that are present have no bounds.\n+        let non_lifetime_param_spans: Vec<_> = params.iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKindAST::Lifetime { ref bounds, .. } => {\n+                    if !bounds.is_empty() {\n+                        let spans: Vec<_> = bounds.iter().map(|b| b.ident.span).collect();\n                         self.err_handler().span_err(spans,\n                             \"lifetime bounds cannot be used in this context\");\n                     }\n+                    None\n                 }\n-                GenericParamAST::Type(_) => {}\n-            }\n+                _ => Some(param.ident.span),\n+            }).collect();\n+        if !non_lifetime_param_spans.is_empty() {\n+            self.err_handler().span_err(non_lifetime_param_spans,\n+                \"only lifetime parameters can be used in this context\");\n         }\n     }\n }\n@@ -335,22 +329,21 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::TraitAlias(Generics { ref params, .. }, ..) => {\n                 for param in params {\n-                    if let GenericParamAST::Type(TyParam {\n-                        ident,\n-                        ref bounds,\n-                        ref default,\n-                        ..\n-                    }) = *param\n-                    {\n-                        if !bounds.is_empty() {\n-                            self.err_handler().span_err(ident.span,\n-                                                        \"type parameters on the left side of a \\\n-                                                         trait alias cannot be bounded\");\n-                        }\n-                        if !default.is_none() {\n-                            self.err_handler().span_err(ident.span,\n-                                                        \"type parameters on the left side of a \\\n-                                                         trait alias cannot have defaults\");\n+                    match param.kind {\n+                        GenericParamKindAST::Lifetime { .. } => {}\n+                        GenericParamKindAST::Type { ref bounds, ref default, .. } => {\n+                            if !bounds.is_empty() {\n+                                self.err_handler().span_err(param.ident.span,\n+                                                            \"type parameters on the left side \\\n+                                                             of a trait alias cannot be \\\n+                                                             bounded\");\n+                            }\n+                            if !default.is_none() {\n+                                self.err_handler().span_err(param.ident.span,\n+                                                            \"type parameters on the left side \\\n+                                                             of a trait alias cannot have \\\n+                                                             defaults\");\n+                            }\n                         }\n                     }\n                 }\n@@ -413,24 +406,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         let mut seen_non_lifetime_param = false;\n         let mut seen_default = None;\n         for param in &g.params {\n-            match (param, seen_non_lifetime_param) {\n-                (&GenericParamAST::Lifetime(ref ld), true) => {\n+            match (&param.kind, seen_non_lifetime_param) {\n+                (GenericParamKindAST::Lifetime { .. }, true) => {\n                     self.err_handler()\n-                        .span_err(ld.lifetime.ident.span, \"lifetime parameters must be leading\");\n+                        .span_err(param.ident.span, \"lifetime parameters must be leading\");\n                 },\n-                (&GenericParamAST::Lifetime(_), false) => {}\n-                _ => {\n+                (GenericParamKindAST::Lifetime { .. }, false) => {}\n+                (GenericParamKindAST::Type { ref default, .. }, _) => {\n                     seen_non_lifetime_param = true;\n+                    if default.is_some() {\n+                        seen_default = Some(param.ident.span);\n+                    } else if let Some(span) = seen_default {\n+                        self.err_handler()\n+                            .span_err(span, \"type parameters with a default must be trailing\");\n+                        break;\n+                    }\n                 }\n             }\n-\n-            if let GenericParamAST::Type(ref ty_param @ TyParam { default: Some(_), .. }) = *param {\n-                seen_default = Some(ty_param.ident.span);\n-            } else if let Some(span) = seen_default {\n-                self.err_handler()\n-                    .span_err(span, \"type parameters with a default must be trailing\");\n-                break\n-            }\n         }\n         for predicate in &g.where_clause.predicates {\n             if let WherePredicate::EqPredicate(ref predicate) = *predicate {"}, {"sha": "37264eb3382287a227e93af431526318c468a56e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -56,7 +56,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n-use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamAST, Generics};\n+use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKindAST, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n@@ -797,31 +797,43 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         // put all the parameters on the ban list and then remove\n         // them one by one as they are processed and become available.\n         let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n+        let mut found_default = false;\n         default_ban_rib.bindings.extend(generics.params.iter()\n-            .filter_map(|p| if let GenericParamAST::Type(ref tp) = *p { Some(tp) } else { None })\n-            .skip_while(|p| p.default.is_none())\n-            .map(|p| (Ident::with_empty_ctxt(p.ident.name), Def::Err)));\n+            .filter_map(|param| match param.kind {\n+                GenericParamKindAST::Lifetime { .. } => None,\n+                GenericParamKindAST::Type { ref default, .. } => {\n+                    if default.is_some() {\n+                        found_default = true;\n+                    }\n+                    if found_default {\n+                        return Some((Ident::with_empty_ctxt(param.ident.name), Def::Err));\n+                    }\n+                    None\n+                }\n+            }));\n \n         for param in &generics.params {\n-            match *param {\n-                GenericParamAST::Lifetime(_) => self.visit_generic_param(param),\n-                GenericParamAST::Type(ref ty_param) => {\n-                    for bound in &ty_param.bounds {\n+            match param.kind {\n+                GenericParamKindAST::Lifetime { .. } => self.visit_generic_param(param),\n+                GenericParamKindAST::Type { ref bounds, ref default, .. } => {\n+                    for bound in bounds {\n                         self.visit_ty_param_bound(bound);\n                     }\n \n-                    if let Some(ref ty) = ty_param.default {\n+                    if let Some(ref ty) = default {\n                         self.ribs[TypeNS].push(default_ban_rib);\n                         self.visit_ty(ty);\n                         default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n                     }\n \n                     // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(ty_param.ident.name));\n+                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n                 }\n             }\n         }\n-        for p in &generics.where_clause.predicates { self.visit_where_predicate(p); }\n+        for p in &generics.where_clause.predicates {\n+            self.visit_where_predicate(p);\n+        }\n     }\n }\n \n@@ -2198,25 +2210,28 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n                 for param in &generics.params {\n-                    if let GenericParamAST::Type(ref type_parameter) = *param {\n-                        let ident = type_parameter.ident.modern();\n-                        debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n-\n-                        if seen_bindings.contains_key(&ident) {\n-                            let span = seen_bindings.get(&ident).unwrap();\n-                            let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n-                                ident.name,\n-                                span,\n-                            );\n-                            resolve_error(self, type_parameter.ident.span, err);\n-                        }\n-                        seen_bindings.entry(ident).or_insert(type_parameter.ident.span);\n+                    match param.kind {\n+                        GenericParamKindAST::Type { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_type_parameter_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                    ident.name,\n+                                    span,\n+                                );\n+                                resolve_error(self, param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                        // plain insert (no renaming)\n-                        let def_id = self.definitions.local_def_id(type_parameter.id);\n-                        let def = Def::TyParam(def_id);\n-                        function_type_rib.bindings.insert(ident, def);\n-                        self.record_def(type_parameter.id, PathResolution::new(def));\n+                            // plain insert (no renaming)\n+                            let def_id = self.definitions.local_def_id(param.id);\n+                            let def = Def::TyParam(def_id);\n+                            function_type_rib.bindings.insert(ident, def);\n+                            self.record_def(param.id, PathResolution::new(def));\n+                        }\n+                        _ => {}\n                     }\n                 }\n                 self.ribs[TypeNS].push(function_type_rib);"}, {"sha": "94552e08a8cea7c4e0667f862fbb309869cc6cb7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -370,35 +370,38 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         id: NodeId,\n     ) {\n         for param in &generics.params {\n-            if let ast::GenericParamAST::Type(ref ty_param) = *param {\n-                let param_ss = ty_param.ident.span;\n-                let name = escape(self.span.snippet(param_ss));\n-                // Append $id to name to make sure each one is unique\n-                let qualname = format!(\"{}::{}${}\", prefix, name, id);\n-                if !self.span.filter_generated(Some(param_ss), full_span) {\n-                    let id = ::id_from_node_id(ty_param.id, &self.save_ctxt);\n-                    let span = self.span_from_span(param_ss);\n+            match param.kind {\n+                ast::GenericParamKindAST::Lifetime { .. } => {}\n+                ast::GenericParamKindAST::Type { .. } => {\n+                    let param_ss = param.ident.span;\n+                    let name = escape(self.span.snippet(param_ss));\n+                    // Append $id to name to make sure each one is unique.\n+                    let qualname = format!(\"{}::{}${}\", prefix, name, id);\n+                    if !self.span.filter_generated(Some(param_ss), full_span) {\n+                        let id = ::id_from_node_id(param.id, &self.save_ctxt);\n+                        let span = self.span_from_span(param_ss);\n \n-                    self.dumper.dump_def(\n-                        &Access {\n-                            public: false,\n-                            reachable: false,\n-                        },\n-                        Def {\n-                            kind: DefKind::Type,\n-                            id,\n-                            span,\n-                            name,\n-                            qualname,\n-                            value: String::new(),\n-                            parent: None,\n-                            children: vec![],\n-                            decl_id: None,\n-                            docs: String::new(),\n-                            sig: None,\n-                            attributes: vec![],\n-                        },\n-                    );\n+                        self.dumper.dump_def(\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n+                            Def {\n+                                kind: DefKind::Type,\n+                                id,\n+                                span,\n+                                name,\n+                                qualname,\n+                                value: String::new(),\n+                                parent: None,\n+                                children: vec![],\n+                                decl_id: None,\n+                                docs: String::new(),\n+                                sig: None,\n+                                attributes: vec![],\n+                            },\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -1479,14 +1482,17 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n \n     fn visit_generics(&mut self, generics: &'l ast::Generics) {\n         for param in &generics.params {\n-            if let ast::GenericParamAST::Type(ref ty_param) = *param {\n-                for bound in ty_param.bounds.iter() {\n-                    if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                        self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+            match param.kind {\n+                ast::GenericParamKindAST::Lifetime { .. } => {}\n+                ast::GenericParamKindAST::Type { ref bounds, ref default, .. } => {\n+                    for bound in bounds {\n+                        if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n+                            self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n+                        }\n+                    }\n+                    if let Some(ref ty) = default {\n+                        self.visit_ty(&ty);\n                     }\n-                }\n-                if let Some(ref ty) = ty_param.default {\n-                    self.visit_ty(&ty);\n                 }\n             }\n         }"}, {"sha": "f656b013c0a01ec9e817c37bb847e9e339000955", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -934,9 +934,9 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n         sig.push_str(&generics\n             .params\n             .iter()\n-            .map(|param| match *param {\n-                ast::GenericParamAST::Lifetime(ref l) => l.lifetime.ident.name.to_string(),\n-                ast::GenericParamAST::Type(ref t) => t.ident.to_string(),\n+            .map(|param| match param.kind {\n+                ast::GenericParamKindAST::Lifetime { .. } => param.ident.name.to_string(),\n+                ast::GenericParamKindAST::Type { .. } => param.ident.to_string(),\n             })\n             .collect::<Vec<_>>()\n             .join(\", \"));"}, {"sha": "8e8e0dfa1828e57e70ec97db3babe0107b39141c", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -223,9 +223,9 @@ impl Sig for ast::Ty {\n                     text.push_str(\"for<\");\n                     text.push_str(&f.generic_params\n                         .iter()\n-                        .filter_map(|p| match *p {\n-                            ast::GenericParamAST::Lifetime(ref l) => {\n-                                Some(l.lifetime.ident.to_string())\n+                        .filter_map(|param| match param.kind {\n+                            ast::GenericParamKindAST::Lifetime { .. } => {\n+                                Some(param.ident.to_string())\n                             }\n                             _ => None,\n                         })\n@@ -617,45 +617,34 @@ impl Sig for ast::Generics {\n \n         let mut defs = vec![];\n         for param in &self.params {\n-            match *param {\n-                ast::GenericParamAST::Lifetime(ref l) => {\n-                    let mut l_text = l.lifetime.ident.to_string();\n-                    defs.push(SigElement {\n-                        id: id_from_node_id(l.lifetime.id, scx),\n-                        start: offset + text.len(),\n-                        end: offset + text.len() + l_text.len(),\n-                    });\n-\n-                    if !l.bounds.is_empty() {\n-                        l_text.push_str(\": \");\n-                        let bounds = l.bounds\n-                            .iter()\n+            let mut param_text = param.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(param.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + param_text.len(),\n+            });\n+            match param.kind {\n+                ast::GenericParamKindAST::Lifetime { ref bounds, .. } => {\n+                    if !bounds.is_empty() {\n+                        param_text.push_str(\": \");\n+                        let bounds = bounds.iter()\n                             .map(|l| l.ident.to_string())\n                             .collect::<Vec<_>>()\n                             .join(\" + \");\n-                        l_text.push_str(&bounds);\n+                        param_text.push_str(&bounds);\n                         // FIXME add lifetime bounds refs.\n                     }\n-                    text.push_str(&l_text);\n-                    text.push(',');\n                 }\n-                ast::GenericParamAST::Type(ref t) => {\n-                    let mut t_text = t.ident.to_string();\n-                    defs.push(SigElement {\n-                        id: id_from_node_id(t.id, scx),\n-                        start: offset + text.len(),\n-                        end: offset + text.len() + t_text.len(),\n-                    });\n-\n-                    if !t.bounds.is_empty() {\n-                        t_text.push_str(\": \");\n-                        t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n+                ast::GenericParamKindAST::Type { ref bounds, .. } => {\n+                    if !bounds.is_empty() {\n+                        param_text.push_str(\": \");\n+                        param_text.push_str(&pprust::bounds_to_string(bounds));\n                         // FIXME descend properly into bounds.\n                     }\n-                    text.push_str(&t_text);\n-                    text.push(',');\n                 }\n             }\n+            text.push_str(&param_text);\n+            text.push(',');\n         }\n \n         text.push('>');"}, {"sha": "c354edc5aaff4abbc67b081efa84f549d3786d6f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -58,14 +58,6 @@ impl fmt::Debug for Lifetime {\n     }\n }\n \n-/// A lifetime definition, e.g. `'a: 'b+'c+'d`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct LifetimeDef {\n-    pub attrs: ThinVec<Attribute>,\n-    pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>\n-}\n-\n /// A \"Path\" is essentially Rust's notion of a name.\n ///\n /// It's represented as a sequence of identifiers,\n@@ -329,31 +321,38 @@ pub enum TraitBoundModifier {\n pub type TyParamBounds = Vec<TyParamBound>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct TyParam {\n-    pub attrs: ThinVec<Attribute>,\n-    pub ident: Ident,\n-    pub id: NodeId,\n-    pub bounds: TyParamBounds,\n-    pub default: Option<P<Ty>>,\n+pub enum GenericParamKindAST {\n+    /// A lifetime definition, e.g. `'a: 'b+'c+'d`.\n+    Lifetime {\n+        bounds: Vec<Lifetime>,\n+        lifetime: Lifetime,\n+    },\n+    Type {\n+        bounds: TyParamBounds,\n+        default: Option<P<Ty>>,\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum GenericParamAST {\n-    Lifetime(LifetimeDef),\n-    Type(TyParam),\n+pub struct GenericParamAST {\n+    pub ident: Ident,\n+    pub id: NodeId,\n+    pub attrs: ThinVec<Attribute>,\n+\n+    pub kind: GenericParamKindAST,\n }\n \n impl GenericParamAST {\n     pub fn is_lifetime_param(&self) -> bool {\n-        match *self {\n-            GenericParamAST::Lifetime(_) => true,\n+        match self.kind {\n+            GenericParamKindAST::Lifetime { .. } => true,\n             _ => false,\n         }\n     }\n \n     pub fn is_type_param(&self) -> bool {\n-        match *self {\n-            GenericParamAST::Type(_) => true,\n+        match self.kind {\n+            GenericParamKindAST::Type { .. } => true,\n             _ => false,\n         }\n     }\n@@ -383,10 +382,8 @@ impl Generics {\n \n     pub fn span_for_name(&self, name: &str) -> Option<Span> {\n         for param in &self.params {\n-            if let GenericParamAST::Type(ref t) = *param {\n-                if t.ident.name == name {\n-                    return Some(t.ident.span);\n-                }\n+            if param.ident.name == name {\n+                return Some(param.ident.span);\n             }\n         }\n         None"}, {"sha": "42745c14965a369a4d8298bd831dc04ebdbb0a0f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -69,7 +69,7 @@ pub trait AstBuilder {\n                id: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n                bounds: ast::TyParamBounds,\n-               default: Option<P<ast::Ty>>) -> ast::TyParam;\n+               default: Option<P<ast::Ty>>) -> ast::GenericParamAST;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n     fn poly_trait_ref(&self, span: Span, path: ast::Path) -> ast::PolyTraitRef;\n@@ -80,7 +80,7 @@ pub trait AstBuilder {\n                     ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n                     bounds: Vec<ast::Lifetime>)\n-                    -> ast::LifetimeDef;\n+                    -> ast::GenericParamAST;\n \n     // statements\n     fn stmt_expr(&self, expr: P<ast::Expr>) -> ast::Stmt;\n@@ -437,13 +437,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                ident: ast::Ident,\n                attrs: Vec<ast::Attribute>,\n                bounds: ast::TyParamBounds,\n-               default: Option<P<ast::Ty>>) -> ast::TyParam {\n-        ast::TyParam {\n+               default: Option<P<ast::Ty>>) -> ast::GenericParamAST {\n+        ast::GenericParamAST {\n             ident: ident.with_span_pos(span),\n             id: ast::DUMMY_NODE_ID,\n             attrs: attrs.into(),\n-            bounds,\n-            default,\n+            kind: ast::GenericParamKindAST::Type {\n+                bounds,\n+                default,\n+            }\n         }\n     }\n \n@@ -475,11 +477,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                     ident: ast::Ident,\n                     attrs: Vec<ast::Attribute>,\n                     bounds: Vec<ast::Lifetime>)\n-                    -> ast::LifetimeDef {\n-        ast::LifetimeDef {\n+                    -> ast::GenericParamAST {\n+        let lifetime = self.lifetime(span, ident);\n+        ast::GenericParamAST {\n+            ident: lifetime.ident,\n+            id: lifetime.id,\n             attrs: attrs.into(),\n-            lifetime: self.lifetime(span, ident),\n-            bounds,\n+            kind: ast::GenericParamKindAST::Lifetime {\n+                lifetime,\n+                bounds,\n+            }\n         }\n     }\n "}, {"sha": "2f43487e036acda3f219943ca3b5c3523706e075", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -687,38 +687,23 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n     }\n }\n \n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {attrs, id, ident, bounds, default} = tp;\n-    let attrs: Vec<_> = attrs.into();\n-    TyParam {\n-        attrs: attrs.into_iter()\n-            .flat_map(|x| fld.fold_attribute(x).into_iter())\n-            .collect::<Vec<_>>()\n-            .into(),\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n-    }\n-}\n-\n pub fn noop_fold_generic_param<T: Folder>(param: GenericParamAST, fld: &mut T) -> GenericParamAST {\n     match param {\n-        GenericParamAST::Lifetime(l) => {\n-            let attrs: Vec<_> = l.attrs.into();\n+        GenericParamAST::Lifetime { bounds, lifetime } => {\n+            let attrs: Vec<_> = param.attrs.into();\n             GenericParamAST::Lifetime(LifetimeDef {\n                 attrs: attrs.into_iter()\n                     .flat_map(|x| fld.fold_attribute(x).into_iter())\n                     .collect::<Vec<_>>()\n                     .into(),\n                 lifetime: Lifetime {\n-                    id: fld.new_id(l.lifetime.id),\n-                    ident: fld.fold_ident(l.lifetime.ident),\n+                    id: fld.new_id(param.id),\n+                    ident: fld.fold_ident(param.ident),\n                 },\n-                bounds: l.bounds.move_map(|l| noop_fold_lifetime(l, fld)),\n+                bounds: bounds.move_map(|l| noop_fold_lifetime(l, fld)),\n             })\n         }\n-        GenericParamAST::Type(t) => GenericParamAST::Type(fld.fold_ty_param(t)),\n+        GenericParamAST::Type { .. } => GenericParamAST::Type(fld.fold_ty_param(param)),\n     }\n }\n "}, {"sha": "2a1fc6b291c31a4aae984a7818aeac2e192eaeca", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -21,10 +21,10 @@ use ast::EnumDef;\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n-use ast::GenericParamAST;\n+use ast::{GenericParamAST, GenericParamKindAST};\n use ast::GenericArgAST;\n use ast::{Ident, ImplItem, IsAuto, Item, ItemKind};\n-use ast::{Label, Lifetime, LifetimeDef, Lit, LitKind};\n+use ast::{Label, Lifetime, Lit, LitKind};\n use ast::Local;\n use ast::MacStmtStyle;\n use ast::{Mac, Mac_, MacDelimiter};\n@@ -36,7 +36,7 @@ use ast::{VariantData, StructField};\n use ast::StrStyle;\n use ast::SelfKind;\n use ast::{TraitItem, TraitRef, TraitObjectSyntax};\n-use ast::{Ty, TyKind, TypeBinding, TyParam, TyParamBounds};\n+use ast::{Ty, TyKind, TypeBinding, TyParamBounds};\n use ast::{Visibility, VisibilityKind, WhereClause, CrateSugar};\n use ast::{UseTree, UseTreeKind};\n use ast::{BinOpKind, UnOp};\n@@ -1311,9 +1311,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n \n         let (name, node, generics) = if self.eat_keyword(keywords::Type) {\n-            let (generics, TyParam {ident, bounds, default, ..}) =\n-                self.parse_trait_item_assoc_ty(vec![])?;\n-            (ident, TraitItemKind::Type(bounds, default), generics)\n+            self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n             self.expect_keyword(keywords::Const)?;\n             let ident = self.parse_ident()?;\n@@ -4805,7 +4803,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n-    fn parse_ty_param(&mut self, preceding_attrs: Vec<Attribute>) -> PResult<'a, TyParam> {\n+    fn parse_ty_param(&mut self,\n+                      preceding_attrs: Vec<Attribute>)\n+                      -> PResult<'a, GenericParamAST> {\n         let ident = self.parse_ident()?;\n \n         // Parse optional colon and param bounds.\n@@ -4821,19 +4821,21 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n-        Ok(TyParam {\n-            attrs: preceding_attrs.into(),\n+        Ok(GenericParamAST {\n             ident,\n+            attrs: preceding_attrs.into(),\n             id: ast::DUMMY_NODE_ID,\n-            bounds,\n-            default,\n+            kind: GenericParamKindAST::Type {\n+                bounds,\n+                default,\n+            }\n         })\n     }\n \n     /// Parses the following grammar:\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [TyParamBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self, preceding_attrs: Vec<Attribute>)\n-        -> PResult<'a, (ast::Generics, TyParam)> {\n+    fn parse_trait_item_assoc_ty(&mut self)\n+        -> PResult<'a, (Ident, TraitItemKind, ast::Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -4852,13 +4854,7 @@ impl<'a> Parser<'a> {\n         };\n         self.expect(&token::Semi)?;\n \n-        Ok((generics, TyParam {\n-            attrs: preceding_attrs.into(),\n-            ident,\n-            id: ast::DUMMY_NODE_ID,\n-            bounds,\n-            default,\n-        }))\n+        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n     }\n \n     /// Parses (possibly empty) list of lifetime and type parameters, possibly including\n@@ -4876,18 +4872,22 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Vec::new()\n                 };\n-                params.push(ast::GenericParamAST::Lifetime(LifetimeDef {\n+                params.push(ast::GenericParamAST {\n+                    ident: lifetime.ident,\n+                    id: lifetime.id,\n                     attrs: attrs.into(),\n-                    lifetime,\n-                    bounds,\n-                }));\n+                    kind: ast::GenericParamKindAST::Lifetime {\n+                        lifetime,\n+                        bounds,\n+                    }\n+                });\n                 if seen_ty_param {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n                 }\n             } else if self.check_ident() {\n                 // Parse type parameter.\n-                params.push(ast::GenericParamAST::Type(self.parse_ty_param(attrs)?));\n+                params.push(self.parse_ty_param(attrs)?);\n                 seen_ty_param = true;\n             } else {\n                 // Check for trailing attributes and stop parsing."}, {"sha": "1626135400de83c43d4a35552ac04bc685320d9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -2878,33 +2878,31 @@ impl<'a> State<'a> {\n         self.s.word(\"<\")?;\n \n         self.commasep(Inconsistent, &generic_params, |s, param| {\n-            match *param {\n-                ast::GenericParamAST::Lifetime(ref lifetime_def) => {\n-                    s.print_outer_attributes_inline(&lifetime_def.attrs)?;\n-                    s.print_lifetime_bounds(&lifetime_def.lifetime, &lifetime_def.bounds)\n+            match param.kind {\n+                ast::GenericParamKindAST::Lifetime { ref bounds, ref lifetime } => {\n+                    s.print_outer_attributes_inline(&param.attrs)?;\n+                    s.print_lifetime_bounds(lifetime, bounds)\n                 },\n-                ast::GenericParamAST::Type(ref ty_param) => s.print_ty_param(ty_param),\n+                ast::GenericParamKindAST::Type { ref bounds, ref default } => {\n+                    s.print_outer_attributes_inline(&param.attrs)?;\n+                    s.print_ident(param.ident)?;\n+                    s.print_bounds(\":\", bounds)?;\n+                    match default {\n+                        Some(ref default) => {\n+                            s.s.space()?;\n+                            s.word_space(\"=\")?;\n+                            s.print_type(default)\n+                        }\n+                        _ => Ok(())\n+                    }\n+                }\n             }\n         })?;\n \n         self.s.word(\">\")?;\n         Ok(())\n     }\n \n-    pub fn print_ty_param(&mut self, param: &ast::TyParam) -> io::Result<()> {\n-        self.print_outer_attributes_inline(&param.attrs)?;\n-        self.print_ident(param.ident)?;\n-        self.print_bounds(\":\", &param.bounds)?;\n-        match param.default {\n-            Some(ref default) => {\n-                self.s.space()?;\n-                self.word_space(\"=\")?;\n-                self.print_type(default)\n-            }\n-            _ => Ok(())\n-        }\n-    }\n-\n     pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n         if where_clause.predicates.is_empty() {"}, {"sha": "c919f6c355c09efab24d584e84242745efbb8c54", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -491,17 +491,17 @@ pub fn walk_ty_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a TyPar\n }\n \n pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParamAST) {\n-    match *param {\n-        GenericParamAST::Lifetime(ref l) => {\n-            visitor.visit_ident(l.lifetime.ident);\n-            walk_list!(visitor, visit_lifetime, &l.bounds);\n-            walk_list!(visitor, visit_attribute, &*l.attrs);\n+    match param.kind {\n+        GenericParamKindAST::Lifetime { ref bounds, ref lifetime, .. } => {\n+            visitor.visit_ident(param.ident);\n+            walk_list!(visitor, visit_lifetime, bounds);\n+            walk_list!(visitor, visit_attribute, param.attrs.iter());\n         }\n-        GenericParamAST::Type(ref t) => {\n+        GenericParamKindAST::Type { ref bounds, ref default, .. } => {\n             visitor.visit_ident(t.ident);\n-            walk_list!(visitor, visit_ty_param_bound, &t.bounds);\n-            walk_list!(visitor, visit_ty, &t.default);\n-            walk_list!(visitor, visit_attribute, &*t.attrs);\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, default);\n+            walk_list!(visitor, visit_attribute, param.attrs.iter());\n         }\n     }\n }"}, {"sha": "cbf7b1e08761321154be3290b3334ebe9258ccf9", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -192,8 +192,8 @@ use std::collections::HashSet;\n use std::vec;\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, BinOpKind, EnumDef, Expr, GenericParamAST, Generics, Ident, PatKind};\n-use syntax::ast::{VariantData, GenericArgAST};\n+use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n+use syntax::ast::{VariantData, GenericParamKindAST, GenericArgAST};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n@@ -547,9 +547,9 @@ impl<'a> TraitDef<'a> {\n \n         // Create the generic parameters\n         params.extend(generics.params.iter().map(|param| {\n-            match *param {\n-                ref l @ GenericParamAST::Lifetime(_) => l.clone(),\n-                GenericParamAST::Type(ref ty_param) => {\n+            match param.kind {\n+                GenericParamKindAST::Lifetime { .. } => param.clone(),\n+                GenericParamKindAST::Type { bounds: ref ty_bounds, .. } => {\n                     // I don't think this can be moved out of the loop, since\n                     // a TyParamBound requires an ast id\n                     let mut bounds: Vec<_> =\n@@ -564,12 +564,11 @@ impl<'a> TraitDef<'a> {\n                     bounds.push(cx.typarambound(trait_path.clone()));\n \n                     // also add in any bounds from the declaration\n-                    for declared_bound in ty_param.bounds.iter() {\n+                    for declared_bound in ty_bounds {\n                         bounds.push((*declared_bound).clone());\n                     }\n \n-                    let ty_param = cx.typaram(self.span, ty_param.ident, vec![], bounds, None);\n-                    GenericParamAST::Type(ty_param)\n+                    cx.typaram(self.span, param.ident, vec![], bounds, None)\n                 }\n             }\n         }));\n@@ -607,8 +606,8 @@ impl<'a> TraitDef<'a> {\n             // Extra scope required here so ty_params goes out of scope before params is moved\n \n             let mut ty_params = params.iter()\n-                .filter_map(|param| match *param {\n-                    ast::GenericParamAST::Type(ref t) => Some(t),\n+                .filter_map(|param| match param.kind {\n+                    ast::GenericParamKindAST::Type { .. } => Some(param),\n                     _ => None,\n                 })\n                 .peekable();\n@@ -668,17 +667,16 @@ impl<'a> TraitDef<'a> {\n         // Create the type parameters on the `self` path.\n         let self_ty_params: Vec<P<ast::Ty>> = generics.params\n             .iter()\n-            .filter_map(|param| match *param {\n-                GenericParamAST::Type(ref ty_param)\n-                    => Some(cx.ty_ident(self.span, ty_param.ident)),\n+            .filter_map(|param| match param.kind {\n+                GenericParamKindAST::Type { .. } => Some(cx.ty_ident(self.span, param.ident)),\n                 _ => None,\n             })\n             .collect();\n \n         let self_lifetimes: Vec<ast::Lifetime> = generics.params\n             .iter()\n-            .filter_map(|param| match *param {\n-                GenericParamAST::Lifetime(ref ld) => Some(ld.lifetime),\n+            .filter_map(|param| match param.kind {\n+                GenericParamKindAST::Lifetime { ref lifetime, .. } => Some(*lifetime),\n                 _ => None,\n             })\n             .collect();"}, {"sha": "c9f274ed210909e76a2e3147293a78e72980d1d7", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -15,7 +15,7 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr, GenericParamAST, Generics, Ident, SelfKind, GenericArgAST};\n+use syntax::ast::{Expr, GenericParamKindAST, Generics, Ident, SelfKind, GenericArgAST};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{respan, DUMMY_SP};\n@@ -191,18 +191,18 @@ impl<'a> Ty<'a> {\n             Self_ => {\n                 let ty_params: Vec<P<ast::Ty>> = self_generics.params\n                     .iter()\n-                    .filter_map(|param| match *param {\n-                        GenericParamAST::Type(ref ty_param) => {\n-                            Some(cx.ty_ident(span, ty_param.ident))\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKindAST::Type { .. } => {\n+                            Some(cx.ty_ident(span, param.ident))\n                         }\n                         _ => None,\n                     })\n                     .collect();\n \n                 let lifetimes: Vec<ast::Lifetime> = self_generics.params\n                     .iter()\n-                    .filter_map(|param| match *param {\n-                        GenericParamAST::Lifetime(ref ld) => Some(ld.lifetime),\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKindAST::Lifetime { ref lifetime, .. } => Some(*lifetime),\n                         _ => None,\n                     })\n                     .collect();\n@@ -234,7 +234,7 @@ fn mk_ty_param(cx: &ExtCtxt,\n                bounds: &[Path],\n                self_ident: Ident,\n                self_generics: &Generics)\n-               -> ast::TyParam {\n+               -> ast::GenericParamAST {\n     let bounds = bounds.iter()\n         .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n@@ -244,7 +244,7 @@ fn mk_ty_param(cx: &ExtCtxt,\n     cx.typaram(span, cx.ident_of(name), attrs.to_owned(), bounds, None)\n }\n \n-fn mk_generics(params: Vec<GenericParamAST>, span: Span) -> Generics {\n+fn mk_generics(params: Vec<ast::GenericParamAST>, span: Span) -> Generics {\n     Generics {\n         params,\n         where_clause: ast::WhereClause {\n@@ -282,16 +282,13 @@ impl<'a> LifetimeBounds<'a> {\n                 let bounds = bounds.iter()\n                     .map(|b| cx.lifetime(span, Ident::from_str(b)))\n                     .collect();\n-                let lifetime_def = cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds);\n-                GenericParamAST::Lifetime(lifetime_def)\n+                cx.lifetime_def(span, Ident::from_str(lt), vec![], bounds)\n             })\n             .chain(self.bounds\n                 .iter()\n                 .map(|t| {\n                     let (name, ref bounds) = *t;\n-                    GenericParamAST::Type(mk_ty_param(\n-                        cx, span, name, &[], &bounds, self_ty, self_generics\n-                    ))\n+                    mk_ty_param(cx, span, name, &[], &bounds, self_ty, self_generics)\n                 })\n             )\n             .collect();"}, {"sha": "6813ce4c265f9071c80e1de566d9d4069a18e614", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c6ff2469a94e37b9605a43bc861de66830a94d4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=2c6ff2469a94e37b9605a43bc861de66830a94d4", "patch": "@@ -134,9 +134,12 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n         match item.node {\n             ast::ItemKind::Struct(_, ast::Generics { ref params, .. }) |\n             ast::ItemKind::Enum(_, ast::Generics { ref params, .. }) => {\n-                for param in params.iter() {\n-                    if let ast::GenericParamAST::Type(ref ty) = *param {\n-                        typaram.push_str(&ty.ident.as_str());\n+                for param in params {\n+                    match param.kind {\n+                        ast::GenericParamKindAST::Type { .. } => {\n+                            typaram.push_str(&param.ident.as_str());\n+                        }\n+                        _ => {}\n                     }\n                 }\n             }"}]}