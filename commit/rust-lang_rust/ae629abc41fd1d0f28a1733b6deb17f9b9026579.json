{"sha": "ae629abc41fd1d0f28a1733b6deb17f9b9026579", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNjI5YWJjNDFmZDFkMGYyOGExNzMzYjZkZWIxN2Y5YjkwMjY1Nzk=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-07T06:40:52Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-09T05:07:43Z"}, "message": "Add overflow module\n\nThis commit adds `overflow` module. This module provides two APIs.\n`rewrite_with_parens` is basically the same as `rewrite_call_inner`.\n`rewrite_with_angle_brackets` is used for rewriting generics and types.", "tree": {"sha": "ad4009aa192e8b2dd452477ac76134c9cd58d2ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad4009aa192e8b2dd452477ac76134c9cd58d2ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae629abc41fd1d0f28a1733b6deb17f9b9026579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae629abc41fd1d0f28a1733b6deb17f9b9026579", "html_url": "https://github.com/rust-lang/rust/commit/ae629abc41fd1d0f28a1733b6deb17f9b9026579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae629abc41fd1d0f28a1733b6deb17f9b9026579/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8943c376bc7bdaf252c173aaf1b0f4f37de3f820", "url": "https://api.github.com/repos/rust-lang/rust/commits/8943c376bc7bdaf252c173aaf1b0f4f37de3f820", "html_url": "https://github.com/rust-lang/rust/commit/8943c376bc7bdaf252c173aaf1b0f4f37de3f820"}], "stats": {"total": 1022, "additions": 558, "deletions": 464}, "files": [{"sha": "e69dd15aa0eec393d9259a071232ef1891e2660d", "filename": "src/expr.rs", "status": "modified", "additions": 32, "deletions": 443, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -25,6 +25,7 @@ use config::{Config, ControlBraceStyle, IndentStyle};\n use lists::{definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting,\n             struct_lit_shape, struct_lit_tactic, write_list, ListFormatting, ListItem, Separator};\n use macros::{rewrite_macro, MacroArg, MacroPosition};\n+use overflow;\n use patterns::{can_be_overflowed_pat, TuplePatField};\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n@@ -523,7 +524,7 @@ fn array_tactic<T: Rewrite + Spanned + ToExpr>(\n                 None => DefinitiveListTactic::Vertical,\n             };\n             if tactic == DefinitiveListTactic::Vertical && !has_long_item\n-                && is_every_args_simple(exprs)\n+                && is_every_expr_simple(exprs)\n             {\n                 DefinitiveListTactic::Mixed\n             } else {\n@@ -1872,6 +1873,20 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     )\n }\n \n+/// In case special-case style is required, returns an offset from which we start horizontal layout.\n+pub fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n+    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n+        .iter()\n+        .find(|&&(s, _)| s == callee_str)\n+    {\n+        let all_simple = args.len() > num_args_before && is_every_expr_simple(args);\n+\n+        Some((all_simple, num_args_before))\n+    } else {\n+        None\n+    }\n+}\n+\n /// A list of `format!`-like macros, that take a long format string and a list of arguments to\n /// format.\n ///\n@@ -1913,297 +1928,22 @@ pub fn rewrite_call(\n     span: Span,\n     shape: Shape,\n ) -> Option<String> {\n-    let force_trailing_comma = if context.inside_macro {\n-        span_ends_with_comma(context, span)\n-    } else {\n-        false\n-    };\n-    rewrite_call_inner(\n+    overflow::rewrite_with_parens(\n         context,\n         callee,\n         &ptr_vec_to_ref_vec(args),\n-        span,\n         shape,\n+        span,\n         context.config.width_heuristics().fn_call_width,\n-        force_trailing_comma,\n-    )\n-}\n-\n-pub fn rewrite_call_inner<'a, T>(\n-    context: &RewriteContext,\n-    callee_str: &str,\n-    args: &[&T],\n-    span: Span,\n-    shape: Shape,\n-    args_max_width: usize,\n-    force_trailing_comma: bool,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    // 2 = `( `, 1 = `(`\n-    let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n-        2\n-    } else {\n-        1\n-    };\n-    let used_width = extra_offset(callee_str, shape);\n-    let one_line_width = shape\n-        .width\n-        .checked_sub(used_width + 2 * paren_overhead)\n-        .unwrap_or(0);\n-\n-    // 1 = \"(\" or \")\"\n-    let one_line_shape = shape\n-        .offset_left(last_line_width(callee_str) + 1)\n-        .and_then(|shape| shape.sub_width(1))\n-        .unwrap_or(Shape { width: 0, ..shape });\n-    let nested_shape = shape_from_indent_style(\n-        context,\n-        shape,\n-        used_width + 2 * paren_overhead,\n-        used_width + paren_overhead,\n-    )?;\n-\n-    let span_lo = context.snippet_provider.span_after(span, \"(\");\n-    let args_span = mk_sp(span_lo, span.hi());\n-\n-    let (extendable, list_str) = rewrite_call_args(\n-        context,\n-        args,\n-        args_span,\n-        one_line_shape,\n-        nested_shape,\n-        one_line_width,\n-        args_max_width,\n-        force_trailing_comma,\n-        callee_str,\n-    )?;\n-\n-    if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n-        let mut new_context = context.clone();\n-        new_context.use_block = true;\n-        return rewrite_call_inner(\n-            &new_context,\n-            callee_str,\n-            args,\n-            span,\n-            shape,\n-            args_max_width,\n-            force_trailing_comma,\n-        );\n-    }\n-\n-    let args_shape = Shape {\n-        width: shape\n-            .width\n-            .checked_sub(last_line_width(callee_str))\n-            .unwrap_or(0),\n-        ..shape\n-    };\n-    Some(format!(\n-        \"{}{}\",\n-        callee_str,\n-        wrap_args_with_parens(context, &list_str, extendable, args_shape, nested_shape)\n-    ))\n-}\n-\n-fn need_block_indent(s: &str, shape: Shape) -> bool {\n-    s.lines().skip(1).any(|s| {\n-        s.find(|c| !char::is_whitespace(c))\n-            .map_or(false, |w| w + 1 < shape.indent.width())\n-    })\n-}\n-\n-fn rewrite_call_args<'a, T>(\n-    context: &RewriteContext,\n-    args: &[&T],\n-    span: Span,\n-    one_line_shape: Shape,\n-    nested_shape: Shape,\n-    one_line_width: usize,\n-    args_max_width: usize,\n-    force_trailing_comma: bool,\n-    callee_str: &str,\n-) -> Option<(bool, String)>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    let items = itemize_list(\n-        context.snippet_provider,\n-        args.iter(),\n-        \")\",\n-        \",\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| item.rewrite(context, nested_shape),\n-        span.lo(),\n-        span.hi(),\n-        true,\n-    );\n-    let mut item_vec: Vec<_> = items.collect();\n-\n-    // Try letting the last argument overflow to the next line with block\n-    // indentation. If its first line fits on one line with the other arguments,\n-    // we format the function arguments horizontally.\n-    let tactic = try_overflow_last_arg(\n-        context,\n-        &mut item_vec,\n-        &args[..],\n-        one_line_shape,\n-        nested_shape,\n-        one_line_width,\n-        args_max_width,\n-        callee_str,\n-    );\n-\n-    let fmt = ListFormatting {\n-        tactic,\n-        separator: \",\",\n-        trailing_separator: if force_trailing_comma {\n-            SeparatorTactic::Always\n-        } else if context.inside_macro || !context.use_block_indent() {\n-            SeparatorTactic::Never\n+        if context.inside_macro {\n+            span_ends_with_comma(context, span)\n         } else {\n-            context.config.trailing_comma()\n+            false\n         },\n-        separator_place: SeparatorPlace::Back,\n-        shape: nested_shape,\n-        ends_with_newline: context.use_block_indent() && tactic == DefinitiveListTactic::Vertical,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-\n-    write_list(&item_vec, &fmt)\n-        .map(|args_str| (tactic == DefinitiveListTactic::Horizontal, args_str))\n-}\n-\n-fn try_overflow_last_arg<'a, T>(\n-    context: &RewriteContext,\n-    item_vec: &mut Vec<ListItem>,\n-    args: &[&T],\n-    one_line_shape: Shape,\n-    nested_shape: Shape,\n-    one_line_width: usize,\n-    args_max_width: usize,\n-    callee_str: &str,\n-) -> DefinitiveListTactic\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    // 1 = \"(\"\n-    let combine_arg_with_callee =\n-        callee_str.len() + 1 <= context.config.tab_spaces() && args.len() == 1;\n-    let overflow_last = combine_arg_with_callee || can_be_overflowed(context, args);\n-\n-    // Replace the last item with its first line to see if it fits with\n-    // first arguments.\n-    let placeholder = if overflow_last {\n-        let mut context = context.clone();\n-        if !combine_arg_with_callee {\n-            if let Some(expr) = args[args.len() - 1].to_expr() {\n-                if let ast::ExprKind::MethodCall(..) = expr.node {\n-                    context.force_one_line_chain = true;\n-                }\n-            }\n-        }\n-        last_arg_shape(args, item_vec, one_line_shape, args_max_width).and_then(|arg_shape| {\n-            rewrite_last_arg_with_overflow(&context, args, &mut item_vec[args.len() - 1], arg_shape)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    let mut tactic = definitive_tactic(\n-        &*item_vec,\n-        ListTactic::LimitedHorizontalVertical(args_max_width),\n-        Separator::Comma,\n-        one_line_width,\n-    );\n-\n-    // Replace the stub with the full overflowing last argument if the rewrite\n-    // succeeded and its first line fits with the other arguments.\n-    match (overflow_last, tactic, placeholder) {\n-        (true, DefinitiveListTactic::Horizontal, Some(ref overflowed)) if args.len() == 1 => {\n-            // When we are rewriting a nested function call, we restrict the\n-            // bugdet for the inner function to avoid them being deeply nested.\n-            // However, when the inner function has a prefix or a suffix\n-            // (e.g. `foo() as u32`), this budget reduction may produce poorly\n-            // formatted code, where a prefix or a suffix being left on its own\n-            // line. Here we explicitlly check those cases.\n-            if count_newlines(overflowed) == 1 {\n-                let rw = args.last()\n-                    .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n-                let no_newline = rw.as_ref().map_or(false, |s| !s.contains('\\n'));\n-                if no_newline {\n-                    item_vec[args.len() - 1].item = rw;\n-                } else {\n-                    item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n-                }\n-            } else {\n-                item_vec[args.len() - 1].item = Some(overflowed.to_owned());\n-            }\n-        }\n-        (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n-            item_vec[args.len() - 1].item = placeholder;\n-        }\n-        _ if args.len() >= 1 => {\n-            item_vec[args.len() - 1].item = args.last()\n-                .and_then(|last_arg| last_arg.rewrite(context, nested_shape));\n-\n-            let default_tactic = || {\n-                definitive_tactic(\n-                    &*item_vec,\n-                    ListTactic::LimitedHorizontalVertical(args_max_width),\n-                    Separator::Comma,\n-                    one_line_width,\n-                )\n-            };\n-\n-            // Use horizontal layout for a function with a single argument as long as\n-            // everything fits in a single line.\n-            if args.len() == 1\n-                && args_max_width != 0 // Vertical layout is forced.\n-                && !item_vec[0].has_comment()\n-                && !item_vec[0].inner_as_ref().contains('\\n')\n-                && ::lists::total_item_width(&item_vec[0]) <= one_line_width\n-            {\n-                tactic = DefinitiveListTactic::Horizontal;\n-            } else {\n-                tactic = default_tactic();\n-\n-                if tactic == DefinitiveListTactic::Vertical {\n-                    if let Some((all_simple, num_args_before)) =\n-                        maybe_get_args_offset(callee_str, args)\n-                    {\n-                        let one_line = all_simple\n-                            && definitive_tactic(\n-                                &item_vec[..num_args_before],\n-                                ListTactic::HorizontalVertical,\n-                                Separator::Comma,\n-                                nested_shape.width,\n-                            ) == DefinitiveListTactic::Horizontal\n-                            && definitive_tactic(\n-                                &item_vec[num_args_before + 1..],\n-                                ListTactic::HorizontalVertical,\n-                                Separator::Comma,\n-                                nested_shape.width,\n-                            ) == DefinitiveListTactic::Horizontal;\n-\n-                        if one_line {\n-                            tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n-                        };\n-                    }\n-                }\n-            }\n-        }\n-        _ => (),\n-    }\n-\n-    tactic\n+    )\n }\n \n-fn is_simple_arg(expr: &ast::Expr) -> bool {\n+fn is_simple_expr(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Lit(..) => true,\n         ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n@@ -2213,106 +1953,18 @@ fn is_simple_arg(expr: &ast::Expr) -> bool {\n         | ast::ExprKind::Field(ref expr, _)\n         | ast::ExprKind::Try(ref expr)\n         | ast::ExprKind::TupField(ref expr, _)\n-        | ast::ExprKind::Unary(_, ref expr) => is_simple_arg(expr),\n+        | ast::ExprKind::Unary(_, ref expr) => is_simple_expr(expr),\n         ast::ExprKind::Index(ref lhs, ref rhs) | ast::ExprKind::Repeat(ref lhs, ref rhs) => {\n-            is_simple_arg(lhs) && is_simple_arg(rhs)\n+            is_simple_expr(lhs) && is_simple_expr(rhs)\n         }\n         _ => false,\n     }\n }\n \n-fn is_every_args_simple<T: ToExpr>(lists: &[&T]) -> bool {\n+fn is_every_expr_simple<T: ToExpr>(lists: &[&T]) -> bool {\n     lists\n         .iter()\n-        .all(|arg| arg.to_expr().map_or(false, is_simple_arg))\n-}\n-\n-/// In case special-case style is required, returns an offset from which we start horizontal layout.\n-fn maybe_get_args_offset<T: ToExpr>(callee_str: &str, args: &[&T]) -> Option<(bool, usize)> {\n-    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n-        .iter()\n-        .find(|&&(s, _)| s == callee_str)\n-    {\n-        let all_simple = args.len() > num_args_before && is_every_args_simple(args);\n-\n-        Some((all_simple, num_args_before))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Returns a shape for the last argument which is going to be overflowed.\n-fn last_arg_shape<T>(\n-    lists: &[&T],\n-    items: &[ListItem],\n-    shape: Shape,\n-    args_max_width: usize,\n-) -> Option<Shape>\n-where\n-    T: Rewrite + Spanned + ToExpr,\n-{\n-    let is_nested_call = lists\n-        .iter()\n-        .next()\n-        .and_then(|item| item.to_expr())\n-        .map_or(false, is_nested_call);\n-    if items.len() == 1 && !is_nested_call {\n-        return Some(shape);\n-    }\n-    let offset = items.iter().rev().skip(1).fold(0, |acc, i| {\n-        // 2 = \", \"\n-        acc + 2 + i.inner_as_ref().len()\n-    });\n-    Shape {\n-        width: min(args_max_width, shape.width),\n-        ..shape\n-    }.offset_left(offset)\n-}\n-\n-fn rewrite_last_arg_with_overflow<'a, T>(\n-    context: &RewriteContext,\n-    args: &[&T],\n-    last_item: &mut ListItem,\n-    shape: Shape,\n-) -> Option<String>\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    let last_arg = args[args.len() - 1];\n-    let rewrite = if let Some(expr) = last_arg.to_expr() {\n-        match expr.node {\n-            // When overflowing the closure which consists of a single control flow expression,\n-            // force to use block if its condition uses multi line.\n-            ast::ExprKind::Closure(..) => {\n-                // If the argument consists of multiple closures, we do not overflow\n-                // the last closure.\n-                if closures::args_have_many_closure(args) {\n-                    None\n-                } else {\n-                    closures::rewrite_last_closure(context, expr, shape)\n-                }\n-            }\n-            _ => expr.rewrite(context, shape),\n-        }\n-    } else {\n-        last_arg.rewrite(context, shape)\n-    };\n-\n-    if let Some(rewrite) = rewrite {\n-        let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n-        last_item.item = rewrite_first_line;\n-        Some(rewrite)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n-where\n-    T: Rewrite + Spanned + ToExpr + 'a,\n-{\n-    args.last()\n-        .map_or(false, |x| x.can_be_overflowed(context, args.len()))\n+        .all(|arg| arg.to_expr().map_or(false, is_simple_expr))\n }\n \n pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n@@ -2348,7 +2000,7 @@ pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_l\n     }\n }\n \n-fn is_nested_call(expr: &ast::Expr) -> bool {\n+pub fn is_nested_call(expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Call(..) | ast::ExprKind::Mac(..) => true,\n         ast::ExprKind::AddrOf(_, ref expr)\n@@ -2360,55 +2012,10 @@ fn is_nested_call(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn wrap_args_with_parens(\n-    context: &RewriteContext,\n-    args_str: &str,\n-    is_extendable: bool,\n-    shape: Shape,\n-    nested_shape: Shape,\n-) -> String {\n-    let paren_overhead = paren_overhead(context);\n-    let fits_one_line = args_str.len() + paren_overhead <= shape.width;\n-    let extend_width = if args_str.is_empty() {\n-        paren_overhead\n-    } else {\n-        paren_overhead / 2\n-    };\n-    if !context.use_block_indent()\n-        || (context.inside_macro && !args_str.contains('\\n') && fits_one_line)\n-        || (is_extendable && extend_width <= shape.width)\n-    {\n-        let mut result = String::with_capacity(args_str.len() + 4);\n-        if context.config.spaces_within_parens_and_brackets() && !args_str.is_empty() {\n-            result.push_str(\"( \");\n-            result.push_str(args_str);\n-            result.push_str(\" )\");\n-        } else {\n-            result.push_str(\"(\");\n-            result.push_str(args_str);\n-            result.push_str(\")\");\n-        }\n-        result\n-    } else {\n-        let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n-        let indent_str = shape.block().indent.to_string_with_newline(context.config);\n-        let mut result =\n-            String::with_capacity(args_str.len() + 2 + indent_str.len() + nested_indent_str.len());\n-        result.push_str(\"(\");\n-        if !args_str.is_empty() {\n-            result.push_str(&nested_indent_str);\n-            result.push_str(args_str);\n-        }\n-        result.push_str(&indent_str);\n-        result.push_str(\")\");\n-        result\n-    }\n-}\n-\n /// Return true if a function call or a method call represented by the given span ends with a\n /// trailing comma. This function is used when rewriting macro, as adding or removing a trailing\n /// comma from macro can potentially break the code.\n-fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n+pub fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n     let mut result: bool = Default::default();\n     let mut prev_char: char = Default::default();\n \n@@ -2735,24 +2342,6 @@ pub fn rewrite_field(\n     }\n }\n \n-fn shape_from_indent_style(\n-    context: &RewriteContext,\n-    shape: Shape,\n-    overhead: usize,\n-    offset: usize,\n-) -> Option<Shape> {\n-    if context.use_block_indent() {\n-        // 1 = \",\"\n-        shape\n-            .block()\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config)\n-            .sub_width(1)\n-    } else {\n-        shape.visual_indent(offset).sub_width(overhead)\n-    }\n-}\n-\n fn rewrite_tuple_in_visual_indent_style<'a, T>(\n     context: &RewriteContext,\n     items: &[&T],\n@@ -2838,12 +2427,12 @@ where\n         } else {\n             items.len() == 1\n         };\n-        rewrite_call_inner(\n+        overflow::rewrite_with_parens(\n             context,\n-            &String::new(),\n+            \"\",\n             items,\n-            span,\n             shape,\n+            span,\n             context.config.width_heuristics().fn_call_width,\n             force_trailing_comma,\n         )"}, {"sha": "ac392ccf62e4d24d1df1dd4a2a3e5a6c3dbc173b", "filename": "src/items.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -23,10 +23,10 @@ use codemap::{LineRangeUtils, SpanUtils};\n use comment::{combine_strs_with_missing_comments, contains_comment, recover_comment_removed,\n               recover_missing_comment_in_span, rewrite_missing_comment, FindUncommented};\n use config::{BraceStyle, Config, Density, IndentStyle};\n-use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs,\n-           rewrite_call_inner, ExprType};\n+use expr::{format_expr, is_empty_block, is_simple_block_stmt, rewrite_assign_rhs, ExprType};\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n+use overflow;\n use shape::{Indent, Shape};\n use spanned::Spanned;\n use types::join_bounds;\n@@ -1309,8 +1309,15 @@ fn format_tuple_struct(\n     } else {\n         let shape = Shape::indented(offset, context.config).sub_width(1)?;\n         let fields = &fields.iter().collect::<Vec<_>>()[..];\n-        let one_line_width = context.config.width_heuristics().fn_call_width;\n-        result = rewrite_call_inner(context, &result, fields, span, shape, one_line_width, false)?;\n+        result = overflow::rewrite_with_parens(\n+            context,\n+            &result,\n+            fields,\n+            shape,\n+            span,\n+            context.config.width_heuristics().fn_call_width,\n+            false,\n+        )?;\n     }\n \n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n')"}, {"sha": "6f18094661c33ba07ea2b47b97f65cf8e79bc36d", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -74,6 +74,7 @@ mod lists;\n mod macros;\n mod missed_spans;\n pub mod modules;\n+mod overflow;\n mod patterns;\n mod reorder;\n mod rewrite;"}, {"sha": "db79fb9d576dd05988990c658bb75c093cea0972", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -34,8 +34,9 @@ use syntax::util::ThinVec;\n \n use codemap::SpanUtils;\n use comment::{contains_comment, remove_trailing_white_spaces, FindUncommented};\n-use expr::{rewrite_array, rewrite_call_inner};\n+use expr::rewrite_array;\n use lists::{itemize_list, write_list, ListFormatting};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use utils::{format_visibility, mk_sp, wrap_str};\n@@ -223,14 +224,14 @@ pub fn rewrite_macro(\n \n     match style {\n         MacroStyle::Parens => {\n-            // Format macro invocation as function call, forcing no trailing\n+            // Format macro invocation as function call, preserve the trailing\n             // comma because not all macros support them.\n-            rewrite_call_inner(\n+            overflow::rewrite_with_parens(\n                 context,\n                 &macro_name,\n                 &arg_vec.iter().map(|e| &*e).collect::<Vec<_>>()[..],\n-                mac.span,\n                 shape,\n+                mac.span,\n                 context.config.width_heuristics().fn_call_width,\n                 trailing_comma,\n             ).map(|rw| match position {"}, {"sha": "b5634def086a958a1c83c421b08b626061e36f14", "filename": "src/overflow.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -0,0 +1,491 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rewrite a list some items with overflow.\n+// FIXME: Replace `ToExpr` with some enum.\n+\n+use config::lists::*;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+\n+use closures;\n+use codemap::SpanUtils;\n+use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n+use rewrite::{Rewrite, RewriteContext};\n+use expr::{is_nested_call, maybe_get_args_offset, ToExpr};\n+use shape::Shape;\n+use spanned::Spanned;\n+use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_sp, paren_overhead};\n+\n+use std::cmp::min;\n+\n+pub fn rewrite_with_parens<T>(\n+    context: &RewriteContext,\n+    ident: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+    item_max_width: usize,\n+    force_trailing_comma: bool,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    Context::new(\n+        context,\n+        items,\n+        ident,\n+        shape,\n+        span,\n+        \"(\",\n+        \")\",\n+        item_max_width,\n+        force_trailing_comma,\n+    ).rewrite(shape)\n+}\n+\n+pub fn rewrite_with_angle_brackets<T>(\n+    context: &RewriteContext,\n+    ident: &str,\n+    items: &[&T],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String>\n+where\n+    T: Rewrite + ToExpr + Spanned,\n+{\n+    Context::new(\n+        context,\n+        items,\n+        ident,\n+        shape,\n+        span,\n+        \"<\",\n+        \">\",\n+        context.config.max_width(),\n+        false,\n+    ).rewrite(shape)\n+}\n+\n+struct Context<'a, T: 'a> {\n+    context: &'a RewriteContext<'a>,\n+    items: &'a [&'a T],\n+    ident: &'a str,\n+    prefix: &'static str,\n+    suffix: &'static str,\n+    one_line_shape: Shape,\n+    nested_shape: Shape,\n+    span: Span,\n+    item_max_width: usize,\n+    one_line_width: usize,\n+    force_trailing_comma: bool,\n+}\n+\n+impl<'a, T: 'a + Rewrite + ToExpr + Spanned> Context<'a, T> {\n+    pub fn new(\n+        context: &'a RewriteContext,\n+        items: &'a [&'a T],\n+        ident: &'a str,\n+        shape: Shape,\n+        span: Span,\n+        prefix: &'static str,\n+        suffix: &'static str,\n+        item_max_width: usize,\n+        force_trailing_comma: bool,\n+    ) -> Context<'a, T> {\n+        // 2 = `( `, 1 = `(`\n+        let paren_overhead = if context.config.spaces_within_parens_and_brackets() {\n+            2\n+        } else {\n+            1\n+        };\n+        let used_width = extra_offset(ident, shape);\n+        let one_line_width = shape\n+            .width\n+            .checked_sub(used_width + 2 * paren_overhead)\n+            .unwrap_or(0);\n+\n+        // 1 = \"(\" or \")\"\n+        let one_line_shape = shape\n+            .offset_left(last_line_width(ident) + 1)\n+            .and_then(|shape| shape.sub_width(1))\n+            .unwrap_or(Shape { width: 0, ..shape });\n+        let nested_shape = shape_from_indent_style(\n+            context,\n+            shape,\n+            used_width + 2 * paren_overhead,\n+            used_width + paren_overhead,\n+        );\n+        Context {\n+            context,\n+            items,\n+            ident,\n+            one_line_shape,\n+            nested_shape,\n+            span,\n+            prefix,\n+            suffix,\n+            item_max_width,\n+            one_line_width,\n+            force_trailing_comma,\n+        }\n+    }\n+\n+    fn last_item(&self) -> Option<&&T> {\n+        self.items.last()\n+    }\n+\n+    fn items_span(&self) -> Span {\n+        let span_lo = self.context\n+            .snippet_provider\n+            .span_after(self.span, self.prefix);\n+        mk_sp(span_lo, self.span.hi())\n+    }\n+\n+    fn rewrite_last_item_with_overflow(\n+        &self,\n+        last_list_item: &mut ListItem,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let last_item = self.last_item()?;\n+        let rewrite = if let Some(expr) = last_item.to_expr() {\n+            match expr.node {\n+                // When overflowing the closure which consists of a single control flow expression,\n+                // force to use block if its condition uses multi line.\n+                ast::ExprKind::Closure(..) => {\n+                    // If the argument consists of multiple closures, we do not overflow\n+                    // the last closure.\n+                    if closures::args_have_many_closure(self.items) {\n+                        None\n+                    } else {\n+                        closures::rewrite_last_closure(self.context, expr, shape)\n+                    }\n+                }\n+                _ => expr.rewrite(self.context, shape),\n+            }\n+        } else {\n+            last_item.rewrite(self.context, shape)\n+        };\n+\n+        if let Some(rewrite) = rewrite {\n+            let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n+            last_list_item.item = rewrite_first_line;\n+            Some(rewrite)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn try_overflow_last_item(&self, list_items: &mut Vec<ListItem>) -> DefinitiveListTactic {\n+        // 1 = \"(\"\n+        let combine_arg_with_callee = self.items.len() == 1 && self.items[0].to_expr().is_some()\n+            && self.ident.len() + 1 <= self.context.config.tab_spaces();\n+        let overflow_last = combine_arg_with_callee || can_be_overflowed(self.context, self.items);\n+\n+        // Replace the last item with its first line to see if it fits with\n+        // first arguments.\n+        let placeholder = if overflow_last {\n+            let old_value = *self.context.force_one_line_chain.borrow();\n+            if !combine_arg_with_callee {\n+                if let Some(expr) = self.last_item().and_then(|item| item.to_expr()) {\n+                    if let ast::ExprKind::MethodCall(..) = expr.node {\n+                        self.context.force_one_line_chain.replace(true);\n+                    }\n+                }\n+            }\n+            let result = last_item_shape(\n+                self.items,\n+                list_items,\n+                self.one_line_shape,\n+                self.item_max_width,\n+            ).and_then(|arg_shape| {\n+                self.rewrite_last_item_with_overflow(\n+                    &mut list_items[self.items.len() - 1],\n+                    arg_shape,\n+                )\n+            });\n+            self.context.force_one_line_chain.replace(old_value);\n+            result\n+        } else {\n+            None\n+        };\n+\n+        let mut tactic = definitive_tactic(\n+            &*list_items,\n+            ListTactic::LimitedHorizontalVertical(self.item_max_width),\n+            Separator::Comma,\n+            self.one_line_width,\n+        );\n+\n+        // Replace the stub with the full overflowing last argument if the rewrite\n+        // succeeded and its first line fits with the other arguments.\n+        match (overflow_last, tactic, placeholder) {\n+            (true, DefinitiveListTactic::Horizontal, Some(ref overflowed))\n+                if self.items.len() == 1 =>\n+            {\n+                // When we are rewriting a nested function call, we restrict the\n+                // bugdet for the inner function to avoid them being deeply nested.\n+                // However, when the inner function has a prefix or a suffix\n+                // (e.g. `foo() as u32`), this budget reduction may produce poorly\n+                // formatted code, where a prefix or a suffix being left on its own\n+                // line. Here we explicitlly check those cases.\n+                if count_newlines(overflowed) == 1 {\n+                    let rw = self.items\n+                        .last()\n+                        .and_then(|last_item| last_item.rewrite(self.context, self.nested_shape));\n+                    let no_newline = rw.as_ref().map_or(false, |s| !s.contains('\\n'));\n+                    if no_newline {\n+                        list_items[self.items.len() - 1].item = rw;\n+                    } else {\n+                        list_items[self.items.len() - 1].item = Some(overflowed.to_owned());\n+                    }\n+                } else {\n+                    list_items[self.items.len() - 1].item = Some(overflowed.to_owned());\n+                }\n+            }\n+            (true, DefinitiveListTactic::Horizontal, placeholder @ Some(..)) => {\n+                list_items[self.items.len() - 1].item = placeholder;\n+            }\n+            _ if self.items.len() >= 1 => {\n+                list_items[self.items.len() - 1].item = self.items\n+                    .last()\n+                    .and_then(|last_item| last_item.rewrite(self.context, self.nested_shape));\n+\n+                let default_tactic = || {\n+                    definitive_tactic(\n+                        &*list_items,\n+                        ListTactic::LimitedHorizontalVertical(self.item_max_width),\n+                        Separator::Comma,\n+                        self.one_line_width,\n+                    )\n+                };\n+\n+                // Use horizontal layout for a function with a single argument as long as\n+                // everything fits in a single line.\n+                if self.items.len() == 1\n+                && self.one_line_width != 0 // Vertical layout is forced.\n+                && !list_items[0].has_comment()\n+                    && !list_items[0].inner_as_ref().contains('\\n')\n+                    && ::lists::total_item_width(&list_items[0]) <= self.one_line_width\n+                {\n+                    tactic = DefinitiveListTactic::Horizontal;\n+                } else {\n+                    tactic = default_tactic();\n+\n+                    if tactic == DefinitiveListTactic::Vertical {\n+                        if let Some((all_simple, num_args_before)) =\n+                            maybe_get_args_offset(self.ident, self.items)\n+                        {\n+                            let one_line = all_simple\n+                                && definitive_tactic(\n+                                    &list_items[..num_args_before],\n+                                    ListTactic::HorizontalVertical,\n+                                    Separator::Comma,\n+                                    self.nested_shape.width,\n+                                )\n+                                    == DefinitiveListTactic::Horizontal\n+                                && definitive_tactic(\n+                                    &list_items[num_args_before + 1..],\n+                                    ListTactic::HorizontalVertical,\n+                                    Separator::Comma,\n+                                    self.nested_shape.width,\n+                                )\n+                                    == DefinitiveListTactic::Horizontal;\n+\n+                            if one_line {\n+                                tactic = DefinitiveListTactic::SpecialMacro(num_args_before);\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+\n+        tactic\n+    }\n+\n+    fn rewrite_items(&self) -> Option<(bool, String)> {\n+        let span = self.items_span();\n+        let items = itemize_list(\n+            self.context.snippet_provider,\n+            self.items.iter(),\n+            self.suffix,\n+            \",\",\n+            |item| item.span().lo(),\n+            |item| item.span().hi(),\n+            |item| item.rewrite(self.context, self.nested_shape),\n+            span.lo(),\n+            span.hi(),\n+            true,\n+        );\n+        let mut list_items: Vec<_> = items.collect();\n+\n+        // Try letting the last argument overflow to the next line with block\n+        // indentation. If its first line fits on one line with the other arguments,\n+        // we format the function arguments horizontally.\n+        let tactic = self.try_overflow_last_item(&mut list_items);\n+\n+        let fmt = ListFormatting {\n+            tactic,\n+            separator: \",\",\n+            trailing_separator: if self.force_trailing_comma {\n+                SeparatorTactic::Always\n+            } else if self.context.inside_macro || !self.context.use_block_indent() {\n+                SeparatorTactic::Never\n+            } else {\n+                self.context.config.trailing_comma()\n+            },\n+            separator_place: SeparatorPlace::Back,\n+            shape: self.nested_shape,\n+            ends_with_newline: self.context.use_block_indent()\n+                && tactic == DefinitiveListTactic::Vertical,\n+            preserve_newline: false,\n+            config: self.context.config,\n+        };\n+\n+        write_list(&list_items, &fmt)\n+            .map(|items_str| (tactic == DefinitiveListTactic::Horizontal, items_str))\n+    }\n+\n+    fn wrap_items(&self, items_str: &str, shape: Shape, is_extendable: bool) -> String {\n+        let shape = Shape {\n+            width: shape\n+                .width\n+                .checked_sub(last_line_width(self.ident))\n+                .unwrap_or(0),\n+            ..shape\n+        };\n+\n+        let paren_overhead = paren_overhead(self.context);\n+        let fits_one_line = items_str.len() + paren_overhead <= shape.width;\n+        let extend_width = if items_str.is_empty() {\n+            paren_overhead\n+        } else {\n+            paren_overhead / 2\n+        };\n+        let nested_indent_str = self.nested_shape\n+            .indent\n+            .to_string_with_newline(self.context.config);\n+        let indent_str = shape\n+            .block()\n+            .indent\n+            .to_string_with_newline(self.context.config);\n+        let mut result = String::with_capacity(\n+            self.ident.len() + items_str.len() + 2 + indent_str.len() + nested_indent_str.len(),\n+        );\n+        result.push_str(self.ident);\n+        result.push_str(self.prefix);\n+        if !self.context.use_block_indent()\n+            || (self.context.inside_macro && !items_str.contains('\\n') && fits_one_line)\n+            || (is_extendable && extend_width <= shape.width)\n+        {\n+            if self.context.config.spaces_within_parens_and_brackets() && !items_str.is_empty() {\n+                result.push(' ');\n+                result.push_str(items_str);\n+                result.push(' ');\n+            } else {\n+                result.push_str(items_str);\n+            }\n+        } else {\n+            if !items_str.is_empty() {\n+                result.push_str(&nested_indent_str);\n+                result.push_str(items_str);\n+            }\n+            result.push_str(&indent_str);\n+        }\n+        result.push_str(self.suffix);\n+        result\n+    }\n+\n+    fn rewrite(&self, shape: Shape) -> Option<String> {\n+        let (extendable, items_str) = self.rewrite_items()?;\n+\n+        // If we are using visual indent style and failed to format, retry with block indent.\n+        if !self.context.use_block_indent() && need_block_indent(&items_str, self.nested_shape)\n+            && !extendable\n+        {\n+            self.context.use_block.replace(true);\n+            let result = self.rewrite(shape);\n+            self.context.use_block.replace(false);\n+            return result;\n+        }\n+\n+        Some(self.wrap_items(&items_str, shape, extendable))\n+    }\n+}\n+\n+fn need_block_indent(s: &str, shape: Shape) -> bool {\n+    s.lines().skip(1).any(|s| {\n+        s.find(|c| !char::is_whitespace(c))\n+            .map_or(false, |w| w + 1 < shape.indent.width())\n+    })\n+}\n+\n+fn can_be_overflowed<'a, T>(context: &RewriteContext, items: &[&T]) -> bool\n+where\n+    T: Rewrite + Spanned + ToExpr + 'a,\n+{\n+    items\n+        .last()\n+        .map_or(false, |x| x.can_be_overflowed(context, items.len()))\n+}\n+\n+/// Returns a shape for the last argument which is going to be overflowed.\n+fn last_item_shape<T>(\n+    lists: &[&T],\n+    items: &[ListItem],\n+    shape: Shape,\n+    args_max_width: usize,\n+) -> Option<Shape>\n+where\n+    T: Rewrite + Spanned + ToExpr,\n+{\n+    let is_nested_call = lists\n+        .iter()\n+        .next()\n+        .and_then(|item| item.to_expr())\n+        .map_or(false, is_nested_call);\n+    if items.len() == 1 && !is_nested_call {\n+        return Some(shape);\n+    }\n+    let offset = items.iter().rev().skip(1).fold(0, |acc, i| {\n+        // 2 = \", \"\n+        acc + 2 + i.inner_as_ref().len()\n+    });\n+    Shape {\n+        width: min(args_max_width, shape.width),\n+        ..shape\n+    }.offset_left(offset)\n+}\n+\n+fn shape_from_indent_style(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    overhead: usize,\n+    offset: usize,\n+) -> Shape {\n+    if context.use_block_indent() {\n+        // 1 = \",\"\n+        shape\n+            .block()\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+            .sub_width(1)\n+            .unwrap()\n+    } else {\n+        let shape = shape.visual_indent(offset);\n+        if let Some(shape) = shape.sub_width(overhead) {\n+            shape\n+        } else {\n+            Shape { width: 0, ..shape }\n+        }\n+    }\n+}"}, {"sha": "c6cacc8bff5f6af8c560cbe2fcf4e16d1493bb0a", "filename": "src/patterns.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -15,11 +15,12 @@ use syntax::ptr;\n \n use codemap::SpanUtils;\n use comment::FindUncommented;\n-use expr::{can_be_overflowed_expr, rewrite_call_inner, rewrite_pair, rewrite_unary_prefix,\n-           wrap_struct_field, PairParts};\n+use expr::{can_be_overflowed_expr, rewrite_pair, rewrite_unary_prefix, wrap_struct_field,\n+           PairParts};\n use lists::{itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n             struct_lit_tactic, write_list};\n use macros::{rewrite_macro, MacroPosition};\n+use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n@@ -335,13 +336,13 @@ fn rewrite_tuple_pat(\n         pat_ref_vec.push(pat);\n     }\n \n-    rewrite_call_inner(\n+    overflow::rewrite_with_parens(\n         &context,\n         &path_str,\n         &pat_ref_vec[..],\n-        span,\n         shape,\n-        shape.width,\n+        span,\n+        context.config.max_width(),\n         add_comma,\n     )\n }"}, {"sha": "e52648e575c6b4508431f18bec41070f5c334e22", "filename": "src/types.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae629abc41fd1d0f28a1733b6deb17f9b9026579/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ae629abc41fd1d0f28a1733b6deb17f9b9026579", "patch": "@@ -384,14 +384,18 @@ where\n         FunctionRetTy::Default(..) => String::new(),\n     };\n \n-    let extendable = (!list_str.contains('\\n') || list_str.is_empty()) && !output.contains('\\n');\n-    let args = wrap_args_with_parens(\n-        context,\n-        &list_str,\n-        extendable,\n-        shape.sub_width(first_line_width(&output))?,\n-        Shape::indented(offset, context.config),\n-    );\n+    let args = if (!list_str.contains('\\n') || list_str.is_empty()) && !output.contains('\\n')\n+        || !context.use_block_indent()\n+    {\n+        format!(\"({})\", list_str)\n+    } else {\n+        format!(\n+            \"({}{}{})\",\n+            offset.to_string_with_newline(context.config),\n+            list_str,\n+            shape.block().indent.to_string_with_newline(context.config),\n+        )\n+    };\n     if last_line_width(&args) + first_line_width(&output) <= shape.width {\n         Some(format!(\"{}{}\", args, output))\n     } else {"}]}