{"sha": "e41f41142bef5900d34dffb324d71e26a63f25db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MWY0MTE0MmJlZjU5MDBkMzRkZmZiMzI0ZDcxZTI2YTYzZjI1ZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-25T06:48:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-25T06:48:14Z"}, "message": "Auto merge of #53609 - bemeurer:tidy-ctfe, r=RalfJung\n\nTidy CFTE/MIRI\n\nFixes #53596", "tree": {"sha": "1b78f1b742bd613e3ce84e6429dc44f0b8ece2b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b78f1b742bd613e3ce84e6429dc44f0b8ece2b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41f41142bef5900d34dffb324d71e26a63f25db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41f41142bef5900d34dffb324d71e26a63f25db", "html_url": "https://github.com/rust-lang/rust/commit/e41f41142bef5900d34dffb324d71e26a63f25db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41f41142bef5900d34dffb324d71e26a63f25db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f87d9135b485a044b35a09ec9c17b3c2556567f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f87d9135b485a044b35a09ec9c17b3c2556567f5", "html_url": "https://github.com/rust-lang/rust/commit/f87d9135b485a044b35a09ec9c17b3c2556567f5"}, {"sha": "e07c1542ac4ab8bfd67748a604ddbe5fa766e408", "url": "https://api.github.com/repos/rust-lang/rust/commits/e07c1542ac4ab8bfd67748a604ddbe5fa766e408", "html_url": "https://github.com/rust-lang/rust/commit/e07c1542ac4ab8bfd67748a604ddbe5fa766e408"}], "stats": {"total": 404, "additions": 331, "deletions": 73}, "files": [{"sha": "dc6d17d34535be0c142315c01995a3e21d1d1c80", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::{fmt, env};\n \n use mir;\n@@ -315,7 +325,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n             ReadForeignStatic =>\n                 \"tried to read from foreign (extern) static\",\n             InvalidPointerMath =>\n-                \"attempted to do invalid arithmetic on pointers that would leak base addresses, e.g. comparing pointers into different allocations\",\n+                \"attempted to do invalid arithmetic on pointers that would leak base addresses, \\\n+                e.g. comparing pointers into different allocations\",\n             ReadUndefBytes =>\n                 \"attempted to read undefined bytes\",\n             DeadLocal =>\n@@ -369,11 +380,13 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n             Layout(_) =>\n                 \"rustc layout computation failed\",\n             UnterminatedCString(_) =>\n-                \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n+                \"attempted to get length of a null terminated string, but no null found before end \\\n+                of allocation\",\n             HeapAllocZeroBytes =>\n                 \"tried to re-, de- or allocate zero bytes on the heap\",\n             HeapAllocNonPowerOfTwoAlignment(_) =>\n-                \"tried to re-, de-, or allocate heap memory with alignment that is not a power of two\",\n+                \"tried to re-, de-, or allocate heap memory with alignment that is not a power of \\\n+                two\",\n             Unreachable =>\n                 \"entered unreachable code\",\n             Panic { .. } =>\n@@ -435,8 +448,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                        kind, ptr, len, lock)\n             }\n             InvalidMemoryLockRelease { ptr, len, frame, ref lock } => {\n-                write!(f, \"frame {} tried to release memory write lock at {:?}, size {}, but cannot release lock {:?}\",\n-                       frame, ptr, len, lock)\n+                write!(f, \"frame {} tried to release memory write lock at {:?}, size {}, but \\\n+                       cannot release lock {:?}\", frame, ptr, len, lock)\n             }\n             DeallocatedLockedMemory { ptr, ref lock } => {\n                 write!(f, \"tried to deallocate memory at {:?} in conflict with lock {:?}\",\n@@ -447,7 +460,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n             }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n-                write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),\n+                write!(f, \"tried to call a function with sig {} through a \\\n+                       function pointer of type {}\", sig, got),\n             BoundsCheck { ref len, ref index } =>\n                 write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n@@ -470,7 +484,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n             MachineError(ref inner) =>\n                 write!(f, \"{}\", inner),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n-                write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n+                write!(f, \"incorrect alloc info: expected size {} and align {}, got size {} and \\\n+                       align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n             Panic { ref msg, line, col, ref file } =>\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col),\n             _ => write!(f, \"{}\", self.description()),"}, {"sha": "6458c211ab537be78bfe70a4e8d2fa7963cc3072", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! An interpreter for MIR used in CTFE and by miri\n \n #[macro_export]\n@@ -40,7 +50,8 @@ use std::num::NonZeroU32;\n pub enum Lock {\n     NoLock,\n     WriteLock(DynamicLifetime),\n-    /// This should never be empty -- that would be a read lock held and nobody there to release it...\n+    /// This should never be empty -- that would be a read lock held and nobody\n+    /// there to release it...\n     ReadLock(Vec<DynamicLifetime>),\n }\n "}, {"sha": "6b34e3f47cc5dac92125345c33bf2a363980cd6b", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n #![allow(unknown_lints)]\n \n use ty::layout::{HasDataLayout, Size};"}, {"sha": "4522f477959b3206f9ff99d9d48cbd9058412c4a", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc::ty::{self, Ty, TypeAndMut};\n use rustc::ty::layout::{self, TyLayout, Size};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n@@ -216,7 +226,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(Scalar::Bits { bits: v, size: 4 })\n             },\n \n-            // No alignment check needed for raw pointers.  But we have to truncate to target ptr size.\n+            // No alignment check needed for raw pointers.\n+            // But we have to truncate to target ptr size.\n             RawPtr(_) => {\n                 Ok(Scalar::Bits {\n                     bits: self.memory.truncate_to_ptr(v).0 as u128,\n@@ -229,7 +240,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    fn cast_from_float(&self, bits: u128, fty: FloatTy, dest_ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n+    fn cast_from_float(\n+        &self,\n+        bits: u128,\n+        fty: FloatTy,\n+        dest_ty: Ty<'tcx>\n+    ) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TyKind::*;\n         use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n@@ -292,7 +308,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn cast_from_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Scalar> {\n         use rustc::ty::TyKind::*;\n         match ty.sty {\n-            // Casting to a reference or fn pointer is not permitted by rustc, no need to support it here.\n+            // Casting to a reference or fn pointer is not permitted by rustc,\n+            // no need to support it here.\n             RawPtr(_) |\n             Int(IntTy::Isize) |\n             Uint(UintTy::Usize) => Ok(ptr.into()),"}, {"sha": "8e77af7526e351528151425d1c02861a494b8dae", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::fmt;\n use std::error::Error;\n \n@@ -462,7 +472,8 @@ fn to_str<'a, 'tcx, 'mir>(\n     if let Value::ScalarPair(ptr, len) = val {\n         let len = len.not_undef()?.to_bits(ecx.memory.pointer_size())?;\n         let bytes = ecx.memory.read_bytes(ptr.not_undef()?, Size::from_bytes(len as u64))?;\n-        let str = ::std::str::from_utf8(bytes).map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n+        let str = ::std::str::from_utf8(bytes)\n+            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n         Ok(Symbol::intern(str))\n     } else {\n         bug!(\"panic arg is not a str\")"}, {"sha": "fa70a1500d0609d5c50f26361d9c5d3eb3612d10", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::mem;\n@@ -82,7 +92,8 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub return_place: Place,\n \n     /// The list of locals for this stack frame, stored in order as\n-    /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`.\n+    /// The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     pub locals: IndexVec<mir::Local, LocalValue>,\n@@ -269,7 +280,9 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         *self.tcx\n@@ -329,7 +342,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n         let stack = mem::replace(&mut self.stack, Vec::new());\n-        let steps = mem::replace(&mut self.steps_since_detector_enabled, -STEPS_UNTIL_DETECTOR_ENABLED);\n+        let steps = mem::replace(&mut self.steps_since_detector_enabled,\n+                                 -STEPS_UNTIL_DETECTOR_ENABLED);\n         let r = f(self);\n         self.stack = stack;\n         self.steps_since_detector_enabled = steps;\n@@ -378,7 +392,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n-    pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub(super) fn resolve(\n+        &self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>\n+    ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"substs: {:#?}\", self.substs());\n         trace!(\"param_env: {:#?}\", self.param_env);\n@@ -405,7 +423,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n-        if did.is_local() && self.tcx.has_typeck_tables(did) && self.tcx.typeck_tables_of(did).tainted_by_errors {\n+        if did.is_local()\n+            && self.tcx.has_typeck_tables(did)\n+            && self.tcx.typeck_tables_of(did).tainted_by_errors\n+        {\n             return err!(TypeckError);\n         }\n         trace!(\"load mir {:?}\", instance);\n@@ -614,7 +635,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n-                    // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n+                    // FIXME: to_ptr()? might be too extreme here,\n+                    // static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,\n@@ -651,7 +673,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         } else {\n             self.param_env\n         };\n-        self.tcx.const_eval(param_env.and(gid)).map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n+        self.tcx.const_eval(param_env.and(gid))\n+            .map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n     #[inline(always)]\n@@ -757,7 +780,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             } else {\n                 last_span = Some(span);\n             }\n-            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data == DefPathData::ClosureExpr {\n+            let location = if self.tcx.def_key(instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr\n+            {\n                 \"closure\".to_owned()\n             } else {\n                 instance.to_string()"}, {"sha": "1fcdab2be62b85b41d9444d0cb5714b3362b86d2", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! This module contains everything needed to instantiate an interpreter.\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE."}, {"sha": "6f1a126534ce876224658aa6c6fe3e1b3d6db594", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 67, "deletions": 23, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! The memory subsystem.\n //!\n //! Generally, we use `Pointer` to denote memory addresses. However, some operations\n@@ -231,13 +241,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        let alloc_kind = self.alloc_kind.remove(&ptr.alloc_id).expect(\"alloc_map out of sync with alloc_kind\");\n+        let alloc_kind = self.alloc_kind\n+                        .remove(&ptr.alloc_id)\n+                        .expect(\"alloc_map out of sync with alloc_kind\");\n \n-        // It is okay for us to still holds locks on deallocation -- for example, we could store data we own\n-        // in a local, and the local could be deallocated (from StorageDead) before the function returns.\n-        // However, we should check *something*.  For now, we make sure that there is no conflicting write\n-        // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n-        // TODO: Figure out the exact rules here.\n+        // It is okay for us to still holds locks on deallocation -- for example, we could store\n+        // data we own in a local, and the local could be deallocated (from StorageDead) before the\n+        // function returns. However, we should check *something*.  For now, we make sure that there\n+        // is no conflicting write lock by another frame.  We *have* to permit deallocation if we\n+        // hold a read lock.\n+        // FIXME: Figure out the exact rules here.\n         M::free_lock(self, ptr.alloc_id, alloc.bytes.len() as u64)?;\n \n         if alloc_kind != kind {\n@@ -248,7 +261,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         if let Some((size, align)) = size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n-                return err!(IncorrectAllocationInformation(size, Size::from_bytes(alloc.bytes.len() as u64), align, alloc.align));\n+                let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n+                return err!(IncorrectAllocationInformation(size,\n+                                                           bytes,\n+                                                           align,\n+                                                           alloc.align));\n             }\n         }\n \n@@ -511,13 +528,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n+        // Zero-sized accesses can use dangling pointers,\n+        // but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n         if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Read)?;\n-        self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, self)?, true)?;\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n@@ -532,13 +551,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n-        // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n+        // Zero-sized accesses can use dangling pointers,\n+        // but they still have to be aligned and non-NULL\n         self.check_align(ptr.into(), align)?;\n         if size.bytes() == 0 {\n             return Ok(&mut []);\n         }\n         M::check_locks(self, ptr, size, AccessKind::Write)?;\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n+        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n@@ -663,7 +684,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     relocations\n                     .iter()\n                     .map(|&(offset, alloc_id)| {\n-                    (offset + dest.offset - src.offset + (i * size * relocations.len() as u64), alloc_id)\n+                    (offset + dest.offset - src.offset + (i * size * relocations.len() as u64),\n+                    alloc_id)\n                     })\n                 );\n             }\n@@ -692,11 +714,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 }\n \n                 for i in 0..length {\n-                    ptr::copy(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                    ptr::copy(src_bytes,\n+                              dest_bytes.offset((size.bytes() * i) as isize),\n+                              size.bytes() as usize);\n                 }\n             } else {\n                 for i in 0..length {\n-                    ptr::copy_nonoverlapping(src_bytes, dest_bytes.offset((size.bytes() * i) as isize), size.bytes() as usize);\n+                    ptr::copy_nonoverlapping(src_bytes,\n+                                             dest_bytes.offset((size.bytes() * i) as isize),\n+                                             size.bytes() as usize);\n                 }\n             }\n         }\n@@ -763,15 +789,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Read a *non-ZST* scalar\n-    pub fn read_scalar(&self, ptr: Pointer, ptr_align: Align, size: Size) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n+    pub fn read_scalar(\n+        &self,\n+        ptr: Pointer,\n+        ptr_align: Align,\n+        size: Size\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+        // Make sure we don't read part of a pointer as a pointer\n+        self.check_relocation_edges(ptr, size)?;\n         let endianness = self.endianness();\n         // get_bytes_unchecked tests alignment\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few bytes are undefined\n+            // this inflates undefined bytes to the entire scalar,\n+            // even if only a few bytes are undefined\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n@@ -784,7 +817,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n-                Some(&alloc_id) => return Ok(ScalarMaybeUndef::Scalar(Pointer::new(alloc_id, Size::from_bytes(bits as u64)).into())),\n+                Some(&alloc_id) => {\n+                    let ptr = Pointer::new(alloc_id, Size::from_bytes(bits as u64));\n+                    return Ok(ScalarMaybeUndef::Scalar(ptr.into()))\n+                }\n                 None => {},\n             }\n         }\n@@ -795,7 +831,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }))\n     }\n \n-    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+    pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align)\n+        -> EvalResult<'tcx, ScalarMaybeUndef> {\n         self.read_scalar(ptr, ptr_align, self.pointer_size())\n     }\n \n@@ -848,7 +885,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef) -> EvalResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, ptr: Pointer, ptr_align: Align, val: ScalarMaybeUndef)\n+        -> EvalResult<'tcx> {\n         let ptr_size = self.pointer_size();\n         self.write_scalar(ptr.into(), ptr_align, val, ptr_size)\n     }\n@@ -992,7 +1030,9 @@ pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         self\n@@ -1004,7 +1044,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Me\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n@@ -1016,7 +1058,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Ev\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M>\n+    where M: Machine<'mir, 'tcx>\n+{\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "8192ef3d0f31d4ba949adece9b0fc0c578d9065b", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;"}, {"sha": "aa4585fb8924201cd42a7cc09ed984a1f2b2da9f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n "}, {"sha": "89293dc10123269280a1967ea7432024ce933e1e", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc::mir;\n use rustc::ty::{self, layout::{self, TyLayout}};\n use syntax::ast::FloatTy;\n@@ -58,7 +68,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n             _ => return err!(TypeNotPrimitive(right_layout.ty)),\n         };\n-        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+        bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {"}, {"sha": "f1c2b6b34fb15b2f5e9fd04451b4142371ee7291", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! Computations on places -- field projections, going from mir::Place, and writing\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n@@ -109,8 +119,9 @@ impl MemPlace {\n     /// Extract the ptr part of the mplace\n     #[inline(always)]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n-        // and no matter where it came from, it now must be aligned.\n+        // At this point, we forget about the alignment information --\n+        // the place has been turned into a reference, and no matter where it came from,\n+        // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n \n@@ -276,11 +287,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 offsets[usize::try_from(field).unwrap()],\n             layout::FieldPlacement::Array { stride, .. } => {\n                 let len = base.len();\n-                assert!(field < len, \"Tried to access element {} of array/slice with length {}\", field, len);\n+                assert!(field < len,\n+                        \"Tried to access element {} of array/slice with length {}\", field, len);\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n-                assert!(field < count as u64, \"Tried to access field {} of union with {} fields\", field, count);\n+                assert!(field < count as u64,\n+                        \"Tried to access field {} of union with {} fields\", field, count);\n                 // Offset is always 0\n                 Size::from_bytes(0)\n             }\n@@ -572,9 +585,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         dest: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n-        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n-        // correct if we never look at this data with the wrong type.\n+        // Note that it is really important that the type here is the right one, and matches the\n+        // type things are read at. In case `src_val` is a `ScalarPair`, we don't do any magic here\n+        // to handle padding properly, which is only correct if we never look at this data with the\n+        // wrong type.\n \n         // Nothing to do for ZSTs, other than checking alignment\n         if dest.layout.size.bytes() == 0 {\n@@ -592,7 +606,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Value::ScalarPair(a_val, b_val) => {\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\", dest.layout)\n+                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\",\n+                              dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n                 let (a_align, b_align) = (a.align(&self), b.align(&self));\n@@ -758,7 +773,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n     /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n     /// This \"unpacks\" the existential quantifier, so to speak.\n-    pub fn unpack_unsized_mplace(&self, mplace: MPlaceTy<'tcx>) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+    pub fn unpack_unsized_mplace(\n+        &self,\n+        mplace: MPlaceTy<'tcx>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n         let layout = match mplace.extra {\n             PlaceExtra::Vtable(vtable) => {"}, {"sha": "0271a09482cd2c1b8f2ea86367844bc303043266", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n //! This module contains the `EvalContext` methods for executing a single step of the interpreter.\n //!\n //! The main entry point is the `step` method.\n@@ -98,8 +108,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         use rustc::mir::StatementKind::*;\n \n-        // Some statements (e.g. box) push new stack frames.  We have to record the stack frame number\n-        // *before* executing the statement.\n+        // Some statements (e.g. box) push new stack frames.\n+        // We have to record the stack frame number *before* executing the statement.\n         let frame_idx = self.cur_frame();\n         self.tcx.span = stmt.source_info.span;\n         self.memory.tcx.span = stmt.source_info.span;"}, {"sha": "8e413aa8284fb6c584a5f00e7c83e38359bc8c2b", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc::mir::BasicBlock;\n use rustc::ty::{self, layout::LayoutOf};\n use syntax::source_map::Span;\n@@ -14,9 +24,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n-        // We take the address of the object.  This may well be unaligned, which is fine for us here.\n-        // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n-        // by rustc.\n+        // We take the address of the object.  This may well be unaligned, which is fine for us\n+        // here. However, unaligned accesses will probably make the actual drop implementation fail\n+        // -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n         let (instance, place) = match place.layout.ty.sty {"}, {"sha": "aec7bb0c0d6064916549037e2f850c809d398edb", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::LayoutOf;\n@@ -45,7 +55,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits { bits: const_int, size: discr.layout.size.bytes() as u8 };\n+                    let const_int = Scalar::Bits {\n+                        bits: const_int,\n+                        size: discr.layout.size.bytes() as u8\n+                    };\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n                         discr,\n                         ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n@@ -144,7 +157,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_and_read_value(cond, None)?.to_scalar()?.to_bool()?;\n+                let cond_val = self.eval_operand_and_read_value(cond, None)?\n+                    .to_scalar()?\n+                    .to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n@@ -175,15 +190,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             DropAndReplace { .. } => unimplemented!(),\n             Resume => unimplemented!(),\n             Abort => unimplemented!(),\n-            FalseEdges { .. } => bug!(\"should have been eliminated by `simplify_branches` mir pass\"),\n-            FalseUnwind { .. } => bug!(\"should have been eliminated by `simplify_branches` mir pass\"),\n+            FalseEdges { .. } => bug!(\"should have been eliminated by\\\n+                                      `simplify_branches` mir pass\"),\n+            FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n+                                       `simplify_branches` mir pass\"),\n             Unreachable => return err!(Unreachable),\n         }\n \n         Ok(())\n     }\n \n-    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`.\n+    /// Decides whether it is okay to call the method with signature `real_sig`\n+    /// using signature `sig`.\n     /// FIXME: This should take into account the platform-dependent ABI description.\n     fn check_sig_compat(\n         &mut self,\n@@ -197,7 +215,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return match (&ty.sty, &real_ty.sty) {\n                 // Permit changing the pointer type of raw pointers and references as well as\n                 // mutability of raw pointers.\n-                // TODO: Should not be allowed when fat pointers are involved.\n+                // FIXME: Should not be allowed when fat pointers are involved.\n                 (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n                 (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n                     ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n@@ -226,15 +244,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // We need to allow what comes up when a non-capturing closure is cast to a fn().\n         match (sig.abi, real_sig.abi) {\n             (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n-                if check_ty_compat(sig.output(), real_sig.output()) && real_sig.inputs_and_output.len() == 3 => {\n+                if check_ty_compat(sig.output(), real_sig.output())\n+                    && real_sig.inputs_and_output.len() == 3 => {\n                 // First argument of real_sig must be a ZST\n                 let fst_ty = real_sig.inputs_and_output[0];\n                 if self.layout_of(fst_ty)?.is_zst() {\n                     // Second argument must be a tuple matching the argument list of sig\n                     let snd_ty = real_sig.inputs_and_output[1];\n                     match snd_ty.sty {\n                         ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n-                            if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+                            if sig.inputs()\n+                                .iter()\n+                                .zip(tys)\n+                                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n                                 return Ok(true)\n                             },\n                         _ => {}\n@@ -291,7 +313,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         trace!(\n                             \"args: {:#?}\",\n                             self.frame().mir.args_iter().zip(args.iter())\n-                                .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n+                                .map(|(local, arg)| (local, **arg, arg.layout.ty))\n+                                .collect::<Vec<_>>()\n                         );\n                         let local = arg_locals.nth(1).unwrap();\n                         for (i, &op) in args.into_iter().enumerate() {\n@@ -312,7 +335,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::Item(_) => {\n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n                 if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    // TODO: Can we make it return the frame to push, instead\n+                    // FIXME: Can we make it return the frame to push, instead\n                     // of the hook doing half of the work and us doing the argument\n                     // initialization?\n                     return Ok(());"}, {"sha": "4ce0563749ac6963f203e1cb5b3e8a46a9283cbe", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult};\n@@ -82,7 +92,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n+            .to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align"}, {"sha": "b0dfceb259746b38a5b44ac7d8a33b8232662c7a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -1,3 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::fmt::Write;\n \n use syntax_pos::symbol::Symbol;\n@@ -211,7 +221,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let variant = self.read_discriminant_as_variant_index(dest.into())?;\n                 let inner_dest = self.mplace_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n-                path.push(PathElem::Field(dest.layout.ty.ty_adt_def().unwrap().variants[variant].name));\n+                path.push(PathElem::Field(dest.layout.ty\n+                                          .ty_adt_def()\n+                                          .unwrap()\n+                                          .variants[variant].name));\n                 trace!(\"variant layout: {:#?}\", dest.layout);\n                 (variant, inner_dest)\n             },\n@@ -255,7 +268,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 if value.layout.ty.builtin_deref(false).is_some() {\n                                     trace!(\"Recursing below ptr {:#?}\", value);\n                                     let ptr_place = self.ref_to_mplace(value)?;\n-                                    // we have not encountered this pointer+layout combination before\n+                                    // we have not encountered this pointer+layout\n+                                    // combination before\n                                     if seen.insert(ptr_place) {\n                                         todo.push((ptr_place, path_clone_and_deref(path)));\n                                     }"}, {"sha": "c4bd0bbd03ca3b195168b3fd1d7daba4860ff359", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f41142bef5900d34dffb324d71e26a63f25db/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=e41f41142bef5900d34dffb324d71e26a63f25db", "patch": "@@ -76,8 +76,6 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/miri\",\n         \"src/tools/lld\",\n         \"src/tools/lldb\",\n-        \"src/librustc/mir/interpret\",\n-        \"src/librustc_mir/interpret\",\n         \"src/target\",\n         \"src/stdsimd\",\n     ];"}]}