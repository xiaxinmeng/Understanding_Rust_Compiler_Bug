{"sha": "43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzI1ZGNiMzk5OWVkMTk0MGRkNWI4YzVhNWU0MWVhYmY0NWIwYjQ=", "commit": {"author": {"name": "w00ns", "email": "w00ns@w00ns.top", "date": "2015-08-21T06:22:51Z"}, "committer": {"name": "w00ns", "email": "w00ns@w00ns.top", "date": "2015-12-11T13:45:07Z"}, "message": "Fix for issue #27889: same field names in enum variants", "tree": {"sha": "6ca3285af9b0e43957df8a2782014adcac9396a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ca3285af9b0e43957df8a2782014adcac9396a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "html_url": "https://github.com/rust-lang/rust/commit/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/comments", "author": null, "committer": null, "parents": [{"sha": "01e5c48656ac41e5a83d63d9dac7473fdd63d4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/01e5c48656ac41e5a83d63d9dac7473fdd63d4e0", "html_url": "https://github.com/rust-lang/rust/commit/01e5c48656ac41e5a83d63d9dac7473fdd63d4e0"}], "stats": {"total": 90, "additions": 69, "deletions": 21}, "files": [{"sha": "3f48051029d9dfe49a71d9f3fe0ce100f392b78f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -744,7 +744,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n-            LpExtend(ref lp_base, _, LpInterior(InteriorField(_))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n                     ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n                         // In the case where the owner implements drop, then\n@@ -770,7 +770,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.check_if_assigned_path_is_moved(id, span,\n                                                      use_kind, lp_base);\n             }\n-            LpExtend(ref lp_base, _, LpInterior(InteriorElement(..))) |\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) |\n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 // assigning to `P[i]` requires `P` is initialized\n                 // assigning to `(*P)` requires `P` is initialized"}, {"sha": "c5e2b69683b10cc3676f4141c3186d37bb12d490", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -379,15 +379,15 @@ fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n         // bind.\n         //\n         // Anyway, for now: LV[j] is not tracked precisely\n-        LpExtend(_, _, LpInterior(InteriorElement(..))) => {\n+        LpExtend(_, _, LpInterior(_, InteriorElement(..))) => {\n             let mp = this.move_path(tcx, lp.clone());\n             gathered_fragments.push(AllButOneFrom(mp));\n         }\n \n         // field access LV.x and tuple access LV#k are the cases\n         // we are interested in\n         LpExtend(ref loan_parent, mc,\n-                 LpInterior(InteriorField(ref field_name))) => {\n+                 LpInterior(_, InteriorField(ref field_name))) => {\n             let enum_variant_info = match loan_parent.kind {\n                 LpDowncast(ref loan_parent_2, variant_def_id) =>\n                     Some((variant_def_id, loan_parent_2.clone())),\n@@ -516,7 +516,7 @@ fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n         LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,\n     };\n \n-    let loan_path_elem = LpInterior(InteriorField(new_field_name));\n+    let loan_path_elem = LpInterior(opt_variant_did, InteriorField(new_field_name));\n     let new_lp_type = match new_field_name {\n         mc::NamedField(ast_name) =>\n             tcx.named_element_ty(parent.to_type(), ast_name, opt_variant_did),"}, {"sha": "cb75180b474667850ea26b1432fcf669b6375791", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -97,8 +97,12 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 // Overwriting the base would not change the type of\n                 // the memory, so no additional restrictions are\n                 // needed.\n+                let opt_variant_id = match cmt_base.cat {\n+                    Categorization::Downcast(_, variant_id) => Some(variant_id),\n+                    _ => None\n+                };\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, &cmt, LpInterior(i.cleaned()))\n+                self.extend(result, &cmt, LpInterior(opt_variant_id, i.cleaned()))\n             }\n \n             Categorization::StaticItem => {"}, {"sha": "64bbf49e3a8e0e50829bb93c7de1d425a6be9e36", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -377,10 +377,18 @@ impl ToInteriorKind for mc::InteriorKind {\n     }\n }\n \n+// This can be:\n+// - a pointer dereference (`*LV` in README.md)\n+// - a field reference, with an optional definition of the containing\n+//   enum variant (`LV.f` in README.md)\n+// `DefId` is present when the field is part of struct that is in\n+// a variant of an enum. For instance in:\n+// `enum E { X { foo: u32 }, Y { foo: u32 }}`\n+// each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathElem {\n-    LpDeref(mc::PointerKind),    // `*LV` in README.md\n-    LpInterior(InteriorKind),    // `LV.f` in README.md\n+    LpDeref(mc::PointerKind),\n+    LpInterior(Option<DefId>, InteriorKind),\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n@@ -413,8 +421,9 @@ impl<'tcx> LoanPath<'tcx> {\n \n     fn has_fork(&self, other: &LoanPath<'tcx>) -> bool {\n         match (&self.kind, &other.kind) {\n-            (&LpExtend(ref base, _, LpInterior(id)), &LpExtend(ref base2, _, LpInterior(id2))) =>\n-                if id == id2 {\n+            (&LpExtend(ref base, _, LpInterior(opt_variant_id, id)),\n+             &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) =>\n+                if id == id2 && opt_variant_id == opt_variant_id2 {\n                     base.has_fork(&**base2)\n                 } else {\n                     true\n@@ -428,23 +437,23 @@ impl<'tcx> LoanPath<'tcx> {\n     fn depth(&self) -> usize {\n         match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n-            LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n+            LpExtend(ref base, _, LpInterior(_, _)) => base.depth() + 1,\n             _ => 0,\n         }\n     }\n \n     fn common(&self, other: &LoanPath<'tcx>) -> Option<LoanPath<'tcx>> {\n         match (&self.kind, &other.kind) {\n-            (&LpExtend(ref base, a, LpInterior(id)),\n-             &LpExtend(ref base2, _, LpInterior(id2))) => {\n-                if id == id2 {\n+            (&LpExtend(ref base, a, LpInterior(opt_variant_id, id)),\n+             &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) => {\n+                if id == id2 && opt_variant_id == opt_variant_id2 {\n                     base.common(&**base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n                             assert_eq!(base.ty, base2.ty);\n                             assert_eq!(self.ty, other.ty);\n                             LoanPath {\n-                                kind: LpExtend(Rc::new(x), a, LpInterior(id)),\n+                                kind: LpExtend(Rc::new(x), a, LpInterior(opt_variant_id, id)),\n                                 ty: self.ty,\n                             }\n                         } else {\n@@ -509,7 +518,11 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n \n         Categorization::Interior(ref cmt_base, ik) => {\n             opt_loan_path(cmt_base).map(|lp| {\n-                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(ik.cleaned())))\n+                let opt_variant_id = match cmt_base.cat {\n+                    Categorization::Downcast(_, did) =>  Some(did),\n+                    _ => None\n+                };\n+                new_lp(LpExtend(lp, cmt.mutbl, LpInterior(opt_variant_id, ik.cleaned())))\n             })\n         }\n \n@@ -1068,7 +1081,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n \n-            LpExtend(ref lp_base, _, LpInterior(InteriorField(fname))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n@@ -1082,7 +1095,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(InteriorElement(..))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) => {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n@@ -1210,7 +1223,7 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n                 write!(f, \"{:?}.*\", lp)\n             }\n \n-            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n                 write!(f, \"{:?}.{:?}\", lp, interior)\n             }\n         }\n@@ -1242,7 +1255,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n                 write!(f, \"{}.*\", lp)\n             }\n \n-            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+            LpExtend(ref lp, _, LpInterior(_, ref interior)) => {\n                 write!(f, \"{}.{:?}\", lp, interior)\n             }\n         }"}, {"sha": "62404a73ad3be5184bc1a66ed6d0542edbdd7752", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -195,7 +195,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         LpVar(_) | LpUpvar(_) => {\n             true\n         }\n-        LpExtend(_, _, LpInterior(InteriorKind::InteriorElement(..))) => {\n+        LpExtend(_, _, LpInterior(_, InteriorKind::InteriorElement(..))) => {\n             // Paths involving element accesses a[i] do not refer to a unique\n             // location, as there is no accurate tracking of the indices.\n             //"}, {"sha": "3f7d0400c884e953d67835ccd91dc74005cd7457", "filename": "src/test/run-pass/issue-27889.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Ftest%2Frun-pass%2Fissue-27889.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4/src%2Ftest%2Frun-pass%2Fissue-27889.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27889.rs?ref=43725dcb3999ed1940dd5b8c5a5e41eabf45b0b4", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a field can have the same name in different variants\n+// of an enum\n+// FIXME #27889\n+\n+pub enum Foo {\n+    X { foo: u32 },\n+    Y { foo: u32 }\n+}\n+\n+pub fn foo(mut x: Foo) {\n+    let mut y = None;\n+    let mut z = None;\n+    if let Foo::X { ref foo } = x {\n+        z = Some(foo);\n+    }\n+    if let Foo::Y { ref mut foo } = x {\n+        y = Some(foo);\n+    }\n+}\n+\n+fn main() {}"}]}