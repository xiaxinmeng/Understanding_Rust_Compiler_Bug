{"sha": "4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMzc2OWZiZjJmZjk0YTg2M2RkYjkzMWNmNmRmYTdkYTlhYzgxNzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-08T19:01:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-08T19:01:23Z"}, "message": "Merge #9180\n\n9180: fix: fix some IDE functionality inside attribute macros r=jonas-schievink a=jonas-schievink\n\nIn `SourceToDefCtx::find_container`, we might encounter a container that has an attribute macro. We need to skip that item, instead of bailing out and creating an empty `Resolver`, otherwise all names in the macro stay unresolved.\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/9142\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "fc27726da074c677ef7c603740dd674c60ed2419", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc27726da074c677ef7c603740dd674c60ed2419"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgv76DCRBK7hj4Ov3rIwAA+DUIAF7/MiJ/kXrez3PvsL/Aeycy\nGoiaJ7KHP6G5LLdrJCJTshzBaWZXcAsnMbP0hkq9XV6uDyBPUth0ghj6S3KD1xL6\n9pbfdbd50KQknFlwBgEiNGKIzHtL218RSqYmFT9Wp1GryGJr8egsbgZElG0ROXUQ\nJ2Hszk+JktMBHI90G00FxdemgX1z4BXn5OhxxZgiqaFjH56BUgOdvkOP+YuT4TLG\nV/4S+PI/ywx45Oc02mz7GaOIpM/2YuXxvPYoAnEKJ0J0Gs6160Khl67s2xwjKiu8\nmzSHJqWtbiKw9+XNQRA7uvOli1qMUF2qmnRw5Gpgz/FrtbNtYLpw8n2sLtie8rM=\n=PKhk\n-----END PGP SIGNATURE-----\n", "payload": "tree fc27726da074c677ef7c603740dd674c60ed2419\nparent 16e142cd395f264ba5c6c3814ece92431415c089\nparent 8482329d65ab4c916c5c385818b056c8176a6c75\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623178883 +0000\ncommitter GitHub <noreply@github.com> 1623178883 +0000\n\nMerge #9180\n\n9180: fix: fix some IDE functionality inside attribute macros r=jonas-schievink a=jonas-schievink\n\nIn `SourceToDefCtx::find_container`, we might encounter a container that has an attribute macro. We need to skip that item, instead of bailing out and creating an empty `Resolver`, otherwise all names in the macro stay unresolved.\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/9142\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172", "html_url": "https://github.com/rust-lang/rust/commit/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e142cd395f264ba5c6c3814ece92431415c089", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e142cd395f264ba5c6c3814ece92431415c089", "html_url": "https://github.com/rust-lang/rust/commit/16e142cd395f264ba5c6c3814ece92431415c089"}, {"sha": "8482329d65ab4c916c5c385818b056c8176a6c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/8482329d65ab4c916c5c385818b056c8176a6c75", "html_url": "https://github.com/rust-lang/rust/commit/8482329d65ab4c916c5c385818b056c8176a6c75"}], "stats": {"total": 106, "additions": 56, "deletions": 50}, "files": [{"sha": "e8c2ed48e018d125b1e0c344eed7206d12749ece", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=4e3769fbf2ff94a863ddb931cf6dfa7da9ac8172", "patch": "@@ -211,62 +211,68 @@ impl SourceToDefCtx<'_, '_> {\n \n     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n         for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n-            let res: ChildContainer = match_ast! {\n-                match (container.value) {\n-                    ast::Module(it) => {\n-                        let def = self.module_to_def(container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::Trait(it) => {\n-                        let def = self.trait_to_def(container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::Impl(it) => {\n-                        let def = self.impl_to_def(container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::Fn(it) => {\n-                        let def = self.fn_to_def(container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::Struct(it) => {\n-                        let def = self.struct_to_def(container.with_value(it))?;\n-                        VariantId::from(def).into()\n-                    },\n-                    ast::Enum(it) => {\n-                        let def = self.enum_to_def(container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::Union(it) => {\n-                        let def = self.union_to_def(container.with_value(it))?;\n-                        VariantId::from(def).into()\n-                    },\n-                    ast::Static(it) => {\n-                        let def = self.static_to_def(container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::Const(it) => {\n-                        let def = self.const_to_def(container.with_value(it))?;\n-                        DefWithBodyId::from(def).into()\n-                    },\n-                    ast::TypeAlias(it) => {\n-                        let def = self.type_alias_to_def(container.with_value(it))?;\n-                        def.into()\n-                    },\n-                    ast::Variant(it) => {\n-                        let def = self.enum_variant_to_def(container.with_value(it))?;\n-                        VariantId::from(def).into()\n-                    },\n-                    _ => continue,\n-                }\n-            };\n-            return Some(res);\n+            if let Some(res) = self.container_to_def(container) {\n+                return Some(res);\n+            }\n         }\n \n         let def = self.file_to_def(src.file_id.original_file(self.db.upcast())).get(0).copied()?;\n         Some(def.into())\n     }\n \n+    fn container_to_def(&mut self, container: InFile<SyntaxNode>) -> Option<ChildContainer> {\n+        let cont = match_ast! {\n+            match (container.value) {\n+                ast::Module(it) => {\n+                    let def = self.module_to_def(container.with_value(it))?;\n+                    def.into()\n+                },\n+                ast::Trait(it) => {\n+                    let def = self.trait_to_def(container.with_value(it))?;\n+                    def.into()\n+                },\n+                ast::Impl(it) => {\n+                    let def = self.impl_to_def(container.with_value(it))?;\n+                    def.into()\n+                },\n+                ast::Fn(it) => {\n+                    let def = self.fn_to_def(container.with_value(it))?;\n+                    DefWithBodyId::from(def).into()\n+                },\n+                ast::Struct(it) => {\n+                    let def = self.struct_to_def(container.with_value(it))?;\n+                    VariantId::from(def).into()\n+                },\n+                ast::Enum(it) => {\n+                    let def = self.enum_to_def(container.with_value(it))?;\n+                    def.into()\n+                },\n+                ast::Union(it) => {\n+                    let def = self.union_to_def(container.with_value(it))?;\n+                    VariantId::from(def).into()\n+                },\n+                ast::Static(it) => {\n+                    let def = self.static_to_def(container.with_value(it))?;\n+                    DefWithBodyId::from(def).into()\n+                },\n+                ast::Const(it) => {\n+                    let def = self.const_to_def(container.with_value(it))?;\n+                    DefWithBodyId::from(def).into()\n+                },\n+                ast::TypeAlias(it) => {\n+                    let def = self.type_alias_to_def(container.with_value(it))?;\n+                    def.into()\n+                },\n+                ast::Variant(it) => {\n+                    let def = self.enum_variant_to_def(container.with_value(it))?;\n+                    VariantId::from(def).into()\n+                },\n+                _ => return None,\n+            }\n+        };\n+        Some(cont)\n+    }\n+\n     fn find_generic_param_container(&mut self, src: InFile<&SyntaxNode>) -> Option<GenericDefId> {\n         for container in src.cloned().ancestors_with_macros(self.db.upcast()).skip(1) {\n             let res: GenericDefId = match_ast! {"}]}