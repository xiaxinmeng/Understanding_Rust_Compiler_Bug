{"sha": "4c2ebc3947568f5ca11c4e8a97538296b4f78285", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMmViYzM5NDc1NjhmNWNhMTFjNGU4YTk3NTM4Mjk2YjRmNzgyODU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-23T11:12:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-23T11:12:02Z"}, "message": "Auto merge of #25416 - kballard:ffi-cstr-to-str-convenience, r=alexcrichton\n\nThis was motivated by http://www.evanmiller.org/a-taste-of-rust.html.\r\n\r\nA common problem when working with FFI right now is converting from raw\r\nC strings into `&str` or `String`. Right now you're required to say\r\nsomething like\r\n\r\n    let cstr = unsafe { CStr::from_ptr(ptr) };\r\n    let result = str::from_utf8(cstr.to_bytes());\r\n\r\nThis is slightly awkward, and is not particularly intuitive for people\r\nwho haven't used the ffi module before. We can do a bit better by\r\nproviding some convenience methods on CStr:\r\n\r\n    fn to_str(&self) -> Result<&str, str::Utf8Error>\r\n    fn to_string_lossy(&self) -> Cow<str>\r\n\r\nThis will make it immediately apparent to new users of CStr how to get a\r\nstring from a raw C string, so they can say:\r\n\r\n    let s = unsafe { CStr::from_ptr(ptr).to_string_lossy() };", "tree": {"sha": "63e1f3a8bdb342abacb432405355deefe586b555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63e1f3a8bdb342abacb432405355deefe586b555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c2ebc3947568f5ca11c4e8a97538296b4f78285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2ebc3947568f5ca11c4e8a97538296b4f78285", "html_url": "https://github.com/rust-lang/rust/commit/4c2ebc3947568f5ca11c4e8a97538296b4f78285", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c2ebc3947568f5ca11c4e8a97538296b4f78285/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bc80ba9fc8a297e0633a4f6e7fad1c333cbe8b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc80ba9fc8a297e0633a4f6e7fad1c333cbe8b4", "html_url": "https://github.com/rust-lang/rust/commit/8bc80ba9fc8a297e0633a4f6e7fad1c333cbe8b4"}, {"sha": "d0b5eb35a26a92b3845e90ac340a6422893c447b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b5eb35a26a92b3845e90ac340a6422893c447b", "html_url": "https://github.com/rust-lang/rust/commit/d0b5eb35a26a92b3845e90ac340a6422893c447b"}], "stats": {"total": 72, "additions": 72, "deletions": 0}, "files": [{"sha": "8c066b3dc2e8107b22149bd60967717219ff44a9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4c2ebc3947568f5ca11c4e8a97538296b4f78285/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c2ebc3947568f5ca11c4e8a97538296b4f78285/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=4c2ebc3947568f5ca11c4e8a97538296b4f78285", "patch": "@@ -10,6 +10,7 @@\n \n #![unstable(feature = \"std_misc\")]\n \n+use borrow::Cow;\n use convert::{Into, From};\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use error::Error;\n@@ -22,6 +23,7 @@ use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n use slice;\n+use str;\n use string::String;\n use vec::Vec;\n \n@@ -113,6 +115,26 @@ pub struct CString {\n ///     work(&s);\n /// }\n /// ```\n+///\n+/// Converting a foreign C string into a Rust `String`\n+///\n+/// ```no_run\n+/// # #![feature(libc,cstr_to_str)]\n+/// extern crate libc;\n+/// use std::ffi::CStr;\n+///\n+/// extern { fn my_string() -> *const libc::c_char; }\n+///\n+/// fn my_string_safe() -> String {\n+///     unsafe {\n+///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     println!(\"string: {}\", my_string_safe());\n+/// }\n+/// ```\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n@@ -327,6 +349,39 @@ impl CStr {\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n         unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.inner) }\n     }\n+\n+    /// Yields a `&str` slice if the `CStr` contains valid UTF-8.\n+    ///\n+    /// This function will calculate the length of this string and check for\n+    /// UTF-8 validity, and then return the `&str` if it's valid.\n+    ///\n+    /// > **Note**: This method is currently implemented to check for validity\n+    /// > after a 0-cost cast, but it is planned to alter its definition in the\n+    /// > future to perform the length calculation in addition to the UTF-8\n+    /// > check whenever this method is called.\n+    #[unstable(feature = \"cstr_to_str\", reason = \"recently added\")]\n+    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n+        // NB: When CStr is changed to perform the length check in .to_bytes() instead of in\n+        // from_ptr(), it may be worth considering if this should be rewritten to do the UTF-8\n+        // check inline with the length calculation instead of doing it afterwards.\n+        str::from_utf8(self.to_bytes())\n+    }\n+\n+    /// Converts a `CStr` into a `Cow<str>`.\n+    ///\n+    /// This function will calculate the length of this string (which normally\n+    /// requires a linear amount of work to be done) and then return the\n+    /// resulting slice as a `Cow<str>`, replacing any invalid UTF-8 sequences\n+    /// with `U+FFFD REPLACEMENT CHARACTER`.\n+    ///\n+    /// > **Note**: This method is currently implemented to check for validity\n+    /// > after a 0-cost cast, but it is planned to alter its definition in the\n+    /// > future to perform the length calculation in addition to the UTF-8\n+    /// > check whenever this method is called.\n+    #[unstable(feature = \"cstr_to_str\", reason = \"recently added\")]\n+    pub fn to_string_lossy(&self) -> Cow<str> {\n+        String::from_utf8_lossy(self.to_bytes())\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -355,6 +410,7 @@ mod tests {\n     use prelude::v1::*;\n     use super::*;\n     use libc;\n+    use borrow::Cow::{Borrowed, Owned};\n \n     #[test]\n     fn c_to_rust() {\n@@ -404,4 +460,20 @@ mod tests {\n             assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n         }\n     }\n+\n+    #[test]\n+    fn to_str() {\n+        let data = b\"123\\xE2\\x80\\xA6\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n+            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n+        }\n+        let data = b\"123\\xE2\\0\";\n+        let ptr = data.as_ptr() as *const libc::c_char;\n+        unsafe {\n+            assert!(CStr::from_ptr(ptr).to_str().is_err());\n+            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n+        }\n+    }\n }"}]}