{"sha": "e5d46a5bdac3f19793297914d4ada432024fbe95", "node_id": "C_kwDOAAsO6NoAKGU1ZDQ2YTViZGFjM2YxOTc5MzI5NzkxNGQ0YWRhNDMyMDI0ZmJlOTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T22:42:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-07T22:42:39Z"}, "message": "Auto merge of #106573 - matthiaskrgr:rollup-zkgfsta, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #101936 (Migrating rustc_infer to session diagnostics (part 3))\n - #104081 (PhantomData layout guarantees)\n - #104543 (Migrate `codegen_ssa` to diagnostics structs - [Part 3])\n - #105128 (Add O(1) `Vec -> VecDeque` conversion guarantee)\n - #105517 (Fix process-panic-after-fork.rs to pass on newer versions of Android.)\n - #105859 (Point out span where we could introduce higher-ranked lifetime)\n - #106509 (Detect closures assigned to binding in block)\n - #106553 (docs: make `HashSet::retain` doctest more clear)\n - #106556 (rustdoc: remove no-op mobile CSS `.content { margin-left: 0 }`)\n - #106564 (Change to immutable borrow when cloning element of RepeatN)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8906e54cb1653ccd0127f88b4979fb806f61aa9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8906e54cb1653ccd0127f88b4979fb806f61aa9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5d46a5bdac3f19793297914d4ada432024fbe95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d46a5bdac3f19793297914d4ada432024fbe95", "html_url": "https://github.com/rust-lang/rust/commit/e5d46a5bdac3f19793297914d4ada432024fbe95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5d46a5bdac3f19793297914d4ada432024fbe95/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee0412d1ef81efcfabe7f66cd21476ca85d618b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0412d1ef81efcfabe7f66cd21476ca85d618b1", "html_url": "https://github.com/rust-lang/rust/commit/ee0412d1ef81efcfabe7f66cd21476ca85d618b1"}, {"sha": "3076f269888008c6c47d5572e629a3e390597c97", "url": "https://api.github.com/repos/rust-lang/rust/commits/3076f269888008c6c47d5572e629a3e390597c97", "html_url": "https://github.com/rust-lang/rust/commit/3076f269888008c6c47d5572e629a3e390597c97"}], "stats": {"total": 2666, "additions": 1913, "deletions": 753}, "files": [{"sha": "86e1e50c400612676db1930fcb978186940292da", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3890,6 +3890,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde_json\",\n  \"smallvec\",\n  \"snap\",\n@@ -4024,6 +4025,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\","}, {"sha": "a4943d112042dc212d419f0247933a88cecb158a", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -440,15 +440,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         closure_kind: &str,\n         borrowed_path: &str,\n         capture_span: Span,\n+        scope: &str,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let mut err = struct_span_err!(\n             self,\n             closure_span,\n             E0373,\n-            \"{} may outlive the current function, but it borrows {}, which is owned by the current \\\n-             function\",\n-            closure_kind,\n-            borrowed_path,\n+            \"{closure_kind} may outlive the current {scope}, but it borrows {borrowed_path}, \\\n+             which is owned by the current {scope}\",\n         );\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n             .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));"}, {"sha": "d99bfc01a4298ccd50fb8d7fa0adec260065e361", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1423,6 +1423,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             //\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n+            (\n+                Some(name),\n+                BorrowExplanation::UsedLater(LaterUseKind::ClosureCapture, var_or_use_span, _),\n+            ) => self.report_escaping_closure_capture(\n+                borrow_spans,\n+                borrow_span,\n+                &RegionName {\n+                    name: self.synthesize_region_name(),\n+                    source: RegionNameSource::Static,\n+                },\n+                ConstraintCategory::CallArgument(None),\n+                var_or_use_span,\n+                &format!(\"`{}`\", name),\n+                \"block\",\n+            ),\n             (\n                 Some(name),\n                 BorrowExplanation::MustBeValidFor {\n@@ -1443,6 +1458,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     category,\n                     span,\n                     &format!(\"`{}`\", name),\n+                    \"function\",\n                 ),\n             (\n                 name,\n@@ -1895,6 +1911,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         Some(err)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_closure_capture(\n         &mut self,\n         use_span: UseSpans<'tcx>,\n@@ -1903,6 +1920,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         category: ConstraintCategory<'tcx>,\n         constraint_span: Span,\n         captured_var: &str,\n+        scope: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         let tcx = self.infcx.tcx;\n         let args_span = use_span.args_or_use();\n@@ -1933,8 +1951,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None => \"closure\",\n         };\n \n-        let mut err =\n-            self.cannot_capture_in_long_lived_closure(args_span, kind, captured_var, var_span);\n+        let mut err = self.cannot_capture_in_long_lived_closure(\n+            args_span,\n+            kind,\n+            captured_var,\n+            var_span,\n+            scope,\n+        );\n         err.span_suggestion_verbose(\n             sugg_span,\n             &format!(\n@@ -1956,10 +1979,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if matches!(use_span.generator_kind(), Some(GeneratorKind::Async(_))) {\n                     err.note(\n                         \"async blocks are not executed immediately and must either take a \\\n-                    reference or ownership of outside variables they use\",\n+                         reference or ownership of outside variables they use\",\n                     );\n                 } else {\n-                    let msg = format!(\"function requires argument type to outlive `{}`\", fr_name);\n+                    let msg = format!(\"{scope} requires argument type to outlive `{fr_name}`\");\n                     err.span_note(constraint_span, &msg);\n                 }\n             }"}, {"sha": "c4ae30151c4bd2ee6eac2beea26dbed1d1438a4d", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -444,6 +444,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// First span returned points to the location of the conflicting use\n     /// Second span if `Some` is returned in the case of closures and points\n     /// to the use of the path\n+    #[instrument(level = \"debug\", skip(self))]\n     fn later_use_kind(\n         &self,\n         borrow: &BorrowData<'tcx>,\n@@ -461,11 +462,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let block = &self.body.basic_blocks[location.block];\n \n                 let kind = if let Some(&Statement {\n-                    kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), _)),\n+                    kind: StatementKind::FakeRead(box (FakeReadCause::ForLet(_), place)),\n                     ..\n                 }) = block.statements.get(location.statement_index)\n                 {\n-                    LaterUseKind::FakeLetRead\n+                    if let Some(l) = place.as_local()\n+                        && let local_decl = &self.body.local_decls[l]\n+                        && local_decl.ty.is_closure()\n+                    {\n+                        LaterUseKind::ClosureCapture\n+                    } else {\n+                        LaterUseKind::FakeLetRead\n+                    }\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {"}, {"sha": "579ce90a760f2e977ee9a0a1e65da7827590c4ca", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -200,7 +200,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// increment the counter.\n     ///\n     /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n-    fn synthesize_region_name(&self) -> Symbol {\n+    pub(crate) fn synthesize_region_name(&self) -> Symbol {\n         let c = self.next_region_name.replace_with(|counter| *counter + 1);\n         Symbol::intern(&format!(\"'{:?}\", c))\n     }"}, {"sha": "680d810f78eb9b4121e98955f6cbad23629f52a3", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 283, "deletions": 266, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -8,8 +8,8 @@ use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n-use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::errors::{ExpectedPointerMutability, InvalidMonomorphization};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -284,15 +284,11 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n+                        tcx.sess.emit_err(InvalidMonomorphization::BasicIntegerType {\n                             span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                            name,\n+                            ty,\n+                        });\n                         return;\n                     }\n                 }\n@@ -838,40 +834,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n-    // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n-            {\n-                emit_error!($($fmt)*);\n-                return Err(());\n-            }\n-        }\n+        ($diag: expr) => {{\n+            bx.sess().emit_err($diag);\n+            return Err(());\n+        }};\n     }\n \n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond: expr, $diag: expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($diag);\n             }\n         };\n     }\n \n     macro_rules! require_simd {\n-        ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        ($ty: expr, $diag: expr) => {\n+            require!($ty.is_simd(), $diag)\n         };\n     }\n \n@@ -881,7 +861,11 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n+\n         let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n \n         let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n@@ -902,12 +886,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::InvalidBitmask {\n+                span,\n+                name,\n                 mask_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         };\n \n         let i1 = bx.type_i1();\n@@ -919,7 +904,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n-    require_simd!(arg_tys[0], \"input\");\n+    require_simd!(arg_tys[0], InvalidMonomorphization::SimdInput { span, name, ty: arg_tys[0] });\n     let in_ty = arg_tys[0];\n \n     let comparison = match name {\n@@ -934,23 +919,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n     if let Some(cmp_op) = comparison {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -975,34 +961,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                         span_bug!(span, \"could not evaluate shuffle index array length\")\n                     })\n                 }\n-                _ => return_error!(\n-                    \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                    args[2].layout.ty\n-                ),\n+                _ => return_error!(InvalidMonomorphization::SimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n         } else {\n             stripped.parse().unwrap_or_else(|_| {\n                 span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n             })\n         };\n \n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let total_len = u128::from(in_len) * 2;\n@@ -1015,15 +994,20 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let val = bx.const_get_elt(vector, i as u64);\n                 match bx.const_to_opt_u128(val, true) {\n                     None => {\n-                        emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexNotConstant {\n+                            span,\n+                            name,\n+                            arg_idx,\n+                        });\n                         None\n                     }\n                     Some(idx) if idx >= total_len => {\n-                        emit_error!(\n-                            \"shuffle index #{} is out of bounds (limit {})\",\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexOutOfBounds {\n+                            span,\n+                            name,\n                             arg_idx,\n-                            total_len\n-                        );\n+                            total_len,\n+                        });\n                         None\n                     }\n                     Some(idx) => Some(bx.const_i32(idx as i32)),\n@@ -1044,10 +1028,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphization::InsertedType {\n+                span,\n+                name,\n+                in_elem,\n+                in_ty,\n+                out_ty: arg_tys[2]\n+            }\n         );\n         return Ok(bx.insert_element(\n             args[0].immediate(),\n@@ -1058,28 +1045,26 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()));\n     }\n \n     if name == sym::simd_select {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphization::MismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphization::MaskType { span, name, ty: m_elem_ty }),\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = bx.type_i1();\n@@ -1111,11 +1096,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 args[0].immediate(),\n                 i.bit_width().unwrap_or_else(|| bx.data_layout().pointer_size.bits()),\n             ),\n-            _ => return_error!(\n-                \"vector argument `{}`'s element type `{}`, expected integer element type\",\n+            _ => return_error!(InvalidMonomorphization::VectorArgument {\n+                span,\n+                name,\n                 in_ty,\n                 in_elem\n-            ),\n+            }),\n         };\n \n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n@@ -1150,12 +1136,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -1168,42 +1155,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n-        #[allow(unused_macro_rules)]\n-        macro_rules! emit_error {\n-            ($msg: tt) => {\n-                emit_error!($msg, )\n-            };\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n-                {\n-                    emit_error!($($fmt)*);\n-                    return Err(());\n-                }\n-            }\n+            ($diag: expr) => {{\n+                bx.sess().emit_err($diag);\n+                return Err(());\n+            }};\n         }\n \n         let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n             let elem_ty = bx.cx.type_float_from_ty(*f);\n             match f.bit_width() {\n                 32 => (\"f32\", elem_ty),\n                 64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(\n-                        \"unsupported element type `{}` of floating-point vector `{}`\",\n-                        f.name_str(),\n-                        in_ty\n-                    );\n-                }\n+                _ => return_error!(InvalidMonomorphization::FloatingPointVector {\n+                    span,\n+                    name,\n+                    f_ty: *f,\n+                    in_ty,\n+                }),\n             }\n         } else {\n-            return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            return_error!(InvalidMonomorphization::FloatingPointType { span, name, in_ty });\n         };\n \n         let vec_ty = bx.type_vector(elem_ty, in_len);\n@@ -1225,7 +1197,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+            _ => return_error!(InvalidMonomorphization::UnrecognizedIntrinsic { span, name }),\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n@@ -1319,37 +1291,48 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         // Of the same length:\n         let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -1376,15 +1359,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1400,10 +1383,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                                 to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1452,32 +1437,40 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n \n         // Of the same length:\n         let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -1508,15 +1501,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1531,10 +1524,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                         be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1581,10 +1576,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -1607,25 +1599,28 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                                 32 => bx.const_real(bx.type_f32(), $identity),\n                                 64 => bx.const_real(bx.type_f64(), $identity),\n                                 v => return_error!(\n-                                    r#\"\n-unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    sym::$name,\n-                                    in_ty,\n-                                    in_elem,\n-                                    v,\n-                                    ret_ty\n+                                    InvalidMonomorphization::UnsupportedSymbolOfSize {\n+                                        span,\n+                                        name,\n+                                        symbol: sym::$name,\n+                                        in_ty,\n+                                        in_elem,\n+                                        size: v,\n+                                        ret_ty\n+                                    }\n                                 ),\n                             }\n                         };\n                         Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1653,22 +1648,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_i) => Ok(bx.$int_red(args[0].immediate(), true)),\n                     ty::Uint(_u) => Ok(bx.$int_red(args[0].immediate(), false)),\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1686,22 +1679,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n+                        _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                            span,\n+                            name,\n+                            symbol: sym::$name,\n                             in_ty,\n                             in_elem,\n                             ret_ty\n-                        ),\n+                        }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -1714,13 +1705,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                         let r = bx.$red(input);\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1733,16 +1725,18 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n     if name == sym::simd_cast_ptr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n@@ -1751,19 +1745,29 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast fat pointer `{}`\", in_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: in_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(p) => {\n                 let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast to fat pointer `{}`\", out_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: out_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n         }\n \n         if in_elem == out_elem {\n@@ -1774,66 +1778,76 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     }\n \n     if name == sym::simd_expose_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n+            }\n         }\n         match out_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", out_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: out_elem }),\n         }\n \n         return Ok(bx.ptrtoint(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_from_exposed_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", in_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: in_elem }),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n+            }\n         }\n \n         return Ok(bx.inttoptr(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_cast || name == sym::simd_as {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -1912,11 +1926,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n         require!(\n             false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+            InvalidMonomorphization::UnsupportedCast {\n+                span,\n+                name,\n+                in_ty,\n+                in_elem,\n+                ret_ty,\n+                out_elem\n+            }\n         );\n     }\n     macro_rules! arith_binary {\n@@ -1928,10 +1945,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -1959,10 +1976,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -2000,12 +2017,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphization::ExpectedVectorElementType {\n+                    span,\n+                    name,\n+                    expected_element: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vector_type: arg_tys[0]\n+                });\n             }\n         };\n         let llvm_intrinsic = &format!("}, {"sha": "d1ad687e6aee32a2b3e30c17557e58e366efce87", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -27,6 +27,7 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "8ca7103ed482cc5f7646537165823a4dbcf2041d", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -2616,7 +2616,7 @@ fn add_static_crate<'a>(\n             sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n         let mut archive = archive_builder_builder.new_archive_builder(sess);\n-        if let Err(e) = archive.add_archive(\n+        if let Err(error) = archive.add_archive(\n             cratepath,\n             Box::new(move |f| {\n                 if f == METADATA_FILENAME {\n@@ -2656,7 +2656,7 @@ fn add_static_crate<'a>(\n                 false\n             }),\n         ) {\n-            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+            sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n         }\n         if archive.build(&dst) {\n             link_upstream(&dst);"}, {"sha": "d318c15d34221231ef8843f97083094d054edb87", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -5,6 +5,7 @@ use crate::back::write::{\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n+use crate::errors;\n use crate::meth;\n use crate::mir;\n use crate::mir::operand::OperandValue;\n@@ -451,10 +452,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let Some(llfn) = cx.declare_c_main(llfty) else {\n             // FIXME: We should be smart and show a better diagnostic here.\n             let span = cx.tcx().def_span(rust_main_def_id);\n-            cx.sess()\n-                .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n-                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                .emit();\n+            cx.sess().emit_err(errors::MultipleMainFunctions { span });\n             cx.sess().abort_if_errors();\n             bug!();\n         };\n@@ -595,8 +593,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 &metadata,\n                 &exported_symbols::metadata_symbol_name(tcx),\n             );\n-            if let Err(err) = std::fs::write(&file_name, data) {\n-                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+            if let Err(error) = std::fs::write(&file_name, data) {\n+                tcx.sess.emit_fatal(errors::MetadataObjectFileWrite { error });\n             }\n             Some(CompiledModule {\n                 name: metadata_cgu_name,\n@@ -815,11 +813,7 @@ impl CrateInfo {\n         let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n-                tcx.sess.fatal(&format!(\n-                    \"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                    subsystem\n-                ));\n+                tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });\n             }\n             subsystem.to_string()\n         });"}, {"sha": "e1abb73a504a3bea8ce211910cc63bd15ffcbd75", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,10 +1,8 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_errors::struct_span_err;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n-use rustc_session::Session;\n use rustc_span::Span;\n \n use crate::base;\n@@ -193,10 +191,6 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    struct_span_err!(a, b, E0511, \"{}\", c).emit();\n-}\n-\n pub fn asm_const_to_str<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,"}, {"sha": "1599ccbb2594c747e7ef31495e0c2171f5c06417", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -93,6 +93,7 @@ fn push_debuginfo_type_name<'tcx>(\n                     Err(e) => {\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n+                        // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n                         tcx.sess.fatal(&format!(\"{}\", e));\n                     }\n                 }"}, {"sha": "d81252653dfe8094d9aafcf505075acb60a5f33c", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -6,7 +6,9 @@ use rustc_errors::{\n     IntoDiagnosticArg,\n };\n use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n use rustc_span::{Span, Symbol};\n+use rustc_type_ir::FloatTy;\n use std::borrow::Cow;\n use std::io::Error;\n use std::path::{Path, PathBuf};\n@@ -549,3 +551,432 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_multiple_main_functions)]\n+#[help]\n+pub struct MultipleMainFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_metadata_object_file_write)]\n+pub struct MetadataObjectFileWrite {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_windows_subsystem)]\n+pub struct InvalidWindowsSubsystem {\n+    pub subsystem: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_erroneous_constant)]\n+pub struct ErroneousConstant {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_polymorphic_constant_too_generic)]\n+pub struct PolymorphicConstantTooGeneric {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_shuffle_indices_evaluation)]\n+pub struct ShuffleIndicesEvaluation {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_memory_ordering)]\n+pub struct MissingMemoryOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_ordering)]\n+pub struct UnknownAtomicOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_atomic_compare_exchange)]\n+pub struct AtomicCompareExchange;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_operation)]\n+pub struct UnknownAtomicOperation;\n+\n+#[derive(Diagnostic)]\n+pub enum InvalidMonomorphization<'tcx> {\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_integer_type, code = \"E0511\")]\n+    BasicIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_float_type, code = \"E0511\")]\n+    BasicFloatType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_float_to_int_unchecked, code = \"E0511\")]\n+    FloatToIntUnchecked {\n+        #[primary_span]\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_vector, code = \"E0511\")]\n+    FloatingPointVector {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        f_ty: FloatTy,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_type, code = \"E0511\")]\n+    FloatingPointType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unrecognized_intrinsic, code = \"E0511\")]\n+    UnrecognizedIntrinsic {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_argument, code = \"E0511\")]\n+    SimdArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_input, code = \"E0511\")]\n+    SimdInput {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_first, code = \"E0511\")]\n+    SimdFirst {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_second, code = \"E0511\")]\n+    SimdSecond {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_third, code = \"E0511\")]\n+    SimdThird {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_return, code = \"E0511\")]\n+    SimdReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+    InvalidBitmask {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        mask_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+    ReturnLengthInputType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_second_argument_length, code = \"E0511\")]\n+    SecondArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_argument_length, code = \"E0511\")]\n+    ThirdArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+    ReturnIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+    SimdShuffle {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length, code = \"E0511\")]\n+    ReturnLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_element, code = \"E0511\")]\n+    ReturnElement {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_not_constant, code = \"E0511\")]\n+    ShuffleIndexNotConstant {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds, code = \"E0511\")]\n+    ShuffleIndexOutOfBounds {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+        total_len: u128,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_inserted_type, code = \"E0511\")]\n+    InsertedType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_type, code = \"E0511\")]\n+    ReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_return_type, code = \"E0511\")]\n+    ExpectedReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+    MismatchedLengths {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        m_len: u64,\n+        v_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mask_type, code = \"E0511\")]\n+    MaskType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_vector_argument, code = \"E0511\")]\n+    VectorArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cannot_return, code = \"E0511\")]\n+    CannotReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_element_type, code = \"E0511\")]\n+    ExpectedElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        second_arg: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        mutability: ExpectedPointerMutability,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_arg_element_type, code = \"E0511\")]\n+    ThirdArgElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        third_arg: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size, code = \"E0511\")]\n+    UnsupportedSymbolOfSize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        size: u64,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol, code = \"E0511\")]\n+    UnsupportedSymbol {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cast_fat_pointer, code = \"E0511\")]\n+    CastFatPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_pointer, code = \"E0511\")]\n+    ExpectedPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_usize, code = \"E0511\")]\n+    ExpectedUsize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+    UnsupportedCast {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+    UnsupportedOperation {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_vector_element_type, code = \"E0511\")]\n+    ExpectedVectorElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        vector_type: Ty<'tcx>,\n+    },\n+}\n+\n+pub enum ExpectedPointerMutability {\n+    Mut,\n+    Not,\n+}\n+\n+impl IntoDiagnosticArg for ExpectedPointerMutability {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            ExpectedPointerMutability::Mut => DiagnosticArgValue::Str(Cow::Borrowed(\"*mut\")),\n+            ExpectedPointerMutability::Not => DiagnosticArgValue::Str(Cow::Borrowed(\"*_\")),\n+        }\n+    }\n+}"}, {"sha": "14fe84a146da0792144787ee67a46f049a46dfa9", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n use rustc_middle::mir;\n@@ -44,10 +45,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n             match err {\n                 ErrorHandled::Reported(_) => {\n-                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                    self.cx.tcx().sess.emit_err(errors::ErroneousConstant { span: constant.span });\n                 }\n                 ErrorHandled::TooGeneric => {\n-                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+                    self.cx\n+                        .tcx()\n+                        .sess\n+                        .diagnostic()\n+                        .emit_bug(errors::PolymorphicConstantTooGeneric { span: constant.span });\n                 }\n             }\n             err\n@@ -87,7 +92,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (llval, c.ty())\n             })\n             .unwrap_or_else(|_| {\n-                bx.tcx().sess.span_err(span, \"could not evaluate shuffle_indices at compile time\");\n+                bx.tcx().sess.emit_err(errors::ShuffleIndicesEvaluation { span });\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(ty);\n                 let llty = bx.backend_type(bx.layout_of(ty));"}, {"sha": "766dc74cbbb6a39e66dd5dbacd6c82b80a821125", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,7 +1,9 @@\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n use super::FunctionCx;\n-use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n+use crate::common::IntPredicate;\n+use crate::errors;\n+use crate::errors::InvalidMonomorphization;\n use crate::glue;\n use crate::meth;\n use crate::traits::*;\n@@ -305,15 +307,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                         return;\n                     }\n                 }\n@@ -329,45 +323,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\",\n-                                name, arg_tys[0]\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicFloatType { span, name, ty: arg_tys[0] });\n                         return;\n                     }\n                 }\n             }\n \n             sym::float_to_int_unchecked => {\n                 if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                  intrinsic: expected basic float type, \\\n-                                  found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: arg_tys[0] });\n                     return;\n                 }\n                 let Some((_width, signed)) = int_type_width_signed(ret_ty, bx.tcx()) else {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                    intrinsic:  expected basic integer type, \\\n-                                    found `{}`\",\n-                            ret_ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: ret_ty });\n                     return;\n                 };\n                 if signed {\n@@ -402,7 +370,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n \n                 let Some((instruction, ordering)) = atomic.split_once('_') else {\n-                    bx.sess().fatal(\"Atomic intrinsic missing memory ordering\");\n+                    bx.sess().emit_fatal(errors::MissingMemoryOrdering);\n                 };\n \n                 let parse_ordering = |bx: &Bx, s| match s {\n@@ -412,25 +380,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     \"release\" => Release,\n                     \"acqrel\" => AcquireRelease,\n                     \"seqcst\" => SequentiallyConsistent,\n-                    _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    _ => bx.sess().emit_fatal(errors::UnknownAtomicOrdering),\n                 };\n \n                 let invalid_monomorphization = |ty| {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\",\n-                            name, ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                 };\n \n                 match instruction {\n                     \"cxchg\" | \"cxchgweak\" => {\n                         let Some((success, failure)) = ordering.split_once('_') else {\n-                            bx.sess().fatal(\"Atomic compare-exchange intrinsic missing failure memory ordering\");\n+                            bx.sess().emit_fatal(errors::AtomicCompareExchange);\n                         };\n                         let ty = substs.type_at(0);\n                         if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n@@ -529,7 +489,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             \"min\" => AtomicRmwBinOp::AtomicMin,\n                             \"umax\" => AtomicRmwBinOp::AtomicUMax,\n                             \"umin\" => AtomicRmwBinOp::AtomicUMin,\n-                            _ => bx.sess().fatal(\"unknown atomic operation\"),\n+                            _ => bx.sess().emit_fatal(errors::UnknownAtomicOperation),\n                         };\n \n                         let ty = substs.type_at(0);"}, {"sha": "c8c7afb5f919632b8555682136978d0ea4dc4c99", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -192,3 +192,102 @@ codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n \n codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n+    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n+\n+codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n+\n+codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n+\n+codegen_ssa_erroneous_constant = erroneous constant encountered\n+\n+codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n+\n+codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n+\n+codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n+\n+codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n+\n+codegen_ssa_unknown_atomic_operation = unknown atomic operation\n+\n+codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n+\n+codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type"}, {"sha": "52babec4f9ea74b730646cd28f79771f66ac7c5b", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -172,3 +172,142 @@ infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n infer_suggest_add_let_for_letchains = consider adding `let`\n+\n+infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n+\n+infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n+\n+infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n+infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{lifetime_1}`...\n+infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$ty_or_sig}` must implement `{$trait_path}`\n+\n+infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n+}\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough\n+\n+infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n+    .found = found `{$found}`\n+    .expected = expected `{$expected}`\n+    .expected_found = expected `{$expected}`\n+               {\"   \"}found `{$found}`\n+\n+infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n+infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_but_calling_introduces = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$lifetime_kind ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{assoc_item}` introduces an implicit `'static` lifetime requirement\n+    .label1 = {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }\n+    .label2 = ...is used and required to live as long as `'static` here because of an implicit lifetime bound on the {$has_impl_path ->\n+        [named] `impl` of `{$impl_path}`\n+        *[anon] inherent `impl`\n+    }\n+\n+infer_but_needs_to_satisfy = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but it needs to satisfy a `'static` lifetime requirement\n+    .influencer = this data with {$has_lifetime ->\n+        [named] lifetime `{lifetime}`\n+        *[anon] an anonymous lifetime `'_`\n+    }...\n+    .require = {$spans_empty ->\n+        *[true] ...is used and required to live as long as `'static` here\n+        [false] ...and is required to live as long as `'static` here\n+    }\n+    .used_here = ...is used here...\n+    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+\n+infer_more_targeted = {$has_param_name ->\n+    [true] `{$param_name}`\n+    *[false] `fn` parameter\n+} has {$has_lifetime ->\n+    [named] lifetime `{lifetime}`\n+    *[anon] an anonymous lifetime `'_`\n+} but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n+\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_because_of = because of this returned expression\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type"}, {"sha": "cadd53fbd8356b3409ec98e7d9eaac9cfb54fcc4", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -17,6 +17,7 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n unicode-width = \"0.1.4\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\""}, {"sha": "cbfee582d871f2c5925b0e8449e60dad19749212", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostic::IntoDiagnosticArg;\n use crate::{\n     Diagnostic, DiagnosticId, DiagnosticMessage, DiagnosticStyledString, ErrorGuaranteed,\n-    SubdiagnosticMessage,\n+    ExplicitBug, SubdiagnosticMessage,\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n@@ -12,6 +12,7 @@ use std::borrow::Cow;\n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n+use std::panic;\n use std::thread::panicking;\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n@@ -308,6 +309,58 @@ impl EmissionGuarantee for Noted {\n     }\n }\n \n+/// Marker type which enables implementation of `create_bug` and `emit_bug` functions for\n+/// bug struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Bug;\n+\n+impl<'a> DiagnosticBuilder<'a, Bug> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n+    pub(crate) fn new_bug(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Bug, None, message);\n+        Self::new_diagnostic_bug(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_bug(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic bug\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Bug {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+        // Then panic. No need to return the marker type.\n+        panic::panic_any(ExplicitBug);\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_bug(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`]."}, {"sha": "794b6efcc2b246674b452ad0f4e3aa3e120b2b6a", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -9,6 +9,7 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n+use rustc_type_ir as type_ir;\n use std::borrow::Cow;\n use std::fmt;\n use std::num::ParseIntError;\n@@ -170,6 +171,12 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n     }\n }\n \n+impl IntoDiagnosticArg for type_ir::FloatTy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.name_str()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(match self {"}, {"sha": "b4d23e96f8f45ca06a991bbfac73fa5622a0be41", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1133,6 +1133,20 @@ impl Handler {\n         self.create_fatal(fatal).emit()\n     }\n \n+    pub fn create_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> DiagnosticBuilder<'a, diagnostic_builder::Bug> {\n+        bug.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> diagnostic_builder::Bug {\n+        self.create_bug(bug).emit()\n+    }\n+\n     fn emit_diag_at_span(\n         &self,\n         mut diag: Diagnostic,"}, {"sha": "033a1842edb25c57c95ea20d97c910be67a82c3e", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 416, "deletions": 5, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,15 +1,18 @@\n use hir::GenericParamKind;\n use rustc_errors::{\n     fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString,\n-    MultiSpan, SubdiagnosticMessage,\n+    IntoDiagnosticArg, MultiSpan, SubdiagnosticMessage,\n };\n use rustc_hir as hir;\n-use rustc_hir::{FnRetTy, Ty};\n+use rustc_hir::FnRetTy;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_middle::ty::print::TraitRefPrintOnlyTraitPath;\n+use rustc_middle::ty::{Binder, FnSig, Region, Ty, TyCtxt};\n use rustc_span::symbol::kw;\n+use rustc_span::Symbol;\n use rustc_span::{symbol::Ident, BytePos, Span};\n \n+use crate::infer::error_reporting::nice_region_error::placeholder_error::Highlighted;\n use crate::infer::error_reporting::{\n     need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n     ObligationCauseAsDiagArg,\n@@ -357,8 +360,8 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n pub struct AddLifetimeParamsSuggestion<'a> {\n     pub tcx: TyCtxt<'a>,\n     pub sub: Region<'a>,\n-    pub ty_sup: &'a Ty<'a>,\n-    pub ty_sub: &'a Ty<'a>,\n+    pub ty_sup: &'a hir::Ty<'a>,\n+    pub ty_sub: &'a hir::Ty<'a>,\n     pub add_note: bool,\n }\n \n@@ -520,3 +523,411 @@ pub struct MismatchedStaticLifetime<'a> {\n     #[subdiagnostic]\n     pub implicit_static_lifetimes: Vec<ImplicitStaticLifetimeSubdiag>,\n }\n+\n+#[derive(Diagnostic)]\n+pub enum ExplicitLifetimeRequired<'a> {\n+    #[diag(infer_explicit_lifetime_required_with_ident, code = \"E0621\")]\n+    WithIdent {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        simple_ident: Ident,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_ident,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+    #[diag(infer_explicit_lifetime_required_with_param_type, code = \"E0621\")]\n+    WithParamType {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        named: String,\n+        #[suggestion(\n+            infer_explicit_lifetime_required_sugg_with_param_type,\n+            code = \"{new_ty}\",\n+            applicability = \"unspecified\"\n+        )]\n+        new_ty_span: Span,\n+        #[skip_arg]\n+        new_ty: Ty<'a>,\n+    },\n+}\n+\n+pub enum TyOrSig<'tcx> {\n+    Ty(Highlighted<'tcx, Ty<'tcx>>),\n+    ClosureSig(Highlighted<'tcx, Binder<'tcx, FnSig<'tcx>>>),\n+}\n+\n+impl IntoDiagnosticArg for TyOrSig<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        match self {\n+            TyOrSig::Ty(ty) => ty.into_diagnostic_arg(),\n+            TyOrSig::ClosureSig(sig) => sig.into_diagnostic_arg(),\n+        }\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ActualImplExplNotes<'tcx> {\n+    #[note(infer_actual_impl_expl_expected_signature_two)]\n+    ExpectedSignatureTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_any)]\n+    ExpectedSignatureAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_some)]\n+    ExpectedSignatureSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_signature_nothing)]\n+    ExpectedSignatureNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_two)]\n+    ExpectedPassiveTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_any)]\n+    ExpectedPassiveAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_some)]\n+    ExpectedPassiveSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_passive_nothing)]\n+    ExpectedPassiveNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_two)]\n+    ExpectedOtherTwo {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_any)]\n+    ExpectedOtherAny {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_some)]\n+    ExpectedOtherSome {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+    },\n+    #[note(infer_actual_impl_expl_expected_other_nothing)]\n+    ExpectedOtherNothing {\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implements_trait)]\n+    ButActuallyImplementsTrait {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_implemented_for_ty)]\n+    ButActuallyImplementedForTy {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+    #[note(infer_actual_impl_expl_but_actually_ty_implements)]\n+    ButActuallyTyImplements {\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        has_lifetime: bool,\n+        lifetime: usize,\n+        ty: String,\n+    },\n+}\n+\n+pub enum ActualImplExpectedKind {\n+    Signature,\n+    Passive,\n+    Other,\n+}\n+\n+pub enum ActualImplExpectedLifetimeKind {\n+    Two,\n+    Any,\n+    Some,\n+    Nothing,\n+}\n+\n+impl<'tcx> ActualImplExplNotes<'tcx> {\n+    pub fn new_expected(\n+        kind: ActualImplExpectedKind,\n+        lt_kind: ActualImplExpectedLifetimeKind,\n+        leading_ellipsis: bool,\n+        ty_or_sig: TyOrSig<'tcx>,\n+        trait_path: Highlighted<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+        lifetime_1: usize,\n+        lifetime_2: usize,\n+    ) -> Self {\n+        match (kind, lt_kind) {\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedSignatureTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedSignatureAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedSignatureSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Signature, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedSignatureNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedPassiveTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedPassiveAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedPassiveSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Passive, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedPassiveNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Two) => {\n+                Self::ExpectedOtherTwo {\n+                    leading_ellipsis,\n+                    ty_or_sig,\n+                    trait_path,\n+                    lifetime_1,\n+                    lifetime_2,\n+                }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Any) => {\n+                Self::ExpectedOtherAny { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Some) => {\n+                Self::ExpectedOtherSome { leading_ellipsis, ty_or_sig, trait_path, lifetime_1 }\n+            }\n+            (ActualImplExpectedKind::Other, ActualImplExpectedLifetimeKind::Nothing) => {\n+                Self::ExpectedOtherNothing { leading_ellipsis, ty_or_sig, trait_path }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_placeholder_mismatch)]\n+pub struct TraitPlaceholderMismatch<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(label_satisfy)]\n+    pub satisfy_span: Option<Span>,\n+    #[label(label_where)]\n+    pub where_span: Option<Span>,\n+    #[label(label_dup)]\n+    pub dup_span: Option<Span>,\n+    pub def_id: String,\n+    pub trait_def_id: String,\n+\n+    #[subdiagnostic]\n+    pub actual_impl_expl_notes: Vec<ActualImplExplNotes<'tcx>>,\n+}\n+\n+pub struct ConsiderBorrowingParamHelp {\n+    pub spans: Vec<Span>,\n+}\n+\n+impl AddToDiagnostic for ConsiderBorrowingParamHelp {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut type_param_span: MultiSpan = self.spans.clone().into();\n+        for &span in &self.spans {\n+            // Seems like we can't call f() here as Into<DiagnosticMessage> is required\n+            type_param_span.push_span_label(span, fluent::infer_tid_consider_borrowing);\n+        }\n+        let msg = f(diag, fluent::infer_tid_param_help.into());\n+        diag.span_help(type_param_span, msg);\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(infer_tid_rel_help)]\n+pub struct RelationshipHelp;\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_trait_impl_diff)]\n+pub struct TraitImplDiff {\n+    #[primary_span]\n+    #[label(found)]\n+    pub sp: Span,\n+    #[label(expected)]\n+    pub trait_sp: Span,\n+    #[note(expected_found)]\n+    pub note: (),\n+    #[subdiagnostic]\n+    pub param_help: ConsiderBorrowingParamHelp,\n+    #[subdiagnostic]\n+    // Seems like subdiagnostics are always pushed to the end, so this one\n+    // also has to be a subdiagnostic to maintain order.\n+    pub rel_help: Option<RelationshipHelp>,\n+    pub expected: String,\n+    pub found: String,\n+}\n+\n+pub struct DynTraitConstraintSuggestion {\n+    pub span: Span,\n+    pub ident: Ident,\n+}\n+\n+impl AddToDiagnostic for DynTraitConstraintSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        let mut multi_span: MultiSpan = vec![self.span].into();\n+        multi_span.push_span_label(self.span, fluent::infer_dtcs_has_lifetime_req_label);\n+        multi_span.push_span_label(self.ident.span, fluent::infer_dtcs_introduces_requirement);\n+        let msg = f(diag, fluent::infer_dtcs_has_req_note.into());\n+        diag.span_note(multi_span, msg);\n+        let msg = f(diag, fluent::infer_dtcs_suggestion.into());\n+        diag.span_suggestion_verbose(\n+            self.span.shrink_to_hi(),\n+            msg,\n+            \" + '_\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_calling_introduces, code = \"E0772\")]\n+pub struct ButCallingIntroduces {\n+    #[label(label1)]\n+    pub param_ty_span: Span,\n+    #[primary_span]\n+    #[label(label2)]\n+    pub cause_span: Span,\n+\n+    pub has_param_name: bool,\n+    pub param_name: String,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+    pub assoc_item: Symbol,\n+    pub has_impl_path: bool,\n+    pub impl_path: String,\n+}\n+\n+pub struct ReqIntroducedLocations {\n+    pub span: MultiSpan,\n+    pub spans: Vec<Span>,\n+    pub fn_decl_span: Span,\n+    pub cause_span: Span,\n+    pub add_label: bool,\n+}\n+\n+impl AddToDiagnostic for ReqIntroducedLocations {\n+    fn add_to_diagnostic_with<F>(mut self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        for sp in self.spans {\n+            self.span.push_span_label(sp, fluent::infer_ril_introduced_here);\n+        }\n+\n+        if self.add_label {\n+            self.span.push_span_label(self.fn_decl_span, fluent::infer_ril_introduced_by);\n+        }\n+        self.span.push_span_label(self.cause_span, fluent::infer_ril_because_of);\n+        let msg = f(diag, fluent::infer_ril_static_introduced_by.into());\n+        diag.span_note(self.span, msg);\n+    }\n+}\n+\n+pub struct MoreTargeted {\n+    pub ident: Symbol,\n+}\n+\n+impl AddToDiagnostic for MoreTargeted {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n+        diag.code(rustc_errors::error_code!(E0772));\n+        diag.set_primary_message(fluent::infer_more_targeted);\n+        diag.set_arg(\"ident\", self.ident);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(infer_but_needs_to_satisfy, code = \"E0759\")]\n+pub struct ButNeedsToSatisfy {\n+    #[primary_span]\n+    pub sp: Span,\n+    #[label(influencer)]\n+    pub influencer_point: Span,\n+    #[label(used_here)]\n+    pub spans: Vec<Span>,\n+    #[label(require)]\n+    pub require_span_as_label: Option<Span>,\n+    #[note(require)]\n+    pub require_span_as_note: Option<Span>,\n+    #[note(introduced_by_bound)]\n+    pub bound: Option<Span>,\n+\n+    #[subdiagnostic]\n+    pub req_introduces_loc: Option<ReqIntroducedLocations>,\n+\n+    pub spans_empty: bool,\n+    pub has_lifetime: bool,\n+    pub lifetime: String,\n+}"}, {"sha": "59fb74eb54378f0c1e836c33214251659871d701", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -9,7 +9,7 @@ mod different_lifetimes;\n pub mod find_anon_type;\n mod mismatched_static_lifetime;\n mod named_anon_conflict;\n-mod placeholder_error;\n+pub(crate) mod placeholder_error;\n mod placeholder_relation;\n mod static_impl_trait;\n mod trait_impl_difference;"}, {"sha": "4e13ec90228d66c8b451cb885b17ed794094e258", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,8 +1,11 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n-use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use crate::{\n+    errors::ExplicitLifetimeRequired,\n+    infer::error_reporting::nice_region_error::find_anon_type::find_anon_type,\n+};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_middle::ty;\n use rustc_span::symbol::kw;\n \n@@ -86,31 +89,17 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         {\n             return None;\n         }\n-\n-        let (error_var, span_label_var) = match param.pat.simple_ident() {\n-            Some(simple_ident) => (\n-                format!(\"the type of `{}`\", simple_ident),\n-                format!(\"the type of `{}`\", simple_ident),\n-            ),\n-            None => (\"parameter type\".to_owned(), \"type\".to_owned()),\n+        let named = named.to_string();\n+        let err = match param.pat.simple_ident() {\n+            Some(simple_ident) => ExplicitLifetimeRequired::WithIdent {\n+                span,\n+                simple_ident,\n+                named,\n+                new_ty_span,\n+                new_ty,\n+            },\n+            None => ExplicitLifetimeRequired::WithParamType { span, named, new_ty_span, new_ty },\n         };\n-\n-        let mut diag = struct_span_err!(\n-            self.tcx().sess,\n-            span,\n-            E0621,\n-            \"explicit lifetime required in {}\",\n-            error_var\n-        );\n-\n-        diag.span_label(span, format!(\"lifetime `{}` required\", named));\n-        diag.span_suggestion(\n-            new_ty_span,\n-            &format!(\"add explicit lifetime `{}` to {}\", named, span_label_var),\n-            new_ty,\n-            Applicability::Unspecified,\n-        );\n-\n-        Some(diag)\n+        Some(self.tcx().sess.parse_sess.create_err(err))\n     }\n }"}, {"sha": "202f39521e967d7283fbfe8b747ccb94788878ed", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 155, "deletions": 156, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,18 +1,58 @@\n+use crate::errors::{\n+    ActualImplExpectedKind, ActualImplExpectedLifetimeKind, ActualImplExplNotes,\n+    TraitPlaceholderMismatch, TyOrSig,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use rustc_data_structures::intern::Interned;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, RePlaceholder, ReVar, Region, TyCtxt};\n \n-use std::fmt::{self, Write};\n+use std::fmt;\n+\n+// HACK(eddyb) maybe move this in a more central location.\n+#[derive(Copy, Clone)]\n+pub struct Highlighted<'tcx, T> {\n+    tcx: TyCtxt<'tcx>,\n+    highlight: RegionHighlightMode<'tcx>,\n+    value: T,\n+}\n+\n+impl<'tcx, T> IntoDiagnosticArg for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        rustc_errors::DiagnosticArgValue::Str(self.to_string().into())\n+    }\n+}\n+\n+impl<'tcx, T> Highlighted<'tcx, T> {\n+    fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n+        Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n+    }\n+}\n+\n+impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n+where\n+    T: for<'a> Print<'tcx, FmtPrinter<'a, 'tcx>, Error = fmt::Error, Output = FmtPrinter<'a, 'tcx>>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n+        printer.region_highlight_mode = self.highlight;\n+\n+        let s = self.value.print(printer)?.into_buffer();\n+        f.write_str(&s)\n+    }\n+}\n \n impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n@@ -205,26 +245,21 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_substs: SubstsRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let span = cause.span();\n-        let msg = format!(\n-            \"implementation of `{}` is not general enough\",\n-            self.tcx().def_path_str(trait_def_id),\n-        );\n-        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n-\n-        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id)\n-        | ObligationCauseCode::ExprItemObligation(def_id, ..) =\n-            *cause.code()\n-        {\n-            err.span_label(span, \"doesn't satisfy where-clause\");\n-            err.span_label(\n-                self.tcx().def_span(def_id),\n-                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n-            );\n-            true\n-        } else {\n-            err.span_label(span, &msg);\n-            false\n-        };\n+\n+        let (leading_ellipsis, satisfy_span, where_span, dup_span, def_id) =\n+            if let ObligationCauseCode::ItemObligation(def_id)\n+            | ObligationCauseCode::ExprItemObligation(def_id, ..) = *cause.code()\n+            {\n+                (\n+                    true,\n+                    Some(span),\n+                    Some(self.tcx().def_span(def_id)),\n+                    None,\n+                    self.tcx().def_path_str(def_id),\n+                )\n+            } else {\n+                (false, None, None, Some(span), String::new())\n+            };\n \n         let expected_trait_ref = self\n             .cx\n@@ -284,8 +319,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             ?expected_self_ty_has_vid,\n         );\n \n-        self.explain_actual_impl_that_was_found(\n-            &mut err,\n+        let actual_impl_expl_notes = self.explain_actual_impl_that_was_found(\n             sub_placeholder,\n             sup_placeholder,\n             has_sub,\n@@ -299,7 +333,15 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n             leading_ellipsis,\n         );\n \n-        err\n+        self.tcx().sess.create_err(TraitPlaceholderMismatch {\n+            span,\n+            satisfy_span,\n+            where_span,\n+            dup_span,\n+            def_id,\n+            trait_def_id: self.tcx().def_path_str(trait_def_id),\n+            actual_impl_expl_notes,\n+        })\n     }\n \n     /// Add notes with details about the expected and actual trait refs, with attention to cases\n@@ -309,7 +351,6 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n     /// due to the number of combinations we have to deal with.\n     fn explain_actual_impl_that_was_found(\n         &self,\n-        err: &mut Diagnostic,\n         sub_placeholder: Option<Region<'tcx>>,\n         sup_placeholder: Option<Region<'tcx>>,\n         has_sub: Option<usize>,\n@@ -321,39 +362,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n         leading_ellipsis: bool,\n-    ) {\n-        // HACK(eddyb) maybe move this in a more central location.\n-        #[derive(Copy, Clone)]\n-        struct Highlighted<'tcx, T> {\n-            tcx: TyCtxt<'tcx>,\n-            highlight: RegionHighlightMode<'tcx>,\n-            value: T,\n-        }\n-\n-        impl<'tcx, T> Highlighted<'tcx, T> {\n-            fn map<U>(self, f: impl FnOnce(T) -> U) -> Highlighted<'tcx, U> {\n-                Highlighted { tcx: self.tcx, highlight: self.highlight, value: f(self.value) }\n-            }\n-        }\n-\n-        impl<'tcx, T> fmt::Display for Highlighted<'tcx, T>\n-        where\n-            T: for<'a> Print<\n-                'tcx,\n-                FmtPrinter<'a, 'tcx>,\n-                Error = fmt::Error,\n-                Output = FmtPrinter<'a, 'tcx>,\n-            >,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                let mut printer = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS);\n-                printer.region_highlight_mode = self.highlight;\n-\n-                let s = self.value.print(printer)?.into_buffer();\n-                f.write_str(&s)\n-            }\n-        }\n-\n+    ) -> Vec<ActualImplExplNotes<'tcx>> {\n         // The weird thing here with the `maybe_highlighting_region` calls and the\n         // the match inside is meant to be like this:\n         //\n@@ -380,120 +389,110 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n-        err.note(&{\n-            let passive_voice = match (has_sub, has_sup) {\n-                (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n-                (None, None) => {\n-                    expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n-                    match expected_has_vid {\n-                        Some(_) => true,\n-                        None => any_self_ty_has_vid,\n-                    }\n-                }\n-            };\n \n-            let mut note = if same_self_type {\n-                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n-                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-\n-                if self_ty.value.is_closure()\n-                    && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n-                {\n-                    let closure_sig = self_ty.map(|closure| {\n-                        if let ty::Closure(_, substs) = closure.kind() {\n-                            self.tcx().signature_unclosure(\n-                                substs.as_closure().sig(),\n-                                rustc_hir::Unsafety::Normal,\n-                            )\n-                        } else {\n-                            bug!(\"type is not longer closure\");\n-                        }\n-                    });\n-\n-                    format!(\n-                        \"{}closure with signature `{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        closure_sig,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n-                } else {\n-                    format!(\n-                        \"{}`{}` must implement `{}`\",\n-                        if leading_ellipsis { \"...\" } else { \"\" },\n-                        self_ty,\n-                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    )\n+        let passive_voice = match (has_sub, has_sup) {\n+            (Some(_), _) | (_, Some(_)) => any_self_ty_has_vid,\n+            (None, None) => {\n+                expected_trait_ref.highlight.maybe_highlighting_region(vid, expected_has_vid);\n+                match expected_has_vid {\n+                    Some(_) => true,\n+                    None => any_self_ty_has_vid,\n                 }\n-            } else if passive_voice {\n-                format!(\n-                    \"{}`{}` would have to be implemented for the type `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n+            }\n+        };\n+\n+        let (kind, ty_or_sig, trait_path) = if same_self_type {\n+            let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+            self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+            if self_ty.value.is_closure() && self.tcx().is_fn_trait(expected_trait_ref.value.def_id)\n+            {\n+                let closure_sig = self_ty.map(|closure| {\n+                    if let ty::Closure(_, substs) = closure.kind() {\n+                        self.tcx().signature_unclosure(\n+                            substs.as_closure().sig(),\n+                            rustc_hir::Unsafety::Normal,\n+                        )\n+                    } else {\n+                        bug!(\"type is not longer closure\");\n+                    }\n+                });\n+                (\n+                    ActualImplExpectedKind::Signature,\n+                    TyOrSig::ClosureSig(closure_sig),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n-                format!(\n-                    \"{}`{}` must implement `{}`\",\n-                    if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref.map(|tr| tr.self_ty()),\n+                (\n+                    ActualImplExpectedKind::Other,\n+                    TyOrSig::Ty(self_ty),\n                     expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n-            };\n+            }\n+        } else if passive_voice {\n+            (\n+                ActualImplExpectedKind::Passive,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        } else {\n+            (\n+                ActualImplExpectedKind::Other,\n+                TyOrSig::Ty(expected_trait_ref.map(|tr| tr.self_ty())),\n+                expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+            )\n+        };\n \n-            match (has_sub, has_sup) {\n-                (Some(n1), Some(n2)) => {\n-                    let _ = write!(\n-                        note,\n-                        \", for any two lifetimes `'{}` and `'{}`...\",\n-                        std::cmp::min(n1, n2),\n-                        std::cmp::max(n1, n2),\n-                    );\n-                }\n-                (Some(n), _) | (_, Some(n)) => {\n-                    let _ = write!(note, \", for any lifetime `'{}`...\", n,);\n-                }\n-                (None, None) => {\n-                    if let Some(n) = expected_has_vid {\n-                        let _ = write!(note, \", for some specific lifetime `'{}`...\", n,);\n-                    }\n+        let (lt_kind, lifetime_1, lifetime_2) = match (has_sub, has_sup) {\n+            (Some(n1), Some(n2)) => {\n+                (ActualImplExpectedLifetimeKind::Two, std::cmp::min(n1, n2), std::cmp::max(n1, n2))\n+            }\n+            (Some(n), _) | (_, Some(n)) => (ActualImplExpectedLifetimeKind::Any, n, 0),\n+            (None, None) => {\n+                if let Some(n) = expected_has_vid {\n+                    (ActualImplExpectedLifetimeKind::Some, n, 0)\n+                } else {\n+                    (ActualImplExpectedLifetimeKind::Nothing, 0, 0)\n                 }\n             }\n+        };\n \n-            note\n-        });\n+        let note_1 = ActualImplExplNotes::new_expected(\n+            kind,\n+            lt_kind,\n+            leading_ellipsis,\n+            ty_or_sig,\n+            trait_path,\n+            lifetime_1,\n+            lifetime_2,\n+        );\n \n         let mut actual_trait_ref = highlight_trait_ref(actual_trait_ref);\n         actual_trait_ref.highlight.maybe_highlighting_region(vid, actual_has_vid);\n-        err.note(&{\n-            let passive_voice = match actual_has_vid {\n-                Some(_) => any_self_ty_has_vid,\n-                None => true,\n-            };\n \n-            let mut note = if same_self_type {\n-                format!(\n-                    \"...but it actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            } else if passive_voice {\n-                format!(\n-                    \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                )\n-            } else {\n-                format!(\n-                    \"...but `{}` actually implements `{}`\",\n-                    actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n-                )\n-            };\n+        let passive_voice = match actual_has_vid {\n+            Some(_) => any_self_ty_has_vid,\n+            None => true,\n+        };\n \n-            if let Some(n) = actual_has_vid {\n-                let _ = write!(note, \", for some specific lifetime `'{}`\", n);\n+        let trait_path = actual_trait_ref.map(|tr| tr.print_only_trait_path());\n+        let ty = actual_trait_ref.map(|tr| tr.self_ty()).to_string();\n+        let has_lifetime = actual_has_vid.is_some();\n+        let lifetime = actual_has_vid.unwrap_or_default();\n+\n+        let note_2 = if same_self_type {\n+            ActualImplExplNotes::ButActuallyImplementsTrait { trait_path, has_lifetime, lifetime }\n+        } else if passive_voice {\n+            ActualImplExplNotes::ButActuallyImplementedForTy {\n+                trait_path,\n+                ty,\n+                has_lifetime,\n+                lifetime,\n             }\n+        } else {\n+            ActualImplExplNotes::ButActuallyTyImplements { trait_path, ty, has_lifetime, lifetime }\n+        };\n \n-            note\n-        });\n+        vec![note_1, note_2]\n     }\n }"}, {"sha": "fb0f09198ccc185330064cb2b7df525d1048f26c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 70, "deletions": 110, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,11 +1,15 @@\n //! Error Reporting for static impl Traits.\n \n+use crate::errors::{\n+    ButCallingIntroduces, ButNeedsToSatisfy, DynTraitConstraintSuggestion, MoreTargeted,\n+    ReqIntroducedLocations,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{AddToDiagnostic, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n@@ -53,46 +57,32 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                     }\n \n                     let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-                    let lifetime = if sup_r.has_name() {\n-                        format!(\"lifetime `{}`\", sup_r)\n-                    } else {\n-                        \"an anonymous lifetime `'_`\".to_string()\n+                    let simple_ident = param.param.pat.simple_ident();\n+\n+                    let (has_impl_path, impl_path) = match ctxt.assoc_item.container {\n+                        AssocItemContainer::TraitContainer => {\n+                            let id = ctxt.assoc_item.container_id(tcx);\n+                            (true, tcx.def_path_str(id))\n+                        }\n+                        AssocItemContainer::ImplContainer => (false, String::new()),\n                     };\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        cause.span,\n-                        E0772,\n-                        \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                         requirement\",\n-                        param\n-                            .param\n-                            .pat\n-                            .simple_ident()\n-                            .map(|s| format!(\"`{}`\", s))\n-                            .unwrap_or_else(|| \"`fn` parameter\".to_string()),\n-                        lifetime,\n-                        ctxt.assoc_item.name,\n-                    );\n-                    err.span_label(param.param_ty_span, &format!(\"this data with {}...\", lifetime));\n-                    err.span_label(\n-                        cause.span,\n-                        &format!(\n-                            \"...is used and required to live as long as `'static` here \\\n-                             because of an implicit lifetime bound on the {}\",\n-                            match ctxt.assoc_item.container {\n-                                AssocItemContainer::TraitContainer => {\n-                                    let id = ctxt.assoc_item.container_id(tcx);\n-                                    format!(\"`impl` of `{}`\", tcx.def_path_str(id))\n-                                }\n-                                AssocItemContainer::ImplContainer => \"inherent `impl`\".to_string(),\n-                            },\n-                        ),\n-                    );\n+\n+                    let mut err = self.tcx().sess.create_err(ButCallingIntroduces {\n+                        param_ty_span: param.param_ty_span,\n+                        cause_span: cause.span,\n+                        has_param_name: simple_ident.is_some(),\n+                        param_name: simple_ident.map(|x| x.to_string()).unwrap_or_default(),\n+                        has_lifetime: sup_r.has_name(),\n+                        lifetime: sup_r.to_string(),\n+                        assoc_item: ctxt.assoc_item.name,\n+                        has_impl_path,\n+                        impl_path,\n+                    });\n                     if self.find_impl_on_dyn_trait(&mut err, param.param_ty, &ctxt) {\n                         let reported = err.emit();\n                         return Some(reported);\n                     } else {\n-                        err.cancel();\n+                        err.cancel()\n                     }\n                 }\n                 return None;\n@@ -108,25 +98,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sp = var_origin.span();\n         let return_sp = sub_origin.span();\n         let param = self.find_param_with_region(*sup_r, *sub_r)?;\n-        let (lifetime_name, lifetime) = if sup_r.has_name() {\n-            (sup_r.to_string(), format!(\"lifetime `{}`\", sup_r))\n-        } else {\n-            (\"'_\".to_owned(), \"an anonymous lifetime `'_`\".to_string())\n-        };\n-        let param_name = param\n-            .param\n-            .pat\n-            .simple_ident()\n-            .map(|s| format!(\"`{}`\", s))\n-            .unwrap_or_else(|| \"`fn` parameter\".to_string());\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            sp,\n-            E0759,\n-            \"{} has {} but it needs to satisfy a `'static` lifetime requirement\",\n-            param_name,\n-            lifetime,\n-        );\n+        let lifetime_name = if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n \n         let (mention_influencer, influencer_point) =\n             if sup_origin.span().overlaps(param.param_ty_span) {\n@@ -145,7 +117,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             } else {\n                 (!sup_origin.span().overlaps(return_sp), param.param_ty_span)\n             };\n-        err.span_label(influencer_point, &format!(\"this data with {}...\", lifetime));\n \n         debug!(\"try_report_static_impl_trait: param_info={:?}\", param);\n \n@@ -159,65 +130,70 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         spans.dedup_by_key(|span| (span.lo(), span.hi()));\n \n         // We try to make the output have fewer overlapping spans if possible.\n-        let require_msg = if spans.is_empty() {\n-            \"...is used and required to live as long as `'static` here\"\n-        } else {\n-            \"...and is required to live as long as `'static` here\"\n-        };\n         let require_span =\n             if sup_origin.span().overlaps(return_sp) { sup_origin.span() } else { return_sp };\n \n-        for span in &spans {\n-            err.span_label(*span, \"...is used here...\");\n-        }\n-\n-        if spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp) {\n-            // If any of the \"captured here\" labels appears on the same line or after\n-            // `require_span`, we put it on a note to ensure the text flows by appearing\n-            // always at the end.\n-            err.span_note(require_span, require_msg);\n+        let spans_empty = spans.is_empty();\n+        let require_as_note = spans.iter().any(|sp| sp.overlaps(return_sp) || *sp > return_sp);\n+        let bound = if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n+            Some(*bound)\n         } else {\n-            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n-            err.span_label(require_span, require_msg);\n-        }\n+            None\n+        };\n+\n+        let mut subdiag = None;\n \n-        if let SubregionOrigin::RelateParamBound(_, _, Some(bound)) = sub_origin {\n-            err.span_note(*bound, \"`'static` lifetime requirement introduced by this bound\");\n-        }\n         if let SubregionOrigin::Subtype(box TypeTrace { cause, .. }) = sub_origin {\n             if let ObligationCauseCode::ReturnValue(hir_id)\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id.into()) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n+                    let mut spans = Vec::new();\n                     let mut add_label = true;\n                     if let hir::FnRetTy::Return(ty) = fn_decl.output {\n                         let mut v = StaticLifetimeVisitor(vec![], tcx.hir());\n                         v.visit_ty(ty);\n                         if !v.0.is_empty() {\n                             span = v.0.clone().into();\n-                            for sp in v.0 {\n-                                span.push_span_label(sp, \"`'static` requirement introduced here\");\n-                            }\n+                            spans = v.0;\n                             add_label = false;\n                         }\n                     }\n-                    if add_label {\n-                        span.push_span_label(\n-                            fn_decl.output.span(),\n-                            \"requirement introduced by this return type\",\n-                        );\n-                    }\n-                    span.push_span_label(cause.span, \"because of this returned expression\");\n-                    err.span_note(\n+                    let fn_decl_span = fn_decl.output.span();\n+\n+                    subdiag = Some(ReqIntroducedLocations {\n                         span,\n-                        \"`'static` lifetime requirement introduced by the return type\",\n-                    );\n+                        spans,\n+                        fn_decl_span,\n+                        cause_span: cause.span,\n+                        add_label,\n+                    });\n                 }\n             }\n         }\n \n+        let diag = ButNeedsToSatisfy {\n+            sp,\n+            influencer_point,\n+            spans: spans.clone(),\n+            // If any of the \"captured here\" labels appears on the same line or after\n+            // `require_span`, we put it on a note to ensure the text flows by appearing\n+            // always at the end.\n+            require_span_as_note: require_as_note.then_some(require_span),\n+            // We don't need a note, it's already at the end, it can be shown as a `span_label`.\n+            require_span_as_label: (!require_as_note).then_some(require_span),\n+            req_introduces_loc: subdiag,\n+\n+            has_lifetime: sup_r.has_name(),\n+            lifetime: sup_r.to_string(),\n+            spans_empty,\n+            bound,\n+        };\n+\n+        let mut err = self.tcx().sess.create_err(diag);\n+\n         let fn_returns = tcx.return_type_impl_or_dyn_traits(anon_reg_sup.def_id);\n \n         let mut override_error_code = None;\n@@ -251,12 +227,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n             // Provide a more targeted error code and description.\n-            err.code(rustc_errors::error_code!(E0772));\n-            err.set_primary_message(&format!(\n-                \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\\n-                requirement\",\n-                param_name, lifetime, ident,\n-            ));\n+            let retarget_subdiag = MoreTargeted { ident };\n+            retarget_subdiag.add_to_diagnostic(&mut err);\n         }\n \n         let arg = match param.param.pat.simple_ident() {\n@@ -551,21 +523,9 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut traits = vec![];\n             let mut hir_v = HirTraitObjectVisitor(&mut traits, *found_did);\n             hir_v.visit_ty(&self_ty);\n-            for span in &traits {\n-                let mut multi_span: MultiSpan = vec![*span].into();\n-                multi_span\n-                    .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n-                multi_span.push_span_label(\n-                    ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n-                );\n-                err.span_note(multi_span, \"the used `impl` has a `'static` requirement\");\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"consider relaxing the implicit `'static` requirement\",\n-                    \" + '_\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+            for &span in &traits {\n+                let subdiag = DynTraitConstraintSuggestion { span, ident };\n+                subdiag.add_to_diagnostic(err);\n                 suggested = true;\n             }\n         }"}, {"sha": "17c887a132aaf598b3f6584e8d8d87619a3f742a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,10 +1,11 @@\n //! Error Reporting for `impl` items that do not match the obligations from their `trait`.\n \n+use crate::errors::{ConsiderBorrowingParamHelp, RelationshipHelp, TraitImplDiff};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::Subtype;\n use crate::traits::ObligationCauseCode::CompareImplItemObligation;\n-use rustc_errors::{ErrorGuaranteed, MultiSpan};\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n@@ -51,10 +52,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         trait_def_id: DefId,\n     ) -> ErrorGuaranteed {\n         let trait_sp = self.tcx().def_span(trait_def_id);\n-        let mut err = self\n-            .tcx()\n-            .sess\n-            .struct_span_err(sp, \"`impl` item signature doesn't match `trait` item signature\");\n \n         // Mark all unnamed regions in the type with a number.\n         // This diagnostic is called in response to lifetime errors, so be informative.\n@@ -91,9 +88,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let found =\n             self.cx.extract_inference_diagnostics_data(found.into(), Some(found_highlight)).name;\n \n-        err.span_label(sp, &format!(\"found `{}`\", found));\n-        err.span_label(trait_sp, &format!(\"expected `{}`\", expected));\n-\n         // Get the span of all the used type parameters in the method.\n         let assoc_item = self.tcx().associated_item(trait_def_id);\n         let mut visitor = TypeParamSpanVisitor { tcx: self.tcx(), types: vec![] };\n@@ -110,26 +104,18 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n             _ => {}\n         }\n-        let mut type_param_span: MultiSpan = visitor.types.to_vec().into();\n-        for &span in &visitor.types {\n-            type_param_span\n-                .push_span_label(span, \"consider borrowing this type parameter in the trait\");\n-        }\n \n-        err.note(&format!(\"expected `{}`\\n   found `{}`\", expected, found));\n-\n-        err.span_help(\n-            type_param_span,\n-            \"the lifetime requirements from the `impl` do not correspond to the requirements in \\\n-             the `trait`\",\n-        );\n-        if visitor.types.is_empty() {\n-            err.help(\n-                \"verify the lifetime relationships in the `trait` and `impl` between the `self` \\\n-                 argument, the other inputs and its output\",\n-            );\n-        }\n-        err.emit()\n+        let diag = TraitImplDiff {\n+            sp,\n+            trait_sp,\n+            note: (),\n+            param_help: ConsiderBorrowingParamHelp { spans: visitor.types.to_vec() },\n+            rel_help: visitor.types.is_empty().then_some(RelationshipHelp),\n+            expected,\n+            found,\n+        };\n+\n+        self.tcx().sess.emit_err(diag)\n     }\n }\n "}, {"sha": "ca43762aa214ec63c846c738a8a8aabe90d86e64", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1515,7 +1515,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             count: 1,\n         };\n         let elision_candidate = LifetimeElisionCandidate::Missing(missing_lifetime);\n-        for rib in self.lifetime_ribs.iter().rev() {\n+        for (i, rib) in self.lifetime_ribs.iter().enumerate().rev() {\n             debug!(?rib.kind);\n             match rib.kind {\n                 LifetimeRibKind::AnonymousCreateParameter { binder, .. } => {\n@@ -1532,16 +1532,31 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     } else {\n                         (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n                     };\n-                    rustc_errors::struct_span_err!(\n+                    let mut diag = rustc_errors::struct_span_err!(\n                         self.r.session,\n                         lifetime.ident.span,\n                         E0637,\n                         \"{}\",\n                         msg,\n-                    )\n-                    .span_label(lifetime.ident.span, note)\n-                    .emit();\n-\n+                    );\n+                    diag.span_label(lifetime.ident.span, note);\n+                    if elided {\n+                        for rib in self.lifetime_ribs[i..].iter().rev() {\n+                            if let LifetimeRibKind::Generics {\n+                                span,\n+                                kind: LifetimeBinderKind::PolyTrait | LifetimeBinderKind::WhereBound,\n+                                ..\n+                            } = &rib.kind\n+                            {\n+                                diag.span_help(\n+                                    *span,\n+                                    \"consider introducing a higher-ranked lifetime here with `for<'a>`\",\n+                                );\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    diag.emit();\n                     self.record_lifetime_res(lifetime.id, LifetimeRes::Error, elision_candidate);\n                     return;\n                 }"}, {"sha": "0017baa66abe00dfc166cb3fc7b3f2bc0f43e59e", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -2821,9 +2821,9 @@ impl<T, A: Allocator> From<Vec<T, A>> for VecDeque<T, A> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// In its current implementation, this is a very cheap\n-    /// conversion. This isn't yet a guarantee though, and\n-    /// shouldn't be relied on.\n+    /// This conversion is guaranteed to run in *O*(1) time\n+    /// and to not re-allocate the `Vec`'s buffer or allocate\n+    /// any additional memory.\n     #[inline]\n     fn from(other: Vec<T, A>) -> Self {\n         let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();"}, {"sha": "dc61d6065b8edaae5c11cc055aedc98c3ef7be36", "filename": "library/core/src/iter/sources/repeat_n.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_n.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -126,7 +126,7 @@ impl<A: Clone> Iterator for RepeatN<A> {\n             // zero so it won't be dropped later, and thus it's okay to take it here.\n             unsafe { ManuallyDrop::take(&mut self.element) }\n         } else {\n-            A::clone(&mut self.element)\n+            A::clone(&self.element)\n         })\n     }\n "}, {"sha": "1326fc9ab096f03d6edde634db009dc697c17c15", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -623,6 +623,12 @@ impl<T: ?Sized> !Sync for *mut T {}\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n ///\n+/// ## Layout\n+///\n+/// For all `T`, the following are guaranteed:\n+/// * `size_of::<PhantomData<T>>() == 0`\n+/// * `align_of::<PhantomData<T>>() == 1`\n+///\n /// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b59f89d321c47ad93f61b53950127157304e8a63", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -317,7 +317,7 @@ impl<T, S> HashSet<T, S> {\n     ///\n     /// let mut set = HashSet::from([1, 2, 3, 4, 5, 6]);\n     /// set.retain(|&k| k % 2 == 0);\n-    /// assert_eq!(set.len(), 3);\n+    /// assert_eq!(set, HashSet::from([2, 4, 6]));\n     /// ```\n     ///\n     /// # Performance"}, {"sha": "77401e8b76e80ba3e2e05a014e0788981770bc41", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1651,10 +1651,6 @@ in storage.js\n \t\tmargin-top: 1em;\n \t}\n \n-\t.content {\n-\t\tmargin-left: 0px;\n-\t}\n-\n \t.anchor {\n \t\tdisplay: none !important;\n \t}"}, {"sha": "00f50c33e1ccdb6b64ffb17488756027661ea5d1", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-3.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -8,10 +8,9 @@ struct Point {\n fn main() {\n     let mut c = {\n         let mut p = Point {x: \"1\".to_string(), y: \"2\".to_string() };\n-        || {\n+        || { //~ ERROR closure may outlive the current block, but it borrows `p`\n            let x = &mut p.x;\n            println!(\"{:?}\", p);\n-            //~^ ERROR `p` does not live long enough\n         }\n     };\n     c();"}, {"sha": "ee923804786852c807d88782b9caa5126d5ba775", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/borrowck/borrowck-3.stderr", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fborrowck%2Fborrowck-3.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,18 +1,22 @@\n-error[E0597]: `p` does not live long enough\n-  --> $DIR/borrowck-3.rs:13:29\n+error[E0373]: closure may outlive the current block, but it borrows `p`, which is owned by the current block\n+  --> $DIR/borrowck-3.rs:11:9\n    |\n-LL |     let mut c = {\n-   |         ----- borrow later stored here\n-LL |         let mut p = Point {x: \"1\".to_string(), y: \"2\".to_string() };\n LL |         || {\n-   |         -- value captured here\n+   |         ^^ may outlive borrowed value `p`\n LL |            let x = &mut p.x;\n LL |            println!(\"{:?}\", p);\n-   |                             ^ borrowed value does not live long enough\n-...\n-LL |     };\n-   |     - `p` dropped here while still borrowed\n+   |                             - `p` is borrowed here\n+   |\n+note: block requires argument type to outlive `'1`\n+  --> $DIR/borrowck-3.rs:9:9\n+   |\n+LL |     let mut c = {\n+   |         ^^^^^\n+help: to force the closure to take ownership of `p` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |         move || {\n+   |         ++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "78341735e191a1fbea98c8862328fc397e13bae6", "filename": "src/test/ui/error-codes/E0637.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0637.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -21,6 +21,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL |     T: Into<&u32>,\n    |             ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/E0637.rs:13:8\n+   |\n+LL |     T: Into<&u32>,\n+   |        ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9d859fddf56b472d706ab7e0529647bdfbdc238d", "filename": "src/test/ui/generics/issue-65285-incorrect-explicit-lifetime-name-needed.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerics%2Fissue-65285-incorrect-explicit-lifetime-name-needed.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3,6 +3,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL | fn should_error<T>() where T : Into<&u32> {}\n    |                                     ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:5:32\n+   |\n+LL | fn should_error<T>() where T : Into<&u32> {}\n+   |                                ^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/issue-65285-incorrect-explicit-lifetime-name-needed.rs:9:20"}, {"sha": "da2683121735f1176f97775866fbd4e6973ecbcb", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -84,42 +84,47 @@ fn expect_aborted(status: ExitStatus) {\n \n     #[cfg(target_os = \"android\")]\n     {\n-        // Android signals an abort() call with SIGSEGV at address 0xdeadbaad\n-        // See e.g. https://groups.google.com/g/android-ndk/c/laW1CJc7Icc\n-        assert!(signal == libc::SIGSEGV);\n-\n-        // Additional checks performed:\n-        // 1. Find last tombstone (similar to coredump but in text format) from the\n-        //    same executable (path) as we are (must be because of usage of fork):\n-        //    This ensures that we look into the correct tombstone.\n-        // 2. Cause of crash is a SIGSEGV with address 0xdeadbaad.\n-        // 3. libc::abort call is in one of top two functions on callstack.\n-        // The last two steps distinguish between a normal SIGSEGV and one caused\n-        // by libc::abort.\n-\n-        let this_exe = std::env::current_exe().unwrap().into_os_string().into_string().unwrap();\n-        let exe_string = format!(\">>> {this_exe} <<<\");\n-        let tombstone = (0..100)\n-            .map(|n| format!(\"/data/tombstones/tombstone_{n:02}\"))\n-            .filter(|f| std::path::Path::new(&f).exists())\n-            .map(|f| std::fs::read_to_string(&f).expect(\"Cannot read tombstone file\"))\n-            .filter(|f| f.contains(&exe_string))\n-            .last()\n-            .expect(\"no tombstone found\");\n-\n-        println!(\"Content of tombstone:\\n{tombstone}\");\n-\n-        assert!(\n-            tombstone.contains(\"signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad\")\n-        );\n-        let abort_on_top = tombstone\n-            .lines()\n-            .skip_while(|l| !l.contains(\"backtrace:\"))\n-            .skip(1)\n-            .take_while(|l| l.starts_with(\"    #\"))\n-            .take(2)\n-            .any(|f| f.contains(\"/system/lib/libc.so (abort\"));\n-        assert!(abort_on_top);\n+        assert!(signal == libc::SIGABRT || signal == libc::SIGSEGV);\n+\n+        if signal == libc::SIGSEGV {\n+            // Pre-KitKat versions of Android signal an abort() with SIGSEGV at address 0xdeadbaad\n+            // See e.g. https://groups.google.com/g/android-ndk/c/laW1CJc7Icc\n+            //\n+            // This behavior was changed in KitKat to send a standard SIGABRT signal.\n+            // See: https://r.android.com/60341\n+            //\n+            // Additional checks performed:\n+            // 1. Find last tombstone (similar to coredump but in text format) from the\n+            //    same executable (path) as we are (must be because of usage of fork):\n+            //    This ensures that we look into the correct tombstone.\n+            // 2. Cause of crash is a SIGSEGV with address 0xdeadbaad.\n+            // 3. libc::abort call is in one of top two functions on callstack.\n+            // The last two steps distinguish between a normal SIGSEGV and one caused\n+            // by libc::abort.\n+\n+            let this_exe = std::env::current_exe().unwrap().into_os_string().into_string().unwrap();\n+            let exe_string = format!(\">>> {this_exe} <<<\");\n+            let tombstone = (0..100)\n+                .map(|n| format!(\"/data/tombstones/tombstone_{n:02}\"))\n+                .filter(|f| std::path::Path::new(&f).exists())\n+                .map(|f| std::fs::read_to_string(&f).expect(\"Cannot read tombstone file\"))\n+                .filter(|f| f.contains(&exe_string))\n+                .last()\n+                .expect(\"no tombstone found\");\n+\n+            println!(\"Content of tombstone:\\n{tombstone}\");\n+\n+            assert!(tombstone\n+                .contains(\"signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad\"));\n+            let abort_on_top = tombstone\n+                .lines()\n+                .skip_while(|l| !l.contains(\"backtrace:\"))\n+                .skip(1)\n+                .take_while(|l| l.starts_with(\"    #\"))\n+                .take(2)\n+                .any(|f| f.contains(\"/system/lib/libc.so (abort\"));\n+            assert!(abort_on_top);\n+        }\n     }\n }\n "}, {"sha": "51fe118c93ff146c6f67d8da2cdf9437f1d21daa", "filename": "src/test/ui/unboxed-closures/unboxed-closure-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -5,7 +5,7 @@\n fn main() {\n     let _f = {\n         let x = 0;\n-        || x //~ ERROR `x` does not live long enough\n+        || x //~ ERROR closure may outlive the current block, but it borrows `x`\n     };\n     _f;\n }"}, {"sha": "43e9af24a7c2bc0d655e0cb36b2145a6284fe741", "filename": "src/test/ui/unboxed-closures/unboxed-closure-region.stderr", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-region.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -1,16 +1,21 @@\n-error[E0597]: `x` does not live long enough\n-  --> $DIR/unboxed-closure-region.rs:8:12\n+error[E0373]: closure may outlive the current block, but it borrows `x`, which is owned by the current block\n+  --> $DIR/unboxed-closure-region.rs:8:9\n    |\n-LL |     let _f = {\n-   |         -- borrow later stored here\n-LL |         let x = 0;\n LL |         || x\n-   |         -- ^ borrowed value does not live long enough\n+   |         ^^ - `x` is borrowed here\n    |         |\n-   |         value captured here\n-LL |     };\n-   |     - `x` dropped here while still borrowed\n+   |         may outlive borrowed value `x`\n+   |\n+note: block requires argument type to outlive `'1`\n+  --> $DIR/unboxed-closure-region.rs:6:9\n+   |\n+LL |     let _f = {\n+   |         ^^\n+help: to force the closure to take ownership of `x` (and any other referenced variables), use the `move` keyword\n+   |\n+LL |         move || x\n+   |         ++++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0597`.\n+For more information about this error, try `rustc --explain E0373`."}, {"sha": "f4d14b5f87bec9fd1bb52881b9e8227f1cd18017", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2015.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2015.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3,6 +3,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL |     T: WithType<&u32>\n    |                 ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/where-clause-inherent-impl-ampersand.rs:13:8\n+   |\n+LL |     T: WithType<&u32>\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "f4d14b5f87bec9fd1bb52881b9e8227f1cd18017", "filename": "src/test/ui/underscore-lifetime/where-clause-inherent-impl-ampersand.rust2018.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-inherent-impl-ampersand.rust2018.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3,6 +3,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL |     T: WithType<&u32>\n    |                 ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/where-clause-inherent-impl-ampersand.rs:13:8\n+   |\n+LL |     T: WithType<&u32>\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "63fc1a19b9383e53b686fe8ee0c2a5a1712e5792", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2015.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2015.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3,6 +3,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL |     T: WithType<&u32>\n    |                 ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/where-clause-trait-impl-region.rs:11:8\n+   |\n+LL |     T: WithType<&u32>\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "63fc1a19b9383e53b686fe8ee0c2a5a1712e5792", "filename": "src/test/ui/underscore-lifetime/where-clause-trait-impl-region.rust2018.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fwhere-clause-trait-impl-region.rust2018.stderr?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -3,6 +3,12 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n    |\n LL |     T: WithType<&u32>\n    |                 ^ explicit lifetime name needed here\n+   |\n+help: consider introducing a higher-ranked lifetime here with `for<'a>`\n+  --> $DIR/where-clause-trait-impl-region.rs:11:8\n+   |\n+LL |     T: WithType<&u32>\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "d3734e90b7ffa97c47633d0a0b6909356ea26160", "filename": "src/tools/rustfmt/tests/target/issue_4110.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5d46a5bdac3f19793297914d4ada432024fbe95/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fissue_4110.rs?ref=e5d46a5bdac3f19793297914d4ada432024fbe95", "patch": "@@ -20,6 +20,7 @@ fn bindings() {\n                 category,\n                 span,\n                 &format!(\"`{}`\", name),\n+                \"function\",\n             ),\n         (\n             ref name,"}]}