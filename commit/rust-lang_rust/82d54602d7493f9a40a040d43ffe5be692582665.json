{"sha": "82d54602d7493f9a40a040d43ffe5be692582665", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZDU0NjAyZDc0OTNmOWE0MGEwNDBkNDNmZmU1YmU2OTI1ODI2NjU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-05T07:18:19Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-04-05T07:19:50Z"}, "message": "libstd: add basic complex numbers", "tree": {"sha": "0f20f4ccc6133244ce752c4751c9eb6e53590b62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f20f4ccc6133244ce752c4751c9eb6e53590b62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82d54602d7493f9a40a040d43ffe5be692582665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82d54602d7493f9a40a040d43ffe5be692582665", "html_url": "https://github.com/rust-lang/rust/commit/82d54602d7493f9a40a040d43ffe5be692582665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82d54602d7493f9a40a040d43ffe5be692582665/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b0401d774bac77bee279dff8641aba2b05cf9b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b0401d774bac77bee279dff8641aba2b05cf9b8", "html_url": "https://github.com/rust-lang/rust/commit/7b0401d774bac77bee279dff8641aba2b05cf9b8"}], "stats": {"total": 318, "additions": 318, "deletions": 0}, "files": [{"sha": "ceb1078d3f27b787d5943ea78825615409a646ce", "filename": "src/libstd/num/complex.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/82d54602d7493f9a40a040d43ffe5be692582665/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d54602d7493f9a40a040d43ffe5be692582665/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=82d54602d7493f9a40a040d43ffe5be692582665", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! Complex numbers.\n+\n+use core::num::{Zero,One,ToStrRadix};\n+use core::prelude::*;\n+\n+// FIXME #1284: handle complex NaN & infinity etc. This\n+// probably doesn't map to C's _Complex correctly.\n+\n+// XXX: Need generic sqrt to implement .norm(). Need generic sin/cos\n+// for .to/from_polar().\n+\n+\n+/// A complex number in Cartesian form.\n+#[deriving(Eq,Clone)]\n+pub struct Cmplx<T> {\n+    re: T,\n+    im: T\n+}\n+\n+pub type Complex = Cmplx<float>;\n+pub type Complex32 = Cmplx<f32>;\n+pub type Complex64 = Cmplx<f64>;\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Cmplx<T> {\n+    /// Create a new Cmplx\n+    #[inline]\n+    pub fn new(re: T, im: T) -> Cmplx<T> {\n+        Cmplx { re: re, im: im }\n+    }\n+\n+    /**\n+    Returns the square of the norm (since `T` doesn't necessarily\n+    have a sqrt function), i.e. `re^2 + im^2`.\n+    */\n+    #[inline]\n+    pub fn norm_sqr(&self) -> T {\n+        self.re * self.re + self.im * self.im\n+    }\n+\n+\n+    /// Returns the complex conjugate. i.e. `re - i im`\n+    #[inline]\n+    pub fn conj(&self) -> Cmplx<T> {\n+        Cmplx::new(self.re, -self.im)\n+    }\n+\n+\n+    /// Multiplies `self` by the scalar `t`.\n+    #[inline]\n+    pub fn scale(&self, t: T) -> Cmplx<T> {\n+        Cmplx::new(self.re * t, self.im * t)\n+    }\n+\n+    /// Divides `self` by the scalar `t`.\n+    #[inline]\n+    pub fn unscale(&self, t: T) -> Cmplx<T> {\n+        Cmplx::new(self.re / t, self.im / t)\n+    }\n+\n+    /// Returns `1/self`\n+    #[inline]\n+    pub fn inv(&self) -> Cmplx<T> {\n+        let norm_sqr = self.norm_sqr();\n+        Cmplx::new(self.re / norm_sqr,\n+                    -self.im / norm_sqr)\n+\n+    }\n+}\n+\n+/* arithmetic */\n+// (a + i b) + (c + i d) == (a + c) + i (b + d)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Add<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn add(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re + other.re, self.im + other.im)\n+    }\n+}\n+// (a + i b) - (c + i d) == (a - c) + i (b - d)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Sub<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn sub(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re - other.re, self.im - other.im)\n+    }\n+}\n+// (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn mul(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        Cmplx::new(self.re*other.re - self.im*other.im,\n+                     self.re*other.im + self.im*other.re)\n+    }\n+}\n+\n+// (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n+//   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+        let norm_sqr = other.norm_sqr();\n+        Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n+                     (self.im*other.re - self.re*other.im) / norm_sqr)\n+    }\n+}\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T>>\n+    Neg<Cmplx<T>> for Cmplx<T> {\n+    #[inline]\n+    fn neg(&self) -> Cmplx<T> {\n+        Cmplx::new(-self.re, -self.im)\n+    }\n+}\n+\n+/* constants */\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero>\n+    Zero for Cmplx<T> {\n+    #[inline]\n+    fn zero() -> Cmplx<T> {\n+        Cmplx::new(Zero::zero(), Zero::zero())\n+    }\n+}\n+\n+impl<T: Copy + Add<T,T> + Sub<T,T> + Mul<T,T> + Div<T,T> + Neg<T> + Zero + One>\n+    One for Cmplx<T> {\n+    #[inline]\n+    fn one() -> Cmplx<T> {\n+        Cmplx::new(One::one(), Zero::zero())\n+    }\n+}\n+\n+/* string conversions */\n+impl<T: ToStr + Zero + Ord + Neg<T>> ToStr for Cmplx<T> {\n+    fn to_str(&self) -> ~str {\n+        if self.im < Zero::zero() {\n+            fmt!(\"%s-%si\", self.re.to_str(), (-self.im).to_str())\n+        } else {\n+            fmt!(\"%s+%si\", self.re.to_str(), self.im.to_str())\n+        }\n+    }\n+}\n+\n+impl<T: ToStrRadix + Zero + Ord + Neg<T>> ToStrRadix for Cmplx<T> {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n+        if self.im < Zero::zero() {\n+            fmt!(\"%s-%si\", self.re.to_str_radix(radix), (-self.im).to_str_radix(radix))\n+        } else {\n+            fmt!(\"%s+%si\", self.re.to_str_radix(radix), self.im.to_str_radix(radix))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use core::num::{Zero,One};\n+\n+    pub static _0_0i : Complex = Cmplx { re: 0f, im: 0f };\n+    pub static _1_0i : Complex = Cmplx { re: 1f, im: 0f };\n+    pub static _1_1i : Complex = Cmplx { re: 1f, im: 1f };\n+    pub static _0_1i : Complex = Cmplx { re: 0f, im: 1f };\n+    pub static _neg1_1i : Complex = Cmplx { re: -1f, im: 1f };\n+    pub static _05_05i : Complex = Cmplx { re: 0.5f, im: 0.5f };\n+    pub static all_consts : [Complex, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n+\n+    #[test]\n+    fn test_consts() {\n+        // check our constants are what Cmplx::new creates\n+        fn test(c : Complex, r : float, i: float) {\n+            assert_eq!(c, Cmplx::new(r,i));\n+        }\n+        test(_0_0i, 0f, 0f);\n+        test(_1_0i, 1f, 0f);\n+        test(_1_1i, 1f, 1f);\n+        test(_neg1_1i, -1f, 1f);\n+        test(_05_05i, 0.5f, 0.5f);\n+\n+        assert_eq!(_0_0i, Zero::zero());\n+        assert_eq!(_1_0i, One::one());\n+    }\n+\n+    #[test]\n+    fn test_norm_sqr() {\n+        fn test(c: Complex, ns: float) {\n+            assert_eq!(c.norm_sqr(), ns);\n+        }\n+        test(_0_0i, 0f);\n+        test(_1_0i, 1f);\n+        test(_1_1i, 2f);\n+        test(_neg1_1i, 2f);\n+        test(_05_05i, 0.5f);\n+    }\n+\n+    #[test]\n+    fn test_scale_unscale() {\n+        assert_eq!(_05_05i.scale(2f), _1_1i);\n+        assert_eq!(_1_1i.unscale(2f), _05_05i);\n+        for all_consts.each |&c| {\n+            assert_eq!(c.scale(2f).unscale(2f), c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conj() {\n+        for all_consts.each |&c| {\n+            assert_eq!(c.conj(), Cmplx::new(c.re, -c.im));\n+            assert_eq!(c.conj().conj(), c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_inv() {\n+        assert_eq!(_1_1i.inv(), _05_05i.conj());\n+        assert_eq!(_1_0i.inv(), _1_0i.inv());\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore]\n+    fn test_inv_zero() {\n+        // XXX: should this really fail, or just NaN?\n+        _0_0i.inv();\n+    }\n+\n+\n+    mod arith {\n+        use super::*;\n+        use super::super::*;\n+        use core::num::Zero;\n+\n+        #[test]\n+        fn test_add() {\n+            assert_eq!(_05_05i + _05_05i, _1_1i);\n+            assert_eq!(_0_1i + _1_0i, _1_1i);\n+            assert_eq!(_1_0i + _neg1_1i, _0_1i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(_0_0i + c, c);\n+                assert_eq!(c + _0_0i, c);\n+            }\n+        }\n+\n+        #[test]\n+        fn test_sub() {\n+            assert_eq!(_05_05i - _05_05i, _0_0i);\n+            assert_eq!(_0_1i - _1_0i, _neg1_1i);\n+            assert_eq!(_0_1i - _neg1_1i, _1_0i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(c - _0_0i, c);\n+                assert_eq!(c - c, _0_0i);\n+            }\n+        }\n+\n+        #[test]\n+        fn test_mul() {\n+            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2f));\n+            assert_eq!(_1_1i * _0_1i, _neg1_1i);\n+\n+            // i^2 & i^4\n+            assert_eq!(_0_1i * _0_1i, -_1_0i);\n+            assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n+\n+            for all_consts.each |&c| {\n+                assert_eq!(c * _1_0i, c);\n+                assert_eq!(_1_0i * c, c);\n+            }\n+        }\n+        #[test]\n+        fn test_div() {\n+            assert_eq!(_neg1_1i / _0_1i, _1_1i);\n+            for all_consts.each |&c| {\n+                if c != Zero::zero() {\n+                    assert_eq!(c / c, _1_0i);\n+                }\n+            }\n+        }\n+        #[test]\n+        fn test_neg() {\n+            assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n+            assert_eq!((-_0_1i) * _0_1i, _1_0i);\n+            for all_consts.each |&c| {\n+                assert_eq!(-(-c), c);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_str() {\n+        fn test(c : Complex, s: ~str) {\n+            assert_eq!(c.to_str(), s);\n+        }\n+        test(_0_0i, ~\"0+0i\");\n+        test(_1_0i, ~\"1+0i\");\n+        test(_0_1i, ~\"0+1i\");\n+        test(_1_1i, ~\"1+1i\");\n+        test(_neg1_1i, ~\"-1+1i\");\n+        test(-_neg1_1i, ~\"1-1i\");\n+        test(_05_05i, ~\"0.5+0.5i\");\n+    }\n+}"}, {"sha": "9aac8d230558d77cd61fad04e2befe186819e84c", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82d54602d7493f9a40a040d43ffe5be692582665/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/82d54602d7493f9a40a040d43ffe5be692582665/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=82d54602d7493f9a40a040d43ffe5be692582665", "patch": "@@ -99,6 +99,8 @@ pub mod workcache;\n pub mod bigint;\n #[path=\"num/rational.rs\"]\n pub mod rational;\n+#[path=\"num/complex.rs\"]\n+pub mod complex;\n pub mod stats;\n pub mod semver;\n pub mod fileinput;"}]}