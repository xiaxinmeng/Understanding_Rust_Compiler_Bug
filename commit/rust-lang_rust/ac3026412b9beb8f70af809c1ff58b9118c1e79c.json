{"sha": "ac3026412b9beb8f70af809c1ff58b9118c1e79c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMzAyNjQxMmI5YmViOGY3MGFmODA5YzFmZjU4YjkxMThjMWU3OWM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-07T00:53:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-07T21:19:16Z"}, "message": "Revise EBML reader API\n\nNew one is less stateful, easier to work with.", "tree": {"sha": "294a0760c1dea3281c272f75cc371f1a07200d5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/294a0760c1dea3281c272f75cc371f1a07200d5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac3026412b9beb8f70af809c1ff58b9118c1e79c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac3026412b9beb8f70af809c1ff58b9118c1e79c", "html_url": "https://github.com/rust-lang/rust/commit/ac3026412b9beb8f70af809c1ff58b9118c1e79c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac3026412b9beb8f70af809c1ff58b9118c1e79c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f5f467dc0ef2858d08522745be4048994a0c552", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f5f467dc0ef2858d08522745be4048994a0c552", "html_url": "https://github.com/rust-lang/rust/commit/0f5f467dc0ef2858d08522745be4048994a0c552"}], "stats": {"total": 481, "additions": 201, "deletions": 280}, "files": [{"sha": "b561367c8b3561ba1bca4bfc13b8ee1583a93cd7", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 122, "deletions": 191, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=ac3026412b9beb8f70af809c1ff58b9118c1e79c", "patch": "@@ -62,7 +62,7 @@ impure fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n     ret ch as u8;\n }\n \n-impure fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n+fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n     auto len = _str.byte_len(rep);\n     auto st = @rec(rep=rep, mutable pos=0u, len=len);\n     auto result = parse_ty(st, sd);\n@@ -71,7 +71,6 @@ impure fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n             + _uint.to_str(st.pos, 10u) + \" of \"\n             + _uint.to_str(len, 10u) + \" in str '\" + rep + \"'\";\n     }\n-    check(st.pos == len);\n     ret result;\n }\n \n@@ -254,197 +253,142 @@ fn parse_def_id(vec[u8] buf) -> ast.def_id {\n     ret tup(crate_num, def_num);\n }\n \n-impure fn lookup_hash_entry(&ebml.reader ebml_r,\n-                            impure fn(&ebml.reader) -> bool eq_fn,\n-                            uint hash) -> bool {\n-    ebml.move_to_child_with_id(ebml_r, metadata.tag_index);\n-    ebml.move_to_child_with_id(ebml_r, metadata.tag_index_table);\n-    ebml.move_to_first_child(ebml_r);\n-\n-    // Move to the bucket.\n-    auto bucket_index = hash % 256u;\n-    auto buf_reader = ebml_r.reader.get_buf_reader();\n-    buf_reader.seek((bucket_index * 4u) as int, io.seek_cur);\n-    auto bucket_pos = ebml_r.reader.read_be_uint(4u);\n-    ebml.reset_reader(ebml_r, bucket_pos);\n-\n-    // Search to find the item ID in the bucket.\n-    check (ebml.peek(ebml_r).id == metadata.tag_index_buckets_bucket);\n-    ebml.move_to_first_child(ebml_r);\n-    while (ebml.bytes_left(ebml_r) > 0u) {\n-        if (ebml.peek(ebml_r).id == metadata.tag_index_buckets_bucket_elt) {\n-            ebml.move_to_first_child(ebml_r);\n-            auto pos = ebml_r.reader.read_be_uint(4u);\n-            if (eq_fn(ebml_r)) {\n-                // Found the item. Move to its data and return.\n-                ebml.reset_reader(ebml_r, pos);\n-                ebml.move_to_first_child(ebml_r);\n-                ret true;\n+fn lookup_hash(&ebml.doc d, fn(vec[u8]) -> bool eq_fn, uint hash)\n+    -> option.t[ebml.doc] {\n+    auto index = ebml.get_doc(d, metadata.tag_index);\n+    auto table = ebml.get_doc(index, metadata.tag_index_table);\n+\n+    auto hash_pos = table.start + (hash % 256u) * 4u;\n+    auto pos = ebml.be_uint_from_bytes(d.data, hash_pos, 4u);\n+    auto bucket = ebml.doc_at(d.data, pos);\n+    // Awkward logic because we can't ret from foreach yet\n+    auto result = option.none[ebml.doc];\n+    auto belt = metadata.tag_index_buckets_bucket_elt;\n+    for each (ebml.doc elt in ebml.tagged_docs(bucket, belt)) {\n+        alt (result) {\n+            case (option.none[ebml.doc]) {\n+                auto pos = ebml.be_uint_from_bytes(elt.data, elt.start, 4u);\n+                if (eq_fn(_vec.slice[u8](elt.data, elt.start+4u, elt.end))) {\n+                    result = option.some[ebml.doc](ebml.doc_at(d.data, pos));\n+                }\n             }\n-            ebml.move_to_parent(ebml_r);\n+            case (_) {}\n         }\n-        ebml.move_to_next_sibling(ebml_r);\n     }\n-\n-    ret false;\n+    ret result;\n }\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n-    impure fn eq_item(&ebml.reader ebml_r, str s) -> bool {\n-        auto this_str = _str.unsafe_from_bytes(ebml.read_data(ebml_r));\n-        ret _str.eq(this_str, s);\n+fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n+    fn eq_item(vec[u8] data, str s) -> bool {\n+        ret _str.eq(_str.unsafe_from_bytes(data), s);\n     }\n-\n     auto s = _str.connect(path, \".\");\n-\n-    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n-    auto ebml_r = ebml.create_reader(io_r);\n-    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_paths);\n-\n+    auto md = ebml.new_doc(data);\n+    auto paths = ebml.get_doc(md, metadata.tag_paths);\n     auto eqer = bind eq_item(_, s);\n-    auto hash = metadata.hash_path(s);\n-    if (!lookup_hash_entry(ebml_r, eqer, hash)) {\n-        ret rr_not_found(s);\n+    alt (lookup_hash(paths, eqer, metadata.hash_path(s))) {\n+        case (option.some[ebml.doc](?d)) {\n+            auto did_doc = ebml.get_doc(d, metadata.tag_def_id);\n+            ret rr_ok(parse_def_id(ebml.doc_data(did_doc)));\n+        }\n+        case (option.none[ebml.doc]) {\n+            ret rr_not_found(s);\n+        }\n     }\n-\n-    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_def_id);\n-    ebml.move_to_first_child(ebml_r);\n-    auto did_data = ebml.read_data(ebml_r);\n-    ebml.move_to_parent(ebml_r);\n-    auto did = parse_def_id(did_data);\n-    ret rr_ok(did);\n }\n \n-impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n-    impure fn eq_item(&ebml.reader ebml_r, int item_id) -> bool {\n-        ret (ebml_r.reader.read_be_uint(4u) as int) == item_id;\n+fn maybe_find_item(int item_id, &ebml.doc items) -> option.t[ebml.doc] {\n+    fn eq_item(vec[u8] bytes, int item_id) -> bool {\n+        ret ebml.be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n     }\n-\n     auto eqer = bind eq_item(_, item_id);\n-    auto hash = metadata.hash_def_num(item_id);\n-    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_items);\n-    auto found = lookup_hash_entry(ebml_r, eqer, hash);\n-    check (found);\n-}\n-\n-// Looks up an item in the given metadata and returns an EBML reader pointing\n-// to the item data.\n-impure fn lookup_item(int item_id, vec[u8] data) -> ebml.reader {\n-    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n-    auto ebml_r = ebml.create_reader(io_r);\n-    move_to_item(ebml_r, item_id);\n-    ret ebml_r;\n-}\n-\n-impure fn get_item_generic[T](&ebml.reader ebml_r, uint tag_id,\n-        impure fn(vec[u8] buf) -> T converter) -> T {\n-    while (ebml.bytes_left(ebml_r) > 0u) {\n-        auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == tag_id) {\n-            ebml.move_to_first_child(ebml_r);\n-            auto result = converter(ebml.read_data(ebml_r));\n-\n-            // Be kind, rewind.\n-            ebml.move_to_parent(ebml_r);\n-            ebml.move_to_parent(ebml_r);\n-            ebml.move_to_first_child(ebml_r);\n-\n-            ret result;\n-        }\n-        ebml.move_to_next_sibling(ebml_r);\n-    }\n-\n-    log #fmt(\"get_item_generic(): tag %u not found\", tag_id);\n-    fail;\n+    ret lookup_hash(items, eqer, metadata.hash_def_num(item_id));\n }\n \n-impure fn get_item_kind(&ebml.reader ebml_r) -> u8 {\n-    impure fn converter(vec[u8] data) -> u8 {\n-        auto x = @mutable 3;\n-        *x = 5;\n-        ret data.(0);\n+fn find_item(int item_id, &ebml.doc items) -> ebml.doc {\n+    alt (maybe_find_item(item_id, items)) {\n+        case (option.some[ebml.doc](?d)) {ret d;}\n     }\n-    auto f = converter;\n-    ret get_item_generic[u8](ebml_r, metadata.tag_items_data_item_kind, f);\n }\n \n-impure fn get_item_symbol(&ebml.reader ebml_r) -> str {\n-    impure fn converter(vec[u8] data) -> str {\n-        auto x = @mutable 3;\n-        *x = 5;\n-        ret _str.unsafe_from_bytes(data);\n-    }\n-    auto f = converter;\n-    ret get_item_generic[str](ebml_r, metadata.tag_items_data_item_symbol, f);\n+// Looks up an item in the given metadata and returns an EBML doc pointing\n+// to the item data.\n+fn lookup_item(int item_id, vec[u8] data) -> ebml.doc {\n+    auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n+    ret find_item(item_id, items);\n }\n \n-// FIXME: This is a *terrible* botch.\n-impure fn impure_parse_def_id(vec[u8] data) -> ast.def_id {\n-    auto x = @mutable 3;\n-    *x = 5;\n-    ret parse_def_id(data);\n+fn item_kind(&ebml.doc item) -> u8 {\n+    auto kind = ebml.get_doc(item, metadata.tag_items_data_item_kind);\n+    ret ebml.doc_as_uint(kind) as u8;\n }\n \n-impure fn get_variant_tag_id(&ebml.reader ebml_r) -> ast.def_id {\n-    auto f = impure_parse_def_id;\n-    ret get_item_generic[ast.def_id](ebml_r,\n-                                     metadata.tag_items_data_item_tag_id, f);\n+fn item_symbol(&ebml.doc item) -> str {\n+    auto sym = ebml.get_doc(item, metadata.tag_items_data_item_symbol);\n+    ret _str.unsafe_from_bytes(ebml.doc_data(sym));\n }\n \n-impure fn get_item_type(&ebml.reader ebml_r, int this_cnum) -> @ty.t {\n-    impure fn converter(int this_cnum, vec[u8] data) -> @ty.t {\n-        fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n-            // FIXME: This is completely wrong when linking against a crate\n-            // that, in turn, links against another crate. We need a mapping\n-            // from crate ID to crate \"meta\" attributes as part of the crate\n-            // metadata.\n-            auto buf = _str.bytes(s);\n-            auto external_def_id = parse_def_id(buf);\n-            ret tup(this_cnum, external_def_id._1);\n-        }\n-        auto s = _str.unsafe_from_bytes(data);\n-        ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n-    }\n-    auto f = bind converter(this_cnum, _);\n-    ret get_item_generic[@ty.t](ebml_r, metadata.tag_items_data_item_type, f);\n+fn variant_tag_id(&ebml.doc d) -> ast.def_id {\n+    auto tagdoc = ebml.get_doc(d, metadata.tag_items_data_item_tag_id);\n+    ret parse_def_id(ebml.doc_data(tagdoc));\n }\n \n-impure fn collect_def_ids(&ebml.reader ebml_r, int this_cnum, uint tag_id)\n-        -> vec[ast.def_id] {\n-    let vec[ast.def_id] def_ids = vec();\n-    while (ebml.bytes_left(ebml_r) > 0u) {\n-        auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == tag_id) {\n-            ebml.move_to_first_child(ebml_r);\n-\n-            auto data = ebml.read_data(ebml_r);\n-            auto external_def_id = parse_def_id(data);\n-            def_ids += vec(tup(this_cnum, external_def_id._1));\n-\n-            ebml.move_to_parent(ebml_r);\n-        }\n-        ebml.move_to_next_sibling(ebml_r);\n+fn item_type(&ebml.doc item, int this_cnum) -> @ty.t {\n+    fn parse_external_def_id(int this_cnum, str s) -> ast.def_id {\n+        // FIXME: This is completely wrong when linking against a crate\n+        // that, in turn, links against another crate. We need a mapping\n+        // from crate ID to crate \"meta\" attributes as part of the crate\n+        // metadata.\n+        auto buf = _str.bytes(s);\n+        auto external_def_id = parse_def_id(buf);\n+        ret tup(this_cnum, external_def_id._1);\n     }\n \n-    // Be kind, rewind.\n-    ebml.move_to_parent(ebml_r);\n-    ebml.move_to_first_child(ebml_r);\n-\n-    ret def_ids;\n+    auto tp = ebml.get_doc(item, metadata.tag_items_data_item_type);\n+    auto s = _str.unsafe_from_bytes(ebml.doc_data(tp));\n+    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n }\n \n-impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n-        -> vec[ast.def_id] {\n-    ret collect_def_ids(ebml_r, this_cnum,\n-                        metadata.tag_items_data_item_ty_param);\n+fn item_ty_params(&ebml.doc item, int this_cnum) -> vec[ast.def_id] {\n+    let vec[ast.def_id] params = vec();\n+    auto tp = metadata.tag_items_data_item_ty_param;\n+    for each (ebml.doc p in ebml.tagged_docs(item, tp)) {\n+        auto ext = parse_def_id(ebml.doc_data(p));\n+        _vec.push[ast.def_id](params, tup(this_cnum, ext._1));\n+    }\n+    ret params;\n }\n \n-impure fn collect_tag_variant_ids(&ebml.reader ebml_r, int this_cnum)\n-        -> vec[ast.def_id] {\n-    ret collect_def_ids(ebml_r, this_cnum,\n-                        metadata.tag_items_data_item_variant);\n+fn tag_variant_ids(&ebml.doc item, int this_cnum) -> vec[ast.def_id] {\n+    let vec[ast.def_id] ids = vec();\n+    auto v = metadata.tag_items_data_item_variant;\n+    for each (ebml.doc p in ebml.tagged_docs(item, v)) {\n+        auto ext = parse_def_id(ebml.doc_data(p));\n+        _vec.push[ast.def_id](ids, tup(this_cnum, ext._1));\n+    }\n+    ret ids;\n+}\n+\n+fn get_metadata_section(str filename) -> option.t[vec[u8]] {\n+    auto mb = llvm.LLVMRustCreateMemoryBufferWithContentsOfFile\n+        (_str.buf(filename));\n+    if (mb as int == 0) {ret option.none[vec[u8]];}\n+    auto of = mk_object_file(mb);\n+    auto si = mk_section_iter(of.llof);\n+    while (llvm.LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False) {\n+        auto name_buf = llvm.LLVMGetSectionName(si.llsi);\n+        auto name = _str.str_from_cstr(name_buf);\n+        if (_str.eq(name, x86.get_meta_sect_name())) {\n+            auto cbuf = llvm.LLVMGetSectionContents(si.llsi);\n+            auto csz = llvm.LLVMGetSectionSize(si.llsi);\n+            auto cvbuf = cbuf as _vec.vbuf;\n+            ret option.some[vec[u8]](_vec.vec_from_vbuf[u8](cvbuf, csz));\n+        }\n+        llvm.LLVMMoveToNextSection(si.llsi);\n+    }\n+    ret option.none[vec[u8]];\n }\n \n \n@@ -455,25 +399,12 @@ fn load_crate(session.session sess,\n     auto filename = parser.default_native_name(sess, ident);\n     for (str library_search_path in library_search_paths) {\n         auto path = fs.connect(library_search_path, filename);\n-        auto pbuf = _str.buf(path);\n-        auto mb = llvm.LLVMRustCreateMemoryBufferWithContentsOfFile(pbuf);\n-        if (mb as int != 0) {\n-            auto of = mk_object_file(mb);\n-            auto si = mk_section_iter(of.llof);\n-            while (llvm.LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) ==\n-                    False) {\n-                auto name_buf = llvm.LLVMGetSectionName(si.llsi);\n-                auto name = _str.str_from_cstr(name_buf);\n-                if (_str.eq(name, x86.get_meta_sect_name())) {\n-                    auto cbuf = llvm.LLVMGetSectionContents(si.llsi);\n-                    auto csz = llvm.LLVMGetSectionSize(si.llsi);\n-                    auto cvbuf = cbuf as _vec.vbuf;\n-                    auto cvec = _vec.vec_from_vbuf[u8](cvbuf, csz);\n-                    sess.set_external_crate(cnum, cvec);\n-                    ret;\n-                }\n-                llvm.LLVMMoveToNextSection(si.llsi);\n+        alt (get_metadata_section(path)) {\n+            case (option.some[vec[u8]](?cvec)) {\n+                sess.set_external_crate(cnum, cvec);\n+                ret;\n             }\n+            case (_) {}\n         }\n     }\n \n@@ -550,8 +481,8 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n         }\n     }\n \n-    auto ebml_r = lookup_item(did._1, data);\n-    auto kind_ch = get_item_kind(ebml_r);\n+    auto item = lookup_item(did._1, data);\n+    auto kind_ch = item_kind(item);\n \n     did = tup(cnum, did._1);\n \n@@ -569,7 +500,7 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     } else if (kind_ch == ('m' as u8))  { def = ast.def_mod(did);        }\n     else if (kind_ch == ('n' as u8))    { def = ast.def_native_mod(did); }\n     else if (kind_ch == ('v' as u8)) {\n-        auto tid = get_variant_tag_id(ebml_r);\n+        auto tid = variant_tag_id(item);\n         tid = tup(cnum, tid._1);\n         def = ast.def_variant(tid, did);\n     } else {\n@@ -583,14 +514,14 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_opt_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id);\n-    auto ebml_r = lookup_item(def._1, data);\n-    auto t = get_item_type(ebml_r, external_crate_id);\n+    auto item = lookup_item(def._1, data);\n+    auto t = item_type(item, external_crate_id);\n \n     auto tps_opt;\n-    auto kind_ch = get_item_kind(ebml_r);\n+    auto kind_ch = item_kind(item);\n     auto has_ty_params = kind_has_type_params(kind_ch);\n     if (has_ty_params) {\n-        auto tps = get_item_ty_params(ebml_r, external_crate_id);\n+        auto tps = item_ty_params(item, external_crate_id);\n         tps_opt = some[vec[ast.def_id]](tps);\n     } else {\n         tps_opt = none[vec[ast.def_id]];\n@@ -602,22 +533,22 @@ fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_opt_and_ty {\n fn get_symbol(session.session sess, ast.def_id def) -> str {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id);\n-    auto ebml_r = lookup_item(def._1, data);\n-    ret get_item_symbol(ebml_r);\n+    auto item = lookup_item(def._1, data);\n+    ret item_symbol(item);\n }\n \n fn get_tag_variants(session.session sess, ast.def_id def)\n         -> vec[trans.variant_info] {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id);\n-    auto ebml_r = lookup_item(def._1, data);\n+    auto items = ebml.get_doc(ebml.new_doc(data), metadata.tag_items);\n+    auto item = find_item(def._1, items);\n \n     let vec[trans.variant_info] infos = vec();\n-    auto variant_ids = collect_tag_variant_ids(ebml_r, external_crate_id);\n+    auto variant_ids = tag_variant_ids(item, external_crate_id);\n     for (ast.def_id did in variant_ids) {\n-        ebml.reset_reader(ebml_r, 0u);\n-        move_to_item(ebml_r, did._1);\n-        auto ctor_ty = get_item_type(ebml_r, external_crate_id);\n+        auto item = find_item(did._1, items);\n+        auto ctor_ty = item_type(item, external_crate_id);\n         let vec[@ty.t] arg_tys = vec();\n         alt (ctor_ty.struct) {\n             case (ty.ty_fn(_, ?args, _)) {"}, {"sha": "e9d0b788205b7d7dc170b4d0ed054c918466d903", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=ac3026412b9beb8f70af809c1ff58b9118c1e79c", "patch": "@@ -44,7 +44,9 @@ mod util {\n }\n \n auth driver.rustc.main = impure;\n+auth front.creader.parse_ty_str = impure;\n auth front.creader.load_crate = unsafe;\n+auth front.creader.get_metadata_section = unsafe;\n auth front.creader.lookup_def = impure;\n auth front.creader.get_type = impure;\n auth front.creader.get_symbol = impure;"}, {"sha": "0dbc066e2314d737e8cfb5cd27b9877b63695888", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 77, "deletions": 89, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac3026412b9beb8f70af809c1ff58b9118c1e79c/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=ac3026412b9beb8f70af809c1ff58b9118c1e79c", "patch": "@@ -13,118 +13,107 @@ type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n \n // EBML reading\n \n-type reader = rec(\n-    io.reader reader,\n-    mutable vec[ebml_state] states,\n-    uint size\n-);\n-\n-// TODO: eventually use u64 or big here\n-impure fn read_vint(&io.reader reader) -> uint {\n-    auto a = reader.read_byte() as u8;\n-    if (a & 0x80u8 != 0u8) { ret (a & 0x7fu8) as uint; }\n-    auto b = reader.read_byte() as u8;\n+type doc = rec(vec[u8] data,\n+               uint start,\n+               uint end);\n+\n+fn vint_at(vec[u8] data, uint start) -> tup(uint, uint) {\n+    auto a = data.(start);\n+    if (a & 0x80u8 != 0u8) { ret tup((a & 0x7fu8) as uint, start + 1u); }\n     if (a & 0x40u8 != 0u8) {\n-        ret (((a & 0x3fu8) as uint) << 8u) | (b as uint);\n-    }\n-    auto c = reader.read_byte() as u8;\n-    if (a & 0x20u8 != 0u8) {\n-        ret (((a & 0x1fu8) as uint) << 16u) | ((b as uint) << 8u) |\n-            (c as uint);\n-    }\n-    auto d = reader.read_byte() as u8;\n-    if (a & 0x10u8 != 0u8) {\n-        ret (((a & 0x0fu8) as uint) << 24u) | ((b as uint) << 16u) |\n-            ((c as uint) << 8u) | (d as uint);\n+        ret tup((((a & 0x3fu8) as uint) << 8u) | (data.(start + 1u) as uint),\n+                start + 2u);\n+    } else if (a & 0x20u8 != 0u8) {\n+        ret tup((((a & 0x1fu8) as uint) << 16u) |\n+                ((data.(start + 1u) as uint) << 8u) |\n+                (data.(start + 2u) as uint), start + 3u);\n+    } else if (a & 0x10u8 != 0u8) {\n+        ret tup((((a & 0x0fu8) as uint) << 24u) |\n+                ((data.(start + 1u) as uint) << 16u) |\n+                ((data.(start + 2u) as uint) << 8u) |\n+                (data.(start + 3u) as uint), start + 4u);\n+    } else {\n+        log \"vint too big\"; fail;\n     }\n-\n-    log \"vint too big\"; fail;\n }\n \n-impure fn create_reader(&io.reader r) -> reader {\n-    let vec[ebml_state] states = vec();\n-\n-    // Calculate the size of the stream.\n-    auto pos = r.tell();\n-    r.seek(0, io.seek_end);\n-    auto size = r.tell() - pos;\n-    r.seek(pos as int, io.seek_set);\n+fn new_doc(vec[u8] data) -> doc {\n+    ret rec(data=data, start=0u, end=_vec.len[u8](data));\n+}\n \n-    ret rec(reader=r, mutable states=states, size=size);\n+fn doc_at(vec[u8] data, uint start) -> doc {\n+    auto elt_tag = vint_at(data, start);\n+    auto elt_size = vint_at(data, elt_tag._1);\n+    auto end = elt_size._1 + elt_size._0;\n+    ret rec(data=data, start=elt_size._1, end=end);\n }\n \n-impure fn bytes_left(&reader r) -> uint {\n-    auto pos = r.reader.tell();\n-    alt (_vec.last[ebml_state](r.states)) {\n-        case (none[ebml_state]) { ret r.size - pos; }\n-        case (some[ebml_state](?st)) {\n-            ret st.data_pos + st.ebml_tag.size - pos;\n+fn maybe_get_doc(doc d, uint tg) -> option.t[doc] {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        if (elt_tag._0 == tg) {\n+            ret some[doc](rec(data=d.data, start=elt_size._1, end=pos));\n         }\n     }\n+    ret none[doc];\n }\n \n-impure fn read_tag(&reader r) -> ebml_tag {\n-    auto id = read_vint(r.reader);\n-    auto size = read_vint(r.reader);\n-    ret rec(id=id, size=size);\n-}\n-\n-// Reads a tag and moves the cursor to its first child or data segment.\n-impure fn move_to_first_child(&reader r) {\n-    auto tag_pos = r.reader.tell();\n-    auto t = read_tag(r);\n-    auto data_pos = r.reader.tell();\n-    r.states += vec(rec(ebml_tag=t, tag_pos=tag_pos, data_pos=data_pos));\n-}\n-\n-// Reads a tag and skips over its contents, moving to its next sibling.\n-impure fn move_to_next_sibling(&reader r) {\n-    auto t = read_tag(r);\n-    r.reader.seek(t.size as int, io.seek_cur);\n-}\n-\n-// Moves to the parent of this tag.\n-impure fn move_to_parent(&reader r) {\n-    check (_vec.len[ebml_state](r.states) > 0u);\n-    auto st = _vec.pop[ebml_state](r.states);\n-    r.reader.seek(st.tag_pos as int, io.seek_set);\n+fn get_doc(doc d, uint tg) -> doc {\n+    alt (maybe_get_doc(d, tg)) {\n+        case (some[doc](?d)) {ret d;}\n+        case (none[doc]) {\n+            log \"failed to find block with tag \" + _uint.to_str(tg, 10u);\n+            fail;\n+        }\n+    }\n }\n \n-// Moves to the sibling of the current item with the given tag ID.\n-impure fn move_to_sibling_with_id(&reader r, uint tag_id) {\n-    while (peek(r).id != tag_id) {\n-        move_to_next_sibling(r);\n+iter docs(doc d) -> tup(uint, doc) {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        put tup(elt_tag._0, rec(data=d.data, start=elt_size._1, end=pos));\n     }\n }\n \n-// Moves to the first child of the current item with the given tag ID.\n-impure fn move_to_child_with_id(&reader r, uint tag_id) {\n-    move_to_first_child(r);\n-    move_to_sibling_with_id(r, tag_id);\n+iter tagged_docs(doc d, uint tg) -> doc {\n+    auto pos = d.start;\n+    while (pos < d.end) {\n+        auto elt_tag = vint_at(d.data, pos);\n+        auto elt_size = vint_at(d.data, elt_tag._1);\n+        pos = elt_size._1 + elt_size._0;\n+        if (elt_tag._0 == tg) {\n+            put rec(data=d.data, start=elt_size._1, end=pos);\n+        }\n+    }\n }\n \n-// Reads the data segment of a tag.\n-impure fn read_data(&reader r) -> vec[u8] {\n-    ret r.reader.read_bytes(bytes_left(r));\n+fn doc_data(doc d) -> vec[u8] {\n+    ret _vec.slice[u8](d.data, d.start, d.end);\n }\n \n-// Blows away the tag stack and moves the reader to the given byte position.\n-impure fn reset_reader(&reader r, uint pos) {\n-    // FIXME: rustc \"ty_var in trans.type_of\" bug\n-    let vec[ebml_state] states = vec();\n-    r.states = states;\n-    r.reader.seek(pos as int, io.seek_set);\n+fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n+    auto sz = size;\n+    check (sz <= 4u);\n+    auto val = 0u;\n+    auto pos = start;\n+    while (sz > 0u) {\n+        sz -= 1u;\n+        val += (data.(pos) as uint) << (sz * 8u);\n+        pos += 1u;\n+    }\n+    ret val;\n }\n \n-impure fn peek(&reader r) -> ebml_tag {\n-    check (bytes_left(r) > 0u);\n-    auto pos = r.reader.tell();\n-    auto t = read_tag(r);\n-    r.reader.seek(pos as int, io.seek_set);\n-    ret t;\n+fn doc_as_uint(doc d) -> uint {\n+    ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n }\n \n-\n // EBML writing\n \n type writer = rec(io.buf_writer writer, mutable vec[uint] size_positions);\n@@ -195,4 +184,3 @@ fn end_tag(&writer w) {\n \n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n // encode sizes; this is a fixed point iteration\n-"}]}