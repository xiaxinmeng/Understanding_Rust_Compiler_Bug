{"sha": "3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMGNlZjdkNjkzN2UxN2I2N2RlYzI1NDc3ZWQ1NmVmMjM4NmEzZTA=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T19:02:34Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-01-05T19:14:02Z"}, "message": "Fix overlength lines in `core::pin`.", "tree": {"sha": "2a2e6fa64261a5cc7e1d3ba0768d54b053e669e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2e6fa64261a5cc7e1d3ba0768d54b053e669e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "html_url": "https://github.com/rust-lang/rust/commit/3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e0cef7d6937e17b67dec25477ed56ef2386a3e0/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "684edf7a70d2e90466ae74e7a321670259bf3fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/684edf7a70d2e90466ae74e7a321670259bf3fd9", "html_url": "https://github.com/rust-lang/rust/commit/684edf7a70d2e90466ae74e7a321670259bf3fd9"}], "stats": {"total": 130, "additions": 68, "deletions": 62}, "files": [{"sha": "3d888299485b5249b08afd63bd5bbe1f9990853c", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 68, "deletions": 62, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3e0cef7d6937e17b67dec25477ed56ef2386a3e0/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e0cef7d6937e17b67dec25477ed56ef2386a3e0/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=3e0cef7d6937e17b67dec25477ed56ef2386a3e0", "patch": "@@ -14,13 +14,15 @@\n //! for more details.\n //!\n //! By default, all types in Rust are movable. Rust allows passing all types by-value,\n-//! and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow replacing and\n-//! moving the values they contain: you can move out of a <code>[Box]\\<T></code>, or you can use [`mem::swap`].\n-//! <code>[Pin]\\<P></code> wraps a pointer type `P`, so <code>[Pin]<[Box]\\<T>></code> functions much like a regular\n-//! <code>[Box]\\<T></code>: when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n-//! deallocated. Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>. However, <code>[Pin]\\<P></code> does\n-//! not let clients actually obtain a <code>[Box]\\<T></code> or <code>[&mut] T</code> to pinned data, which implies that you\n-//! cannot use operations such as [`mem::swap`]:\n+//! and common smart-pointer types such as <code>[Box]\\<T></code> and <code>[&mut] T</code> allow\n+//! replacing and moving the values they contain: you can move out of a <code>[Box]\\<T></code>,\n+//! or you can use [`mem::swap`]. <code>[Pin]\\<P></code> wraps a pointer type `P`, so\n+//! <code>[Pin]<[Box]\\<T>></code> functions much like a regular <code>[Box]\\<T></code>:\n+//! when a <code>[Pin]<[Box]\\<T>></code> gets dropped, so do its contents, and the memory gets\n+//! deallocated. Similarly, <code>[Pin]<[&mut] T></code> is a lot like <code>[&mut] T</code>.\n+//! However, <code>[Pin]\\<P></code> does not let clients actually obtain a <code>[Box]\\<T></code>\n+//! or <code>[&mut] T</code> to pinned data, which implies that you cannot use operations such\n+//! as [`mem::swap`]:\n //!\n //! ```\n //! use std::pin::Pin;\n@@ -32,17 +34,17 @@\n //! }\n //! ```\n //!\n-//! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust compiler\n-//! considers all types movable. [`mem::swap`] remains callable for any `T`. Instead, <code>[Pin]\\<P></code>\n-//! prevents certain *values* (pointed to by pointers wrapped in <code>[Pin]\\<P></code>) from being\n-//! moved by making it impossible to call methods that require <code>[&mut] T</code> on them\n-//! (like [`mem::swap`]).\n+//! It is worth reiterating that <code>[Pin]\\<P></code> does *not* change the fact that a Rust\n+//! compiler considers all types movable. [`mem::swap`] remains callable for any `T`. Instead,\n+//! <code>[Pin]\\<P></code> prevents certain *values* (pointed to by pointers wrapped in\n+//! <code>[Pin]\\<P></code>) from being moved by making it impossible to call methods that require\n+//! <code>[&mut] T</code> on them (like [`mem::swap`]).\n //!\n //! <code>[Pin]\\<P></code> can be used to wrap any pointer type `P`, and as such it interacts with\n-//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be considered\n-//! as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> \u2013 so, a <code>[Pin]<[Box]\\<T>></code> is\n-//! an owned pointer to a pinned `T`, and a <code>[Pin]<[Rc]\\<T>></code> is a reference-counted\n-//! pointer to a pinned `T`.\n+//! [`Deref`] and [`DerefMut`]. A <code>[Pin]\\<P></code> where <code>P: [Deref]</code> should be\n+//! considered as a \"`P`-style pointer\" to a pinned <code>P::[Target]</code> \u2013 so, a\n+//! <code>[Pin]<[Box]\\<T>></code> is an owned pointer to a pinned `T`, and a\n+//! <code>[Pin]<[Rc]\\<T>></code> is a reference-counted pointer to a pinned `T`.\n //! For correctness, <code>[Pin]\\<P></code> relies on the implementations of [`Deref`] and\n //! [`DerefMut`] not to move out of their `self` parameter, and only ever to\n //! return a pointer to pinned data when they are called on a pinned pointer.\n@@ -54,13 +56,13 @@\n //! [`bool`], [`i32`], and references) as well as types consisting solely of these\n //! types. Types that do not care about pinning implement the [`Unpin`]\n //! auto-trait, which cancels the effect of <code>[Pin]\\<P></code>. For <code>T: [Unpin]</code>,\n-//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do <code>[Pin]<[&mut] T></code> and\n-//! <code>[&mut] T</code>.\n+//! <code>[Pin]<[Box]\\<T>></code> and <code>[Box]\\<T></code> function identically, as do\n+//! <code>[Pin]<[&mut] T></code> and <code>[&mut] T</code>.\n //!\n-//! Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>, not the pointer\n-//! type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example, whether or not <code>[Box]\\<T></code> is\n-//! [`Unpin`] has no effect on the behavior of <code>[Pin]<[Box]\\<T>></code> (here, `T` is the\n-//! pointed-to type).\n+//! Note that pinning and [`Unpin`] only affect the pointed-to type <code>P::[Target]</code>,\n+//! not the pointer type `P` itself that got wrapped in <code>[Pin]\\<P></code>. For example,\n+//! whether or not <code>[Box]\\<T></code> is [`Unpin`] has no effect on the behavior of\n+//! <code>[Pin]<[Box]\\<T>></code> (here, `T` is the pointed-to type).\n //!\n //! # Example: self-referential struct\n //!\n@@ -149,8 +151,8 @@\n //! when [`drop`] is called*.  Only once [`drop`] returns or panics, the memory may be reused.\n //!\n //! Memory can be \"invalidated\" by deallocation, but also by\n-//! replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some elements\n-//! off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n+//! replacing a <code>[Some]\\(v)</code> by [`None`], or calling [`Vec::set_len`] to \"kill\" some\n+//! elements off of a vector. It can be repurposed by using [`ptr::write`] to overwrite it without\n //! calling the destructor first. None of this is allowed for pinned data without calling [`drop`].\n //!\n //! This is exactly the kind of guarantee that the intrusive linked list from the previous\n@@ -172,8 +174,8 @@\n //! This can never cause a problem in safe code because implementing a type that\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n-//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your [`Drop`][Drop]\n-//! implementation as well: if an element of your type could have been pinned,\n+//! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your\n+//! [`Drop`][Drop]implementation as well: if an element of your type could have been pinned,\n //! you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.\n //!\n //! For example, you could implement [`Drop`][Drop] as follows:\n@@ -206,16 +208,16 @@\n //! When working with pinned structs, the question arises how one can access the\n //! fields of that struct in a method that takes just <code>[Pin]<[&mut] Struct></code>.\n //! The usual approach is to write helper methods (so called *projections*)\n-//! that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what\n-//! type should that reference have? Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?\n+//! that turn <code>[Pin]<[&mut] Struct></code> into a reference to the field, but what type should\n+//! that reference have? Is it <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>?\n //! The same question arises with the fields of an `enum`, and also when considering\n-//! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>, or <code>[RefCell]\\<T></code>.\n-//! (This question applies to both mutable and shared references, we just\n-//! use the more common case of mutable references here for illustration.)\n+//! container/wrapper types such as <code>[Vec]\\<T></code>, <code>[Box]\\<T></code>,\n+//! or <code>[RefCell]\\<T></code>. (This question applies to both mutable and shared references,\n+//! we just use the more common case of mutable references here for illustration.)\n //!\n-//! It turns out that it is actually up to the author of the data structure\n-//! to decide whether the pinned projection for a particular field turns\n-//! <code>[Pin]<[&mut] Struct></code> into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>. There are some\n+//! It turns out that it is actually up to the author of the data structure to decide whether\n+//! the pinned projection for a particular field turns <code>[Pin]<[&mut] Struct></code>\n+//! into <code>[Pin]<[&mut] Field></code> or <code>[&mut] Field</code>. There are some\n //! constraints though, and the most important constraint is *consistency*:\n //! every field can be *either* projected to a pinned reference, *or* have\n //! pinning removed as part of the projection. If both are done for the same field,\n@@ -283,19 +285,20 @@\n //!     the principle that you only have to worry about any of this if you use [`unsafe`].)\n //! 2.  The destructor of the struct must not move structural fields out of its argument. This\n //!     is the exact point that was raised in the [previous section][drop-impl]: [`drop`] takes\n-//!     <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned before.\n-//!     You have to guarantee that you do not move a field inside your [`Drop`][Drop] implementation.\n-//!     In particular, as explained previously, this means that your struct must *not*\n-//!     be `#[repr(packed)]`.\n+//!     <code>[&mut] self</code>, but the struct (and hence its fields) might have been pinned\n+//!     before. You have to guarantee that you do not move a field inside your [`Drop`][Drop]\n+//!     implementation. In particular, as explained previously, this means that your struct\n+//!     must *not* be `#[repr(packed)]`.\n //!     See that section for how to write [`drop`] in a way that the compiler can help you\n //!     not accidentally break pinning.\n //! 3.  You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n //!     once your struct is pinned, the memory that contains the\n //!     content is not overwritten or deallocated without calling the content's destructors.\n-//!     This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of <code>[VecDeque]\\<T></code>\n-//!     can fail to call [`drop`] on all elements if one of the destructors panics. This violates\n-//!     the [`Drop`][Drop] guarantee, because it can lead to elements being deallocated without\n-//!     their destructor being called. (<code>[VecDeque]\\<T></code> has no pinning projections, so this\n+//!     This can be tricky, as witnessed by <code>[VecDeque]\\<T></code>: the destructor of\n+//!     <code>[VecDeque]\\<T></code> can fail to call [`drop`] on all elements if one of the\n+//!     destructors panics. This violates the [`Drop`][Drop] guarantee, because it can lead to\n+//!     elements being deallocated without their destructor being called.\n+//!     (<code>[VecDeque]\\<T></code> has no pinning projections, so this\n //!     does not cause unsoundness.)\n //! 4.  You must not offer any other operations that could lead to data being moved out of\n //!     the structural fields when your type is pinned. For example, if the struct contains an\n@@ -304,8 +307,9 @@\n //!     that operation can be used to move a `T` out of a pinned `Struct<T>` \u2013 which means\n //!     pinning cannot be structural for the field holding this data.\n //!\n-//!     For a more complex example of moving data out of a pinned type, imagine if <code>[RefCell]\\<T></code>\n-//!     had a method <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.\n+//!     For a more complex example of moving data out of a pinned type,\n+//!     imagine if <code>[RefCell]\\<T></code> had a method\n+//!     <code>fn get_pin_mut(self: [Pin]<[&mut] Self>) -> [Pin]<[&mut] T></code>.\n //!     Then we could do the following:\n //!     ```compile_fail\n //!     fn exploit_ref_cell<T>(rc: Pin<&mut RefCell<T>>) {\n@@ -315,31 +319,33 @@\n //!         let content = &mut *b; // And here we have `&mut T` to the same data.\n //!     }\n //!     ```\n-//!     This is catastrophic, it means we can first pin the content of the <code>[RefCell]\\<T></code>\n-//!     (using <code>[RefCell]::get_pin_mut</code>) and then move that content using the mutable\n-//!     reference we got later.\n+//!     This is catastrophic, it means we can first pin the content of the\n+//!     <code>[RefCell]\\<T></code> (using <code>[RefCell]::get_pin_mut</code>) and then move that\n+//!     content using the mutable reference we got later.\n //!\n //! ## Examples\n //!\n-//! For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make sense.\n-//! A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut` methods to get\n-//! pinned references to elements. However, it could *not* allow calling\n-//! [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally pinned)\n-//! contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also move the\n-//! contents.\n+//! For a type like <code>[Vec]\\<T></code>, both possibilities (structural pinning or not) make\n+//! sense. A <code>[Vec]\\<T></code> with structural pinning could have `get_pin`/`get_pin_mut`\n+//! methods to get pinned references to elements. However, it could *not* allow calling\n+//! [`pop`][Vec::pop] on a pinned <code>[Vec]\\<T></code> because that would move the (structurally\n+//! pinned) contents! Nor could it allow [`push`][Vec::push], which might reallocate and thus also\n+//! move the contents.\n //!\n-//! A <code>[Vec]\\<T></code> without structural pinning could <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents\n-//! are never pinned and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n+//! A <code>[Vec]\\<T></code> without structural pinning could\n+//! <code>impl\\<T> [Unpin] for [Vec]\\<T></code>, because the contents are never pinned\n+//! and the <code>[Vec]\\<T></code> itself is fine with being moved as well.\n //! At that point pinning just has no effect on the vector at all.\n //!\n //! In the standard library, pointer types generally do not have structural pinning,\n-//! and thus they do not offer pinning projections. This is why <code>[Box]\\<T>: [Unpin]</code> holds for all `T`.\n-//! It makes sense to do this for pointer types, because moving the <code>[Box]\\<T></code>\n-//! does not actually move the `T`: the <code>[Box]\\<T></code> can be freely movable (aka [`Unpin`]) even if\n-//! the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and <code>[Pin]<[&mut] T></code> are always\n-//! [`Unpin`] themselves, for the same reason: their contents (the `T`) are pinned, but the\n-//! pointers themselves can be moved without moving the pinned data. For both <code>[Box]\\<T></code> and\n-//! <code>[Pin]<[Box]\\<T>></code>, whether the content is pinned is entirely independent of whether the\n+//! and thus they do not offer pinning projections. This is why <code>[Box]\\<T>: [Unpin]</code>\n+//! holds for all `T`. It makes sense to do this for pointer types, because moving the\n+//! <code>[Box]\\<T></code> does not actually move the `T`: the <code>[Box]\\<T></code> can be freely\n+//! movable (aka [`Unpin`]) even if the `T` is not. In fact, even <code>[Pin]<[Box]\\<T>></code> and\n+//! <code>[Pin]<[&mut] T></code> are always [`Unpin`] themselves, for the same reason:\n+//! their contents (the `T`) are pinned, but the pointers themselves can be moved without moving\n+//! the pinned data. For both <code>[Box]\\<T></code> and <code>[Pin]<[Box]\\<T>></code>,\n+//! whether the content is pinned is entirely independent of whether the\n //! pointer is pinned, meaning pinning is *not* structural.\n //!\n //! When implementing a [`Future`] combinator, you will usually need structural pinning"}]}