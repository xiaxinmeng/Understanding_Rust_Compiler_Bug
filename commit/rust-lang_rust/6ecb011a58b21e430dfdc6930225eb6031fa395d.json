{"sha": "6ecb011a58b21e430dfdc6930225eb6031fa395d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlY2IwMTFhNThiMjFlNDMwZGZkYzY5MzAyMjVlYjYwMzFmYTM5NWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:42:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-10T16:42:53Z"}, "message": "rollup merge of #22109: petrochenkov/intuint1", "tree": {"sha": "69aeb8d382b5f75c10b9ab4f84d40ef4c2f25757", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69aeb8d382b5f75c10b9ab4f84d40ef4c2f25757"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ecb011a58b21e430dfdc6930225eb6031fa395d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ecb011a58b21e430dfdc6930225eb6031fa395d", "html_url": "https://github.com/rust-lang/rust/commit/6ecb011a58b21e430dfdc6930225eb6031fa395d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ecb011a58b21e430dfdc6930225eb6031fa395d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "011b77b69cffcaebe60cc78d889bbf6f7796f87a", "url": "https://api.github.com/repos/rust-lang/rust/commits/011b77b69cffcaebe60cc78d889bbf6f7796f87a", "html_url": "https://github.com/rust-lang/rust/commit/011b77b69cffcaebe60cc78d889bbf6f7796f87a"}, {"sha": "6a2bad32575c890105f3bc4914eea7c76fb85e30", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2bad32575c890105f3bc4914eea7c76fb85e30", "html_url": "https://github.com/rust-lang/rust/commit/6a2bad32575c890105f3bc4914eea7c76fb85e30"}], "stats": {"total": 204, "additions": 101, "deletions": 103}, "files": [{"sha": "0617c604121f49bcc9cb2569185ca2dbb704b805", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -206,12 +206,12 @@ impl<T> Arc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n+pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n+pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n@@ -649,7 +649,7 @@ mod tests {\n         let (tx, rx) = channel();\n \n         let _t = Thread::spawn(move || {\n-            let arc_v: Arc<Vec<int>> = rx.recv().unwrap();\n+            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });\n \n@@ -818,5 +818,5 @@ mod tests {\n \n     // Make sure deriving works with Arc<T>\n     #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo { inner: Arc<int> }\n+    struct Foo { inner: Arc<i32> }\n }"}, {"sha": "b7bacaa0cae2bf074ba3a311da0a34c7a7b256b9", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -22,7 +22,7 @@ use std::boxed::BoxAny;\n #[test]\n fn test_owned_clone() {\n     let a = Box::new(5);\n-    let b: Box<int> = a.clone();\n+    let b: Box<i32> = a.clone();\n     assert!(a == b);\n }\n \n@@ -31,11 +31,11 @@ struct Test;\n \n #[test]\n fn any_move() {\n-    let a = Box::new(8us) as Box<Any>;\n+    let a = Box::new(8) as Box<Any>;\n     let b = Box::new(Test) as Box<Any>;\n \n-    match a.downcast::<uint>() {\n-        Ok(a) => { assert!(a == Box::new(8us)); }\n+    match a.downcast::<i32>() {\n+        Ok(a) => { assert!(a == Box::new(8)); }\n         Err(..) => panic!()\n     }\n     match b.downcast::<Test>() {\n@@ -47,7 +47,7 @@ fn any_move() {\n     let b = Box::new(Test) as Box<Any>;\n \n     assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<uint>>().is_err());\n+    assert!(b.downcast::<Box<i32>>().is_err());\n }\n \n #[test]"}, {"sha": "d3d86270d1e9fdea6a4bb02149f6cfbc2a554c0a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -21,7 +21,7 @@ use core::ptr::PtrExt;\n /// power of 2. The alignment must be no larger than the largest supported page\n /// size on the platform.\n #[inline]\n-pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n     imp::allocate(size, align)\n }\n \n@@ -37,7 +37,7 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n     imp::reallocate(ptr, old_size, size, align)\n }\n \n@@ -54,7 +54,8 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint)\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> uint {\n+pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                 align: usize) -> usize {\n     imp::reallocate_inplace(ptr, old_size, size, align)\n }\n \n@@ -66,14 +67,14 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint, align\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     imp::deallocate(ptr, old_size, align)\n }\n \n /// Returns the usable size of an allocation created with the specified the\n /// `size` and `align`.\n #[inline]\n-pub fn usable_size(size: uint, align: uint) -> uint {\n+pub fn usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n@@ -96,7 +97,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n+unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n         EMPTY as *mut u8\n     } else {\n@@ -109,7 +110,7 @@ unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n #[cfg(not(test))]\n #[lang=\"exchange_free\"]\n #[inline]\n-unsafe fn exchange_free(ptr: *mut u8, old_size: uint, align: uint) {\n+unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);\n }\n \n@@ -122,49 +123,49 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: uint, align: uint) {\n               target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\")))]\n-const MIN_ALIGN: uint = 8;\n+const MIN_ALIGN: usize = 8;\n #[cfg(all(not(feature = \"external_funcs\"),\n           not(feature = \"external_crate\"),\n           any(target_arch = \"x86\",\n               target_arch = \"x86_64\",\n               target_arch = \"aarch64\")))]\n-const MIN_ALIGN: uint = 16;\n+const MIN_ALIGN: usize = 16;\n \n #[cfg(feature = \"external_funcs\")]\n mod imp {\n     extern {\n-        fn rust_allocate(size: uint, align: uint) -> *mut u8;\n-        fn rust_deallocate(ptr: *mut u8, old_size: uint, align: uint);\n-        fn rust_reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8;\n-        fn rust_reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n-                                   align: uint) -> uint;\n-        fn rust_usable_size(size: uint, align: uint) -> uint;\n+        fn rust_allocate(size: usize, align: usize) -> *mut u8;\n+        fn rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n+        fn rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n+        fn rust_reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                   align: usize) -> usize;\n+        fn rust_usable_size(size: usize, align: usize) -> usize;\n         fn rust_stats_print();\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         rust_allocate(size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n         rust_deallocate(ptr, old_size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         rust_reallocate(ptr, old_size, size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n-                                     align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n+                                     align: usize) -> usize {\n         rust_reallocate_inplace(ptr, old_size, size, align)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, align: uint) -> uint {\n+    pub fn usable_size(size: usize, align: usize) -> usize {\n         unsafe { rust_usable_size(size, align) }\n     }\n \n@@ -215,42 +216,42 @@ mod imp {\n \n     // MALLOCX_ALIGN(a) macro\n     #[inline(always)]\n-    fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n+    fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }\n \n     #[inline(always)]\n-    fn align_to_flags(align: uint) -> c_int {\n+    fn align_to_flags(align: usize) -> c_int {\n         if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align);\n         je_mallocx(size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align);\n         je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: uint, size: uint,\n-                                     align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, _old_size: usize, size: usize,\n+                                     align: usize) -> usize {\n         let flags = align_to_flags(align);\n-        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as uint\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n         let flags = align_to_flags(align);\n         je_sdallocx(ptr as *mut c_void, old_size as size_t, flags)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, align: uint) -> uint {\n+    pub fn usable_size(size: usize, align: usize) -> usize {\n         let flags = align_to_flags(align);\n-        unsafe { je_nallocx(size as size_t, flags) as uint }\n+        unsafe { je_nallocx(size as size_t, flags) as usize }\n     }\n \n     pub fn stats_print() {\n@@ -277,7 +278,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n@@ -294,7 +295,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n@@ -306,18 +307,18 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, _size: uint,\n-                                     _align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                     _align: usize) -> usize {\n         old_size\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: uint, _align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n         libc::free(ptr as *mut libc::c_void)\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, _align: uint) -> uint {\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n         size\n     }\n \n@@ -341,7 +342,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as size_t) as *mut u8\n         } else {\n@@ -350,7 +351,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: uint, size: uint, align: uint) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut c_void, size as size_t) as *mut u8\n         } else {\n@@ -359,13 +360,13 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: uint, _size: uint,\n-                                     _align: uint) -> uint {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n+                                     _align: usize) -> usize {\n         old_size\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _old_size: uint, align: uint) {\n+    pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n         if align <= MIN_ALIGN {\n             libc::free(ptr as *mut libc::c_void)\n         } else {\n@@ -374,7 +375,7 @@ mod imp {\n     }\n \n     #[inline]\n-    pub fn usable_size(size: uint, _align: uint) -> uint {\n+    pub fn usable_size(size: usize, _align: usize) -> usize {\n         size\n     }\n "}, {"sha": "0e6266f9cbc578f395c255e20df4bb322d8ab79d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -70,7 +70,6 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n-#![feature(int_uint)]\n #![feature(unboxed_closures)]\n #![feature(core)]\n #![feature(hash)]"}, {"sha": "ab3c0901bc9563276b8a13660286db43fbf1900b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -40,7 +40,7 @@\n //! }\n //!\n //! struct Gadget {\n-//!     id: int,\n+//!     id: i32,\n //!     owner: Rc<Owner>\n //!     // ...other fields\n //! }\n@@ -99,7 +99,7 @@\n //! }\n //!\n //! struct Gadget {\n-//!     id: int,\n+//!     id: i32,\n //!     owner: Rc<Owner>\n //!     // ...other fields\n //! }\n@@ -166,8 +166,8 @@ use heap::deallocate;\n \n struct RcBox<T> {\n     value: T,\n-    strong: Cell<uint>,\n-    weak: Cell<uint>\n+    strong: Cell<usize>,\n+    weak: Cell<usize>\n }\n \n /// An immutable reference-counted pointer type.\n@@ -233,12 +233,12 @@ impl<T> Rc<T> {\n /// Get the number of weak references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n+pub fn weak_count<T>(this: &Rc<T>) -> usize { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n #[unstable(feature = \"alloc\")]\n-pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n+pub fn strong_count<T>(this: &Rc<T>) -> usize { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n ///\n@@ -447,7 +447,7 @@ impl<T: Default> Default for Rc<T> {\n     /// use std::rc::Rc;\n     /// use std::default::Default;\n     ///\n-    /// let x: Rc<int> = Default::default();\n+    /// let x: Rc<i32> = Default::default();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -750,7 +750,7 @@ trait RcBoxPtr<T> {\n     fn inner(&self) -> &RcBox<T>;\n \n     #[inline]\n-    fn strong(&self) -> uint { self.inner().strong.get() }\n+    fn strong(&self) -> usize { self.inner().strong.get() }\n \n     #[inline]\n     fn inc_strong(&self) { self.inner().strong.set(self.strong() + 1); }\n@@ -759,7 +759,7 @@ trait RcBoxPtr<T> {\n     fn dec_strong(&self) { self.inner().strong.set(self.strong() - 1); }\n \n     #[inline]\n-    fn weak(&self) -> uint { self.inner().weak.get() }\n+    fn weak(&self) -> usize { self.inner().weak.get() }\n \n     #[inline]\n     fn inc_weak(&self) { self.inner().weak.set(self.weak() + 1); }"}, {"sha": "223c5111f8f4e72e4747c7b10ebaf10808733f00", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -31,7 +31,6 @@\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unsafe_destructor)]\n@@ -55,12 +54,12 @@ use std::rt::heap::{allocate, deallocate};\n #[derive(Clone, PartialEq)]\n struct Chunk {\n     data: Rc<RefCell<Vec<u8>>>,\n-    fill: Cell<uint>,\n+    fill: Cell<usize>,\n     is_copy: Cell<bool>,\n }\n \n impl Chunk {\n-    fn capacity(&self) -> uint {\n+    fn capacity(&self) -> usize {\n         self.data.borrow().capacity()\n     }\n \n@@ -105,7 +104,7 @@ impl Arena {\n     }\n \n     /// Allocates a new Arena with `initial_size` bytes preallocated.\n-    pub fn new_with_size(initial_size: uint) -> Arena {\n+    pub fn new_with_size(initial_size: usize) -> Arena {\n         Arena {\n             head: RefCell::new(chunk(initial_size, false)),\n             copy_head: RefCell::new(chunk(initial_size, true)),\n@@ -114,7 +113,7 @@ impl Arena {\n     }\n }\n \n-fn chunk(size: uint, is_copy: bool) -> Chunk {\n+fn chunk(size: usize, is_copy: bool) -> Chunk {\n     Chunk {\n         data: Rc::new(RefCell::new(Vec::with_capacity(size))),\n         fill: Cell::new(0),\n@@ -137,7 +136,7 @@ impl Drop for Arena {\n }\n \n #[inline]\n-fn round_up(base: uint, align: uint) -> uint {\n+fn round_up(base: usize, align: usize) -> usize {\n     (base.checked_add(align - 1)).unwrap() & !(align - 1)\n }\n \n@@ -149,7 +148,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill.get();\n \n     while idx < fill {\n-        let tydesc_data: *const uint = mem::transmute(buf.offset(idx as int));\n+        let tydesc_data: *const usize = mem::transmute(buf.offset(idx as isize));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -160,7 +159,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = {}, size = {}, align = {}, done = {}\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(buf.offset(start as int) as *const i8);\n+            ((*tydesc).drop_glue)(buf.offset(start as isize) as *const i8);\n         }\n \n         // Find where the next tydesc lives\n@@ -173,21 +172,21 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n // is necessary in order to properly do cleanup if a panic occurs\n // during an initializer.\n #[inline]\n-fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> uint {\n-    p as uint | (is_done as uint)\n+fn bitpack_tydesc_ptr(p: *const TyDesc, is_done: bool) -> usize {\n+    p as usize | (is_done as usize)\n }\n #[inline]\n-fn un_bitpack_tydesc_ptr(p: uint) -> (*const TyDesc, bool) {\n+fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n     ((p & !1) as *const TyDesc, p & 1 == 1)\n }\n \n impl Arena {\n-    fn chunk_size(&self) -> uint {\n+    fn chunk_size(&self) -> usize {\n         self.copy_head.borrow().capacity()\n     }\n \n     // Functions for the POD part of the arena\n-    fn alloc_copy_grow(&self, n_bytes: uint, align: uint) -> *const u8 {\n+    fn alloc_copy_grow(&self, n_bytes: usize, align: usize) -> *const u8 {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n@@ -199,7 +198,7 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_copy_inner(&self, n_bytes: uint, align: uint) -> *const u8 {\n+    fn alloc_copy_inner(&self, n_bytes: usize, align: usize) -> *const u8 {\n         let start = round_up(self.copy_head.borrow().fill.get(), align);\n \n         let end = start + n_bytes;\n@@ -211,7 +210,7 @@ impl Arena {\n         copy_head.fill.set(end);\n \n         unsafe {\n-            copy_head.as_ptr().offset(start as int)\n+            copy_head.as_ptr().offset(start as isize)\n         }\n     }\n \n@@ -227,8 +226,8 @@ impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: uint,\n-                          align: uint) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: usize,\n+                          align: usize) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n@@ -240,8 +239,8 @@ impl Arena {\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: uint,\n-                           align: uint) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: usize,\n+                           align: usize) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n@@ -265,7 +264,7 @@ impl Arena {\n \n         unsafe {\n             let buf = head.as_ptr();\n-            return (buf.offset(tydesc_start as int), buf.offset(start as int));\n+            return (buf.offset(tydesc_start as isize), buf.offset(start as isize));\n         }\n     }\n \n@@ -276,7 +275,7 @@ impl Arena {\n             let (ty_ptr, ptr) =\n                 self.alloc_noncopy_inner(mem::size_of::<T>(),\n                                          mem::min_align_of::<T>());\n-            let ty_ptr = ty_ptr as *mut uint;\n+            let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n@@ -320,7 +319,7 @@ fn test_arena_destructors() {\n \n #[test]\n fn test_arena_alloc_nested() {\n-    struct Inner { value: uint }\n+    struct Inner { value: usize }\n     struct Outer<'a> { inner: &'a Inner }\n \n     let arena = Arena::new();\n@@ -343,10 +342,10 @@ fn test_arena_destructors_fail() {\n         arena.alloc(|| { Rc::new(i) });\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        arena.alloc(|| { [0u8, 1u8, 2u8] });\n+        arena.alloc(|| { [0u8, 1, 2] });\n     }\n     // Now, panic while allocating\n-    arena.alloc::<Rc<int>, _>(|| {\n+    arena.alloc::<Rc<i32>, _>(|| {\n         panic!();\n     });\n }\n@@ -373,12 +372,12 @@ struct TypedArenaChunk<T> {\n     next: *mut TypedArenaChunk<T>,\n \n     /// The number of elements that this chunk can hold.\n-    capacity: uint,\n+    capacity: usize,\n \n     // Objects follow here, suitably aligned.\n }\n \n-fn calculate_size<T>(capacity: uint) -> uint {\n+fn calculate_size<T>(capacity: usize) -> usize {\n     let mut size = mem::size_of::<TypedArenaChunk<T>>();\n     size = round_up(size, mem::min_align_of::<T>());\n     let elem_size = mem::size_of::<T>();\n@@ -389,7 +388,7 @@ fn calculate_size<T>(capacity: uint) -> uint {\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: uint)\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n            -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n         let chunk = allocate(size, mem::min_align_of::<TypedArenaChunk<T>>())\n@@ -403,13 +402,13 @@ impl<T> TypedArenaChunk<T> {\n     /// Destroys this arena chunk. If the type descriptor is supplied, the\n     /// drop glue is called; otherwise, drop glue is not called.\n     #[inline]\n-    unsafe fn destroy(&mut self, len: uint) {\n+    unsafe fn destroy(&mut self, len: usize) {\n         // Destroy all the allocated objects.\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n             for _ in 0..len {\n                 ptr::read(start as *const T); // run the destructor on the pointer\n-                start = start.offset(mem::size_of::<T>() as int)\n+                start = start.offset(mem::size_of::<T>() as isize)\n             }\n         }\n \n@@ -429,7 +428,7 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *const u8 {\n         let this: *const TypedArenaChunk<T> = self;\n         unsafe {\n-            mem::transmute(round_up(this.offset(1) as uint,\n+            mem::transmute(round_up(this.offset(1) as usize,\n                                     mem::min_align_of::<T>()))\n         }\n     }\n@@ -439,7 +438,7 @@ impl<T> TypedArenaChunk<T> {\n     fn end(&self) -> *const u8 {\n         unsafe {\n             let size = mem::size_of::<T>().checked_mul(self.capacity).unwrap();\n-            self.start().offset(size as int)\n+            self.start().offset(size as isize)\n         }\n     }\n }\n@@ -454,7 +453,7 @@ impl<T> TypedArena<T> {\n     /// Creates a new `TypedArena` with preallocated space for the given number of\n     /// objects.\n     #[inline]\n-    pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n+    pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n         unsafe {\n             let chunk = TypedArenaChunk::<T>::new(ptr::null_mut(), capacity);\n             TypedArena {\n@@ -501,8 +500,8 @@ impl<T> Drop for TypedArena<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // Determine how much was filled.\n-            let start = self.first.borrow().as_ref().unwrap().start() as uint;\n-            let end = self.ptr.get() as uint;\n+            let start = self.first.borrow().as_ref().unwrap().start() as usize;\n+            let end = self.ptr.get() as usize;\n             let diff = (end - start) / mem::size_of::<T>();\n \n             // Pass that to the `destroy` method.\n@@ -519,9 +518,9 @@ mod tests {\n \n     #[allow(dead_code)]\n     struct Point {\n-        x: int,\n-        y: int,\n-        z: int,\n+        x: i32,\n+        y: i32,\n+        z: i32,\n     }\n \n     #[test]\n@@ -576,7 +575,7 @@ mod tests {\n     #[allow(dead_code)]\n     struct Noncopy {\n         string: String,\n-        array: Vec<int>,\n+        array: Vec<i32>,\n     }\n \n     #[test]"}, {"sha": "d95d0863ca81f6e9003bac268e010324835105ca", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ecb011a58b21e430dfdc6930225eb6031fa395d/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=6ecb011a58b21e430dfdc6930225eb6031fa395d", "patch": "@@ -15,7 +15,6 @@\n #![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n-#![feature(int_uint)]\n #![feature(no_std)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -1905,7 +1904,7 @@ pub mod types {\n                 #[repr(C)]\n                 #[derive(Copy)] pub struct WSAPROTOCOLCHAIN {\n                     pub ChainLen: c_int,\n-                    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as uint],\n+                    pub ChainEntries: [DWORD; MAX_PROTOCOL_CHAIN as usize],\n                 }\n \n                 pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n@@ -1931,7 +1930,7 @@ pub mod types {\n                     pub iSecurityScheme: c_int,\n                     pub dwMessageSize: DWORD,\n                     pub dwProviderReserved: DWORD,\n-                    pub szProtocol: [u8; (WSAPROTOCOL_LEN as uint) + 1us],\n+                    pub szProtocol: [u8; WSAPROTOCOL_LEN as usize + 1],\n                 }\n \n                 pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;"}]}