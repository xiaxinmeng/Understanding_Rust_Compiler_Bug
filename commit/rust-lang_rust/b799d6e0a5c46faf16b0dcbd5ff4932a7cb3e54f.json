{"sha": "b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "node_id": "C_kwDOAAsO6NoAKGI3OTlkNmUwYTVjNDZmYWYxNmIwZGNiZDVmZjQ5MzJhN2NiM2U1NGY", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-12-31T15:26:32Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-12-31T15:26:32Z"}, "message": "Merge commit '1411a98352ba6bee8ba3b0131c9243e5db1e6a2e' into sync_cg_clif-2021-12-31", "tree": {"sha": "dc0ec811eb7a9793c3cfa17b7715aa5eae5e3ca4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc0ec811eb7a9793c3cfa17b7715aa5eae5e3ca4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "html_url": "https://github.com/rust-lang/rust/commit/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e670844012c2e26442d7a70f2f4236e390d91647", "url": "https://api.github.com/repos/rust-lang/rust/commits/e670844012c2e26442d7a70f2f4236e390d91647", "html_url": "https://github.com/rust-lang/rust/commit/e670844012c2e26442d7a70f2f4236e390d91647"}, {"sha": "1411a98352ba6bee8ba3b0131c9243e5db1e6a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1411a98352ba6bee8ba3b0131c9243e5db1e6a2e", "html_url": "https://github.com/rust-lang/rust/commit/1411a98352ba6bee8ba3b0131c9243e5db1e6a2e"}], "stats": {"total": 454, "additions": 245, "deletions": 209}, "files": [{"sha": "47925f72c2cbdd30b6964213f60da8da3dc26d2f", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -17,12 +17,6 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"450575f58f7bee32816abbff470cbc47797397c2a81e0eaced4b98436daf52e1\"\n \n-[[package]]\n-name = \"autocfg\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n-\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -35,15 +29,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n-[[package]]\n-name = \"crc32fast\"\n-version = \"1.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"81156fece84ab6a9f2afdb109ce3ae577e42b1228441eded99bd77f627953b1a\"\n-dependencies = [\n- \"cfg-if\",\n-]\n-\n [[package]]\n name = \"fm\"\n version = \"0.1.4\"\n@@ -56,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#0672b78d162d65b6f36ea4062947253affe9fdef\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -85,33 +70,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"wasi\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.11.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab5ef0d4909ef3724cc8cce6ccc8572c5c817592e9285f5464f8e86f8bd3726e\"\n-\n [[package]]\n name = \"hermit-abi\"\n version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.102\",\n-]\n-\n-[[package]]\n-name = \"indexmap\"\n-version = \"1.7.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bc633605454125dec4b66843673f01c7df2b89479b32e0ed634e43a91cff62a5\"\n-dependencies = [\n- \"autocfg\",\n- \"hashbrown\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n@@ -122,7 +91,7 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n@@ -138,9 +107,9 @@ checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.102\"\n+version = \"0.2.112\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n+checksum = \"1b03d17f364a3a042d5e5d46b053bbbf82c92c9430c592dd4c064dc6ee997125\"\n \n [[package]]\n name = \"memchr\"\n@@ -155,33 +124,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.102\",\n-]\n-\n-[[package]]\n-name = \"object\"\n-version = \"0.25.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a38f2be3697a57b4060074ff41b44c16870d916ad7877c17696e063257482bc7\"\n-dependencies = [\n- \"crc32fast\",\n- \"indexmap\",\n- \"memchr\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]\n name = \"ppv-lite86\"\n-version = \"0.2.10\"\n+version = \"0.2.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac74c624d6b2d21f425f752262f42188365d7b8ff1aff74c82e45136510a4857\"\n+checksum = \"ed0cfbc8191465bed66e1718596ee0b0b35d5ee1f41c5df2189d0fe8bde535ba\"\n \n [[package]]\n name = \"rand\"\n version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -257,7 +215,6 @@ dependencies = [\n  \"ar\",\n  \"gccjit\",\n  \"lang_tester\",\n- \"object\",\n  \"target-lexicon\",\n  \"tempfile\",\n ]\n@@ -284,7 +241,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -321,7 +278,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.102\",\n+ \"libc 0.2.112\",\n ]\n \n [[package]]"}, {"sha": "21f0bfbf69d7fac441bccb879999fbc80bd801b5", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -23,11 +23,6 @@ target-lexicon = \"0.10.0\"\n \n ar = \"0.8.0\"\n \n-[dependencies.object]\n-version = \"0.25.0\"\n-default-features = false\n-features = [\"read\", \"std\", \"write\"] # We don't need WASM support.\n-\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "1fcfb5f6e20a108661fce85ecbc8fa36ab5d7820", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -111,6 +111,8 @@ Or add a breakpoint to `add_error` in gdb and print the line number using:\n p loc->m_line\n ```\n \n+To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`)."}, {"sha": "73e9c858caf2b6dbb51419d804152e83045a3ab8", "filename": "compiler/rustc_codegen_gcc/patches/0023-core-Ignore-failing-tests.patch", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0023-core-Ignore-failing-tests.patch?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -46,4 +46,24 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 3e00e0a..8e5663b 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -2108,6 +2108,7 @@ fn test_copy_within_panics_src_out_of_bounds() {\n+     bytes.copy_within(usize::MAX..=usize::MAX, 0);\n+ }\n+ \n++/*\n+ #[test]\n+ fn test_is_sorted() {\n+     let empty: [i32; 0] = [];\n+@@ -2122,6 +2123,7 @@ fn test_is_sorted() {\n+     assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n+     assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+ }\n++*/\n+ \n+ #[test]\n+ fn test_slice_run_destructors() {\n -- 2.21.0 (Apple Git-122)"}, {"sha": "8954f91021f47ab9ccd2e2e3fd0b1227aecb3bc6", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -0,0 +1,24 @@\n+From b1ae000f6da1abd3b8e9b80c40bc11c89b8ae93c Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 30 Dec 2021 16:54:40 +0100\n+Subject: [PATCH] [core] Disable portable-simd test\n+\n+---\n+ library/core/tests/lib.rs | 1 -\n+ 1 file changed, 1 deletion(-)\n+\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index ec70034..7cd9e21 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -121,7 +121,6 @@ mod pattern;\n+ mod pin;\n+ mod ptr;\n+ mod result;\n+-mod simd;\n+ mod slice;\n+ mod str;\n+ mod str_lossy;\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "bf74a74c7c4b8dd44ede03324d707a3bd89acfa2", "filename": "compiler/rustc_codegen_gcc/patches/0028-core-Disable-long-running-tests.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0028-core-Disable-long-running-tests.patch?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -0,0 +1,30 @@\n+From 0ffdd8eda8df364391c8ac6e1ce92c73ba9254d4 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Fri, 3 Dec 2021 12:16:30 +0100\n+Subject: [PATCH] Disable long running tests\n+\n+---\n+ library/core/tests/slice.rs | 3 +++\n+ 1 file changed, 3 insertions(+)\n+\n+diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+index 2c8f00a..44847ee 100644\n+--- a/library/core/tests/slice.rs\n++++ b/library/core/tests/slice.rs\n+@@ -2332,7 +2332,8 @@ macro_rules! empty_max_mut {\n+     };\n+ }\n+ \n++/*\n+ #[cfg(not(miri))] // Comparing usize::MAX many elements takes forever in Miri (and in rustc without optimizations)\n+ take_tests! {\n+     slice: &[(); usize::MAX], method: take,\n+     (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n+@@ -2345,3 +2347,4 @@ take_tests! {\n+     (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n+     (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n+ }\n++*/\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "ee0822f6c31457c6b4f125a765e613221d466537", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -1 +1 @@\n-nightly-2021-09-28\n+nightly-2021-12-30"}, {"sha": "453bcd601d3fe51b391b5627930c4350190d5bcc", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -18,30 +18,30 @@ use crate::type_of::LayoutGccExt;\n \n // Rust asm! and GCC Extended Asm semantics differ substantially.\n //\n-// 1. Rust asm operands go along as one list of operands. Operands themselves indicate \n-//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be \n+// 1. Rust asm operands go along as one list of operands. Operands themselves indicate\n+//    if they're \"in\" or \"out\". \"In\" and \"out\" operands can interleave. One operand can be\n //    both \"in\" and \"out\" (`inout(reg)`).\n //\n-//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit, \n-//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands \n+//    GCC asm has two different lists for \"in\" and \"out\" operands. In terms of gccjit,\n+//    this means that all \"out\" operands must go before \"in\" operands. \"In\" and \"out\" operands\n //    cannot interleave.\n //\n-// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important \n+// 2. Operand lists in both Rust and GCC are indexed. Index starts from 0. Indexes are important\n //    because the asm template refers to operands by index.\n //\n //    Mapping from Rust to GCC index would be 1-1 if it wasn't for...\n //\n-// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes. \n-//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to \n+// 3. Clobbers. GCC has a separate list of clobbers, and clobbers don't have indexes.\n+//    Contrary, Rust expresses clobbers through \"out\" operands that aren't tied to\n //    a variable (`_`),  and such \"clobbers\" do have index.\n //\n-// 4. Furthermore, GCC Extended Asm does not support explicit register constraints \n-//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\" \n-//    as a workaround. These variables need to be declared and initialized *before* \n-//    the Extended Asm block but *after* normal local variables \n+// 4. Furthermore, GCC Extended Asm does not support explicit register constraints\n+//    (like `out(\"eax\")`) directly, offering so-called \"local register variables\"\n+//    as a workaround. These variables need to be declared and initialized *before*\n+//    the Extended Asm block but *after* normal local variables\n //    (see comment in `codegen_inline_asm` for explanation).\n //\n-// With that in mind, let's see how we translate Rust syntax to GCC \n+// With that in mind, let's see how we translate Rust syntax to GCC\n // (from now on, `CC` stands for \"constraint code\"):\n //\n // * `out(reg_class) var`   -> translated to output operand: `\"=CC\"(var)`\n@@ -52,18 +52,17 @@ use crate::type_of::LayoutGccExt;\n //\n // * `out(\"explicit register\") _` -> not translated to any operands, register is simply added to clobbers list\n //\n-// * `inout(reg_class) in_var => out_var` -> translated to two operands: \n+// * `inout(reg_class) in_var => out_var` -> translated to two operands:\n //                              output: `\"=CC\"(in_var)`\n-//                              input:  `\"num\"(out_var)` where num is the GCC index \n+//                              input:  `\"num\"(out_var)` where num is the GCC index\n //                                       of the corresponding output operand\n //\n-// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`, \n+// * `inout(reg_class) in_var => _` -> same as `inout(reg_class) in_var => tmp`,\n //                                      where \"tmp\" is a temporary unused variable\n //\n-// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above \n-//                                              with `\"r\"(var)` constraint, \n+// * `out/in/inout(\"explicit register\") var` -> translated to one or two operands as described above\n+//                                              with `\"r\"(var)` constraint,\n //                                              and one register variable assigned to the desired register.\n-// \n \n const ATT_SYNTAX_INS: &str = \".att_syntax noprefix\\n\\t\";\n const INTEL_SYNTAX_INS: &str = \"\\n\\t.intel_syntax noprefix\";\n@@ -131,7 +130,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let att_dialect = is_x86 && options.contains(InlineAsmOptions::ATT_SYNTAX);\n         let intel_dialect = is_x86 && !options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n-        // GCC index of an output operand equals its position in the array \n+        // GCC index of an output operand equals its position in the array\n         let mut outputs = vec![];\n \n         // GCC index of an input operand equals its position in the array\n@@ -145,9 +144,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let mut constants_len = 0;\n \n         // There are rules we must adhere to if we want GCC to do the right thing:\n-        // \n+        //\n         // * Every local variable that the asm block uses as an output must be declared *before*\n-        //   the asm block. \n+        //   the asm block.\n         // * There must be no instructions whatsoever between the register variables and the asm.\n         //\n         // Therefore, the backend must generate the instructions strictly in this order:\n@@ -159,7 +158,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // We also must make sure that no input operands are emitted before output operands.\n         //\n         // This is why we work in passes, first emitting local vars, then local register vars.\n-        // Also, we don't emit any asm operands immediately; we save them to \n+        // Also, we don't emit any asm operands immediately; we save them to\n         // the one of the buffers to be emitted later.\n \n         // 1. Normal variables (and saving operands to buffers).\n@@ -172,7 +171,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n-                        // needs to be of a type that's \"compatible\" with the register class, but specific type \n+                        // needs to be of a type that's \"compatible\" with the register class, but specific type\n                         // doesn't matter.\n                         (Constraint(constraint), None) => (constraint, dummy_output_type(self.cx, reg.reg_class())),\n                         (Register(_), Some(_)) => {\n@@ -200,7 +199,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite: false,\n@@ -211,12 +210,12 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n-                        inputs.push(AsmInOperand { \n-                            constraint: Cow::Borrowed(constraint), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: Cow::Borrowed(constraint),\n+                            rust_idx,\n                             val: value.immediate()\n                         });\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -226,7 +225,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     let constraint = if let ConstraintOrRegister::Constraint(constraint) = reg_to_gcc(reg) {\n                         constraint\n-                    } \n+                    }\n                     else {\n                         // left for the next pass\n                         continue\n@@ -235,22 +234,22 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // Rustc frontend guarantees that input and output types are \"compatible\",\n                     // so we can just use input var's type for the output variable.\n                     //\n-                    // This decision is also backed by the fact that LLVM needs in and out \n-                    // values to be of *exactly the same type*, not just \"compatible\". \n+                    // This decision is also backed by the fact that LLVM needs in and out\n+                    // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n                     let ty = in_value.layout.gcc_type(self.cx, false);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n-                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two \n+                    // it to one \"readwrite (+) output variable\", otherwise we translate it to two\n                     // \"out and tied in\" vars as described above.\n                     let readwrite = out_place.is_none();\n                     outputs.push(AsmOutOperand {\n-                        constraint, \n+                        constraint,\n                         rust_idx,\n                         late,\n                         readwrite,\n-                        tmp_var, \n+                        tmp_var,\n                         out_place,\n                     });\n \n@@ -259,8 +258,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         let constraint = Cow::Owned(out_gcc_idx.to_string());\n \n                         inputs.push(AsmInOperand {\n-                            constraint, \n-                            rust_idx, \n+                            constraint,\n+                            rust_idx,\n                             val: in_value.immediate()\n                         });\n                     }\n@@ -287,7 +286,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         let out_place = if let Some(place) = place {\n                             place\n-                        } \n+                        }\n                         else {\n                             // processed in the previous pass\n                             continue\n@@ -298,7 +297,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n@@ -318,9 +317,9 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n \n-                        inputs.push(AsmInOperand { \n-                            constraint: \"r\".into(), \n-                            rust_idx, \n+                        inputs.push(AsmInOperand {\n+                            constraint: \"r\".into(),\n+                            rust_idx,\n                             val: reg_var.to_rvalue()\n                         });\n                     }\n@@ -331,31 +330,23 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `inout(\"explicit register\") in_var => out_var`\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let out_place = if let Some(place) = out_place {\n-                            place\n-                        } \n-                        else {\n-                            // processed in the previous pass\n-                            continue\n-                        };\n-\n                         // See explanation in the first pass.\n                         let ty = in_value.layout.gcc_type(self.cx, false);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n                         outputs.push(AsmOutOperand {\n-                            constraint: \"r\".into(), \n+                            constraint: \"r\".into(),\n                             rust_idx,\n                             late,\n                             readwrite: false,\n                             tmp_var,\n-                            out_place: Some(out_place)\n+                            out_place,\n                         });\n \n                         let constraint = Cow::Owned((outputs.len() - 1).to_string());\n-                        inputs.push(AsmInOperand { \n-                            constraint, \n+                        inputs.push(AsmInOperand {\n+                            constraint,\n                             rust_idx,\n                             val: in_value.immediate()\n                         });\n@@ -364,8 +355,8 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // processed in the previous pass\n                 }\n \n-                InlineAsmOperandRef::Const { .. } \n-                | InlineAsmOperandRef::SymFn { .. } \n+                InlineAsmOperandRef::Const { .. }\n+                | InlineAsmOperandRef::SymFn { .. }\n                 | InlineAsmOperandRef::SymStatic { .. } => {\n                     // processed in the previous pass\n                 }\n@@ -460,7 +451,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if !intel_dialect {\n             template_str.push_str(INTEL_SYNTAX_INS);\n         }\n-        \n+\n         // 4. Generate Extended Asm block\n \n         let block = self.llbb();\n@@ -479,7 +470,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         }\n \n         if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n-            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient \n+            // TODO(@Commeownist): I'm not 100% sure this one clobber is sufficient\n             // on all architectures. For instance, what about FP stack?\n             extended_asm.add_clobber(\"cc\");\n         }\n@@ -498,18 +489,18 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             self.call(self.type_void(), builtin_unreachable, &[], None);\n         }\n \n-        // Write results to outputs. \n+        // Write results to outputs.\n         //\n         // We need to do this because:\n-        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases \n+        //  1. Turning `PlaceRef` into `RValue` is error-prone and has nasty edge cases\n         //     (especially with current `rustc_backend_ssa` API).\n         //  2. Not every output operand has an `out_place`, and it's required by `add_output_operand`.\n         //\n         // Instead, we generate a temporary output variable for each output operand, and then this loop,\n         // generates `out_place = tmp_var;` assignments if out_place exists.\n         for op in &outputs {\n             if let Some(place) = op.out_place {\n-                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);                \n+                OperandValue::Immediate(op.tmp_var.to_rvalue()).store(self, place);\n             }\n         }\n "}, {"sha": "334ef32f1d1d7471f7bb6b2bf0b511974cfeae9b", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -1,4 +1,4 @@\n-use std::fs;\n+use std::{env, fs};\n \n use gccjit::OutputKind;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n@@ -42,17 +42,17 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &*module.name);\n-                match &*module.name {\n-                    \"std_example.7rcbfp3g-cgu.15\" => {\n-                        println!(\"Dumping reproducer {}\", module.name);\n-                        let _ = fs::create_dir(\"/tmp/reproducers\");\n-                        // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n-                        // transmuting an rvalue to an lvalue.\n-                        // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n-                        context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n-                        println!(\"Dumped reproducer {}\", module.name);\n-                    },\n-                    _ => (),\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE_NAMES\").as_deref() == Ok(\"1\") {\n+                    println!(\"Module {}\", module.name);\n+                }\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n+                    println!(\"Dumping reproducer {}\", module.name);\n+                    let _ = fs::create_dir(\"/tmp/reproducers\");\n+                    // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n+                    // transmuting an rvalue to an lvalue.\n+                    // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n+                    context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n+                    println!(\"Dumped reproducer {}\", module.name);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n             }"}, {"sha": "8b23e96066eed1307ffd46982cfe8e0c65b06252", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -81,7 +81,10 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n+        // NOTE: an optimization (https://github.com/rust-lang/rustc_codegen_gcc/issues/53).\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n+        // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n+        context.add_command_line_option(\"-fno-strict-aliasing\");\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }"}, {"sha": "ccf8123000cf83ec0fff9c58bb09d28fb31f6e71", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn check_ptr_call<'b>(&mut self, _typ: &str, func_ptr: RValue<'gcc>, args: &'b [RValue<'gcc>]) -> Cow<'b, [RValue<'gcc>]> {\n         let mut all_args_match = true;\n         let mut param_types = vec![];\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         for (index, arg) in args.iter().enumerate().take(gcc_func.get_param_count()) {\n             let param = gcc_func.get_param_type(index);\n             if param != arg.get_type() {\n@@ -277,7 +277,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().is_function_ptr_type().expect(\"function ptr\");\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let mut return_type = gcc_func.get_return_type();\n         let current_block = self.current_block.borrow().expect(\"block\");\n         let void_type = self.context.new_type::<()>();\n@@ -605,31 +605,25 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn and(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n-        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n         if a.get_type() != b.get_type() {\n             b = self.context.new_cast(None, b, a.get_type());\n         }\n-        let res = self.current_func().new_local(None, b.get_type(), \"andResult\");\n-        self.llbb().add_assignment(None, res, a & b);\n-        res.to_rvalue()\n+        a & b\n     }\n \n-    fn or(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n-        // FIXME(antoyo): hack by putting the result in a variable to workaround this bug:\n-        // https://gcc.gnu.org/bugzilla//show_bug.cgi?id=95498\n-        let res = self.current_func().new_local(None, b.get_type(), \"orResult\");\n-        self.llbb().add_assignment(None, res, a | b);\n-        res.to_rvalue()\n+    fn or(&mut self, a: RValue<'gcc>, mut b: RValue<'gcc>) -> RValue<'gcc> {\n+        if a.get_type() != b.get_type() {\n+            b = self.context.new_cast(None, b, a.get_type());\n+        }\n+        a | b\n     }\n \n     fn xor(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n         a ^ b\n     }\n \n     fn neg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n-        // TODO(antoyo): use new_unary_op()?\n-        self.cx.context.new_rvalue_from_long(a.get_type(), 0) - a\n+        self.cx.context.new_unary_op(None, UnaryOp::Minus, a.get_type(), a)\n     }\n \n     fn fneg(&mut self, a: RValue<'gcc>) -> RValue<'gcc> {\n@@ -816,7 +810,10 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let atomic_load = self.context.get_builtin_function(&format!(\"__atomic_load_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n \n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_const()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n         self.context.new_call(None, atomic_load, &[ptr, ordering])\n     }\n@@ -941,7 +938,9 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo): handle alignment.\n         let atomic_store = self.context.get_builtin_function(&format!(\"__atomic_store_{}\", size.bytes()));\n         let ordering = self.context.new_rvalue_from_int(self.i32_type, order.to_gcc());\n-        let volatile_const_void_ptr_type = self.context.new_type::<*mut ()>().make_const().make_volatile();\n+        let volatile_const_void_ptr_type = self.context.new_type::<()>()\n+            .make_volatile()\n+            .make_pointer();\n         let ptr = self.context.new_cast(None, ptr, volatile_const_void_ptr_type);\n \n         // FIXME(antoyo): fix libgccjit to allow comparing an integer type with an aligned integer type because\n@@ -981,12 +980,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value = ptr.dereference(None).to_rvalue();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, value, index);\n             element.get_address(None)\n         }\n-        else if let Some(vector_type) = value_type.is_vector() {\n+        else if let Some(vector_type) = value_type.dyncast_vector() {\n             let array_type = vector_type.get_element_type().make_pointer();\n             let array = self.bitcast(ptr, array_type);\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n@@ -1009,7 +1008,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n \n     fn sext(&mut self, value: RValue<'gcc>, dest_ty: Type<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): check that it indeed sign extend the value.\n-        if dest_ty.is_vector().is_some() {\n+        if dest_ty.dyncast_vector().is_some() {\n             // TODO(antoyo): nothing to do as it is only for LLVM?\n             return value;\n         }\n@@ -1081,7 +1080,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let right_type = rhs.get_type();\n         if left_type != right_type {\n             // NOTE: because libgccjit cannot compare function pointers.\n-            if left_type.is_function_ptr_type().is_some() && right_type.is_function_ptr_type().is_some() {\n+            if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n                 lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                 rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n             }\n@@ -1189,12 +1188,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(idx as usize as u64, idx);\n         let value_type = aggregate_value.get_type();\n \n-        if value_type.is_array().is_some() {\n+        if value_type.dyncast_array().is_some() {\n             let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n             let element = self.context.new_array_access(None, aggregate_value, index);\n             element.get_address(None)\n         }\n-        else if value_type.is_vector().is_some() {\n+        else if value_type.dyncast_vector().is_some() {\n             panic!();\n         }\n         else if let Some(pointer_type) = value_type.get_pointee() {\n@@ -1221,11 +1220,11 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let value_type = aggregate_value.get_type();\n \n         let lvalue =\n-            if value_type.is_array().is_some() {\n+            if value_type.dyncast_array().is_some() {\n                 let index = self.context.new_rvalue_from_long(self.u64_type, i64::try_from(idx).expect(\"i64::try_from\"));\n                 self.context.new_array_access(None, aggregate_value, index)\n             }\n-            else if value_type.is_vector().is_some() {\n+            else if value_type.dyncast_vector().is_some() {\n                 panic!();\n             }\n             else if let Some(pointer_type) = value_type.get_pointee() {"}, {"sha": "5851826147dfac9fd5cedacf1d9120f406be702b", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -1,5 +1,4 @@\n use std::convert::TryFrom;\n-use std::convert::TryInto;\n \n use gccjit::LValue;\n use gccjit::{Block, CType, RValue, Type, ToRValue};\n@@ -44,7 +43,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let string = self.context.new_string_literal(&*string);\n         let sym = self.generate_local_symbol_name(\"str\");\n         let global = self.declare_private_global(&sym, self.val_ty(string));\n-        global.global_set_initializer_value(string);\n+        global.global_set_initializer_rvalue(string);\n         global\n         // TODO(antoyo): set linkage.\n     }\n@@ -79,7 +78,7 @@ pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) ->\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n         .collect();\n-    context.new_rvalue_from_array(None, typ, &elements)\n+    context.new_array_constructor(None, typ, &elements)\n }\n \n pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n@@ -120,13 +119,6 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn const_uint_big(&self, typ: Type<'gcc>, num: u128) -> RValue<'gcc> {\n-        let num64: Result<i64, _> = num.try_into();\n-        if let Ok(num) = num64 {\n-            // FIXME(antoyo): workaround for a bug where libgccjit is expecting a constant.\n-            // The operations >> 64 and | low are making the normal case a non-constant.\n-            return self.context.new_rvalue_from_long(typ, num as i64);\n-        }\n-\n         if num >> 64 != 0 {\n             // FIXME(antoyo): use a new function new_rvalue_from_unsigned_long()?\n             let low = self.context.new_rvalue_from_long(self.u64_type, num as u64 as i64);\n@@ -193,7 +185,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo): cache the type? It's anonymous, so probably not.\n         let typ = self.type_struct(&fields, packed);\n         let struct_type = typ.is_struct().expect(\"struct type\");\n-        self.context.new_rvalue_from_struct(None, struct_type, values)\n+        self.context.new_struct_constructor(None, struct_type.as_type(), None, values)\n     }\n \n     fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {"}, {"sha": "ba4589bd810255be742e27f90a908bd54d4135f8", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -20,7 +20,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn const_bitcast(&self, value: RValue<'gcc>, typ: Type<'gcc>) -> RValue<'gcc> {\n         if value.get_type() == self.bool_type.make_pointer() {\n             if let Some(pointee) = typ.get_pointee() {\n-                if pointee.is_vector().is_some() {\n+                if pointee.dyncast_vector().is_some() {\n                     panic!()\n                 }\n             }\n@@ -31,9 +31,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n-        if let Some(global_value) = self.const_globals.borrow().get(&cv) {\n-            // TODO(antoyo): upgrade alignment.\n-            return *global_value;\n+        // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n+        // following:\n+        for (value, variable) in &*self.const_globals.borrow() {\n+            if format!(\"{:?}\", value) == format!(\"{:?}\", cv) {\n+                // TODO(antoyo): upgrade alignment.\n+                return *variable;\n+            }\n         }\n         let global_value = self.static_addr_of_mut(cv, align, kind);\n         // TODO(antoyo): set global constant.\n@@ -77,7 +81,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n             else {\n                 value\n             };\n-        global.global_set_initializer_value(value);\n+        global.global_set_initializer_rvalue(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n@@ -176,7 +180,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             };\n         // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n         // globally.\n-        global.global_set_initializer_value(cv);\n+        global.global_set_initializer_rvalue(cv);\n         // TODO(antoyo): set unnamed address.\n         global.get_address(None)\n     }\n@@ -371,7 +375,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         real_name.push_str(&sym);\n         let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_value(global1.get_address(None));\n+        global2.global_set_initializer_rvalue(global1.get_address(None));\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }"}, {"sha": "dfcd1b6231216cb49acc361bdb83e054a43e058d", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -1,16 +1,6 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{\n-    Block,\n-    Context,\n-    CType,\n-    Function,\n-    FunctionType,\n-    LValue,\n-    RValue,\n-    Struct,\n-    Type,\n-};\n+use gccjit::{Block, CType, Context, Function, FunctionType, LValue, RValue, Struct, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,"}, {"sha": "572ac559d09dfb89fb5842cab86c7903d900dae7", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, typ)\n+                self.context.new_cast(None, value, typ)\n             }\n             else {\n                 value\n@@ -690,7 +690,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 },\n             };\n \n-        self.context.new_bitcast(None, result, result_type)\n+        self.context.new_cast(None, result, result_type)\n     }\n \n     fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n@@ -741,6 +741,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_low = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, low);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_high + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n@@ -764,7 +769,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let arg =\n             if result_type.is_signed(self.cx) {\n                 let new_type = result_type.to_unsigned(self.cx);\n-                self.context.new_bitcast(None, arg, new_type)\n+                self.context.new_cast(None, arg, new_type)\n             }\n             else {\n                 arg\n@@ -816,10 +821,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_high = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, high);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_low + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_bitcast(None, res, result_type);\n+                return self.context.new_cast(None, res, result_type);\n             }\n             else {\n                 unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n@@ -833,7 +843,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 arg\n             };\n         let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n-        self.context.new_bitcast(None, res, result_type)\n+        self.context.new_cast(None, res, result_type)\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> i64 {\n@@ -847,7 +857,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, value_type)\n+                self.context.new_cast(None, value, value_type)\n             }\n             else {\n                 value\n@@ -863,7 +873,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n             let res = high + low;\n-            return self.context.new_bitcast(None, res, result_type);\n+            return self.context.new_cast(None, res, result_type);\n         }\n \n         // First step.\n@@ -888,7 +898,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u8(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fourth step.\n@@ -899,7 +909,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u16(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fifth step.\n@@ -910,7 +920,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u32(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Sixth step.\n@@ -920,7 +930,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let right = shifted & mask;\n         let value = left + right;\n \n-        self.context.new_bitcast(None, value, result_type)\n+        self.context.new_cast(None, value, result_type)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063"}, {"sha": "034558a879dbd882459e946a09a118c6b1b9eff0", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -91,8 +91,6 @@ impl CodegenBackend for GccCodegenBackend {\n         let target_cpu = target_cpu(tcx.sess);\n         let res = codegen_crate(self.clone(), tcx, target_cpu.to_string(), metadata, need_metadata_module);\n \n-        rustc_symbol_mangling::test::report_symbol_names(tcx);\n-\n         Box::new(res)\n     }\n "}, {"sha": "28e2adc492bbeb49f86be0c3037610c3d0fd53a2", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -122,7 +122,7 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         if typ.is_integral() {\n             TypeKind::Integer\n         }\n-        else if typ.is_vector().is_some() {\n+        else if typ.dyncast_vector().is_some() {\n             TypeKind::Vector\n         }\n         else {\n@@ -141,10 +141,10 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n \n     fn element_type(&self, ty: Type<'gcc>) -> Type<'gcc> {\n-        if let Some(typ) = ty.is_array() {\n+        if let Some(typ) = ty.dyncast_array() {\n             typ\n         }\n-        else if let Some(vector_type) = ty.is_vector() {\n+        else if let Some(vector_type) = ty.dyncast_vector() {\n             vector_type.get_element_type()\n         }\n         else if let Some(typ) = ty.get_pointee() {"}, {"sha": "46abbb553bf2f6e257d61bc39e399161a5654553", "filename": "compiler/rustc_codegen_gcc/tests/run/asm.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs?ref=b799d6e0a5c46faf16b0dcbd5ff4932a7cb3e54f", "patch": "@@ -3,6 +3,10 @@\n // Run-time:\n //   status: 0\n \n+#![feature(asm_const, asm_sym)]\n+\n+use std::arch::{asm, global_asm};\n+\n global_asm!(\"\n     .global add_asm\n add_asm:\n@@ -15,6 +19,16 @@ extern \"C\" {\n     fn add_asm(a: i64, b: i64) -> i64;\n }\n \n+pub unsafe fn mem_cpy(dst: *mut u8, src: *const u8, len: usize) {\n+    asm!(\n+        \"rep movsb\",\n+        inout(\"rdi\") dst => _,\n+        inout(\"rsi\") src => _,\n+        inout(\"rcx\") len => _,\n+        options(preserves_flags, nostack)\n+    );\n+}\n+\n fn main() {\n     unsafe {\n         asm!(\"nop\");\n@@ -60,11 +74,11 @@ fn main() {\n     }\n     assert_eq!(x, 43);\n \n-    // check inout(reg_class) x \n+    // check inout(reg_class) x\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {0}, {0}\",\n-            inout(reg) x \n+            inout(reg) x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -73,7 +87,7 @@ fn main() {\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add r11, r11\",\n-            inout(\"r11\") x \n+            inout(\"r11\") x\n         );\n     }\n     assert_eq!(x, 84);\n@@ -96,12 +110,12 @@ fn main() {\n     assert_eq!(res, 7);\n     assert_eq!(rem, 2);\n \n-    // check const \n+    // check const\n     let mut x: u64 = 42;\n     unsafe {\n         asm!(\"add {}, {}\",\n             inout(reg) x,\n-            const 1 \n+            const 1\n         );\n     }\n     assert_eq!(x, 43);\n@@ -148,4 +162,11 @@ fn main() {\n     assert_eq!(x, 42);\n \n     assert_eq!(unsafe { add_asm(40, 2) }, 42);\n+\n+    let array1 = [1u8, 2, 3];\n+    let mut array2 = [0u8, 0, 0];\n+    unsafe {\n+        mem_cpy(array2.as_mut_ptr(), array1.as_ptr(), 3);\n+    }\n+    assert_eq!(array1, array2);\n }"}]}