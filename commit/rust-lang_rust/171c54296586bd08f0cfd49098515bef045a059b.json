{"sha": "171c54296586bd08f0cfd49098515bef045a059b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MWM1NDI5NjU4NmJkMDhmMGNmZDQ5MDk4NTE1YmVmMDQ1YTA1OWI=", "commit": {"author": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-21T18:25:47Z"}, "committer": {"name": "Luqman Aden", "email": "me@luqman.ca", "date": "2014-08-21T18:25:47Z"}, "message": "librustc: Mark unboxed closure calls and definitions with appropriate llvm return/argument attributes.", "tree": {"sha": "0f1470143630165ce1af40cac987b2077a7f453a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f1470143630165ce1af40cac987b2077a7f453a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/171c54296586bd08f0cfd49098515bef045a059b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/171c54296586bd08f0cfd49098515bef045a059b", "html_url": "https://github.com/rust-lang/rust/commit/171c54296586bd08f0cfd49098515bef045a059b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/171c54296586bd08f0cfd49098515bef045a059b/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4444aec1423b2f9431f30e1dc121d239c16ed71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4444aec1423b2f9431f30e1dc121d239c16ed71c", "html_url": "https://github.com/rust-lang/rust/commit/4444aec1423b2f9431f30e1dc121d239c16ed71c"}], "stats": {"total": 40, "additions": 29, "deletions": 11}, "files": [{"sha": "043636a32c0f61bbf7b609ca2f1587ff652c48cc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/171c54296586bd08f0cfd49098515bef045a059b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/171c54296586bd08f0cfd49098515bef045a059b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=171c54296586bd08f0cfd49098515bef045a059b", "patch": "@@ -2240,26 +2240,44 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _) => {\n             let unboxed_closures = ccx.tcx.unboxed_closures.borrow();\n-            let function_type = unboxed_closures.get(&closure_did)\n-                                                .closure_type\n-                                                .clone();\n+            let ref function_type = unboxed_closures.get(&closure_did)\n+                                                    .closure_type;\n+\n             (function_type.sig.clone(), RustCall, true)\n         }\n-        _ => fail!(\"expected closure or function.\")\n+        _ => ccx.sess().bug(\"expected closure or function.\")\n     };\n \n+\n     // Since index 0 is the return value of the llvm func, we start\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n     let ret_ty = fn_sig.output;\n \n-    // These have an odd calling convention, so we skip them for now.\n-    //\n-    // FIXME(pcwalton): We don't have to skip them; just untuple the result.\n-    if abi == RustCall {\n-        return attrs;\n-    }\n+    // These have an odd calling convention, so we need to manually\n+    // unpack the input ty's\n+    let input_tys = match ty::get(fn_ty).sty {\n+        ty::ty_unboxed_closure(_, _) => {\n+            assert!(abi == RustCall);\n+\n+            match ty::get(fn_sig.inputs[0]).sty {\n+                ty::ty_nil => Vec::new(),\n+                ty::ty_tup(ref inputs) => inputs.clone(),\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        },\n+        ty::ty_bare_fn(_) if abi == RustCall => {\n+            let inputs = vec![fn_sig.inputs[0]];\n+\n+            match ty::get(fn_sig.inputs[1]).sty {\n+                ty::ty_nil => inputs,\n+                ty::ty_tup(ref t_in) => inputs.append(t_in.as_slice()),\n+                _ => ccx.sess().bug(\"expected tuple'd inputs\")\n+            }\n+        }\n+        _ => fn_sig.inputs.clone()\n+    };\n \n     // A function pointer is called without the declaration\n     // available, so we have to apply any attributes with ABI\n@@ -2315,7 +2333,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         }\n     }\n \n-    for (idx, &t) in fn_sig.inputs.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n+    for (idx, &t) in input_tys.iter().enumerate().map(|(i, v)| (i + first_arg_offset, v)) {\n         match ty::get(t).sty {\n             // this needs to be first to prevent fat pointers from falling through\n             _ if !type_is_immediate(ccx, t) => {"}]}