{"sha": "f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwZTBkOWUxMDFkMzY5NTcxMDJjMzhkZTNlYzllMDg5YzFkNDNkYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-09T09:06:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-09T09:06:23Z"}, "message": "auto merge of #12117 : nikomatsakis/rust/issue-11913-borrow-in-aliasable-loc, r=pcwalton\n\nRepair a rather embarassingly obvious hole that I created as part of #9629. In particular, prevent `&mut` borrows of data in an aliasable location. This used to be prevented through the restrictions mechanism, but in #9629 I modified those rules incorrectly. \r\n\r\nr? @pcwalton\r\n\r\nFixes #11913", "tree": {"sha": "4ea7bae4e9370238aa47845b5575ac40df873829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ea7bae4e9370238aa47845b5575ac40df873829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "html_url": "https://github.com/rust-lang/rust/commit/f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49ac48db3fe2666751908668ba8e5ab16e2fb07a", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ac48db3fe2666751908668ba8e5ab16e2fb07a", "html_url": "https://github.com/rust-lang/rust/commit/49ac48db3fe2666751908668ba8e5ab16e2fb07a"}, {"sha": "eb774f69e5099f73b053d08f9baf29f80f321309", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb774f69e5099f73b053d08f9baf29f80f321309", "html_url": "https://github.com/rust-lang/rust/commit/eb774f69e5099f73b053d08f9baf29f80f321309"}], "stats": {"total": 581, "additions": 317, "deletions": 264}, "files": [{"sha": "4abfedb87228eded779d68f6b3a66e14e8ae06bb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -681,7 +681,7 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     ebml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: &writer::Encoder,\n+    fn encode_mutability(ebml_w: &mut writer::Encoder,\n                          m: ast::Mutability) {\n         match m {\n             MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }"}, {"sha": "cfd2c0719b09b4ef1799453a152484cc5cc80bbf", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 44, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -22,7 +22,6 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -220,9 +219,8 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            MutableMutability   => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n-            ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n-            ConstMutability     => RESTR_ALIAS,\n+            MutableMutability   => RESTR_FREEZE | RESTR_CLAIM,\n+            ImmutableMutability => RESTR_FREEZE,\n         };\n         debug!(\"illegal_if={:?}\", illegal_if);\n \n@@ -424,7 +422,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n+                mc::cat_deref(b, _, mc::region_ptr(ast::MutMutable, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     check_for_aliasability_violation(this, expr, b);\n@@ -438,43 +436,18 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n                                             expr: &ast::Expr,\n-                                            cmt: mc::cmt) -> bool {\n-            let mut cmt = cmt;\n-\n-            loop {\n-                match cmt.cat {\n-                    mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) |\n-                    mc::cat_downcast(b) |\n-                    mc::cat_stack_upvar(b) |\n-                    mc::cat_deref(b, _, mc::uniq_ptr) |\n-                    mc::cat_interior(b, _) |\n-                    mc::cat_discr(b, _) => {\n-                        // Aliasability depends on base cmt\n-                        cmt = b;\n-                    }\n-\n-                    mc::cat_copied_upvar(_) |\n-                    mc::cat_rvalue(..) |\n-                    mc::cat_local(..) |\n-                    mc::cat_arg(_) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_static_item(..) |\n-                    mc::cat_deref(_, _, mc::gc_ptr) |\n-                    mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n-                        // Aliasability is independent of base cmt\n-                        match cmt.freely_aliasable() {\n-                            None => {\n-                                return true;\n-                            }\n-                            Some(cause) => {\n-                                this.bccx.report_aliasability_violation(\n-                                    expr.span,\n-                                    MutabilityViolation,\n-                                    cause);\n-                                return false;\n-                            }\n-                        }\n-                    }\n+                                            cmt: mc::cmt)\n+                                            -> bool {\n+            match cmt.freely_aliasable() {\n+                None => {\n+                    return true;\n+                }\n+                Some(cause) => {\n+                    this.bccx.report_aliasability_violation(\n+                        expr.span,\n+                        MutabilityViolation,\n+                        cause);\n+                    return false;\n                 }\n             }\n         }\n@@ -598,8 +571,7 @@ impl<'a> CheckLoanCtxt<'a> {\n \n                 // Check for a non-const loan of `loan_path`\n                 let cont = this.each_in_scope_loan(expr.id, |loan| {\n-                    if loan.loan_path == loan_path &&\n-                            loan.mutbl != ConstMutability {\n+                    if loan.loan_path == loan_path {\n                         this.report_illegal_mutation(expr,\n                                                      full_loan_path,\n                                                      loan);"}, {"sha": "ffc269f8cc8ddeada56531732fb1477822789d5e", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -151,14 +151,13 @@ that the value `(*x).f` may be mutated via the newly created reference\n restrictions `RS` that accompany the loan.\n \n The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n-the lender may not mutate nor freeze `(*x).f`. Mutation is illegal\n-because `(*x).f` is only supposed to be mutated via the new reference,\n-not by mutating the original path `(*x).f`. Freezing is\n+the lender may not mutate, freeze, nor alias `(*x).f`. Mutation is\n+illegal because `(*x).f` is only supposed to be mutated via the new\n+reference, not by mutating the original path `(*x).f`. Freezing is\n illegal because the path now has an `&mut` alias; so even if we the\n lender were to consider `(*x).f` to be immutable, it might be mutated\n-via this alias. Both of these restrictions are temporary. They will be\n-enforced for the lifetime `'a` of the loan. After the loan expires,\n-the restrictions no longer apply.\n+via this alias. They will be enforced for the lifetime `'a` of the\n+loan. After the loan expires, the restrictions no longer apply.\n \n The second restriction on `*x` is interesting because it does not\n apply to the path that was lent (`(*x).f`) but rather to a prefix of\n@@ -188,11 +187,9 @@ The kinds of expressions which in-scope loans can render illegal are:\n   against mutating `lv`;\n - *moves*: illegal if there is any in-scope restriction on `lv` at all;\n - *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n-  against mutating `lv` or aliasing `lv`;\n+  against claiming `lv`;\n - *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n-  against freezing `lv` or aliasing `lv`;\n-- *read-only borrows* (`&const lv`): illegal there is an in-scope restriction\n-  against aliasing `lv`.\n+  against freezing `lv`.\n \n ## Formal rules\n \n@@ -238,19 +235,23 @@ live. (This is done via restrictions, read on.)\n We start with the `gather_loans` pass, which walks the AST looking for\n borrows.  For each borrow, there are three bits of information: the\n lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n-of the resulting pointer. Given those, `gather_loans` applies three\n+of the resulting pointer. Given those, `gather_loans` applies four\n validity tests:\n \n 1. `MUTABILITY(LV, MQ)`: The mutability of the reference is\n compatible with the mutability of `LV` (i.e., not borrowing immutable\n data as mutable).\n \n-2. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+2. `ALIASABLE(LV, MQ)`: The aliasability of the reference is\n+compatible with the aliasability of `LV`. The goal is to prevent\n+`&mut` borrows of aliasability data.\n+\n+3. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n the lifetime of the value being borrowed. This pass is also\n responsible for inserting root annotations to keep managed values\n alive.\n \n-3. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n+4. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -313,6 +314,47 @@ be borrowed if MQ is immutable or const:\n     MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n       TYPE(LV) = &mut Ty\n \n+## Checking aliasability\n+\n+The goal of the aliasability check is to ensure that we never permit\n+`&mut` borrows of aliasable data. Formally we define a predicate\n+`ALIASABLE(LV, MQ)` which if defined means that\n+\"borrowing `LV` with mutability `MQ` is ok\". The\n+Rust code corresponding to this predicate is the function\n+`check_aliasability()` in `middle::borrowck::gather_loans`.\n+\n+### Checking aliasability of variables\n+\n+Local variables are never aliasable as they are accessible only within\n+the stack frame.\n+\n+    ALIASABLE(X, MQ)                   // M-Var-Mut\n+\n+### Checking aliasable of owned content\n+\n+Owned content is aliasable if it is found in an aliasable location:\n+\n+    ALIASABLE(LV.f, MQ)                // M-Field\n+      ALIASABLE(LV, MQ)\n+\n+    ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n+      ALIASABLE(LV, MQ)\n+\n+### Checking mutability of immutable pointer types\n+\n+Immutable pointer types like `&T` are aliasable, and hence can only be\n+borrowed immutably:\n+\n+    ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n+      TYPE(LV) = &Ty\n+\n+### Checking mutability of mutable pointer types\n+\n+`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n+\n+    ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+      TYPE(LV) = &mut Ty\n+\n ## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that exceeds"}, {"sha": "957073ac392bdf5a0149c0b3fe78e683c43c5923", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -460,6 +460,11 @@ impl<'a> GatherLoanCtxt<'a> {\n             return; // reported an error, no sense in reporting more.\n         }\n \n+        // Check that we don't allow mutable borrows of aliasable data.\n+        if check_aliasability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n+\n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n@@ -568,11 +573,6 @@ impl<'a> GatherLoanCtxt<'a> {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_mutbl {\n-                ConstMutability => {\n-                    // Data of any mutability can be lent as const.\n-                    Ok(())\n-                }\n-\n                 ImmutableMutability => {\n                     // both imm and mut data can be lent as imm;\n                     // for mutable data, this is a freeze\n@@ -591,16 +591,53 @@ impl<'a> GatherLoanCtxt<'a> {\n                 }\n             }\n         }\n+\n+        fn check_aliasability(bccx: &BorrowckCtxt,\n+                              borrow_span: Span,\n+                              cmt: mc::cmt,\n+                              req_mutbl: LoanMutability) -> Result<(),()> {\n+            //! Implements the A-* rules in doc.rs.\n+\n+            match req_mutbl {\n+                ImmutableMutability => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n+                    Ok(())\n+                }\n+\n+                MutableMutability => {\n+                    // Check for those cases where we cannot control\n+                    // the aliasing and make sure that we are not\n+                    // being asked to.\n+                    match cmt.freely_aliasable() {\n+                        None => {\n+                            Ok(())\n+                        }\n+                        Some(mc::AliasableStaticMut) => {\n+                            // This is nasty, but we ignore the\n+                            // aliasing rules if the data is based in\n+                            // a `static mut`, since those are always\n+                            // unsafe. At your own peril and all that.\n+                            Ok(())\n+                        }\n+                        Some(cause) => {\n+                            bccx.report_aliasability_violation(\n+                                borrow_span,\n+                                BorrowViolation,\n+                                cause);\n+                            Err(())\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     pub fn restriction_set(&self, req_mutbl: LoanMutability)\n                            -> RestrictionSet {\n         match req_mutbl {\n-            ConstMutability => RESTR_EMPTY,\n-            ImmutableMutability => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n-            MutableMutability => {\n-                RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n-            }\n+            ImmutableMutability => RESTR_MUTATE | RESTR_CLAIM,\n+            MutableMutability => RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE,\n         }\n     }\n "}, {"sha": "60e0baa3534bab5d3ab979c2e858a1ffca84ad3b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -53,16 +53,6 @@ impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {\n-\n-        // Check for those cases where we cannot control the aliasing\n-        // and make sure that we are not being asked to.\n-        match cmt.freely_aliasable() {\n-            None => {}\n-            Some(cause) => {\n-                self.check_aliasing_permitted(cause, restrictions);\n-            }\n-        }\n-\n         match cmt.cat {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -179,28 +169,4 @@ impl<'a> RestrictionsContext<'a> {\n             }\n         }\n     }\n-\n-    fn check_aliasing_permitted(&self,\n-                                cause: mc::AliasableReason,\n-                                restrictions: RestrictionSet) {\n-        //! This method is invoked when the current `cmt` is something\n-        //! where aliasing cannot be controlled. It reports an error if\n-        //! the restrictions required that it not be aliased; currently\n-        //! this only occurs when re-borrowing an `&mut` pointer.\n-        //!\n-        //! NB: To be 100% consistent, we should report an error if\n-        //! RESTR_FREEZE is found, because we cannot prevent freezing,\n-        //! nor would we want to. However, we do not report such an\n-        //! error, because this restriction only occurs when the user\n-        //! is creating an `&mut` pointer to immutable or read-only\n-        //! data, and there is already another piece of code that\n-        //! checks for this condition.\n-\n-        if restrictions.intersects(RESTR_ALIAS) {\n-            self.bccx.report_aliasability_violation(\n-                self.span,\n-                BorrowViolation,\n-                cause);\n-        }\n-    }\n }"}, {"sha": "6a3e2fc63b08f21fde4427a9cfed1248d63b5051", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -214,7 +214,6 @@ pub enum PartialTotal {\n #[deriving(Clone, Eq)]\n pub enum LoanMutability {\n     ImmutableMutability,\n-    ConstMutability,\n     MutableMutability,\n }\n \n@@ -232,7 +231,6 @@ impl ToStr for LoanMutability {\n     fn to_str(&self) -> ~str {\n         match *self {\n             ImmutableMutability => ~\"immutable\",\n-            ConstMutability => ~\"read-only\",\n             MutableMutability => ~\"mutable\",\n         }\n     }\n@@ -318,7 +316,6 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // - `RESTR_MUTATE`: The lvalue may not be modified.\n // - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n // - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n-// - `RESTR_ALIAS`: All borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n // restrictions are meaningful even if the RestrictionSet is empty,\n@@ -338,7 +335,6 @@ pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n-pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n impl RestrictionSet {\n     pub fn intersects(&self, restr: RestrictionSet) -> bool {\n@@ -663,8 +659,8 @@ impl BorrowckCtxt {\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n         let prefix = match kind {\n-            MutabilityViolation => \"cannot assign to an `&mut`\",\n-            BorrowViolation => \"cannot borrow an `&mut`\"\n+            MutabilityViolation => \"cannot assign to data\",\n+            BorrowViolation => \"cannot borrow data mutably\"\n         };\n \n         match cause {\n@@ -673,17 +669,21 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in an aliasable location\", prefix));\n             }\n+            mc::AliasableStatic |\n+            mc::AliasableStaticMut => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"{} in a static location\", prefix));\n+            }\n             mc::AliasableManaged => {\n-                self.tcx.sess.span_err(span, format!(\"{} in a `@` pointer\",\n-                                                     prefix))\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"{} in a `@` pointer\", prefix));\n             }\n-            mc::AliasableBorrowed(m) => {\n+            mc::AliasableBorrowed(_) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&{}` pointer; \\\n-                          try an `&mut` instead\",\n-                         prefix,\n-                         self.mut_to_keyword(m)));\n+                    format!(\"{} in a `&` reference\", prefix));\n             }\n         }\n     }"}, {"sha": "93f439b653c59e1df0dc1a5a22d211c205e0fdb6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -1100,7 +1100,9 @@ pub fn field_mutbl(tcx: ty::ctxt,\n pub enum AliasableReason {\n     AliasableManaged,\n     AliasableBorrowed(ast::Mutability),\n-    AliasableOther\n+    AliasableOther,\n+    AliasableStatic,\n+    AliasableStaticMut,\n }\n \n impl cmt_ {\n@@ -1130,10 +1132,6 @@ impl cmt_ {\n         }\n     }\n \n-    pub fn is_freely_aliasable(&self) -> bool {\n-        self.freely_aliasable().is_some()\n-    }\n-\n     pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n         /*!\n          * Returns `Some(_)` if this lvalue represents a freely aliasable\n@@ -1145,35 +1143,43 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n+            cat_deref(b, _, region_ptr(MutMutable, _)) |\n+            cat_downcast(b) |\n+            cat_stack_upvar(b) |\n+            cat_deref(b, _, uniq_ptr) |\n+            cat_interior(b, _) |\n+            cat_discr(b, _) => {\n+                // Aliasability depends on base cmt\n+                b.freely_aliasable()\n+            }\n+\n             cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_arg(_) |\n-            cat_deref(_, _, unsafe_ptr(..)) | // of course it is aliasable, but...\n-            cat_deref(_, _, region_ptr(MutMutable, _)) => {\n+            cat_deref(_, _, unsafe_ptr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) |\n-            cat_static_item(..) => {\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) => {\n                 Some(AliasableOther)\n             }\n \n+            cat_static_item(..) => {\n+                if self.mutbl.is_mutable() {\n+                    Some(AliasableStaticMut)\n+                } else {\n+                    Some(AliasableStatic)\n+                }\n+            }\n+\n             cat_deref(_, _, gc_ptr) => {\n                 Some(AliasableManaged)\n             }\n \n             cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n                 Some(AliasableBorrowed(m))\n             }\n-\n-            cat_downcast(..) |\n-            cat_stack_upvar(..) |\n-            cat_deref(_, _, uniq_ptr) |\n-            cat_interior(..) |\n-            cat_discr(..) => {\n-                None\n-            }\n         }\n     }\n }"}, {"sha": "76cf5997aee75851e586ac63c8b7ed4c1819c069", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              in_items: ~[@Item])\n                           -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"clone\", \"Clone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -39,7 +38,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n@@ -48,8 +47,7 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n                                   in_items: ~[@Item])\n     -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"clone\", \"DeepClone\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -69,7 +67,7 @@ pub fn expand_deriving_deep_clone(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn cs_clone("}, {"sha": "4672f1a8db689131de597d841b04f13c03ff9e70", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -45,8 +45,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"Eq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -55,5 +54,5 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n             md!(\"ne\", cs_ne)\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }"}, {"sha": "1a8ace69307a7313b17c6fecd2dfe2580cfab3de", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -35,8 +35,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n     );\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -47,7 +46,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n             md!(\"ge\", false, true)\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n /// Strict inequality."}, {"sha": "7b7c1afa4d5cb990928adb196e025c1d03ca701d", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -24,8 +24,7 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n     }\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"TotalEq\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -42,5 +41,5 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }"}, {"sha": "157b6dc7521b7a737dcd82bf56ac9ed9ae49dc00", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -21,8 +21,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                                 mitem: @MetaItem,\n                                 in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"cmp\", \"TotalOrd\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -40,7 +39,7 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n "}, {"sha": "fdf1ef17d538bf084884a8091526811bb39502a3", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -26,8 +26,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new_(~[\"serialize\", \"Decodable\"], None,\n                          ~[~Literal(Path::new_local(\"__D\"))], true),\n         additional_bounds: ~[],\n@@ -50,7 +49,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "7b87152b7115a1c122786310fe005c23cd0a2b5a", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -18,10 +18,9 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                               -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"default\", \"Default\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -38,7 +37,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n             },\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "43edf6006b414bfd83e6f07f6a34db6a9ee5ed4f", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -87,8 +87,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  mitem: @MetaItem,\n                                  in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new_(~[\"serialize\", \"Encodable\"], None,\n                          ~[~Literal(Path::new_local(\"__E\"))], true),\n         additional_bounds: ~[],\n@@ -111,7 +110,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "47be3067284a50f39c074bf2df5a5c691cc65bcd", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 122, "deletions": 82, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -193,13 +193,12 @@ pub use self::ty::*;\n mod ty;\n \n pub struct TraitDef<'a> {\n-    /// The extension context\n-    cx: &'a mut ExtCtxt<'a>,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n     /// Path of the trait, including any type parameters\n     path: Path<'a>,\n+\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n     additional_bounds: ~[Ty<'a>],\n@@ -321,19 +320,22 @@ pub type EnumNonMatchFunc<'a> =\n \n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n+                  cx: &mut ExtCtxt,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::Item]) -> ~[@ast::Item] {\n         let mut result = ~[];\n         for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::ItemStruct(struct_def, ref generics) => {\n-                    result.push(self.expand_struct_def(struct_def,\n+                    result.push(self.expand_struct_def(cx,\n+                                                       struct_def,\n                                                        item.ident,\n                                                        generics));\n                 }\n                 ast::ItemEnum(ref enum_def, ref generics) => {\n-                    result.push(self.expand_enum_def(enum_def,\n+                    result.push(self.expand_enum_def(cx,\n+                                                     enum_def,\n                                                      item.ident,\n                                                      generics));\n                 }\n@@ -354,9 +356,9 @@ impl<'a> TraitDef<'a> {\n      *\n      */\n     fn create_derived_impl(&self,\n+                           cx: &mut ExtCtxt,\n                            type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::Method]) -> @ast::Item {\n-        let cx = &*self.cx;\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         let mut trait_generics = self.generics.to_generics(cx, self.span,\n@@ -372,7 +374,8 @@ impl<'a> TraitDef<'a> {\n             let mut bounds = opt_vec::from(\n                 // extra restrictions on the generics parameters to the type being derived upon\n                 self.additional_bounds.map(|p| {\n-                    cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n+                    cx.typarambound(p.to_path(cx, self.span,\n+                                                  type_ident, generics))\n                 }));\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n@@ -393,15 +396,15 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, ~[ type_ident ], self_lifetimes,\n-                             opt_vec::take_vec(self_ty_params)), None);\n+                        opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n             self.span,\n             cx.meta_name_value(self.span,\n                                InternedString::new(\"doc\"),\n                                ast::LitStr(token::intern_and_get_ident(\n-                                       \"Automatically derived.\"),\n-                                       ast::CookedStr)));\n+                                               \"Automatically derived.\"),\n+                                           ast::CookedStr)));\n         cx.item(\n             self.span,\n             ::parse::token::special_idents::clownshoes_extensions,\n@@ -411,68 +414,77 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn expand_struct_def(&self,\n+                         cx: &mut ExtCtxt,\n                          struct_def: &StructDef,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(self, type_ident, generics);\n+                method_def.split_self_nonself_args(\n+                    cx, self, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_struct_method_body(\n+                    cx,\n                     self,\n                     struct_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_struct_method_body(self,\n+                method_def.expand_struct_method_body(cx,\n+                                                     self,\n                                                      struct_def,\n                                                      type_ident,\n                                                      self_args, nonself_args)\n             };\n \n-            method_def.create_method(self,\n+            method_def.create_method(cx, self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n \n     fn expand_enum_def(&self,\n+                       cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(self, type_ident, generics);\n+                method_def.split_self_nonself_args(cx, self,\n+                                                   type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_enum_method_body(\n+                    cx,\n                     self,\n                     enum_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_enum_method_body(self,\n+                method_def.expand_enum_method_body(cx,\n+                                                   self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args, nonself_args)\n             };\n \n-            method_def.create_method(self,\n+            method_def.create_method(cx, self,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         });\n \n-        self.create_derived_impl(type_ident, generics, methods)\n+        self.create_derived_impl(cx, type_ident, generics, methods)\n     }\n }\n \n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n+                                cx: &mut ExtCtxt,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,\n                                 self_args: &[@Expr],\n@@ -481,26 +493,33 @@ impl<'a> MethodDef<'a> {\n         -> @Expr {\n         let substructure = Substructure {\n             type_ident: type_ident,\n-            method_ident: trait_.cx.ident_of(self.name),\n+            method_ident: cx.ident_of(self.name),\n             self_args: self_args,\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(trait_.cx, trait_.span,\n+        (self.combine_substructure)(cx, trait_.span,\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, trait_: &TraitDef,\n-                  generics: &Generics, type_ident: Ident) -> P<ast::Ty> {\n-        self.ret_ty.to_ty(trait_.cx, trait_.span, type_ident, generics)\n+    fn get_ret_ty(&self,\n+                  cx: &mut ExtCtxt,\n+                  trait_: &TraitDef,\n+                  generics: &Generics,\n+                  type_ident: Ident)\n+                  -> P<ast::Ty> {\n+        self.ret_ty.to_ty(cx, trait_.span, type_ident, generics)\n     }\n \n     fn is_static(&self) -> bool {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, trait_: &TraitDef,\n-                               type_ident: Ident, generics: &Generics)\n+    fn split_self_nonself_args(&self,\n+                               cx: &mut ExtCtxt,\n+                               trait_: &TraitDef,\n+                               type_ident: Ident,\n+                               generics: &Generics)\n         -> (ast::ExplicitSelf, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n \n         let mut self_args = ~[];\n@@ -511,7 +530,7 @@ impl<'a> MethodDef<'a> {\n         let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n                 let (self_expr, explicit_self) =\n-                    ty::get_explicit_self(trait_.cx, trait_.span, self_ptr);\n+                    ty::get_explicit_self(cx, trait_.span, self_ptr);\n \n                 self_args.push(self_expr);\n                 nonstatic = true;\n@@ -522,11 +541,11 @@ impl<'a> MethodDef<'a> {\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n-            let ast_ty = ty.to_ty(trait_.cx, trait_.span, type_ident, generics);\n-            let ident = trait_.cx.ident_of(format!(\"__arg_{}\", i));\n+            let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = trait_.cx.expr_ident(trait_.span, ident);\n+            let arg_expr = cx.expr_ident(trait_.span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -535,7 +554,7 @@ impl<'a> MethodDef<'a> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(trait_.cx.expr_deref(trait_.span, arg_expr))\n+                    self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -546,35 +565,37 @@ impl<'a> MethodDef<'a> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, trait_: &TraitDef,\n+    fn create_method(&self,\n+                     cx: &mut ExtCtxt,\n+                     trait_: &TraitDef,\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::ExplicitSelf,\n                      arg_types: ~[(Ident, P<ast::Ty>)],\n                      body: @Expr) -> @ast::Method {\n         // create the generics that aren't for Self\n-        let fn_generics = self.generics.to_generics(trait_.cx, trait_.span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let self_arg = match explicit_self.node {\n             ast::SelfStatic => None,\n             _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n         };\n         let args = arg_types.move_iter().map(|(name, ty)| {\n-            trait_.cx.arg(trait_.span, name, ty)\n+            cx.arg(trait_.span, name, ty)\n         });\n         let args = self_arg.move_iter().chain(args).collect();\n \n-        let ret_type = self.get_ret_ty(trait_, generics, type_ident);\n+        let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = trait_.cx.ident_of(self.name);\n-        let fn_decl = trait_.cx.fn_decl(args, ret_type);\n-        let body_block = trait_.cx.block_expr(body);\n+        let method_ident = cx.ident_of(self.name);\n+        let fn_decl = cx.fn_decl(args, ret_type);\n+        let body_block = cx.block_expr(body);\n \n         let attrs = if self.inline {\n             ~[\n-                trait_.cx\n+                cx\n                       .attribute(trait_.span,\n-                                 trait_.cx\n+                                 cx\n                                        .meta_word(trait_.span,\n                                                   InternedString::new(\n                                                       \"inline\")))\n@@ -620,6 +641,7 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     */\n     fn expand_struct_method_body(&self,\n+                                 cx: &mut ExtCtxt,\n                                  trait_: &TraitDef,\n                                  struct_def: &StructDef,\n                                  type_ident: Ident,\n@@ -631,7 +653,7 @@ impl<'a> MethodDef<'a> {\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n         for i in range(0u, self_args.len()) {\n-            let (pat, ident_expr) = trait_.create_struct_pattern(type_ident, struct_def,\n+            let (pat, ident_expr) = trait_.create_struct_pattern(cx, type_ident, struct_def,\n                                                                  format!(\"__self_{}\", i),\n                                                                  ast::MutImmutable);\n             patterns.push(pat);\n@@ -655,13 +677,14 @@ impl<'a> MethodDef<'a> {\n                     }\n                 }).collect()\n             }\n-            [] => { trait_.cx.span_bug(trait_.span,\n-                                       \"no self arguments to non-static method \\\n-                                       in generic `deriving`\") }\n+            [] => { cx.span_bug(trait_.span,\n+                                \"no self arguments to non-static method \\\n+                                in generic `deriving`\") }\n         };\n \n         // body of the inner most destructuring match\n         let mut body = self.call_substructure_method(\n+            cx,\n             trait_,\n             type_ident,\n             self_args,\n@@ -672,22 +695,24 @@ impl<'a> MethodDef<'a> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = trait_.cx.expr_match(trait_.span, arg_expr,\n-                                        ~[ trait_.cx.arm(trait_.span, ~[pat], body) ])\n+            body = cx.expr_match(trait_.span, arg_expr,\n+                                     ~[ cx.arm(trait_.span, ~[pat], body) ])\n         }\n         body\n     }\n \n     fn expand_static_struct_method_body(&self,\n+                                        cx: &mut ExtCtxt,\n                                         trait_: &TraitDef,\n                                         struct_def: &StructDef,\n                                         type_ident: Ident,\n                                         self_args: &[@Expr],\n                                         nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = trait_.summarise_struct(struct_def);\n+        let summary = trait_.summarise_struct(cx, struct_def);\n \n-        self.call_substructure_method(trait_,\n+        self.call_substructure_method(cx,\n+                                      trait_,\n                                       type_ident,\n                                       self_args, nonself_args,\n                                       &StaticStruct(struct_def, summary))\n@@ -720,14 +745,15 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     */\n     fn expand_enum_method_body(&self,\n+                               cx: &mut ExtCtxt,\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n                                type_ident: Ident,\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n-        -> @Expr {\n+                               -> @Expr {\n         let mut matches = ~[];\n-        self.build_enum_match(trait_, enum_def, type_ident,\n+        self.build_enum_match(cx, trait_, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n     }\n@@ -755,6 +781,7 @@ impl<'a> MethodDef<'a> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n+                        cx: &mut ExtCtxt,\n                         trait_: &TraitDef,\n                         enum_def: &EnumDef,\n                         type_ident: Ident,\n@@ -764,13 +791,13 @@ impl<'a> MethodDef<'a> {\n                         matches_so_far: &mut ~[(uint, P<ast::Variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n-        let cx = &trait_.cx;\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             if matches_so_far.len() == 0 {\n                 cx.span_bug(trait_.span,\n-                            \"no self match on an enum in generic `deriving`\");\n+                                \"no self match on an enum in \\\n+                                generic `deriving`\");\n             }\n             // we currently have a vec of vecs, where each\n             // subvec is the fields of one of the arguments,\n@@ -820,7 +847,7 @@ impl<'a> MethodDef<'a> {\n                     substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n-            self.call_substructure_method(trait_, type_ident,\n+            self.call_substructure_method(cx, trait_, type_ident,\n                                           self_args, nonself_args,\n                                           &substructure)\n \n@@ -846,12 +873,14 @@ impl<'a> MethodDef<'a> {\n \n                 // matching-variant match\n                 let variant = enum_def.variants[index];\n-                let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n+                                                                           variant,\n                                                                            current_match_str,\n                                                                            ast::MutImmutable);\n \n                 matches_so_far.push((index, variant, idents));\n-                let arm_expr = self.build_enum_match(trait_,\n+                let arm_expr = self.build_enum_match(cx,\n+                                                     trait_,\n                                                      enum_def,\n                                                      type_ident,\n                                                      self_args, nonself_args,\n@@ -863,18 +892,20 @@ impl<'a> MethodDef<'a> {\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(trait_, type_ident,\n+                    let wild_expr = self.call_substructure_method(cx, trait_, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = cx.arm(trait_.span,\n-                                          ~[ cx.pat_wild(trait_.span) ],\n-                                          wild_expr);\n+                    let wild_arm = cx.arm(\n+                        trait_.span,\n+                        ~[ cx.pat_wild(trait_.span) ],\n+                        wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n                 // create an arm matching on each variant\n                 for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) = trait_.create_enum_variant_pattern(variant,\n+                    let (pattern, idents) = trait_.create_enum_variant_pattern(cx,\n+                                                                               variant,\n                                                                                current_match_str,\n                                                                                ast::MutImmutable);\n \n@@ -885,7 +916,8 @@ impl<'a> MethodDef<'a> {\n                             Some(i) if index == i => Some(i),\n                             _ => None\n                         };\n-                    let arm_expr = self.build_enum_match(trait_,\n+                    let arm_expr = self.build_enum_match(cx,\n+                                                         trait_,\n                                                          enum_def,\n                                                          type_ident,\n                                                          self_args, nonself_args,\n@@ -905,6 +937,7 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn expand_static_enum_method_body(&self,\n+                                      cx: &mut ExtCtxt,\n                                       trait_: &TraitDef,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n@@ -915,15 +948,15 @@ impl<'a> MethodDef<'a> {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n-                    Unnamed(args.map(|va| trait_.set_expn_info(va.ty.span)))\n+                    Unnamed(args.map(|va| trait_.set_expn_info(cx, va.ty.span)))\n                 }\n                 ast::StructVariantKind(struct_def) => {\n-                    trait_.summarise_struct(struct_def)\n+                    trait_.summarise_struct(cx, struct_def)\n                 }\n             };\n             (ident, v.span, summary)\n         });\n-        self.call_substructure_method(trait_, type_ident,\n+        self.call_substructure_method(cx, trait_, type_ident,\n                                       self_args, nonself_args,\n                                       &StaticEnum(enum_def, summary))\n     }\n@@ -936,9 +969,11 @@ enum StructType {\n \n // general helper methods.\n impl<'a> TraitDef<'a> {\n-    fn set_expn_info(&self, mut to_set: Span) -> Span {\n+    fn set_expn_info(&self,\n+                     cx: &mut ExtCtxt,\n+                     mut to_set: Span) -> Span {\n         let trait_name = match self.path.path.last() {\n-            None => self.cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n+            None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n         to_set.expn_info = Some(@codemap::ExpnInfo {\n@@ -952,21 +987,23 @@ impl<'a> TraitDef<'a> {\n         to_set\n     }\n \n-    fn summarise_struct(&self, struct_def: &StructDef) -> StaticFields {\n+    fn summarise_struct(&self,\n+                        cx: &mut ExtCtxt,\n+                        struct_def: &StructDef) -> StaticFields {\n         let mut named_idents = ~[];\n         let mut just_spans = ~[];\n         for field in struct_def.fields.iter(){\n-            let sp = self.set_expn_info(field.span);\n+            let sp = self.set_expn_info(cx, field.span);\n             match field.node.kind {\n                 ast::NamedField(ident, _) => named_idents.push((ident, sp)),\n                 ast::UnnamedField => just_spans.push(sp),\n             }\n         }\n \n         match (just_spans.is_empty(), named_idents.is_empty()) {\n-            (false, false) => self.cx.span_bug(self.span,\n-                                               \"a struct with named and unnamed \\\n-                                               fields in generic `deriving`\"),\n+            (false, false) => cx.span_bug(self.span,\n+                                          \"a struct with named and unnamed \\\n+                                          fields in generic `deriving`\"),\n             // named fields\n             (_, false) => Named(named_idents),\n             // tuple structs (includes empty structs)\n@@ -975,23 +1012,23 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_subpatterns(&self,\n+                          cx: &mut ExtCtxt,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::Mutability)\n                           -> ~[@ast::Pat] {\n         field_paths.map(|path| {\n-            self.cx.pat(path.span,\n+            cx.pat(path.span,\n                         ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n             })\n     }\n \n     fn create_struct_pattern(&self,\n+                             cx: &mut ExtCtxt,\n                              struct_ident: Ident,\n                              struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-        -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = &self.cx;\n-\n+                             -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n         if struct_def.fields.is_empty() {\n             return (\n                 cx.pat_ident_binding_mode(\n@@ -1006,7 +1043,7 @@ impl<'a> TraitDef<'a> {\n         let mut struct_type = Unknown;\n \n         for (i, struct_field) in struct_def.fields.iter().enumerate() {\n-            let sp = self.set_expn_info(struct_field.span);\n+            let sp = self.set_expn_info(cx, struct_field.span);\n             let opt_id = match struct_field.node.kind {\n                 ast::NamedField(ident, _) if (struct_type == Unknown ||\n                                               struct_type == Record) => {\n@@ -1024,11 +1061,13 @@ impl<'a> TraitDef<'a> {\n             };\n             let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n             paths.push(path.clone());\n-            let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+            let val = cx.expr(\n+                sp, ast::ExprParen(\n+                    cx.expr_deref(sp, cx.expr_path(path))));\n             ident_expr.push((sp, opt_id, val));\n         }\n \n-        let subpats = self.create_subpatterns(paths, mutbl);\n+        let subpats = self.create_subpatterns(cx, paths, mutbl);\n \n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n@@ -1046,17 +1085,17 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_enum_variant_pattern(&self,\n+                                   cx: &mut ExtCtxt,\n                                    variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n-        let cx = &*self.cx;\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n             ast::TupleVariantKind(ref variant_args) => {\n                 if variant_args.is_empty() {\n                     return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n-                                                      ast::BindByValue(ast::MutImmutable)),\n+                                                          ast::BindByValue(ast::MutImmutable)),\n                             ~[]);\n                 }\n \n@@ -1065,21 +1104,22 @@ impl<'a> TraitDef<'a> {\n                 let mut paths = ~[];\n                 let mut ident_expr = ~[];\n                 for (i, va) in variant_args.iter().enumerate() {\n-                    let sp = self.set_expn_info(va.ty.span);\n+                    let sp = self.set_expn_info(cx, va.ty.span);\n                     let path = cx.path_ident(sp, cx.ident_of(format!(\"{}_{}\", prefix, i)));\n \n                     paths.push(path.clone());\n-                    let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n+                    let val = cx.expr(\n+                        sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(path))));\n                     ident_expr.push((sp, None, val));\n                 }\n \n-                let subpats = self.create_subpatterns(paths, mutbl);\n+                let subpats = self.create_subpatterns(cx, paths, mutbl);\n \n                 (cx.pat_enum(variant.span, matching_path, subpats),\n                  ident_expr)\n             }\n             ast::StructVariantKind(struct_def) => {\n-                self.create_struct_pattern(variant_ident, struct_def,\n+                self.create_struct_pattern(cx, variant_ident, struct_def,\n                                            prefix, mutbl)\n             }\n         }"}, {"sha": "19e81b81df6a650434d04bb28d05ef63791050e4", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -20,8 +20,7 @@ pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n                                   mitem: @MetaItem,\n                                   in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"to_bytes\", \"IterBytes\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -42,7 +41,7 @@ pub fn expand_deriving_iter_bytes(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn iter_bytes_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "1b356667b6b313da7e7cc7137e9223e486773fe6", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -21,8 +21,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       mitem: @MetaItem,\n                                       in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"num\", \"FromPrimitive\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -62,7 +61,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n         ]\n     };\n \n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "a40317286c96083615f102fcbdeff9455bd81ca6", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -20,10 +20,9 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"rand\", \"Rand\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -47,7 +46,7 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "e2d507f30351054190ddd95baa8de70a65d42737", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -24,14 +24,13 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(~Literal(Path::new(~[\"std\", \"fmt\", \"Formatter\"])),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"fmt\", \"Show\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -48,7 +47,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n // we construct a format string and then defer to std::fmt, since that"}, {"sha": "186f12544935d519886d0cb2830072cebf5f3881", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -21,10 +21,9 @@ pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n                               span: Span,\n                               mitem: @MetaItem,\n                               in_items: ~[@Item])\n-    -> ~[@Item] {\n+                              -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"to_str\", \"ToStr\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -41,7 +40,7 @@ pub fn expand_deriving_to_str(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n // It used to be the case that this deriving implementation invoked"}, {"sha": "ca5c1543d88dc66f5e30772e8199e7beccbdd1c0", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -18,10 +18,9 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n                             in_items: ~[@Item])\n-    -> ~[@Item] {\n+                            -> ~[@Item] {\n     let trait_def = TraitDef {\n-        cx: cx, span: span,\n-\n+        span: span,\n         path: Path::new(~[\"std\", \"num\", \"Zero\"]),\n         additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n@@ -54,7 +53,7 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n             }\n         ]\n     };\n-    trait_def.expand(mitem, in_items)\n+    trait_def.expand(cx, mitem, in_items)\n }\n \n fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "d19538c5d362b26d687fce143a2ad86e01fb96cb", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0e0d9e101d36957102c38de3ec9e089c1d43dbb/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=f0e0d9e101d36957102c38de3ec9e089c1d43dbb", "patch": "@@ -27,5 +27,10 @@ fn foo3(t0: &mut &mut int) {\n     **t1 = 22;\n }\n \n+fn foo4(t0: & &mut int) {\n+    let x:  &mut int = &mut **t0; //~ ERROR cannot borrow\n+    *x += 1;\n+}\n+\n fn main() {\n }"}]}