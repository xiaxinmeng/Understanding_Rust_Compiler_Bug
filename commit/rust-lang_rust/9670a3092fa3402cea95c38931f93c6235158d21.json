{"sha": "9670a3092fa3402cea95c38931f93c6235158d21", "node_id": "C_kwDOAAsO6NoAKDk2NzBhMzA5MmZhMzQwMmNlYTk1YzM4OTMxZjkzYzYyMzUxNThkMjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T12:23:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T12:23:11Z"}, "message": "Auto merge of #2609 - RalfJung:is_terminal, r=RalfJung\n\nUse is_terminal to implement isatty\n\nThis means that Linux targets on Windows hosts should give a correct reply. We still don't have an implementation for Windows targets though, that requires some tracking of handles.\n\nFixes https://github.com/rust-lang/miri/issues/2419\n\nAlso restructure our `fs` tests a bit to test the parts that don't need libc separately.\n\n`as_unix_host_fd` is now not used any more, but it could become useful again in the future so I kept it.", "tree": {"sha": "d45deb131bb99959c70c058bc3c9dafd4172eac5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d45deb131bb99959c70c058bc3c9dafd4172eac5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9670a3092fa3402cea95c38931f93c6235158d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9670a3092fa3402cea95c38931f93c6235158d21", "html_url": "https://github.com/rust-lang/rust/commit/9670a3092fa3402cea95c38931f93c6235158d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9670a3092fa3402cea95c38931f93c6235158d21/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "html_url": "https://github.com/rust-lang/rust/commit/befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "1c9f3682f5d95ccb5bd7d9f3e49dd49df5e9ee4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c9f3682f5d95ccb5bd7d9f3e49dd49df5e9ee4e", "html_url": "https://github.com/rust-lang/rust/commit/1c9f3682f5d95ccb5bd7d9f3e49dd49df5e9ee4e"}], "stats": {"total": 381, "additions": 230, "deletions": 151}, "files": [{"sha": "97271c33a2e6b78de02aebb560b1df2c769db9be", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -9,6 +9,7 @@\n #![feature(is_some_and)]\n #![feature(nonzero_ops)]\n #![feature(local_key_cell_methods)]\n+#![feature(is_terminal)]\n // Configure clippy and other lints\n #![allow(\n     clippy::collapsible_else_if,"}, {"sha": "44a433df1e9c0d45f08c11304d8375a7468fa414", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -452,7 +452,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"isatty\" => {\n                 let [fd] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let result = this.isatty(fd)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"pthread_atfork\" => {\n                 let [prepare, parent, child] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "0610f65db113f8f690396bdb5ed4fd82f9b39d36", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -4,7 +4,7 @@ use std::convert::TryInto;\n use std::fs::{\n     read_dir, remove_dir, remove_file, rename, DirBuilder, File, FileType, OpenOptions, ReadDir,\n };\n-use std::io::{self, ErrorKind, Read, Seek, SeekFrom, Write};\n+use std::io::{self, ErrorKind, IsTerminal, Read, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n use std::time::SystemTime;\n \n@@ -65,6 +65,8 @@ trait FileDescriptor: std::fmt::Debug {\n \n     fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>>;\n \n+    fn is_tty(&self) -> bool;\n+\n     #[cfg(unix)]\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         None\n@@ -143,6 +145,10 @@ impl FileDescriptor for FileHandle {\n         use std::os::unix::io::AsRawFd;\n         Some(self.file.as_raw_fd())\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.file.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stdin {\n@@ -170,6 +176,10 @@ impl FileDescriptor for io::Stdin {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDIN_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stdout {\n@@ -202,6 +212,10 @@ impl FileDescriptor for io::Stdout {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDOUT_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n impl FileDescriptor for io::Stderr {\n@@ -227,12 +241,16 @@ impl FileDescriptor for io::Stderr {\n     fn as_unix_host_fd(&self) -> Option<i32> {\n         Some(libc::STDERR_FILENO)\n     }\n+\n+    fn is_tty(&self) -> bool {\n+        self.is_terminal()\n+    }\n }\n \n #[derive(Debug)]\n-struct DummyOutput;\n+struct NullOutput;\n \n-impl FileDescriptor for DummyOutput {\n+impl FileDescriptor for NullOutput {\n     fn name(&self) -> &'static str {\n         \"stderr and stdout\"\n     }\n@@ -247,7 +265,11 @@ impl FileDescriptor for DummyOutput {\n     }\n \n     fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n-        Ok(Box::new(DummyOutput))\n+        Ok(Box::new(NullOutput))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n     }\n }\n \n@@ -267,8 +289,8 @@ impl FileHandler {\n         let mut handles: BTreeMap<_, Box<dyn FileDescriptor>> = BTreeMap::new();\n         handles.insert(0i32, Box::new(io::stdin()));\n         if mute_stdout_stderr {\n-            handles.insert(1i32, Box::new(DummyOutput));\n-            handles.insert(2i32, Box::new(DummyOutput));\n+            handles.insert(1i32, Box::new(NullOutput));\n+            handles.insert(2i32, Box::new(NullOutput));\n         } else {\n             handles.insert(1i32, Box::new(io::stdout()));\n             handles.insert(2i32, Box::new(io::stderr()));\n@@ -1662,35 +1684,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     #[cfg_attr(not(unix), allow(unused))]\n-    fn isatty(&mut self, miri_fd: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n+    fn isatty(\n+        &mut self,\n+        miri_fd: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        #[cfg(unix)]\n+        // \"returns 1 if fd is an open file descriptor referring to a terminal;\n+        // otherwise 0 is returned, and errno is set to indicate the error\"\n         if matches!(this.machine.isolated_op, IsolatedOp::Allow) {\n-            let miri_fd = this.read_scalar(miri_fd)?.to_i32()?;\n-            if let Some(host_fd) =\n-                this.machine.file_handler.handles.get(&miri_fd).and_then(|fd| fd.as_unix_host_fd())\n-            {\n-                // \"returns 1 if fd is an open file descriptor referring to a terminal;\n-                // otherwise 0 is returned, and errno is set to indicate the error\"\n-                // SAFETY: isatty has no preconditions\n-                let is_tty = unsafe { libc::isatty(host_fd) };\n-                if is_tty == 0 {\n-                    let errno = std::io::Error::last_os_error()\n-                        .raw_os_error()\n-                        .map(Scalar::from_i32)\n-                        .unwrap();\n-                    this.set_last_error(errno)?;\n-                }\n-                return Ok(is_tty);\n+            let fd = this.read_scalar(miri_fd)?.to_i32()?;\n+            if this.machine.file_handler.handles.get(&fd).map(|fd| fd.is_tty()) == Some(true) {\n+                return Ok(Scalar::from_i32(1));\n             }\n         }\n-        // We are attemping to use a Unix interface on a non-Unix platform, or we are on a Unix\n-        // platform and the passed file descriptor is not open, or isolation is enabled\n-        // FIXME: It should be possible to emulate this at least on Windows by using\n-        // GetConsoleMode.\n+        // Fallback when the FD was not found or isolation is enabled.\n         let enotty = this.eval_libc(\"ENOTTY\")?;\n         this.set_last_error(enotty)?;\n-        Ok(0)\n+        Ok(Scalar::from_i32(0))\n     }\n \n     fn realpath("}, {"sha": "f1838cf64f7feefbf5d5b0a01f7e8c5e3fe7fd9a", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -0,0 +1,28 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n+//@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n+\n+use std::ffi::CString;\n+use std::fs;\n+use std::io::{Error, ErrorKind};\n+\n+fn main() {\n+    // test `fcntl`\n+    unsafe {\n+        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n+    }\n+\n+    // test `readlink`\n+    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n+    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n+    unsafe {\n+        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n+        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+    }\n+\n+    // test `stat`\n+    assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n+    // check that it is the right kind of `PermissionDenied`\n+    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n+}"}, {"sha": "21fcb65243e26160f321b44e3d2df0cad808ea17", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs-with-isolation.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs-with-isolation.stderr?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -0,0 +1,6 @@\n+warning: `fcntl` was made to return an error due to isolation\n+\n+warning: `readlink` was made to return an error due to isolation\n+\n+warning: `$STAT` was made to return an error due to isolation\n+"}, {"sha": "acf16ecb7e06dff5c69ae9aa4624aa02f80c5d58", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -0,0 +1,137 @@\n+//@ignore-target-windows: no libc on Windows\n+//@compile-flags: -Zmiri-disable-isolation\n+\n+#![feature(io_error_more)]\n+#![feature(io_error_uncategorized)]\n+\n+use std::convert::TryInto;\n+use std::ffi::CString;\n+use std::fs::{canonicalize, remove_file, File};\n+use std::io::{Error, ErrorKind, Write};\n+use std::os::unix::ffi::OsStrExt;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    test_dup_stdout_stderr();\n+    test_canonicalize_too_long();\n+    test_readlink();\n+    test_file_open_unix_allow_two_args();\n+    test_file_open_unix_needs_three_args();\n+    test_file_open_unix_extra_third_arg();\n+}\n+\n+fn tmp() -> PathBuf {\n+    std::env::var(\"MIRI_TEMP\")\n+        .map(|tmp| {\n+            // MIRI_TEMP is set outside of our emulated\n+            // program, so it may have path separators that don't\n+            // correspond to our target platform. We normalize them here\n+            // before constructing a `PathBuf`\n+\n+            #[cfg(windows)]\n+            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n+\n+            #[cfg(not(windows))]\n+            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n+        })\n+        .unwrap_or_else(|_| std::env::temp_dir())\n+}\n+\n+/// Prepare: compute filename and make sure the file does not exist.\n+fn prepare(filename: &str) -> PathBuf {\n+    let path = tmp().join(filename);\n+    // Clean the paths for robustness.\n+    remove_file(&path).ok();\n+    path\n+}\n+\n+/// Prepare like above, and also write some initial content to the file.\n+fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n+    let path = prepare(filename);\n+    let mut file = File::create(&path).unwrap();\n+    file.write(content).unwrap();\n+    path\n+}\n+\n+fn test_file_open_unix_allow_two_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n+}\n+\n+fn test_file_open_unix_needs_three_args() {\n+    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n+}\n+\n+fn test_file_open_unix_extra_third_arg() {\n+    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n+\n+    let mut name = path.into_os_string();\n+    name.push(\"\\0\");\n+    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n+    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n+}\n+\n+fn test_dup_stdout_stderr() {\n+    let bytes = b\"hello dup fd\\n\";\n+    unsafe {\n+        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n+        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n+        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n+    }\n+}\n+\n+fn test_canonicalize_too_long() {\n+    // Make sure we get an error for long paths.\n+    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n+    assert!(canonicalize(too_long).is_err());\n+}\n+\n+fn test_readlink() {\n+    let bytes = b\"Hello, World!\\n\";\n+    let path = prepare_with_content(\"miri_test_fs_link_target.txt\", bytes);\n+    let expected_path = path.as_os_str().as_bytes();\n+\n+    let symlink_path = prepare(\"miri_test_fs_symlink.txt\");\n+    std::os::unix::fs::symlink(&path, &symlink_path).unwrap();\n+\n+    // Test that the expected string gets written to a buffer of proper\n+    // length, and that a trailing null byte is not written.\n+    let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n+    let symlink_c_ptr = symlink_c_str.as_ptr();\n+\n+    // Make the buf one byte larger than it needs to be,\n+    // and check that the last byte is not overwritten.\n+    let mut large_buf = vec![0xFF; expected_path.len() + 1];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n+    // Check that the resovled path was properly written into the buf.\n+    assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n+    assert_eq!(large_buf.last(), Some(&0xFF));\n+    assert_eq!(res, large_buf.len() as isize - 1);\n+\n+    // Test that the resolved path is truncated if the provided buffer\n+    // is too small.\n+    let mut small_buf = [0u8; 2];\n+    let res =\n+        unsafe { libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len()) };\n+    assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n+    assert_eq!(res, small_buf.len() as isize);\n+\n+    // Test that we report a proper error for a missing path.\n+    let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n+    let res = unsafe {\n+        libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n+    };\n+    assert_eq!(res, -1);\n+    assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n+}"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stderr?ref=9670a3092fa3402cea95c38931f93c6235158d21", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stderr"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.stdout?ref=9670a3092fa3402cea95c38931f93c6235158d21", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.stdout"}, {"sha": "b6fa69e3d5d2e8c4626550dcb2c413f91dfcd156", "filename": "src/tools/miri/tests/pass-dep/shims/libc-rsfs.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-rsfs.stdout?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -0,0 +1 @@\n+hello dup fd"}, {"sha": "8fa683085b98bb6fc03cf65dd048a658082e2fb9", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.rs", "status": "renamed", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -2,21 +2,14 @@\n //@compile-flags: -Zmiri-isolation-error=warn-nobacktrace\n //@normalize-stderr-test: \"(stat(x)?)\" -> \"$$STAT\"\n \n-use std::ffi::CString;\n use std::fs::{self, File};\n-use std::io::{Error, ErrorKind};\n+use std::io::ErrorKind;\n use std::os::unix;\n \n fn main() {\n     // test `open`\n     assert_eq!(File::create(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n-    // test `fcntl`\n-    unsafe {\n-        assert_eq!(libc::fcntl(1, libc::F_DUPFD, 0), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EPERM));\n-    }\n-\n     // test `unlink`\n     assert_eq!(fs::remove_file(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n \n@@ -26,17 +19,8 @@ fn main() {\n         ErrorKind::PermissionDenied\n     );\n \n-    // test `readlink`\n-    let symlink_c_str = CString::new(\"foo.txt\").unwrap();\n-    let mut buf = vec![0; \"foo_link.txt\".len() + 1];\n-    unsafe {\n-        assert_eq!(libc::readlink(symlink_c_str.as_ptr(), buf.as_mut_ptr(), buf.len()), -1);\n-        assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n-    }\n-\n     // test `stat`\n     assert_eq!(fs::metadata(\"foo.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n \n     // test `rename`\n     assert_eq!(fs::rename(\"a.txt\", \"b.txt\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n@@ -49,5 +33,4 @@ fn main() {\n \n     // test `opendir`\n     assert_eq!(fs::read_dir(\"foo/bar\").unwrap_err().kind(), ErrorKind::PermissionDenied);\n-    assert_eq!(Error::last_os_error().raw_os_error(), Some(libc::EACCES));\n }", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.rs"}, {"sha": "452c5b9b772aa6ad3720957df9eb17dce9ca0849", "filename": "src/tools/miri/tests/pass/shims/fs-with-isolation.stderr", "status": "renamed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs-with-isolation.stderr?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -1,13 +1,9 @@\n warning: `open` was made to return an error due to isolation\n \n-warning: `fcntl` was made to return an error due to isolation\n-\n warning: `unlink` was made to return an error due to isolation\n \n warning: `symlink` was made to return an error due to isolation\n \n-warning: `readlink` was made to return an error due to isolation\n-\n warning: `$STAT` was made to return an error due to isolation\n \n warning: `rename` was made to return an error due to isolation", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs_with_isolation.stderr"}, {"sha": "65cf6fe66ba5ea4446e2ec72f9f690c849f67626", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "renamed", "additions": 7, "deletions": 99, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -3,14 +3,15 @@\n \n #![feature(io_error_more)]\n #![feature(io_error_uncategorized)]\n+#![feature(is_terminal)]\n \n use std::collections::HashMap;\n-use std::ffi::{CString, OsString};\n+use std::ffi::OsString;\n use std::fs::{\n-    create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename, File,\n-    OpenOptions,\n+    canonicalize, create_dir, read_dir, read_link, remove_dir, remove_dir_all, remove_file, rename,\n+    File, OpenOptions,\n };\n-use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n+use std::io::{Error, ErrorKind, IsTerminal, Read, Result, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n \n fn main() {\n@@ -26,13 +27,7 @@ fn main() {\n     test_rename();\n     test_directory();\n     test_canonicalize();\n-    test_dup_stdout_stderr();\n     test_from_raw_os_error();\n-\n-    // These all require unix, if the test is changed to no longer `ignore-windows`, move these to a unix test\n-    test_file_open_unix_allow_two_args();\n-    test_file_open_unix_needs_three_args();\n-    test_file_open_unix_extra_third_arg();\n }\n \n fn tmp() -> PathBuf {\n@@ -97,43 +92,12 @@ fn test_file() {\n     file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n+    assert!(!file.is_terminal());\n+\n     // Removing file should succeed.\n     remove_file(&path).unwrap();\n }\n \n-fn test_file_open_unix_allow_two_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_allow_two_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY) };\n-}\n-\n-fn test_file_open_unix_needs_three_args() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_needs_three_args.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_CREAT, 0o666) };\n-}\n-\n-fn test_file_open_unix_extra_third_arg() {\n-    use std::os::unix::ffi::OsStrExt;\n-\n-    let path = prepare_with_content(\"test_file_open_unix_extra_third_arg.txt\", &[]);\n-\n-    let mut name = path.into_os_string();\n-    name.push(\"\\0\");\n-    let name_ptr = name.as_bytes().as_ptr().cast::<libc::c_char>();\n-    let _fd = unsafe { libc::open(name_ptr, libc::O_RDONLY, 42) };\n-}\n-\n fn test_file_clone() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare_with_content(\"miri_test_fs_file_clone.txt\", bytes);\n@@ -279,46 +243,6 @@ fn test_symlink() {\n     symlink_file.read_to_end(&mut contents).unwrap();\n     assert_eq!(bytes, contents.as_slice());\n \n-    #[cfg(unix)]\n-    {\n-        use std::os::unix::ffi::OsStrExt;\n-\n-        let expected_path = path.as_os_str().as_bytes();\n-\n-        // Test that the expected string gets written to a buffer of proper\n-        // length, and that a trailing null byte is not written.\n-        let symlink_c_str = CString::new(symlink_path.as_os_str().as_bytes()).unwrap();\n-        let symlink_c_ptr = symlink_c_str.as_ptr();\n-\n-        // Make the buf one byte larger than it needs to be,\n-        // and check that the last byte is not overwritten.\n-        let mut large_buf = vec![0xFF; expected_path.len() + 1];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len())\n-        };\n-        // Check that the resovled path was properly written into the buf.\n-        assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n-        assert_eq!(large_buf.last(), Some(&0xFF));\n-        assert_eq!(res, large_buf.len() as isize - 1);\n-\n-        // Test that the resolved path is truncated if the provided buffer\n-        // is too small.\n-        let mut small_buf = [0u8; 2];\n-        let res = unsafe {\n-            libc::readlink(symlink_c_ptr, small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(small_buf, &expected_path[..small_buf.len()]);\n-        assert_eq!(res, small_buf.len() as isize);\n-\n-        // Test that we report a proper error for a missing path.\n-        let bad_path = CString::new(\"MIRI_MISSING_FILE_NAME\").unwrap();\n-        let res = unsafe {\n-            libc::readlink(bad_path.as_ptr(), small_buf.as_mut_ptr().cast(), small_buf.len())\n-        };\n-        assert_eq!(res, -1);\n-        assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n-    }\n-\n     // Test that metadata of a symbolic link (i.e., the file it points to) is correct.\n     check_metadata(bytes, &symlink_path).unwrap();\n     // Test that the metadata of a symbolic link is correct when not following it.\n@@ -369,7 +293,6 @@ fn test_rename() {\n }\n \n fn test_canonicalize() {\n-    use std::fs::canonicalize;\n     let dir_path = prepare_dir(\"miri_test_fs_dir\");\n     create_dir(&dir_path).unwrap();\n     let path = dir_path.join(\"test_file\");\n@@ -379,11 +302,6 @@ fn test_canonicalize() {\n     assert_eq!(p.to_string_lossy().find('.'), None);\n \n     remove_dir_all(&dir_path).unwrap();\n-\n-    // Make sure we get an error for long paths.\n-    use std::convert::TryInto;\n-    let too_long = \"x/\".repeat(libc::PATH_MAX.try_into().unwrap());\n-    assert!(canonicalize(too_long).is_err());\n }\n \n fn test_directory() {\n@@ -440,16 +358,6 @@ fn test_directory() {\n     remove_dir_all(&dir_path).unwrap();\n }\n \n-fn test_dup_stdout_stderr() {\n-    let bytes = b\"hello dup fd\\n\";\n-    unsafe {\n-        let new_stdout = libc::fcntl(1, libc::F_DUPFD, 0);\n-        let new_stderr = libc::fcntl(2, libc::F_DUPFD, 0);\n-        libc::write(new_stdout, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-        libc::write(new_stderr, bytes.as_ptr() as *const libc::c_void, bytes.len());\n-    }\n-}\n-\n fn test_from_raw_os_error() {\n     let code = 6; // not a code that std or Miri know\n     let error = Error::from_raw_os_error(code);", "previous_filename": "src/tools/miri/tests/pass-dep/shims/fs.rs"}, {"sha": "4d43549a930beaf55ca804601075eed06c959011", "filename": "src/tools/miri/tests/pass/shims/io.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9670a3092fa3402cea95c38931f93c6235158d21/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fio.rs?ref=9670a3092fa3402cea95c38931f93c6235158d21", "patch": "@@ -0,0 +1,9 @@\n+#![feature(is_terminal)]\n+\n+use std::io::IsTerminal;\n+\n+fn main() {\n+    // We can't really assume that this is truly a terminal, and anyway on Windows Miri will always\n+    // return `false` here, but we can check that the call succeeds.\n+    std::io::stdout().is_terminal();\n+}"}]}