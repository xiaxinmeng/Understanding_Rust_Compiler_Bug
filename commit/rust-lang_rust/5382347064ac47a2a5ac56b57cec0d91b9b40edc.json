{"sha": "5382347064ac47a2a5ac56b57cec0d91b9b40edc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzODIzNDcwNjRhYzQ3YTJhNWFjNTZiNTdjZWMwZDkxYjliNDBlZGM=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-01T00:51:51Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-01T01:02:08Z"}, "message": "Use Box::into_raw instead of ManuallyDrop in Thread::new.", "tree": {"sha": "4de08ddd74f5747469bea80e5064ace46ac8e21e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4de08ddd74f5747469bea80e5064ace46ac8e21e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5382347064ac47a2a5ac56b57cec0d91b9b40edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5382347064ac47a2a5ac56b57cec0d91b9b40edc", "html_url": "https://github.com/rust-lang/rust/commit/5382347064ac47a2a5ac56b57cec0d91b9b40edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5382347064ac47a2a5ac56b57cec0d91b9b40edc/comments", "author": null, "committer": null, "parents": [{"sha": "753bc7ddf8a0f00acf039731947a12d06ad30884", "url": "https://api.github.com/repos/rust-lang/rust/commits/753bc7ddf8a0f00acf039731947a12d06ad30884", "html_url": "https://github.com/rust-lang/rust/commit/753bc7ddf8a0f00acf039731947a12d06ad30884"}], "stats": {"total": 56, "additions": 20, "deletions": 36}, "files": [{"sha": "9d95a61c3154da002211f721365a6520ec01d594", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=5382347064ac47a2a5ac56b57cec0d91b9b40edc", "patch": "@@ -22,26 +22,21 @@ unsafe impl Sync for Thread {}\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let mut p = mem::ManuallyDrop::new(box p);\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n         assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n \n-        let ret = libc::pthread_create(\n-            &mut native,\n-            &attr,\n-            thread_start,\n-            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n-        );\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to manually drop it.\n-            mem::ManuallyDrop::drop(&mut p);\n+            // safe to reconstruct the box so that it gets deallocated.\n+            let _ = Box::from_raw(p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n             Ok(Thread { id: native })"}, {"sha": "6b009037805416b8c4e3cbb047fb100487430b0a", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=5382347064ac47a2a5ac56b57cec0d91b9b40edc", "patch": "@@ -48,20 +48,20 @@ impl Thread {\n         p: Box<dyn FnOnce()>,\n         core_id: isize,\n     ) -> io::Result<Thread> {\n-        let mut p = mem::ManuallyDrop::new(box p);\n+        let p = Box::into_raw(box p);\n         let mut tid: Tid = u32::MAX;\n         let ret = abi::spawn(\n             &mut tid as *mut Tid,\n             thread_start,\n-            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut u8 as usize,\n+            p as *mut u8 as usize,\n             Priority::into(NORMAL_PRIO),\n             core_id,\n         );\n \n         return if ret != 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to manually drop it.\n-            mem::ManuallyDrop::drop(&mut p);\n+            // safe to reconstruct the box so that it gets deallocated.\n+            let _ = Box::from_raw(p);\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n         } else {\n             Ok(Thread { tid: tid })"}, {"sha": "1cad474e33e63ec0c50f4a5b0f6895d3a1a775fa", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=5382347064ac47a2a5ac56b57cec0d91b9b40edc", "patch": "@@ -41,7 +41,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let mut p = mem::ManuallyDrop::new(box p);\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -63,18 +63,13 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(\n-            &mut native,\n-            &attr,\n-            thread_start,\n-            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n-        );\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to manually drop it.\n-            mem::ManuallyDrop::drop(&mut p);\n+            // safe to reconstruct the box so that it gets deallocated.\n+            let _ = Box::from_raw(p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n             Ok(Thread { id: native })"}, {"sha": "3c9557db94ade3f0a74a2fceedd26cc7c1a6db7e", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=5382347064ac47a2a5ac56b57cec0d91b9b40edc", "patch": "@@ -29,7 +29,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let mut p = mem::ManuallyDrop::new(box p);\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -51,18 +51,13 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(\n-            &mut native,\n-            &attr,\n-            thread_start,\n-            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n-        );\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to manually drop it.\n-            mem::ManuallyDrop::drop(&mut p);\n+            // safe to reconstruct the box so that it gets deallocated.\n+            let _ = Box::from_raw(p);\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n             Ok(Thread { id: native })"}, {"sha": "e39c1c0a132616e3f8fc9aa80d8e74ea8be24964", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5382347064ac47a2a5ac56b57cec0d91b9b40edc/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=5382347064ac47a2a5ac56b57cec0d91b9b40edc", "patch": "@@ -1,6 +1,5 @@\n use crate::ffi::CStr;\n use crate::io;\n-use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n@@ -20,7 +19,7 @@ pub struct Thread {\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let mut p = mem::ManuallyDrop::new(box p);\n+        let p = Box::into_raw(box p);\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -34,15 +33,15 @@ impl Thread {\n             ptr::null_mut(),\n             stack_size,\n             thread_start,\n-            &mut *p as &mut Box<dyn FnOnce()> as *mut _ as *mut _,\n+            p as *mut _,\n             c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n             ptr::null_mut(),\n         );\n \n         return if ret as usize == 0 {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to manually drop it.\n-            mem::ManuallyDrop::drop(&mut p);\n+            // safe to reconstruct the box so that it gets deallocated.\n+            let _ = Box::from_raw(p);\n             Err(io::Error::last_os_error())\n         } else {\n             Ok(Thread { handle: Handle::new(ret) })"}]}