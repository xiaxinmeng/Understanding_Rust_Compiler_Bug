{"sha": "590d201e0b563b33804a78059e243f51f5060190", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MGQyMDFlMGI1NjNiMzM4MDRhNzgwNTllMjQzZjUxZjUwNjAxOTA=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-02T16:27:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-02T16:27:39Z"}, "message": "Rollup merge of #71777 - petrochenkov:crtype, r=Mark-Simulacrum\n\ncleanup: `config::CrateType` -> `CrateType`", "tree": {"sha": "477c66fee096f2880cbdae4fbc612aed544f2a2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/477c66fee096f2880cbdae4fbc612aed544f2a2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/590d201e0b563b33804a78059e243f51f5060190", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJerZ99CRBK7hj4Ov3rIwAAdHIIAHOWjmU34KfKYAmqnMcFQb5K\n9HwPg1wiZPO5747Aat//k4yGA/UdsKOrHUfyW73BaWeFTvLKqNhz3fMnHDRFsC4S\nkPur27XD/sFs3Lh/Hbqth2SKdegHyioQH5iS//iwI6LCZ6x9wC94lJp68OVOqN9K\nxSHDJYBrkR3gpU/tAoaiYdt9APv2++gbeALLDHC7QPHwVW1vHYx37NpyF4qdbvOO\nv7xgfBaOFqRNmoLaTDT6QAdFTVNPmEil5wUKX3eknTH49D+skmiLMoCMIgyq53Lo\ndIi9yFjUKVtKLO3g3a+/gFYr9gKHZZnr+I1osM86xj5WA5MftqvUzXoPFcUM7Kg=\n=qZFP\n-----END PGP SIGNATURE-----\n", "payload": "tree 477c66fee096f2880cbdae4fbc612aed544f2a2c\nparent 78dc7e15c98afa9acbba9be5a36e167c711044e2\nparent ff86a4582021fe0f5be19b54c64693ec8ff1e82f\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588436859 +0200\ncommitter GitHub <noreply@github.com> 1588436859 +0200\n\nRollup merge of #71777 - petrochenkov:crtype, r=Mark-Simulacrum\n\ncleanup: `config::CrateType` -> `CrateType`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/590d201e0b563b33804a78059e243f51f5060190", "html_url": "https://github.com/rust-lang/rust/commit/590d201e0b563b33804a78059e243f51f5060190", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/590d201e0b563b33804a78059e243f51f5060190/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78dc7e15c98afa9acbba9be5a36e167c711044e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/78dc7e15c98afa9acbba9be5a36e167c711044e2", "html_url": "https://github.com/rust-lang/rust/commit/78dc7e15c98afa9acbba9be5a36e167c711044e2"}, {"sha": "ff86a4582021fe0f5be19b54c64693ec8ff1e82f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff86a4582021fe0f5be19b54c64693ec8ff1e82f", "html_url": "https://github.com/rust-lang/rust/commit/ff86a4582021fe0f5be19b54c64693ec8ff1e82f"}], "stats": {"total": 302, "additions": 142, "deletions": 160}, "files": [{"sha": "d3e3441b087c21e61ecba2d044f802e4ef7d36eb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::bug;\n use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{self, Lto};\n+use rustc_session::config::{self, CrateType, Lto};\n \n use std::ffi::{CStr, CString};\n use std::fs::File;\n@@ -33,13 +33,10 @@ use std::sync::Arc;\n /// compilation session.\n pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-imports.bin\";\n \n-pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n+pub fn crate_type_allows_lto(crate_type: CrateType) -> bool {\n     match crate_type {\n-        config::CrateType::Executable\n-        | config::CrateType::Staticlib\n-        | config::CrateType::Cdylib => true,\n-\n-        config::CrateType::Dylib | config::CrateType::Rlib | config::CrateType::ProcMacro => false,\n+        CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => true,\n+        CrateType::Dylib | CrateType::Rlib | CrateType::ProcMacro => false,\n     }\n }\n "}, {"sha": "b33aba0ef8f4d0cf957304d9e21b89aa8687d5f6", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutError, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n-use rustc_session::config::{self, CFGuard, DebugInfo};\n+use rustc_session::config::{CFGuard, CrateType, DebugInfo};\n use rustc_session::Session;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::Symbol;\n@@ -101,9 +101,10 @@ fn to_llvm_tls_model(tls_model: TlsModel) -> llvm::ThreadLocalMode {\n /// If the list of crate types is not yet known we conservatively return `false`.\n pub fn all_outputs_are_pic_executables(sess: &Session) -> bool {\n     sess.relocation_model() == RelocModel::Pic\n-        && sess.crate_types.try_get().map_or(false, |crate_types| {\n-            crate_types.iter().all(|ty| *ty == config::CrateType::Executable)\n-        })\n+        && sess\n+            .crate_types\n+            .try_get()\n+            .map_or(false, |crate_types| crate_types.iter().all(|ty| *ty == CrateType::Executable))\n }\n \n fn strip_function_ptr_alignment(data_layout: String) -> String {"}, {"sha": "7a0e1e2c63887f63e901bb423f099e473d5a28a6", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -3,9 +3,8 @@ use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLibrary, NativeLibraryKind};\n use rustc_middle::middle::dependency_format::Linkage;\n-use rustc_session::config::{\n-    self, CFGuard, DebugInfo, OutputFilenames, OutputType, PrintRequest, Sanitizer,\n-};\n+use rustc_session::config::{self, CFGuard, CrateType, DebugInfo};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, Sanitizer};\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n /// For all the linkers we support, and information they might\n@@ -55,7 +54,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen())\n             && !output_metadata\n-            && crate_type == config::CrateType::Executable\n+            && crate_type == CrateType::Executable\n         {\n             continue;\n         }\n@@ -82,7 +81,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         if outputs.outputs.should_codegen() {\n             let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n             match crate_type {\n-                config::CrateType::Rlib => {\n+                CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n                     link_rlib::<B>(\n                         sess,\n@@ -93,7 +92,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                     )\n                     .build();\n                 }\n-                config::CrateType::Staticlib => {\n+                CrateType::Staticlib => {\n                     link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n                 }\n                 _ => {\n@@ -236,10 +235,10 @@ pub fn each_linked_rlib(\n     let mut fmts = None;\n     for (ty, list) in info.dependency_formats.iter() {\n         match ty {\n-            config::CrateType::Executable\n-            | config::CrateType::Staticlib\n-            | config::CrateType::Cdylib\n-            | config::CrateType::ProcMacro => {\n+            CrateType::Executable\n+            | CrateType::Staticlib\n+            | CrateType::Cdylib\n+            | CrateType::ProcMacro => {\n                 fmts = Some(list);\n                 break;\n             }\n@@ -461,7 +460,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n // links to all upstream files as well.\n fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n@@ -664,13 +663,13 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n     }\n }\n \n-fn link_sanitizer_runtime(sess: &Session, crate_type: config::CrateType, linker: &mut dyn Linker) {\n+fn link_sanitizer_runtime(sess: &Session, crate_type: CrateType, linker: &mut dyn Linker) {\n     let sanitizer = match &sess.opts.debugging_opts.sanitizer {\n         Some(s) => s,\n         None => return,\n     };\n \n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         return;\n     }\n \n@@ -826,7 +825,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n         .crate_types\n         .borrow()\n         .iter()\n-        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n+        .any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n     if !output_linked {\n         return false;\n     }\n@@ -1132,8 +1131,8 @@ fn exec_linker(\n }\n \n /// Add begin object files defined by the target spec.\n-fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n-    let pre_link_objects = if crate_type == config::CrateType::Executable {\n+fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n+    let pre_link_objects = if crate_type == CrateType::Executable {\n         &sess.target.target.options.pre_link_objects_exe\n     } else {\n         &sess.target.target.options.pre_link_objects_dll\n@@ -1142,15 +1141,15 @@ fn add_pre_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n \n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n         for obj in &sess.target.target.options.pre_link_objects_exe_crt {\n             cmd.add_object(&get_object_file_path(sess, obj));\n         }\n     }\n }\n \n /// Add end object files defined by the target spec.\n-fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: config::CrateType) {\n+fn add_post_link_objects(cmd: &mut dyn Linker, sess: &Session, crate_type: CrateType) {\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.add_object(&get_object_file_path(sess, obj));\n     }\n@@ -1167,7 +1166,7 @@ fn add_pre_link_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n ) {\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n@@ -1197,13 +1196,13 @@ fn add_late_link_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n     if let Some(args) = sess.target.target.options.late_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n-    let any_dynamic_crate = crate_type == config::CrateType::Dylib\n+    let any_dynamic_crate = crate_type == CrateType::Dylib\n         || codegen_results.crate_info.dependency_formats.iter().any(|(ty, list)| {\n             *ty == crate_type && list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n@@ -1243,13 +1242,13 @@ fn add_local_crate_allocator_objects(cmd: &mut dyn Linker, codegen_results: &Cod\n /// Add object files containing metadata for the current crate.\n fn add_local_crate_metadata_objects(\n     cmd: &mut dyn Linker,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n     // When linking a dynamic library, we put the metadata into a section of the\n     // executable. This metadata is in a separate object file from the main\n     // object file, so we link that in here.\n-    if crate_type == config::CrateType::Dylib || crate_type == config::CrateType::ProcMacro {\n+    if crate_type == CrateType::Dylib || crate_type == CrateType::ProcMacro {\n         if let Some(obj) = codegen_results.metadata_module.as_ref().and_then(|m| m.object.as_ref())\n         {\n             cmd.add_object(obj);\n@@ -1263,7 +1262,7 @@ fn add_local_crate_metadata_objects(\n fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n     tmpdir: &Path,\n ) {\n@@ -1326,10 +1325,10 @@ fn add_position_independent_executable_args(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     flavor: LinkerFlavor,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     codegen_results: &CodegenResults,\n ) {\n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         return;\n     }\n \n@@ -1407,7 +1406,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     path: &Path,\n     flavor: LinkerFlavor,\n     sess: &'a Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     tmpdir: &Path,\n     out_filename: &Path,\n     codegen_results: &CodegenResults,\n@@ -1463,7 +1462,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     cmd.output_filename(out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n-    if crate_type == config::CrateType::Executable && sess.target.target.options.is_like_windows {\n+    if crate_type == CrateType::Executable && sess.target.target.options.is_like_windows {\n         if let Some(ref s) = codegen_results.windows_subsystem {\n             cmd.subsystem(s);\n         }\n@@ -1486,7 +1485,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     // Try to strip as much out of the generated object by removing unused\n     // sections if possible. See more comments in linker.rs\n     if !sess.opts.cg.link_dead_code {\n-        let keep_metadata = crate_type == config::CrateType::Dylib;\n+        let keep_metadata = crate_type == CrateType::Dylib;\n         cmd.gc_sections(keep_metadata);\n     }\n \n@@ -1522,10 +1521,10 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n     // Tell the linker what we're doing.\n-    if crate_type != config::CrateType::Executable {\n+    if crate_type != CrateType::Executable {\n         cmd.build_dylib(out_filename);\n     }\n-    if crate_type == config::CrateType::Executable && sess.crt_static(Some(crate_type)) {\n+    if crate_type == CrateType::Executable && sess.crt_static(Some(crate_type)) {\n         cmd.build_static_executable();\n     }\n \n@@ -1619,7 +1618,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     tmpdir: &Path,\n ) {\n     // All of the heavy lifting has previously been accomplished by the\n@@ -1780,7 +1779,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         sess: &'a Session,\n         codegen_results: &CodegenResults,\n         tmpdir: &Path,\n-        crate_type: config::CrateType,\n+        crate_type: CrateType,\n         cnum: CrateNum,\n     ) {\n         let src = &codegen_results.crate_info.used_crate_source[&cnum];\n@@ -1796,7 +1795,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n \n         if (!are_upstream_rust_objects_already_included(sess)\n             || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && crate_type != config::CrateType::Dylib\n+            && crate_type != CrateType::Dylib\n             && !skip_native\n         {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1857,7 +1856,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n             // Note, though, that we don't want to include the whole of a\n             // compiler-builtins crate (e.g., compiler-rt) because it'll get\n             // repeatedly linked anyway.\n-            if crate_type == config::CrateType::Dylib\n+            if crate_type == CrateType::Dylib\n                 && codegen_results.crate_info.compiler_builtins != Some(cnum)\n             {\n                 cmd.link_whole_rlib(&fix_windows_verbatim_for_gcc(&dst));\n@@ -1905,7 +1904,7 @@ fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n     codegen_results: &CodegenResults,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n ) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,"}, {"sha": "c0272e1cd2d6ba205f616904ce306e4f57c40443", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -15,23 +15,22 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n-use rustc_session::config::{self, Sanitizer};\n+use rustc_session::config::{CrateType, Sanitizer};\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n-fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n+fn crate_export_threshold(crate_type: CrateType) -> SymbolExportLevel {\n     match crate_type {\n-        config::CrateType::Executable\n-        | config::CrateType::Staticlib\n-        | config::CrateType::ProcMacro\n-        | config::CrateType::Cdylib => SymbolExportLevel::C,\n-        config::CrateType::Rlib | config::CrateType::Dylib => SymbolExportLevel::Rust,\n+        CrateType::Executable | CrateType::Staticlib | CrateType::ProcMacro | CrateType::Cdylib => {\n+            SymbolExportLevel::C\n+        }\n+        CrateType::Rlib | CrateType::Dylib => SymbolExportLevel::Rust,\n     }\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExportLevel {\n+pub fn crates_export_threshold(crate_types: &[CrateType]) -> SymbolExportLevel {\n     if crate_types\n         .iter()\n         .any(|&crate_type| crate_export_threshold(crate_type) == SymbolExportLevel::Rust)\n@@ -213,7 +212,7 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.crate_types.borrow().contains(&config::CrateType::Dylib) {\n+    if tcx.sess.crate_types.borrow().contains(&CrateType::Dylib) {\n         let symbol_name = metadata_symbol_name(tcx);\n         let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n "}, {"sha": "c53fc5551fdfb5f20d6f93e2b69ec5ea773b6b84", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -28,9 +28,8 @@ use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cgu_reuse_tracker::CguReuseTracker;\n-use rustc_session::config::{\n-    self, Lto, OutputFilenames, OutputType, Passes, Sanitizer, SwitchWithOptPath,\n-};\n+use rustc_session::config::{self, CrateType, Lto, OutputFilenames, OutputType};\n+use rustc_session::config::{Passes, Sanitizer, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::source_map::SourceMap;\n@@ -288,7 +287,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub fewer_names: bool,\n     pub exported_symbols: Option<Arc<ExportedSymbols>>,\n     pub opts: Arc<config::Options>,\n-    pub crate_types: Vec<config::CrateType>,\n+    pub crate_types: Vec<CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     pub output_filenames: Arc<OutputFilenames>,\n     pub regular_module_config: Arc<ModuleConfig>,\n@@ -375,7 +374,7 @@ pub struct CompiledModules {\n \n fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.cg.embed_bitcode\n-        && sess.crate_types.borrow().contains(&config::CrateType::Rlib)\n+        && sess.crate_types.borrow().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n@@ -760,7 +759,7 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     // require LTO so the request for LTO is always unconditionally\n     // passed down to the backend, but we don't actually want to do\n     // anything about it yet until we've got a final product.\n-    let is_rlib = cgcx.crate_types.len() == 1 && cgcx.crate_types[0] == config::CrateType::Rlib;\n+    let is_rlib = cgcx.crate_types.len() == 1 && cgcx.crate_types[0] == CrateType::Rlib;\n \n     // Metadata modules never participate in LTO regardless of the lto\n     // settings.\n@@ -1813,7 +1812,7 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     );\n \n     tcx.sess.target.target.options.is_like_msvc &&\n-        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateType::Rlib) &&\n+        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n     // dynamic linking when linker plugin LTO is enabled."}, {"sha": "801c8e9329b24571a98746c3037ae92af449029f", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -27,9 +27,7 @@ use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n use rustc_resolve::{Resolver, ResolverArenas};\n-use rustc_session::config::{\n-    self, CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode,\n-};\n+use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType, PpMode, PpSourceMode};\n use rustc_session::lint;\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n@@ -361,7 +359,7 @@ fn configure_and_expand_inner<'a>(\n     });\n \n     let crate_types = sess.crate_types.borrow();\n-    let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n+    let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n \n     // For backwards compatibility, we don't try to run proc macro injection\n     // if rustdoc is run on a proc macro crate without '--crate-type proc-macro' being"}, {"sha": "c5a4d28d151b3b3173a3ed7b52556dea077a6d5d", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -16,11 +16,12 @@ use rustc_metadata::dynamic_lib::DynamicLibrary;\n use rustc_middle::ty;\n use rustc_resolve::{self, Resolver};\n use rustc_session as session;\n+use rustc_session::config::{self, CrateType};\n use rustc_session::config::{ErrorOutputType, Input, OutputFilenames};\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::CrateDisambiguator;\n-use rustc_session::{config, early_error, filesearch, output, DiagnosticOutput, Session};\n+use rustc_session::{early_error, filesearch, output, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, SourceMap};\n use rustc_span::symbol::{sym, Symbol};\n@@ -409,7 +410,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n \n     // Also incorporate crate type, so that we don't get symbol conflicts when\n     // linking against a library of the same name, if this is an executable.\n-    let is_exe = session.crate_types.borrow().contains(&config::CrateType::Executable);\n+    let is_exe = session.crate_types.borrow().contains(&CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n@@ -457,23 +458,23 @@ pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut\n     }\n }\n \n-const CRATE_TYPES: &[(Symbol, config::CrateType)] = &[\n-    (sym::rlib, config::CrateType::Rlib),\n-    (sym::dylib, config::CrateType::Dylib),\n-    (sym::cdylib, config::CrateType::Cdylib),\n+const CRATE_TYPES: &[(Symbol, CrateType)] = &[\n+    (sym::rlib, CrateType::Rlib),\n+    (sym::dylib, CrateType::Dylib),\n+    (sym::cdylib, CrateType::Cdylib),\n     (sym::lib, config::default_lib_output()),\n-    (sym::staticlib, config::CrateType::Staticlib),\n-    (sym::proc_dash_macro, config::CrateType::ProcMacro),\n-    (sym::bin, config::CrateType::Executable),\n+    (sym::staticlib, CrateType::Staticlib),\n+    (sym::proc_dash_macro, CrateType::ProcMacro),\n+    (sym::bin, CrateType::Executable),\n ];\n \n-fn categorize_crate_type(s: Symbol) -> Option<config::CrateType> {\n+fn categorize_crate_type(s: Symbol) -> Option<CrateType> {\n     Some(CRATE_TYPES.iter().find(|(key, _)| *key == s)?.1)\n }\n \n-pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n+pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<CrateType> {\n     // Unconditionally collect crate types from attributes to make them used\n-    let attr_types: Vec<config::CrateType> = attrs\n+    let attr_types: Vec<CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n             if a.check_name(sym::crate_type) {\n@@ -490,7 +491,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return vec![config::CrateType::Executable];\n+        return vec![CrateType::Executable];\n     }\n \n     // Only check command line flags if present. If no types are specified by"}, {"sha": "a9e7a9f35dc365b9277bc57810c5391378fffc7e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::middle::cstore::{\n     CrateSource, ExternCrate, ExternCrateSource, MetadataLoaderDyn,\n };\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::{self, CrateType};\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{CrateDisambiguator, Session};\n@@ -615,8 +615,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n-        let any_non_rlib =\n-            self.sess.crate_types.borrow().iter().any(|ct| *ct != config::CrateType::Rlib);\n+        let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| *ct != CrateType::Rlib);\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n             return;\n@@ -736,7 +735,7 @@ impl<'a> CrateLoader<'a> {\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n         let all_rlib = self.sess.crate_types.borrow().iter().all(|ct| match *ct {\n-            config::CrateType::Rlib => true,\n+            CrateType::Rlib => true,\n             _ => false,\n         });\n         if all_rlib {"}, {"sha": "0876cd1e638357f6fdd592bcc612fa7cd69de12b", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -59,7 +59,7 @@ use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, Requ\n use rustc_middle::middle::cstore::{self, DepKind};\n use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_target::spec::PanicStrategy;\n \n crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n@@ -75,7 +75,7 @@ crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n         .collect::<Vec<_>>()\n }\n \n-fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n+fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n     let sess = &tcx.sess;\n \n     if !sess.opts.output_types.should_codegen() {\n@@ -90,29 +90,25 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n         // Treat cdylibs similarly. If `-C prefer-dynamic` is set, the caller may\n         // be code-size conscious, but without it, it makes sense to statically\n         // link a cdylib.\n-        config::CrateType::Dylib | config::CrateType::Cdylib if !sess.opts.cg.prefer_dynamic => {\n-            Linkage::Static\n-        }\n-        config::CrateType::Dylib | config::CrateType::Cdylib => Linkage::Dynamic,\n+        CrateType::Dylib | CrateType::Cdylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        CrateType::Dylib | CrateType::Cdylib => Linkage::Dynamic,\n \n         // If the global prefer_dynamic switch is turned off, or the final\n         // executable will be statically linked, prefer static crate linkage.\n-        config::CrateType::Executable\n-            if !sess.opts.cg.prefer_dynamic || sess.crt_static(Some(ty)) =>\n-        {\n+        CrateType::Executable if !sess.opts.cg.prefer_dynamic || sess.crt_static(Some(ty)) => {\n             Linkage::Static\n         }\n-        config::CrateType::Executable => Linkage::Dynamic,\n+        CrateType::Executable => Linkage::Dynamic,\n \n         // proc-macro crates are mostly cdylibs, but we also need metadata.\n-        config::CrateType::ProcMacro => Linkage::Static,\n+        CrateType::ProcMacro => Linkage::Static,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        config::CrateType::Rlib => Linkage::NotLinked,\n+        CrateType::Rlib => Linkage::NotLinked,\n \n         // staticlibs must have all static dependencies.\n-        config::CrateType::Staticlib => Linkage::Static,\n+        CrateType::Staticlib => Linkage::Static,\n     };\n \n     if preferred_linkage == Linkage::NotLinked {\n@@ -129,8 +125,8 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n \n         // Staticlibs and static executables must have all static dependencies.\n         // If any are not found, generate some nice pretty errors.\n-        if ty == config::CrateType::Staticlib\n-            || (ty == config::CrateType::Executable\n+        if ty == CrateType::Staticlib\n+            || (ty == CrateType::Executable\n                 && sess.crt_static(Some(ty))\n                 && !sess.target.target.options.crt_static_allows_dylibs)\n         {"}, {"sha": "f78f3c5d8d40f45fd44782f15964195dafac0163", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -220,9 +220,10 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_middle::middle::cstore::{CrateSource, MetadataLoader};\n+use rustc_session::config::{self, CrateType};\n use rustc_session::filesearch::{FileDoesntMatch, FileMatches, FileSearch};\n use rustc_session::search_paths::PathKind;\n-use rustc_session::{config, CrateDisambiguator, Session};\n+use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::{Target, TargetTriple};\n@@ -669,7 +670,7 @@ impl<'a> CrateLocator<'a> {\n \n         // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n         // legal and produces both inside this type.\n-        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == config::CrateType::Rlib);\n+        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == CrateType::Rlib);\n         let needs_object_code = self.sess.opts.output_types.should_codegen();\n         // If we're producing an rlib, then we don't need object code.\n         // Or, if we're not producing object code, then we don't need it either"}, {"sha": "4ac2092bb069aad8febb0ccb81e2c27335d669a7", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::traits::specialization_graph;\n use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n-use rustc_session::config::{self, CrateType};\n+use rustc_session::config::CrateType;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n@@ -1499,7 +1499,7 @@ impl EncodeContext<'tcx> {\n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n         let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n         for (ty, arr) in formats.iter() {\n-            if *ty != config::CrateType::Dylib {\n+            if *ty != CrateType::Dylib {\n                 continue;\n             }\n             return self.lazy(arr.iter().map(|slot| match *slot {"}, {"sha": "16ce315368a05d139330346b3b894ee8529d07b9", "filename": "src/librustc_middle/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -4,7 +4,7 @@\n //! For all the gory details, see the provider of the `dependency_formats`\n //! query.\n \n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -17,7 +17,7 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = Vec<(config::CrateType, DependencyList)>;\n+pub type Dependencies = Vec<(CrateType, DependencyList)>;\n \n #[derive(Copy, Clone, PartialEq, Debug, HashStable, RustcEncodable, RustcDecodable)]\n pub enum Linkage {"}, {"sha": "e43eb01ad96f7edae3fe096a87831fb56985830b", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -54,8 +54,7 @@ use rustc_hir::{HirId, Node, TraitCandidate};\n use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n-use rustc_session::config::CrateType;\n-use rustc_session::config::{BorrowckMode, OutputFilenames};\n+use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;"}, {"sha": "d2f1d11256bf21f35a145b947188e91e2eafd444", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -7,8 +7,8 @@ use rustc_hir::{HirId, ImplItem, Item, ItemKind, TraitItem};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::EntryFnType;\n-use rustc_session::{config, Session};\n+use rustc_session::config::{CrateType, EntryFnType};\n+use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -51,8 +51,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let any_exe =\n-        tcx.sess.crate_types.borrow().iter().any(|ty| *ty == config::CrateType::Executable);\n+    let any_exe = tcx.sess.crate_types.borrow().iter().any(|ty| *ty == CrateType::Executable);\n     if !any_exe {\n         // No need to find a main function.\n         return None;"}, {"sha": "7c169d6813282c014ebbfe69c207e7550596c2a0", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs}\n use rustc_middle::middle::privacy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_target::spec::abi::Abi;\n \n // Returns true if the given item must be inlined because it may be\n@@ -375,11 +375,10 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n-        *ty == config::CrateType::Rlib\n-            || *ty == config::CrateType::Dylib\n-            || *ty == config::CrateType::ProcMacro\n-    });\n+    let any_library =\n+        tcx.sess.crate_types.borrow().iter().any(|ty| {\n+            *ty == CrateType::Rlib || *ty == CrateType::Dylib || *ty == CrateType::ProcMacro\n+        });\n     let mut reachable_context = ReachableContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),"}, {"sha": "8a581626862a2a94b100ddd1dd52bd032e9e8d61", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::lang_items;\n use rustc_hir::weak_lang_items::WEAK_ITEMS_REFS;\n use rustc_middle::middle::lang_items::whitelisted;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config;\n+use rustc_session::config::CrateType;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n@@ -38,12 +38,12 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n     let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n-        config::CrateType::Dylib\n-        | config::CrateType::ProcMacro\n-        | config::CrateType::Cdylib\n-        | config::CrateType::Executable\n-        | config::CrateType::Staticlib => true,\n-        config::CrateType::Rlib => false,\n+        CrateType::Dylib\n+        | CrateType::ProcMacro\n+        | CrateType::Cdylib\n+        | CrateType::Executable\n+        | CrateType::Staticlib => true,\n+        CrateType::Rlib => false,\n     });\n     if !needs_check {\n         return;"}, {"sha": "52216188397d7eb5d5a07c530bf090d9c67d893a", "filename": "src/librustc_session/output.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_session%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_session%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foutput.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -1,5 +1,5 @@\n //! Related to out filenames of compilation (e.g. save analysis, binaries).\n-use crate::config::{self, Input, OutputFilenames, OutputType};\n+use crate::config::{CrateType, Input, OutputFilenames, OutputType};\n use crate::Session;\n use rustc_ast::{ast, attr};\n use rustc_span::symbol::sym;\n@@ -8,7 +8,7 @@ use std::path::{Path, PathBuf};\n \n pub fn out_filename(\n     sess: &Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     outputs: &OutputFilenames,\n     crate_name: &str,\n ) -> PathBuf {\n@@ -146,27 +146,27 @@ pub fn filename_for_metadata(\n \n pub fn filename_for_input(\n     sess: &Session,\n-    crate_type: config::CrateType,\n+    crate_type: CrateType,\n     crate_name: &str,\n     outputs: &OutputFilenames,\n ) -> PathBuf {\n     let libname = format!(\"{}{}\", crate_name, sess.opts.cg.extra_filename);\n \n     match crate_type {\n-        config::CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n-        config::CrateType::Cdylib | config::CrateType::ProcMacro | config::CrateType::Dylib => {\n+        CrateType::Rlib => outputs.out_directory.join(&format!(\"lib{}.rlib\", libname)),\n+        CrateType::Cdylib | CrateType::ProcMacro | CrateType::Dylib => {\n             let (prefix, suffix) =\n                 (&sess.target.target.options.dll_prefix, &sess.target.target.options.dll_suffix);\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        config::CrateType::Staticlib => {\n+        CrateType::Staticlib => {\n             let (prefix, suffix) = (\n                 &sess.target.target.options.staticlib_prefix,\n                 &sess.target.target.options.staticlib_suffix,\n             );\n             outputs.out_directory.join(&format!(\"{}{}{}\", prefix, libname, suffix))\n         }\n-        config::CrateType::Executable => {\n+        CrateType::Executable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n             let out_filename = outputs.path(OutputType::Exe);\n             if suffix.is_empty() { out_filename } else { out_filename.with_extension(&suffix[1..]) }\n@@ -183,18 +183,18 @@ pub fn filename_for_input(\n /// way to run iOS binaries anyway without jailbreaking and\n /// interaction with Rust code through static library is the only\n /// option for now\n-pub fn default_output_for_target(sess: &Session) -> config::CrateType {\n+pub fn default_output_for_target(sess: &Session) -> CrateType {\n     if !sess.target.target.options.executables {\n-        config::CrateType::Staticlib\n+        CrateType::Staticlib\n     } else {\n-        config::CrateType::Executable\n+        CrateType::Executable\n     }\n }\n \n /// Checks if target supports crate_type as output\n-pub fn invalid_output_for_target(sess: &Session, crate_type: config::CrateType) -> bool {\n+pub fn invalid_output_for_target(sess: &Session, crate_type: CrateType) -> bool {\n     match crate_type {\n-        config::CrateType::Cdylib | config::CrateType::Dylib | config::CrateType::ProcMacro => {\n+        CrateType::Cdylib | CrateType::Dylib | CrateType::ProcMacro => {\n             if !sess.target.target.options.dynamic_linking {\n                 return true;\n             }\n@@ -208,12 +208,12 @@ pub fn invalid_output_for_target(sess: &Session, crate_type: config::CrateType)\n     }\n     if sess.target.target.options.only_cdylib {\n         match crate_type {\n-            config::CrateType::ProcMacro | config::CrateType::Dylib => return true,\n+            CrateType::ProcMacro | CrateType::Dylib => return true,\n             _ => {}\n         }\n     }\n     if !sess.target.target.options.executables {\n-        if crate_type == config::CrateType::Executable {\n+        if crate_type == CrateType::Executable {\n             return true;\n         }\n     }"}, {"sha": "69e1b46de4df75adfdbe791c4ac93f2b5f502534", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -1,7 +1,7 @@\n use crate::cgu_reuse_tracker::CguReuseTracker;\n use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n-use crate::config::{self, OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n+use crate::config::{self, CrateType, OutputType, PrintRequest, Sanitizer, SwitchWithOptPath};\n use crate::filesearch;\n use crate::lint;\n use crate::parse::ParseSess;\n@@ -73,7 +73,7 @@ pub struct Session {\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n-    pub crate_types: Once<Vec<config::CrateType>>,\n+    pub crate_types: Once<Vec<CrateType>>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n@@ -552,7 +552,7 @@ impl Session {\n     }\n \n     /// Check whether this compile session and crate type use static crt.\n-    pub fn crt_static(&self, crate_type: Option<config::CrateType>) -> bool {\n+    pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n         // If the target does not opt in to crt-static support, use its default.\n         if self.target.target.options.crt_static_respected {\n             self.crt_static_feature(crate_type)\n@@ -562,15 +562,15 @@ impl Session {\n     }\n \n     /// Check whether this compile session and crate type use `crt-static` feature.\n-    pub fn crt_static_feature(&self, crate_type: Option<config::CrateType>) -> bool {\n+    pub fn crt_static_feature(&self, crate_type: Option<CrateType>) -> bool {\n         let requested_features = self.opts.cg.target_feature.split(',');\n         let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n         let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n \n         if found_positive || found_negative {\n             found_positive\n-        } else if crate_type == Some(config::CrateType::ProcMacro)\n-            || crate_type == None && self.opts.crate_types.contains(&config::CrateType::ProcMacro)\n+        } else if crate_type == Some(CrateType::ProcMacro)\n+            || crate_type == None && self.opts.crate_types.contains(&CrateType::ProcMacro)\n         {\n             // FIXME: When crate_type is not available,\n             // we use compiler options to determine the crate_type."}, {"sha": "03d1dc21816c320c5e6ebb1b0723a3248d2e427b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -1,6 +1,7 @@\n use rustc_ast::ast::CRATE_NODE_ID;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n@@ -13,15 +14,14 @@ use rustc_middle::middle::cstore::CrateStore;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_resolve as resolve;\n-use rustc_session::config::ErrorOutputType;\n+use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::lint;\n use rustc_session::DiagnosticOutput;\n-use rustc_session::{config, Session};\n+use rustc_session::Session;\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n \n-use rustc_data_structures::sync::{self, Lrc};\n use std::cell::RefCell;\n use std::mem;\n use std::rc::Rc;\n@@ -30,7 +30,6 @@ use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::html::render::RenderInfo;\n-\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n@@ -301,11 +300,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         })\n         .collect();\n \n-    let crate_types = if proc_macro_crate {\n-        vec![config::CrateType::ProcMacro]\n-    } else {\n-        vec![config::CrateType::Rlib]\n-    };\n+    let crate_types =\n+        if proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };\n     // plays with error output here!\n     let sessopts = config::Options {\n         maybe_sysroot,"}, {"sha": "5028bb46b006695dfd051cd0c4bd5b5c3182238d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/590d201e0b563b33804a78059e243f51f5060190/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=590d201e0b563b33804a78059e243f51f5060190", "patch": "@@ -9,20 +9,22 @@ use rustc_hir::{HirId, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::{self, config, lint, DiagnosticOutput, Session};\n+use rustc_session::config::{self, CrateType};\n+use rustc_session::{lint, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, FileName, Pos, Span, DUMMY_SP};\n use rustc_target::spec::TargetTriple;\n+use tempfile::Builder as TempFileBuilder;\n+\n use std::collections::HashMap;\n use std::env;\n use std::io::{self, Write};\n use std::panic;\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use tempfile::Builder as TempFileBuilder;\n \n use crate::clean::Attributes;\n use crate::config::Options;\n@@ -82,11 +84,8 @@ pub fn run(options: Options) -> i32 {\n         })\n         .collect();\n \n-    let crate_types = if options.proc_macro_crate {\n-        vec![config::CrateType::ProcMacro]\n-    } else {\n-        vec![config::CrateType::Rlib]\n-    };\n+    let crate_types =\n+        if options.proc_macro_crate { vec![CrateType::ProcMacro] } else { vec![CrateType::Rlib] };\n \n     let sessopts = config::Options {\n         maybe_sysroot: options.maybe_sysroot.clone(),"}]}