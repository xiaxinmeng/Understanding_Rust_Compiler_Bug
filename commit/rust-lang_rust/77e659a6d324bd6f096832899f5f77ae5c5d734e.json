{"sha": "77e659a6d324bd6f096832899f5f77ae5c5d734e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZTY1OWE2ZDMyNGJkNmYwOTY4MzI4OTlmNWY3N2FlNWM1ZDczNGU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-12-17T01:11:59Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-12-17T01:11:59Z"}, "message": "Remove some more things that were only needed for inlined-HIR DefIds", "tree": {"sha": "f80dabf17695950546a9dc8870aa3358bc9afe40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80dabf17695950546a9dc8870aa3358bc9afe40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77e659a6d324bd6f096832899f5f77ae5c5d734e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77e659a6d324bd6f096832899f5f77ae5c5d734e", "html_url": "https://github.com/rust-lang/rust/commit/77e659a6d324bd6f096832899f5f77ae5c5d734e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77e659a6d324bd6f096832899f5f77ae5c5d734e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45571f34aaaa904ef58484aad41233f815ccace9", "url": "https://api.github.com/repos/rust-lang/rust/commits/45571f34aaaa904ef58484aad41233f815ccace9", "html_url": "https://github.com/rust-lang/rust/commit/45571f34aaaa904ef58484aad41233f815ccace9"}], "stats": {"total": 217, "additions": 2, "deletions": 215}, "files": [{"sha": "d2b94db689bc45c63b3bd1de3049739c45736e6e", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=77e659a6d324bd6f096832899f5f77ae5c5d734e", "patch": "@@ -418,7 +418,7 @@ to see something like:\n \n     Hir(foo) -> Collect(bar)\n     Collect(bar) -> TypeckItemBody(bar)\n-    \n+\n That first edge looks suspicious to you. So you set\n `RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n then observe the backtrace. Voila, bug fixed!\n@@ -440,6 +440,4 @@ To achieve this, the HIR map will detect if the def-id originates in\n an inlined node and add a dependency to a suitable `MetaData` node\n instead. If you are reading a HIR node and are not sure if it may be\n inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n-whether the node is inlined or not and do the right thing.  You can\n-also use `tcx.map.is_inlined_def_id()` and\n-`tcx.map.is_inlined_node_id()` to test.\n+whether the node is inlined or not and do the right thing."}, {"sha": "f6a22e47cf21278051fd3f11fc5ab474cab25303", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=77e659a6d324bd6f096832899f5f77ae5c5d734e", "patch": "@@ -40,7 +40,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);\n@@ -51,7 +50,6 @@ pub fn visit_all_item_likes_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n             let task_id = (self.dep_node_fn)(impl_item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n-            assert!(!self.tcx.map.is_inlined_def_id(impl_item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(impl_item_def_id));\n             self.visitor.visit_impl_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "256aee342a3fc448f83637f02a78d7401df22c3f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=77e659a6d324bd6f096832899f5f77ae5c5d734e", "patch": "@@ -9,23 +9,15 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-\n-use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n \n-use middle::cstore::InlinedItem;\n-\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n-    // If we are walking HIR (c.f., AST), we need to keep a reference to the\n-    // crate.\n-    hir_crate: Option<&'a hir::Crate>,\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n@@ -40,7 +32,6 @@ pub struct MacroInvocationData {\n impl<'a> DefCollector<'a> {\n     pub fn new(definitions: &'a mut Definitions) -> Self {\n         DefCollector {\n-            hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n             visit_macro_invoc: None,\n@@ -51,13 +42,6 @@ impl<'a> DefCollector<'a> {\n         let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n-\n-        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-    }\n-\n-    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n-        self.hir_crate = Some(krate);\n-        ii.visit(self);\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n@@ -95,16 +79,6 @@ impl<'a> DefCollector<'a> {\n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let hir::ExprClosure(..) = expr.node {\n-            return;\n-        }\n-\n-        self.create_def(expr.id, DefPathData::Initializer);\n-    }\n-\n     fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n         if let Some(ref mut visit) = self.visit_macro_invoc {\n             visit(MacroInvocationData {\n@@ -305,169 +279,3 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n     }\n }\n-\n-// We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n-        // note however that we override `visit_body` below\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_body(&mut self, id: hir::ExprId) {\n-        if let Some(krate) = self.hir_crate {\n-            self.visit_expr(krate.expr(id));\n-        }\n-    }\n-\n-    fn visit_item(&mut self, i: &'ast hir::Item) {\n-        debug!(\"visit_item: {:?}\", i);\n-\n-        // Pick the def data. This need not be unique, but the more\n-        // information we encapsulate into\n-        let def_data = match i.node {\n-            hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n-                DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n-            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n-                DefPathData::TypeNs(i.name.as_str()),\n-            hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n-                DefPathData::ValueNs(i.name.as_str()),\n-            hir::ItemUse(..) => DefPathData::Misc,\n-        };\n-        let def = self.create_def(i.id, def_data);\n-\n-        self.with_parent(def, |this| {\n-            match i.node {\n-                hir::ItemEnum(ref enum_definition, _) => {\n-                    for v in &enum_definition.variants {\n-                        let variant_def_index =\n-                            this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.as_str()));\n-\n-                        this.with_parent(variant_def_index, |this| {\n-                            for field in v.node.data.fields() {\n-                                this.create_def(field.id,\n-                                                DefPathData::Field(field.name.as_str()));\n-                            }\n-                            if let Some(ref expr) = v.node.disr_expr {\n-                                this.visit_hir_const_integer(expr);\n-                            }\n-                        });\n-                    }\n-                }\n-                hir::ItemStruct(ref struct_def, _) |\n-                hir::ItemUnion(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n-                    }\n-\n-                    for field in struct_def.fields() {\n-                        this.create_def(field.id, DefPathData::Field(field.name.as_str()));\n-                    }\n-                }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n-        let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.name.as_str()));\n-\n-        self.with_parent(def, |this| {\n-            intravisit::walk_foreign_item(this, foreign_item);\n-        });\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name.as_str()));\n-        }\n-\n-        intravisit::walk_generics(self, generics);\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n-        let def_data = match ti.node {\n-            hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n-                DefPathData::ValueNs(ti.name.as_str()),\n-            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ti.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_trait_item(this, ti);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n-        let def_data = match ii.node {\n-            hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.name.as_str()),\n-            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name.as_str()),\n-        };\n-\n-        let def = self.create_def(ii.id, def_data);\n-        self.with_parent(def, |this| {\n-            if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-                this.create_def(expr.id, DefPathData::Initializer);\n-            }\n-\n-            intravisit::walk_impl_item(this, ii);\n-        });\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n-        let parent_def = self.parent_def;\n-\n-        if let hir::ExprRepeat(_, ref count) = expr.node {\n-            self.visit_hir_const_integer(count);\n-        }\n-\n-        if let hir::ExprClosure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-        self.parent_def = parent_def;\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n-        if let hir::TyArray(_, ref length) = ty.node {\n-            self.visit_hir_const_integer(length);\n-        }\n-        if let hir::TyImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n-        }\n-        intravisit::walk_ty(self, ty);\n-    }\n-\n-    fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n-    }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name.as_str()));\n-    }\n-}"}, {"sha": "4546f6d8c27e6b64674c9fd166d8498de791c3db", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=77e659a6d324bd6f096832899f5f77ae5c5d734e", "patch": "@@ -226,17 +226,9 @@ pub struct Map<'ast> {\n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n-\n-    /// All def-indices that are numerically greater or equal to this value come\n-    /// from inlined items.\n-    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n-    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n-        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n-    }\n-\n     pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n         id >= self.local_node_id_watermark\n     }\n@@ -262,7 +254,6 @@ impl<'ast> Map<'ast> {\n                     EntryItem(_, item) => {\n                         assert_eq!(id, item.id);\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -278,7 +269,6 @@ impl<'ast> Map<'ast> {\n \n                     EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n-                        assert!(!self.is_inlined_def_id(def_id));\n \n                         if let Some(last_id) = last_expr {\n                             // The body of the item may have a separate dep node\n@@ -934,15 +924,13 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = NodeId::new(map.len());\n-    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: definitions,\n         local_node_id_watermark: local_node_id_watermark,\n-        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n "}, {"sha": "799cb6c5e3d8c7d56d334fdea26869126accd844", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77e659a6d324bd6f096832899f5f77ae5c5d734e/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=77e659a6d324bd6f096832899f5f77ae5c5d734e", "patch": "@@ -66,11 +66,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         def_id,\n                         self.tcx.item_path_str(def_id));\n \n-                assert!(!self.tcx.map.is_inlined_def_id(def_id),\n-                        \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n-                        def_id,\n-                        self.tcx.item_path_str(def_id));\n-\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n "}]}