{"sha": "cf9db76454838988620acf6ba7db7bc8654b6f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOWRiNzY0NTQ4Mzg5ODg2MjBhY2Y2YmE3ZGI3YmM4NjU0YjZmNTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-22T22:31:01Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-22T22:44:33Z"}, "message": "hygiene: Require passing transparency explicitly to `apply_mark`", "tree": {"sha": "5d4b542218108abe897a88c32227e3d4dafa6ef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d4b542218108abe897a88c32227e3d4dafa6ef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf9db76454838988620acf6ba7db7bc8654b6f57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9db76454838988620acf6ba7db7bc8654b6f57", "html_url": "https://github.com/rust-lang/rust/commit/cf9db76454838988620acf6ba7db7bc8654b6f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf9db76454838988620acf6ba7db7bc8654b6f57/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0c4d0f8cbb703c90b9dc3cd1b48d2d550508ef8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c4d0f8cbb703c90b9dc3cd1b48d2d550508ef8", "html_url": "https://github.com/rust-lang/rust/commit/b0c4d0f8cbb703c90b9dc3cd1b48d2d550508ef8"}], "stats": {"total": 140, "additions": 66, "deletions": 74}, "files": [{"sha": "c8c0f4ce36e8edbc8122f4bc7c70242bcf2b4b2b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -1388,17 +1388,3 @@ impl<'feat> ExpansionConfig<'feat> {\n         self.features.map_or(false, |features| features.custom_inner_attributes)\n     }\n }\n-\n-// A Marker adds the given mark to the syntax context.\n-#[derive(Debug)]\n-pub struct Marker(pub ExpnId);\n-\n-impl MutVisitor for Marker {\n-    fn visit_span(&mut self, span: &mut Span) {\n-        *span = span.apply_mark(self.0)\n-    }\n-\n-    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-        noop_visit_mac(mac, self)\n-    }\n-}"}, {"sha": "9292ce334b81938d7082fb32e3977ce0d0df9b78", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -19,6 +19,7 @@ use crate::{ast, attr, attr::TransparencyError};\n \n use errors::{DiagnosticBuilder, FatalError};\n use log::debug;\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -128,6 +129,7 @@ impl<'a> ParserAnyMacro<'a> {\n struct MacroRulesMacroExpander {\n     name: ast::Ident,\n     span: Span,\n+    transparency: Transparency,\n     lhses: Vec<quoted::TokenTree>,\n     rhses: Vec<quoted::TokenTree>,\n     valid: bool,\n@@ -143,7 +145,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n-        generic_extension(cx, sp, self.span, self.name, input, &self.lhses, &self.rhses)\n+        generic_extension(\n+            cx, sp, self.span, self.name, self.transparency, input, &self.lhses, &self.rhses\n+        )\n     }\n }\n \n@@ -158,6 +162,7 @@ fn generic_extension<'cx>(\n     sp: Span,\n     def_span: Span,\n     name: ast::Ident,\n+    transparency: Transparency,\n     arg: TokenStream,\n     lhses: &[quoted::TokenTree],\n     rhses: &[quoted::TokenTree],\n@@ -187,7 +192,7 @@ fn generic_extension<'cx>(\n \n                 let rhs_spans = rhs.iter().map(|t| t.span()).collect::<Vec<_>>();\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = transcribe(cx, &named_matches, rhs);\n+                let mut tts = transcribe(cx, &named_matches, rhs, transparency);\n \n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n@@ -415,11 +420,7 @@ pub fn compile(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let expander: Box<_> =\n-        Box::new(MacroRulesMacroExpander { name: def.ident, span: def.span, lhses, rhses, valid });\n-\n-    let (default_transparency, transparency_error) =\n-        attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n             sess.span_diagnostic.span_err(\n@@ -432,6 +433,10 @@ pub fn compile(\n         None => {}\n     }\n \n+    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n+        name: def.ident, span: def.span, transparency, lhses, rhses, valid\n+    });\n+\n     let allow_internal_unstable =\n         attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {\n             attr.meta_item_list()\n@@ -473,7 +478,7 @@ pub fn compile(\n     SyntaxExtension {\n         kind: SyntaxExtensionKind::LegacyBang(expander),\n         span: def.span,\n-        default_transparency,\n+        default_transparency: transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe: attr::contains_name(&def.attrs, sym::allow_internal_unsafe),\n         local_inner_macros,"}, {"sha": "30d5df13dcedb1d3551c2cb337f3d76a25f36b5d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -1,18 +1,40 @@\n-use crate::ast::Ident;\n+use crate::ast::{Ident, Mac};\n use crate::ext::base::ExtCtxt;\n-use crate::ext::expand::Marker;\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n use crate::ext::tt::quoted;\n-use crate::mut_visit::noop_visit_tt;\n+use crate::mut_visit::{self, MutVisitor};\n use crate::parse::token::{self, NtTT, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::{ExpnId, Transparency};\n+use syntax_pos::Span;\n+\n use std::mem;\n \n+// A Marker adds the given mark to the syntax context.\n+struct Marker(ExpnId, Transparency);\n+\n+impl MutVisitor for Marker {\n+    fn visit_span(&mut self, span: &mut Span) {\n+        *span = span.apply_mark(self.0, self.1)\n+    }\n+\n+    fn visit_mac(&mut self, mac: &mut Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n+    }\n+}\n+\n+impl Marker {\n+    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n+        self.visit_span(&mut dspan.open);\n+        self.visit_span(&mut dspan.close);\n+    }\n+}\n+\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<quoted::Delimited>, idx: usize, span: DelimSpan },\n@@ -68,6 +90,7 @@ pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n     interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n+    transparency: Transparency,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n     if src.is_empty() {\n@@ -96,6 +119,7 @@ pub(super) fn transcribe(\n     // again, and we are done transcribing.\n     let mut result: Vec<TreeAndJoint> = Vec::new();\n     let mut result_stack = Vec::new();\n+    let mut marker = Marker(cx.current_expansion.id, transparency);\n \n     loop {\n         // Look at the last frame on the stack.\n@@ -207,7 +231,7 @@ pub(super) fn transcribe(\n             }\n \n             // Replace the meta-var with the matched token tree from the invocation.\n-            quoted::TokenTree::MetaVar(mut sp, ident) => {\n+            quoted::TokenTree::MetaVar(mut sp, mut ident) => {\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n@@ -218,7 +242,7 @@ pub(super) fn transcribe(\n                         if let NtTT(ref tt) = **nt {\n                             result.push(tt.clone().into());\n                         } else {\n-                            sp = sp.apply_mark(cx.current_expansion.id);\n+                            marker.visit_span(&mut sp);\n                             let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n@@ -232,9 +256,8 @@ pub(super) fn transcribe(\n                 } else {\n                     // If we aren't able to match the meta-var, we push it back into the result but\n                     // with modified syntax context. (I believe this supports nested macros).\n-                    let ident =\n-                        Ident::new(ident.name, ident.span.apply_mark(cx.current_expansion.id));\n-                    sp = sp.apply_mark(cx.current_expansion.id);\n+                    marker.visit_span(&mut sp);\n+                    marker.visit_ident(&mut ident);\n                     result.push(TokenTree::token(token::Dollar, sp).into());\n                     result.push(TokenTree::Token(Token::from_ast_ident(ident)).into());\n                 }\n@@ -246,17 +269,16 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             quoted::TokenTree::Delimited(mut span, delimited) => {\n-                span = span.apply_mark(cx.current_expansion.id);\n+                marker.visit_delim_span(&mut span);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }\n \n             // Nothing much to do here. Just push the token to the result, being careful to\n             // preserve syntax context.\n             quoted::TokenTree::Token(token) => {\n-                let mut marker = Marker(cx.current_expansion.id);\n                 let mut tt = TokenTree::Token(token);\n-                noop_visit_tt(&mut tt, &mut marker);\n+                marker.visit_tt(&mut tt);\n                 result.push(tt.into());\n             }\n "}, {"sha": "0d9f3769ce90447133c3e3a548eaaf60406ec789", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -19,7 +19,7 @@ use crate::parse::Directory;\n use crate::parse::token::{self, DelimToken, Token, TokenKind};\n use crate::print::pprust;\n \n-use syntax_pos::{BytePos, ExpnId, Span, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP};\n #[cfg(target_arch = \"x86_64\")]\n use rustc_data_structures::static_assert_size;\n use rustc_data_structures::sync::Lrc;\n@@ -547,11 +547,4 @@ impl DelimSpan {\n     pub fn entire(self) -> Span {\n         self.open.with_hi(self.close.hi())\n     }\n-\n-    pub fn apply_mark(self, expn_id: ExpnId) -> Self {\n-        DelimSpan {\n-            open: self.open.apply_mark(expn_id),\n-            close: self.close.apply_mark(expn_id),\n-        }\n-    }\n }"}, {"sha": "fa84dcdb7bf898ed96feeec0a086632e8a635b4f", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -192,10 +192,10 @@ impl HygieneData {\n         self.syntax_context_data[ctxt.0 as usize].parent\n     }\n \n-    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> ExpnId {\n-        let outer_expn = self.outer_expn(*ctxt);\n+    fn remove_mark(&self, ctxt: &mut SyntaxContext) -> (ExpnId, Transparency) {\n+        let outer_mark = self.outer_mark(*ctxt);\n         *ctxt = self.parent_ctxt(*ctxt);\n-        outer_expn\n+        outer_mark\n     }\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n@@ -218,20 +218,14 @@ impl HygieneData {\n     fn adjust(&self, ctxt: &mut SyntaxContext, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut scope = None;\n         while !self.is_descendant_of(expn_id, self.outer_expn(*ctxt)) {\n-            scope = Some(self.remove_mark(ctxt));\n+            scope = Some(self.remove_mark(ctxt).0);\n         }\n         scope\n     }\n \n-    fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n-        assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(\n-            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n-        )\n-    }\n-\n-    fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n-                                    transparency: Transparency) -> SyntaxContext {\n+    fn apply_mark(\n+        &mut self, ctxt: SyntaxContext, expn_id: ExpnId, transparency: Transparency\n+    ) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n         if transparency == Transparency::Opaque {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n@@ -365,15 +359,9 @@ impl SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n-    /// Extend a syntax context with a given expansion and default transparency for that expansion.\n-    pub fn apply_mark(self, expn_id: ExpnId) -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark(self, expn_id))\n-    }\n-\n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark_with_transparency(self, expn_id: ExpnId, transparency: Transparency)\n-                                        -> SyntaxContext {\n-        HygieneData::with(|data| data.apply_mark_with_transparency(self, expn_id, transparency))\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+        HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n \n     /// Pulls a single mark off of the syntax context. This effectively moves the\n@@ -393,7 +381,7 @@ impl SyntaxContext {\n     /// invocation of f that created g1.\n     /// Returns the mark that was removed.\n     pub fn remove_mark(&mut self) -> ExpnId {\n-        HygieneData::with(|data| data.remove_mark(self))\n+        HygieneData::with(|data| data.remove_mark(self).0)\n     }\n \n     pub fn marks(self) -> Vec<(ExpnId, Transparency)> {\n@@ -466,8 +454,8 @@ impl SyntaxContext {\n             let mut scope = None;\n             let mut glob_ctxt = data.modern(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n-                scope = Some(data.remove_mark(&mut glob_ctxt));\n-                if data.remove_mark(self) != scope.unwrap() {\n+                scope = Some(data.remove_mark(&mut glob_ctxt).0);\n+                if data.remove_mark(self).0 != scope.unwrap() {\n                     return None;\n                 }\n             }\n@@ -498,9 +486,9 @@ impl SyntaxContext {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n             }\n \n-            let scope = marks.last().cloned();\n-            while let Some(mark) = marks.pop() {\n-                *self = data.apply_mark(*self, mark);\n+            let scope = marks.last().map(|mark| mark.0);\n+            while let Some((expn_id, transparency)) = marks.pop() {\n+                *self = data.apply_mark(*self, expn_id, transparency);\n             }\n             Some(scope)\n         })\n@@ -571,9 +559,7 @@ impl Span {\n     ) -> Span {\n         HygieneData::with(|data| {\n             let expn_id = data.fresh_expn(Some(expn_data));\n-            self.with_ctxt(data.apply_mark_with_transparency(\n-                SyntaxContext::root(), expn_id, transparency\n-            ))\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n     }\n }"}, {"sha": "3d8bfc77a89500533316eaa19161c711445891a8", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9db76454838988620acf6ba7db7bc8654b6f57/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=cf9db76454838988620acf6ba7db7bc8654b6f57", "patch": "@@ -517,13 +517,13 @@ impl Span {\n     /// given ID and transparency, assuming that macro was defined directly and not produced by\n     /// some other macro (which is the case for built-in and procedural macros).\n     pub fn with_ctxt_from_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n-        self.with_ctxt(SyntaxContext::root().apply_mark_with_transparency(expn_id, transparency))\n+        self.with_ctxt(SyntaxContext::root().apply_mark(expn_id, transparency))\n     }\n \n     #[inline]\n-    pub fn apply_mark(self, mark: ExpnId) -> Span {\n+    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.apply_mark(mark))\n+        span.with_ctxt(span.ctxt.apply_mark(expn_id, transparency))\n     }\n \n     #[inline]"}]}