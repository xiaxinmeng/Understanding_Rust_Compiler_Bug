{"sha": "1d82fe5aea71b1c265634f32716b268972141efb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkODJmZTVhZWE3MWIxYzI2NTYzNGYzMjcxNmIyNjg5NzIxNDFlZmI=", "commit": {"author": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-07-31T20:52:22Z"}, "committer": {"name": "toddaaro", "email": "github@opprobrio.us", "date": "2013-08-01T22:18:29Z"}, "message": "fixed incorrect handling of returned scheduler option and restructed scheduler functions slightly", "tree": {"sha": "876b41aeb9d01d450bdd08f855f572804f24066d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/876b41aeb9d01d450bdd08f855f572804f24066d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d82fe5aea71b1c265634f32716b268972141efb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d82fe5aea71b1c265634f32716b268972141efb", "html_url": "https://github.com/rust-lang/rust/commit/1d82fe5aea71b1c265634f32716b268972141efb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d82fe5aea71b1c265634f32716b268972141efb/comments", "author": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toddaaro", "id": 366431, "node_id": "MDQ6VXNlcjM2NjQzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/366431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toddaaro", "html_url": "https://github.com/toddaaro", "followers_url": "https://api.github.com/users/toddaaro/followers", "following_url": "https://api.github.com/users/toddaaro/following{/other_user}", "gists_url": "https://api.github.com/users/toddaaro/gists{/gist_id}", "starred_url": "https://api.github.com/users/toddaaro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toddaaro/subscriptions", "organizations_url": "https://api.github.com/users/toddaaro/orgs", "repos_url": "https://api.github.com/users/toddaaro/repos", "events_url": "https://api.github.com/users/toddaaro/events{/privacy}", "received_events_url": "https://api.github.com/users/toddaaro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5f55b3ead06886190d905cfc826bf1d072ff675", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5f55b3ead06886190d905cfc826bf1d072ff675", "html_url": "https://github.com/rust-lang/rust/commit/a5f55b3ead06886190d905cfc826bf1d072ff675"}], "stats": {"total": 139, "additions": 64, "deletions": 75}, "files": [{"sha": "5a671d877d2ecf1ad8cbe0d06ac3dae40312ca24", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -131,10 +131,7 @@ impl<T> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map_consume |woken_task| {\n-                        let mut sched = Local::take::<Scheduler>();\n-                        rtdebug!(\"rendezvous send\");\n-                        sched.metrics.rendezvous_sends += 1;\n-                        sched.schedule_task(woken_task);\n+                        Scheduler::run_task(woken_task);\n                     };\n                 }\n             }\n@@ -350,8 +347,7 @@ impl<T> Drop for ChanOne<T> {\n                     assert!((*this.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map_consume |woken_task| {\n-                        let sched = Local::take::<Scheduler>();\n-                        sched.schedule_task(woken_task);\n+                        Scheduler::run_task(woken_task);\n                     };\n                 }\n             }"}, {"sha": "f0f4b646103996fdfcbbb2c58e23c7657f0dd89a", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -259,6 +259,8 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     let mut handles = ~[];\n \n     do nscheds.times {\n+        rtdebug!(\"inserting a regular scheduler\");\n+\n         // Every scheduler is driven by an I/O event loop.\n         let loop_ = ~UvEventLoop::new();\n         let mut sched = ~Scheduler::new(loop_, work_queue.clone(), sleepers.clone());\n@@ -344,6 +346,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     // Run each remaining scheduler in a thread.\n     while !scheds.is_empty() {\n+        rtdebug!(\"creating regular schedulers\");\n         let sched = scheds.pop();\n         let sched_cell = Cell::new(sched);\n         let thread = do Thread::start {\n@@ -360,15 +363,21 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     if use_main_sched {\n \n+        rtdebug!(\"about to create the main scheduler task\");\n+\n         let mut main_sched = main_sched.get();\n \n         let home = Sched(main_sched.make_handle());\n-        let mut main_task = ~Task::new_root_homed(&mut scheds[0].stack_pool,\n+        let mut main_task = ~Task::new_root_homed(&mut main_sched.stack_pool,\n                                                   home, main.take());\n         main_task.death.on_exit = Some(on_exit.take());\n+        rtdebug!(\"boostrapping main_task\");\n+\n         main_sched.bootstrap(main_task);\n     }\n \n+    rtdebug!(\"waiting for threads\");\n+\n     // Wait for schedulers\n     foreach thread in threads.consume_iter() {\n         thread.join();\n@@ -404,7 +413,6 @@ pub fn context() -> RuntimeContext {\n     if unsafe { rust_try_get_task().is_not_null() } {\n         return OldTaskContext;\n     } else if Local::exists::<Task>() {\n-        rtdebug!(\"either task or scheduler context in newrt\");\n         // In this case we know it is a new runtime context, but we\n         // need to check which one. Going to try borrowing task to\n         // check. Task should always be in TLS, so hopefully this"}, {"sha": "4abe69a7d134b821d660c6a31ecdf9d776504b22", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 46, "deletions": 63, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -142,11 +142,11 @@ impl Scheduler {\n         local_ptr::init_tls_key();\n \n         // Create a task for the scheduler with an empty context.\n-        let sched_task = Task::new_sched_task();\n+        let sched_task = ~Task::new_sched_task();\n \n         // Now that we have an empty task struct for the scheduler\n         // task, put it in TLS.\n-        Local::put::(~sched_task);\n+        Local::put::(sched_task);\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n@@ -165,8 +165,6 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-\n-        rtdebug!(\"post sched.run(), cleaning up scheduler task\");\n         let mut stask = Local::take::<Task>();\n         stask.destroyed = true;\n     }\n@@ -224,6 +222,8 @@ impl Scheduler {\n         // 2) A shutdown is also easy, shutdown.\n         // 3) A pinned task - we resume immediately and do not return\n         //    here.\n+        // 4) A message from another scheduler with a non-homed task\n+        //    to run here.\n \n         let result = sched.interpret_message_queue();\n         let sched = match result {\n@@ -236,6 +236,8 @@ impl Scheduler {\n             }\n         };\n \n+        // Second activity is to try resuming a task from the queue.\n+\n         let result = sched.resume_task_from_queue();\n         let mut sched = match result {\n             Some(sched) => {\n@@ -333,8 +335,7 @@ impl Scheduler {\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n-                this.schedule_task_sched_context(task);\n-                return None;\n+                return this.sched_schedule_task(task);\n             }\n             Some(Wake) => {\n                 this.sleepy = false;\n@@ -442,8 +443,6 @@ impl Scheduler {\n         }\n     }\n \n-    // * Task-context operations\n-\n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n     pub fn terminate_current_task(~self) {\n@@ -457,10 +456,17 @@ impl Scheduler {\n         }\n     }\n \n-    // If a scheduling action is performed, return None. If not,\n-    // return Some(sched).\n+    // Scheduling a task requires a few checks to make sure the task\n+    // ends up in the appropriate location. The run_anything flag on\n+    // the scheduler and the home on the task need to be checked. This\n+    // helper performs that check. It takes a function that specifies\n+    // how to queue the the provided task if that is the correct\n+    // action. This is a \"core\" function that requires handling the\n+    // returned Option correctly.\n \n-    pub fn schedule_task(~self, task: ~Task) -> Option<~Scheduler> {\n+    pub fn schedule_task(~self, task: ~Task,\n+                         schedule_fn: ~fn(sched: ~Scheduler, task: ~Task))\n+        -> Option<~Scheduler> {\n \n         // is the task home?\n         let is_home = task.is_home_no_tls(&self);\n@@ -474,9 +480,7 @@ impl Scheduler {\n             // here we know we are home, execute now OR we know we\n             // aren't homed, and that this sched doesn't care\n             rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n-            do this.switch_running_tasks_and_then(task) |sched, last_task| {\n-                sched.enqueue_blocked_task(last_task);\n-            }\n+            schedule_fn(this, task);\n             return None;\n         } else if !homed && !this.run_anything {\n             // the task isn't homed, but it can't be run here\n@@ -489,35 +493,30 @@ impl Scheduler {\n         }\n     }\n \n-    // BAD BAD BAD BAD BAD\n-    // Do something instead of just copy-pasting this.\n-    pub fn schedule_task_sched_context(~self, task: ~Task) -> Option<~Scheduler> {\n-\n-        // is the task home?\n-        let is_home = task.is_home_no_tls(&self);\n-\n-        // does the task have a home?\n-        let homed = task.homed();\n-\n-        let mut this = self;\n-\n-        if is_home || (!homed && this.run_anything) {\n-            // here we know we are home, execute now OR we know we\n-            // aren't homed, and that this sched doesn't care\n-            rtdebug!(\"task: %u is on ok sched, executing\", to_uint(task));\n-            this.resume_task_immediately(task);\n-            return None;\n-        } else if !homed && !this.run_anything {\n-            // the task isn't homed, but it can't be run here\n-            this.enqueue_task(task);\n-            return Some(this);\n-        } else {\n-            // task isn't home, so don't run it here, send it home\n-            Scheduler::send_task_home(task);\n-            return Some(this);\n+    // There are two contexts in which schedule_task can be called:\n+    // inside the scheduler, and inside a task. These contexts handle\n+    // executing the task slightly differently. In the scheduler\n+    // context case we want to receive the scheduler as an input, and\n+    // manually deal with the option. In the task context case we want\n+    // to use TLS to find the scheduler, and deal with the option\n+    // inside the helper.\n+\n+    pub fn sched_schedule_task(~self, task: ~Task) -> Option<~Scheduler> {\n+        do self.schedule_task(task) |sched, next_task| {\n+            sched.resume_task_immediately(next_task);\n         }\n     }\n \n+    // Task context case - use TLS.\n+    pub fn run_task(task: ~Task) {\n+        let sched = Local::take::<Scheduler>();\n+        let opt = do sched.schedule_task(task) |sched, next_task| {\n+            do sched.switch_running_tasks_and_then(next_task) |sched, last_task| {\n+                sched.enqueue_blocked_task(last_task);\n+            }\n+        };\n+        opt.map_consume(Local::put);\n+    }\n \n     // The primary function for changing contexts. In the current\n     // design the scheduler is just a slightly modified GreenTask, so\n@@ -586,7 +585,7 @@ impl Scheduler {\n             Context::swap(current_task_context, next_task_context);\n         }\n \n-        // When the context swaps back to the scheduler we immediately\n+        // When the context swaps back to this task we immediately\n         // run the cleanup job, as expected by the previously called\n         // swap_contexts function.\n         unsafe {\n@@ -599,15 +598,8 @@ impl Scheduler {\n         }\n     }\n \n-    // There are a variety of \"obvious\" functions to be passed to\n-    // change_task_context, so we can make a few \"named cases\".\n-\n-    // Enqueue the old task on the current scheduler.\n-    pub fn enqueue_old(sched: &mut Scheduler, task: ~Task) {\n-        sched.enqueue_task(task);\n-    }\n-\n-    // Sometimes we just want the old API though.\n+    // Old API for task manipulation implemented over the new core\n+    // function.\n \n     pub fn resume_task_immediately(~self, task: ~Task) {\n         do self.change_task_context(task) |sched, stask| {\n@@ -668,13 +660,6 @@ impl Scheduler {\n         };\n     }\n \n-    // A helper that looks up the scheduler and runs a task. If it can\n-    // be run now it is run now.\n-    pub fn run_task(new_task: ~Task) {\n-        let sched = Local::take::<Scheduler>();\n-        sched.schedule_task(new_task).map_consume(Local::put);\n-    }\n-\n     // Returns a mutable reference to both contexts involved in this\n     // swap. This is unsafe - we are getting mutable internal\n     // references to keep even when we don't own the tasks. It looks\n@@ -692,8 +677,6 @@ impl Scheduler {\n         }\n     }\n \n-    // * Other stuff\n-\n     pub fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n         self.cleanup_job = Some(job);\n     }\n@@ -1004,22 +987,22 @@ mod test {\n             let port = Cell::new(port);\n             let chan = Cell::new(chan);\n \n-            let _thread_one = do Thread::start {\n+            let thread_one = do Thread::start {\n                 let chan = Cell::new(chan.take());\n                 do run_in_newsched_task_core {\n                     chan.take().send(());\n                 }\n             };\n \n-            let _thread_two = do Thread::start {\n+            let thread_two = do Thread::start {\n                 let port = Cell::new(port.take());\n                 do run_in_newsched_task_core {\n                     port.take().recv();\n                 }\n             };\n \n-            thread1.join();\n-            thread2.join();\n+            thread_two.join();\n+            thread_one.join();\n         }\n     }\n "}, {"sha": "fcc6ebeada67a4ea5859f78ca2e70b9d52d61cf4", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -209,7 +209,7 @@ impl Task {\n     }\n \n     pub fn run(&mut self, f: &fn()) {\n-\n+        rtdebug!(\"run called on task: %u\", borrow::to_uint(self));\n         self.unwinder.try(f);\n         { let _ = self.taskgroup.take(); }\n         self.death.collect_failure(!self.unwinder.unwinding);\n@@ -301,7 +301,7 @@ impl Task {\n \n impl Drop for Task {\n     fn drop(&self) {\n-        rtdebug!(\"called drop for a task\");\n+        rtdebug!(\"called drop for a task: %u\", borrow::to_uint(self));\n         assert!(self.destroyed)\n     }\n }"}, {"sha": "22eb42e2ee828f888761ee9998119410a2a39056", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -130,7 +130,9 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n \n         while !scheds.is_empty() {\n             let mut sched = scheds.pop();\n-            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {};\n+            let bootstrap_task = ~do Task::new_root(&mut sched.stack_pool) || {\n+                rtdebug!(\"bootstrapping non-primary scheduler\");\n+            };\n             let bootstrap_task_cell = Cell::new(bootstrap_task);\n             let sched_cell = Cell::new(sched);\n             let thread = do Thread::start {"}, {"sha": "5be197521523439691c26a5d74b3453b62e7b39c", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d82fe5aea71b1c265634f32716b268972141efb/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=1d82fe5aea71b1c265634f32716b268972141efb", "patch": "@@ -253,7 +253,7 @@ impl IoFactory for UvIoFactory {\n         let scheduler = Local::take::<Scheduler>();\n \n         // Block this task and take ownership, switch to scheduler context\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());"}]}