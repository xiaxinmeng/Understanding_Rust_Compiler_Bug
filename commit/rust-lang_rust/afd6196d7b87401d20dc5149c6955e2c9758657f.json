{"sha": "afd6196d7b87401d20dc5149c6955e2c9758657f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZDYxOTZkN2I4NzQwMWQyMGRjNTE0OWM2OTU1ZTJjOTc1ODY1N2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-05T16:12:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-05T16:12:51Z"}, "message": "auto merge of #5233 : bstrie/rust/deimpselfcore, r=graydon", "tree": {"sha": "1c98ce71bfb8b9d572d2b5d20150473e5577a074", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c98ce71bfb8b9d572d2b5d20150473e5577a074"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afd6196d7b87401d20dc5149c6955e2c9758657f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afd6196d7b87401d20dc5149c6955e2c9758657f", "html_url": "https://github.com/rust-lang/rust/commit/afd6196d7b87401d20dc5149c6955e2c9758657f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afd6196d7b87401d20dc5149c6955e2c9758657f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f55a070757792475a325dfd1786765b7bfc84f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f55a070757792475a325dfd1786765b7bfc84f5", "html_url": "https://github.com/rust-lang/rust/commit/5f55a070757792475a325dfd1786765b7bfc84f5"}, {"sha": "9db61e0c219f25fbccf5d284580a61e8806ca596", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db61e0c219f25fbccf5d284580a61e8806ca596", "html_url": "https://github.com/rust-lang/rust/commit/9db61e0c219f25fbccf5d284580a61e8806ca596"}], "stats": {"total": 653, "additions": 338, "deletions": 315}, "files": [{"sha": "a85ab1a29b782b539d7b95375c099499cc033f76", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -30,7 +30,7 @@ pub pure fn empty_cell<T>() -> Cell<T> {\n \n pub impl<T> Cell<T> {\n     /// Yields the value, failing if the cell is empty.\n-    fn take() -> T {\n+    fn take(&self) -> T {\n         if self.is_empty() {\n             fail!(~\"attempt to take an empty cell\");\n         }\n@@ -41,20 +41,20 @@ pub impl<T> Cell<T> {\n     }\n \n     /// Returns the value, failing if the cell is full.\n-    fn put_back(value: T) {\n+    fn put_back(&self, value: T) {\n         if !self.is_empty() {\n             fail!(~\"attempt to put a value back into a full cell\");\n         }\n         self.value = Some(value);\n     }\n \n     /// Returns true if the cell is empty and false if the cell is full.\n-    pure fn is_empty() -> bool {\n+    pure fn is_empty(&self) -> bool {\n         self.value.is_none()\n     }\n \n     // Calls a closure with a reference to the value.\n-    fn with_ref<R>(op: fn(v: &T) -> R) -> R {\n+    fn with_ref<R>(&self, op: fn(v: &T) -> R) -> R {\n         let v = self.take();\n         let r = op(&v);\n         self.put_back(v);"}, {"sha": "4f812a5ae7693214ba7a4c11280d8d8da3009240", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -24,31 +24,31 @@ pub use pipes::Selectable;\n /// A trait for things that can send multiple messages.\n pub trait GenericChan<T> {\n     /// Sends a message.\n-    fn send(x: T);\n+    fn send(&self, x: T);\n }\n \n /// Things that can send multiple messages and can detect when the receiver\n /// is closed\n pub trait GenericSmartChan<T> {\n     /// Sends a message, or report if the receiver has closed the connection.\n-    fn try_send(x: T) -> bool;\n+    fn try_send(&self, x: T) -> bool;\n }\n \n /// A trait for things that can receive multiple messages.\n pub trait GenericPort<T> {\n     /// Receives a message, or fails if the connection closes.\n-    fn recv() -> T;\n+    fn recv(&self) -> T;\n \n     /** Receives a message, or returns `none` if\n     the connection is closed or closes.\n     */\n-    fn try_recv() -> Option<T>;\n+    fn try_recv(&self) -> Option<T>;\n }\n \n /// Ports that can `peek`\n pub trait Peekable<T> {\n     /// Returns true if a message is available\n-    pure fn peek() -> bool;\n+    pure fn peek(&self) -> bool;\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -105,7 +105,7 @@ pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(x: T) {\n+    fn send(&self, x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n@@ -115,7 +115,7 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n \n-    fn try_send(x: T) -> bool {\n+    fn try_send(&self, x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n         match streamp::client::try_data(unwrap(endp), x) {\n@@ -129,15 +129,15 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n-    fn recv() -> T {\n+    fn recv(&self) -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n         let streamp::data(x, endp) = recv(unwrap(endp));\n         self.endp = Some(endp);\n         x\n     }\n \n-    fn try_recv() -> Option<T> {\n+    fn try_recv(&self) -> Option<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         match try_recv(unwrap(endp)) {\n@@ -151,7 +151,7 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    pure fn peek() -> bool {\n+    pure fn peek(&self) -> bool {\n         unsafe {\n             let mut endp = None;\n             endp <-> self.endp;\n@@ -166,7 +166,7 @@ impl<T: Owned> Peekable<T> for Port<T> {\n }\n \n impl<T: Owned> Selectable for Port<T> {\n-    pure fn header() -> *PacketHeader {\n+    pure fn header(&self) -> *PacketHeader {\n         unsafe {\n             match self.endp {\n               Some(ref endp) => endp.header(),\n@@ -189,11 +189,11 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n \n pub impl<T: Owned> PortSet<T> {\n \n-    fn add(port: Port<T>) {\n+    fn add(&self, port: Port<T>) {\n         self.ports.push(port)\n     }\n \n-    fn chan() -> Chan<T> {\n+    fn chan(&self) -> Chan<T> {\n         let (po, ch) = stream();\n         self.add(po);\n         ch\n@@ -202,7 +202,7 @@ pub impl<T: Owned> PortSet<T> {\n \n impl<T: Owned> GenericPort<T> for PortSet<T> {\n \n-    fn try_recv() -> Option<T> {\n+    fn try_recv(&self) -> Option<T> {\n         let mut result = None;\n         // we have to swap the ports array so we aren't borrowing\n         // aliasable mutable memory.\n@@ -224,14 +224,14 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n         result\n     }\n \n-    fn recv() -> T {\n+    fn recv(&self) -> T {\n         self.try_recv().expect(\"port_set: endpoints closed\")\n     }\n \n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    pure fn peek() -> bool {\n+    pure fn peek(&self) -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for vec::each(self.ports) |p| {\n@@ -245,7 +245,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(x: T) {\n+    fn send(&self, x: T) {\n         let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -256,7 +256,7 @@ impl<T: Owned> GenericChan<T> for SharedChan<T> {\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(x: T) -> bool {\n+    fn try_send(&self, x: T) -> bool {\n         let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n@@ -274,27 +274,27 @@ pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n /// Receive a message from one of two endpoints.\n pub trait Select2<T: Owned, U: Owned> {\n     /// Receive a message or return `None` if a connection closes.\n-    fn try_select() -> Either<Option<T>, Option<U>>;\n+    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n-    fn select() -> Either<T, U>;\n+    fn select(&self) -> Either<T, U>;\n }\n \n impl<T: Owned, U: Owned,\n      Left: Selectable + GenericPort<T>,\n      Right: Selectable + GenericPort<U>>\n     Select2<T, U> for (Left, Right) {\n \n-    fn select() -> Either<T, U> {\n-        match self {\n+    fn select(&self) -> Either<T, U> {\n+        match *self {\n           (ref lp, ref rp) => match select2i(lp, rp) {\n             Left(()) => Left (lp.recv()),\n             Right(()) => Right(rp.recv())\n           }\n         }\n     }\n \n-    fn try_select() -> Either<Option<T>, Option<U>> {\n-        match self {\n+    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n+        match *self {\n           (ref lp, ref rp) => match select2i(lp, rp) {\n             Left(()) => Left (lp.try_recv()),\n             Right(()) => Right(rp.try_recv())"}, {"sha": "87752cff1bfa2239aac2e6ec331ada0d785df563", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -35,12 +35,12 @@ pub impl<T, U> Condition<T, U> {\n         }\n     }\n \n-    fn raise(t: T) -> U {\n+    fn raise(&self, t: T) -> U {\n         let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n         self.raise_default(t, || fail!(copy msg))\n     }\n \n-    fn raise_default(t: T, default: &fn() -> U) -> U {\n+    fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         unsafe {\n             match local_data_pop(self.key) {\n                 None => {"}, {"sha": "34a3c3e60af23db0849bc6cf8231a35a0100c878", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -148,7 +148,7 @@ priv impl<T> DList<T> {\n             fail!(~\"That node isn't on this dlist.\")\n         }\n     }\n-    fn make_mine(nobe: @mut DListNode<T>) {\n+    fn make_mine(&self, nobe: @mut DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             fail!(~\"Cannot insert node that's already on a dlist!\")\n         }"}, {"sha": "7eb615d07a6fbe36ef69893960f5addb906726d4", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -82,7 +82,7 @@ pub pure fn unwrap<A>(d: DVec<A>) -> ~[A] {\n \n priv impl<A> DVec<A> {\n     #[inline(always)]\n-    pure fn check_not_borrowed() {\n+    pure fn check_not_borrowed(&self) {\n         unsafe {\n             let data: *() = cast::reinterpret_cast(&self.data);\n             if data.is_null() {\n@@ -92,7 +92,7 @@ priv impl<A> DVec<A> {\n     }\n \n     #[inline(always)]\n-    fn give_back(data: ~[A]) {\n+    fn give_back(&self, data: ~[A]) {\n         unsafe {\n             self.data = data;\n         }\n@@ -119,7 +119,7 @@ pub impl<A> DVec<A> {\n     }\n \n     /// Reserves space for N elements\n-    fn reserve(count: uint) {\n+    fn reserve(&self, count: uint) {\n         vec::reserve(&mut self.data, count)\n     }\n \n@@ -129,26 +129,26 @@ pub impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap(f: &fn(v: ~[A]) -> ~[A]) {\n+    fn swap(&self, f: &fn(v: ~[A]) -> ~[A]) {\n         self.check_out(|v| self.give_back(f(v)))\n     }\n \n     /// Returns the number of elements currently in the dvec\n     #[inline(always)]\n-    pure fn len() -> uint {\n+    pure fn len(&self) -> uint {\n         self.check_not_borrowed();\n         return self.data.len();\n     }\n \n     /// Overwrite the current contents\n     #[inline(always)]\n-    fn set(w: ~[A]) {\n+    fn set(&self, w: ~[A]) {\n         self.check_not_borrowed();\n         self.data = w;\n     }\n \n     /// Remove and return the last element\n-    fn pop() -> A {\n+    fn pop(&self) -> A {\n         do self.check_out |v| {\n             let mut v = v;\n             let result = v.pop();\n@@ -158,7 +158,7 @@ pub impl<A> DVec<A> {\n     }\n \n     /// Insert a single item at the front of the list\n-    fn unshift(t: A) {\n+    fn unshift(&self, t: A) {\n         unsafe {\n             let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n@@ -171,13 +171,13 @@ pub impl<A> DVec<A> {\n \n     /// Append a single item to the end of the list\n     #[inline(always)]\n-    fn push(t: A) {\n+    fn push(&self, t: A) {\n         self.check_not_borrowed();\n         self.data.push(t);\n     }\n \n     /// Remove and return the first element\n-    fn shift() -> A {\n+    fn shift(&self) -> A {\n         do self.check_out |v| {\n             let mut v = v;\n             let result = v.shift();\n@@ -187,7 +187,7 @@ pub impl<A> DVec<A> {\n     }\n \n     /// Reverse the elements in the list, in place\n-    fn reverse() {\n+    fn reverse(&self) {\n         do self.check_out |v| {\n             let mut v = v;\n             vec::reverse(v);\n@@ -196,7 +196,7 @@ pub impl<A> DVec<A> {\n     }\n \n     /// Gives access to the vector as a slice with immutable contents\n-    fn borrow<R>(op: fn(x: &[A]) -> R) -> R {\n+    fn borrow<R>(&self, op: fn(x: &[A]) -> R) -> R {\n         do self.check_out |v| {\n             let result = op(v);\n             self.give_back(v);\n@@ -205,7 +205,7 @@ pub impl<A> DVec<A> {\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(op: &fn(x: &mut [A]) -> R) -> R {\n+    fn borrow_mut<R>(&self, op: &fn(x: &mut [A]) -> R) -> R {\n         do self.check_out |v| {\n             let mut v = v;\n             let result = op(v);\n@@ -221,12 +221,12 @@ pub impl<A:Copy> DVec<A> {\n      *\n      * Equivalent to `append_iter()` but potentially more efficient.\n      */\n-    fn push_all(ts: &[const A]) {\n+    fn push_all(&self, ts: &[const A]) {\n         self.push_slice(ts, 0u, vec::len(ts));\n     }\n \n     /// Appends elements from `from_idx` to `to_idx` (exclusive)\n-    fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n+    fn push_slice(&self, ts: &[const A], from_idx: uint, to_idx: uint) {\n         do self.swap |v| {\n             let mut v = v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n@@ -270,7 +270,7 @@ pub impl<A:Copy> DVec<A> {\n      *\n      * See `unwrap()` if you do not wish to copy the contents.\n      */\n-    pure fn get() -> ~[A] {\n+    pure fn get(&self) -> ~[A] {\n         unsafe {\n             do self.check_out |v| {\n                 let w = copy v;\n@@ -282,13 +282,13 @@ pub impl<A:Copy> DVec<A> {\n \n     /// Copy out an individual element\n     #[inline(always)]\n-    pure fn get_elt(idx: uint) -> A {\n+    pure fn get_elt(&self, idx: uint) -> A {\n         self.check_not_borrowed();\n         return self.data[idx];\n     }\n \n     /// Overwrites the contents of the element at `idx` with `a`\n-    fn set_elt(idx: uint, a: A) {\n+    fn set_elt(&self, idx: uint, a: A) {\n         self.check_not_borrowed();\n         self.data[idx] = a;\n     }\n@@ -298,7 +298,7 @@ pub impl<A:Copy> DVec<A> {\n      * growing the vector if necessary.  New elements will be initialized\n      * with `initval`\n      */\n-    fn grow_set_elt(idx: uint, initval: &A, val: A) {\n+    fn grow_set_elt(&self, idx: uint, initval: &A, val: A) {\n         do self.swap |v| {\n             let mut v = v;\n             v.grow_set(idx, initval, val);\n@@ -308,7 +308,7 @@ pub impl<A:Copy> DVec<A> {\n \n     /// Returns the last element, failing if the vector is empty\n     #[inline(always)]\n-    pure fn last() -> A {\n+    pure fn last(&self) -> A {\n         self.check_not_borrowed();\n \n         let length = self.len();\n@@ -321,7 +321,7 @@ pub impl<A:Copy> DVec<A> {\n \n     /// Iterates over the elements in reverse order\n     #[inline(always)]\n-    fn rev_each(f: fn(v: &A) -> bool) {\n+    fn rev_each(&self, f: fn(v: &A) -> bool) {\n         do self.swap |v| {\n             // FIXME(#2263)---we should be able to write\n             // `vec::rev_each(v, f);` but we cannot write now\n@@ -334,7 +334,7 @@ pub impl<A:Copy> DVec<A> {\n \n     /// Iterates over the elements and indices in reverse order\n     #[inline(always)]\n-    fn rev_eachi(f: fn(uint, v: &A) -> bool) {\n+    fn rev_eachi(&self, f: fn(uint, v: &A) -> bool) {\n         do self.swap |v| {\n             // FIXME(#2263)---we should be able to write\n             // `vec::rev_eachi(v, f);` but we cannot write now"}, {"sha": "2587b84b274ca207d3bb83f82087e5df975cdea8", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -50,32 +50,32 @@ pub trait Hash {\n      * function and require most types to only implement the\n      * IterBytes trait, that feeds SipHash.\n      */\n-    pure fn hash_keyed(k0: u64, k1: u64) -> u64;\n+    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64;\n }\n \n // When we have default methods, won't need this.\n pub trait HashUtil {\n-    pure fn hash() -> u64;\n+    pure fn hash(&self) -> u64;\n }\n \n impl<A:Hash> HashUtil for A {\n     #[inline(always)]\n-    pure fn hash() -> u64 { self.hash_keyed(0,0) }\n+    pure fn hash(&self) -> u64 { self.hash_keyed(0,0) }\n }\n \n /// Streaming hash-functions should implement this.\n pub trait Streaming {\n-    fn input((&[const u8]));\n+    fn input(&self, (&[const u8]));\n     // These can be refactored some when we have default methods.\n-    fn result_bytes() -> ~[u8];\n+    fn result_bytes(&self) -> ~[u8];\n     fn result_str() -> ~str;\n-    fn result_u64() -> u64;\n-    fn reset();\n+    fn result_u64(&self) -> u64;\n+    fn reset(&self);\n }\n \n impl<A:IterBytes> Hash for A {\n     #[inline(always)]\n-    pure fn hash_keyed(k0: u64, k1: u64) -> u64 {\n+    pure fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         unsafe {\n             let s = &State(k0, k1);\n             for self.iter_bytes(true) |bytes| {\n@@ -301,12 +301,12 @@ impl io::Writer for SipState {\n impl Streaming for &SipState {\n \n     #[inline(always)]\n-    fn input(buf: &[const u8]) {\n+    fn input(&self, buf: &[const u8]) {\n         self.write(buf);\n     }\n \n     #[inline(always)]\n-    fn result_u64() -> u64 {\n+    fn result_u64(&self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;\n         let mut v2 = self.v2;\n@@ -336,7 +336,7 @@ impl Streaming for &SipState {\n         return (v0 ^ v1 ^ v2 ^ v3);\n     }\n \n-    fn result_bytes() -> ~[u8] {\n+    fn result_bytes(&self) -> ~[u8] {\n         let h = self.result_u64();\n         ~[(h >> 0) as u8,\n           (h >> 8) as u8,\n@@ -349,6 +349,7 @@ impl Streaming for &SipState {\n         ]\n     }\n \n+    // IMPLICIT SELF WARNING: fix me!\n     fn result_str() -> ~str {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n@@ -359,7 +360,7 @@ impl Streaming for &SipState {\n     }\n \n     #[inline(always)]\n-    fn reset() {\n+    fn reset(&self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n         self.v1 = self.k1 ^ 0x646f72616e646f6d;"}, {"sha": "e4b8d204dd7edb0c50fa2b24d1396f6add4539bc", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -44,7 +44,7 @@ pub fn unwrap<T>(m: Mut<T>) -> T {\n }\n \n pub impl<T> Data<T> {\n-    fn borrow_mut<R>(op: &fn(t: &mut T) -> R) -> R {\n+    fn borrow_mut<R>(&self, op: &fn(t: &mut T) -> R) -> R {\n         match self.mode {\n             Immutable => fail!(fmt!(\"%? currently immutable\",\n                                    self.value)),\n@@ -56,11 +56,11 @@ pub impl<T> Data<T> {\n         }\n     }\n \n-    pure fn borrow_const<R>(op: &fn(t: &const T) -> R) -> R {\n+    pure fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n         op(&const self.value)\n     }\n \n-    fn borrow_imm<R>(op: &fn(t: &T) -> R) -> R {\n+    fn borrow_imm<R>(&self, op: &fn(t: &T) -> R) -> R {\n         match self.mode {\n           Mutable => fail!(fmt!(\"%? currently mutable\",\n                                self.value)),"}, {"sha": "eed6e8540f0ac5e4c47d41c6dc44c85cfa1c13d9", "filename": "src/libcore/path.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -45,28 +45,28 @@ pub pure fn PosixPath(s: &str) -> PosixPath {\n pub trait GenericPath {\n     static pure fn from_str(&str) -> Self;\n \n-    pure fn dirname() -> ~str;\n-    pure fn filename() -> Option<~str>;\n-    pure fn filestem() -> Option<~str>;\n-    pure fn filetype() -> Option<~str>;\n+    pure fn dirname(&self) -> ~str;\n+    pure fn filename(&self) -> Option<~str>;\n+    pure fn filestem(&self) -> Option<~str>;\n+    pure fn filetype(&self) -> Option<~str>;\n \n-    pure fn with_dirname((&str)) -> Self;\n-    pure fn with_filename((&str)) -> Self;\n-    pure fn with_filestem((&str)) -> Self;\n-    pure fn with_filetype((&str)) -> Self;\n+    pure fn with_dirname(&self, (&str)) -> Self;\n+    pure fn with_filename(&self, (&str)) -> Self;\n+    pure fn with_filestem(&self, (&str)) -> Self;\n+    pure fn with_filetype(&self, (&str)) -> Self;\n \n-    pure fn dir_path() -> Self;\n-    pure fn file_path() -> Self;\n+    pure fn dir_path(&self) -> Self;\n+    pure fn file_path(&self) -> Self;\n \n-    pure fn push((&str)) -> Self;\n-    pure fn push_rel((&Self)) -> Self;\n-    pure fn push_many((&[~str])) -> Self;\n-    pure fn pop() -> Self;\n+    pure fn push(&self, (&str)) -> Self;\n+    pure fn push_rel(&self, (&Self)) -> Self;\n+    pure fn push_many(&self, (&[~str])) -> Self;\n+    pure fn pop(&self) -> Self;\n \n-    pure fn unsafe_join((&Self)) -> Self;\n-    pure fn is_restricted() -> bool;\n+    pure fn unsafe_join(&self, (&Self)) -> Self;\n+    pure fn is_restricted(&self) -> bool;\n \n-    pure fn normalize() -> Self;\n+    pure fn normalize(&self) -> Self;\n }\n \n #[cfg(windows)]\n@@ -387,7 +387,7 @@ impl GenericPath for PosixPath {\n                            components: components }\n     }\n \n-    pure fn dirname() -> ~str {\n+    pure fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -398,14 +398,14 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filename() -> Option<~str> {\n+    pure fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem() -> Option<~str> {\n+    pure fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -417,7 +417,7 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn filetype() -> Option<~str> {\n+    pure fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -429,32 +429,32 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn with_dirname(d: &str) -> PosixPath {\n+    pure fn with_dirname(&self, d: &str) -> PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(f: &str) -> PosixPath {\n+    pure fn with_filename(&self, f: &str) -> PosixPath {\n         unsafe {\n             assert ! str::any(f, |c| windows::is_sep(c as u8));\n             self.dir_path().push(f)\n         }\n     }\n \n-    pure fn with_filestem(s: &str) -> PosixPath {\n+    pure fn with_filestem(&self, s: &str) -> PosixPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(t: &str) -> PosixPath {\n+    pure fn with_filetype(&self, t: &str) -> PosixPath {\n         if t.len() == 0 {\n             match self.filestem() {\n-              None => copy self,\n+              None => copy *self,\n               Some(ref s) => self.with_filename(*s)\n             }\n         } else {\n@@ -466,15 +466,15 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn dir_path() -> PosixPath {\n+    pure fn dir_path(&self) -> PosixPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n-            copy self\n+            copy *self\n         }\n     }\n \n-    pure fn file_path() -> PosixPath {\n+    pure fn file_path(&self) -> PosixPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -483,12 +483,12 @@ impl GenericPath for PosixPath {\n                            components: cs }\n     }\n \n-    pure fn push_rel(other: &PosixPath) -> PosixPath {\n+    pure fn push_rel(&self, other: &PosixPath) -> PosixPath {\n         assert !other.is_absolute;\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(other: &PosixPath) -> PosixPath {\n+    pure fn unsafe_join(&self, other: &PosixPath) -> PosixPath {\n         if other.is_absolute {\n             PosixPath { is_absolute: true,\n                         components: copy other.components }\n@@ -497,11 +497,11 @@ impl GenericPath for PosixPath {\n         }\n     }\n \n-    pure fn is_restricted() -> bool {\n+    pure fn is_restricted(&self) -> bool {\n         false\n     }\n \n-    pure fn push_many(cs: &[~str]) -> PosixPath {\n+    pure fn push_many(&self, cs: &[~str]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -513,14 +513,14 @@ impl GenericPath for PosixPath {\n                     components: v }\n     }\n \n-    pure fn push(s: &str) -> PosixPath {\n+    pure fn push(&self, s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n-        PosixPath { components: v, ..copy self }\n+        PosixPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop() -> PosixPath {\n+    pure fn pop(&self) -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -532,7 +532,7 @@ impl GenericPath for PosixPath {\n                           //..self }\n     }\n \n-    pure fn normalize() -> PosixPath {\n+    pure fn normalize(&self) -> PosixPath {\n         return PosixPath {\n             is_absolute: self.is_absolute,\n             components: normalize(self.components)\n@@ -599,7 +599,7 @@ impl GenericPath for WindowsPath {\n                              components: components }\n     }\n \n-    pure fn dirname() -> ~str {\n+    pure fn dirname(&self) -> ~str {\n         unsafe {\n             let s = self.dir_path().to_str();\n             if s.len() == 0 {\n@@ -610,14 +610,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filename() -> Option<~str> {\n+    pure fn filename(&self) -> Option<~str> {\n         match self.components.len() {\n           0 => None,\n           n => Some(copy self.components[n - 1])\n         }\n     }\n \n-    pure fn filestem() -> Option<~str> {\n+    pure fn filestem(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -629,7 +629,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn filetype() -> Option<~str> {\n+    pure fn filetype(&self) -> Option<~str> {\n         match self.filename() {\n           None => None,\n           Some(ref f) => {\n@@ -641,30 +641,30 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn with_dirname(d: &str) -> WindowsPath {\n+    pure fn with_dirname(&self, d: &str) -> WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n           None => dpath\n         }\n     }\n \n-    pure fn with_filename(f: &str) -> WindowsPath {\n+    pure fn with_filename(&self, f: &str) -> WindowsPath {\n         assert ! str::any(f, |c| windows::is_sep(c as u8));\n         self.dir_path().push(f)\n     }\n \n-    pure fn with_filestem(s: &str) -> WindowsPath {\n+    pure fn with_filestem(&self, s: &str) -> WindowsPath {\n         match self.filetype() {\n           None => self.with_filename(s),\n           Some(ref t) => self.with_filename(str::from_slice(s) + *t)\n         }\n     }\n \n-    pure fn with_filetype(t: &str) -> WindowsPath {\n+    pure fn with_filetype(&self, t: &str) -> WindowsPath {\n         if t.len() == 0 {\n             match self.filestem() {\n-              None => copy self,\n+              None => copy *self,\n               Some(ref s) => self.with_filename(*s)\n             }\n         } else {\n@@ -677,15 +677,15 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn dir_path() -> WindowsPath {\n+    pure fn dir_path(&self) -> WindowsPath {\n         if self.components.len() != 0 {\n             self.pop()\n         } else {\n-            copy self\n+            copy *self\n         }\n     }\n \n-    pure fn file_path() -> WindowsPath {\n+    pure fn file_path(&self) -> WindowsPath {\n         let cs = match self.filename() {\n           None => ~[],\n           Some(ref f) => ~[copy *f]\n@@ -696,12 +696,12 @@ impl GenericPath for WindowsPath {\n                              components: cs }\n     }\n \n-    pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n+    pure fn push_rel(&self, other: &WindowsPath) -> WindowsPath {\n         assert !other.is_absolute;\n         self.push_many(other.components)\n     }\n \n-    pure fn unsafe_join(other: &WindowsPath) -> WindowsPath {\n+    pure fn unsafe_join(&self, other: &WindowsPath) -> WindowsPath {\n         /* rhs not absolute is simple push */\n         if !other.is_absolute {\n             return self.push_many(other.components);\n@@ -743,7 +743,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn is_restricted() -> bool {\n+    pure fn is_restricted(&self) -> bool {\n         match self.filestem() {\n             Some(stem) => {\n                 match stem.to_lower() {\n@@ -756,7 +756,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push_many(cs: &[~str]) -> WindowsPath {\n+    pure fn push_many(&self, cs: &[~str]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n             let mut ss = str::split_nonempty(\n@@ -773,14 +773,14 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn push(s: &str) -> WindowsPath {\n+    pure fn push(&self, s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n         unsafe { v.push_all_move(ss); }\n-        return WindowsPath { components: v, ..copy self }\n+        return WindowsPath { components: v, ..copy *self }\n     }\n \n-    pure fn pop() -> WindowsPath {\n+    pure fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n@@ -793,7 +793,7 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    pure fn normalize() -> WindowsPath {\n+    pure fn normalize(&self) -> WindowsPath {\n         return WindowsPath {\n             host: copy self.host,\n             device: match self.device {"}, {"sha": "72215e4863f795ec078ec23c09c36e17d4f570fd", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -158,14 +158,14 @@ pub fn PacketHeader() -> PacketHeader {\n \n pub impl PacketHeader {\n     // Returns the old state.\n-    unsafe fn mark_blocked(this: *rust_task) -> State {\n+    unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n         assert old_task.is_null();\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n-    unsafe fn unblock() {\n+    unsafe fn unblock(&self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             unsafe {\n@@ -182,12 +182,12 @@ pub impl PacketHeader {\n     // unsafe because this can do weird things to the space/time\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll proobably want to forget them when you're done.\n-    unsafe fn buf_header() -> ~BufferHeader {\n+    unsafe fn buf_header(&self) -> ~BufferHeader {\n         assert self.buffer.is_not_null();\n         reinterpret_cast(&self.buffer)\n     }\n \n-    fn set_buffer<T:Owned>(b: ~Buffer<T>) {\n+    fn set_buffer<T:Owned>(&self, b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = reinterpret_cast(&b);\n         }\n@@ -202,11 +202,11 @@ pub struct Packet<T> {\n \n #[doc(hidden)]\n pub trait HasBuffer {\n-    fn set_buffer(b: *libc::c_void);\n+    fn set_buffer(&self, b: *libc::c_void);\n }\n \n impl<T:Owned> HasBuffer for Packet<T> {\n-    fn set_buffer(b: *libc::c_void) {\n+    fn set_buffer(&self, b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n@@ -715,11 +715,11 @@ pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n \n #[doc(hidden)]\n pub trait Selectable {\n-    pure fn header() -> *PacketHeader;\n+    pure fn header(&self) -> *PacketHeader;\n }\n \n impl Selectable for *PacketHeader {\n-    pure fn header() -> *PacketHeader { self }\n+    pure fn header(&self) -> *PacketHeader { *self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n@@ -797,13 +797,13 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n }\n \n pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap() -> *Packet<T> {\n+    fn unwrap(&self) -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n-    pure fn header() -> *PacketHeader {\n+    pure fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n@@ -815,7 +815,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         }\n     }\n \n-    fn reuse_buffer() -> BufferResource<Tbuffer> {\n+    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n@@ -854,13 +854,13 @@ impl<T:Owned,Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n }\n \n pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n-    fn unwrap() -> *Packet<T> {\n+    fn unwrap(&self) -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n-    fn reuse_buffer() -> BufferResource<Tbuffer> {\n+    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n@@ -869,7 +869,7 @@ pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n }\n \n impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    pure fn header() -> *PacketHeader {\n+    pure fn header(&self) -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;"}, {"sha": "c8f5d32252301f9c77dd2872997846805134282b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -175,39 +175,39 @@ pub pure fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n }\n \n pub trait Ptr<T> {\n-    pure fn is_null() -> bool;\n-    pure fn is_not_null() -> bool;\n-    pure fn offset(count: uint) -> Self;\n+    pure fn is_null(&self) -> bool;\n+    pure fn is_not_null(&self) -> bool;\n+    pure fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> Ptr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null() -> bool { is_null(self) }\n+    pure fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null() -> bool { is_not_null(self) }\n+    pure fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a pointer.\n     #[inline(always)]\n-    pure fn offset(count: uint) -> *T { offset(self, count) }\n+    pure fn offset(&self, count: uint) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n impl<T> Ptr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_null() -> bool { is_null(self) }\n+    pure fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline(always)]\n-    pure fn is_not_null() -> bool { is_not_null(self) }\n+    pure fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     /// Calculates the offset from a mutable pointer.\n     #[inline(always)]\n-    pure fn offset(count: uint) -> *mut T { mut_offset(self, count) }\n+    pure fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers"}, {"sha": "377bf5bf4e7cd6da775db6bec15cbb77139a6824", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -131,7 +131,7 @@ extern mod rustrt {\n /// A random number generator\n pub trait Rng {\n     /// Return the next random integer\n-    fn next() -> u32;\n+    fn next(&self) -> u32;\n }\n \n /// A value with a particular weight compared to other values\n@@ -143,90 +143,90 @@ pub struct Weighted<T> {\n /// Extension methods for random number generators\n pub impl Rng {\n     /// Return a random value for a Rand type\n-    fn gen<T:Rand>() -> T {\n-        Rand::rand(self)\n+    fn gen<T:Rand>(&self) -> T {\n+        Rand::rand(*self)\n     }\n \n     /// Return a random int\n-    fn gen_int() -> int {\n+    fn gen_int(&self) -> int {\n         self.gen_i64() as int\n     }\n \n     /**\n      * Return an int randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_int_range(start: int, end: int) -> int {\n+    fn gen_int_range(&self, start: int, end: int) -> int {\n         assert start < end;\n         start + int::abs(self.gen_int() % (end - start))\n     }\n \n     /// Return a random i8\n-    fn gen_i8() -> i8 {\n+    fn gen_i8(&self) -> i8 {\n         self.next() as i8\n     }\n \n     /// Return a random i16\n-    fn gen_i16() -> i16 {\n+    fn gen_i16(&self) -> i16 {\n         self.next() as i16\n     }\n \n     /// Return a random i32\n-    fn gen_i32() -> i32 {\n+    fn gen_i32(&self) -> i32 {\n         self.next() as i32\n     }\n \n     /// Return a random i64\n-    fn gen_i64() -> i64 {\n+    fn gen_i64(&self) -> i64 {\n         (self.next() as i64 << 32) | self.next() as i64\n     }\n \n     /// Return a random uint\n-    fn gen_uint() -> uint {\n+    fn gen_uint(&self) -> uint {\n         self.gen_u64() as uint\n     }\n \n     /**\n      * Return a uint randomly chosen from the range [start, end),\n      * failing if start >= end\n      */\n-    fn gen_uint_range(start: uint, end: uint) -> uint {\n+    fn gen_uint_range(&self, start: uint, end: uint) -> uint {\n         assert start < end;\n         start + (self.gen_uint() % (end - start))\n     }\n \n     /// Return a random u8\n-    fn gen_u8() -> u8 {\n+    fn gen_u8(&self) -> u8 {\n         self.next() as u8\n     }\n \n     /// Return a random u16\n-    fn gen_u16() -> u16 {\n+    fn gen_u16(&self) -> u16 {\n         self.next() as u16\n     }\n \n     /// Return a random u32\n-    fn gen_u32() -> u32 {\n+    fn gen_u32(&self) -> u32 {\n         self.next()\n     }\n \n     /// Return a random u64\n-    fn gen_u64() -> u64 {\n+    fn gen_u64(&self) -> u64 {\n         (self.next() as u64 << 32) | self.next() as u64\n     }\n \n     /// Return a random float in the interval [0,1]\n-    fn gen_float() -> float {\n+    fn gen_float(&self) -> float {\n         self.gen_f64() as float\n     }\n \n     /// Return a random f32 in the interval [0,1]\n-    fn gen_f32() -> f32 {\n+    fn gen_f32(&self) -> f32 {\n         self.gen_f64() as f32\n     }\n \n     /// Return a random f64 in the interval [0,1]\n-    fn gen_f64() -> f64 {\n+    fn gen_f64(&self) -> f64 {\n         let u1 = self.next() as f64;\n         let u2 = self.next() as f64;\n         let u3 = self.next() as f64;\n@@ -235,25 +235,25 @@ pub impl Rng {\n     }\n \n     /// Return a random char\n-    fn gen_char() -> char {\n+    fn gen_char(&self) -> char {\n         self.next() as char\n     }\n \n     /**\n      * Return a char randomly chosen from chars, failing if chars is empty\n      */\n-    fn gen_char_from(chars: &str) -> char {\n+    fn gen_char_from(&self, chars: &str) -> char {\n         assert !chars.is_empty();\n         self.choose(str::chars(chars))\n     }\n \n     /// Return a random bool\n-    fn gen_bool() -> bool {\n+    fn gen_bool(&self) -> bool {\n         self.next() & 1u32 == 1u32\n     }\n \n     /// Return a bool with a 1 in n chance of true\n-    fn gen_weighted_bool(n: uint) -> bool {\n+    fn gen_weighted_bool(&self, n: uint) -> bool {\n         if n == 0u {\n             true\n         } else {\n@@ -264,7 +264,7 @@ pub impl Rng {\n     /**\n      * Return a random string of the specified length composed of A-Z,a-z,0-9\n      */\n-    fn gen_str(len: uint) -> ~str {\n+    fn gen_str(&self, len: uint) -> ~str {\n         let charset = ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                        abcdefghijklmnopqrstuvwxyz\\\n                        0123456789\";\n@@ -278,19 +278,19 @@ pub impl Rng {\n     }\n \n     /// Return a random byte string of the specified length\n-    fn gen_bytes(len: uint) -> ~[u8] {\n+    fn gen_bytes(&self, len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n             self.gen_u8()\n         }\n     }\n \n     /// Choose an item randomly, failing if values is empty\n-    fn choose<T:Copy>(values: &[T]) -> T {\n+    fn choose<T:Copy>(&self, values: &[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n     /// Choose Some(item) randomly, returning None if values is empty\n-    fn choose_option<T:Copy>(values: &[T]) -> Option<T> {\n+    fn choose_option<T:Copy>(&self, values: &[T]) -> Option<T> {\n         if values.is_empty() {\n             None\n         } else {\n@@ -302,15 +302,15 @@ pub impl Rng {\n      * Choose an item respecting the relative weights, failing if the sum of\n      * the weights is 0\n      */\n-    fn choose_weighted<T:Copy>(v : &[Weighted<T>]) -> T {\n+    fn choose_weighted<T:Copy>(&self, v : &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n     /**\n      * Choose Some(item) respecting the relative weights, returning none if\n      * the sum of the weights is 0\n      */\n-    fn choose_weighted_option<T:Copy>(v: &[Weighted<T>]) -> Option<T> {\n+    fn choose_weighted_option<T:Copy>(&self, v: &[Weighted<T>]) -> Option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n             total += item.weight;\n@@ -333,7 +333,7 @@ pub impl Rng {\n      * Return a vec containing copies of the items, in order, where\n      * the weight of the item determines how many copies there are\n      */\n-    fn weighted_vec<T:Copy>(v: &[Weighted<T>]) -> ~[T] {\n+    fn weighted_vec<T:Copy>(&self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n             for uint::range(0u, item.weight) |_i| {\n@@ -344,14 +344,14 @@ pub impl Rng {\n     }\n \n     /// Shuffle a vec\n-    fn shuffle<T:Copy>(values: &[T]) -> ~[T] {\n+    fn shuffle<T:Copy>(&self, values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n         m\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(values: &mut [T]) {\n+    fn shuffle_mut<T>(&self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place.\n@@ -382,7 +382,7 @@ fn RandRes(rng: *rust_rng) -> RandRes {\n }\n \n impl Rng for @RandRes {\n-    fn next() -> u32 {\n+    fn next(&self) -> u32 {\n         unsafe {\n             return rustrt::rand_next((*self).rng);\n         }\n@@ -432,7 +432,7 @@ struct XorShiftState {\n }\n \n impl Rng for XorShiftState {\n-    fn next() -> u32 {\n+    fn next(&self) -> u32 {\n         let x = self.x;\n         let mut t = x ^ (x << 11);\n         self.x = self.y;"}, {"sha": "f29447ef53e338e36191e28751e60920f175b45d", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -26,9 +26,9 @@ use vec;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n-    fn push_ptr();\n-    fn pop_ptr();\n+    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void);\n+    fn push_ptr(&self);\n+    fn pop_ptr(&self);\n }\n \n /// Helper function for alignment calculation.\n@@ -47,26 +47,26 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n \n pub impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline(always)]\n-    fn bump(sz: uint) {\n+    fn bump(&self, sz: uint) {\n       do self.inner.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    fn align(a: uint) {\n+    fn align(&self, a: uint) {\n       do self.inner.move_ptr() |p| {\n             align(p as uint, a) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    fn align_to<T>() {\n+    fn align_to<T>(&self) {\n         self.align(sys::min_align_of::<T>());\n     }\n \n     #[inline(always)]\n-    fn bump_past<T>() {\n+    fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }\n }"}, {"sha": "e68ba26c4c16d5d9aeffcf145b58f37ee9fe0b3a", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -39,11 +39,11 @@ pub use managed::raw::BoxRepr;\n /// Helpers\n \n trait EscapedCharWriter {\n-    fn write_escaped_char(ch: char);\n+    fn write_escaped_char(&self, ch: char);\n }\n \n impl EscapedCharWriter for Writer {\n-    fn write_escaped_char(ch: char) {\n+    fn write_escaped_char(&self, ch: char) {\n         match ch {\n             '\\t' => self.write_str(\"\\\\t\"),\n             '\\r' => self.write_str(\"\\\\r\"),\n@@ -64,68 +64,76 @@ impl EscapedCharWriter for Writer {\n /// Representations\n \n trait Repr {\n-    fn write_repr(writer: @Writer);\n+    fn write_repr(&self, writer: @Writer);\n }\n \n impl Repr for () {\n-    fn write_repr(writer: @Writer) { writer.write_str(\"()\"); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_str(\"()\"); }\n }\n \n impl Repr for bool {\n-    fn write_repr(writer: @Writer) {\n-        writer.write_str(if self { \"true\" } else { \"false\" })\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_str(if *self { \"true\" } else { \"false\" })\n     }\n }\n \n impl Repr for int {\n-    fn write_repr(writer: @Writer) { writer.write_int(self); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_int(*self); }\n }\n impl Repr for i8 {\n-    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n }\n impl Repr for i16 {\n-    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n }\n impl Repr for i32 {\n-    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n }\n impl Repr for i64 {\n     // FIXME #4424: This can lose precision.\n-    fn write_repr(writer: @Writer) { writer.write_int(self as int); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_int(*self as int); }\n }\n \n impl Repr for uint {\n-    fn write_repr(writer: @Writer) { writer.write_uint(self); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_uint(*self); }\n }\n impl Repr for u8 {\n-    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_uint(*self as uint);\n+    }\n }\n impl Repr for u16 {\n-    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_uint(*self as uint);\n+    }\n }\n impl Repr for u32 {\n-    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_uint(*self as uint);\n+    }\n }\n impl Repr for u64 {\n     // FIXME #4424: This can lose precision.\n-    fn write_repr(writer: @Writer) { writer.write_uint(self as uint); }\n+    fn write_repr(&self, writer: @Writer) {\n+        writer.write_uint(*self as uint);\n+    }\n }\n \n impl Repr for float {\n     // FIXME #4423: This mallocs.\n-    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n }\n impl Repr for f32 {\n     // FIXME #4423 This mallocs.\n-    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n }\n impl Repr for f64 {\n     // FIXME #4423: This mallocs.\n-    fn write_repr(writer: @Writer) { writer.write_str(self.to_str()); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_str(self.to_str()); }\n }\n \n impl Repr for char {\n-    fn write_repr(writer: @Writer) { writer.write_char(self); }\n+    fn write_repr(&self, writer: @Writer) { writer.write_char(*self); }\n }\n \n \n@@ -152,13 +160,13 @@ pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n \n impl MovePtr for ReprVisitor {\n     #[inline(always)]\n-    fn move_ptr(adjustment: fn(*c_void) -> *c_void) {\n+    fn move_ptr(&self, adjustment: fn(*c_void) -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n     }\n-    fn push_ptr() {\n+    fn push_ptr(&self) {\n         self.ptr_stk.push(self.ptr);\n     }\n-    fn pop_ptr() {\n+    fn pop_ptr(&self) {\n         self.ptr = self.ptr_stk.pop();\n     }\n }\n@@ -168,32 +176,32 @@ pub impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n     #[inline(always)]\n-    fn get<T>(f: fn(&T)) -> bool {\n+    fn get<T>(&self, f: fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(copy self.ptr));\n         }\n         true\n     }\n \n     #[inline(always)]\n-    fn bump(sz: uint) {\n+    fn bump(&self, sz: uint) {\n       do self.move_ptr() |p| {\n             ((p as uint) + sz) as *c_void\n       };\n     }\n \n     #[inline(always)]\n-    fn bump_past<T>() {\n+    fn bump_past<T>(&self) {\n         self.bump(sys::size_of::<T>());\n     }\n \n     #[inline(always)]\n-    fn visit_inner(inner: *TyDesc) -> bool {\n+    fn visit_inner(&self, inner: *TyDesc) -> bool {\n         self.visit_ptr_inner(self.ptr, inner)\n     }\n \n     #[inline(always)]\n-    fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n+    fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let mut u = ReprVisitor(ptr, self.writer);\n             let v = reflect::MovePtrAdaptor(u);\n@@ -203,21 +211,21 @@ pub impl ReprVisitor {\n     }\n \n     #[inline(always)]\n-    fn write<T:Repr>() -> bool {\n+    fn write<T:Repr>(&self) -> bool {\n         do self.get |v:&T| {\n             v.write_repr(self.writer);\n         }\n     }\n \n-    fn write_escaped_slice(slice: &str) {\n+    fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n         for str::chars_each(slice) |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');\n     }\n \n-    fn write_mut_qualifier(mtbl: uint) {\n+    fn write_mut_qualifier(&self, mtbl: uint) {\n         if mtbl == 0 {\n             self.writer.write_str(\"mut \");\n         } else if mtbl == 1 {\n@@ -228,7 +236,7 @@ pub impl ReprVisitor {\n         }\n     }\n \n-    fn write_vec_range(mtbl: uint, ptr: *u8, len: uint,\n+    fn write_vec_range(&self, mtbl: uint, ptr: *u8, len: uint,\n                        inner: *TyDesc) -> bool {\n         let mut p = ptr;\n         let end = ptr::offset(p, len);\n@@ -249,7 +257,7 @@ pub impl ReprVisitor {\n         true\n     }\n \n-    fn write_unboxed_vec_repr(mtbl: uint, v: &UnboxedVecRepr,\n+    fn write_unboxed_vec_repr(&self, mtbl: uint, v: &UnboxedVecRepr,\n                               inner: *TyDesc) -> bool {\n         self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n                              v.fill, inner)"}, {"sha": "892956e285e06386c27d32bbbf46f0cc01fda31e", "filename": "src/libcore/str.rs", "status": "modified", "additions": 79, "deletions": 65, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -2197,22 +2197,22 @@ pub mod raw {\n }\n \n pub trait Trimmable {\n-    pure fn trim() -> Self;\n-    pure fn trim_left() -> Self;\n-    pure fn trim_right() -> Self;\n+    pure fn trim(&self) -> Self;\n+    pure fn trim_left(&self) -> Self;\n+    pure fn trim_right(&self) -> Self;\n }\n \n /// Extension methods for strings\n impl Trimmable for ~str {\n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    pure fn trim() -> ~str { trim(self) }\n+    pure fn trim(&self) -> ~str { trim(*self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn trim_left() -> ~str { trim_left(self) }\n+    pure fn trim_left(&self) -> ~str { trim_left(*self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    pure fn trim_right() -> ~str { trim_right(self) }\n+    pure fn trim_right(&self) -> ~str { trim_right(*self) }\n }\n \n #[cfg(notest)]\n@@ -2232,35 +2232,35 @@ pub mod traits {\n pub mod traits {}\n \n pub trait StrSlice {\n-    pure fn all(it: fn(char) -> bool) -> bool;\n-    pure fn any(it: fn(char) -> bool) -> bool;\n-    pure fn contains(needle: &a/str) -> bool;\n-    pure fn contains_char(needle: char) -> bool;\n-    pure fn each(it: fn(u8) -> bool);\n-    pure fn eachi(it: fn(uint, u8) -> bool);\n-    pure fn each_char(it: fn(char) -> bool);\n-    pure fn each_chari(it: fn(uint, char) -> bool);\n-    pure fn ends_with(needle: &str) -> bool;\n-    pure fn is_empty() -> bool;\n-    pure fn is_whitespace() -> bool;\n-    pure fn is_alphanumeric() -> bool;\n-    pure fn len() -> uint;\n-    pure fn slice(begin: uint, end: uint) -> ~str;\n-    pure fn split(sepfn: fn(char) -> bool) -> ~[~str];\n-    pure fn split_char(sep: char) -> ~[~str];\n-    pure fn split_str(sep: &a/str) -> ~[~str];\n-    pure fn starts_with(needle: &a/str) -> bool;\n-    pure fn substr(begin: uint, n: uint) -> ~str;\n-    pure fn to_lower() -> ~str;\n-    pure fn to_upper() -> ~str;\n-    pure fn escape_default() -> ~str;\n-    pure fn escape_unicode() -> ~str;\n-    pure fn trim() -> ~str;\n-    pure fn trim_left() -> ~str;\n-    pure fn trim_right() -> ~str;\n-    pure fn to_owned() -> ~str;\n-    pure fn to_managed() -> @str;\n-    pure fn char_at(i: uint) -> char;\n+    pure fn all(&self, it: fn(char) -> bool) -> bool;\n+    pure fn any(&self, it: fn(char) -> bool) -> bool;\n+    pure fn contains(&self, needle: &a/str) -> bool;\n+    pure fn contains_char(&self, needle: char) -> bool;\n+    pure fn each(&self, it: fn(u8) -> bool);\n+    pure fn eachi(&self, it: fn(uint, u8) -> bool);\n+    pure fn each_char(&self, it: fn(char) -> bool);\n+    pure fn each_chari(&self, it: fn(uint, char) -> bool);\n+    pure fn ends_with(&self, needle: &str) -> bool;\n+    pure fn is_empty(&self) -> bool;\n+    pure fn is_whitespace(&self) -> bool;\n+    pure fn is_alphanumeric(&self) -> bool;\n+    pure fn len(&self) -> uint;\n+    pure fn slice(&self, begin: uint, end: uint) -> ~str;\n+    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str];\n+    pure fn split_char(&self, sep: char) -> ~[~str];\n+    pure fn split_str(&self, sep: &a/str) -> ~[~str];\n+    pure fn starts_with(&self, needle: &a/str) -> bool;\n+    pure fn substr(&self, begin: uint, n: uint) -> ~str;\n+    pure fn to_lower(&self) -> ~str;\n+    pure fn to_upper(&self) -> ~str;\n+    pure fn escape_default(&self) -> ~str;\n+    pure fn escape_unicode(&self) -> ~str;\n+    pure fn trim(&self) -> ~str;\n+    pure fn trim_left(&self) -> ~str;\n+    pure fn trim_right(&self) -> ~str;\n+    pure fn to_owned(&self) -> ~str;\n+    pure fn to_managed(&self) -> @str;\n+    pure fn char_at(&self, i: uint) -> char;\n }\n \n /// Extension methods for strings\n@@ -2270,56 +2270,62 @@ impl StrSlice for &str {\n      * contains no characters\n      */\n     #[inline]\n-    pure fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n+    pure fn all(&self, it: fn(char) -> bool) -> bool { all(*self, it) }\n     /**\n      * Return true if a predicate matches any character (and false if it\n      * matches none or there are no characters)\n      */\n     #[inline]\n-    pure fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n+    pure fn any(&self, it: fn(char) -> bool) -> bool { any(*self, it) }\n     /// Returns true if one string contains another\n     #[inline]\n-    pure fn contains(needle: &a/str) -> bool { contains(self, needle) }\n+    pure fn contains(&self, needle: &a/str) -> bool {\n+        contains(*self, needle)\n+    }\n     /// Returns true if a string contains a char\n     #[inline]\n-    pure fn contains_char(needle: char) -> bool {\n-        contains_char(self, needle)\n+    pure fn contains_char(&self, needle: char) -> bool {\n+        contains_char(*self, needle)\n     }\n     /// Iterate over the bytes in a string\n     #[inline]\n-    pure fn each(it: fn(u8) -> bool) { each(self, it) }\n+    pure fn each(&self, it: fn(u8) -> bool) { each(*self, it) }\n     /// Iterate over the bytes in a string, with indices\n     #[inline]\n-    pure fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n+    pure fn eachi(&self, it: fn(uint, u8) -> bool) { eachi(*self, it) }\n     /// Iterate over the chars in a string\n     #[inline]\n-    pure fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n+    pure fn each_char(&self, it: fn(char) -> bool) { each_char(*self, it) }\n     /// Iterate over the chars in a string, with indices\n     #[inline]\n-    pure fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n+    pure fn each_chari(&self, it: fn(uint, char) -> bool) {\n+        each_chari(*self, it)\n+    }\n     /// Returns true if one string ends with another\n     #[inline]\n-    pure fn ends_with(needle: &str) -> bool { ends_with(self, needle) }\n+    pure fn ends_with(&self, needle: &str) -> bool {\n+        ends_with(*self, needle)\n+    }\n     /// Returns true if the string has length 0\n     #[inline]\n-    pure fn is_empty() -> bool { is_empty(self) }\n+    pure fn is_empty(&self) -> bool { is_empty(*self) }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n      * Whitespace characters are determined by `char::is_whitespace`\n      */\n     #[inline]\n-    pure fn is_whitespace() -> bool { is_whitespace(self) }\n+    pure fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n     /**\n      * Returns true if the string contains only alphanumerics\n      *\n      * Alphanumeric characters are determined by `char::is_alphanumeric`\n      */\n     #[inline]\n-    pure fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n+    pure fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n     #[inline]\n     /// Returns the size in bytes not counting the null terminator\n-    pure fn len() -> uint { len(self) }\n+    pure fn len(&self) -> uint { len(*self) }\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -2328,68 +2334,76 @@ impl StrSlice for &str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice(begin: uint, end: uint) -> ~str { slice(self, begin, end) }\n+    pure fn slice(&self, begin: uint, end: uint) -> ~str {\n+        slice(*self, begin, end)\n+    }\n     /// Splits a string into substrings using a character function\n     #[inline]\n-    pure fn split(sepfn: fn(char) -> bool) -> ~[~str] { split(self, sepfn) }\n+    pure fn split(&self, sepfn: fn(char) -> bool) -> ~[~str] {\n+        split(*self, sepfn)\n+    }\n     /**\n      * Splits a string into substrings at each occurrence of a given character\n      */\n     #[inline]\n-    pure fn split_char(sep: char) -> ~[~str] { split_char(self, sep) }\n+    pure fn split_char(&self, sep: char) -> ~[~str] { split_char(*self, sep) }\n     /**\n      * Splits a string into a vector of the substrings separated by a given\n      * string\n      */\n     #[inline]\n-    pure fn split_str(sep: &a/str) -> ~[~str] { split_str(self, sep) }\n+    pure fn split_str(&self, sep: &a/str) -> ~[~str] { split_str(*self, sep) }\n     /// Returns true if one string starts with another\n     #[inline]\n-    pure fn starts_with(needle: &a/str) -> bool { starts_with(self, needle) }\n+    pure fn starts_with(&self, needle: &a/str) -> bool {\n+        starts_with(*self, needle)\n+    }\n     /**\n      * Take a substring of another.\n      *\n      * Returns a string containing `n` characters starting at byte offset\n      * `begin`.\n      */\n     #[inline]\n-    pure fn substr(begin: uint, n: uint) -> ~str { substr(self, begin, n) }\n+    pure fn substr(&self, begin: uint, n: uint) -> ~str {\n+        substr(*self, begin, n)\n+    }\n     /// Convert a string to lowercase\n     #[inline]\n-    pure fn to_lower() -> ~str { to_lower(self) }\n+    pure fn to_lower(&self) -> ~str { to_lower(*self) }\n     /// Convert a string to uppercase\n     #[inline]\n-    pure fn to_upper() -> ~str { to_upper(self) }\n+    pure fn to_upper(&self) -> ~str { to_upper(*self) }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n-    pure fn escape_default() -> ~str { escape_default(self) }\n+    pure fn escape_default(&self) -> ~str { escape_default(*self) }\n     /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n-    pure fn escape_unicode() -> ~str { escape_unicode(self) }\n+    pure fn escape_unicode(&self) -> ~str { escape_unicode(*self) }\n \n     /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n-    pure fn trim() -> ~str { trim(self) }\n+    pure fn trim(&self) -> ~str { trim(*self) }\n     /// Returns a string with leading whitespace removed\n     #[inline]\n-    pure fn trim_left() -> ~str { trim_left(self) }\n+    pure fn trim_left(&self) -> ~str { trim_left(*self) }\n     /// Returns a string with trailing whitespace removed\n     #[inline]\n-    pure fn trim_right() -> ~str { trim_right(self) }\n+    pure fn trim_right(&self) -> ~str { trim_right(*self) }\n \n     #[inline]\n-    pure fn to_owned() -> ~str { self.slice(0, self.len()) }\n+    pure fn to_owned(&self) -> ~str { self.slice(0, self.len()) }\n \n     #[inline]\n-    pure fn to_managed() -> @str {\n+    pure fn to_managed(&self) -> @str {\n         let v = at_vec::from_fn(self.len() + 1, |i| {\n             if i == self.len() { 0 } else { self[i] }\n         });\n         unsafe { ::cast::transmute(v) }\n     }\n \n     #[inline]\n-    pure fn char_at(i: uint) -> char { char_at(self, i) }\n+    pure fn char_at(&self, i: uint) -> char { char_at(*self, i) }\n }\n \n pub trait OwnedStr {"}, {"sha": "e3bc799dfabbeaf779e53001096b23ceb3fcbd1d", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -204,7 +204,7 @@ pub fn task() -> TaskBuilder {\n \n #[doc(hidden)] // FIXME #3538\n priv impl TaskBuilder {\n-    fn consume() -> TaskBuilder {\n+    fn consume(&self) -> TaskBuilder {\n         if self.consumed {\n             fail!(~\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n@@ -229,7 +229,7 @@ pub impl TaskBuilder {\n      * Decouple the child task's failure from the parent's. If either fails,\n      * the other will not be killed.\n      */\n-    fn unlinked() -> TaskBuilder {\n+    fn unlinked(&self) -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -247,7 +247,7 @@ pub impl TaskBuilder {\n      * child's failure will not kill the parent, but the parent's will kill\n      * the child.\n      */\n-    fn supervised() -> TaskBuilder {\n+    fn supervised(&self) -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -264,7 +264,7 @@ pub impl TaskBuilder {\n      * Link the child task's and parent task's failures. If either fails, the\n      * other will be killed.\n      */\n-    fn linked() -> TaskBuilder {\n+    fn linked(&self) -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -295,7 +295,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn future_result(blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n+    fn future_result(&self, blk: fn(v: Port<TaskResult>)) -> TaskBuilder {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -323,7 +323,7 @@ pub impl TaskBuilder {\n         }\n     }\n     /// Configure a custom scheduler mode for the task.\n-    fn sched_mode(mode: SchedMode) -> TaskBuilder {\n+    fn sched_mode(&self, mode: SchedMode) -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -349,7 +349,7 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(wrapper: @fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n+    fn add_wrapper(&self, wrapper: @fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n@@ -377,7 +377,7 @@ pub impl TaskBuilder {\n      * When spawning into a new scheduler, the number of threads requested\n      * must be greater than zero.\n      */\n-    fn spawn(f: ~fn()) {\n+    fn spawn(&self, f: ~fn()) {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n         let opts = TaskOpts {\n@@ -389,7 +389,7 @@ pub impl TaskBuilder {\n         spawn::spawn_raw(opts, (x.gen_body)(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n-    fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n+    fn spawn_with<A:Owned>(&self, arg: A, f: ~fn(v: A)) {\n         let arg = Cell(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -409,7 +409,7 @@ pub impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n+    fn try<T:Owned>(&self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n "}, {"sha": "15fe2a52461795a81d6b27f374a2fdb02f568245", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -16,31 +16,31 @@ use vec;\n #[cfg(notest)] use cmp::{Eq, Ord};\n \n pub trait CopyableTuple<T, U> {\n-    pure fn first() -> T;\n-    pure fn second() -> U;\n-    pure fn swap() -> (U, T);\n+    pure fn first(&self) -> T;\n+    pure fn second(&self) -> U;\n+    pure fn swap(&self) -> (U, T);\n }\n \n impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n \n     /// Return the first element of self\n     #[inline(always)]\n-    pure fn first() -> T {\n-        let (t, _) = self;\n+    pure fn first(&self) -> T {\n+        let (t, _) = *self;\n         return t;\n     }\n \n     /// Return the second element of self\n     #[inline(always)]\n-    pure fn second() -> U {\n-        let (_, u) = self;\n+    pure fn second(&self) -> U {\n+        let (_, u) = *self;\n         return u;\n     }\n \n     /// Return the results of swapping the two elements of self\n     #[inline(always)]\n-    pure fn swap() -> (U, T) {\n-        let (t, u) = self;\n+    pure fn swap(&self) -> (U, T) {\n+        let (t, u) = *self;\n         return (u, t);\n     }\n "}, {"sha": "08328c5af8a1610d03f032bb0af24d7ae9ed1adb", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -140,7 +140,7 @@ pub mod ct {\n     }\n \n     pub impl<T> Parsed<T> {\n-        static pure fn new(val: T, next: uint) -> Parsed<T> {\n+        static pure fn new(&self, val: T, next: uint) -> Parsed<T> {\n             Parsed {val: val, next: next}\n         }\n     }"}, {"sha": "14a37ecbf520fffc99995740dc4c3d1078ec764e", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -26,35 +26,35 @@ pub struct DuplexStream<T, U> {\n }\n \n impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n-    fn send(x: T) {\n+    fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n }\n \n impl<T:Owned,U:Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n-    fn try_send(x: T) -> bool {\n+    fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n }\n \n impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n-    fn recv() -> U {\n+    fn recv(&self) -> U {\n         self.port.recv()\n     }\n \n-    fn try_recv() -> Option<U> {\n+    fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n }\n \n impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n-    pure fn peek() -> bool {\n+    pure fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n \n impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n-    pure fn header() -> *pipes::PacketHeader {\n+    pure fn header(&self) -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "8f6ec2b9cd96ec50d0a72a0eb2f1f42d9b6eba40", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afd6196d7b87401d20dc5149c6955e2c9758657f/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=afd6196d7b87401d20dc5149c6955e2c9758657f", "patch": "@@ -257,13 +257,13 @@ pub trait ByteChan {\n const CONTINUE: [u8 * 4] = [0xAA, 0xBB, 0xCC, 0xDD];\n \n impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n-    fn recv() -> T {\n+    fn recv(&self) -> T {\n         match self.try_recv() {\n             Some(val) => val,\n             None => fail!(~\"port is closed\")\n         }\n     }\n-    fn try_recv() -> Option<T> {\n+    fn try_recv(&self) -> Option<T> {\n         let command = match self.byte_port.try_recv(CONTINUE.len()) {\n             Some(c) => c,\n             None => {\n@@ -302,7 +302,7 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n }\n \n impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n-    fn send(val: T) {\n+    fn send(&self, val: T) {\n         self.byte_chan.send(CONTINUE.to_vec());\n         let bytes = self.flattener.flatten(val);\n         let len = bytes.len() as u64;"}]}