{"sha": "01ded5898b1863e195856d2678323315ae224463", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZGVkNTg5OGIxODYzZTE5NTg1NmQyNjc4MzIzMzE1YWUyMjQ0NjM=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-02T11:53:48Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-11-03T13:20:37Z"}, "message": "Simplify float string conversion function further\n\nWe now have a really simple function signature:\n\n    pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T>\n\nBy removing some of the arguments, we remove the possibility of some invalid states.", "tree": {"sha": "688bf560f5c97979d30bad045f1485efb5576116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/688bf560f5c97979d30bad045f1485efb5576116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ded5898b1863e195856d2678323315ae224463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ded5898b1863e195856d2678323315ae224463", "html_url": "https://github.com/rust-lang/rust/commit/01ded5898b1863e195856d2678323315ae224463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ded5898b1863e195856d2678323315ae224463/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/84f4b58eeb12f1fcf46c67029f09a21dd6506b22", "html_url": "https://github.com/rust-lang/rust/commit/84f4b58eeb12f1fcf46c67029f09a21dd6506b22"}], "stats": {"total": 276, "additions": 115, "deletions": 161}, "files": [{"sha": "ebb1aee816e243b570fb66b14945b10ecbe9d234", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=01ded5898b1863e195856d2678323315ae224463", "patch": "@@ -359,8 +359,8 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n /// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n-pub fn from_str_hex(num: &str) -> Option<f32> {\n-    strconv::from_str_float(num, 16u, true, strconv::ExpBin)\n+pub fn from_str_hex(src: &str) -> Option<f32> {\n+    strconv::from_str_radix_float(src, 16u)\n }\n \n impl FromStr for f32 {\n@@ -390,8 +390,8 @@ impl FromStr for f32 {\n     /// `None` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n-    fn from_str(val: &str) -> Option<f32> {\n-        strconv::from_str_float(val, 10u, true, strconv::ExpDec)\n+    fn from_str(src: &str) -> Option<f32> {\n+        strconv::from_str_radix_float(src, 10u)\n     }\n }\n \n@@ -414,8 +414,8 @@ impl num::FromStrRadix for f32 {\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f32> {\n-        strconv::from_str_float(val, rdx, false, strconv::ExpNone)\n+    fn from_str_radix(src: &str, radix: uint) -> Option<f32> {\n+        strconv::from_str_radix_float(src, radix)\n     }\n }\n "}, {"sha": "e1a46f5710f50937a3e7441e9456c6e9a9b2ba4c", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=01ded5898b1863e195856d2678323315ae224463", "patch": "@@ -368,7 +368,7 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n #[inline]\n pub fn from_str_hex(num: &str) -> Option<f64> {\n-    strconv::from_str_float(num, 16u, true, strconv::ExpBin)\n+    strconv::from_str_radix_float(num, 16u)\n }\n \n impl FromStr for f64 {\n@@ -399,7 +399,7 @@ impl FromStr for f64 {\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n     fn from_str(val: &str) -> Option<f64> {\n-        strconv::from_str_float(val, 10u, true, strconv::ExpDec)\n+        strconv::from_str_radix_float(val, 10u)\n     }\n }\n \n@@ -422,8 +422,8 @@ impl num::FromStrRadix for f64 {\n     /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     #[inline]\n-    fn from_str_radix(val: &str, rdx: uint) -> Option<f64> {\n-        strconv::from_str_float(val, rdx, false, strconv::ExpNone)\n+    fn from_str_radix(val: &str, radix: uint) -> Option<f64> {\n+        strconv::from_str_radix_float(val, radix)\n     }\n }\n "}, {"sha": "7a02d8d77b0b1db19b9bbf8e1e6f903c7a231aba", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 105, "deletions": 151, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ded5898b1863e195856d2678323315ae224463/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=01ded5898b1863e195856d2678323315ae224463", "patch": "@@ -424,69 +424,18 @@ pub fn float_to_str_common<T: Float>(\n // Some constants for from_str_bytes_common's input validation,\n // they define minimum radix values for which the character is a valid digit.\n static DIGIT_P_RADIX: uint = ('p' as uint) - ('a' as uint) + 11u;\n-static DIGIT_I_RADIX: uint = ('i' as uint) - ('a' as uint) + 11u;\n static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n \n-/**\n- * Parses a string as a number. This is meant to\n- * be a common base implementation for all numeric string conversion\n- * functions like `from_str()` or `from_str_radix()`.\n- *\n- * # Arguments\n- * - `src`        - The string to parse.\n- * - `radix`      - Which base to parse the number as. Accepts 2-36.\n- * - `special`    - Whether to accept special values like `inf`\n- *                  and `NaN`. Can conflict with `radix`, see Failure.\n- * - `exponent`   - Which exponent format to accept. Options are:\n- *     - `ExpNone`: No Exponent, accepts just plain numbers like `42` or\n- *                  `-8.2`.\n- *     - `ExpDec`:  Accepts numbers with a decimal exponent like `42e5` or\n- *                  `8.2E-2`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- *     - `ExpBin`:  Accepts numbers with a binary exponent like `42P-8` or\n- *                  `FFp128`. The exponent string itself is always base 10.\n- *                  Can conflict with `radix`, see Failure.\n- *\n- * # Return value\n- * Returns `Some(n)` if `buf` parses to a number n without overflowing, and\n- * `None` otherwise, depending on the constraints set by the remaining\n- * arguments.\n- *\n- * # Failure\n- * - Fails if `radix` < 2 or `radix` > 36.\n- * - Fails if `radix` > 14 and `exponent` is `ExpDec` due to conflict\n- *   between digit and exponent sign `'e'`.\n- * - Fails if `radix` > 25 and `exponent` is `ExpBin` due to conflict\n- *   between digit and exponent sign `'p'`.\n- * - Fails if `radix` > 18 and `special == true` due to conflict\n- *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n- */\n-pub fn from_str_float<T: Float>(\n-        src: &str, radix: uint, special: bool, exponent: ExponentFormat,\n-        ) -> Option<T> {\n-    match exponent {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        ExpBin if radix >= DIGIT_P_RADIX       // binary exponent 'p'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    use of 'p' as binary exponent\", radix),\n-        _ if special && radix >= DIGIT_I_RADIX // first digit of 'inf'\n-          => panic!(\"from_str_bytes_common: radix {} incompatible with \\\n-                    special values 'inf' and 'NaN'\", radix),\n-        _ if (radix as int) < 2\n-          => panic!(\"from_str_bytes_common: radix {} to low, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ if (radix as int) > 36\n-          => panic!(\"from_str_bytes_common: radix {} to high, \\\n-                    must lie in the range [2, 36]\", radix),\n-        _ => ()\n-    }\n+pub fn from_str_radix_float<T: Float>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_float: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n \n     let _0: T = num::zero();\n     let _1: T = num::one();\n-    let radix_gen: T = num::cast(radix as int).unwrap();\n+    let radix_t: T = num::cast(radix as int).unwrap();\n \n+    // Special values\n     match src {\n         \"inf\"   => return Some(Float::infinity()),\n         \"-inf\"  => return Some(Float::neg_infinity()),\n@@ -501,125 +450,131 @@ pub fn from_str_float<T: Float>(\n         (Some(_), _)     => (true,  src),\n     };\n \n-    // Initialize accumulator with signed zero for floating point parsing to\n-    // work\n-    let mut accum      = if is_positive { _0 } else { -_1 };\n-    let mut last_accum = accum; // Necessary to detect overflow\n-    let mut cs         = src.chars().enumerate();\n-    let mut exp        = None::<(char, uint)>;\n+    // The significand to accumulate\n+    let mut sig = if is_positive { _0 } else { -_1 };\n+    // Necessary to detect overflow\n+    let mut prev_sig = sig;\n+    let mut cs = src.chars().enumerate();\n+    // Exponent prefix and exponent index offset\n+    let mut exp_info = None::<(char, uint)>;\n \n-    // Parse integer part of number\n+    // Parse the integer part of the significand\n     for (i, c) in cs {\n-        match c {\n-            'e' | 'E' | 'p' | 'P' => {\n-                exp = Some((c, i + 1));\n-                break;  // start of exponent\n-            },\n-            '.' => {\n-                break;  // start of fractional part\n-            },\n-            c => match c.to_digit(radix) {\n-                Some(digit) => {\n-                    // shift accum one digit left\n-                    accum = accum * radix_gen;\n-\n-                    // add/subtract current digit depending on sign\n-                    if is_positive {\n-                        accum = accum + num::cast(digit as int).unwrap();\n-                    } else {\n-                        accum = accum - num::cast(digit as int).unwrap();\n-                    }\n+        match c.to_digit(radix) {\n+            Some(digit) => {\n+                // shift significand one digit left\n+                sig = sig * radix_t;\n+\n+                // add/subtract current digit depending on sign\n+                if is_positive {\n+                    sig = sig + num::cast(digit as int).unwrap();\n+                } else {\n+                    sig = sig - num::cast(digit as int).unwrap();\n+                }\n \n-                    // Detect overflow by comparing to last value, except\n-                    // if we've not seen any non-zero digits.\n-                    if last_accum != _0 {\n-                        if  is_positive && accum <= last_accum { return Some(Float::infinity());     }\n-                        if !is_positive && accum >= last_accum { return Some(Float::neg_infinity()); }\n-\n-                        // Detect overflow by reversing the shift-and-add process\n-                        if is_positive &&\n-                            (last_accum != ((accum - num::cast(digit as int).unwrap()) / radix_gen)) {\n-                            return Some(Float::infinity());\n-                        }\n-                        if !is_positive &&\n-                            (last_accum != ((accum + num::cast(digit as int).unwrap()) / radix_gen)) {\n-                            return Some(Float::neg_infinity());\n-                        }\n-                    }\n-                    last_accum = accum;\n+                // Detect overflow by comparing to last value, except\n+                // if we've not seen any non-zero digits.\n+                if prev_sig != _0 {\n+                    if is_positive && sig <= prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig >= prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+\n+                    // Detect overflow by reversing the shift-and-add process\n+                    let digit: T = num::cast(digit as int).unwrap();\n+                    if is_positive && (prev_sig != ((sig - digit) / radix_t))\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && (prev_sig != ((sig + digit) / radix_t))\n+                        { return Some(Float::neg_infinity()); }\n+                }\n+                prev_sig = sig;\n+            },\n+            None => match c {\n+                'e' | 'E' | 'p' | 'P' => {\n+                    exp_info = Some((c, i + 1));\n+                    break;  // start of exponent\n+                },\n+                '.' => {\n+                    break;  // start of fractional part\n                 },\n-                None => {\n-                    return None; // invalid number\n+                _ => {\n+                    return None;\n                 },\n             },\n         }\n     }\n \n-    // Parse fractional part of number\n-    // Skip if already reached start of exponent\n-    if exp.is_none() {\n+    // If we are not yet at the exponent parse the fractional\n+    // part of the significand\n+    if exp_info.is_none() {\n         let mut power = _1;\n         for (i, c) in cs {\n-            match c {\n-                'e' | 'E' | 'p' | 'P' => {\n-                    exp = Some((c, i + 1));\n-                    break; // start of exponent\n+            match c.to_digit(radix) {\n+                Some(digit) => {\n+                    let digit: T = num::cast(digit).unwrap();\n+                    // Decrease power one order of magnitude\n+                    power = power / radix_t;\n+                    // add/subtract current digit depending on sign\n+                    sig = if is_positive {\n+                        sig + digit * power\n+                    } else {\n+                        sig - digit * power\n+                    };\n+                    // Detect overflow by comparing to last value\n+                    if is_positive && sig < prev_sig\n+                        { return Some(Float::infinity()); }\n+                    if !is_positive && sig > prev_sig\n+                        { return Some(Float::neg_infinity()); }\n+                    prev_sig = sig;\n                 },\n-                c => match c.to_digit(radix) {\n-                    Some(digit) => {\n-                        let digit: T = num::cast(digit).unwrap();\n-\n-                        // Decrease power one order of magnitude\n-                        power = power / radix_gen;\n-                        // add/subtract current digit depending on sign\n-                        accum = if is_positive {\n-                            accum + digit * power\n-                        } else {\n-                            accum - digit * power\n-                        };\n-                        // Detect overflow by comparing to last value\n-                        if  is_positive && accum < last_accum { return Some(Float::infinity());     }\n-                        if !is_positive && accum > last_accum { return Some(Float::neg_infinity()); }\n-                        last_accum = accum;\n+                None => match c {\n+                    'e' | 'E' | 'p' | 'P' => {\n+                        exp_info = Some((c, i + 1));\n+                        break; // start of exponent\n                     },\n-                    None => {\n+                    _ => {\n                         return None; // invalid number\n                     },\n                 },\n             }\n         }\n     }\n \n-    let multiplier = match exp {\n-        None => {\n-            _1 // no exponent\n-        },\n+    // Parse and calculate the exponent\n+    let exp = match exp_info {\n         Some((c, offset)) => {\n-            let base: T = match (c, exponent) {\n-                // c is never _ so don't need to handle specially\n-                ('e', ExpDec) | ('E', ExpDec) => num::cast(10u).unwrap(),\n-                ('p', ExpBin) | ('P', ExpBin) => num::cast(2u).unwrap(),\n-                _ => return None, // char doesn't fit given exponent format\n+            let base: T = match c {\n+                'E' | 'e' if radix == 10 => num::cast(10u).unwrap(),\n+                'P' | 'p' if radix == 16 => num::cast(2u).unwrap(),\n+                _ => return None,\n             };\n-            // parse remaining string as decimal integer\n-            let exp = from_str::<int>(src[offset..]);\n-            match exp {\n-                Some(exp_pow) if exp_pow < 0 => {\n-                    _1 / num::pow(base, (-exp_pow.to_int().unwrap()) as uint)\n-                },\n-                Some(exp_pow) => {\n-                    num::pow(base, exp_pow.to_int().unwrap() as uint)\n-                },\n-                None => {\n-                    return None; // invalid exponent\n-                },\n+\n+            // Parse the exponent as decimal integer\n+            let src = src[offset..];\n+            let (is_positive, exp) = match src.slice_shift_char() {\n+                (Some('-'), src) => (false, from_str::<uint>(src)),\n+                (Some('+'), src) => (true,  from_str::<uint>(src)),\n+                (Some(_), _)     => (true,  from_str::<uint>(src)),\n+                (None, _)        => return None,\n+            };\n+\n+            match (is_positive, exp) {\n+                (true,  Some(exp)) => num::pow(base, exp),\n+                (false, Some(exp)) => _1 / num::pow(base, exp),\n+                (_, None)          => return None,\n             }\n         },\n+        None => _1, // no exponent\n     };\n-    Some(accum * multiplier)\n+\n+    Some(sig * exp)\n }\n \n pub fn from_str_radix_int<T: Int>(src: &str, radix: uint) -> Option<T> {\n+   assert!(radix >= 2 && radix <= 36,\n+           \"from_str_radix_int: must lie in the range `[2, 36]` - found {}\",\n+           radix);\n+\n     fn cast<T: Int>(x: uint) -> T {\n         num::cast(x).unwrap()\n     }\n@@ -687,10 +642,9 @@ mod test {\n         assert_eq!(u, None);\n         let s : Option<i16> = from_str_radix_int(\"80000\", 10);\n         assert_eq!(s, None);\n-        let f : Option<f32> = from_str_float(\n-            \"10000000000000000000000000000000000000000\", 10, false, ExpNone);\n+        let f : Option<f32> = from_str_radix_float(\"10000000000000000000000000000000000000000\", 10);\n         assert_eq!(f, Some(Float::infinity()))\n-        let fe : Option<f32> = from_str_float(\"1e40\", 10, false, ExpDec);\n+        let fe : Option<f32> = from_str_radix_float(\"1e40\", 10);\n         assert_eq!(fe, Some(Float::infinity()))\n     }\n }"}]}