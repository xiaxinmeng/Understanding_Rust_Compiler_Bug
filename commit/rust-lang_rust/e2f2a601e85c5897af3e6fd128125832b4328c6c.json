{"sha": "e2f2a601e85c5897af3e6fd128125832b4328c6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZjJhNjAxZTg1YzU4OTdhZjNlNmZkMTI4MTI1ODMyYjQzMjhjNmM=", "commit": {"author": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-08-31T18:26:01Z"}, "committer": {"name": "Steven Stewart-Gallus", "email": "sstewartgallus00@mylangara.bc.ca", "date": "2013-08-31T18:26:01Z"}, "message": "Cleanup concurrency tests\n\nIn this commit I:\n- removed unneeded heap allocations\n- added extra whitespace to crowded expressions\n- and removed unneeded syntax", "tree": {"sha": "3f441de9b1596b3243e41c33ac18aea145a50653", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f441de9b1596b3243e41c33ac18aea145a50653"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2f2a601e85c5897af3e6fd128125832b4328c6c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2f2a601e85c5897af3e6fd128125832b4328c6c", "html_url": "https://github.com/rust-lang/rust/commit/e2f2a601e85c5897af3e6fd128125832b4328c6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2f2a601e85c5897af3e6fd128125832b4328c6c/comments", "author": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mstewartgallus", "id": 4070335, "node_id": "MDQ6VXNlcjQwNzAzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4070335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mstewartgallus", "html_url": "https://github.com/mstewartgallus", "followers_url": "https://api.github.com/users/mstewartgallus/followers", "following_url": "https://api.github.com/users/mstewartgallus/following{/other_user}", "gists_url": "https://api.github.com/users/mstewartgallus/gists{/gist_id}", "starred_url": "https://api.github.com/users/mstewartgallus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mstewartgallus/subscriptions", "organizations_url": "https://api.github.com/users/mstewartgallus/orgs", "repos_url": "https://api.github.com/users/mstewartgallus/repos", "events_url": "https://api.github.com/users/mstewartgallus/events{/privacy}", "received_events_url": "https://api.github.com/users/mstewartgallus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89d04009c160b7a88b03f42c633220457bd72a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/89d04009c160b7a88b03f42c633220457bd72a09", "html_url": "https://github.com/rust-lang/rust/commit/89d04009c160b7a88b03f42c633220457bd72a09"}], "stats": {"total": 307, "additions": 153, "deletions": 154}, "files": [{"sha": "2ccbe396f8fd5d8579bdbcaafaac740b0b333d39", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e2f2a601e85c5897af3e6fd128125832b4328c6c/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f2a601e85c5897af3e6fd128125832b4328c6c/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=e2f2a601e85c5897af3e6fd128125832b4328c6c", "patch": "@@ -572,10 +572,10 @@ mod tests {\n \n         let (p, c) = comm::stream();\n \n-        do task::spawn() || {\n-            let arc_v : Arc<~[int]> = p.recv();\n+        do task::spawn {\n+            let arc_v: Arc<~[int]> = p.recv();\n \n-            let v = (*arc_v.get()).clone();\n+            let v = arc_v.get().clone();\n             assert_eq!(v[3], 4);\n         };\n \n@@ -590,11 +590,11 @@ mod tests {\n     #[test]\n     fn test_mutex_arc_condvar() {\n         unsafe {\n-            let arc = ~MutexArc::new(false);\n-            let arc2 = ~arc.clone();\n-            let (p,c) = comm::oneshot();\n-            let (c,p) = (Cell::new(c), Cell::new(p));\n-            do task::spawn || {\n+            let arc = MutexArc::new(false);\n+            let arc2 = arc.clone();\n+            let (p, c) = comm::oneshot();\n+            let (c, p) = (Cell::new(c), Cell::new(p));\n+            do task::spawn {\n                 // wait until parent gets in\n                 p.take().recv();\n                 do arc2.access_cond |state, cond| {\n@@ -615,11 +615,11 @@ mod tests {\n     #[test] #[should_fail]\n     fn test_arc_condvar_poison() {\n         unsafe {\n-            let arc = ~MutexArc::new(1);\n-            let arc2 = ~arc.clone();\n+            let arc = MutexArc::new(1);\n+            let arc2 = arc.clone();\n             let (p, c) = comm::stream();\n \n-            do task::spawn_unlinked || {\n+            do task::spawn_unlinked {\n                 let _ = p.recv();\n                 do arc2.access_cond |one, cond| {\n                     cond.signal();\n@@ -639,9 +639,9 @@ mod tests {\n     #[test] #[should_fail]\n     fn test_mutex_arc_poison() {\n         unsafe {\n-            let arc = ~MutexArc::new(1);\n-            let arc2 = ~arc.clone();\n-            do task::try || {\n+            let arc = MutexArc::new(1);\n+            let arc2 = arc.clone();\n+            do task::try {\n                 do arc2.access |one| {\n                     assert_eq!(*one, 2);\n                 }\n@@ -654,7 +654,7 @@ mod tests {\n     #[test] #[should_fail]\n     pub fn test_mutex_arc_unwrap_poison() {\n         let arc = MutexArc::new(1);\n-        let arc2 = ~(&arc).clone();\n+        let arc2 = arc.clone();\n         let (p, c) = comm::stream();\n         do task::spawn {\n             unsafe {\n@@ -670,9 +670,9 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_wr() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.write |one| {\n                 assert_eq!(*one, 2);\n             }\n@@ -683,9 +683,9 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_ww() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.write |one| {\n                 assert_eq!(*one, 2);\n             }\n@@ -696,9 +696,9 @@ mod tests {\n     }\n     #[test] #[should_fail]\n     fn test_rw_arc_poison_dw() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.write_downgrade |mut write_mode| {\n                 do write_mode.write |one| {\n                     assert_eq!(*one, 2);\n@@ -711,9 +711,9 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rr() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.read |one| {\n                 assert_eq!(*one, 2);\n             }\n@@ -724,9 +724,9 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_rw() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.read |one| {\n                 assert_eq!(*one, 2);\n             }\n@@ -737,12 +737,12 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc_no_poison_dr() {\n-        let arc = ~RWArc::new(1);\n-        let arc2 = (*arc).clone();\n-        do task::try || {\n+        let arc = RWArc::new(1);\n+        let arc2 = arc.clone();\n+        do task::try {\n             do arc2.write_downgrade |write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n-                do (&read_mode).read |one| {\n+                do read_mode.read |one| {\n                     assert_eq!(*one, 2);\n                 }\n             }\n@@ -753,11 +753,11 @@ mod tests {\n     }\n     #[test]\n     fn test_rw_arc() {\n-        let arc = ~RWArc::new(0);\n-        let arc2 = (*arc).clone();\n-        let (p,c) = comm::stream();\n+        let arc = RWArc::new(0);\n+        let arc2 = arc.clone();\n+        let (p, c) = comm::stream();\n \n-        do task::spawn || {\n+        do task::spawn {\n             do arc2.write |num| {\n                 do 10.times {\n                     let tmp = *num;\n@@ -772,7 +772,7 @@ mod tests {\n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n         do 5.times {\n-            let arc3 = (*arc).clone();\n+            let arc3 = arc.clone();\n             let mut builder = task::task();\n             builder.future_result(|r| children.push(r));\n             do builder.spawn {\n@@ -801,15 +801,15 @@ mod tests {\n         // (4) tells writer and all other readers to contend as it downgrades.\n         // (5) Writer attempts to set state back to 42, while downgraded task\n         //     and all reader tasks assert that it's 31337.\n-        let arc = ~RWArc::new(0);\n+        let arc = RWArc::new(0);\n \n         // Reader tasks\n         let mut reader_convos = ~[];\n         do 10.times {\n-            let ((rp1,rc1),(rp2,rc2)) = (comm::stream(),comm::stream());\n+            let ((rp1, rc1), (rp2, rc2)) = (comm::stream(), comm::stream());\n             reader_convos.push((rc1, rp2));\n-            let arcn = (*arc).clone();\n-            do task::spawn || {\n+            let arcn = arc.clone();\n+            do task::spawn {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 do arcn.read |state| {\n                     assert_eq!(*state, 31337);\n@@ -819,8 +819,8 @@ mod tests {\n         }\n \n         // Writer task\n-        let arc2 = (*arc).clone();\n-        let ((wp1,wc1),(wp2,wc2)) = (comm::stream(),comm::stream());\n+        let arc2 = arc.clone();\n+        let ((wp1, wc1), (wp2, wc2)) = (comm::stream(), comm::stream());\n         do task::spawn || {\n             wp1.recv();\n             do arc2.write_cond |state, cond| {\n@@ -853,7 +853,7 @@ mod tests {\n                 }\n             }\n             let read_mode = arc.downgrade(write_mode);\n-            do (&read_mode).read |state| {\n+            do read_mode.read |state| {\n                 // complete handshake with other readers\n                 for &(_, ref rp) in reader_convos.iter() {\n                     rp.recv()\n@@ -876,11 +876,11 @@ mod tests {\n         // line in RWLock::write_cond() that looks like:\n         //     \"blk(&Condvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n-        let x = ~RWArc::new(true);\n+        let x = RWArc::new(true);\n         let (wp, wc) = comm::stream();\n \n         // writer task\n-        let xw = (*x).clone();\n+        let xw = x.clone();\n         do task::spawn {\n             do xw.write_cond |state, c| {\n                 wc.send(()); // tell downgrader it's ok to go\n@@ -901,7 +901,7 @@ mod tests {\n                 c.signal();\n             }\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n-            let xr = (*x).clone();\n+            let xr = x.clone();\n             let (rp, rc) = comm::stream();\n             do task::spawn {\n                 rc.send(());"}, {"sha": "99235e3029cc43b663335838087c762bab3cfba2", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 104, "deletions": 105, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/e2f2a601e85c5897af3e6fd128125832b4328c6c/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2f2a601e85c5897af3e6fd128125832b4328c6c/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=e2f2a601e85c5897af3e6fd128125832b4328c6c", "patch": "@@ -691,7 +691,6 @@ impl<'self> RWLockReadMode<'self> {\n \n #[cfg(test)]\n mod tests {\n-\n     use sync::*;\n \n     use std::cast;\n@@ -705,21 +704,21 @@ mod tests {\n      ************************************************************************/\n     #[test]\n     fn test_sem_acquire_release() {\n-        let s = ~Semaphore::new(1);\n+        let s = Semaphore::new(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n     fn test_sem_basic() {\n-        let s = ~Semaphore::new(1);\n+        let s = Semaphore::new(1);\n         do s.access { }\n     }\n     #[test]\n     fn test_sem_as_mutex() {\n-        let s = ~Semaphore::new(1);\n-        let s2 = ~s.clone();\n-        do task::spawn || {\n+        let s = Semaphore::new(1);\n+        let s2 = s.clone();\n+        do task::spawn {\n             do s2.access {\n                 do 5.times { task::deschedule(); }\n             }\n@@ -731,10 +730,10 @@ mod tests {\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n-        let (p,c) = comm::stream();\n-        let s = ~Semaphore::new(0);\n-        let s2 = ~s.clone();\n-        do task::spawn || {\n+        let (p, c) = comm::stream();\n+        let s = Semaphore::new(0);\n+        let s2 = s.clone();\n+        do task::spawn {\n             s2.acquire();\n             c.send(());\n         }\n@@ -743,10 +742,10 @@ mod tests {\n         let _ = p.recv();\n \n         /* Parent waits and child signals */\n-        let (p,c) = comm::stream();\n-        let s = ~Semaphore::new(0);\n-        let s2 = ~s.clone();\n-        do task::spawn || {\n+        let (p, c) = comm::stream();\n+        let s = Semaphore::new(0);\n+        let s2 = s.clone();\n+        do task::spawn {\n             do 5.times { task::deschedule(); }\n             s2.release();\n             let _ = p.recv();\n@@ -758,11 +757,11 @@ mod tests {\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n-        let s = ~Semaphore::new(2);\n-        let s2 = ~s.clone();\n+        let s = Semaphore::new(2);\n+        let s2 = s.clone();\n         let (p1,c1) = comm::stream();\n         let (p2,c2) = comm::stream();\n-        do task::spawn || {\n+        do task::spawn {\n             do s2.access {\n                 let _ = p2.recv();\n                 c1.send(());\n@@ -778,13 +777,13 @@ mod tests {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::SingleThreaded) {\n-            let s = ~Semaphore::new(1);\n-            let s2 = ~s.clone();\n-            let (p,c) = comm::stream();\n+            let s = Semaphore::new(1);\n+            let s2 = s.clone();\n+            let (p, c) = comm::stream();\n             let child_data = Cell::new((s2, c));\n             do s.access {\n                 let (s2, c) = child_data.take();\n-                do task::spawn || {\n+                do task::spawn {\n                     c.send(());\n                     do s2.access { }\n                     c.send(());\n@@ -802,22 +801,22 @@ mod tests {\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (p,c) = comm::stream();\n-        let m = ~Mutex::new();\n+        let (p, c) = comm::stream();\n+        let m = Mutex::new();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn || {\n+            do task::spawn {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n-                access_shared(sharedstate, m2, 10);\n+                access_shared(sharedstate, &m2, 10);\n                 c.send(());\n \n             }\n         }\n         {\n-            access_shared(sharedstate, m, 10);\n+            access_shared(sharedstate, &m, 10);\n             let _ = p.recv();\n \n             assert_eq!(*sharedstate, 20);\n@@ -835,12 +834,12 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_wait() {\n-        let m = ~Mutex::new();\n+        let m = Mutex::new();\n \n         // Child wakes up parent\n         do m.lock_cond |cond| {\n-            let m2 = ~m.clone();\n-            do task::spawn || {\n+            let m2 = m.clone();\n+            do task::spawn {\n                 do m2.lock_cond |cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n@@ -850,8 +849,8 @@ mod tests {\n         }\n         // Parent wakes up child\n         let (port,chan) = comm::stream();\n-        let m3 = ~m.clone();\n-        do task::spawn || {\n+        let m3 = m.clone();\n+        do task::spawn {\n             do m3.lock_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -867,14 +866,14 @@ mod tests {\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n-        let m = ~Mutex::new();\n+        let m = Mutex::new();\n         let mut ports = ~[];\n \n         do num_waiters.times {\n-            let mi = ~m.clone();\n+            let mi = m.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n-            do task::spawn || {\n+            do task::spawn {\n                 do mi.lock_cond |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -902,9 +901,9 @@ mod tests {\n     }\n     #[test]\n     fn test_mutex_cond_no_waiter() {\n-        let m = ~Mutex::new();\n-        let m2 = ~m.clone();\n-        do task::try || {\n+        let m = Mutex::new();\n+        let m2 = m.clone();\n+        do task::try {\n             do m.lock_cond |_x| { }\n         };\n         do m2.lock_cond |cond| {\n@@ -914,10 +913,10 @@ mod tests {\n     #[test]\n     fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let m = ~Mutex::new();\n-        let m2 = ~m.clone();\n+        let m = Mutex::new();\n+        let m2 = m.clone();\n \n-        let result: result::Result<(),()> = do task::try || {\n+        let result: result::Result<(),()> = do task::try {\n             do m2.lock {\n                 fail!();\n             }\n@@ -931,11 +930,11 @@ mod tests {\n     fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n-        let m = ~Mutex::new();\n-        let m2 = ~m.clone();\n+        let m = Mutex::new();\n+        let m2 = m.clone();\n \n-        let result: result::Result<(),()> = do task::try || {\n-            let (p,c) = comm::stream();\n+        let result: result::Result<(),()> = do task::try {\n+            let (p, c) = comm::stream();\n             do task::spawn || { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n@@ -958,17 +957,17 @@ mod tests {\n     fn test_mutex_killed_broadcast() {\n         use std::unstable::finally::Finally;\n \n-        let m = ~Mutex::new();\n-        let m2 = ~m.clone();\n-        let (p,c) = comm::stream();\n+        let m = Mutex::new();\n+        let m2 = m.clone();\n+        let (p, c) = comm::stream();\n \n-        let result: result::Result<(),()> = do task::try || {\n+        let result: result::Result<(),()> = do task::try {\n             let mut sibling_convos = ~[];\n             do 2.times {\n-                let (p,c) = comm::stream();\n+                let (p, c) = comm::stream();\n                 let c = Cell::new(c);\n                 sibling_convos.push(p);\n-                let mi = ~m2.clone();\n+                let mi = m2.clone();\n                 // spawn sibling task\n                 do task::spawn { // linked\n                     do mi.lock_cond |cond| {\n@@ -1003,10 +1002,10 @@ mod tests {\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n-        let m = ~Mutex::new();\n+        let m = Mutex::new();\n         do m.lock_cond |cond| {\n-            let m2 = ~m.clone();\n-            do task::spawn || {\n+            let m2 = m.clone();\n+            do task::spawn {\n                 do m2.lock_cond |cond| {\n                     cond.signal_on(0);\n                 }\n@@ -1017,10 +1016,10 @@ mod tests {\n     #[test]\n     fn test_mutex_different_conds() {\n         let result = do task::try {\n-            let m = ~Mutex::new_with_condvars(2);\n-            let m2 = ~m.clone();\n-            let (p,c) = comm::stream();\n-            do task::spawn || {\n+            let m = Mutex::new_with_condvars(2);\n+            let m2 = m.clone();\n+            let (p, c) = comm::stream();\n+            do task::spawn {\n                 do m2.lock_cond |cond| {\n                     c.send(());\n                     cond.wait_on(1);\n@@ -1038,17 +1037,17 @@ mod tests {\n     #[test]\n     fn test_mutex_no_condvars() {\n         let result = do task::try {\n-            let m = ~Mutex::new_with_condvars(0);\n+            let m = Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n-            let m = ~Mutex::new_with_condvars(0);\n+            let m = Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.signal(); }\n         };\n         assert!(result.is_err());\n         let result = do task::try {\n-            let m = ~Mutex::new_with_condvars(0);\n+            let m = Mutex::new_with_condvars(0);\n             do m.lock_cond |cond| { cond.broadcast(); }\n         };\n         assert!(result.is_err());\n@@ -1075,17 +1074,17 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: ~RWLock,\n+    fn test_rwlock_exclusion(x: &RWLock,\n                                  mode1: RWLockMode,\n                                  mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n-        let (p,c) = comm::stream();\n-        let x2 = (*x).clone();\n+        let (p, c) = comm::stream();\n+        let x2 = x.clone();\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn || {\n+            do task::spawn {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &x2, mode1, 10);\n@@ -1112,28 +1111,28 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(~RWLock::new(), Read, Write);\n-        test_rwlock_exclusion(~RWLock::new(), Write, Read);\n-        test_rwlock_exclusion(~RWLock::new(), Read, Downgrade);\n-        test_rwlock_exclusion(~RWLock::new(), Downgrade, Read);\n+        test_rwlock_exclusion(&RWLock::new(), Read, Write);\n+        test_rwlock_exclusion(&RWLock::new(), Write, Read);\n+        test_rwlock_exclusion(&RWLock::new(), Read, Downgrade);\n+        test_rwlock_exclusion(&RWLock::new(), Downgrade, Read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(~RWLock::new(), Write, Write);\n-        test_rwlock_exclusion(~RWLock::new(), Write, Downgrade);\n-        test_rwlock_exclusion(~RWLock::new(), Downgrade, Write);\n-        test_rwlock_exclusion(~RWLock::new(), Downgrade, Downgrade);\n+        test_rwlock_exclusion(&RWLock::new(), Write, Write);\n+        test_rwlock_exclusion(&RWLock::new(), Write, Downgrade);\n+        test_rwlock_exclusion(&RWLock::new(), Downgrade, Write);\n+        test_rwlock_exclusion(&RWLock::new(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: ~RWLock,\n+    fn test_rwlock_handshake(x: &RWLock,\n                                  mode1: RWLockMode,\n                                  mode2: RWLockMode,\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n-        let x2 = (*x).clone();\n-        let (p1,c1) = comm::stream();\n-        let (p2,c2) = comm::stream();\n-        do task::spawn || {\n+        let x2 = x.clone();\n+        let (p1, c1) = comm::stream();\n+        let (p2, c2) = comm::stream();\n+        do task::spawn {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1158,37 +1157,37 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(~RWLock::new(), Read, Read, false);\n+        test_rwlock_handshake(&RWLock::new(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(~RWLock::new(), DowngradeRead, Read, false);\n-        test_rwlock_handshake(~RWLock::new(), Read, DowngradeRead, true);\n+        test_rwlock_handshake(&RWLock::new(), DowngradeRead, Read, false);\n+        test_rwlock_handshake(&RWLock::new(), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n-        let x = ~RWLock::new();\n-        do lock_rwlock_in_mode(x, Downgrade) { }\n-        test_rwlock_handshake(x, Read, Read, false);\n-        let y = ~RWLock::new();\n-        do lock_rwlock_in_mode(y, DowngradeRead) { }\n-        test_rwlock_exclusion(y, Write, Write);\n+        let x = RWLock::new();\n+        do lock_rwlock_in_mode(&x, Downgrade) { }\n+        test_rwlock_handshake(&x, Read, Read, false);\n+        let y = RWLock::new();\n+        do lock_rwlock_in_mode(&y, DowngradeRead) { }\n+        test_rwlock_exclusion(&y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n-        let x = ~RWLock::new();\n+        let x = RWLock::new();\n         do x.read { do x.read { } }\n     }\n     #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n-        let x = ~RWLock::new();\n+        let x = RWLock::new();\n \n         // Child wakes up parent\n         do x.write_cond |cond| {\n-            let x2 = (*x).clone();\n-            do task::spawn || {\n+            let x2 = x.clone();\n+            do task::spawn {\n                 do x2.write_cond |cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n@@ -1197,9 +1196,9 @@ mod tests {\n             cond.wait();\n         }\n         // Parent wakes up child\n-        let (port,chan) = comm::stream();\n-        let x3 = (*x).clone();\n-        do task::spawn || {\n+        let (port, chan) = comm::stream();\n+        let x3 = x.clone();\n+        do task::spawn {\n             do x3.write_cond |cond| {\n                 chan.send(());\n                 cond.wait();\n@@ -1229,14 +1228,14 @@ mod tests {\n                 do x.write_cond |c| { blk(c) }\n             }\n         }\n-        let x = ~RWLock::new();\n+        let x = RWLock::new();\n         let mut ports = ~[];\n \n         do num_waiters.times {\n-            let xi = (*x).clone();\n+            let xi = x.clone();\n             let (port, chan) = comm::stream();\n             ports.push(port);\n-            do task::spawn || {\n+            do task::spawn {\n                 do lock_cond(&xi, dg1) |cond| {\n                     chan.send(());\n                     cond.wait();\n@@ -1247,7 +1246,7 @@ mod tests {\n \n         // wait until all children get in the mutex\n         for port in ports.iter() { let _ = port.recv(); }\n-        do lock_cond(x, dg2) |cond| {\n+        do lock_cond(&x, dg2) |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         }\n@@ -1268,8 +1267,8 @@ mod tests {\n     #[cfg(test)]\n     fn rwlock_kill_helper(mode1: RWLockMode, mode2: RWLockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n-        let x = ~RWLock::new();\n-        let x2 = (*x).clone();\n+        let x = RWLock::new();\n+        let x2 = x.clone();\n \n         let result: result::Result<(),()> = do task::try || {\n             do lock_rwlock_in_mode(&x2, mode1) {\n@@ -1278,23 +1277,23 @@ mod tests {\n         };\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n-        do lock_rwlock_in_mode(x, mode2) { }\n+        do lock_rwlock_in_mode(&x, mode2) { }\n     }\n     #[test]\n     fn test_rwlock_reader_killed_writer() {\n         rwlock_kill_helper(Read, Write);\n     }\n     #[test]\n     fn test_rwlock_writer_killed_reader() {\n-        rwlock_kill_helper(Write,Read );\n+        rwlock_kill_helper(Write, Read);\n     }\n     #[test]\n     fn test_rwlock_reader_killed_reader() {\n-        rwlock_kill_helper(Read, Read );\n+        rwlock_kill_helper(Read, Read);\n     }\n     #[test]\n     fn test_rwlock_writer_killed_writer() {\n-        rwlock_kill_helper(Write,Write);\n+        rwlock_kill_helper(Write, Write);\n     }\n     #[test]\n     fn test_rwlock_kill_downgrader() {\n@@ -1314,8 +1313,8 @@ mod tests {\n     #[test] #[should_fail]\n     fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n-        let x = ~RWLock::new();\n-        let y = ~RWLock::new();\n+        let x = RWLock::new();\n+        let y = RWLock::new();\n         do x.write_downgrade |xwrite| {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {"}]}