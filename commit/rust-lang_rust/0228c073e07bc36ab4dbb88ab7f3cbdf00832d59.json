{"sha": "0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "node_id": "C_kwDOAAsO6NoAKDAyMjhjMDczZTA3YmMzNmFiNGRiYjg4YWI3ZjNjYmRmMDA4MzJkNTk", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2022-03-13T06:41:44Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2022-09-11T06:04:12Z"}, "message": "add generator_clone feature gate", "tree": {"sha": "9237ad3cedb36706c204737ee902a2748a3a50d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9237ad3cedb36706c204737ee902a2748a3a50d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "html_url": "https://github.com/rust-lang/rust/commit/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0bc9444eea8677a307c2440b2f206911d5bbbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0bc9444eea8677a307c2440b2f206911d5bbbe", "html_url": "https://github.com/rust-lang/rust/commit/2c0bc9444eea8677a307c2440b2f206911d5bbbe"}], "stats": {"total": 59, "additions": 35, "deletions": 24}, "files": [{"sha": "0168587fbce4454a0d9f1b4daa0a973bef7764bd", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "patch": "@@ -396,6 +396,8 @@ declare_features! (\n     (active, fn_align, \"1.53.0\", Some(82232), None),\n     /// Allows defining generators.\n     (active, generators, \"1.21.0\", Some(43122), None),\n+    /// Allows generators to be cloned.\n+    (active, generator_clone, \"1.60.0\", None, None),\n     /// Infer generic args for both consts and types.\n     (active, generic_arg_infer, \"1.55.0\", Some(85077), None),\n     /// Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598)."}, {"sha": "5bddcd3481974b88f7d80f178fb449d5b8ead76a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "patch": "@@ -763,6 +763,7 @@ symbols! {\n         gen_future,\n         gen_kill,\n         generator,\n+        generator_clone,\n         generator_state,\n         generators,\n         generic_arg_infer,"}, {"sha": "0e7483847e3c4ac934c63da8995442955d259829", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0228c073e07bc36ab4dbb88ab7f3cbdf00832d59/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=0228c073e07bc36ab4dbb88ab7f3cbdf00832d59", "patch": "@@ -1938,35 +1938,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Generator(_, substs, hir::Movability::Movable) => {\n-                let resolved_upvars = self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n-                let resolved_witness = self.infcx.shallow_resolve(substs.as_generator().witness());\n-                if {\n-                    matches!(resolved_upvars.kind(), ty::Infer(ty::TyVar(_))) ||\n-                    matches!(resolved_witness.kind(), ty::Infer(ty::TyVar(_)))\n-                } {\n-                    // Not yet resolved.\n-                    Ambiguous\n+                if self.tcx().features().generator_clone {\n+                    let resolved_upvars = self.infcx.shallow_resolve(substs.as_generator().tupled_upvars_ty());\n+                    let resolved_witness = self.infcx.shallow_resolve(substs.as_generator().witness());\n+                    if {\n+                        matches!(resolved_upvars.kind(), ty::Infer(ty::TyVar(_))) ||\n+                        matches!(resolved_witness.kind(), ty::Infer(ty::TyVar(_)))\n+                    } {\n+                        // Not yet resolved.\n+                        Ambiguous\n+                    } else {\n+                        let mut all = substs.as_generator().upvar_tys().collect::<Vec<_>>();\n+                        all.push(substs.as_generator().witness());\n+                        Where(obligation.predicate.rebind(all))\n+                    }\n                 } else {\n-                    let mut all = substs.as_generator().upvar_tys().collect::<Vec<_>>();\n-                    all.push(substs.as_generator().witness());\n-                    Where(obligation.predicate.rebind(all))\n+                    None\n                 }\n             }\n \n             ty::GeneratorWitness(binder) => {\n-                let tys = binder.no_bound_vars().unwrap();\n-                let mut iter = tys.iter();\n-                loop {\n-                    let ty = match iter.next() {\n-                        Some(ty) => ty,\n-                        Option::None => {\n-                            break Where(obligation.predicate.rebind(tys.to_vec()))\n-                        },\n-                    };\n-                    let resolved = self.infcx.shallow_resolve(ty);\n-                    if matches!(resolved.kind(), ty::Infer(ty::TyVar(_))) {\n-                        break Ambiguous;\n-                    }\n+                match binder.no_bound_vars() {\n+                    Some(tys) => {\n+                        let mut iter = tys.iter();\n+                        loop {\n+                            let ty = match iter.next() {\n+                                Some(ty) => ty,\n+                                Option::None => {\n+                                    break Where(obligation.predicate.rebind(tys.to_vec()))\n+                                },\n+                            };\n+                            let resolved = self.infcx.shallow_resolve(ty);\n+                            if matches!(resolved.kind(), ty::Infer(ty::TyVar(_))) {\n+                                break Ambiguous;\n+                            }\n+                        }\n+                    },\n+                    Option::None => None,\n                 }\n             }\n "}]}