{"sha": "935b4347e286b0022ae6f38b2875df6f05c55fa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNWI0MzQ3ZTI4NmIwMDIyYWU2ZjM4YjI4NzVkZjZmMDVjNTVmYTM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-05T17:10:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-05T17:10:39Z"}, "message": "Mop up workarounds in stdlib no longer required as issue #93 is closed.", "tree": {"sha": "da099f73a9db22b1fbd1aa52dbc8d2741a2dde88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da099f73a9db22b1fbd1aa52dbc8d2741a2dde88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/935b4347e286b0022ae6f38b2875df6f05c55fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/935b4347e286b0022ae6f38b2875df6f05c55fa3", "html_url": "https://github.com/rust-lang/rust/commit/935b4347e286b0022ae6f38b2875df6f05c55fa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/935b4347e286b0022ae6f38b2875df6f05c55fa3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29987b56e1dafff4a850eef4e668a364340fc59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/29987b56e1dafff4a850eef4e668a364340fc59b", "html_url": "https://github.com/rust-lang/rust/commit/29987b56e1dafff4a850eef4e668a364340fc59b"}], "stats": {"total": 35, "additions": 11, "deletions": 24}, "files": [{"sha": "7d1a2dbdcd7a8dedcc9f38bed2fe905e043e3670", "filename": "src/lib/_str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=935b4347e286b0022ae6f38b2875df6f05c55fa3", "patch": "@@ -16,8 +16,7 @@ fn is_ascii(str s) -> bool {\n   let uint i = len(s);\n   while (i > 0u) {\n     i -= 1u;\n-    // FIXME (issue #94)\n-    if ((s.(i as int) & 0x80u8) != 0u8) {\n+    if ((s.(i) & 0x80u8) != 0u8) {\n       ret false;\n     }\n   }\n@@ -38,7 +37,7 @@ fn buf(str s) -> sbuf {\n \n fn bytes(&str s) -> vec[u8] {\n   fn ith(str s, uint i) -> u8 {\n-    ret s.(i as int); // FIXME (issue #94)\n+    ret s.(i);\n   }\n   ret _vec.init_fn[u8](bind ith(s, _), _str.len(s));\n }"}, {"sha": "bf7acb533bbaa6b41ee844a788235cd6c919557a", "filename": "src/lib/deque.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=935b4347e286b0022ae6f38b2875df6f05c55fa3", "patch": "@@ -36,7 +36,7 @@ fn create[T]() -> t[T] {\n \n     fn fill[T](uint i, uint nelts, uint lo, &vec[cell[T]] old) -> cell[T] {\n       if (i < nelts) {\n-        ret old.(((lo + i) % nelts) as int);\n+        ret old.((lo + i) % nelts);\n       } else {\n         ret util.none[T]();\n       }\n@@ -47,14 +47,8 @@ fn create[T]() -> t[T] {\n     ret _vec.init_fn[cell[T]](copy_op, nalloc);\n   }\n \n-  /**\n-   * FIXME (issue #94): We're converting to int every time we index into the\n-   * vec, but we really want to index with the lo and hi uints that we have\n-   * around.\n-   */\n-\n   fn get[T](&vec[cell[T]] elts, uint i) -> T {\n-    alt (elts.(i as int)) {\n+    alt (elts.(i)) {\n       case (util.some[T](t)) { ret t; }\n       case (_) { fail; }\n     }\n@@ -82,7 +76,7 @@ fn create[T]() -> t[T] {\n         hi = nelts;\n       }\n \n-      elts.(lo as int) = util.some[T](t);\n+      elts.(lo) = util.some[T](t);\n       nelts += 1u;\n     }\n \n@@ -93,7 +87,7 @@ fn create[T]() -> t[T] {\n         hi = nelts;\n       }\n \n-      elts.(hi as int) = util.some[T](t);\n+      elts.(hi) = util.some[T](t);\n       hi = (hi + 1u) % _vec.len[cell[T]](elts);\n       nelts += 1u;\n     }\n@@ -104,7 +98,7 @@ fn create[T]() -> t[T] {\n      */\n     fn pop_front() -> T {\n       let T t = get[T](elts, lo);\n-      elts.(lo as int) = util.none[T]();\n+      elts.(lo) = util.none[T]();\n       lo = (lo + 1u) % _vec.len[cell[T]](elts);\n       ret t;\n     }\n@@ -117,7 +111,7 @@ fn create[T]() -> t[T] {\n       }\n \n       let T t = get[T](elts, hi);\n-      elts.(hi as int) = util.none[T]();\n+      elts.(hi) = util.none[T]();\n       ret t;\n     }\n "}, {"sha": "ff7b441115bf619c58eab2818a47311f42c899a1", "filename": "src/lib/map.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/935b4347e286b0022ae6f38b2875df6f05c55fa3/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=935b4347e286b0022ae6f38b2875df6f05c55fa3", "patch": "@@ -75,8 +75,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n-      // FIXME (issue #94): as in find_common()\n-      let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+      let uint j = (hash[K](hasher, nbkts, key, i));\n       alt (bkts.(j)) {\n         case (some[K, V](k, _)) {\n           if (eqer(key, k)) {\n@@ -103,8 +102,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   {\n     let uint i = 0u;\n     while (i < nbkts) {\n-      // FIXME (issue #94):  Pending bugfix, remove uint coercion.\n-      let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+      let uint j = (hash[K](hasher, nbkts, key, i));\n       alt (bkts.(j)) {\n         case (some[K, V](k, v)) {\n           if (eqer(key, k)) {\n@@ -149,9 +147,6 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n       if (!util.rational_leq(load, lf)) {\n         let uint nnewbkts = _int.next_power_of_two(nbkts + 1u);\n \n-        // FIXME (issue #94):  Enforce our workaround to issue #94.\n-        check ((nnewbkts as int) > 0);\n-\n         let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nnewbkts);\n         rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n       }\n@@ -183,8 +178,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n     fn remove(&K key) -> util.option[V] {\n       let uint i = 0u;\n       while (i < nbkts) {\n-        // FIXME (issue #94): as in find_common()\n-        let int j = (hash[K](hasher, nbkts, key, i)) as int;\n+        let uint j = (hash[K](hasher, nbkts, key, i));\n         alt (bkts.(j)) {\n           case (some[K, V](_, val)) {\n             bkts.(j) = deleted[K, V]();"}]}