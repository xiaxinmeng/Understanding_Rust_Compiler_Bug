{"sha": "5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOTdlMTY2NDg1NmZhNGZlZjVhNGM0ZGQ0M2I2OTE1ZTlmYTg0N2Q=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-04T10:58:08Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-04T10:58:08Z"}, "message": "Merge #916\n\n916: Error handling for macros r=matklad a=detrumi\n\nPart of #720 \n\nCo-authored-by: Wilco Kusee <wilcokusee@gmail.com>", "tree": {"sha": "9ae47c46374251c049531aa0b25859cfe98a78a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ae47c46374251c049531aa0b25859cfe98a78a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "html_url": "https://github.com/rust-lang/rust/commit/5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "698aa9b3f6420351a41a3fb4819b871fec3c891c", "url": "https://api.github.com/repos/rust-lang/rust/commits/698aa9b3f6420351a41a3fb4819b871fec3c891c", "html_url": "https://github.com/rust-lang/rust/commit/698aa9b3f6420351a41a3fb4819b871fec3c891c"}, {"sha": "c9d6efc468b2e845aba3237331ea2e02af1b8cc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d6efc468b2e845aba3237331ea2e02af1b8cc2", "html_url": "https://github.com/rust-lang/rust/commit/c9d6efc468b2e845aba3237331ea2e02af1b8cc2"}], "stats": {"total": 292, "additions": 220, "deletions": 72}, "files": [{"sha": "2c75b7b4fced5f1f2d8e4a700a6cff73c1de1532", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "patch": "@@ -24,6 +24,18 @@ use ra_syntax::SmolStr;\n \n pub use tt::{Delimiter, Punct};\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ParseError {\n+    Expected(String),\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ExpandError {\n+    NoMatchingRule,\n+    UnexpectedToken,\n+    BindingError(String),\n+}\n+\n pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list};\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n@@ -36,11 +48,11 @@ pub struct MacroRules {\n }\n \n impl MacroRules {\n-    pub fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n+    pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n         mbe_parser::parse(tt)\n     }\n-    pub fn expand(&self, tt: &tt::Subtree) -> Option<tt::Subtree> {\n-        mbe_expander::exapnd(self, tt)\n+    pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n+        mbe_expander::expand(self, tt)\n     }\n }\n "}, {"sha": "2dd97b66583d13db451c6e4fe3afe69eeb832b21", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 116, "deletions": 31, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "patch": "@@ -5,17 +5,21 @@ use rustc_hash::FxHashMap;\n use ra_syntax::SmolStr;\n use tt::TokenId;\n \n+use crate::ExpandError;\n use crate::tt_cursor::TtCursor;\n \n-pub(crate) fn exapnd(rules: &crate::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n-    rules.rules.iter().find_map(|it| expand_rule(it, input))\n+pub(crate) fn expand(\n+    rules: &crate::MacroRules,\n+    input: &tt::Subtree,\n+) -> Result<tt::Subtree, ExpandError> {\n+    rules.rules.iter().find_map(|it| expand_rule(it, input).ok()).ok_or(ExpandError::NoMatchingRule)\n }\n \n-fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n+fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n     let mut input = TtCursor::new(input);\n     let bindings = match_lhs(&rule.lhs, &mut input)?;\n     if !input.is_eof() {\n-        return None;\n+        return Err(ExpandError::UnexpectedToken);\n     }\n     expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n }\n@@ -77,70 +81,86 @@ enum Binding {\n }\n \n impl Bindings {\n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Option<&tt::TokenTree> {\n-        let mut b = self.inner.get(name)?;\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&tt::TokenTree, ExpandError> {\n+        let mut b = self\n+            .inner\n+            .get(name)\n+            .ok_or(ExpandError::BindingError(format!(\"could not find binding `{}`\", name)))?;\n         for &idx in nesting.iter() {\n             b = match b {\n                 Binding::Simple(_) => break,\n-                Binding::Nested(bs) => bs.get(idx)?,\n+                Binding::Nested(bs) => bs.get(idx).ok_or(ExpandError::BindingError(format!(\n+                    \"could not find nested binding `{}`\",\n+                    name\n+                )))?,\n             };\n         }\n         match b {\n-            Binding::Simple(it) => Some(it),\n-            Binding::Nested(_) => None,\n+            Binding::Simple(it) => Ok(it),\n+            Binding::Nested(_) => Err(ExpandError::BindingError(format!(\n+                \"expected simple binding, found nested binding `{}`\",\n+                name\n+            ))),\n         }\n     }\n-    fn push_nested(&mut self, nested: Bindings) -> Option<()> {\n+\n+    fn push_nested(&mut self, nested: Bindings) -> Result<(), ExpandError> {\n         for (key, value) in nested.inner {\n             if !self.inner.contains_key(&key) {\n                 self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n             }\n             match self.inner.get_mut(&key) {\n                 Some(Binding::Nested(it)) => it.push(value),\n-                _ => return None,\n+                _ => {\n+                    return Err(ExpandError::BindingError(format!(\n+                        \"could not find binding `{}`\",\n+                        key\n+                    )));\n+                }\n             }\n         }\n-        Some(())\n+        Ok(())\n     }\n }\n \n-fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n+fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings, ExpandError> {\n     let mut res = Bindings::default();\n     for pat in pattern.token_trees.iter() {\n         match pat {\n             crate::TokenTree::Leaf(leaf) => match leaf {\n                 crate::Leaf::Var(crate::Var { text, kind }) => {\n-                    let kind = kind.clone()?;\n+                    let kind = kind.clone().ok_or(ExpandError::UnexpectedToken)?;\n                     match kind.as_str() {\n                         \"ident\" => {\n-                            let ident = input.eat_ident()?.clone();\n+                            let ident =\n+                                input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n                             res.inner.insert(\n                                 text.clone(),\n                                 Binding::Simple(tt::Leaf::from(ident).into()),\n                             );\n                         }\n-                        _ => return None,\n+                        _ => return Err(ExpandError::UnexpectedToken),\n                     }\n                 }\n                 crate::Leaf::Punct(punct) => {\n-                    if input.eat_punct()? != punct {\n-                        return None;\n+                    if input.eat_punct() != Some(punct) {\n+                        return Err(ExpandError::UnexpectedToken);\n                     }\n                 }\n                 crate::Leaf::Ident(ident) => {\n-                    if input.eat_ident()?.text != ident.text {\n-                        return None;\n+                    if input.eat_ident().map(|i| &i.text) != Some(&ident.text) {\n+                        return Err(ExpandError::UnexpectedToken);\n                     }\n                 }\n-                _ => return None,\n+                _ => return Err(ExpandError::UnexpectedToken),\n             },\n             crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n-                while let Some(nested) = match_lhs(subtree, input) {\n+                while let Ok(nested) = match_lhs(subtree, input) {\n                     res.push_nested(nested)?;\n                     if let Some(separator) = *separator {\n                         if !input.is_eof() {\n-                            if input.eat_punct()?.char != separator {\n-                                return None;\n+                            if input.eat_punct().map(|p| p.char) != Some(separator) {\n+                                return Err(ExpandError::UnexpectedToken);\n                             }\n                         }\n                     }\n@@ -149,34 +169,34 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings>\n             _ => {}\n         }\n     }\n-    Some(res)\n+    Ok(res)\n }\n \n fn expand_subtree(\n     template: &crate::Subtree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n-) -> Option<tt::Subtree> {\n+) -> Result<tt::Subtree, ExpandError> {\n     let token_trees = template\n         .token_trees\n         .iter()\n         .map(|it| expand_tt(it, bindings, nesting))\n-        .collect::<Option<Vec<_>>>()?;\n+        .collect::<Result<Vec<_>, ExpandError>>()?;\n \n-    Some(tt::Subtree { token_trees, delimiter: template.delimiter })\n+    Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n }\n \n fn expand_tt(\n     template: &crate::TokenTree,\n     bindings: &Bindings,\n     nesting: &mut Vec<usize>,\n-) -> Option<tt::TokenTree> {\n+) -> Result<tt::TokenTree, ExpandError> {\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees = Vec::new();\n             nesting.push(0);\n-            while let Some(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+            while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n                 let idx = nesting.pop().unwrap();\n                 nesting.push(idx + 1);\n                 token_trees.push(t.into())\n@@ -194,5 +214,70 @@ fn expand_tt(\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n         },\n     };\n-    Some(res)\n+    Ok(res)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::{ast, AstNode};\n+\n+    use super::*;\n+    use crate::ast_to_token_tree;\n+\n+    #[test]\n+    fn test_expand_rule() {\n+        assert_err(\n+            \"($i:ident) => ($j)\",\n+            \"foo!{a}\",\n+            ExpandError::BindingError(String::from(\"could not find binding `j`\")),\n+        );\n+\n+        assert_err(\n+            \"($($i:ident);*) => ($i)\",\n+            \"foo!{a}\",\n+            ExpandError::BindingError(String::from(\n+                \"expected simple binding, found nested binding `i`\",\n+            )),\n+        );\n+\n+        assert_err(\"($i) => ($i)\", \"foo!{a}\", ExpandError::UnexpectedToken);\n+        assert_err(\"($i:) => ($i)\", \"foo!{a}\", ExpandError::UnexpectedToken);\n+    }\n+\n+    fn assert_err(macro_body: &str, invocation: &str, err: ExpandError) {\n+        assert_eq!(expand_first(&create_rules(&format_macro(macro_body)), invocation), Err(err));\n+    }\n+\n+    fn format_macro(macro_body: &str) -> String {\n+        format!(\n+            \"\n+        macro_rules! foo {{\n+            {}\n+        }}\n+\",\n+            macro_body\n+        )\n+    }\n+\n+    fn create_rules(macro_definition: &str) -> crate::MacroRules {\n+        let source_file = ast::SourceFile::parse(macro_definition);\n+        let macro_definition =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+        crate::MacroRules::parse(&definition_tt).unwrap()\n+    }\n+\n+    fn expand_first(\n+        rules: &crate::MacroRules,\n+        invocation: &str,\n+    ) -> Result<tt::Subtree, ExpandError> {\n+        let source_file = ast::SourceFile::parse(invocation);\n+        let macro_invocation =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+        let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+\n+        expand_rule(&rules.rules[0], &invocation_tt)\n+    }\n }"}, {"sha": "e3669f66cbeb52fb4bec6d1bcec9a3b45f4eb1b0", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "patch": "@@ -1,33 +1,34 @@\n /// This module parses a raw `tt::TokenStream` into macro-by-example token\n /// stream. This is a *mostly* identify function, expect for handling of\n /// `$var:tt_kind` and `$(repeat),*` constructs.\n+use crate::ParseError;\n use crate::tt_cursor::TtCursor;\n \n-pub(crate) fn parse(tt: &tt::Subtree) -> Option<crate::MacroRules> {\n+pub(crate) fn parse(tt: &tt::Subtree) -> Result<crate::MacroRules, ParseError> {\n     let mut parser = TtCursor::new(tt);\n     let mut rules = Vec::new();\n     while !parser.is_eof() {\n         rules.push(parse_rule(&mut parser)?);\n-        if parser.expect_char(';') == None {\n+        if let Err(e) = parser.expect_char(';') {\n             if !parser.is_eof() {\n-                return None;\n+                return Err(e);\n             }\n             break;\n         }\n     }\n-    Some(crate::MacroRules { rules })\n+    Ok(crate::MacroRules { rules })\n }\n \n-fn parse_rule(p: &mut TtCursor) -> Option<crate::Rule> {\n+fn parse_rule(p: &mut TtCursor) -> Result<crate::Rule, ParseError> {\n     let lhs = parse_subtree(p.eat_subtree()?)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n     let mut rhs = parse_subtree(p.eat_subtree()?)?;\n     rhs.delimiter = crate::Delimiter::None;\n-    Some(crate::Rule { lhs, rhs })\n+    Ok(crate::Rule { lhs, rhs })\n }\n \n-fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n+fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree, ParseError> {\n     let mut token_trees = Vec::new();\n     let mut p = TtCursor::new(tt);\n     while let Some(tt) = p.eat() {\n@@ -52,10 +53,10 @@ fn parse_subtree(tt: &tt::Subtree) -> Option<crate::Subtree> {\n         };\n         token_trees.push(child);\n     }\n-    Some(crate::Subtree { token_trees, delimiter: tt.delimiter })\n+    Ok(crate::Subtree { token_trees, delimiter: tt.delimiter })\n }\n \n-fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n+fn parse_var(p: &mut TtCursor) -> Result<crate::Var, ParseError> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n     let kind = if p.at_char(':') {\n@@ -69,25 +70,77 @@ fn parse_var(p: &mut TtCursor) -> Option<crate::Var> {\n     } else {\n         None\n     };\n-    Some(crate::Var { text, kind })\n+    Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor) -> Option<crate::Repeat> {\n+fn parse_repeat(p: &mut TtCursor) -> Result<crate::Repeat, ParseError> {\n     let subtree = p.eat_subtree().unwrap();\n     let mut subtree = parse_subtree(subtree)?;\n     subtree.delimiter = crate::Delimiter::None;\n-    let sep = p.eat_punct()?;\n+    let sep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n     let (separator, rep) = match sep.char {\n         '*' | '+' | '?' => (None, sep.char),\n-        char => (Some(char), p.eat_punct()?.char),\n+        char => {\n+            (Some(char), p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?.char)\n+        }\n     };\n \n     let kind = match rep {\n         '*' => crate::RepeatKind::ZeroOrMore,\n         '+' => crate::RepeatKind::OneOrMore,\n         '?' => crate::RepeatKind::ZeroOrOne,\n-        _ => return None,\n+        _ => return Err(ParseError::Expected(String::from(\"repeat\"))),\n     };\n     p.bump();\n-    Some(crate::Repeat { subtree, kind, separator })\n+    Ok(crate::Repeat { subtree, kind, separator })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::{ast, AstNode};\n+\n+    use super::*;\n+    use crate::ast_to_token_tree;\n+\n+    #[test]\n+    fn test_invalid_parse() {\n+        expect_err(\"invalid\", \"subtree\");\n+\n+        is_valid(\"($i:ident) => ()\");\n+        expect_err(\"$i:ident => ()\", \"subtree\");\n+        expect_err(\"($i:ident) ()\", \"`=`\");\n+        expect_err(\"($($i:ident)_) => ()\", \"separator\");\n+    }\n+\n+    fn expect_err(macro_body: &str, expected: &str) {\n+        assert_eq!(\n+            create_rules(&format_macro(macro_body)),\n+            Err(ParseError::Expected(String::from(expected)))\n+        );\n+    }\n+\n+    fn is_valid(macro_body: &str) {\n+        assert!(create_rules(&format_macro(macro_body)).is_ok());\n+    }\n+\n+    fn format_macro(macro_body: &str) -> String {\n+        format!(\n+            \"\n+        macro_rules! foo {{\n+            {}\n+        }}\n+\",\n+            macro_body\n+        )\n+    }\n+\n+    fn create_rules(macro_definition: &str) -> Result<crate::MacroRules, ParseError> {\n+        let source_file = ast::SourceFile::parse(macro_definition);\n+        let macro_definition =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+        let (definition_tt, _) = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+        parse(&definition_tt)\n+    }\n+\n }"}, {"sha": "3128cb9ae2e96eb7e26370ebe7d77d46d80fc12d", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197e1664856fa4fef5a4c4dd43b6915e9fa847d/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=5197e1664856fa4fef5a4c4dd43b6915e9fa847d", "patch": "@@ -1,3 +1,5 @@\n+use crate::ParseError;\n+\n #[derive(Clone)]\n pub(crate) struct TtCursor<'a> {\n     subtree: &'a tt::Subtree,\n@@ -46,46 +48,42 @@ impl<'a> TtCursor<'a> {\n     }\n \n     pub(crate) fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n-        match self.current() {\n-            Some(it) => {\n-                self.bump();\n-                Some(it)\n-            }\n-            None => None,\n-        }\n+        self.current().map(|it| {\n+            self.bump();\n+            it\n+        })\n     }\n \n-    pub(crate) fn eat_subtree(&mut self) -> Option<&'a tt::Subtree> {\n-        match self.current()? {\n-            tt::TokenTree::Subtree(sub) => {\n+    pub(crate) fn eat_subtree(&mut self) -> Result<&'a tt::Subtree, ParseError> {\n+        match self.current() {\n+            Some(tt::TokenTree::Subtree(sub)) => {\n                 self.bump();\n-                Some(sub)\n+                Ok(sub)\n             }\n-            _ => return None,\n+            _ => Err(ParseError::Expected(String::from(\"subtree\"))),\n         }\n     }\n \n     pub(crate) fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n-        if let Some(it) = self.at_punct() {\n+        self.at_punct().map(|it| {\n             self.bump();\n-            return Some(it);\n-        }\n-        None\n+            it\n+        })\n     }\n \n     pub(crate) fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n-        if let Some(i) = self.at_ident() {\n+        self.at_ident().map(|i| {\n             self.bump();\n-            return Some(i);\n-        }\n-        None\n+            i\n+        })\n     }\n \n-    pub(crate) fn expect_char(&mut self, char: char) -> Option<()> {\n+    pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n         if self.at_char(char) {\n             self.bump();\n-            return Some(());\n+            Ok(())\n+        } else {\n+            Err(ParseError::Expected(format!(\"`{}`\", char)))\n         }\n-        None\n     }\n }"}]}