{"sha": "1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "node_id": "C_kwDOAAsO6NoAKDFkN2QxMGE5M2Q3YTdmM2U3NjFhOWIxZmM2YWVlZmY4NGQ3NDgzZWY", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2023-01-04T22:05:58Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2023-01-04T22:05:58Z"}, "message": "tidy: Don't include wasm32 in compiler dependency check", "tree": {"sha": "4676d7cf87dfc45a5c31019a2b2837125c401045", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4676d7cf87dfc45a5c31019a2b2837125c401045"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "html_url": "https://github.com/rust-lang/rust/commit/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "659e169d37990b9c730a59a96081f2ef7afbe8f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/659e169d37990b9c730a59a96081f2ef7afbe8f1", "html_url": "https://github.com/rust-lang/rust/commit/659e169d37990b9c730a59a96081f2ef7afbe8f1"}], "stats": {"total": 170, "additions": 67, "deletions": 103}, "files": [{"sha": "77c8809785a2f537c696be43ab09b140e24993fd", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "patch": "@@ -5596,6 +5596,7 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"cargo-platform 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.14.0\",\n  \"ignore\",\n  \"lazy_static\","}, {"sha": "714bdace848898ecb6b86d241fd72ff64c23fd62", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "patch": "@@ -6,6 +6,7 @@ autobins = false\n \n [dependencies]\n cargo_metadata = \"0.14\"\n+cargo-platform = \"0.1.2\"\n regex = \"1\"\n miropt-test-tools = { path = \"../miropt-test-tools\" }\n lazy_static = \"1\""}, {"sha": "9870af86d7eaf5f4a78e6e881df03b0b4f6ed973", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 65, "deletions": 103, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=1d7d10a93d7a7f3e761a9b1fc6aeeff84d7483ef", "patch": "@@ -1,7 +1,7 @@\n //! Checks the licenses of third-party dependencies.\n \n-use cargo_metadata::{Metadata, Package, PackageId, Resolve};\n-use std::collections::{BTreeSet, HashSet};\n+use cargo_metadata::{DepKindInfo, Metadata, Package, PackageId};\n+use std::collections::HashSet;\n use std::path::Path;\n \n /// These are licenses that are allowed for all crates, including the runtime,\n@@ -98,14 +98,12 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"autocfg\",\n     \"bitflags\",\n     \"block-buffer\",\n-    \"bumpalo\", // Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"cc\",\n     \"cfg-if\",\n     \"chalk-derive\",\n     \"chalk-engine\",\n     \"chalk-ir\",\n     \"chalk-solve\",\n-    \"chrono\",\n     \"convert_case\", // dependency of derive_more\n     \"compiler_builtins\",\n     \"cpufeatures\",\n@@ -124,11 +122,9 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"dlmalloc\",\n     \"either\",\n     \"ena\",\n-    \"env_logger\",\n     \"expect-test\",\n     \"fallible-iterator\", // dependency of `thorin`\n     \"fastrand\",\n-    \"filetime\",\n     \"fixedbitset\",\n     \"flate2\",\n     \"fluent-bundle\",\n@@ -142,21 +138,18 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"gsgdt\",\n     \"hashbrown\",\n     \"hermit-abi\",\n-    \"humantime\",\n     \"icu_list\",\n     \"icu_locid\",\n     \"icu_provider\",\n     \"icu_provider_adapters\",\n     \"icu_provider_macros\",\n-    \"if_chain\",\n     \"indexmap\",\n     \"instant\",\n     \"intl-memoizer\",\n     \"intl_pluralrules\",\n     \"itertools\",\n     \"itoa\",\n     \"jobserver\",\n-    \"js-sys\", // Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"lazy_static\",\n     \"libc\",\n     \"libloading\",\n@@ -171,8 +164,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"memmap2\",\n     \"memoffset\",\n     \"miniz_oxide\",\n-    \"num-integer\",\n-    \"num-traits\",\n     \"num_cpus\",\n     \"object\",\n     \"odht\",\n@@ -190,7 +181,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"proc-macro2\",\n     \"psm\",\n     \"punycode\",\n-    \"quick-error\",\n     \"quote\",\n     \"rand\",\n     \"rand_chacha\",\n@@ -236,7 +226,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"thiserror-impl\",\n     \"thorin-dwp\",\n     \"thread_local\",\n-    \"time\",\n     \"tinystr\",\n     \"tinyvec\",\n     \"tinyvec_macros\",\n@@ -269,13 +258,6 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"valuable\",\n     \"version_check\",\n     \"wasi\",\n-    // vvv Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n-    \"wasm-bindgen\",\n-    \"wasm-bindgen-backend\",\n-    \"wasm-bindgen-macro\",\n-    \"wasm-bindgen-macro-support\",\n-    \"wasm-bindgen-shared\",\n-    // ^^^ Included in Cargo's dep graph but only activated on wasm32-*-unknown.\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-util\",\n@@ -486,73 +468,55 @@ fn check_permitted_dependencies(\n     restricted_dependency_crates: &[&'static str],\n     bad: &mut bool,\n ) {\n+    let mut deps = HashSet::new();\n+    for to_check in restricted_dependency_crates {\n+        let to_check = pkg_from_name(metadata, to_check);\n+        use cargo_platform::Cfg;\n+        use std::str::FromStr;\n+        // We don't expect the compiler to ever run on wasm32, so strip\n+        // out those dependencies to avoid polluting the permitted list.\n+        deps_of_filtered(metadata, &to_check.id, &mut deps, &|dep_kinds| {\n+            dep_kinds.iter().any(|dep_kind| {\n+                dep_kind\n+                    .target\n+                    .as_ref()\n+                    .map(|target| {\n+                        !target.matches(\n+                            \"wasm32-unknown-unknown\",\n+                            &[\n+                                Cfg::from_str(\"target_arch=\\\"wasm32\\\"\").unwrap(),\n+                                Cfg::from_str(\"target_os=\\\"unknown\\\"\").unwrap(),\n+                            ],\n+                        )\n+                    })\n+                    .unwrap_or(true)\n+            })\n+        });\n+    }\n+\n     // Check that the PERMITTED_DEPENDENCIES does not have unused entries.\n-    for name in permitted_dependencies {\n-        if !metadata.packages.iter().any(|p| p.name == *name) {\n+    for permitted in permitted_dependencies {\n+        if !deps.iter().any(|dep_id| &pkg_from_id(metadata, dep_id).name == permitted) {\n             tidy_error!(\n                 bad,\n-                \"could not find allowed package `{}`\\n\\\n+                \"could not find allowed package `{permitted}`\\n\\\n                 Remove from PERMITTED_DEPENDENCIES list if it is no longer used.\",\n-                name\n             );\n         }\n     }\n-    // Get the list in a convenient form.\n-    let permitted_dependencies: HashSet<_> = permitted_dependencies.iter().cloned().collect();\n-\n-    // Check dependencies.\n-    let mut visited = BTreeSet::new();\n-    let mut unapproved = BTreeSet::new();\n-    for &krate in restricted_dependency_crates.iter() {\n-        let pkg = pkg_from_name(metadata, krate);\n-        let mut bad =\n-            check_crate_dependencies(&permitted_dependencies, metadata, &mut visited, pkg);\n-        unapproved.append(&mut bad);\n-    }\n-\n-    if !unapproved.is_empty() {\n-        tidy_error!(bad, \"Dependencies for {} not explicitly permitted:\", descr);\n-        for dep in unapproved {\n-            println!(\"* {dep}\");\n-        }\n-    }\n-}\n-\n-/// Checks the dependencies of the given crate from the given cargo metadata to see if they are on\n-/// the list of permitted dependencies. Returns a list of disallowed dependencies.\n-fn check_crate_dependencies<'a>(\n-    permitted_dependencies: &'a HashSet<&'static str>,\n-    metadata: &'a Metadata,\n-    visited: &mut BTreeSet<&'a PackageId>,\n-    krate: &'a Package,\n-) -> BTreeSet<&'a PackageId> {\n-    // This will contain bad deps.\n-    let mut unapproved = BTreeSet::new();\n-\n-    // Check if we have already visited this crate.\n-    if visited.contains(&krate.id) {\n-        return unapproved;\n-    }\n \n-    visited.insert(&krate.id);\n+    // Get in a convenient form.\n+    let permitted_dependencies: HashSet<_> = permitted_dependencies.iter().cloned().collect();\n \n-    // If this path is in-tree, we don't require it to be explicitly permitted.\n-    if krate.source.is_some() {\n-        // If this dependency is not on `PERMITTED_DEPENDENCIES`, add to bad set.\n-        if !permitted_dependencies.contains(krate.name.as_str()) {\n-            unapproved.insert(&krate.id);\n+    for dep in deps {\n+        let dep = pkg_from_id(metadata, dep);\n+        // If this path is in-tree, we don't require it to be explicitly permitted.\n+        if dep.source.is_some() {\n+            if !permitted_dependencies.contains(dep.name.as_str()) {\n+                tidy_error!(bad, \"Dependency for {descr} not explicitly permitted: {}\", dep.id);\n+            }\n         }\n     }\n-\n-    // Do a DFS in the crate graph.\n-    let to_check = deps_of(metadata, &krate.id);\n-\n-    for dep in to_check {\n-        let mut bad = check_crate_dependencies(permitted_dependencies, metadata, visited, dep);\n-        unapproved.append(&mut bad);\n-    }\n-\n-    unapproved\n }\n \n /// Prevents multiple versions of some expensive crates.\n@@ -589,24 +553,6 @@ fn check_crate_duplicate(\n     }\n }\n \n-/// Returns a list of dependencies for the given package.\n-fn deps_of<'a>(metadata: &'a Metadata, pkg_id: &'a PackageId) -> Vec<&'a Package> {\n-    let resolve = metadata.resolve.as_ref().unwrap();\n-    let node = resolve\n-        .nodes\n-        .iter()\n-        .find(|n| &n.id == pkg_id)\n-        .unwrap_or_else(|| panic!(\"could not find `{pkg_id}` in resolve\"));\n-    node.deps\n-        .iter()\n-        .map(|dep| {\n-            metadata.packages.iter().find(|pkg| pkg.id == dep.pkg).unwrap_or_else(|| {\n-                panic!(\"could not find dep `{}` for pkg `{}` in resolve\", dep.pkg, pkg_id)\n-            })\n-        })\n-        .collect()\n-}\n-\n /// Finds a package with the given name.\n fn pkg_from_name<'a>(metadata: &'a Metadata, name: &'static str) -> &'a Package {\n     let mut i = metadata.packages.iter().filter(|p| p.name == name);\n@@ -616,41 +562,57 @@ fn pkg_from_name<'a>(metadata: &'a Metadata, name: &'static str) -> &'a Package\n     result\n }\n \n+fn pkg_from_id<'a>(metadata: &'a Metadata, id: &PackageId) -> &'a Package {\n+    metadata.packages.iter().find(|p| &p.id == id).unwrap()\n+}\n+\n /// Finds all the packages that are in the rust runtime.\n fn compute_runtime_crates<'a>(metadata: &'a Metadata) -> HashSet<&'a PackageId> {\n-    let resolve = metadata.resolve.as_ref().unwrap();\n     let mut result = HashSet::new();\n     for name in RUNTIME_CRATES {\n         let id = &pkg_from_name(metadata, name).id;\n-        normal_deps_of_r(resolve, id, &mut result);\n+        deps_of_filtered(metadata, id, &mut result, &|_| true);\n     }\n     result\n }\n \n-/// Recursively find all normal dependencies.\n-fn normal_deps_of_r<'a>(\n-    resolve: &'a Resolve,\n+/// Recursively find all dependencies.\n+fn deps_of_filtered<'a>(\n+    metadata: &'a Metadata,\n     pkg_id: &'a PackageId,\n     result: &mut HashSet<&'a PackageId>,\n+    filter: &dyn Fn(&[DepKindInfo]) -> bool,\n ) {\n     if !result.insert(pkg_id) {\n         return;\n     }\n-    let node = resolve\n+    let node = metadata\n+        .resolve\n+        .as_ref()\n+        .unwrap()\n         .nodes\n         .iter()\n         .find(|n| &n.id == pkg_id)\n         .unwrap_or_else(|| panic!(\"could not find `{pkg_id}` in resolve\"));\n     for dep in &node.deps {\n-        normal_deps_of_r(resolve, &dep.pkg, result);\n+        if !filter(&dep.dep_kinds) {\n+            continue;\n+        }\n+        deps_of_filtered(metadata, &dep.pkg, result, filter);\n     }\n }\n \n+fn direct_deps_of<'a>(metadata: &'a Metadata, pkg_id: &'a PackageId) -> Vec<&'a Package> {\n+    let resolve = metadata.resolve.as_ref().unwrap();\n+    let node = resolve.nodes.iter().find(|n| &n.id == pkg_id).unwrap();\n+    node.deps.iter().map(|dep| pkg_from_id(metadata, &dep.pkg)).collect()\n+}\n+\n fn check_rustfix(metadata: &Metadata, bad: &mut bool) {\n     let cargo = pkg_from_name(metadata, \"cargo\");\n     let compiletest = pkg_from_name(metadata, \"compiletest\");\n-    let cargo_deps = deps_of(metadata, &cargo.id);\n-    let compiletest_deps = deps_of(metadata, &compiletest.id);\n+    let cargo_deps = direct_deps_of(metadata, &cargo.id);\n+    let compiletest_deps = direct_deps_of(metadata, &compiletest.id);\n     let cargo_rustfix = cargo_deps.iter().find(|p| p.name == \"rustfix\").unwrap();\n     let compiletest_rustfix = compiletest_deps.iter().find(|p| p.name == \"rustfix\").unwrap();\n     if cargo_rustfix.version != compiletest_rustfix.version {"}]}