{"sha": "d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzODdiZmRjNGFiYzQ3ZmY2MmYxZGZmZTdkNDFjZTJiYjExZTdhMDA=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-04T17:50:34Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-01-04T18:00:51Z"}, "message": "Simplify SubtreeTokenSource", "tree": {"sha": "b165e688fb6b32b743d6b505d0b48967e70eb782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b165e688fb6b32b743d6b505d0b48967e70eb782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00", "html_url": "https://github.com/rust-lang/rust/commit/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af3d75ad2e760dc885f54e6179543718ef8f141f", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3d75ad2e760dc885f54e6179543718ef8f141f", "html_url": "https://github.com/rust-lang/rust/commit/af3d75ad2e760dc885f54e6179543718ef8f141f"}], "stats": {"total": 148, "additions": 60, "deletions": 88}, "files": [{"sha": "d7433bd353c7ea37aa3f979baafbd0aacbf736fc", "filename": "crates/mbe/src/subtree_source.rs", "status": "modified", "additions": 60, "deletions": 88, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=d387bfdc4abc47ff62f1dffe7d41ce2bb11e7a00", "patch": "@@ -1,145 +1,117 @@\n //! FIXME: write short doc here\n \n use parser::{Token, TokenSource};\n-use std::cell::{Cell, Ref, RefCell};\n use syntax::{lex_single_syntax_kind, SmolStr, SyntaxKind, SyntaxKind::*, T};\n-use tt::buffer::{Cursor, TokenBuffer};\n+use tt::buffer::TokenBuffer;\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n struct TtToken {\n-    kind: SyntaxKind,\n-    is_joint_to_next: bool,\n+    tt: Token,\n     text: SmolStr,\n }\n \n-pub(crate) struct SubtreeTokenSource<'a> {\n-    cached_cursor: Cell<Cursor<'a>>,\n-    cached: RefCell<Vec<Option<TtToken>>>,\n+pub(crate) struct SubtreeTokenSource {\n+    cached: Vec<TtToken>,\n     curr: (Token, usize),\n }\n \n-impl<'a> SubtreeTokenSource<'a> {\n+impl<'a> SubtreeTokenSource {\n     // Helper function used in test\n     #[cfg(test)]\n     pub(crate) fn text(&self) -> SmolStr {\n-        match *self.get(self.curr.1) {\n+        match self.cached.get(self.curr.1) {\n             Some(ref tt) => tt.text.clone(),\n             _ => SmolStr::new(\"\"),\n         }\n     }\n }\n \n-impl<'a> SubtreeTokenSource<'a> {\n-    pub(crate) fn new(buffer: &'a TokenBuffer) -> SubtreeTokenSource<'a> {\n-        let cursor = buffer.begin();\n+impl<'a> SubtreeTokenSource {\n+    pub(crate) fn new(buffer: &TokenBuffer) -> SubtreeTokenSource {\n+        let mut current = buffer.begin();\n+        let mut cached = Vec::with_capacity(100);\n \n-        let mut res = SubtreeTokenSource {\n-            curr: (Token { kind: EOF, is_jointed_to_next: false }, 0),\n-            cached_cursor: Cell::new(cursor),\n-            cached: RefCell::new(Vec::with_capacity(10)),\n-        };\n-        res.curr = (res.mk_token(0), 0);\n-        res\n-    }\n+        while !current.eof() {\n+            let cursor = current;\n+            let tt = cursor.token_tree();\n \n-    fn mk_token(&self, pos: usize) -> Token {\n-        match *self.get(pos) {\n-            Some(ref tt) => Token { kind: tt.kind, is_jointed_to_next: tt.is_joint_to_next },\n-            None => Token { kind: EOF, is_jointed_to_next: false },\n-        }\n-    }\n-\n-    fn get(&self, pos: usize) -> Ref<Option<TtToken>> {\n-        fn is_lifetime(c: Cursor) -> Option<(Cursor, SmolStr)> {\n-            let tkn = c.token_tree();\n-\n-            if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = tkn {\n+            // Check if it is lifetime\n+            if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Punct(punct), _)) = tt {\n                 if punct.char == '\\'' {\n-                    let next = c.bump();\n+                    let next = cursor.bump();\n                     if let Some(tt::buffer::TokenTreeRef::Leaf(tt::Leaf::Ident(ident), _)) =\n                         next.token_tree()\n                     {\n-                        let res_cursor = next.bump();\n-                        let text = SmolStr::new(\"'\".to_string() + &ident.to_string());\n-\n-                        return Some((res_cursor, text));\n+                        let text = SmolStr::new(\"'\".to_string() + &ident.text);\n+                        cached.push(TtToken {\n+                            tt: Token { kind: LIFETIME_IDENT, is_jointed_to_next: false },\n+                            text,\n+                        });\n+                        current = next.bump();\n+                        continue;\n                     } else {\n                         panic!(\"Next token must be ident : {:#?}\", next.token_tree());\n                     }\n                 }\n             }\n \n-            None\n-        }\n-\n-        if pos < self.cached.borrow().len() {\n-            return Ref::map(self.cached.borrow(), |c| &c[pos]);\n-        }\n-\n-        {\n-            let mut cached = self.cached.borrow_mut();\n-            while pos >= cached.len() {\n-                let cursor = self.cached_cursor.get();\n-                if cursor.eof() {\n-                    cached.push(None);\n-                    continue;\n+            current = match tt {\n+                Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n+                    cached.push(convert_leaf(&leaf));\n+                    cursor.bump()\n                 }\n-\n-                if let Some((curr, text)) = is_lifetime(cursor) {\n-                    cached.push(Some(TtToken {\n-                        kind: LIFETIME_IDENT,\n-                        is_joint_to_next: false,\n-                        text,\n-                    }));\n-                    self.cached_cursor.set(curr);\n-                    continue;\n+                Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n+                    cached.push(convert_delim(subtree.delimiter_kind(), false));\n+                    cursor.subtree().unwrap()\n                 }\n-\n-                match cursor.token_tree() {\n-                    Some(tt::buffer::TokenTreeRef::Leaf(leaf, _)) => {\n-                        cached.push(Some(convert_leaf(&leaf)));\n-                        self.cached_cursor.set(cursor.bump());\n-                    }\n-                    Some(tt::buffer::TokenTreeRef::Subtree(subtree, _)) => {\n-                        self.cached_cursor.set(cursor.subtree().unwrap());\n-                        cached.push(Some(convert_delim(subtree.delimiter_kind(), false)));\n-                    }\n-                    None => {\n-                        if let Some(subtree) = cursor.end() {\n-                            cached.push(Some(convert_delim(subtree.delimiter_kind(), true)));\n-                            self.cached_cursor.set(cursor.bump());\n-                        }\n+                None => {\n+                    if let Some(subtree) = cursor.end() {\n+                        cached.push(convert_delim(subtree.delimiter_kind(), true));\n+                        cursor.bump()\n+                    } else {\n+                        continue;\n                     }\n                 }\n-            }\n+            };\n         }\n \n-        Ref::map(self.cached.borrow(), |c| &c[pos])\n+        let mut res = SubtreeTokenSource {\n+            curr: (Token { kind: EOF, is_jointed_to_next: false }, 0),\n+            cached,\n+        };\n+        res.curr = (res.token(0), 0);\n+        res\n+    }\n+\n+    fn token(&self, pos: usize) -> Token {\n+        match self.cached.get(pos) {\n+            Some(it) => it.tt,\n+            None => Token { kind: EOF, is_jointed_to_next: false },\n+        }\n     }\n }\n \n-impl<'a> TokenSource for SubtreeTokenSource<'a> {\n+impl<'a> TokenSource for SubtreeTokenSource {\n     fn current(&self) -> Token {\n         self.curr.0\n     }\n \n     /// Lookahead n token\n     fn lookahead_nth(&self, n: usize) -> Token {\n-        self.mk_token(self.curr.1 + n)\n+        self.token(self.curr.1 + n)\n     }\n \n     /// bump cursor to next token\n     fn bump(&mut self) {\n         if self.current().kind == EOF {\n             return;\n         }\n-\n-        self.curr = (self.mk_token(self.curr.1 + 1), self.curr.1 + 1);\n+        self.curr = (self.token(self.curr.1 + 1), self.curr.1 + 1);\n     }\n \n     /// Is the current token a specified keyword?\n     fn is_keyword(&self, kw: &str) -> bool {\n-        match *self.get(self.curr.1) {\n+        match self.cached.get(self.curr.1) {\n             Some(ref t) => t.text == *kw,\n             _ => false,\n         }\n@@ -157,7 +129,7 @@ fn convert_delim(d: Option<tt::DelimiterKind>, closing: bool) -> TtToken {\n     let idx = closing as usize;\n     let kind = kinds[idx];\n     let text = if !texts.is_empty() { &texts[idx..texts.len() - (1 - idx)] } else { \"\" };\n-    TtToken { kind, is_joint_to_next: false, text: SmolStr::new(text) }\n+    TtToken { tt: Token { kind, is_jointed_to_next: false }, text: SmolStr::new(text) }\n }\n \n fn convert_literal(l: &tt::Literal) -> TtToken {\n@@ -171,7 +143,7 @@ fn convert_literal(l: &tt::Literal) -> TtToken {\n         })\n         .unwrap_or_else(|| panic!(\"Fail to convert given literal {:#?}\", &l));\n \n-    TtToken { kind, is_joint_to_next: false, text: l.text.clone() }\n+    TtToken { tt: Token { kind, is_jointed_to_next: false }, text: l.text.clone() }\n }\n \n fn convert_ident(ident: &tt::Ident) -> TtToken {\n@@ -182,7 +154,7 @@ fn convert_ident(ident: &tt::Ident) -> TtToken {\n         _ => SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT),\n     };\n \n-    TtToken { kind, is_joint_to_next: false, text: ident.text.clone() }\n+    TtToken { tt: Token { kind, is_jointed_to_next: false }, text: ident.text.clone() }\n }\n \n fn convert_punct(p: tt::Punct) -> TtToken {\n@@ -196,7 +168,7 @@ fn convert_punct(p: tt::Punct) -> TtToken {\n         let s: &str = p.char.encode_utf8(&mut buf);\n         SmolStr::new(s)\n     };\n-    TtToken { kind, is_joint_to_next: p.spacing == tt::Spacing::Joint, text }\n+    TtToken { tt: Token { kind, is_jointed_to_next: p.spacing == tt::Spacing::Joint }, text }\n }\n \n fn convert_leaf(leaf: &tt::Leaf) -> TtToken {\n@@ -210,6 +182,7 @@ fn convert_leaf(leaf: &tt::Leaf) -> TtToken {\n #[cfg(test)]\n mod tests {\n     use super::{convert_literal, TtToken};\n+    use parser::Token;\n     use syntax::{SmolStr, SyntaxKind};\n \n     #[test]\n@@ -220,8 +193,7 @@ mod tests {\n                 text: SmolStr::new(\"-42.0\")\n             }),\n             TtToken {\n-                kind: SyntaxKind::FLOAT_NUMBER,\n-                is_joint_to_next: false,\n+                tt: Token { kind: SyntaxKind::FLOAT_NUMBER, is_jointed_to_next: false },\n                 text: SmolStr::new(\"-42.0\")\n             }\n         );"}]}