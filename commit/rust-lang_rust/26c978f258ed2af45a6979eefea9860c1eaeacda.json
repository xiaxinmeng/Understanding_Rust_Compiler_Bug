{"sha": "26c978f258ed2af45a6979eefea9860c1eaeacda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2Yzk3OGYyNThlZDJhZjQ1YTY5NzllZWZlYTk4NjBjMWVhZWFjZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T15:46:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-14T15:46:54Z"}, "message": "internal: adapt diagnostics to the new rename API", "tree": {"sha": "6b96b1d2f5ba48148dcfd6442ab9c742696e7847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b96b1d2f5ba48148dcfd6442ab9c742696e7847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26c978f258ed2af45a6979eefea9860c1eaeacda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26c978f258ed2af45a6979eefea9860c1eaeacda", "html_url": "https://github.com/rust-lang/rust/commit/26c978f258ed2af45a6979eefea9860c1eaeacda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26c978f258ed2af45a6979eefea9860c1eaeacda/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a91071b57be6e64ad2fd277998ada0ae6206457b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a91071b57be6e64ad2fd277998ada0ae6206457b", "html_url": "https://github.com/rust-lang/rust/commit/a91071b57be6e64ad2fd277998ada0ae6206457b"}], "stats": {"total": 929, "additions": 474, "deletions": 455}, "files": [{"sha": "88b6b1260189376ba87882fc3107a92d3f91c9c5", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 12, "deletions": 423, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=26c978f258ed2af45a6979eefea9860c1eaeacda", "patch": "@@ -2,44 +2,23 @@\n //!\n //! All reference and file rename requests go through here where the corresponding [`SourceChange`]s\n //! will be calculated.\n-use std::fmt::{self, Display};\n-\n-use either::Either;\n-use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n+use hir::{AsAssocItem, InFile, Semantics};\n use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId, FileRange},\n+    base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::FileReference,\n+    rename::{bail, format_err, source_edit_from_references, IdentifierKind},\n     RootDatabase,\n };\n use stdx::never;\n-use syntax::{\n-    ast::{self, NameOwner},\n-    lex_single_syntax_kind, AstNode, SyntaxKind, SyntaxNode, T,\n-};\n+use syntax::{ast, AstNode, SyntaxNode};\n \n use text_edit::TextEdit;\n \n-use crate::{FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n-\n-type RenameResult<T> = Result<T, RenameError>;\n-#[derive(Debug)]\n-pub struct RenameError(String);\n-\n-impl fmt::Display for RenameError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Display::fmt(&self.0, f)\n-    }\n-}\n+use crate::{FilePosition, RangeInfo, SourceChange};\n \n-macro_rules! format_err {\n-    ($fmt:expr) => {RenameError(format!($fmt))};\n-    ($fmt:expr, $($arg:tt)+) => {RenameError(format!($fmt, $($arg)+))}\n-}\n+pub use ide_db::rename::RenameError;\n \n-macro_rules! bail {\n-    ($($tokens:tt)*) => {return Err(format_err!($($tokens)*))}\n-}\n+type RenameResult<T> = Result<T, RenameError>;\n \n /// Prepares a rename. The sole job of this function is to return the TextRange of the thing that is\n /// being targeted for a rename.\n@@ -52,8 +31,8 @@ pub(crate) fn prepare_rename(\n     let syntax = source_file.syntax();\n \n     let def = find_definition(&sema, syntax, position)?;\n-    let frange = def_name_range(&&sema, def)\n-        .ok_or_else(|| format_err!(\"No references found at position\"))?;\n+    let frange =\n+        def.rename_range(&sema).ok_or_else(|| format_err!(\"No references found at position\"))?;\n     Ok(RangeInfo::new(frange.range, ()))\n }\n \n@@ -98,14 +77,7 @@ pub(crate) fn rename_with_semantics(\n         }\n     }\n \n-    match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n-        Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-            bail!(\"Cannot rename builtin type\")\n-        }\n-        def => rename_reference(sema, def, new_name),\n-    }\n+    def.rename(sema, new_name)\n }\n \n /// Called by the client when it is about to rename a file.\n@@ -116,38 +88,12 @@ pub(crate) fn will_rename_file(\n ) -> Option<SourceChange> {\n     let sema = Semantics::new(db);\n     let module = sema.to_module_def(file_id)?;\n-    let mut change = rename_mod(&sema, module, new_name_stem).ok()?;\n+    let def = Definition::ModuleDef(module.into());\n+    let mut change = def.rename(&sema, new_name_stem).ok()?;\n     change.file_system_edits.clear();\n     Some(change)\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-enum IdentifierKind {\n-    Ident,\n-    Lifetime,\n-    Underscore,\n-}\n-\n-impl IdentifierKind {\n-    fn classify(new_name: &str) -> RenameResult<IdentifierKind> {\n-        match lex_single_syntax_kind(new_name) {\n-            Some(res) => match res {\n-                (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n-                (T![_], _) => Ok(IdentifierKind::Underscore),\n-                (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n-                    Ok(IdentifierKind::Lifetime)\n-                }\n-                (SyntaxKind::LIFETIME_IDENT, _) => {\n-                    bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n-                }\n-                (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n-                (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-            },\n-            None => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        }\n-    }\n-}\n-\n fn find_definition(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n@@ -189,126 +135,6 @@ fn find_definition(\n     .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn rename_mod(\n-    sema: &Semantics<RootDatabase>,\n-    module: hir::Module,\n-    new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    if IdentifierKind::classify(new_name)? != IdentifierKind::Ident {\n-        bail!(\"Invalid name `{0}`: cannot rename module to {0}\", new_name);\n-    }\n-\n-    let mut source_change = SourceChange::default();\n-\n-    let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n-    let file_id = file_id.original_file(sema.db);\n-    if let ModuleSource::SourceFile(..) = def_source {\n-        // mod is defined in path/to/dir/mod.rs\n-        let path = if module.is_mod_rs(sema.db) {\n-            format!(\"../{}/mod.rs\", new_name)\n-        } else {\n-            format!(\"{}.rs\", new_name)\n-        };\n-        let dst = AnchoredPathBuf { anchor: file_id, path };\n-        let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n-        source_change.push_file_system_edit(move_file);\n-    }\n-\n-    if let Some(InFile { file_id, value: decl_source }) = module.declaration_source(sema.db) {\n-        let file_id = file_id.original_file(sema.db);\n-        match decl_source.name() {\n-            Some(name) => source_change.insert_source_edit(\n-                file_id,\n-                TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n-            ),\n-            _ => never!(\"Module source node is missing a name\"),\n-        }\n-    }\n-    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n-    let usages = def.usages(sema).all();\n-    let ref_edits = usages.iter().map(|(&file_id, references)| {\n-        (file_id, source_edit_from_references(references, def, new_name))\n-    });\n-    source_change.extend(ref_edits);\n-\n-    Ok(source_change)\n-}\n-\n-fn rename_reference(\n-    sema: &Semantics<RootDatabase>,\n-    mut def: Definition,\n-    new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    let ident_kind = IdentifierKind::classify(new_name)?;\n-\n-    if matches!(\n-        def, // is target a lifetime?\n-        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n-    ) {\n-        match ident_kind {\n-            IdentifierKind::Ident | IdentifierKind::Underscore => {\n-                cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n-                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name);\n-            }\n-            IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n-        }\n-    } else {\n-        match (ident_kind, def) {\n-            (IdentifierKind::Lifetime, _) => {\n-                cov_mark::hit!(rename_not_an_ident_ref);\n-                bail!(\"Invalid name `{}`: not an identifier\", new_name);\n-            }\n-            (IdentifierKind::Ident, _) => cov_mark::hit!(rename_non_local),\n-            (IdentifierKind::Underscore, _) => (),\n-        }\n-    }\n-\n-    def = match def {\n-        // HACK: resolve trait impl items to the item def of the trait definition\n-        // so that we properly resolve all trait item references\n-        Definition::ModuleDef(mod_def) => mod_def\n-            .as_assoc_item(sema.db)\n-            .and_then(|it| it.containing_trait_impl(sema.db))\n-            .and_then(|it| {\n-                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n-                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n-                        if trait_func.name(sema.db) == func.name(sema.db) =>\n-                    {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n-                    }\n-                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n-                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n-                    {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n-                    }\n-                    (\n-                        hir::AssocItem::TypeAlias(trait_type_alias),\n-                        hir::ModuleDef::TypeAlias(type_alias),\n-                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n-                    }\n-                    _ => None,\n-                })\n-            })\n-            .unwrap_or(def),\n-        _ => def,\n-    };\n-    let usages = def.usages(sema).all();\n-\n-    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n-        cov_mark::hit!(rename_underscore_multiple);\n-        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n-    }\n-    let mut source_change = SourceChange::default();\n-    source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        (file_id, source_edit_from_references(references, def, new_name))\n-    }));\n-\n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n-    Ok(source_change)\n-}\n-\n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n     if never!(local.is_self(sema.db)) {\n         bail!(\"rename_to_self invoked on self\");\n@@ -426,243 +252,6 @@ fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Opt\n     Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n }\n \n-fn source_edit_from_references(\n-    references: &[FileReference],\n-    def: Definition,\n-    new_name: &str,\n-) -> TextEdit {\n-    let mut edit = TextEdit::builder();\n-    for reference in references {\n-        let (range, replacement) = match &reference.name {\n-            // if the ranges differ then the node is inside a macro call, we can't really attempt\n-            // to make special rewrites like shorthand syntax and such, so just rename the node in\n-            // the macro input\n-            ast::NameLike::NameRef(name_ref)\n-                if name_ref.syntax().text_range() == reference.range =>\n-            {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n-            }\n-            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n-            }\n-            _ => None,\n-        }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n-    }\n-    edit.finish()\n-}\n-\n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n-    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n-        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                [new_name, \": \"].concat(),\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n-fn source_edit_from_name_ref(\n-    name_ref: &ast::NameRef,\n-    new_name: &str,\n-    def: Definition,\n-) -> Option<(TextRange, String)> {\n-    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_expr = record_field.expr();\n-        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n-            // field: init-expr, check if we can use a field init shorthand\n-            (Some(field_name), Some(init)) => {\n-                if field_name == *name_ref {\n-                    if init.text() == new_name {\n-                        cov_mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                } else if init == *name_ref {\n-                    if field_name.text() == new_name {\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                }\n-                None\n-            }\n-            // init shorthand\n-            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n-                cov_mark::hit!(test_rename_field_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n-            }\n-            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n-                cov_mark::hit!(test_rename_local_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n-            }\n-            _ => None,\n-        }\n-    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_pat = record_field.pat();\n-        match (rcf_name_ref, rcf_pat) {\n-            // field: rename\n-            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n-                // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn source_edit_from_def(\n-    sema: &Semantics<RootDatabase>,\n-    def: Definition,\n-    new_name: &str,\n-) -> RenameResult<(FileId, TextEdit)> {\n-    let frange: FileRange = def_name_range(sema, def)\n-        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-\n-    let mut replacement_text = String::new();\n-    let mut repl_range = frange.range;\n-    if let Definition::Local(local) = def {\n-        if let Either::Left(pat) = local.source(sema.db).value {\n-            if matches!(\n-                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n-                Some(pat_field) if pat_field.name_ref().is_none()\n-            ) {\n-                replacement_text.push_str(\": \");\n-                replacement_text.push_str(new_name);\n-                repl_range = TextRange::new(\n-                    pat.syntax().text_range().end(),\n-                    pat.syntax().text_range().end(),\n-                );\n-            }\n-        }\n-    }\n-    if replacement_text.is_empty() {\n-        replacement_text.push_str(new_name);\n-    }\n-    let edit = TextEdit::replace(repl_range, replacement_text);\n-    Ok((frange.file_id, edit))\n-}\n-\n-fn def_name_range(sema: &Semantics<RootDatabase>, def: Definition) -> Option<FileRange> {\n-    // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n-    // and _fall back_ to the entirety of the macro call. Such fall back is\n-    // incorrect for renames. The safe behavior would be to return an error for\n-    // such cases. The correct behavior would be to return an auxiliary list of\n-    // \"can't rename these occurrences in macros\" items, and then show some kind\n-    // of a dialog to the user.\n-\n-    let res = match def {\n-        Definition::Macro(mac) => {\n-            let src = mac.source(sema.db)?;\n-            let name = match &src.value {\n-                Either::Left(it) => it.name()?,\n-                Either::Right(it) => it.name()?,\n-            };\n-            src.with_value(name.syntax()).original_file_range(sema.db)\n-        }\n-        Definition::Field(field) => {\n-            let src = field.source(sema.db)?;\n-\n-            match &src.value {\n-                FieldSource::Named(record_field) => {\n-                    let name = record_field.name()?;\n-                    src.with_value(name.syntax()).original_file_range(sema.db)\n-                }\n-                FieldSource::Pos(_) => {\n-                    return None;\n-                }\n-            }\n-        }\n-        Definition::ModuleDef(module_def) => match module_def {\n-            hir::ModuleDef::Module(module) => {\n-                let src = module.declaration_source(sema.db)?;\n-                let name = src.value.name()?;\n-                src.with_value(name.syntax()).original_file_range(sema.db)\n-            }\n-            hir::ModuleDef::Function(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Adt(adt) => match adt {\n-                hir::Adt::Struct(it) => name_range(it, sema)?,\n-                hir::Adt::Union(it) => name_range(it, sema)?,\n-                hir::Adt::Enum(it) => name_range(it, sema)?,\n-            },\n-            hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Const(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Static(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n-            hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n-            hir::ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::SelfType(_) => return None,\n-        Definition::Local(local) => {\n-            let src = local.source(sema.db);\n-            let name = match &src.value {\n-                Either::Left(bind_pat) => bind_pat.name()?,\n-                Either::Right(_) => return None,\n-            };\n-            src.with_value(name.syntax()).original_file_range(sema.db)\n-        }\n-        Definition::GenericParam(generic_param) => match generic_param {\n-            hir::GenericParam::TypeParam(type_param) => {\n-                let src = type_param.source(sema.db)?;\n-                let name = match &src.value {\n-                    Either::Left(_) => return None,\n-                    Either::Right(type_param) => type_param.name()?,\n-                };\n-                src.with_value(name.syntax()).original_file_range(sema.db)\n-            }\n-            hir::GenericParam::LifetimeParam(lifetime_param) => {\n-                let src = lifetime_param.source(sema.db)?;\n-                let lifetime = src.value.lifetime()?;\n-                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n-            }\n-            hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n-        },\n-        Definition::Label(label) => {\n-            let src = label.source(sema.db);\n-            let lifetime = src.value.lifetime()?;\n-            src.with_value(lifetime.syntax()).original_file_range(sema.db)\n-        }\n-    };\n-    return Some(res);\n-\n-    fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n-    where\n-        D: HasSource,\n-        D::Ast: ast::NameOwner,\n-    {\n-        let src = def.source(sema.db)?;\n-        let name = src.value.name()?;\n-        let res = src.with_value(name.syntax()).original_file_range(sema.db);\n-        Some(res)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};"}, {"sha": "7bbd08d6f1764300125fd722f02d080e4f983aff", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=26c978f258ed2af45a6979eefea9860c1eaeacda", "patch": "@@ -8,14 +8,16 @@ pub mod label;\n pub mod line_index;\n pub mod symbol_index;\n pub mod defs;\n-pub mod search;\n pub mod items_locator;\n pub mod source_change;\n pub mod ty_filter;\n pub mod traits;\n pub mod call_info;\n pub mod helpers;\n \n+pub mod search;\n+pub mod rename;\n+\n use std::{fmt, sync::Arc};\n \n use base_db::{"}, {"sha": "877650df0fe2b52cf7b9dccfb7556711130e2bc5", "filename": "crates/ide_db/src/rename.rs", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=26c978f258ed2af45a6979eefea9860c1eaeacda", "patch": "@@ -0,0 +1,444 @@\n+use std::fmt;\n+\n+use base_db::{AnchoredPathBuf, FileId, FileRange};\n+use either::Either;\n+use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n+use stdx::never;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    lex_single_syntax_kind, AstNode, SyntaxKind, TextRange, T,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    defs::Definition,\n+    search::FileReference,\n+    source_change::{FileSystemEdit, SourceChange},\n+    RootDatabase,\n+};\n+\n+pub type Result<T, E = RenameError> = std::result::Result<T, E>;\n+\n+#[derive(Debug)]\n+pub struct RenameError(pub String);\n+\n+impl fmt::Display for RenameError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! _format_err {\n+    ($fmt:expr) => { RenameError(format!($fmt)) };\n+    ($fmt:expr, $($arg:tt)+) => { RenameError(format!($fmt, $($arg)+)) }\n+}\n+pub use _format_err as format_err;\n+\n+#[macro_export]\n+macro_rules! _bail {\n+    ($($tokens:tt)*) => { return Err(format_err!($($tokens)*)) }\n+}\n+pub use _bail as bail;\n+\n+impl Definition {\n+    pub fn rename(&self, sema: &Semantics<RootDatabase>, new_name: &str) -> Result<SourceChange> {\n+        match *self {\n+            Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                rename_mod(sema, module, new_name)\n+            }\n+            Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+                bail!(\"Cannot rename builtin type\")\n+            }\n+            Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n+            def => rename_reference(sema, def, new_name),\n+        }\n+    }\n+\n+    /// Textual range of the identifier which will change when renaming this\n+    /// `Definition`. Note that some definitions, like buitin types, can't be\n+    /// renamed.\n+    pub fn rename_range(self, sema: &Semantics<RootDatabase>) -> Option<FileRange> {\n+        // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n+        // and _fall back_ to the entirety of the macro call. Such fall back is\n+        // incorrect for renames. The safe behavior would be to return an error for\n+        // such cases. The correct behavior would be to return an auxiliary list of\n+        // \"can't rename these occurrences in macros\" items, and then show some kind\n+        // of a dialog to the user.\n+\n+        let res = match self {\n+            Definition::Macro(mac) => {\n+                let src = mac.source(sema.db)?;\n+                let name = match &src.value {\n+                    Either::Left(it) => it.name()?,\n+                    Either::Right(it) => it.name()?,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            Definition::Field(field) => {\n+                let src = field.source(sema.db)?;\n+\n+                match &src.value {\n+                    FieldSource::Named(record_field) => {\n+                        let name = record_field.name()?;\n+                        src.with_value(name.syntax()).original_file_range(sema.db)\n+                    }\n+                    FieldSource::Pos(_) => {\n+                        return None;\n+                    }\n+                }\n+            }\n+            Definition::ModuleDef(module_def) => match module_def {\n+                hir::ModuleDef::Module(module) => {\n+                    let src = module.declaration_source(sema.db)?;\n+                    let name = src.value.name()?;\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                hir::ModuleDef::Function(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Adt(adt) => match adt {\n+                    hir::Adt::Struct(it) => name_range(it, sema)?,\n+                    hir::Adt::Union(it) => name_range(it, sema)?,\n+                    hir::Adt::Enum(it) => name_range(it, sema)?,\n+                },\n+                hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Const(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Static(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n+                hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n+                hir::ModuleDef::BuiltinType(_) => return None,\n+            },\n+            Definition::SelfType(_) => return None,\n+            Definition::Local(local) => {\n+                let src = local.source(sema.db);\n+                let name = match &src.value {\n+                    Either::Left(bind_pat) => bind_pat.name()?,\n+                    Either::Right(_) => return None,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            Definition::GenericParam(generic_param) => match generic_param {\n+                hir::GenericParam::TypeParam(type_param) => {\n+                    let src = type_param.source(sema.db)?;\n+                    let name = match &src.value {\n+                        Either::Left(_) => return None,\n+                        Either::Right(type_param) => type_param.name()?,\n+                    };\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                hir::GenericParam::LifetimeParam(lifetime_param) => {\n+                    let src = lifetime_param.source(sema.db)?;\n+                    let lifetime = src.value.lifetime()?;\n+                    src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+                }\n+                hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n+            },\n+            Definition::Label(label) => {\n+                let src = label.source(sema.db);\n+                let lifetime = src.value.lifetime()?;\n+                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+            }\n+        };\n+        return Some(res);\n+\n+        fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n+        where\n+            D: HasSource,\n+            D::Ast: ast::NameOwner,\n+        {\n+            let src = def.source(sema.db)?;\n+            let name = src.value.name()?;\n+            let res = src.with_value(name.syntax()).original_file_range(sema.db);\n+            Some(res)\n+        }\n+    }\n+}\n+\n+fn rename_mod(\n+    sema: &Semantics<RootDatabase>,\n+    module: hir::Module,\n+    new_name: &str,\n+) -> Result<SourceChange> {\n+    if IdentifierKind::classify(new_name)? != IdentifierKind::Ident {\n+        bail!(\"Invalid name `{0}`: cannot rename module to {0}\", new_name);\n+    }\n+\n+    let mut source_change = SourceChange::default();\n+\n+    let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n+    let file_id = file_id.original_file(sema.db);\n+    if let ModuleSource::SourceFile(..) = def_source {\n+        // mod is defined in path/to/dir/mod.rs\n+        let path = if module.is_mod_rs(sema.db) {\n+            format!(\"../{}/mod.rs\", new_name)\n+        } else {\n+            format!(\"{}.rs\", new_name)\n+        };\n+        let dst = AnchoredPathBuf { anchor: file_id, path };\n+        let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n+        source_change.push_file_system_edit(move_file);\n+    }\n+\n+    if let Some(InFile { file_id, value: decl_source }) = module.declaration_source(sema.db) {\n+        let file_id = file_id.original_file(sema.db);\n+        match decl_source.name() {\n+            Some(name) => source_change.insert_source_edit(\n+                file_id,\n+                TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n+            ),\n+            _ => never!(\"Module source node is missing a name\"),\n+        }\n+    }\n+    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n+    let usages = def.usages(sema).all();\n+    let ref_edits = usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(references, def, new_name))\n+    });\n+    source_change.extend(ref_edits);\n+\n+    Ok(source_change)\n+}\n+\n+fn rename_reference(\n+    sema: &Semantics<RootDatabase>,\n+    mut def: Definition,\n+    new_name: &str,\n+) -> Result<SourceChange> {\n+    let ident_kind = IdentifierKind::classify(new_name)?;\n+\n+    if matches!(\n+        def, // is target a lifetime?\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n+    ) {\n+        match ident_kind {\n+            IdentifierKind::Ident | IdentifierKind::Underscore => {\n+                cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n+                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name);\n+            }\n+            IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n+        }\n+    } else {\n+        match (ident_kind, def) {\n+            (IdentifierKind::Lifetime, _) => {\n+                cov_mark::hit!(rename_not_an_ident_ref);\n+                bail!(\"Invalid name `{}`: not an identifier\", new_name);\n+            }\n+            (IdentifierKind::Ident, _) => cov_mark::hit!(rename_non_local),\n+            (IdentifierKind::Underscore, _) => (),\n+        }\n+    }\n+\n+    def = match def {\n+        // HACK: resolve trait impl items to the item def of the trait definition\n+        // so that we properly resolve all trait item references\n+        Definition::ModuleDef(mod_def) => mod_def\n+            .as_assoc_item(sema.db)\n+            .and_then(|it| it.containing_trait_impl(sema.db))\n+            .and_then(|it| {\n+                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n+                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n+                        if trait_func.name(sema.db) == func.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n+                    }\n+                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n+                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n+                    }\n+                    (\n+                        hir::AssocItem::TypeAlias(trait_type_alias),\n+                        hir::ModuleDef::TypeAlias(type_alias),\n+                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n+                    }\n+                    _ => None,\n+                })\n+            })\n+            .unwrap_or(def),\n+        _ => def,\n+    };\n+    let usages = def.usages(sema).all();\n+\n+    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n+        cov_mark::hit!(rename_underscore_multiple);\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n+    let mut source_change = SourceChange::default();\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(references, def, new_name))\n+    }));\n+\n+    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+    source_change.insert_source_edit(file_id, edit);\n+    Ok(source_change)\n+}\n+\n+pub fn source_edit_from_references(\n+    references: &[FileReference],\n+    def: Definition,\n+    new_name: &str,\n+) -> TextEdit {\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let (range, replacement) = match &reference.name {\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            ast::NameLike::NameRef(name_ref)\n+                if name_ref.syntax().text_range() == reference.range =>\n+            {\n+                source_edit_from_name_ref(name_ref, new_name, def)\n+            }\n+            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n+                source_edit_from_name(name, new_name)\n+            }\n+            _ => None,\n+        }\n+        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n+        edit.replace(range, replacement);\n+    }\n+    edit.finish()\n+}\n+\n+fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            return Some((\n+                TextRange::empty(ident_pat.syntax().text_range().start()),\n+                [new_name, \": \"].concat(),\n+            ));\n+        }\n+    }\n+    None\n+}\n+\n+fn source_edit_from_name_ref(\n+    name_ref: &ast::NameRef,\n+    new_name: &str,\n+    def: Definition,\n+) -> Option<(TextRange, String)> {\n+    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_expr = record_field.expr();\n+        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+            // field: init-expr, check if we can use a field init shorthand\n+            (Some(field_name), Some(init)) => {\n+                if field_name == *name_ref {\n+                    if init.text() == new_name {\n+                        cov_mark::hit!(test_rename_field_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                } else if init == *name_ref {\n+                    if field_name.text() == new_name {\n+                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                }\n+                None\n+            }\n+            // init shorthand\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n+                cov_mark::hit!(test_rename_field_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().start();\n+                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+            }\n+            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n+                cov_mark::hit!(test_rename_local_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().end();\n+                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+            }\n+            _ => None,\n+        }\n+    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_pat = record_field.pat();\n+        match (rcf_name_ref, rcf_pat) {\n+            // field: rename\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+                // field name is being renamed\n+                if pat.name().map_or(false, |it| it.text() == new_name) {\n+                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    // same names, we can use a shorthand here instead/\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().start();\n+                    let e = record_field.syntax().text_range().end();\n+                    Some((TextRange::new(s, e), pat.to_string()))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn source_edit_from_def(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    new_name: &str,\n+) -> Result<(FileId, TextEdit)> {\n+    let frange =\n+        def.rename_range(sema).ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+\n+    let mut replacement_text = String::new();\n+    let mut repl_range = frange.range;\n+    if let Definition::Local(local) = def {\n+        if let Either::Left(pat) = local.source(sema.db).value {\n+            if matches!(\n+                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n+                Some(pat_field) if pat_field.name_ref().is_none()\n+            ) {\n+                replacement_text.push_str(\": \");\n+                replacement_text.push_str(new_name);\n+                repl_range = TextRange::new(\n+                    pat.syntax().text_range().end(),\n+                    pat.syntax().text_range().end(),\n+                );\n+            }\n+        }\n+    }\n+    if replacement_text.is_empty() {\n+        replacement_text.push_str(new_name);\n+    }\n+    let edit = TextEdit::replace(repl_range, replacement_text);\n+    Ok((frange.file_id, edit))\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum IdentifierKind {\n+    Ident,\n+    Lifetime,\n+    Underscore,\n+}\n+\n+impl IdentifierKind {\n+    pub fn classify(new_name: &str) -> Result<IdentifierKind> {\n+        match lex_single_syntax_kind(new_name) {\n+            Some(res) => match res {\n+                (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n+                (T![_], _) => Ok(IdentifierKind::Underscore),\n+                (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n+                    Ok(IdentifierKind::Lifetime)\n+                }\n+                (SyntaxKind::LIFETIME_IDENT, _) => {\n+                    bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n+                }\n+                (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n+                (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+            },\n+            None => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        }\n+    }\n+}"}, {"sha": "2cf232d56419237a02bb5ded0a73a733effc7876", "filename": "crates/ide_diagnostics/src/incorrect_case.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_diagnostics%2Fsrc%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26c978f258ed2af45a6979eefea9860c1eaeacda/crates%2Fide_diagnostics%2Fsrc%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fincorrect_case.rs?ref=26c978f258ed2af45a6979eefea9860c1eaeacda", "patch": "@@ -1,5 +1,5 @@\n use hir::{db::AstDatabase, InFile};\n-use ide_db::{assists::Assist, base_db::FilePosition};\n+use ide_db::{assists::Assist, defs::NameClass};\n use syntax::AstNode;\n \n use crate::{\n@@ -27,35 +27,26 @@ pub(super) fn incorrect_case(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCas\n }\n \n fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Option<Vec<Assist>> {\n-    if true {\n-        return None;\n-    }\n-\n     let root = ctx.sema.db.parse_or_expand(d.file)?;\n     let name_node = d.ident.to_node(&root);\n+    let def = NameClass::classify(&ctx.sema, &name_node)?.defined(ctx.sema.db)?;\n \n     let name_node = InFile::new(d.file, name_node.syntax());\n     let frange = name_node.original_file_range(ctx.sema.db);\n-    let _file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let label = format!(\"Rename to {}\", d.suggested_text);\n-    let res = unresolved_fix(\"change_case\", &label, frange.range);\n+    let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n     if ctx.resolve.should_resolve(&res.id) {\n-        //let source_change = rename_with_semantics(&ctx.sema, file_position, &d.suggested_text);\n-        //res.source_change = Some(source_change.ok().unwrap_or_default());\n-        todo!()\n+        let source_change = def.rename(&ctx.sema, &d.suggested_text);\n+        res.source_change = Some(source_change.ok().unwrap_or_default());\n     }\n \n     Some(vec![res])\n }\n \n-#[cfg(TODO)]\n+#[cfg(test)]\n mod change_case {\n-    use crate::{\n-        fixture,\n-        tests::{check_diagnostics, check_fix},\n-        AssistResolveStrategy, DiagnosticsConfig,\n-    };\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn test_rename_incorrect_case() {\n@@ -123,7 +114,7 @@ fn some_fn() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n-    const ANOTHER_ITEM$0: &str = \"some_item\";\n+    const ANOTHER_ITEM: &str = \"some_item\";\n }\n \"#,\n         );\n@@ -155,20 +146,13 @@ impl TestStruct {\n \n     #[test]\n     fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n-        let input = r#\"fn FOO$0() {}\"#;\n-        let expected = r#\"fn foo() {}\"#;\n-\n-        let (analysis, file_position) = fixture::position(input);\n-        let diagnostics = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap();\n-        assert_eq!(diagnostics.len(), 1);\n-\n-        check_fix(input, expected);\n+        check_diagnostics(\n+            r#\"\n+fn FOO() {}\n+// ^^^ Function `FOO` should have snake_case name, e.g. `foo`\n+\"#,\n+        );\n+        check_fix(r#\"fn FOO$0() {}\"#, r#\"fn foo() {}\"#);\n     }\n \n     #[test]"}]}