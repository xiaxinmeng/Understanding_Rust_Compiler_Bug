{"sha": "747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0N2Q1ZDk5Y2RiZTQ5ZDU5MGIzZTBiODg1Njk1M2YxYTU0NWZkZDc=", "commit": {"author": {"name": "Roman Stoliar", "email": "rizakrko@rambler.ru", "date": "2018-05-09T07:47:09Z"}, "committer": {"name": "Roman Stoliar", "email": "rizakrko@rambler.ru", "date": "2018-05-11T12:12:53Z"}, "message": "[wip] fixed some error, added missing test", "tree": {"sha": "356650710698dd0668b56b562b065f7dce3d2ffe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/356650710698dd0668b56b562b065f7dce3d2ffe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "html_url": "https://github.com/rust-lang/rust/commit/747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/comments", "author": {"login": "rizakrko", "id": 18172179, "node_id": "MDQ6VXNlcjE4MTcyMTc5", "avatar_url": "https://avatars.githubusercontent.com/u/18172179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rizakrko", "html_url": "https://github.com/rizakrko", "followers_url": "https://api.github.com/users/rizakrko/followers", "following_url": "https://api.github.com/users/rizakrko/following{/other_user}", "gists_url": "https://api.github.com/users/rizakrko/gists{/gist_id}", "starred_url": "https://api.github.com/users/rizakrko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rizakrko/subscriptions", "organizations_url": "https://api.github.com/users/rizakrko/orgs", "repos_url": "https://api.github.com/users/rizakrko/repos", "events_url": "https://api.github.com/users/rizakrko/events{/privacy}", "received_events_url": "https://api.github.com/users/rizakrko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rizakrko", "id": 18172179, "node_id": "MDQ6VXNlcjE4MTcyMTc5", "avatar_url": "https://avatars.githubusercontent.com/u/18172179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rizakrko", "html_url": "https://github.com/rizakrko", "followers_url": "https://api.github.com/users/rizakrko/followers", "following_url": "https://api.github.com/users/rizakrko/following{/other_user}", "gists_url": "https://api.github.com/users/rizakrko/gists{/gist_id}", "starred_url": "https://api.github.com/users/rizakrko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rizakrko/subscriptions", "organizations_url": "https://api.github.com/users/rizakrko/orgs", "repos_url": "https://api.github.com/users/rizakrko/repos", "events_url": "https://api.github.com/users/rizakrko/events{/privacy}", "received_events_url": "https://api.github.com/users/rizakrko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56fbc63456d204c32e53e82c2277445d31ce983d", "url": "https://api.github.com/repos/rust-lang/rust/commits/56fbc63456d204c32e53e82c2277445d31ce983d", "html_url": "https://github.com/rust-lang/rust/commit/56fbc63456d204c32e53e82c2277445d31ce983d"}], "stats": {"total": 152, "additions": 77, "deletions": 75}, "files": [{"sha": "51a455dc25c1e0f2f447bda2e1a1c8fc3af7c6ce", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 60, "deletions": 73, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "patch": "@@ -246,7 +246,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Err(()) => {\n                 // error types are considered \"builtin\"\n                 if !lhs_ty.references_error() {\n-                    match is_assign{\n+                    let codemap = self.tcx.sess.codemap();\n+                    match is_assign {\n                         IsAssign::Yes => {\n                             let mut err = struct_span_err!(self.tcx.sess, expr.span, E0368,\n                                                 \"binary assignment operation `{}=` \\\n@@ -256,19 +257,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             err.span_label(lhs_expr.span,\n                                     format!(\"cannot use `{}=` on type `{}`\",\n                                     op.node.as_str(), lhs_ty));\n-                            let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n-                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n-                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n-                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n-                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n-                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n-                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n-                                _             => None\n-                            };\n                             let mut suggested_deref = false;\n                             if let TyRef(_, ref ty_mut) = lhs_ty.sty {\n                                 if {\n@@ -280,22 +268,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                 Op::Binary(op, is_assign))\n                                             .is_ok()\n                                 } {\n-                                    let codemap = self.tcx.sess.codemap();\n-                                    match codemap.span_to_snippet(lhs_expr.span) {\n-                                        Ok(lstring) =>{\n-                                            let msg = &format!(\n+                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                        let msg = &format!(\n                                                 \"`{}=` can be used on '{}', you can \\\n                                                 dereference `{2}`: `*{2}`\",\n                                                 op.node.as_str(), ty_mut.ty, lstring);\n-                                            err.help(msg);\n-                                            suggested_deref = true;\n-                                        },\n-                                        _ => {}\n-                                    };\n+                                        err.help(msg);\n+                                        suggested_deref = true;\n+                                    }\n                                 }\n                             }\n+                            let missing_trait = match op.node {\n+                                hir::BiAdd    => Some(\"std::ops::AddAssign\"),\n+                                hir::BiSub    => Some(\"std::ops::SubAssign\"),\n+                                hir::BiMul    => Some(\"std::ops::MulAssign\"),\n+                                hir::BiDiv    => Some(\"std::ops::DivAssign\"),\n+                                hir::BiRem    => Some(\"std::ops::RemAssign\"),\n+                                hir::BiBitAnd => Some(\"std::ops::BitAndAssign\"),\n+                                hir::BiBitXor => Some(\"std::ops::BitXorAssign\"),\n+                                hir::BiBitOr  => Some(\"std::ops::BitOrAssign\"),\n+                                hir::BiShl    => Some(\"std::ops::ShlAssign\"),\n+                                hir::BiShr    => Some(\"std::ops::ShrAssign\"),\n+                                _             => None\n+                            };\n                             if let Some(missing_trait) = missing_trait {\n-                                if missing_trait == \"std::ops::AddAssign\" &&\n+                                if op.node == hir::BiAdd &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -306,13 +303,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     err.note(\n                                         &format!(\"`{}` might need a bound for `{}`\",\n                                                     lhs_ty, missing_trait));\n-                                } else {\n-                                    if !suggested_deref{\n-                                        err.note(\n-                                            &format!(\"an implementation of `{}` might \\\n-                                                        be missing for `{}`\",\n-                                                        missing_trait, lhs_ty));\n-                                    }\n+                                } else if !suggested_deref {\n+                                    err.note(\n+                                        &format!(\"an implementation of `{}` might \\\n+                                                    be missing for `{}`\",\n+                                                    missing_trait, lhs_ty));\n                                 }\n                             }\n                             err.emit();\n@@ -322,22 +317,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             \"binary operation `{}` cannot be applied to type `{}`\",\n                                             op.node.as_str(),\n                                             lhs_ty);\n-                            let missing_trait = match op.node {\n-                                hir::BiAdd    => Some(\"std::ops::Add\"),\n-                                hir::BiSub    => Some(\"std::ops::Sub\"),\n-                                hir::BiMul    => Some(\"std::ops::Mul\"),\n-                                hir::BiDiv    => Some(\"std::ops::Div\"),\n-                                hir::BiRem    => Some(\"std::ops::Rem\"),\n-                                hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n-                                hir::BiBitXor => Some(\"std::ops::BitXor\"),\n-                                hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n-                                hir::BiShl    => Some(\"std::ops::Shl\"),\n-                                hir::BiShr    => Some(\"std::ops::Shr\"),\n-                                hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n-                                hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n-                                    Some(\"std::cmp::PartialOrd\"),\n-                                _             => None\n-                            };\n                             let mut suggested_deref = false;\n                             if let TyRef(_, ref ty_mut) = lhs_ty.sty {\n                                 if {\n@@ -349,22 +328,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                 Op::Binary(op, is_assign))\n                                             .is_ok()\n                                 } {\n-                                    let codemap = self.tcx.sess.codemap();\n-                                    match codemap.span_to_snippet(lhs_expr.span) {\n-                                        Ok(lstring) =>{\n-                                            let msg = &format!(\n+                                    if let Ok(lstring) = codemap.span_to_snippet(lhs_expr.span) {\n+                                        let msg = &format!(\n                                                 \"`{}` can be used on '{}', you can \\\n                                                 dereference `{2}`: `*{2}`\",\n                                                 op.node.as_str(), ty_mut.ty, lstring);\n-                                            err.help(msg);\n-                                            suggested_deref = true;\n-                                        },\n-                                        _ =>{}\n+                                        err.help(msg);\n+                                        suggested_deref = true;\n                                     }\n                                 }\n                             }\n+                            let missing_trait = match op.node {\n+                                hir::BiAdd    => Some(\"std::ops::Add\"),\n+                                hir::BiSub    => Some(\"std::ops::Sub\"),\n+                                hir::BiMul    => Some(\"std::ops::Mul\"),\n+                                hir::BiDiv    => Some(\"std::ops::Div\"),\n+                                hir::BiRem    => Some(\"std::ops::Rem\"),\n+                                hir::BiBitAnd => Some(\"std::ops::BitAnd\"),\n+                                hir::BiBitXor => Some(\"std::ops::BitXor\"),\n+                                hir::BiBitOr  => Some(\"std::ops::BitOr\"),\n+                                hir::BiShl    => Some(\"std::ops::Shl\"),\n+                                hir::BiShr    => Some(\"std::ops::Shr\"),\n+                                hir::BiEq | hir::BiNe => Some(\"std::cmp::PartialEq\"),\n+                                hir::BiLt | hir::BiLe | hir::BiGt | hir::BiGe =>\n+                                    Some(\"std::cmp::PartialOrd\"),\n+                                _             => None\n+                            };\n                             if let Some(missing_trait) = missing_trait {\n-                                if missing_trait == \"std::ops::Add\" &&\n+                                if op.node == hir::BiAdd &&\n                                     self.check_str_addition(expr, lhs_expr, rhs_expr, lhs_ty,\n                                                             rhs_ty, &mut err) {\n                                     // This has nothing here because it means we did string\n@@ -375,13 +366,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     err.note(\n                                         &format!(\"`{}` might need a bound for `{}`\",\n                                                     lhs_ty, missing_trait));\n-                                } else {\n-                                    if !suggested_deref{\n-                                        err.note(\n-                                            &format!(\"an implementation of `{}` might \\\n-                                                        be missing for `{}`\",\n-                                                        missing_trait, lhs_ty));\n-                                    }\n+                                } else if !suggested_deref {\n+                                    err.note(\n+                                        &format!(\"an implementation of `{}` might \\\n+                                                    be missing for `{}`\",\n+                                                    missing_trait, lhs_ty));\n                                 }\n                             }\n                             err.emit();\n@@ -468,20 +457,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                      op.as_str(), actual);\n                     err.span_label(ex.span, format!(\"cannot apply unary \\\n                                                     operator `{}`\", op.as_str()));\n-                    let missing_trait = match op {\n-                        hir::UnNeg => \"std::ops::Neg\",\n-                        hir::UnNot => \"std::ops::Not\",\n-                        hir::UnDeref => \"std::ops::UnDerf\"\n-                    };\n-                    match actual.sty{\n-                        TyUint(_) => {\n-                            if op == hir::UnNeg{\n-                                err.note(&format!(\"unsigned values cannot be negated\"));\n-                            }\n+                    match actual.sty {\n+                        TyUint(_) if op == hir::UnNeg => {\n+                            err.note(&format!(\"unsigned values cannot be negated\"));\n                         },\n                         TyStr | TyNever | TyChar | TyTuple(_) | TyArray(_,_) => {},\n                         TyRef(_, ref lty) if lty.ty.sty == TyStr => {},\n                         _ => {\n+                            let missing_trait = match op {\n+                                hir::UnNeg => \"std::ops::Neg\",\n+                                hir::UnNot => \"std::ops::Not\",\n+                                hir::UnDeref => \"std::ops::UnDerf\"\n+                            };\n                             err.note(&format!(\"an implementation of `{}` might \\\n                                                 be missing for `{}`\",\n                                              missing_trait, operand_ty));"}, {"sha": "b3e79ce2447fb564838d82ea413716b8c7ec8e03", "filename": "src/test/ui/type-check/missing_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.rs?ref=747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "patch": "@@ -14,3 +14,7 @@ fn main() {\n fn foo<T>(x: T, y: T) {\n     let z = x + y; //~ ERROR binary operation `+` cannot be applied to type `T`\n }\n+\n+fn bar<T>(x: T) {\n+    x += x; //~ ERROR binary assignment operation `+=` cannot be applied to type `T`\n+}"}, {"sha": "4b01a626814e555a5427e4a316b65d970ef12c8a", "filename": "src/test/ui/type-check/missing_trait_impl.stderr", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/747d5d99cdbe49d590b3e0b8856953f1a545fdd7/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fmissing_trait_impl.stderr?ref=747d5d99cdbe49d590b3e0b8856953f1a545fdd7", "patch": "@@ -6,6 +6,17 @@ LL |     let z = x + y; //~ ERROR binary operation `+` cannot be applied to type\n    |\n    = note: `T` might need a bound for `std::ops::Add`\n \n-error: aborting due to previous error\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `T`\n+  --> $DIR/missing_trait_impl.rs:19:5\n+   |\n+LL |     x += x; //~ ERROR binary assignment operation `+=` cannot be applied to type `T`\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `T`\n+   |\n+   = note: `T` might need a bound for `std::ops::AddAssign`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0369`.\n+Some errors occurred: E0368, E0369.\n+For more information about an error, try `rustc --explain E0368`."}]}