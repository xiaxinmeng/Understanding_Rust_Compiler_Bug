{"sha": "fa07e6238985a329d82ee09de7587f7f90c7a4d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMDdlNjIzODk4NWEzMjlkODJlZTA5ZGU3NTg3ZjdmOTBjN2E0ZDI=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-18T18:59:00Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:54:18Z"}, "message": "Fixed handling of unit variants of aliased enums in type NS.", "tree": {"sha": "6bcdcf4ad0153547fd7b99fcb3b853fad8dabd8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bcdcf4ad0153547fd7b99fcb3b853fad8dabd8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa07e6238985a329d82ee09de7587f7f90c7a4d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa07e6238985a329d82ee09de7587f7f90c7a4d2", "html_url": "https://github.com/rust-lang/rust/commit/fa07e6238985a329d82ee09de7587f7f90c7a4d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa07e6238985a329d82ee09de7587f7f90c7a4d2/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb1a9e4e7337dd17827e00f0e1d2e10f11de30c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb1a9e4e7337dd17827e00f0e1d2e10f11de30c", "html_url": "https://github.com/rust-lang/rust/commit/8eb1a9e4e7337dd17827e00f0e1d2e10f11de30c"}], "stats": {"total": 509, "additions": 215, "deletions": 294}, "files": [{"sha": "98013dd00dc7043f688f96c7ade156e692c9deb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 147, "deletions": 5, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=fa07e6238985a329d82ee09de7587f7f90c7a4d2", "patch": "@@ -32,6 +32,10 @@ use std::iter;\n use std::slice;\n \n use super::{check_type_alias_enum_variants_enabled};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+#[derive(Debug)]\n+pub struct PathSeg(pub DefId, pub usize);\n \n pub trait AstConv<'gcx, 'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n@@ -1470,6 +1474,134 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         err.span_label(span, \"associated type not allowed here\").emit();\n     }\n \n+    pub fn def_ids_for_path_segments(&self,\n+                                     segments: &[hir::PathSegment],\n+                                     self_ty: Option<Ty<'tcx>>,\n+                                     def: Def)\n+                                     -> Vec<PathSeg> {\n+        // We need to extract the type parameters supplied by the user in\n+        // the path `path`. Due to the current setup, this is a bit of a\n+        // tricky-process; the problem is that resolve only tells us the\n+        // end-point of the path resolution, and not the intermediate steps.\n+        // Luckily, we can (at least for now) deduce the intermediate steps\n+        // just from the end-point.\n+        //\n+        // There are basically five cases to consider:\n+        //\n+        // 1. Reference to a constructor of a struct:\n+        //\n+        //        struct Foo<T>(...)\n+        //\n+        //    In this case, the parameters are declared in the type space.\n+        //\n+        // 2. Reference to a constructor of an enum variant:\n+        //\n+        //        enum E<T> { Foo(...) }\n+        //\n+        //    In this case, the parameters are defined in the type space,\n+        //    but may be specified either on the type or the variant.\n+        //\n+        // 3. Reference to a fn item or a free constant:\n+        //\n+        //        fn foo<T>() { }\n+        //\n+        //    In this case, the path will again always have the form\n+        //    `a::b::foo::<T>` where only the final segment should have\n+        //    type parameters. However, in this case, those parameters are\n+        //    declared on a value, and hence are in the `FnSpace`.\n+        //\n+        // 4. Reference to a method or an associated constant:\n+        //\n+        //        impl<A> SomeStruct<A> {\n+        //            fn foo<B>(...)\n+        //        }\n+        //\n+        //    Here we can have a path like\n+        //    `a::b::SomeStruct::<A>::foo::<B>`, in which case parameters\n+        //    may appear in two places. The penultimate segment,\n+        //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n+        //    final segment, `foo::<B>` contains parameters in fn space.\n+        //\n+        // 5. Reference to a local variable\n+        //\n+        //    Local variables can't have any type parameters.\n+        //\n+        // The first step then is to categorize the segments appropriately.\n+\n+        let tcx = self.tcx();\n+\n+        assert!(!segments.is_empty());\n+        let last = segments.len() - 1;\n+\n+        let mut path_segs = vec![];\n+\n+        match def {\n+            // Case 1. Reference to a struct constructor.\n+            Def::StructCtor(def_id, ..) |\n+            Def::SelfCtor(.., def_id) => {\n+                // Everything but the final segment should have no\n+                // parameters at all.\n+                let generics = tcx.generics_of(def_id);\n+                // Variant and struct constructors use the\n+                // generics of their parent type definition.\n+                let generics_def_id = generics.parent.unwrap_or(def_id);\n+                path_segs.push(PathSeg(generics_def_id, last));\n+            }\n+\n+            // Case 2. Reference to a variant constructor.\n+            Def::Variant(def_id) |\n+            Def::VariantCtor(def_id, ..) => {\n+                let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n+                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n+                    debug_assert!(adt_def.is_enum());\n+                    (adt_def.did, last)\n+                } else if last >= 1 && segments[last - 1].args.is_some() {\n+                    // Everything but the penultimate segment should have no\n+                    // parameters at all.\n+                    let enum_def_id = tcx.parent_def_id(def_id).unwrap();\n+                    (enum_def_id, last - 1)\n+                } else {\n+                    // FIXME: lint here recommending `Enum::<...>::Variant` form\n+                    // instead of `Enum::Variant::<...>` form.\n+\n+                    // Everything but the final segment should have no\n+                    // parameters at all.\n+                    let generics = tcx.generics_of(def_id);\n+                    // Variant and struct constructors use the\n+                    // generics of their parent type definition.\n+                    (generics.parent.unwrap_or(def_id), last)\n+                };\n+                path_segs.push(PathSeg(generics_def_id, index));\n+            }\n+\n+            // Case 3. Reference to a top-level value.\n+            Def::Fn(def_id) |\n+            Def::Const(def_id) |\n+            Def::Static(def_id, _) => {\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 4. Reference to a method or associated const.\n+            Def::Method(def_id) |\n+            Def::AssociatedConst(def_id) => {\n+                if segments.len() >= 2 {\n+                    let generics = tcx.generics_of(def_id);\n+                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n+                }\n+                path_segs.push(PathSeg(def_id, last));\n+            }\n+\n+            // Case 5. Local variable, no generics.\n+            Def::Local(..) | Def::Upvar(..) => {}\n+\n+            _ => bug!(\"unexpected definition: {:?}\", def),\n+        }\n+\n+        debug!(\"path_segs = {:?}\", path_segs);\n+\n+        path_segs\n+    }\n+\n     // Check a type `Path` and convert it to a `Ty`.\n     pub fn def_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n@@ -1500,14 +1632,24 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n-            Def::Variant(did) if permit_variants => {\n+            Def::Variant(_) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(span,\n-                                    tcx.parent_def_id(did).unwrap(),\n-                                    path.segments.last().unwrap())\n+\n+                let path_segs = self.def_ids_for_path_segments(&path.segments, None, path.def);\n+                let generic_segs: FxHashSet<_> =\n+                    path_segs.iter().map(|PathSeg(_, index)| index).collect();\n+                self.prohibit_generics(path.segments.iter().enumerate().filter_map(|(index, seg)| {\n+                    if !generic_segs.contains(&index) {\n+                        Some(seg)\n+                    } else {\n+                        None\n+                    }\n+                }));\n+\n+                let PathSeg(def_id, index) = path_segs.last().unwrap();\n+                self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);"}, {"sha": "76fbe862211cf9e387d4a86093a5e6ba9f0e70a1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 130, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fa07e6238985a329d82ee09de7587f7f90c7a4d2", "patch": "@@ -83,7 +83,7 @@ mod generator_interior;\n mod intrinsic;\n mod op;\n \n-use astconv::AstConv;\n+use astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n use rustc::hir::def::{CtorKind, Def};\n@@ -507,9 +507,6 @@ impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-struct PathSeg(DefId, usize);\n-\n pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n@@ -5060,131 +5057,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Applicability::MachineApplicable);\n     }\n \n-    fn def_ids_for_path_segments(&self,\n-                                 segments: &[hir::PathSegment],\n-                                 self_ty: Option<Ty<'tcx>>,\n-                                 def: Def)\n-                                 -> Vec<PathSeg> {\n-        // We need to extract the type parameters supplied by the user in\n-        // the path `path`. Due to the current setup, this is a bit of a\n-        // tricky-process; the problem is that resolve only tells us the\n-        // end-point of the path resolution, and not the intermediate steps.\n-        // Luckily, we can (at least for now) deduce the intermediate steps\n-        // just from the end-point.\n-        //\n-        // There are basically five cases to consider:\n-        //\n-        // 1. Reference to a constructor of a struct:\n-        //\n-        //        struct Foo<T>(...)\n-        //\n-        //    In this case, the parameters are declared in the type space.\n-        //\n-        // 2. Reference to a constructor of an enum variant:\n-        //\n-        //        enum E<T> { Foo(...) }\n-        //\n-        //    In this case, the parameters are defined in the type space,\n-        //    but may be specified either on the type or the variant.\n-        //\n-        // 3. Reference to a fn item or a free constant:\n-        //\n-        //        fn foo<T>() { }\n-        //\n-        //    In this case, the path will again always have the form\n-        //    `a::b::foo::<T>` where only the final segment should have\n-        //    type parameters. However, in this case, those parameters are\n-        //    declared on a value, and hence are in the `FnSpace`.\n-        //\n-        // 4. Reference to a method or an associated constant:\n-        //\n-        //        impl<A> SomeStruct<A> {\n-        //            fn foo<B>(...)\n-        //        }\n-        //\n-        //    Here we can have a path like\n-        //    `a::b::SomeStruct::<A>::foo::<B>`, in which case parameters\n-        //    may appear in two places. The penultimate segment,\n-        //    `SomeStruct::<A>`, contains parameters in TypeSpace, and the\n-        //    final segment, `foo::<B>` contains parameters in fn space.\n-        //\n-        // 5. Reference to a local variable\n-        //\n-        //    Local variables can't have any type parameters.\n-        //\n-        // The first step then is to categorize the segments appropriately.\n-\n-        assert!(!segments.is_empty());\n-        let last = segments.len() - 1;\n-\n-        let mut path_segs = vec![];\n-\n-        match def {\n-            // Case 1. Reference to a struct constructor.\n-            Def::StructCtor(def_id, ..) |\n-            Def::SelfCtor(.., def_id) => {\n-                // Everything but the final segment should have no\n-                // parameters at all.\n-                let generics = self.tcx.generics_of(def_id);\n-                // Variant and struct constructors use the\n-                // generics of their parent type definition.\n-                let generics_def_id = generics.parent.unwrap_or(def_id);\n-                path_segs.push(PathSeg(generics_def_id, last));\n-            }\n-\n-            // Case 2. Reference to a variant constructor.\n-            Def::VariantCtor(def_id, ..) => {\n-                let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n-                let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n-                    debug_assert!(adt_def.is_enum());\n-                    (adt_def.did, last)\n-                } else if last >= 1 && segments[last - 1].args.is_some() {\n-                    // Everything but the penultimate segment should have no\n-                    // parameters at all.\n-                    let enum_def_id = self.tcx.parent_def_id(def_id).unwrap();\n-                    (enum_def_id, last - 1)\n-                } else {\n-                    // FIXME: lint here suggesting `Enum::<...>::Variant` form\n-                    // instead of `Enum::Variant::<...>` form.\n-\n-                    // Everything but the final segment should have no\n-                    // parameters at all.\n-                    let generics = self.tcx.generics_of(def_id);\n-                    // Variant and struct constructors use the\n-                    // generics of their parent type definition.\n-                    (generics.parent.unwrap_or(def_id), last)\n-                };\n-                path_segs.push(PathSeg(generics_def_id, index));\n-            }\n-\n-            // Case 3. Reference to a top-level value.\n-            Def::Fn(def_id) |\n-            Def::Const(def_id) |\n-            Def::Static(def_id, _) => {\n-                path_segs.push(PathSeg(def_id, last));\n-            }\n-\n-            // Case 4. Reference to a method or associated const.\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n-                if segments.len() >= 2 {\n-                    let generics = self.tcx.generics_of(def_id);\n-                    path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n-                }\n-                path_segs.push(PathSeg(def_id, last));\n-            }\n-\n-            // Case 5. Local variable, no generics.\n-            Def::Local(..) | Def::Upvar(..) => {}\n-\n-            _ => bug!(\"unexpected definition: {:?}\", def),\n-        }\n-\n-        debug!(\"path_segs = {:?}\", path_segs);\n-\n-        path_segs\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -5204,7 +5076,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let path_segs = self.def_ids_for_path_segments(segments, self_ty, def);\n+        let path_segs = AstConv::def_ids_for_path_segments(self, segments, self_ty, def);\n \n         let mut user_self_ty = None;\n         match def {"}, {"sha": "ace4ebdfa0595bf482a01d3bb0b820ab66f960d0", "filename": "src/test/run-pass/enum-variant-generic-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-variant-generic-args.rs?ref=fa07e6238985a329d82ee09de7587f7f90c7a4d2", "patch": "@@ -8,9 +8,9 @@ type Alias<T> = Enum<T>;\n type AliasFixed = Enum<()>;\n \n macro_rules! is_variant {\n-    (TSVariant, $expr:expr) => (is_variant!(@TSVariant, (_), $expr));\n-    (SVariant, $expr:expr) => (is_variant!(@SVariant, { v: _ }, $expr));\n-    (@$variant:ident, $matcher:tt, $expr:expr) => (\n+    (TSVariant, $expr:expr) => (is_variant!(@check TSVariant, (_), $expr));\n+    (SVariant, $expr:expr) => (is_variant!(@check SVariant, { v: _ }, $expr));\n+    (@check $variant:ident, $matcher:tt, $expr:expr) => (\n         assert!(if let Enum::$variant::<()> $matcher = $expr { true } else { false },\n                 \"expr does not have correct type\");\n     );"}, {"sha": "044d8438815ba8d325210d94bfb312f7eb067619", "filename": "src/test/ui/enum-variant-generic-args.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-variant-generic-args.rs?ref=fa07e6238985a329d82ee09de7587f7f90c7a4d2", "patch": "@@ -16,13 +16,16 @@ impl<T> Enum<T> {\n     }\n \n     fn s_variant() {\n-        Self::SVariant::<()>(());\n+        Self::SVariant::<()> { v: () };\n         //~^ ERROR type arguments are not allowed on this entity [E0109]\n-        Self::<()>::SVariant(());\n+        //~^^ ERROR mismatched types [E0308]\n+        Self::<()>::SVariant { v: () };\n         //~^ ERROR type arguments are not allowed on this entity [E0109]\n-        Self::<()>::SVariant::<()>(());\n+        //~^^ ERROR mismatched types [E0308]\n+        Self::<()>::SVariant::<()> { v: () };\n         //~^ ERROR type arguments are not allowed on this entity [E0109]\n         //~^^ ERROR type arguments are not allowed on this entity [E0109]\n+        //~^^^ ERROR mismatched types [E0308]\n     }\n }\n \n@@ -47,19 +50,19 @@ fn main() {\n \n     // Struct variant\n \n-    Enum::<()>::SVariant::<()>(());\n+    Enum::<()>::SVariant::<()> { v: () };\n     //~^ ERROR type arguments are not allowed on this entity [E0109]\n \n-    Alias::SVariant::<()>(());\n+    Alias::SVariant::<()> { v: () };\n     //~^ ERROR type arguments are not allowed on this entity [E0109]\n-    Alias::<()>::SVariant::<()>(());\n+    Alias::<()>::SVariant::<()> { v: () };\n     //~^ ERROR type arguments are not allowed on this entity [E0109]\n \n-    AliasFixed::SVariant::<()>(());\n+    AliasFixed::SVariant::<()> { v: () };\n     //~^ ERROR type arguments are not allowed on this entity [E0109]\n-    AliasFixed::<()>::SVariant(());\n+    AliasFixed::<()>::SVariant { v: () };\n     //~^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n-    AliasFixed::<()>::SVariant::<()>(());\n+    AliasFixed::<()>::SVariant::<()> { v: () };\n     //~^ ERROR type arguments are not allowed on this entity [E0109]\n     //~^^ ERROR wrong number of type arguments: expected 0, found 1 [E0107]\n }"}, {"sha": "4228a807bad1600bdaf2617b6d90913cd217957a", "filename": "src/test/ui/enum-variant-generic-args.stderr", "status": "modified", "additions": 51, "deletions": 147, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa07e6238985a329d82ee09de7587f7f90c7a4d2/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum-variant-generic-args.stderr?ref=fa07e6238985a329d82ee09de7587f7f90c7a4d2", "patch": "@@ -1,12 +1,3 @@\n-error[E0423]: expected function, found struct variant `Enum::SVariant`\n-  --> $DIR/enum-variant-generic-args.rs:50:5\n-   |\n-LL |     Enum::<()>::SVariant::<()>(());\n-   |     ^^^^^^^^^^^^--------^^^^^^\n-   |     |           |\n-   |     |           did you mean `TSVariant`?\n-   |     did you mean `Enum::SVariant { /* fields */ }`?\n-\n error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/enum-variant-generic-args.rs:9:27\n    |\n@@ -34,226 +25,139 @@ LL |         Self::<()>::TSVariant::<()>(());\n error[E0109]: type arguments are not allowed on this entity\n   --> $DIR/enum-variant-generic-args.rs:19:26\n    |\n-LL |         Self::SVariant::<()>(());\n+LL |         Self::SVariant::<()> { v: () };\n    |                          ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<Self>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:19:9\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:19:35\n    |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<Self>::SVariant::<()>` defined here\n-...\n-LL |         Self::SVariant::<()>(());\n-   |         ^^^^^^^^^^^^^^^^^^^^----\n-   |         |\n-   |         call expression requires function\n-help: `<Self>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n+LL |         Self::SVariant::<()> { v: () };\n+   |                                   ^^ expected type parameter, found ()\n    |\n-LL |         <Self>::SVariant::<()>;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `T`\n+              found type `()`\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:21:16\n+  --> $DIR/enum-variant-generic-args.rs:22:16\n    |\n-LL |         Self::<()>::SVariant(());\n+LL |         Self::<()>::SVariant { v: () };\n    |                ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<Self<()>>::SVariant`\n-  --> $DIR/enum-variant-generic-args.rs:21:9\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:22:35\n    |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<Self<()>>::SVariant` defined here\n-...\n-LL |         Self::<()>::SVariant(());\n-   |         ^^^^^^^^^^^^^^^^^^^^----\n-   |         |\n-   |         call expression requires function\n-help: `<Self<()>>::SVariant` is a unit variant, you need to write it without the parenthesis\n+LL |         Self::<()>::SVariant { v: () };\n+   |                                   ^^ expected type parameter, found ()\n    |\n-LL |         <Self<()>>::SVariant;\n-   |         ^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `T`\n+              found type `()`\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:23:16\n+  --> $DIR/enum-variant-generic-args.rs:25:16\n    |\n-LL |         Self::<()>::SVariant::<()>(());\n+LL |         Self::<()>::SVariant::<()> { v: () };\n    |                ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:23:32\n+  --> $DIR/enum-variant-generic-args.rs:25:32\n    |\n-LL |         Self::<()>::SVariant::<()>(());\n+LL |         Self::<()>::SVariant::<()> { v: () };\n    |                                ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<Self<()>>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:23:9\n+error[E0308]: mismatched types\n+  --> $DIR/enum-variant-generic-args.rs:25:41\n    |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<Self<()>>::SVariant::<()>` defined here\n-...\n-LL |         Self::<()>::SVariant::<()>(());\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^----\n-   |         |\n-   |         call expression requires function\n-help: `<Self<()>>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n+LL |         Self::<()>::SVariant::<()> { v: () };\n+   |                                         ^^ expected type parameter, found ()\n    |\n-LL |         <Self<()>>::SVariant::<()>;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: expected type `T`\n+              found type `()`\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:32:29\n+  --> $DIR/enum-variant-generic-args.rs:35:29\n    |\n LL |     Enum::<()>::TSVariant::<()>(());\n    |                             ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:35:24\n+  --> $DIR/enum-variant-generic-args.rs:38:24\n    |\n LL |     Alias::TSVariant::<()>(());\n    |                        ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:37:30\n+  --> $DIR/enum-variant-generic-args.rs:40:30\n    |\n LL |     Alias::<()>::TSVariant::<()>(());\n    |                              ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:40:29\n+  --> $DIR/enum-variant-generic-args.rs:43:29\n    |\n LL |     AliasFixed::TSVariant::<()>(());\n    |                             ^^ type argument not allowed\n \n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/enum-variant-generic-args.rs:42:18\n+  --> $DIR/enum-variant-generic-args.rs:45:18\n    |\n LL |     AliasFixed::<()>::TSVariant(());\n    |                  ^^ unexpected type argument\n \n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/enum-variant-generic-args.rs:44:18\n+  --> $DIR/enum-variant-generic-args.rs:47:18\n    |\n LL |     AliasFixed::<()>::TSVariant::<()>(());\n    |                  ^^ unexpected type argument\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:44:35\n+  --> $DIR/enum-variant-generic-args.rs:47:35\n    |\n LL |     AliasFixed::<()>::TSVariant::<()>(());\n    |                                   ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:53:23\n+  --> $DIR/enum-variant-generic-args.rs:53:28\n    |\n-LL |     Alias::SVariant::<()>(());\n-   |                       ^^ type argument not allowed\n+LL |     Enum::<()>::SVariant::<()> { v: () };\n+   |                            ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<Alias>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:53:5\n-   |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<Alias>::SVariant::<()>` defined here\n-...\n-LL |     Alias::SVariant::<()>(());\n-   |     ^^^^^^^^^^^^^^^^^^^^^----\n-   |     |\n-   |     call expression requires function\n-help: `<Alias>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n+error[E0109]: type arguments are not allowed on this entity\n+  --> $DIR/enum-variant-generic-args.rs:56:23\n    |\n-LL |     <Alias>::SVariant::<()>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     Alias::SVariant::<()> { v: () };\n+   |                       ^^ type argument not allowed\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:55:29\n+  --> $DIR/enum-variant-generic-args.rs:58:29\n    |\n-LL |     Alias::<()>::SVariant::<()>(());\n+LL |     Alias::<()>::SVariant::<()> { v: () };\n    |                             ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<Alias<()>>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:55:5\n-   |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<Alias<()>>::SVariant::<()>` defined here\n-...\n-LL |     Alias::<()>::SVariant::<()>(());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^----\n-   |     |\n-   |     call expression requires function\n-help: `<Alias<()>>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n-   |\n-LL |     <Alias<()>>::SVariant::<()>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:58:28\n+  --> $DIR/enum-variant-generic-args.rs:61:28\n    |\n-LL |     AliasFixed::SVariant::<()>(());\n+LL |     AliasFixed::SVariant::<()> { v: () };\n    |                            ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<AliasFixed>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:58:5\n-   |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<AliasFixed>::SVariant::<()>` defined here\n-...\n-LL |     AliasFixed::SVariant::<()>(());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^----\n-   |     |\n-   |     call expression requires function\n-help: `<AliasFixed>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n-   |\n-LL |     <AliasFixed>::SVariant::<()>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/enum-variant-generic-args.rs:60:18\n+  --> $DIR/enum-variant-generic-args.rs:63:18\n    |\n-LL |     AliasFixed::<()>::SVariant(());\n+LL |     AliasFixed::<()>::SVariant { v: () };\n    |                  ^^ unexpected type argument\n \n-error[E0618]: expected function, found enum variant `<AliasFixed<()>>::SVariant`\n-  --> $DIR/enum-variant-generic-args.rs:60:5\n-   |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<AliasFixed<()>>::SVariant` defined here\n-...\n-LL |     AliasFixed::<()>::SVariant(());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^----\n-   |     |\n-   |     call expression requires function\n-help: `<AliasFixed<()>>::SVariant` is a unit variant, you need to write it without the parenthesis\n-   |\n-LL |     <AliasFixed<()>>::SVariant;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0107]: wrong number of type arguments: expected 0, found 1\n-  --> $DIR/enum-variant-generic-args.rs:62:18\n+  --> $DIR/enum-variant-generic-args.rs:65:18\n    |\n-LL |     AliasFixed::<()>::SVariant::<()>(());\n+LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n    |                  ^^ unexpected type argument\n \n error[E0109]: type arguments are not allowed on this entity\n-  --> $DIR/enum-variant-generic-args.rs:62:34\n+  --> $DIR/enum-variant-generic-args.rs:65:34\n    |\n-LL |     AliasFixed::<()>::SVariant::<()>(());\n+LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n    |                                  ^^ type argument not allowed\n \n-error[E0618]: expected function, found enum variant `<AliasFixed<()>>::SVariant::<()>`\n-  --> $DIR/enum-variant-generic-args.rs:62:5\n-   |\n-LL | enum Enum<T> { TSVariant(T), SVariant { v: T } }\n-   |                              ----------------- `<AliasFixed<()>>::SVariant::<()>` defined here\n-...\n-LL |     AliasFixed::<()>::SVariant::<()>(());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^----\n-   |     |\n-   |     call expression requires function\n-help: `<AliasFixed<()>>::SVariant::<()>` is a unit variant, you need to write it without the parenthesis\n-   |\n-LL |     <AliasFixed<()>>::SVariant::<()>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 30 previous errors\n+error: aborting due to 25 previous errors\n \n-Some errors occurred: E0107, E0109, E0423, E0618.\n+Some errors occurred: E0107, E0109, E0308.\n For more information about an error, try `rustc --explain E0107`."}]}