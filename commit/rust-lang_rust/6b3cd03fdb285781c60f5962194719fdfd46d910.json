{"sha": "6b3cd03fdb285781c60f5962194719fdfd46d910", "node_id": "C_kwDOAAsO6NoAKDZiM2NkMDNmZGIyODU3ODFjNjBmNTk2MjE5NDcxOWZkZmQ0NmQ5MTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-23T07:32:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-23T07:32:07Z"}, "message": "Auto merge of #107215 - Dylan-DPC:rollup-zqtiufk, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #104926 (Move relationships from FulfillmentContext to Inherited)\n - #106854 (Add `Arc::into_inner` for safely discarding `Arc`s without calling the destructor on the inner type.)\n - #107108 (Consider doc(alias) when providing typo suggestions)\n - #107186 (rustdoc: Use correct pseudo-element selector)\n - #107192 (Add myself to the mailmap)\n - #107195 (Fix typo in universal_regions.rs comment)\n - #107203 (Suggest remove deref for type mismatch)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "84eaf25c217169e58808d559f1c66f8c9abe6a1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84eaf25c217169e58808d559f1c66f8c9abe6a1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b3cd03fdb285781c60f5962194719fdfd46d910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b3cd03fdb285781c60f5962194719fdfd46d910", "html_url": "https://github.com/rust-lang/rust/commit/6b3cd03fdb285781c60f5962194719fdfd46d910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b3cd03fdb285781c60f5962194719fdfd46d910/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad48c109815a2e9441a7ad7796e55b8771fe01a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad48c109815a2e9441a7ad7796e55b8771fe01a5", "html_url": "https://github.com/rust-lang/rust/commit/ad48c109815a2e9441a7ad7796e55b8771fe01a5"}, {"sha": "66d6a0b5da24b41185d060e3e7f9155a22f78872", "url": "https://api.github.com/repos/rust-lang/rust/commits/66d6a0b5da24b41185d060e3e7f9155a22f78872", "html_url": "https://github.com/rust-lang/rust/commit/66d6a0b5da24b41185d060e3e7f9155a22f78872"}], "stats": {"total": 601, "additions": 465, "deletions": 136}, "files": [{"sha": "8ed692989ccbf73baf3dbe06012380237c5b3a56", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -325,6 +325,7 @@ Lennart Kudling <github@kudling.de>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com>\n L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com> <38361244+LeSeulArtichaut@users.noreply.github.com>\n L\u00e9o Testard <leo.testard@gmail.com>\n+Le\u00f3n Orell Valerian Liehr <me@fmease.dev> <liehr.exchange@gmx.net>\n Leonardo Yvens <leoyvens@gmail.com>\n Liigo Zhuang <liigo@qq.com>\n Lily Ballard <lily@ballards.net> <kevin@sb.org>"}, {"sha": "8bff66f8d5cca02c3c6b15e525e98347cad0d1e7", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -162,7 +162,7 @@ struct UniversalRegionIndices<'tcx> {\n     /// `ty::Region` to the internal `RegionVid` we are using. This is\n     /// used because trait matching and type-checking will feed us\n     /// region constraints that reference those regions and we need to\n-    /// be able to map them our internal `RegionVid`. This is\n+    /// be able to map them to our internal `RegionVid`. This is\n     /// basically equivalent to an `InternalSubsts`, except that it also\n     /// contains an entry for `ReStatic` -- it might be nice to just\n     /// use a substs, and then handle `ReStatic` another way."}, {"sha": "bd1626dff79515908687a64fd667223ab24ca127", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1233,6 +1233,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             sugg_sp = receiver.span;\n                         }\n                     }\n+\n+                    if let hir::ExprKind::Unary(hir::UnOp::Deref, ref inner) = expr.kind\n+                        && let Some(1) = self.deref_steps(expected, checked_ty) {\n+                        // We have `*&T`, check if what was expected was `&T`.\n+                        // If so, we may want to suggest removing a `*`.\n+                        sugg_sp = sugg_sp.with_hi(inner.span.lo());\n+                        return Some((\n+                            sugg_sp,\n+                            \"consider removing deref here\".to_string(),\n+                            \"\".to_string(),\n+                            Applicability::MachineApplicable,\n+                            true,\n+                            false,\n+                        ));\n+                    }\n+\n                     if let Ok(src) = sm.span_to_snippet(sugg_sp) {\n                         let needs_parens = match expr.kind {\n                             // parenthesize if needed (Issue #46756)"}, {"sha": "943dc9b9646fc63131cd4f4394b0b530f7bbd978", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -196,8 +196,6 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     ) -> FxHashMap<Ty<'tcx>, Ty<'tcx>> {\n         debug!(\"calculate_diverging_fallback({:?})\", unsolved_variables);\n \n-        let relationships = self.fulfillment_cx.borrow_mut().relationships().clone();\n-\n         // Construct a coercion graph where an edge `A -> B` indicates\n         // a type variable is that is coerced\n         let coercion_graph = self.create_coercion_graph();\n@@ -281,9 +279,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             roots_reachable_from_non_diverging,\n         );\n \n-        debug!(\"inherited: {:#?}\", self.inh.fulfillment_cx.borrow_mut().pending_obligations());\n         debug!(\"obligations: {:#?}\", self.fulfillment_cx.borrow_mut().pending_obligations());\n-        debug!(\"relationships: {:#?}\", relationships);\n \n         // For each diverging variable, figure out whether it can\n         // reach a member of N. If so, it falls back to `()`. Else\n@@ -297,16 +293,16 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n                 .depth_first_search(root_vid)\n                 .any(|n| roots_reachable_from_non_diverging.visited(n));\n \n-            let mut relationship = ty::FoundRelationships { self_in_trait: false, output: false };\n+            let mut found_infer_var_info = ty::InferVarInfo { self_in_trait: false, output: false };\n \n-            for (vid, rel) in relationships.iter() {\n-                if self.root_var(*vid) == root_vid {\n-                    relationship.self_in_trait |= rel.self_in_trait;\n-                    relationship.output |= rel.output;\n+            for (vid, info) in self.inh.infer_var_info.borrow().iter() {\n+                if self.infcx.root_var(*vid) == root_vid {\n+                    found_infer_var_info.self_in_trait |= info.self_in_trait;\n+                    found_infer_var_info.output |= info.output;\n                 }\n             }\n \n-            if relationship.self_in_trait && relationship.output {\n+            if found_infer_var_info.self_in_trait && found_infer_var_info.output {\n                 // This case falls back to () to ensure that the code pattern in\n                 // tests/ui/never_type/fallback-closure-ret.rs continues to\n                 // compile when never_type_fallback is enabled."}, {"sha": "ba34f299453ecff0473190c130ccf5643542d351", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,6 +1,6 @@\n use super::callee::DeferredCallResolution;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n@@ -10,7 +10,8 @@ use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{self, TraitEngine, TraitEngineExt as _};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, PredicateObligation, TraitEngine, TraitEngineExt as _};\n \n use std::cell::RefCell;\n use std::ops::Deref;\n@@ -63,6 +64,8 @@ pub struct Inherited<'tcx> {\n     /// we record that type variable here. This is later used to inform\n     /// fallback. See the `fallback` module for details.\n     pub(super) diverging_type_vars: RefCell<FxHashSet<Ty<'tcx>>>,\n+\n+    pub(super) infer_var_info: RefCell<FxHashMap<ty::TyVid, ty::InferVarInfo>>,\n }\n \n impl<'tcx> Deref for Inherited<'tcx> {\n@@ -128,6 +131,7 @@ impl<'tcx> Inherited<'tcx> {\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n             diverging_type_vars: RefCell::new(Default::default()),\n             body_id,\n+            infer_var_info: RefCell::new(Default::default()),\n         }\n     }\n \n@@ -136,6 +140,9 @@ impl<'tcx> Inherited<'tcx> {\n         if obligation.has_escaping_bound_vars() {\n             span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\", obligation);\n         }\n+\n+        self.update_infer_var_info(&obligation);\n+\n         self.fulfillment_cx.borrow_mut().register_predicate_obligation(self, obligation);\n     }\n \n@@ -152,4 +159,43 @@ impl<'tcx> Inherited<'tcx> {\n         self.register_predicates(infer_ok.obligations);\n         infer_ok.value\n     }\n+\n+    pub fn update_infer_var_info(&self, obligation: &PredicateObligation<'tcx>) {\n+        let infer_var_info = &mut self.infer_var_info.borrow_mut();\n+\n+        // (*) binder skipped\n+        if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n+            && let Some(ty) = self.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| self.root_var(t))\n+            && self.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+        {\n+            let new_self_ty = self.tcx.types.unit;\n+\n+            // Then construct a new obligation with Self = () added\n+            // to the ParamEnv, and see if it holds.\n+            let o = obligation.with(self.tcx,\n+                obligation\n+                    .predicate\n+                    .kind()\n+                    .rebind(\n+                        // (*) binder moved here\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(tpred.with_self_ty(self.tcx, new_self_ty)))\n+                    ),\n+            );\n+            // Don't report overflow errors. Otherwise equivalent to may_hold.\n+            if let Ok(result) = self.probe(|_| self.evaluate_obligation(&o)) && result.may_apply() {\n+                infer_var_info.entry(ty).or_default().self_in_trait = true;\n+            }\n+        }\n+\n+        if let ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) =\n+            obligation.predicate.kind().skip_binder()\n+        {\n+            // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n+            // we need to make it into one.\n+            if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n+                debug!(\"infer_var_info: {:?}.output = true\", vid);\n+                infer_var_info.entry(vid).or_default().output = true;\n+            }\n+        }\n+    }\n }"}, {"sha": "47396204b14e7c50314d32a35ef9ecbd8bc7bb01", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -76,7 +76,7 @@ pub struct NoMatchData<'tcx> {\n     pub unsatisfied_predicates:\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n     pub out_of_scope_traits: Vec<DefId>,\n-    pub lev_candidate: Option<ty::AssocItem>,\n+    pub similar_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n }\n "}, {"sha": "9c06a22315bcba12189377e2770e9884588d5e5f", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     static_candidates: Vec::new(),\n                     unsatisfied_predicates: Vec::new(),\n                     out_of_scope_traits: Vec::new(),\n-                    lev_candidate: None,\n+                    similar_candidate: None,\n                     mode,\n                 }));\n             }\n@@ -1076,13 +1076,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         if let Some((kind, def_id)) = private_candidate {\n             return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n-        let lev_candidate = self.probe_for_lev_candidate()?;\n+        let similar_candidate = self.probe_for_similar_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n-            lev_candidate,\n+            similar_candidate,\n             mode: self.mode,\n         }))\n     }\n@@ -1787,7 +1787,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n     /// Levenshtein based suggestions, we provide at most one such suggestion.\n-    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n+    fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n         let steps = self.steps.clone();\n@@ -1831,6 +1831,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         None,\n                     )\n                 }\n+                .or_else(|| {\n+                    applicable_close_candidates\n+                        .iter()\n+                        .find(|cand| self.matches_by_doc_alias(cand.def_id))\n+                        .map(|cand| cand.name)\n+                })\n                 .unwrap();\n                 Ok(applicable_close_candidates.into_iter().find(|method| method.name == best_name))\n             }\n@@ -1981,6 +1987,38 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    /// Determine if the associated item withe the given DefId matches\n+    /// the desired name via a doc alias.\n+    fn matches_by_doc_alias(&self, def_id: DefId) -> bool {\n+        let Some(name) = self.method_name else { return false; };\n+        let Some(local_def_id) = def_id.as_local() else { return false; };\n+        let hir_id = self.fcx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let attrs = self.fcx.tcx.hir().attrs(hir_id);\n+        for attr in attrs {\n+            let sym::doc = attr.name_or_empty() else { continue; };\n+            let Some(values) = attr.meta_item_list() else { continue; };\n+            for v in values {\n+                if v.name_or_empty() != sym::alias {\n+                    continue;\n+                }\n+                if let Some(nested) = v.meta_item_list() {\n+                    // #[doc(alias(\"foo\", \"bar\"))]\n+                    for n in nested {\n+                        if let Some(lit) = n.lit() && name.as_str() == lit.symbol.as_str() {\n+                            return true;\n+                        }\n+                    }\n+                } else if let Some(meta) = v.meta_item()\n+                    && let Some(lit) = meta.name_value_literal()\n+                    && name.as_str() == lit.symbol.as_str() {\n+                        // #[doc(alias = \"foo\")]\n+                        return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Finds the method with the appropriate name (or return type, as the case may be). If\n     /// `allow_similar_names` is set, find methods with close-matching names.\n     // The length of the returned iterator is nearly always 0 or 1 and this\n@@ -1996,6 +2034,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.is_relevant_kind_for_mode(x.kind) {\n                             return false;\n                         }\n+                        if self.matches_by_doc_alias(x.def_id) {\n+                            return true;\n+                        }\n                         match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n                         {\n                             Some(d) => d > 0,"}, {"sha": "8c54e9bdb5fb3a3ae7670f01c5d8e3b66c346b98", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n-        let lev_candidate = no_match_data.lev_candidate;\n+        let similar_candidate = no_match_data.similar_candidate;\n         let item_kind = if is_method {\n             \"method\"\n         } else if rcvr_ty.is_enum() {\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // give a helping note that it has to be called as `(x.f)(...)`.\n         if let SelfSource::MethodCall(expr) = source {\n             if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                && lev_candidate.is_none()\n+                && similar_candidate.is_none()\n                 && !custom_span_label\n             {\n                 label_span_not_found(&mut err);\n@@ -1015,20 +1015,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if fallback_span {\n                 err.span_label(span, msg);\n             }\n-        } else if let Some(lev_candidate) = lev_candidate {\n+        } else if let Some(similar_candidate) = similar_candidate {\n             // Don't emit a suggestion if we found an actual method\n             // that had unsatisfied trait bounds\n             if unsatisfied_predicates.is_empty() {\n-                let def_kind = lev_candidate.kind.as_def_kind();\n+                let def_kind = similar_candidate.kind.as_def_kind();\n                 // Methods are defined within the context of a struct and their first parameter is always self,\n                 // which represents the instance of the struct the method is being called on\n                 // Associated functions don\u2019t take self as a parameter and\n                 // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                if def_kind == DefKind::AssocFn && similar_candidate.fn_has_self_parameter {\n                     err.span_suggestion(\n                         span,\n                         \"there is a method with a similar name\",\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n@@ -1037,9 +1037,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\n                             \"there is {} {} with a similar name\",\n                             def_kind.article(),\n-                            def_kind.descr(lev_candidate.def_id),\n+                            def_kind.descr(similar_candidate.def_id),\n                         ),\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "fcde00056cbf1c4cf4738e80e851497506a05dcf", "filename": "compiler/rustc_infer/src/traits/engine.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fengine.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, ToPredicate, Ty};\n \n@@ -42,8 +41,6 @@ pub trait TraitEngine<'tcx>: 'tcx {\n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>>;\n \n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>>;\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships>;\n }\n \n pub trait TraitEngineExt<'tcx> {"}, {"sha": "f83bceca3b53ba27bdcab4885698a9ea0193c60d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -2619,7 +2619,7 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n }\n \n #[derive(Debug, Default, Copy, Clone)]\n-pub struct FoundRelationships {\n+pub struct InferVarInfo {\n     /// This is true if we identified that this Ty (`?T`) is found in a `?T: Foo`\n     /// obligation, where:\n     ///"}, {"sha": "40b9bedc84fd3afd8292c2c721bee97d1d8b62de", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,14 +1,12 @@\n use std::mem;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_infer::{\n     infer::InferCtxt,\n     traits::{\n         query::NoSolution, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n         SelectionError, TraitEngine,\n     },\n };\n-use rustc_middle::ty;\n \n use super::{search_graph, Certainty, EvalCtxt};\n \n@@ -102,8 +100,4 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.clone()\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        unimplemented!(\"Should be moved out of `TraitEngine`\")\n-    }\n }"}, {"sha": "61d09189798ea2d82eda6eff65546dde89c3adb2", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -7,24 +7,18 @@ use crate::traits::{\n     ChalkEnvironmentAndGoal, FulfillmentError, FulfillmentErrorCode, PredicateObligation,\n     SelectionError, TraitEngine,\n };\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_middle::ty::{self, TypeVisitable};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_middle::ty::TypeVisitable;\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n \n-    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n-\n     usable_in_snapshot: bool,\n }\n \n impl FulfillmentContext<'_> {\n     pub(super) fn new() -> Self {\n-        FulfillmentContext {\n-            obligations: FxIndexSet::default(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: false,\n-        }\n+        FulfillmentContext { obligations: FxIndexSet::default(), usable_in_snapshot: false }\n     }\n \n     pub(crate) fn new_in_snapshot() -> Self {\n@@ -43,8 +37,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         }\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n-        super::relationships::update(self, infcx, &obligation);\n-\n         self.obligations.insert(obligation);\n     }\n \n@@ -154,8 +146,4 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.obligations.iter().cloned().collect()\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        &mut self.relationships\n-    }\n }"}, {"sha": "5a58d37e18362694dc1b5ec00ec16c22c20a15c7", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,5 +1,4 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n@@ -54,8 +53,6 @@ pub struct FulfillmentContext<'tcx> {\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n-    relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n-\n     // Is it OK to register obligations into this infcx inside\n     // an infcx snapshot?\n     //\n@@ -85,19 +82,11 @@ static_assert_size!(PendingPredicateObligation<'_>, 72);\n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub(super) fn new() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: false,\n-        }\n+        FulfillmentContext { predicates: ObligationForest::new(), usable_in_snapshot: false }\n     }\n \n     pub(super) fn new_in_snapshot() -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            relationships: FxHashMap::default(),\n-            usable_in_snapshot: true,\n-        }\n+        FulfillmentContext { predicates: ObligationForest::new(), usable_in_snapshot: true }\n     }\n \n     /// Attempts to select obligations using `selcx`.\n@@ -139,8 +128,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n \n         assert!(!infcx.is_in_snapshot() || self.usable_in_snapshot);\n \n-        super::relationships::update(self, infcx, &obligation);\n-\n         self.predicates\n             .register_obligation(PendingPredicateObligation { obligation, stalled_on: vec![] });\n     }\n@@ -164,10 +151,6 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n         self.predicates.map_pending_obligations(|o| o.obligation.clone())\n     }\n-\n-    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n-        &mut self.relationships\n-    }\n }\n \n struct FulfillProcessor<'a, 'tcx> {"}, {"sha": "3c640cdc503ceba9010ffe62f5119be36868ff2f", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -14,7 +14,6 @@ mod object_safety;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n-pub(crate) mod relationships;\n mod select;\n mod specialize;\n mod structural_match;"}, {"sha": "34b5fc4891eb36643e65c2412e8ac70330559e55", "filename": "compiler/rustc_trait_selection/src/traits/relationships.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad48c109815a2e9441a7ad7796e55b8771fe01a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad48c109815a2e9441a7ad7796e55b8771fe01a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Frelationships.rs?ref=ad48c109815a2e9441a7ad7796e55b8771fe01a5", "patch": "@@ -1,48 +0,0 @@\n-use crate::infer::InferCtxt;\n-use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::PredicateObligation;\n-use rustc_infer::traits::TraitEngine;\n-use rustc_middle::ty;\n-\n-pub(crate) fn update<'tcx, T>(\n-    engine: &mut T,\n-    infcx: &InferCtxt<'tcx>,\n-    obligation: &PredicateObligation<'tcx>,\n-) where\n-    T: TraitEngine<'tcx>,\n-{\n-    // (*) binder skipped\n-    if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n-        && let Some(ty) = infcx.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| infcx.root_var(t))\n-        && infcx.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n-    {\n-        let new_self_ty = infcx.tcx.types.unit;\n-\n-        // Then construct a new obligation with Self = () added\n-        // to the ParamEnv, and see if it holds.\n-        let o = obligation.with(infcx.tcx,\n-            obligation\n-                .predicate\n-                .kind()\n-                .rebind(\n-                    // (*) binder moved here\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(tpred.with_self_ty(infcx.tcx, new_self_ty)))\n-                ),\n-        );\n-        // Don't report overflow errors. Otherwise equivalent to may_hold.\n-        if let Ok(result) = infcx.probe(|_| infcx.evaluate_obligation(&o)) && result.may_apply() {\n-            engine.relationships().entry(ty).or_default().self_in_trait = true;\n-        }\n-    }\n-\n-    if let ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) =\n-        obligation.predicate.kind().skip_binder()\n-    {\n-        // If the projection predicate (Foo::Bar == X) has X as a non-TyVid,\n-        // we need to make it into one.\n-        if let Some(vid) = predicate.term.ty().and_then(|ty| ty.ty_vid()) {\n-            debug!(\"relationship: {:?}.output = true\", vid);\n-            engine.relationships().entry(vid).or_default().output = true;\n-        }\n-    }\n-}"}, {"sha": "9bc9182f7b53c3b170d0634ed959164f5b4204ea", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -654,6 +654,20 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n+    /*\n+    /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n+    /// want to keep the `Arc` in the [`Err`] case.\n+    /// Immediately dropping the [`Err`] payload, like in the expression\n+    /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n+    /// drop to zero and the inner value of the `Arc` to be dropped:\n+    /// For instance if two threads execute this expression in parallel, then\n+    /// there is a race condition. The threads could first both check whether they\n+    /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n+    /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n+    /// taking the strong count from two down to zero.\n+    ///\n+     */\n     /// # Examples\n     ///\n     /// ```\n@@ -685,6 +699,137 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, [`None`] is returned and the `Arc` is dropped.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// If `Arc::into_inner` is called on every clone of this `Arc`,\n+    /// it is guaranteed that exactly one of the calls returns the inner value.\n+    /// This means in particular that the inner value is not dropped.\n+    ///\n+    /// The similar expression `Arc::try_unwrap(this).ok()` does not\n+    /// offer such a guarantee. See the last example below.\n+    //\n+    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n+    // of the previous sentence:\n+    /*\n+    /// and the documentation of [`Arc::try_unwrap`].\n+     */\n+    ///\n+    /// # Examples\n+    ///\n+    /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// let y = Arc::clone(&x);\n+    ///\n+    /// // Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n+    /// let x_thread = std::thread::spawn(|| Arc::into_inner(x));\n+    /// let y_thread = std::thread::spawn(|| Arc::into_inner(y));\n+    ///\n+    /// let x_inner_value = x_thread.join().unwrap();\n+    /// let y_inner_value = y_thread.join().unwrap();\n+    ///\n+    /// // One of the threads is guaranteed to receive the inner value:\n+    /// assert!(matches!(\n+    ///     (x_inner_value, y_inner_value),\n+    ///     (None, Some(3)) | (Some(3), None)\n+    /// ));\n+    /// // The result could also be `(None, None)` if the threads called\n+    /// // `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n+    /// ```\n+    ///\n+    /// A more practical example demonstrating the need for `Arc::into_inner`:\n+    /// ```\n+    /// #![feature(arc_into_inner)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// // Definition of a simple singly linked list using `Arc`:\n+    /// #[derive(Clone)]\n+    /// struct LinkedList<T>(Option<Arc<Node<T>>>);\n+    /// struct Node<T>(T, Option<Arc<Node<T>>>);\n+    ///\n+    /// // Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n+    /// // can cause a stack overflow. To prevent this, we can provide a\n+    /// // manual `Drop` implementation that does the destruction in a loop:\n+    /// impl<T> Drop for LinkedList<T> {\n+    ///     fn drop(&mut self) {\n+    ///         let mut link = self.0.take();\n+    ///         while let Some(arc_node) = link.take() {\n+    ///             if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n+    ///                 link = next;\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // Implementation of `new` and `push` omitted\n+    /// impl<T> LinkedList<T> {\n+    ///     /* ... */\n+    /// #   fn new() -> Self {\n+    /// #       LinkedList(None)\n+    /// #   }\n+    /// #   fn push(&mut self, x: T) {\n+    /// #       self.0 = Some(Arc::new(Node(x, self.0.take())));\n+    /// #   }\n+    /// }\n+    ///\n+    /// // The following code could have still caused a stack overflow\n+    /// // despite the manual `Drop` impl if that `Drop` impl had used\n+    /// // `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n+    ///\n+    /// // Create a long list and clone it\n+    /// let mut x = LinkedList::new();\n+    /// for i in 0..100000 {\n+    ///     x.push(i); // Adds i to the front of x\n+    /// }\n+    /// let y = x.clone();\n+    ///\n+    /// // Drop the clones in parallel\n+    /// let x_thread = std::thread::spawn(|| drop(x));\n+    /// let y_thread = std::thread::spawn(|| drop(y));\n+    /// x_thread.join().unwrap();\n+    /// y_thread.join().unwrap();\n+    /// ```\n+\n+    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n+    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n+    // open an issue on rust-lang/rust-clippy, asking for a lint against\n+    // `Arc::try_unwrap(...).ok()`.\n+    #[inline]\n+    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    pub fn into_inner(this: Self) -> Option<T> {\n+        // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n+        let mut this = mem::ManuallyDrop::new(this);\n+\n+        // Following the implementation of `drop` and `drop_slow`\n+        if this.inner().strong.fetch_sub(1, Release) != 1 {\n+            return None;\n+        }\n+\n+        acquire!(this.inner().strong);\n+\n+        // SAFETY: This mirrors the line\n+        //\n+        //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };\n+        //\n+        // in `drop_slow`. Instead of dropping the value behind the pointer,\n+        // it is read and eventually returned; `ptr::read` has the same\n+        // safety conditions as `ptr::drop_in_place`.\n+        let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };\n+\n+        drop(Weak { ptr: this.ptr });\n+\n+        Some(inner)\n+    }\n }\n \n impl<T> Arc<[T]> {"}, {"sha": "863d58bdf4d9cdad35f341f1aeb519a67f9bb63f", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -101,6 +101,38 @@ fn try_unwrap() {\n     assert_eq!(Arc::try_unwrap(x), Ok(5));\n }\n \n+#[test]\n+fn into_inner() {\n+    for _ in 0..100\n+    // ^ Increase chances of hitting potential race conditions\n+    {\n+        let x = Arc::new(3);\n+        let y = Arc::clone(&x);\n+        let r_thread = std::thread::spawn(|| Arc::into_inner(x));\n+        let s_thread = std::thread::spawn(|| Arc::into_inner(y));\n+        let r = r_thread.join().expect(\"r_thread panicked\");\n+        let s = s_thread.join().expect(\"s_thread panicked\");\n+        assert!(\n+            matches!((r, s), (None, Some(3)) | (Some(3), None)),\n+            \"assertion failed: unexpected result `{:?}`\\\n+            \\n  expected `(None, Some(3))` or `(Some(3), None)`\",\n+            (r, s),\n+        );\n+    }\n+\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::into_inner(x), Some(3));\n+\n+    let x = Arc::new(4);\n+    let y = Arc::clone(&x);\n+    assert_eq!(Arc::into_inner(x), None);\n+    assert_eq!(Arc::into_inner(y), Some(4));\n+\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::into_inner(x), Some(5));\n+}\n+\n #[test]\n fn into_from_raw() {\n     let x = Arc::new(Box::new(\"hello\"));"}, {"sha": "424bbb0ec42be8a1e42765ebc29638de8bc6a399", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1897,21 +1897,21 @@ in storage.js\n \tright: 0.25em;\n }\n \n-.scraped-example:not(.expanded) .code-wrapper:before,\n-.scraped-example:not(.expanded) .code-wrapper:after {\n+.scraped-example:not(.expanded) .code-wrapper::before,\n+.scraped-example:not(.expanded) .code-wrapper::after {\n \tcontent: \" \";\n \twidth: 100%;\n \theight: 5px;\n \tposition: absolute;\n \tz-index: 1;\n }\n-.scraped-example:not(.expanded) .code-wrapper:before {\n+.scraped-example:not(.expanded) .code-wrapper::before {\n \ttop: 0;\n \tbackground: linear-gradient(to bottom,\n \t\tvar(--scrape-example-code-wrapper-background-start),\n \t\tvar(--scrape-example-code-wrapper-background-end));\n }\n-.scraped-example:not(.expanded) .code-wrapper:after {\n+.scraped-example:not(.expanded) .code-wrapper::after {\n \tbottom: 0;\n \tbackground: linear-gradient(to top,\n \t\tvar(--scrape-example-code-wrapper-background-start),"}, {"sha": "3dea8bf7ac81db5f7dbc7c63c4a221f000f2e4bf", "filename": "tests/ui/generic-associated-types/issue-88360.fixed", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.fixed?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,20 @@\n+// run-rustfix\n+\n+trait GatTrait {\n+    type Gat<'a> where Self: 'a;\n+\n+    fn test(&self) -> Self::Gat<'_>;\n+}\n+\n+trait SuperTrait<T>\n+where\n+    Self: 'static,\n+    for<'a> Self: GatTrait<Gat<'a> = &'a T>,\n+{\n+    fn copy(&self) -> Self::Gat<'_> where T: Copy {\n+        self.test()\n+        //~^ mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4d4c7ea318078ff3412312e010bfa0872e0488ca", "filename": "tests/ui/generic-associated-types/issue-88360.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n trait GatTrait {\n     type Gat<'a> where Self: 'a;\n "}, {"sha": "520aeff1894835c966b31a3fb1ad01c7ac399442", "filename": "tests/ui/generic-associated-types/issue-88360.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88360.stderr?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,19 +1,21 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-88360.rs:13:9\n+  --> $DIR/issue-88360.rs:15:9\n    |\n LL | trait SuperTrait<T>\n    |                  - this type parameter\n ...\n LL |     fn copy(&self) -> Self::Gat<'_> where T: Copy {\n    |                       ------------- expected `&T` because of return type\n LL |         *self.test()\n-   |         ^^^^^^^^^^^^\n-   |         |\n-   |         expected `&T`, found type parameter `T`\n-   |         help: consider borrowing here: `&*self.test()`\n+   |         ^^^^^^^^^^^^ expected `&T`, found type parameter `T`\n    |\n    = note:   expected reference `&T`\n            found type parameter `T`\n+help: consider removing deref here\n+   |\n+LL -         *self.test()\n+LL +         self.test()\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "9c6d10029239b8035c92ab6a48d5136f15fe4866", "filename": "tests/ui/methods/method-not-found-but-doc-alias.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,11 @@\n+struct Foo;\n+\n+impl Foo {\n+    #[doc(alias = \"quux\")]\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    Foo.quux();\n+    //~^ ERROR  no method named `quux` found for struct `Foo` in the current scope\n+}"}, {"sha": "5102a452f0c28c7267fe2d72cb241ddd211673fc", "filename": "tests/ui/methods/method-not-found-but-doc-alias.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `quux` found for struct `Foo` in the current scope\n+  --> $DIR/method-not-found-but-doc-alias.rs:9:9\n+   |\n+LL | struct Foo;\n+   | ---------- method `quux` not found for this struct\n+...\n+LL |     Foo.quux();\n+   |         ^^^^ help: there is a method with a similar name: `bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "4dc12da03dd023535d701946b98f57e84036b838", "filename": "tests/ui/suggestions/suggest-remove-deref.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.fixed?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+//issue #106496\n+\n+struct S;\n+\n+trait X {}\n+impl X for S {}\n+\n+fn foo<T: X>(_: &T) {}\n+fn test_foo() {\n+    let hello = &S;\n+    foo(hello);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar(_: &String) {}\n+fn test_bar() {\n+    let v = String::from(\"hello\");\n+    let s = &v;\n+    bar(s);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "c2d385cbdc378ac56bb09ce20b54d83936579cda", "filename": "tests/ui/suggestions/suggest-remove-deref.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+//issue #106496\n+\n+struct S;\n+\n+trait X {}\n+impl X for S {}\n+\n+fn foo<T: X>(_: &T) {}\n+fn test_foo() {\n+    let hello = &S;\n+    foo(*hello);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar(_: &String) {}\n+fn test_bar() {\n+    let v = String::from(\"hello\");\n+    let s = &v;\n+    bar(*s);\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "f5d810e36f035935913a11faea3c8669b493b166", "filename": "tests/ui/suggestions/suggest-remove-deref.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-remove-deref.stderr?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -0,0 +1,43 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-remove-deref.rs:13:9\n+   |\n+LL |     foo(*hello);\n+   |     --- ^^^^^^ expected reference, found struct `S`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected reference `&_`\n+                 found struct `S`\n+note: function defined here\n+  --> $DIR/suggest-remove-deref.rs:10:4\n+   |\n+LL | fn foo<T: X>(_: &T) {}\n+   |    ^^^       -----\n+help: consider removing deref here\n+   |\n+LL -     foo(*hello);\n+LL +     foo(hello);\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-remove-deref.rs:21:9\n+   |\n+LL |     bar(*s);\n+   |     --- ^^ expected `&String`, found struct `String`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+note: function defined here\n+  --> $DIR/suggest-remove-deref.rs:17:4\n+   |\n+LL | fn bar(_: &String) {}\n+   |    ^^^ ----------\n+help: consider removing deref here\n+   |\n+LL -     bar(*s);\n+LL +     bar(s);\n+   |\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "bd65737ee39895df9e33d39ee3717ba52dbbd06d", "filename": "tests/ui/traits/new-solver/fn-trait-closure.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b3cd03fdb285781c60f5962194719fdfd46d910/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Ffn-trait-closure.rs?ref=6b3cd03fdb285781c60f5962194719fdfd46d910", "patch": "@@ -1,12 +1,5 @@\n // compile-flags: -Ztrait-solver=next\n-// known-bug: unknown\n-// failure-status: 101\n-// dont-check-compiler-stderr\n-\n-// This test will fail until we fix `FulfillmentCtxt::relationships`. That's\n-// because we create a type variable for closure upvar types, which is not\n-// constrained until after we try to do fallback on diverging type variables.\n-// Thus, we will call that function, which is unimplemented.\n+// check-pass\n \n fn require_fn(_: impl Fn() -> i32) {}\n "}]}