{"sha": "2accd295c603799c4d42ced7683fd653b21a666d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhY2NkMjk1YzYwMzc5OWM0ZDQyY2VkNzY4M2ZkNjUzYjIxYTY2NmQ=", "commit": {"author": {"name": "Ivan Jager", "email": "aij+git@mrph.org", "date": "2015-08-04T22:09:44Z"}, "committer": {"name": "Ivan Jager", "email": "aij+git@mrph.org", "date": "2015-08-04T23:40:13Z"}, "message": "Fix some grammar in The Advanced Rust Programming Language", "tree": {"sha": "445e9e3be4fddedbace702a5331f9825a90bc164", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/445e9e3be4fddedbace702a5331f9825a90bc164"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2accd295c603799c4d42ced7683fd653b21a666d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2accd295c603799c4d42ced7683fd653b21a666d", "html_url": "https://github.com/rust-lang/rust/commit/2accd295c603799c4d42ced7683fd653b21a666d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2accd295c603799c4d42ced7683fd653b21a666d/comments", "author": {"login": "aij", "id": 4732885, "node_id": "MDQ6VXNlcjQ3MzI4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/4732885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aij", "html_url": "https://github.com/aij", "followers_url": "https://api.github.com/users/aij/followers", "following_url": "https://api.github.com/users/aij/following{/other_user}", "gists_url": "https://api.github.com/users/aij/gists{/gist_id}", "starred_url": "https://api.github.com/users/aij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aij/subscriptions", "organizations_url": "https://api.github.com/users/aij/orgs", "repos_url": "https://api.github.com/users/aij/repos", "events_url": "https://api.github.com/users/aij/events{/privacy}", "received_events_url": "https://api.github.com/users/aij/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aij", "id": 4732885, "node_id": "MDQ6VXNlcjQ3MzI4ODU=", "avatar_url": "https://avatars.githubusercontent.com/u/4732885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aij", "html_url": "https://github.com/aij", "followers_url": "https://api.github.com/users/aij/followers", "following_url": "https://api.github.com/users/aij/following{/other_user}", "gists_url": "https://api.github.com/users/aij/gists{/gist_id}", "starred_url": "https://api.github.com/users/aij/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aij/subscriptions", "organizations_url": "https://api.github.com/users/aij/orgs", "repos_url": "https://api.github.com/users/aij/repos", "events_url": "https://api.github.com/users/aij/events{/privacy}", "received_events_url": "https://api.github.com/users/aij/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb11d65d08c3e28cfe3387eaa946d56bdc016900", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb11d65d08c3e28cfe3387eaa946d56bdc016900", "html_url": "https://github.com/rust-lang/rust/commit/eb11d65d08c3e28cfe3387eaa946d56bdc016900"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "d781e59d7c9e044b0eaf72f1f8b871e7824740cb", "filename": "src/doc/nomicon/atomics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fatomics.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fatomics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fatomics.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -127,7 +127,7 @@ fundamentally unsynchronized and compilers are free to aggressively optimize\n them. In particular, data accesses are free to be reordered by the compiler on\n the assumption that the program is single-threaded. The hardware is also free to\n propagate the changes made in data accesses to other threads as lazily and\n-inconsistently as it wants. Mostly critically, data accesses are how data races\n+inconsistently as it wants. Most critically, data accesses are how data races\n happen. Data accesses are very friendly to the hardware and compiler, but as\n we've seen they offer *awful* semantics to try to write synchronized code with.\n Actually, that's too weak."}, {"sha": "802f3204cd4527f377153349ac025913a16f3292", "filename": "src/doc/nomicon/concurrency.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fconcurrency.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -7,7 +7,7 @@ an abstraction over them in a relatively uncontroversial way. Message passing,\n green threads, and async APIs are all diverse enough that any abstraction over\n them tends to involve trade-offs that we weren't willing to commit to for 1.0.\n \n-However the way Rust models concurrency makes it relatively easy design your own\n+However the way Rust models concurrency makes it relatively easy to design your own\n concurrency paradigm as a library and have everyone else's code Just Work\n with yours. Just require the right lifetimes and Send and Sync where appropriate\n and you're off to the races. Or rather, off to the... not... having... races."}, {"sha": "29a866063e99674e7fd33738ff15001f30b992d3", "filename": "src/doc/nomicon/destructors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdestructors.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -120,7 +120,7 @@ enum Link {\n will have its inner Box field dropped if and only if an instance stores the\n Next variant.\n \n-In general this works really nice because you don't need to worry about\n+In general this works really nicely because you don't need to worry about\n adding/removing drops when you refactor your data layout. Still there's\n certainly many valid usecases for needing to do trickier things with\n destructors."}, {"sha": "5655c5d245ce0638658550e82814e7a6d2389d4b", "filename": "src/doc/nomicon/drop-flags.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdrop-flags.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdrop-flags.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -1,7 +1,7 @@\n % Drop Flags\n \n The examples in the previous section introduce an interesting problem for Rust.\n-We have seen that's possible to conditionally initialize, deinitialize, and\n+We have seen that it's possible to conditionally initialize, deinitialize, and\n reinitialize locations of memory totally safely. For Copy types, this isn't\n particularly notable since they're just a random pile of bits. However types\n with destructors are a different story: Rust needs to know whether to call a"}, {"sha": "98d269ff76282a389848b76b9f1e5006753bedc9", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -1,7 +1,7 @@\n % Drop Check\n \n We have seen how lifetimes provide us some fairly simple rules for ensuring\n-that never read dangling references. However up to this point we have only ever\n+that we never read dangling references. However up to this point we have only ever\n interacted with the *outlives* relationship in an inclusive manner. That is,\n when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n `'b`. At first glance, this seems to be a meaningless distinction. Nothing ever"}, {"sha": "8724b97546ea118d5b14993e18144e088a4f429d", "filename": "src/doc/nomicon/send-and-sync.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -3,15 +3,15 @@\n Not everything obeys inherited mutability, though. Some types allow you to\n multiply alias a location in memory while mutating it. Unless these types use\n synchronization to manage this access, they are absolutely not thread safe. Rust\n-captures this with through the `Send` and `Sync` traits.\n+captures this through the `Send` and `Sync` traits.\n \n * A type is Send if it is safe to send it to another thread.\n * A type is Sync if it is safe to share between threads (`&T` is Send).\n \n Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n foremost, they're [unsafe traits][]. This means that they are unsafe to\n-implement, and other unsafe code can  that they are correctly\n+implement, and other unsafe code can assume that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can"}, {"sha": "5ae1818dc630690de2a99a811c7c950f3c03460c", "filename": "src/doc/nomicon/unchecked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/2accd295c603799c4d42ced7683fd653b21a666d/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md?ref=2accd295c603799c4d42ced7683fd653b21a666d", "patch": "@@ -77,7 +77,7 @@ contain any `Drop` types.\n However when working with uninitialized memory you need to be ever-vigilant for\n Rust trying to drop values you make like this before they're fully initialized.\n Every control path through that variable's scope must initialize the value\n-before it ends, if has a destructor.\n+before it ends, if it has a destructor.\n *[This includes code panicking](unwinding.html)*.\n \n And that's about it for working with uninitialized memory! Basically nothing"}]}