{"sha": "113e815b3603283ed9dedde9c7f9729e6d263c34", "node_id": "C_kwDOAAsO6NoAKDExM2U4MTViMzYwMzI4M2VkOWRlZGRlOWM3Zjk3MjllNmQyNjNjMzQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-16T07:57:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-16T07:57:08Z"}, "message": "Rollup merge of #109171 - oli-obk:normalization_cleanup, r=compiler-errors\n\nSome cleanups in our normalization logic\n\nChanged a match to be exhaustive and deduplicated some code.\n\nr? ```@compiler-errors```\n\nthis pulls out the uncontroversial part of https://github.com/rust-lang/rust/pull/108860", "tree": {"sha": "cdaba375724277fd881b6a89215481378d7f7797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdaba375724277fd881b6a89215481378d7f7797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/113e815b3603283ed9dedde9c7f9729e6d263c34", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkEsvUCRBK7hj4Ov3rIwAA4aMIAE458WpF+VMW0/wpdOdxDEiQ\nBSSeYdiB7Af8irPet2S+BKOj4MHvbJ/GEMx5kSI02rSWEQtbE/dk2qiLOI2IXaAY\nhcYfs8zNL6WPZMKqTHNccAn6ddSfzOw8ahe8a0HBF0JaDkAI6II43kX+Rr8fLzez\nfra6sw2OLTcDoNR7TazBXoowbVVOF0WC9Jm/6DrZC6X+hdiACbysrhtYWp4wzOXY\n+kFHdN1+XuvfyVcoWxOjeuhxicy/qqfgADVV+pdxWx6MShNfljNt8tS2AbKywhxX\nwBBPEPgHOcnm32txwvguCkmQQjNyq148NGpYiDzLj+bM0bQ/RX9CRMxZbvIKxJ8=\n=x++d\n-----END PGP SIGNATURE-----\n", "payload": "tree cdaba375724277fd881b6a89215481378d7f7797\nparent f0205d55ced197fbbee099ef682d5d9503bbb30d\nparent d87fbb918c5a9d3dc7f8d1d801fd17a622484a85\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1678953428 +0100\ncommitter GitHub <noreply@github.com> 1678953428 +0100\n\nRollup merge of #109171 - oli-obk:normalization_cleanup, r=compiler-errors\n\nSome cleanups in our normalization logic\n\nChanged a match to be exhaustive and deduplicated some code.\n\nr? ```@compiler-errors```\n\nthis pulls out the uncontroversial part of https://github.com/rust-lang/rust/pull/108860\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/113e815b3603283ed9dedde9c7f9729e6d263c34", "html_url": "https://github.com/rust-lang/rust/commit/113e815b3603283ed9dedde9c7f9729e6d263c34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/113e815b3603283ed9dedde9c7f9729e6d263c34/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0205d55ced197fbbee099ef682d5d9503bbb30d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0205d55ced197fbbee099ef682d5d9503bbb30d", "html_url": "https://github.com/rust-lang/rust/commit/f0205d55ced197fbbee099ef682d5d9503bbb30d"}, {"sha": "d87fbb918c5a9d3dc7f8d1d801fd17a622484a85", "url": "https://api.github.com/repos/rust-lang/rust/commits/d87fbb918c5a9d3dc7f8d1d801fd17a622484a85", "html_url": "https://github.com/rust-lang/rust/commit/d87fbb918c5a9d3dc7f8d1d801fd17a622484a85"}], "stats": {"total": 125, "additions": 48, "deletions": 77}, "files": [{"sha": "0f0cccea13075a4ac5bcb67064b961dd1fb99aa6", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/113e815b3603283ed9dedde9c7f9729e6d263c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113e815b3603283ed9dedde9c7f9729e6d263c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=113e815b3603283ed9dedde9c7f9729e6d263c34", "patch": "@@ -468,6 +468,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n             return ty;\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, alias_ty) => (kind, alias_ty),\n+            _ => return ty.super_fold_with(self),\n+        };\n+\n         // We try to be a little clever here as a performance optimization in\n         // cases where there are nested projections under binders.\n         // For example:\n@@ -491,13 +496,11 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n         // replace bound vars if the current type is a `Projection` and we need\n         // to make sure we don't forget to fold the substs regardless.\n \n-        match *ty.kind() {\n+        match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.super_fold_with(self),\n@@ -513,8 +516,8 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                             );\n                         }\n \n-                        let substs = substs.fold_with(self);\n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let substs = data.substs.fold_with(self);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.depth += 1;\n                         let folded_ty = self.fold_ty(concrete_ty);\n@@ -523,8 +526,9 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                     }\n                 }\n             }\n+            ty::Opaque => ty.super_fold_with(self),\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n+            ty::Projection if !data.has_escaping_bound_vars() => {\n                 // This branch is *mostly* just an optimization: when we don't\n                 // have escaping bound vars, we don't need to replace them with\n                 // placeholders (see branch below). *Also*, we know that we can\n@@ -563,7 +567,7 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 normalized_ty.ty().unwrap()\n             }\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // If there are escaping bound vars, we temporarily replace the\n                 // bound vars with placeholders. Note though, that in the case\n                 // that we still can't project for whatever reason (e.g. self\n@@ -612,8 +616,6 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n-\n-            _ => ty.super_fold_with(self),\n         }\n     }\n "}, {"sha": "a986a9b6a71b13597cd72125de3684527845408b", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/113e815b3603283ed9dedde9c7f9729e6d263c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/113e815b3603283ed9dedde9c7f9729e6d263c34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=113e815b3603283ed9dedde9c7f9729e6d263c34", "patch": "@@ -197,23 +197,30 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n             return Ok(*ty);\n         }\n \n+        let (kind, data) = match *ty.kind() {\n+            ty::Alias(kind, data) => (kind, data),\n+            _ => {\n+                let res = ty.try_super_fold_with(self)?;\n+                self.cache.insert(ty, res);\n+                return Ok(res);\n+            }\n+        };\n+\n         // See note in `rustc_trait_selection::traits::project` about why we\n         // wait to fold the substs.\n \n         // Wrap this in a closure so we don't accidentally return from the outer function\n-        let res = match *ty.kind() {\n+        let res = match kind {\n             // This is really important. While we *can* handle this, this has\n             // severe performance implications for large opaque types with\n             // late-bound regions. See `issue-88862` benchmark.\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. })\n-                if !substs.has_escaping_bound_vars() =>\n-            {\n+            ty::Opaque if !data.substs.has_escaping_bound_vars() => {\n                 // Only normalize `impl Trait` outside of type inference, usually in codegen.\n                 match self.param_env.reveal() {\n                     Reveal::UserFacing => ty.try_super_fold_with(self)?,\n \n                     Reveal::All => {\n-                        let substs = substs.try_fold_with(self)?;\n+                        let substs = data.substs.try_fold_with(self)?;\n                         let recursion_limit = self.interner().recursion_limit();\n                         if !recursion_limit.value_within_limit(self.anon_depth) {\n                             // A closure or generator may have itself as in its upvars.\n@@ -228,7 +235,7 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                             return ty.try_super_fold_with(self);\n                         }\n \n-                        let generic_ty = self.interner().type_of(def_id);\n+                        let generic_ty = self.interner().type_of(data.def_id);\n                         let concrete_ty = generic_ty.subst(self.interner(), substs);\n                         self.anon_depth += 1;\n                         if concrete_ty == ty {\n@@ -248,62 +255,22 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 }\n             }\n \n-            ty::Alias(ty::Projection, data) if !data.has_escaping_bound_vars() => {\n-                // This branch is just an optimization: when we don't have escaping bound vars,\n-                // we don't need to replace them with placeholders (see branch below).\n-\n-                let tcx = self.infcx.tcx;\n-                let data = data.try_fold_with(self)?;\n-\n-                let mut orig_values = OriginalQueryValues::default();\n-                // HACK(matthewjasper) `'static` is special-cased in selection,\n-                // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n-                    .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n-                debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n-                debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n-                // We don't expect ambiguity.\n-                if result.is_ambiguous() {\n-                    // Rustdoc normalizes possibly not well-formed types, so only\n-                    // treat this as a bug if we're not in rustdoc.\n-                    if !tcx.sess.opts.actually_rustdoc {\n-                        tcx.sess.delay_span_bug(\n-                            DUMMY_SP,\n-                            format!(\"unexpected ambiguity: {:?} {:?}\", c_data, result),\n-                        );\n-                    }\n-                    return Err(NoSolution);\n-                }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n-                        self.cause,\n-                        self.param_env,\n-                        &orig_values,\n-                        result,\n-                    )?;\n-                debug!(\"QueryNormalizer: result = {:#?}\", result);\n-                debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n-                self.obligations.extend(obligations);\n-\n-                let res = result.normalized_ty;\n-                // `tcx.normalize_projection_ty` may normalize to a type that still has\n-                // unevaluated consts, so keep normalizing here if that's the case.\n-                if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n-                    res.try_super_fold_with(self)?\n-                } else {\n-                    res\n-                }\n-            }\n+            ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Alias(ty::Projection, data) => {\n+            ty::Projection => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n                 let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n-                let (data, mapped_regions, mapped_types, mapped_consts) =\n-                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                // Just an optimization: When we don't have escaping bound vars,\n+                // we don't need to replace them with placeholders.\n+                let (data, maps) = if data.has_escaping_bound_vars() {\n+                    let (data, mapped_regions, mapped_types, mapped_consts) =\n+                        BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                    (data, Some((mapped_regions, mapped_types, mapped_consts)))\n+                } else {\n+                    (data, None)\n+                };\n                 let data = data.try_fold_with(self)?;\n \n                 let mut orig_values = OriginalQueryValues::default();\n@@ -337,14 +304,18 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                 self.obligations.extend(obligations);\n-                let res = PlaceholderReplacer::replace_placeholders(\n-                    infcx,\n-                    mapped_regions,\n-                    mapped_types,\n-                    mapped_consts,\n-                    &self.universes,\n-                    result.normalized_ty,\n-                );\n+                let res = if let Some((mapped_regions, mapped_types, mapped_consts)) = maps {\n+                    PlaceholderReplacer::replace_placeholders(\n+                        infcx,\n+                        mapped_regions,\n+                        mapped_types,\n+                        mapped_consts,\n+                        &self.universes,\n+                        result.normalized_ty,\n+                    )\n+                } else {\n+                    result.normalized_ty\n+                };\n                 // `tcx.normalize_projection_ty` may normalize to a type that still has\n                 // unevaluated consts, so keep normalizing here if that's the case.\n                 if res != ty && res.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n@@ -353,8 +324,6 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     res\n                 }\n             }\n-\n-            _ => ty.try_super_fold_with(self)?,\n         };\n \n         self.cache.insert(ty, res);"}]}