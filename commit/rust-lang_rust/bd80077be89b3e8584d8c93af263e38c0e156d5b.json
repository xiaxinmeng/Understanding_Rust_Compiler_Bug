{"sha": "bd80077be89b3e8584d8c93af263e38c0e156d5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkODAwNzdiZTg5YjNlODU4NGQ4YzkzYWYyNjNlMzhjMGUxNTZkNWI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-10T11:37:34Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-06-10T12:07:38Z"}, "message": "Add format_trait_ref_then_update_result", "tree": {"sha": "83d415dba125a976e0c82769122f07cf75c7daf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83d415dba125a976e0c82769122f07cf75c7daf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd80077be89b3e8584d8c93af263e38c0e156d5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd80077be89b3e8584d8c93af263e38c0e156d5b", "html_url": "https://github.com/rust-lang/rust/commit/bd80077be89b3e8584d8c93af263e38c0e156d5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd80077be89b3e8584d8c93af263e38c0e156d5b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e522f921dad2f50b78f16dcd24ac256c8bf7c8", "html_url": "https://github.com/rust-lang/rust/commit/88e522f921dad2f50b78f16dcd24ac256c8bf7c8"}], "stats": {"total": 315, "additions": 245, "deletions": 70}, "files": [{"sha": "a0b50bd50b71cba4db1f0e8dea57da4c108ee348", "filename": "src/items.rs", "status": "modified", "additions": 66, "deletions": 70, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd80077be89b3e8584d8c93af263e38c0e156d5b/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80077be89b3e8584d8c93af263e38c0e156d5b/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=bd80077be89b3e8584d8c93af263e38c0e156d5b", "patch": "@@ -678,83 +678,30 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n                                                0);\n         let mut generics_str =\n             try_opt!(rewrite_generics(context, generics, shape, shape.width, mk_sp(lo, hi)));\n+        add_polarity(&mut generics_str, &polarity, trait_ref.is_some());\n \n-        if polarity == ast::ImplPolarity::Negative {\n-            generics_str.push_str(\" !\");\n-        }\n-\n-        let mut retry_with_multiline = true;\n         if let Some(ref trait_ref) = *trait_ref {\n-            if polarity != ast::ImplPolarity::Negative {\n-                generics_str.push_str(\" \");\n-            }\n-            let used_space = if generics_str.contains('\\n') {\n-                last_line_width(&generics_str)\n-            } else {\n-                result.len() + generics_str.len()\n-            };\n-            let budget = context\n-                .config\n-                .max_width()\n-                .checked_sub(used_space)\n-                .unwrap_or(0);\n-            let indent = offset + used_space;\n-            if let Some(trait_ref_str) = trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n-                if !trait_ref_str.contains('\\n') {\n-                    result.push_str(&generics_str);\n-                    result.push_str(&trait_ref_str);\n-                    if split_at_for {\n-                        result.push('\\n');\n-                        // Add indentation of one additional tab.\n-                        result.push_str(&offset\n-                                            .block_indent(context.config)\n-                                            .to_string(context.config));\n-                        result.push_str(\"for\");\n-                    } else {\n-                        result.push_str(\" for\");\n-                    }\n-                    retry_with_multiline = false;\n-                }\n-            }\n-            if retry_with_multiline {\n+            let success = format_trait_ref_then_update_result(context,\n+                                                              &trait_ref,\n+                                                              offset,\n+                                                              &generics_str,\n+                                                              split_at_for,\n+                                                              &mut result);\n+            if !success {\n                 let mut generics_str =\n                     try_opt!(rewrite_generics(context, generics, shape, 0, mk_sp(lo, hi)));\n-                if polarity == ast::ImplPolarity::Negative {\n-                    generics_str.push_str(\" !\");\n-                } else {\n-                    generics_str.push_str(\" \");\n-                }\n-                let used_space = if generics_str.contains('\\n') {\n-                    last_line_width(&generics_str)\n-                } else {\n-                    result.len() + generics_str.len()\n-                };\n-                let budget = context\n-                    .config\n-                    .max_width()\n-                    .checked_sub(used_space)\n-                    .unwrap_or(0);\n-                let indent = offset + used_space;\n-                if let Some(trait_ref_str) =\n-                    trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n-                    result.push_str(&generics_str);\n-                    result.push_str(&trait_ref_str);\n-                    if split_at_for {\n-                        result.push('\\n');\n-                        // Add indentation of one additional tab.\n-                        result.push_str(&offset\n-                                            .block_indent(context.config)\n-                                            .to_string(context.config));\n-                        result.push_str(\"for\");\n-                    } else {\n-                        result.push_str(\" for\");\n-                    }\n+                add_polarity(&mut generics_str, &polarity, true);\n+                if !format_trait_ref_then_update_result(context,\n+                                                        &trait_ref,\n+                                                        offset,\n+                                                        &generics_str,\n+                                                        split_at_for,\n+                                                        &mut result) {\n+                    // FIXME: should be unreachable\n+                    return None;\n                 }\n             }\n         } else {\n-            if polarity == ast::ImplPolarity::Negative {\n-                generics_str.push_str(\" \");\n-            }\n             result.push_str(&generics_str);\n         }\n \n@@ -790,6 +737,55 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n     }\n }\n \n+// Returns false if failed to update result: then, try using multiline.\n+fn format_trait_ref_then_update_result(context: &RewriteContext,\n+                                       trait_ref: &ast::TraitRef,\n+                                       offset: Indent,\n+                                       generics_str: &str,\n+                                       split_at_for: bool,\n+                                       result: &mut String)\n+                                       -> bool {\n+    let used_space = if generics_str.contains('\\n') {\n+        last_line_width(&generics_str)\n+    } else {\n+        result.len() + generics_str.len()\n+    };\n+    let budget = context\n+        .config\n+        .max_width()\n+        .checked_sub(used_space)\n+        .unwrap_or(0);\n+    let indent = offset + used_space;\n+    if let Some(trait_ref_str) = trait_ref.rewrite(context, Shape::legacy(budget, indent)) {\n+        if !trait_ref_str.contains('\\n') {\n+            result.push_str(&generics_str);\n+            result.push_str(&trait_ref_str);\n+            if split_at_for {\n+                result.push('\\n');\n+                // Add indentation of one additional tab.\n+                let for_offset = match context.config.where_style() {\n+                    Style::Legacy => offset.block_indent(context.config),\n+                    Style::Rfc => offset,\n+                };\n+                result.push_str(&for_offset.to_string(context.config));\n+                result.push_str(\"for\");\n+            } else {\n+                result.push_str(\" for\");\n+            }\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+fn add_polarity(s: &mut String, polarity: &ast::ImplPolarity, has_trait_ref: bool) {\n+    if polarity == &ast::ImplPolarity::Negative {\n+        s.push_str(\" !\")\n+    } else if has_trait_ref {\n+        s.push(' ')\n+    }\n+}\n+\n pub fn format_struct(context: &RewriteContext,\n                      item_name: &str,\n                      ident: ast::Ident,"}, {"sha": "167f654cc439a853aa422312b056c51535d43cf9", "filename": "tests/source/big-impl-rfc.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/bd80077be89b3e8584d8c93af263e38c0e156d5b/tests%2Fsource%2Fbig-impl-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80077be89b3e8584d8c93af263e38c0e156d5b/tests%2Fsource%2Fbig-impl-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fbig-impl-rfc.rs?ref=bd80077be89b3e8584d8c93af263e38c0e156d5b", "patch": "@@ -0,0 +1,114 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-fn_call_style: Block\n+// rustfmt-generics_indent: Block\n+// rustfmt-where_style: Rfc\n+\n+// #1357\n+impl<\n+    'a,\n+    Select,\n+    From,\n+    Distinct,\n+    Where,\n+    Order,\n+    Limit,\n+    Offset,\n+    Groupby,\n+    DB,\n+> InternalBoxedDsl<'a, DB>\n+    for SelectStatement<\n+        Select,\n+        From,\n+        Distinct,\n+        Where,\n+        Order,\n+        Limit,\n+        Offset,\n+        GroupBy,\n+    > where\n+        DB: Backend,\n+        Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+        Distinct: QueryFragment<DB> + 'a,\n+        Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+        Order: QueryFragment<DB> + 'a,\n+        Limit: QueryFragment<DB> + 'a,\n+        Offset: QueryFragment<DB> + 'a,\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n+    }\n+}\n+\n+// #1369\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}"}, {"sha": "18fa59cb5a0e037ec6bcb3e7d684fc83d3f5dd96", "filename": "tests/target/big-impl-rfc.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bd80077be89b3e8584d8c93af263e38c0e156d5b/tests%2Ftarget%2Fbig-impl-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd80077be89b3e8584d8c93af263e38c0e156d5b/tests%2Ftarget%2Fbig-impl-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl-rfc.rs?ref=bd80077be89b3e8584d8c93af263e38c0e156d5b", "patch": "@@ -0,0 +1,65 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-fn_call_style: Block\n+// rustfmt-generics_indent: Block\n+// rustfmt-where_style: Rfc\n+\n+// #1357\n+impl<'a, Select, From, Distinct, Where, Order, Limit, Offset, Groupby, DB> InternalBoxedDsl<'a, DB>\n+for SelectStatement<Select, From, Distinct, Where, Order, Limit, Offset, GroupBy>\n+where\n+    DB: Backend,\n+    Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+    Distinct: QueryFragment<DB> + 'a,\n+    Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+    Order: QueryFragment<DB> + 'a,\n+    Limit: QueryFragment<DB> + 'a,\n+    Offset: QueryFragment<DB> + 'a,\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n+    }\n+}\n+\n+// #1369\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+for Bar {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+for Bar {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+for Bar<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+for Bar<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+for Bar<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}"}]}