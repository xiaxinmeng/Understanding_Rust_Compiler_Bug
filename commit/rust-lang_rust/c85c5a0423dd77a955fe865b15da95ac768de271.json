{"sha": "c85c5a0423dd77a955fe865b15da95ac768de271", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NWM1YTA0MjNkZDc3YTk1NWZlODY1YjE1ZGE5NWFjNzY4ZGUyNzE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-03-05T19:12:19Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-03-06T21:03:05Z"}, "message": "Make causal tracking lazy", "tree": {"sha": "bf60f88a1e05d5bdef6371ef38d57b22927f5cb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf60f88a1e05d5bdef6371ef38d57b22927f5cb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c85c5a0423dd77a955fe865b15da95ac768de271", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlqfAgkACgkQiMlBzaHU\nZDJwfg//fqo5K1ShEhYqYL0l6X4jb4P+sk7Ql2OrzkLwKNuPDUkj0NsbTNCnEFkI\n2vM9BV+Fkj6GcaYge1ueZFCdV5Mr4tI8+0tTKPogBJNFEYBUpJMx3koaChmf6WQW\n7EOOpY3Ntuj30I9XSDnzwDtwe8t2wXdEUirBEQS0xSG7jQgxld8mfSpaoEqpUhFK\nw1rq8/UU4s2rgN/lKoO3+4RGNt38vOVOVYQRaTpUfMX/UuDJxV8Ce4KHX8bPgZNz\nnwoljyrAM6DILhBbIKknRPQGO+Oh2itKXz6pGF6ILHecFrZL69RrP+o/OrXxCyc3\naTQ1YotGeGFpd0diET6wLCNaXPH7KNMCc9SOxqz7/uSHCrq82LgPs9xBxYfEgIC5\n1tE/CHwvG8QLAvXW/6qzipKACoekvDQvBMG4xuu4CltphVYiY/9tyKbCq/S8flMw\nEwYNJqqVqOtAx5gKTOHah7QI64tmjuehGcGwqPJixVdacDnEthAcMFP9u5rllsSW\nQ4ZOaFq5XqF2uUjHHNLp0Eu6NjcT6GXlQoq8iPRRzoNhPu0YHD2M9PaQruVxyLFf\nMZ35yhtmA4IsBBZEZJKK+M0e5EBFvbicYUwojCHnFwgPb7t+96wxx2xgYCSqrwc/\no3OXh0MRCBILS9kZYbOYm6koWeKdYOq+Mu5gGPjvt5loJj7CiJ4=\n=z9P8\n-----END PGP SIGNATURE-----", "payload": "tree bf60f88a1e05d5bdef6371ef38d57b22927f5cb9\nparent ec761903ec37df5fe6976be1e25079d8f8cbb494\nauthor Santiago Pastorino <spastorino@gmail.com> 1520277139 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1520370185 -0300\n\nMake causal tracking lazy\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c85c5a0423dd77a955fe865b15da95ac768de271", "html_url": "https://github.com/rust-lang/rust/commit/c85c5a0423dd77a955fe865b15da95ac768de271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c85c5a0423dd77a955fe865b15da95ac768de271/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec761903ec37df5fe6976be1e25079d8f8cbb494", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec761903ec37df5fe6976be1e25079d8f8cbb494", "html_url": "https://github.com/rust-lang/rust/commit/ec761903ec37df5fe6976be1e25079d8f8cbb494"}], "stats": {"total": 156, "additions": 113, "deletions": 43}, "files": [{"sha": "630d87c6098edeb358461cd414c12994694d4dd0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -138,9 +138,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.explain_span(scope_decorated_tag, span)\n             }\n \n-            ty::ReEarlyBound(_) | ty::ReFree(_) => self.msg_span_from_free_region(region),\n-\n-            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic => {\n+                self.msg_span_from_free_region(region)\n+            }\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n@@ -175,6 +175,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn msg_span_from_free_region(self, region: ty::Region<'tcx>) -> (String, Option<Span>) {\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_)  => {\n+                self.msg_span_from_early_bound_and_free_regions(region)\n+            },\n+            ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n+            _ => bug!(),\n+        }\n+    }\n+\n+    fn msg_span_from_early_bound_and_free_regions(\n+        self,\n+        region: ty::Region<'tcx>,\n+    ) -> (String, Option<Span>) {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let unknown;"}, {"sha": "cfa1890e182eadc4e7dd9568c7eceb7d47222d1d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -124,6 +124,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n+        let tcx = self.tcx;\n         let value_msg = match self.describe_place(place) {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n@@ -132,7 +133,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(name) => format!(\"`{}`\", name),\n             None => \"value\".to_owned(),\n         };\n-        let mut err = self.tcx.cannot_move_when_borrowed(\n+        let mut err = tcx.cannot_move_when_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             Origin::Mir,\n@@ -152,7 +153,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n-        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+        let tcx = self.tcx;\n+        let mut err = tcx.cannot_use_when_mutably_borrowed(\n             span,\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),\n             self.retrieve_borrow_span(borrow),\n@@ -254,6 +256,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .unwrap_or(issued_span);\n \n         let desc_place = self.describe_place(place).unwrap_or(\"_\".to_owned());\n+        let tcx = self.tcx;\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (\n@@ -265,7 +268,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"mutable\",\n         ) {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut { .. }, _, rgt)\n-            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => self.tcx\n+            | (BorrowKind::Mut { .. }, _, lft, BorrowKind::Shared, rgt, _) => tcx\n                 .cannot_reborrow_already_borrowed(\n                     span,\n                     &desc_place,\n@@ -279,7 +282,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => self.tcx\n+            (BorrowKind::Mut { .. }, _, _, BorrowKind::Mut { .. }, _, _) => tcx\n                 .cannot_mutably_borrow_multiply(\n                     span,\n                     &desc_place,\n@@ -290,7 +293,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => self.tcx\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) => tcx\n                 .cannot_uniquely_borrow_by_two_closures(\n                     span,\n                     &desc_place,\n@@ -299,7 +302,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Unique, _, _, _, _, _) => self.tcx.cannot_uniquely_borrow_by_one_closure(\n+            (BorrowKind::Unique, _, _, _, _, _) => tcx.cannot_uniquely_borrow_by_one_closure(\n                 span,\n                 &desc_place,\n                 \"\",\n@@ -310,7 +313,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 Origin::Mir,\n             ),\n \n-            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => self.tcx\n+            (BorrowKind::Shared, lft, _, BorrowKind::Unique, _, _) => tcx\n                 .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n@@ -322,7 +325,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Origin::Mir,\n                 ),\n \n-            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => self.tcx\n+            (BorrowKind::Mut { .. }, _, lft, BorrowKind::Unique, _, _) => tcx\n                 .cannot_reborrow_already_uniquely_borrowed(\n                     span,\n                     &desc_place,\n@@ -466,7 +469,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         _proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n-        let mut err = self.tcx.path_does_not_live_long_enough(\n+        let tcx = self.tcx;\n+        let mut err = tcx.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n             Origin::Mir,\n@@ -493,9 +497,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         proper_span: Span,\n         end_span: Option<Span>,\n     ) {\n+        let tcx = self.tcx;\n         let mut err =\n-            self.tcx\n-                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n+            tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(\n             drop_span,\n@@ -527,16 +531,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, name, scope_tree, borrow, drop_span, borrow_span\n         );\n \n-        let mut err = self.tcx.path_does_not_live_long_enough(\n+        let tcx = self.tcx;\n+        let mut err = tcx.path_does_not_live_long_enough(\n             borrow_span,\n             &format!(\"`{}`\", name),\n             Origin::Mir,\n         );\n         err.span_label(borrow_span, \"borrowed value does not live long enough\");\n         err.span_label(drop_span, \"borrowed value only lives until here\");\n \n-        if !self.tcx.nll() {\n-            self.tcx.note_and_explain_region(\n+        if !tcx.nll() {\n+            tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,\n                 \"borrowed value must be valid for \",\n@@ -566,14 +571,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context, scope_tree, borrow, drop_span, proper_span\n         );\n \n+        let tcx = self.tcx;\n         let mut err =\n-            self.tcx\n-                .path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n+            tcx.path_does_not_live_long_enough(proper_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value does not live long enough\");\n         err.span_label(drop_span, \"temporary value only lives until here\");\n \n-        if !self.tcx.nll() {\n-            self.tcx.note_and_explain_region(\n+        if !tcx.nll() {\n+            tcx.note_and_explain_region(\n                 scope_tree,\n                 &mut err,\n                 \"borrowed value must be valid for \",\n@@ -592,7 +597,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n-        let mut err = self.tcx.cannot_assign_to_borrowed(\n+        let tcx = self.tcx;\n+        let mut err = tcx.cannot_assign_to_borrowed(\n             span,\n             self.retrieve_borrow_span(loan),\n             &self.describe_place(place).unwrap_or(\"_\".to_owned()),"}, {"sha": "06412a386e84a6fe52a6da387ebec0b8d58709c4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -10,7 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::region_infer::{RegionInferenceContext, RegionCausalInfo};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -231,6 +231,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         access_place_error_reported: FxHashSet(),\n         reservation_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx.clone(),\n+        nonlexical_cause_info: None,\n     };\n \n     let borrows = Borrows::new(tcx, mir, opt_regioncx, def_id, body_id);\n@@ -311,6 +312,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n+    nonlexical_cause_info: Option<RegionCausalInfo>,\n }\n \n // Check that:"}, {"sha": "843407d0810f598ff201ea908b0d59435632142f", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -18,16 +18,26 @@ use rustc_errors::DiagnosticBuilder;\n use util::liveness::{self, DefUse, LivenessMode};\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    /// Adds annotations to `err` explaining *why* the borrow contains the\n+    /// point from `context`. This is key for the \"3-point errors\"\n+    /// [described in the NLL RFC][d].\n+    ///\n+    /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in borrow_check) fn explain_why_borrow_contains_point(\n-        &self,\n+        &mut self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n         if let Some(regioncx) = &self.nonlexical_regioncx {\n-            if let Some(cause) = regioncx.why_region_contains_point(borrow.region, context.loc) {\n-                let mir = self.mir;\n+            let mir = self.mir;\n \n+            if self.nonlexical_cause_info.is_none() {\n+                self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n+            }\n+\n+            let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n+            if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n                 match *cause.root_cause() {\n                     Cause::LiveVar(local, location) => {\n                         match find_regular_use(&mir, regioncx, borrow, location, local) {"}, {"sha": "9b598b8dd5d1190aad26eabf3ab20cb69d689ce8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -72,6 +72,8 @@ pub struct RegionInferenceContext<'tcx> {\n     universal_regions: UniversalRegions<'tcx>,\n }\n \n+struct TrackCauses(bool);\n+\n struct RegionDefinition<'tcx> {\n     /// Why we created this variable. Mostly these will be\n     /// `RegionVariableOrigin::NLL`, but some variables get created\n@@ -122,6 +124,10 @@ pub(crate) enum Cause {\n     },\n }\n \n+pub(crate) struct RegionCausalInfo {\n+    inferred_values: RegionValues,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n     // NB. The ordering here is not significant for correctness, but\n@@ -343,17 +349,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         inferred_values.contains(r.to_region_vid(), p)\n     }\n \n-    /// Returns the *reason* that the region `r` contains the given point.\n-    pub(crate) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n-    where\n-        R: ToRegionVid,\n-    {\n-        let inferred_values = self.inferred_values\n-            .as_ref()\n-            .expect(\"region values not yet inferred\");\n-        inferred_values.cause(r.to_region_vid(), p)\n-    }\n-\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n         let inferred_values = self.inferred_values\n@@ -444,21 +439,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Re-execute the region inference, this time tracking causal information.\n+    /// This is significantly slower, so it is done only when an error is being reported.\n+    pub(super) fn compute_causal_info(&self, mir: &Mir<'tcx>) -> RegionCausalInfo {\n+        let inferred_values = self.compute_region_values(mir, TrackCauses(true));\n+        RegionCausalInfo { inferred_values }\n+    }\n+\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        debug!(\"propagate_constraints()\");\n-        debug!(\"propagate_constraints: constraints={:#?}\", {\n+        let inferred_values = self.compute_region_values(mir, TrackCauses(false));\n+        self.inferred_values = Some(inferred_values);\n+    }\n+\n+    fn compute_region_values(&self, mir: &Mir<'tcx>, track_causes: TrackCauses) -> RegionValues {\n+        debug!(\"compute_region_values()\");\n+        debug!(\"compute_region_values: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n             constraints.sort();\n             constraints\n         });\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.clone();\n+        let mut inferred_values = self.liveness_constraints.duplicate(track_causes);\n \n         let dependency_map = self.build_dependency_map();\n \n@@ -502,7 +509,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             debug!(\"\\n\");\n         }\n \n-        self.inferred_values = Some(inferred_values);\n+        inferred_values\n     }\n \n     /// Builds up a map from each region variable X to a vector with the\n@@ -1092,6 +1099,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n }\n \n+impl RegionCausalInfo {\n+    /// Returns the *reason* that the region `r` contains the given point.\n+    pub(super) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n+    where\n+        R: ToRegionVid,\n+    {\n+        self.inferred_values.cause(r.to_region_vid(), p)\n+    }\n+}\n+\n impl<'tcx> RegionDefinition<'tcx> {\n     fn new(origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free"}, {"sha": "eb2756e2245d409bffc260beb4629ba08aa120d4", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n use syntax::codemap::Span;\n \n-use super::{Cause, CauseExt};\n+use super::{Cause, CauseExt, TrackCauses};\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -184,7 +184,6 @@ impl ToElementIndex for RegionElementIndex {\n /// compact `SparseBitMatrix` representation, with one row per region\n /// variable. The columns consist of either universal regions or\n /// points in the CFG.\n-#[derive(Clone)]\n pub(super) struct RegionValues {\n     elements: Rc<RegionValueElements>,\n     matrix: SparseBitMatrix<RegionVid, RegionElementIndex>,\n@@ -199,6 +198,9 @@ pub(super) struct RegionValues {\n type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n \n impl RegionValues {\n+    /// Creates a new set of \"region values\" that tracks causal information.\n+    /// Each of the regions in num_region_variables will be initialized with an\n+    /// empty set of points and no causal information.\n     pub(super) fn new(\n         elements: &Rc<RegionValueElements>,\n         num_region_variables: usize,\n@@ -218,6 +220,24 @@ impl RegionValues {\n         }\n     }\n \n+    /// Duplicates the region values. If track_causes is false, then the\n+    /// resulting value will not track causal information (and any existing\n+    /// causal information is dropped). Otherwise, the causal information is\n+    /// preserved and maintained. Tracking the causal information makes region\n+    /// propagation significantly slower, so we prefer not to do it until an\n+    /// error is reported.\n+    pub(super) fn duplicate(&self, track_causes: TrackCauses) -> Self {\n+        Self {\n+            elements: self.elements.clone(),\n+            matrix: self.matrix.clone(),\n+            causes: if track_causes.0 {\n+                self.causes.clone()\n+            } else {\n+                None\n+            },\n+        }\n+    }\n+\n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n     pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E, cause: &Cause) -> bool {"}, {"sha": "86653138a185f3652c1356bc318fb44bd36c3c95", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c85c5a0423dd77a955fe865b15da95ac768de271/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=c85c5a0423dd77a955fe865b15da95ac768de271", "patch": "@@ -78,6 +78,8 @@ LL |     let cell = Cell::new(&a);\n ...\n LL | }\n    | - borrowed value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n \n error: aborting due to 2 previous errors\n "}]}