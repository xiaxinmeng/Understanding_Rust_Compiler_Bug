{"sha": "c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjA0YmIyODFkNmY4Y2E3N2MzM2YxNWU2N2EyNmUwY2VlYjk1YTM=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-16T17:47:45Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-01-16T17:47:45Z"}, "message": "Add a lint to warn about call to `.*or(foo(..))`", "tree": {"sha": "7f1fdbd31c45b5ffab38270780dcb5cf073d2627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f1fdbd31c45b5ffab38270780dcb5cf073d2627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "html_url": "https://github.com/rust-lang/rust/commit/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "604be945d27c37f3415b52a3c249984a860a2f56", "url": "https://api.github.com/repos/rust-lang/rust/commits/604be945d27c37f3415b52a3c249984a860a2f56", "html_url": "https://github.com/rust-lang/rust/commit/604be945d27c37f3415b52a3c249984a860a2f56"}], "stats": {"total": 94, "additions": 90, "deletions": 4}, "files": [{"sha": "29644a14fc48a7c4d22d347f128a9923b547a691", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 92 lints included in this crate:\n+There are 93 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -63,6 +63,7 @@ name\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                   | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n [option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)         | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                       | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                     | warn    | using any `*or` method when the `*or_else` would do\n [out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)               | deny    | out of bound constant indexing\n [panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                   | warn    | missing parameters in `panic!`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                       | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught"}, {"sha": "4e13ba5c45838b72c82f3e80b6b6e9fd02a17390", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "patch": "@@ -194,6 +194,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,\n         methods::OPTION_MAP_UNWRAP_OR_ELSE,\n+        methods::OR_FUN_CALL,\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,"}, {"sha": "ff91759be2377e1a2e27ab2e9d0053f584f7fbb7", "filename": "src/methods.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "patch": "@@ -4,6 +4,7 @@ use rustc::middle::ty;\n use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n+use syntax::ptr::P;\n \n use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n             walk_ptrs_ty_depth, walk_ptrs_ty};\n@@ -170,6 +171,25 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n               \"using an iterator search followed by `is_some()`, which is more succinctly \\\n                expressed as a call to `any()`\");\n \n+/// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n+/// suggests to use `or_else`, `unwrap_or_else`, etc., instead.\n+///\n+/// **Why is this bad?** The function will always be called and potentially allocate an object\n+/// in expressions such as:\n+/// ```rust\n+/// foo.unwrap_or(String::new())\n+/// ```\n+/// this can instead be written:\n+/// ```rust\n+/// foo.unwrap_or_else(String::new)\n+/// ```\n+///\n+/// **Known problems:** If the function as side-effects, not calling it will change the semantic of\n+/// the program, but you shouldn't rely on that anyway. The will won't catch\n+/// `foo.unwrap_or(vec![])`.\n+declare_lint!(pub OR_FUN_CALL, Warn,\n+              \"using any `*or` method when the `*or_else` would do\");\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED,\n@@ -181,13 +201,15 @@ impl LintPass for MethodsPass {\n                     WRONG_PUB_SELF_CONVENTION,\n                     OK_EXPECT,\n                     OPTION_MAP_UNWRAP_OR,\n-                    OPTION_MAP_UNWRAP_OR_ELSE)\n+                    OPTION_MAP_UNWRAP_OR_ELSE,\n+                    OR_FUN_CALL)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(_, _, _) = expr.node {\n+        if let ExprMethodCall(name, _, ref args) = expr.node {\n+            // Chain calls\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 lint_unwrap(cx, expr, arglists[0]);\n             } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n@@ -207,6 +229,8 @@ impl LateLintPass for MethodsPass {\n             } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n                 lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n             }\n+\n+            lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n         }\n     }\n \n@@ -258,6 +282,39 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+/// Checks for the `OR_FUN_CALL` lint.\n+fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n+    if args.len() == 2 && [\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"].contains(&name) {\n+        let self_ty = cx.tcx.expr_ty(&args[0]);\n+\n+        let is_result = if match_type(cx, self_ty, &RESULT_PATH) {\n+            true\n+        }\n+        else if match_type(cx, self_ty, &OPTION_PATH) {\n+            false\n+        }\n+        else {\n+            return;\n+        };\n+\n+        if let ExprCall(ref fun, ref or_args) = args[1].node {\n+            let sugg = match (is_result, or_args.is_empty()) {\n+                (true, _) => format!(\"|_| {}\", snippet(cx, args[1].span, \"..\")),\n+                (false, false) => format!(\"|| {}\", snippet(cx, args[1].span, \"..\")),\n+                (false, true) => format!(\"{}\", snippet(cx, fun.span, \"..\")),\n+            };\n+\n+            span_lint(cx, OR_FUN_CALL, expr.span,\n+                      &format!(\"use of `{}` followed by a function call\", name))\n+                .span_suggestion(expr.span, \"try this\",\n+                                 format!(\"{}.{}_else({})\",\n+                                         snippet(cx, args[0].span, \"_\"),\n+                                         name,\n+                                         sugg));\n+        }\n+    }\n+}\n+\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s"}, {"sha": "4b1444520634ed063acbf40d33d54ef6727757f5", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "patch": "@@ -244,7 +244,7 @@ pub fn is_from_for_desugar(decl: &Decl) -> bool {\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n+    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available."}, {"sha": "570715db6af8365eb85a3934f9c29dd1886b59a6", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=c6604bb281d6f8ca77c33f15e67a26e0ceeb95a3", "patch": "@@ -175,6 +175,33 @@ fn search_is_some() {\n     let _ = foo.rposition().is_some();\n }\n \n+/// Checks implementation of the OR_FUN_CALL lint\n+fn or_fun_call() {\n+    let foo = Some(vec![1]);\n+    foo.unwrap_or(Vec::new());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION foo.unwrap_or_else(Vec::new);\n+\n+    let bar = Some(vec![1]);\n+    bar.unwrap_or(Vec::with_capacity(12));\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION bar.unwrap_or_else(|| Vec::with_capacity(12));\n+\n+    let baz : Result<_, ()> = Ok(vec![1]);\n+    baz.unwrap_or(Vec::new());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION baz.unwrap_or_else(|_| Vec::new());\n+\n+    let qux : Result<_, ()> = Ok(vec![1]);\n+    qux.unwrap_or(Vec::with_capacity(12));\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION qux.unwrap_or_else(|_| Vec::with_capacity(12));\n+}\n+\n fn main() {\n     use std::io;\n "}]}