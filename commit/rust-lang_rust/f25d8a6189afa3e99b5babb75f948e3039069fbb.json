{"sha": "f25d8a6189afa3e99b5babb75f948e3039069fbb", "node_id": "C_kwDOAAsO6NoAKGYyNWQ4YTYxODlhZmEzZTk5YjViYWJiNzVmOTQ4ZTMwMzkwNjlmYmI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-11T08:52:23Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-12-11T08:52:23Z"}, "message": "Merge from rustc", "tree": {"sha": "b192f46b784d197549351e884b7448c06fa873f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b192f46b784d197549351e884b7448c06fa873f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f25d8a6189afa3e99b5babb75f948e3039069fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f25d8a6189afa3e99b5babb75f948e3039069fbb", "html_url": "https://github.com/rust-lang/rust/commit/f25d8a6189afa3e99b5babb75f948e3039069fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f25d8a6189afa3e99b5babb75f948e3039069fbb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30e435907e324d679943b21c94fc8e7a9ddd7348", "url": "https://api.github.com/repos/rust-lang/rust/commits/30e435907e324d679943b21c94fc8e7a9ddd7348", "html_url": "https://github.com/rust-lang/rust/commit/30e435907e324d679943b21c94fc8e7a9ddd7348"}, {"sha": "23a34c18f7b2ce8b20fed717ef48e2be1776246b", "url": "https://api.github.com/repos/rust-lang/rust/commits/23a34c18f7b2ce8b20fed717ef48e2be1776246b", "html_url": "https://github.com/rust-lang/rust/commit/23a34c18f7b2ce8b20fed717ef48e2be1776246b"}], "stats": {"total": 11087, "additions": 7531, "deletions": 3556}, "files": [{"sha": "37bbe95d633817484ca6f0f93cff859fca843f2b", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -4168,6 +4168,7 @@ dependencies = [\n name = \"rustc_parse_format\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_data_structures\",\n  \"rustc_lexer\",\n ]\n \n@@ -4342,6 +4343,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_lint_defs\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -4402,6 +4404,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"tracing\",\n+ \"twox-hash\",\n ]\n \n [[package]]\n@@ -5392,6 +5395,17 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"twox-hash\"\n+version = \"1.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"rand 0.8.5\",\n+ \"static_assertions\",\n+]\n+\n [[package]]\n name = \"type-map\"\n version = \"0.4.0\""}, {"sha": "6fd9290058c36383e1a5c155de33f467701ee93d", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -106,7 +106,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {"}, {"sha": "5289de9b0abf2ffa3d0d2d142904b392070dc2d9", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -644,7 +644,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n         self.check_activations(loc, span, flow_state);\n \n         match &term.kind {\n-            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place, target: _, unwind: _ } => {"}, {"sha": "814bc275019ca0109e4e3d265406630f2cf07398", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1360,25 +1360,10 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt { discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { discr, .. } => {\n                 self.check_operand(discr, term_location);\n \n-                let discr_ty = discr.ty(body, tcx);\n-                if let Err(terr) = self.sub_types(\n-                    discr_ty,\n-                    *switch_ty,\n-                    term_location.to_locations(),\n-                    ConstraintCategory::Assignment,\n-                ) {\n-                    span_mirbug!(\n-                        self,\n-                        term,\n-                        \"bad SwitchInt ({:?} on {:?}): {:?}\",\n-                        switch_ty,\n-                        discr_ty,\n-                        terr\n-                    );\n-                }\n+                let switch_ty = discr.ty(body, tcx);\n                 if !switch_ty.is_integral() && !switch_ty.is_char() && !switch_ty.is_bool() {\n                     span_mirbug!(self, term, \"bad SwitchInt discr ty {:?}\", switch_ty);\n                 }"}, {"sha": "9ae65c641fd624bb82aeeea2f05db155ac3ce7af", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -11,7 +11,7 @@ pub fn expand_concat(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+    let Some(es) = base::get_exprs_from_tts(cx, tts) else {\n         return DummyResult::any(sp);\n     };\n     let mut accumulator = String::new();"}, {"sha": "70ce5a6c41929ebc87afe228579426766ee46daf", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -137,7 +137,7 @@ pub fn expand_concat_bytes(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+    let Some(es) = base::get_exprs_from_tts(cx, tts) else {\n         return DummyResult::any(sp);\n     };\n     let mut accumulator = Vec::new();"}, {"sha": "a7283ea601b19e4c20a846beb76663562001da0f", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -52,7 +52,7 @@ pub fn expand_env<'cx>(\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n+    let mut exprs = match get_exprs_from_tts(cx, tts) {\n         Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);"}, {"sha": "63bc0d552c11e7e24e17bbb45ff095590fd1f18b", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -333,7 +333,7 @@ pub fn make_format_args(\n             parse::Piece::String(s) => {\n                 unfinished_literal.push_str(s);\n             }\n-            parse::Piece::NextArgument(parse::Argument { position, position_span, format }) => {\n+            parse::Piece::NextArgument(box parse::Argument { position, position_span, format }) => {\n                 if !unfinished_literal.is_empty() {\n                     template.push(FormatArgsPiece::Literal(Symbol::intern(&unfinished_literal)));\n                     unfinished_literal.clear();"}, {"sha": "06813d7ec953f558a44eec3eb059723167e45131", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -372,8 +372,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 }\n             }\n \n-            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n-                let discr = codegen_operand(fx, discr).load_scalar(fx);\n+            TerminatorKind::SwitchInt { discr, targets } => {\n+                let discr = codegen_operand(fx, discr);\n+                let switch_ty = discr.layout().ty;\n+                let discr = discr.load_scalar(fx);\n \n                 let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n                     || (targets.iter().count() == 1 && targets.iter().next().unwrap().0 == 0);"}, {"sha": "89a415cdb36cd2d8d98c0b1f132541e018364f39", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -300,4 +300,8 @@ impl<'gcc, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // Unsupported.\n         self.context.new_rvalue_from_int(self.int_type, 0)\n     }\n+\n+    fn set_kcfi_type_metadata(&self, _function: RValue<'gcc>, _kcfi_typeid: u32) {\n+        // Unsupported.\n+    }\n }"}, {"sha": "668d929270530023e08c94352b9d7522b3871e75", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -88,7 +88,8 @@ pub(crate) unsafe fn codegen(\n             callee,\n             args.as_ptr(),\n             args.len() as c_uint,\n-            None,\n+            [].as_ptr(),\n+            0 as c_uint,\n         );\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n@@ -132,8 +133,15 @@ pub(crate) unsafe fn codegen(\n         .enumerate()\n         .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n         .collect::<Vec<_>>();\n-    let ret =\n-        llvm::LLVMRustBuildCall(llbuilder, ty, callee, args.as_ptr(), args.len() as c_uint, None);\n+    let ret = llvm::LLVMRustBuildCall(\n+        llbuilder,\n+        ty,\n+        callee,\n+        args.as_ptr(),\n+        args.len() as c_uint,\n+        [].as_ptr(),\n+        0 as c_uint,\n+    );\n     llvm::LLVMSetTailCall(ret, True);\n     llvm::LLVMBuildRetVoid(llbuilder);\n     llvm::LLVMDisposeBuilder(llbuilder);"}, {"sha": "83bffb20e0ce02c706f191199119627fefe1a4f5", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::layout::{\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n+use rustc_symbol_mangling::typeid::kcfi_typeid_for_fnabi;\n use rustc_target::abi::{self, call::FnAbi, Align, Size, WrappingRange};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -225,9 +226,25 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         debug!(\"invoke {:?} with args ({:?})\", llfn, args);\n \n         let args = self.check_call(\"invoke\", llty, llfn, args);\n-        let bundle = funclet.map(|funclet| funclet.bundle());\n-        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+        let funclet_bundle = funclet.map(|funclet| funclet.bundle());\n+        let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n+        let mut bundles = vec![funclet_bundle];\n+\n+        // Set KCFI operand bundle\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        let kcfi_bundle =\n+            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n+            } else {\n+                None\n+            };\n+        if kcfi_bundle.is_some() {\n+            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+            bundles.push(kcfi_bundle);\n+        }\n \n+        bundles.retain(|bundle| bundle.is_some());\n         let invoke = unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n@@ -237,7 +254,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.len() as c_uint,\n                 then,\n                 catch,\n-                bundle,\n+                bundles.as_ptr(),\n+                bundles.len() as c_uint,\n                 UNNAMED,\n             )\n         };\n@@ -1143,7 +1161,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                None,\n+                [].as_ptr(),\n+                0 as c_uint,\n             );\n         }\n     }\n@@ -1159,17 +1178,34 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         debug!(\"call {:?} with args ({:?})\", llfn, args);\n \n         let args = self.check_call(\"call\", llty, llfn, args);\n-        let bundle = funclet.map(|funclet| funclet.bundle());\n-        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+        let funclet_bundle = funclet.map(|funclet| funclet.bundle());\n+        let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n+        let mut bundles = vec![funclet_bundle];\n+\n+        // Set KCFI operand bundle\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        let kcfi_bundle =\n+            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n+            } else {\n+                None\n+            };\n+        if kcfi_bundle.is_some() {\n+            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+            bundles.push(kcfi_bundle);\n+        }\n \n+        bundles.retain(|bundle| bundle.is_some());\n         let call = unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                bundle,\n+                bundles.as_ptr(),\n+                bundles.len() as c_uint,\n             )\n         };\n         if let Some(fn_abi) = fn_abi {"}, {"sha": "aa1735f38acfd1e8c4c65e49f1998939407e84af", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -250,6 +250,11 @@ pub unsafe fn create_module<'ll>(\n         );\n     }\n \n+    if sess.is_sanitizer_kcfi_enabled() {\n+        let kcfi = \"kcfi\\0\".as_ptr().cast();\n+        llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Override, kcfi, 1);\n+    }\n+\n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n     if sess.target.is_like_msvc {\n         match sess.opts.cg.control_flow_guard {"}, {"sha": "a9e3dcf4cb39a7c56663f6bb271c82e0003ea71f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -27,9 +27,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n-use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n@@ -1026,33 +1024,6 @@ fn build_struct_type_di_node<'ll, 'tcx>(\n // Tuples\n //=-----------------------------------------------------------------------------\n \n-/// Returns names of captured upvars for closures and generators.\n-///\n-/// Here are some examples:\n-///  - `name__field1__field2` when the upvar is captured by value.\n-///  - `_ref__name__field` when the upvar is captured by reference.\n-///\n-/// For generators this only contains upvars that are shared by all states.\n-fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) -> SmallVec<String> {\n-    let body = tcx.optimized_mir(def_id);\n-\n-    body.var_debug_info\n-        .iter()\n-        .filter_map(|var| {\n-            let is_ref = match var.value {\n-                mir::VarDebugInfoContents::Place(place) if place.local == mir::Local::new(1) => {\n-                    // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n-                    // implies whether the variable is captured by value or by reference.\n-                    matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n-                }\n-                _ => return None,\n-            };\n-            let prefix = if is_ref { \"_ref__\" } else { \"\" };\n-            Some(prefix.to_owned() + var.name.as_str())\n-        })\n-        .collect()\n-}\n-\n /// Builds the DW_TAG_member debuginfo nodes for the upvars of a closure or generator.\n /// For a generator, this will handle upvars shared by all states.\n fn build_upvar_field_di_nodes<'ll, 'tcx>(\n@@ -1083,7 +1054,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n             .all(|&t| t == cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n     );\n \n-    let capture_names = closure_saved_names_of_captured_variables(cx.tcx, def_id);\n+    let capture_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n     let layout = cx.layout_of(closure_or_generator_ty);\n \n     up_var_tys\n@@ -1229,43 +1200,6 @@ fn build_union_type_di_node<'ll, 'tcx>(\n     )\n }\n \n-// FIXME(eddyb) maybe precompute this? Right now it's computed once\n-// per generator monomorphization, but it doesn't depend on substs.\n-fn generator_layout_and_saved_local_names<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n-    let body = tcx.optimized_mir(def_id);\n-    let generator_layout = body.generator_layout().unwrap();\n-    let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n-\n-    let state_arg = mir::Local::new(1);\n-    for var in &body.var_debug_info {\n-        let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n-        if place.local != state_arg {\n-            continue;\n-        }\n-        match place.projection[..] {\n-            [\n-                // Deref of the `Pin<&mut Self>` state argument.\n-                mir::ProjectionElem::Field(..),\n-                mir::ProjectionElem::Deref,\n-                // Field of a variant of the state.\n-                mir::ProjectionElem::Downcast(_, variant),\n-                mir::ProjectionElem::Field(field, _),\n-            ] => {\n-                let name = &mut generator_saved_local_names\n-                    [generator_layout.variant_fields[variant][field]];\n-                if name.is_none() {\n-                    name.replace(var.name);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    (generator_layout, generator_saved_local_names)\n-}\n-\n /// Computes the type parameters for a type, if any, for the given metadata.\n fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,"}, {"sha": "69443b9b828e2caf3a19ba382557c3431ada8169", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -22,9 +22,9 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            build_field_di_node, closure_saved_names_of_captured_variables,\n+            build_field_di_node,\n             enums::{tag_base_type, DiscrResult},\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n@@ -677,9 +677,9 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n     };\n \n     let (generator_layout, state_specific_upvar_names) =\n-        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+        cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n-    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let common_upvar_names = cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n     let variant_count = (variant_range.start.as_u32()..variant_range.end.as_u32()).len();\n "}, {"sha": "93419d27a6236c5356a1a4045c7e05b0225794a6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -4,9 +4,8 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            closure_saved_names_of_captured_variables,\n             enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, StubInfo, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n             UNKNOWN_LINE_NUMBER,\n@@ -157,7 +156,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n         ),\n         |cx, generator_type_di_node| {\n             let (generator_layout, state_specific_upvar_names) =\n-                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+                cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n             let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n                 bug!(\n@@ -167,7 +166,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n             };\n \n             let common_upvar_names =\n-                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+                cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n \n             // Build variant struct types\n             let variant_struct_type_di_nodes: SmallVec<_> = variants"}, {"sha": "6a575095f7e45dbc5e05a7b86cebd7ce2851925e", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -20,7 +20,7 @@ use crate::type_::Type;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::TypeMembershipMethods;\n use rustc_middle::ty::Ty;\n-use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n+use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi};\n use smallvec::SmallVec;\n \n /// Declare a function.\n@@ -136,6 +136,11 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             self.set_type_metadata(llfn, typeid);\n         }\n \n+        if self.tcx.sess.is_sanitizer_kcfi_enabled() {\n+            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n+            self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+        }\n+\n         llfn\n     }\n "}, {"sha": "e61dbe8b8fc50dfbd2c0fe6de8fc8c7604b06974", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -427,6 +427,7 @@ pub enum MetadataType {\n     MD_type = 19,\n     MD_vcall_visibility = 28,\n     MD_noundef = 29,\n+    MD_kcfi_type = 36,\n }\n \n /// LLVMRustAsmDialect\n@@ -1063,6 +1064,7 @@ extern \"C\" {\n     pub fn LLVMGlobalSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMRustGlobalAddMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMValueAsMetadata(Node: &Value) -> &Metadata;\n+    pub fn LLVMIsAFunction(Val: &Value) -> Option<&Value>;\n \n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n@@ -1273,7 +1275,8 @@ extern \"C\" {\n         NumArgs: c_uint,\n         Then: &'a BasicBlock,\n         Catch: &'a BasicBlock,\n-        Bundle: Option<&OperandBundleDef<'a>>,\n+        OpBundles: *const Option<&OperandBundleDef<'a>>,\n+        NumOpBundles: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n     pub fn LLVMBuildLandingPad<'a>(\n@@ -1643,7 +1646,8 @@ extern \"C\" {\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n-        Bundle: Option<&OperandBundleDef<'a>>,\n+        OpBundles: *const Option<&OperandBundleDef<'a>>,\n+        NumOpBundles: c_uint,\n     ) -> &'a Value;\n     pub fn LLVMRustBuildMemCpy<'a>(\n         B: &Builder<'a>,"}, {"sha": "ff111d96f840b1bc817ceb7bfbecf29aa1ee0e6d", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -316,4 +316,19 @@ impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             )\n         }\n     }\n+\n+    fn set_kcfi_type_metadata(&self, function: &'ll Value, kcfi_typeid: u32) {\n+        let kcfi_type_metadata = self.const_u32(kcfi_typeid);\n+        unsafe {\n+            llvm::LLVMGlobalSetMetadata(\n+                function,\n+                llvm::MD_kcfi_type as c_uint,\n+                llvm::LLVMMDNodeInContext2(\n+                    self.llcx,\n+                    &llvm::LLVMValueAsMetadata(kcfi_type_metadata),\n+                    1,\n+                ),\n+            )\n+        }\n+    }\n }"}, {"sha": "f3f5ddb52d6a4a29117ee3ad4be87ccd99e4c763", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -307,12 +307,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         helper: TerminatorCodegenHelper<'tcx>,\n         bx: &mut Bx,\n         discr: &mir::Operand<'tcx>,\n-        switch_ty: Ty<'tcx>,\n         targets: &SwitchTargets,\n     ) {\n         let discr = self.codegen_operand(bx, &discr);\n-        // `switch_ty` is redundant, sanity-check that.\n-        assert_eq!(discr.layout.ty, switch_ty);\n+        let switch_ty = discr.layout.ty;\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit `br` instead of\n@@ -1293,8 +1291,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 helper.funclet_br(self, bx, target, mergeable_succ())\n             }\n \n-            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n-                self.codegen_switchint_terminator(helper, bx, discr, switch_ty, targets);\n+            mir::TerminatorKind::SwitchInt { ref discr, ref targets } => {\n+                self.codegen_switchint_terminator(helper, bx, discr, targets);\n                 MergingSucc::False\n             }\n "}, {"sha": "b7982b633f57fa8b38b93983d078358152820d68", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 107, "deletions": 29, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -3,12 +3,12 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir;\n use rustc_middle::ty;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::Abi;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Abi, Size, VariantIdx};\n \n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -76,6 +76,106 @@ impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n     }\n }\n \n+trait DebugInfoOffsetLocation<'tcx, Bx> {\n+    fn deref(&self, bx: &mut Bx) -> Self;\n+    fn layout(&self) -> TyAndLayout<'tcx>;\n+    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self;\n+    fn downcast(&self, bx: &mut Bx, variant: VariantIdx) -> Self;\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> DebugInfoOffsetLocation<'tcx, Bx>\n+    for PlaceRef<'tcx, Bx::Value>\n+{\n+    fn deref(&self, bx: &mut Bx) -> Self {\n+        bx.load_operand(*self).deref(bx.cx())\n+    }\n+\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self {\n+        PlaceRef::project_field(*self, bx, field.index())\n+    }\n+\n+    fn downcast(&self, bx: &mut Bx, variant: VariantIdx) -> Self {\n+        self.project_downcast(bx, variant)\n+    }\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> DebugInfoOffsetLocation<'tcx, Bx>\n+    for TyAndLayout<'tcx>\n+{\n+    fn deref(&self, bx: &mut Bx) -> Self {\n+        bx.cx().layout_of(\n+            self.ty.builtin_deref(true).unwrap_or_else(|| bug!(\"cannot deref `{}`\", self.ty)).ty,\n+        )\n+    }\n+\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        *self\n+    }\n+\n+    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self {\n+        self.field(bx.cx(), field.index())\n+    }\n+\n+    fn downcast(&self, bx: &mut Bx, variant: VariantIdx) -> Self {\n+        self.for_variant(bx.cx(), variant)\n+    }\n+}\n+\n+struct DebugInfoOffset<T> {\n+    /// Offset from the `base` used to calculate the debuginfo offset.\n+    direct_offset: Size,\n+    /// Each offset in this vector indicates one level of indirection from the base or previous\n+    /// indirect offset plus a dereference.\n+    indirect_offsets: Vec<Size>,\n+    /// The final location debuginfo should point to.\n+    result: T,\n+}\n+\n+fn calculate_debuginfo_offset<\n+    'a,\n+    'tcx,\n+    Bx: BuilderMethods<'a, 'tcx>,\n+    L: DebugInfoOffsetLocation<'tcx, Bx>,\n+>(\n+    bx: &mut Bx,\n+    local: mir::Local,\n+    var: &PerLocalVarDebugInfo<'tcx, Bx::DIVariable>,\n+    base: L,\n+) -> DebugInfoOffset<L> {\n+    let mut direct_offset = Size::ZERO;\n+    // FIXME(eddyb) use smallvec here.\n+    let mut indirect_offsets = vec![];\n+    let mut place = base;\n+\n+    for elem in &var.projection[..] {\n+        match *elem {\n+            mir::ProjectionElem::Deref => {\n+                indirect_offsets.push(Size::ZERO);\n+                place = place.deref(bx);\n+            }\n+            mir::ProjectionElem::Field(field, _) => {\n+                let offset = indirect_offsets.last_mut().unwrap_or(&mut direct_offset);\n+                *offset += place.layout().fields.offset(field.index());\n+                place = place.project_field(bx, field);\n+            }\n+            mir::ProjectionElem::Downcast(_, variant) => {\n+                place = place.downcast(bx, variant);\n+            }\n+            _ => span_bug!(\n+                var.source_info.span,\n+                \"unsupported var debuginfo place `{:?}`\",\n+                mir::Place { local, projection: var.projection },\n+            ),\n+        }\n+    }\n+\n+    DebugInfoOffset { direct_offset, indirect_offsets, result: place }\n+}\n+\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn set_debug_loc(&self, bx: &mut Bx, source_info: mir::SourceInfo) {\n         bx.set_span(source_info.span);\n@@ -262,33 +362,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let Some(dbg_var) = var.dbg_var else { continue };\n             let Some(dbg_loc) = self.dbg_loc(var.source_info) else { continue };\n \n-            let mut direct_offset = Size::ZERO;\n-            // FIXME(eddyb) use smallvec here.\n-            let mut indirect_offsets = vec![];\n-            let mut place = base;\n-\n-            for elem in &var.projection[..] {\n-                match *elem {\n-                    mir::ProjectionElem::Deref => {\n-                        indirect_offsets.push(Size::ZERO);\n-                        place = bx.load_operand(place).deref(bx.cx());\n-                    }\n-                    mir::ProjectionElem::Field(field, _) => {\n-                        let i = field.index();\n-                        let offset = indirect_offsets.last_mut().unwrap_or(&mut direct_offset);\n-                        *offset += place.layout.fields.offset(i);\n-                        place = place.project_field(bx, i);\n-                    }\n-                    mir::ProjectionElem::Downcast(_, variant) => {\n-                        place = place.project_downcast(bx, variant);\n-                    }\n-                    _ => span_bug!(\n-                        var.source_info.span,\n-                        \"unsupported var debuginfo place `{:?}`\",\n-                        mir::Place { local, projection: var.projection },\n-                    ),\n-                }\n-            }\n+            let DebugInfoOffset { direct_offset, indirect_offsets, result: _ } =\n+                calculate_debuginfo_offset(bx, local, &var, base.layout);\n \n             // When targeting MSVC, create extra allocas for arguments instead of pointing multiple\n             // dbg_var_addr() calls into the same alloca with offsets. MSVC uses CodeView records\n@@ -306,6 +381,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     || !matches!(&indirect_offsets[..], [Size::ZERO] | []));\n \n             if should_create_individual_allocas {\n+                let DebugInfoOffset { direct_offset: _, indirect_offsets: _, result: place } =\n+                    calculate_debuginfo_offset(bx, local, &var, base);\n+\n                 // Create a variable which will be a pointer to the actual value\n                 let ptr_ty = bx.tcx().mk_ty(ty::RawPtr(ty::TypeAndMut {\n                     mutbl: mir::Mutability::Mut,"}, {"sha": "109161ccc836865e36ea8151bc61f236125347db", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -122,6 +122,7 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n pub trait TypeMembershipMethods<'tcx>: Backend<'tcx> {\n     fn set_type_metadata(&self, function: Self::Function, typeid: String);\n     fn typeid_metadata(&self, typeid: String) -> Self::Value;\n+    fn set_kcfi_type_metadata(&self, function: Self::Function, typeid: u32);\n }\n \n pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {"}, {"sha": "c60d6e4fed9f55277ba8640f9fb8ed81d4612dfc", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -123,14 +123,14 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 // Helper closure to print duplicated lines.\n                 let mut flush_last_line = |last_frame, times| {\n                     if let Some((line, span)) = last_frame {\n-                        err.span_label(span, &line);\n+                        err.span_note(span, &line);\n                         // Don't print [... additional calls ...] if the number of lines is small\n                         if times < 3 {\n                             for _ in 0..times {\n-                                err.span_label(span, &line);\n+                                err.span_note(span, &line);\n                             }\n                         } else {\n-                            err.span_label(\n+                            err.span_note(\n                                 span,\n                                 format!(\"[... {} additional calls {} ...]\", times, &line),\n                             );"}, {"sha": "0b2809f1d2c285238c1a93a8bb65fc314483de87", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::{\n };\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_session::Limit;\n-use rustc_span::{Pos, Span};\n+use rustc_span::Span;\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n@@ -256,25 +256,13 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n             if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n                 == DefPathData::ClosureExpr\n             {\n-                write!(f, \"inside closure\")?;\n+                write!(f, \"inside closure\")\n             } else {\n                 // Note: this triggers a `good_path_bug` state, which means that if we ever get here\n                 // we must emit a diagnostic. We should never display a `FrameInfo` unless we\n                 // actually want to emit a warning or error to the user.\n-                write!(f, \"inside `{}`\", self.instance)?;\n+                write!(f, \"inside `{}`\", self.instance)\n             }\n-            if !self.span.is_dummy() {\n-                let sm = tcx.sess.source_map();\n-                let lo = sm.lookup_char_pos(self.span.lo());\n-                write!(\n-                    f,\n-                    \" at {}:{}:{}\",\n-                    sm.filename_for_diagnostics(&lo.file.name),\n-                    lo.line,\n-                    lo.col.to_usize() + 1\n-                )?;\n-            }\n-            Ok(())\n         })\n     }\n }"}, {"sha": "0e7ffcdffc97aae54f0b020282f3b61aa9dfa701", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,10 +29,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Goto { target } => self.go_to_block(target),\n \n-            SwitchInt { ref discr, ref targets, switch_ty } => {\n+            SwitchInt { ref discr, ref targets } => {\n                 let discr = self.read_immediate(&self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n-                assert_eq!(discr.layout.ty, switch_ty);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets.otherwise();"}, {"sha": "64318f5f54d5d061c255726f800e9251d631933b", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::bit_set::BitSet;\n+use rustc_infer::traits::Reveal;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -44,8 +45,11 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             return;\n         }\n         let def_id = body.source.def_id();\n-        let param_env = tcx.param_env(def_id);\n         let mir_phase = self.mir_phase;\n+        let param_env = match mir_phase.reveal() {\n+            Reveal::UserFacing => tcx.param_env(def_id),\n+            Reveal::All => tcx.param_env_reveal_all_normalized(def_id),\n+        };\n \n         let always_live_locals = always_storage_live_locals(body);\n         let storage_liveness = MaybeStorageLive::new(always_live_locals)\n@@ -682,17 +686,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             TerminatorKind::Goto { target } => {\n                 self.check_edge(location, *target, EdgeKind::Normal);\n             }\n-            TerminatorKind::SwitchInt { targets, switch_ty, discr } => {\n-                let ty = discr.ty(&self.body.local_decls, self.tcx);\n-                if ty != *switch_ty {\n-                    self.fail(\n-                        location,\n-                        format!(\n-                            \"encountered `SwitchInt` terminator with type mismatch: {:?} != {:?}\",\n-                            ty, switch_ty,\n-                        ),\n-                    );\n-                }\n+            TerminatorKind::SwitchInt { targets, discr } => {\n+                let switch_ty = discr.ty(&self.body.local_decls, self.tcx);\n \n                 let target_width = self.tcx.sess.target.pointer_width;\n "}, {"sha": "df0e8ae5dd8f5d11bb0577d502ef388e44d132e3", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -20,3 +20,110 @@ expand_var_still_repeating =\n     variable '{$ident}' is still repeating at this depth\n \n expand_meta_var_dif_seq_matchers = {$msg}\n+\n+expand_macro_const_stability =\n+    macros cannot have const stability attributes\n+    .label = invalid const stability attribute\n+    .label2 = const stability attribute affects this macro\n+\n+expand_macro_body_stability =\n+    macros cannot have body stability attributes\n+    .label = invalid body stability attribute\n+    .label2 = body stability attribute affects this macro\n+\n+expand_resolve_relative_path =\n+    cannot resolve relative path in non-file source `{$path}`\n+\n+expand_attr_no_arguments =\n+    attribute must have either one or two arguments\n+\n+expand_not_a_meta_item =\n+    not a meta item\n+\n+expand_only_one_word =\n+    must only be one word\n+\n+expand_cannot_be_name_of_macro =\n+    `{$trait_ident}` cannot be a name of {$macro_type} macro\n+\n+expand_arg_not_attributes =\n+    second argument must be `attributes`\n+\n+expand_attributes_wrong_form =\n+    attribute must be of form: `attributes(foo, bar)`\n+\n+expand_attribute_meta_item =\n+    attribute must be a meta item, not a literal\n+\n+expand_attribute_single_word =\n+    attribute must only be a single word\n+\n+expand_helper_attribute_name_invalid =\n+    `{$name}` cannot be a name of derive helper attribute\n+\n+expand_expected_comma_in_list =\n+    expected token: `,`\n+\n+expand_only_one_argument =\n+    {$name} takes 1 argument\n+\n+expand_takes_no_arguments =\n+    {$name} takes no arguments\n+\n+expand_feature_included_in_edition =\n+    the feature `{$feature}` is included in the Rust {$edition} edition\n+\n+expand_feature_removed =\n+    feature has been removed\n+    .label = feature has been removed\n+    .reason = {$reason}\n+\n+expand_feature_not_allowed =\n+    the feature `{$name}` is not in the list of allowed features\n+\n+expand_recursion_limit_reached =\n+    recursion limit reached while expanding `{$descr}`\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+expand_malformed_feature_attribute =\n+    malformed `feature` attribute input\n+    .expected = expected just one word\n+\n+expand_remove_expr_not_supported =\n+    removing an expression is not supported in this position\n+\n+expand_invalid_cfg_no_parens = `cfg` is not followed by parentheses\n+expand_invalid_cfg_no_predicate = `cfg` predicate is not specified\n+expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n+expand_invalid_cfg_predicate_literal = `cfg` predicate key cannot be a literal\n+expand_invalid_cfg_expected_syntax = expected syntax is\n+\n+expand_wrong_fragment_kind =\n+    non-{$kind} macro in {$kind} position: {$name}\n+\n+expand_unsupported_key_value =\n+    key-value macro attributes are not supported\n+\n+expand_incomplete_parse =\n+    macro expansion ignores token `{$token}` and any following\n+    .label = caused by the macro expansion here\n+    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n+    .suggestion_add_semi = you might be missing a semicolon here\n+\n+expand_remove_node_not_supported =\n+    removing {$descr} is not supported in this position\n+\n+expand_module_circular =\n+    circular modules: {$modules}\n+\n+expand_module_in_block =\n+    cannot declare a non-inline module inside a block unless it has a path attribute\n+    .note = maybe `use` the module `{$name}` instead of redeclaring it\n+\n+expand_module_file_not_found =\n+    file not found for module `{$name}`\n+    .help = to create the module `{$name}`, create file \"{$default_path}\" or \"{$secondary_path}\"\n+\n+expand_module_multiple_candidates =\n+    file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n+    .help = delete or rename one of them to remove the ambiguity"}, {"sha": "cb39e997436e065948694c1536d35ac1737f3b04", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -152,6 +152,12 @@ impl IntoDiagnosticArg for ast::Path {\n     }\n }\n \n+impl IntoDiagnosticArg for &ast::Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(self)))\n+    }\n+}\n+\n impl IntoDiagnosticArg for ast::token::Token {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(pprust::token_to_string(&self))"}, {"sha": "4df2198fb0e9bc8eaad61d0babc663efe6e6bd72", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 81, "deletions": 59, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -24,7 +24,7 @@ use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::FluentArgs;\n+use rustc_error_messages::{FluentArgs, SpanLabel};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n@@ -773,6 +773,7 @@ impl EmitterWriter {\n         draw_col_separator_no_space(buffer, line_offset, width_offset - 2);\n     }\n \n+    #[instrument(level = \"trace\", skip(self), ret)]\n     fn render_source_line(\n         &self,\n         buffer: &mut StyledBuffer,\n@@ -804,6 +805,7 @@ impl EmitterWriter {\n             Some(s) => normalize_whitespace(&s),\n             None => return Vec::new(),\n         };\n+        trace!(?source_string);\n \n         let line_offset = buffer.num_lines();\n \n@@ -1323,6 +1325,7 @@ impl EmitterWriter {\n         }\n     }\n \n+    #[instrument(level = \"trace\", skip(self, args), ret)]\n     fn emit_message_default(\n         &mut self,\n         msp: &MultiSpan,\n@@ -1384,22 +1387,15 @@ impl EmitterWriter {\n             }\n         }\n         let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n+        trace!(\"{annotated_files:#?}\");\n \n         // Make sure our primary file comes first\n-        let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n-            (self.sm.as_ref(), msp.primary_span().as_ref())\n-        {\n-            if !primary_span.is_dummy() {\n-                (sm.lookup_char_pos(primary_span.lo()), sm)\n-            } else {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n-                return Ok(());\n-            }\n-        } else {\n+        let primary_span = msp.primary_span().unwrap_or_default();\n+        let (Some(sm), false) = (self.sm.as_ref(), primary_span.is_dummy()) else {\n             // If we don't have span information, emit and exit\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n-            return Ok(());\n+            return emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message);\n         };\n+        let primary_lo = sm.lookup_char_pos(primary_span.lo());\n         if let Ok(pos) =\n             annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n         {\n@@ -1410,6 +1406,54 @@ impl EmitterWriter {\n         for annotated_file in annotated_files {\n             // we can't annotate anything if the source is unavailable.\n             if !sm.ensure_source_file_source_present(annotated_file.file.clone()) {\n+                if !self.short_message {\n+                    // We'll just print an unannotated message.\n+                    for (annotation_id, line) in annotated_file.lines.into_iter().enumerate() {\n+                        let mut annotations = line.annotations.clone();\n+                        annotations.sort_by_key(|a| Reverse(a.start_col));\n+                        let mut line_idx = buffer.num_lines();\n+                        buffer.append(\n+                            line_idx,\n+                            &format!(\n+                                \"{}:{}:{}\",\n+                                sm.filename_for_diagnostics(&annotated_file.file.name),\n+                                sm.doctest_offset_line(&annotated_file.file.name, line.line_index),\n+                                annotations[0].start_col + 1,\n+                            ),\n+                            Style::LineAndColumn,\n+                        );\n+                        if annotation_id == 0 {\n+                            buffer.prepend(line_idx, \"--> \", Style::LineNumber);\n+                            for _ in 0..max_line_num_len {\n+                                buffer.prepend(line_idx, \" \", Style::NoStyle);\n+                            }\n+                            line_idx += 1;\n+                        };\n+                        for (i, annotation) in annotations.into_iter().enumerate() {\n+                            if let Some(label) = &annotation.label {\n+                                let style = if annotation.is_primary {\n+                                    Style::LabelPrimary\n+                                } else {\n+                                    Style::LabelSecondary\n+                                };\n+                                if annotation_id == 0 {\n+                                    buffer.prepend(line_idx, \" |\", Style::LineNumber);\n+                                    for _ in 0..max_line_num_len {\n+                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n+                                    }\n+                                    line_idx += 1;\n+                                    buffer.append(line_idx + i, \" = note: \", style);\n+                                    for _ in 0..max_line_num_len {\n+                                        buffer.prepend(line_idx, \" \", Style::NoStyle);\n+                                    }\n+                                } else {\n+                                    buffer.append(line_idx + i, \": \", style);\n+                                }\n+                                buffer.append(line_idx + i, label, style);\n+                            }\n+                        }\n+                    }\n+                }\n                 continue;\n             }\n \n@@ -1656,6 +1700,7 @@ impl EmitterWriter {\n                     multilines.extend(&to_add);\n                 }\n             }\n+            trace!(\"buffer: {:#?}\", buffer.render());\n         }\n \n         if let Some(tracked) = emitted_at {\n@@ -1979,6 +2024,7 @@ impl EmitterWriter {\n         Ok(())\n     }\n \n+    #[instrument(level = \"trace\", skip(self, args, code, children, suggestions))]\n     fn emit_messages_default(\n         &mut self,\n         level: &Level,\n@@ -2209,46 +2255,28 @@ impl FileWithAnnotatedLines {\n         let mut multiline_annotations = vec![];\n \n         if let Some(ref sm) = emitter.source_map() {\n-            for span_label in msp.span_labels() {\n-                let fixup_lo_hi = |span: Span| {\n-                    let lo = sm.lookup_char_pos(span.lo());\n-                    let mut hi = sm.lookup_char_pos(span.hi());\n-\n-                    // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                    // want to just display a `^` at 6, so convert that to\n-                    // 6..7. This is degenerate input, but it's best to degrade\n-                    // gracefully -- and the parser likes to supply a span like\n-                    // that for EOF, in particular.\n-\n-                    if lo.col_display == hi.col_display && lo.line == hi.line {\n-                        hi.col_display += 1;\n-                    }\n-                    (lo, hi)\n+            for SpanLabel { span, is_primary, label } in msp.span_labels() {\n+                // If we don't have a useful span, pick the primary span if that exists.\n+                // Worst case we'll just print an error at the top of the main file.\n+                let span = match (span.is_dummy(), msp.primary_span()) {\n+                    (_, None) | (false, _) => span,\n+                    (true, Some(span)) => span,\n                 };\n \n-                if span_label.span.is_dummy() {\n-                    if let Some(span) = msp.primary_span() {\n-                        // if we don't know where to render the annotation, emit it as a note\n-                        // on the primary span.\n-\n-                        let (lo, hi) = fixup_lo_hi(span);\n-\n-                        let ann = Annotation {\n-                            start_col: lo.col_display,\n-                            end_col: hi.col_display,\n-                            is_primary: span_label.is_primary,\n-                            label: span_label\n-                                .label\n-                                .as_ref()\n-                                .map(|m| emitter.translate_message(m, args).to_string()),\n-                            annotation_type: AnnotationType::Singleline,\n-                        };\n-                        add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n-                    }\n-                    continue;\n+                let lo = sm.lookup_char_pos(span.lo());\n+                let mut hi = sm.lookup_char_pos(span.hi());\n+\n+                // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                // want to just display a `^` at 6, so convert that to\n+                // 6..7. This is degenerate input, but it's best to degrade\n+                // gracefully -- and the parser likes to supply a span like\n+                // that for EOF, in particular.\n+\n+                if lo.col_display == hi.col_display && lo.line == hi.line {\n+                    hi.col_display += 1;\n                 }\n \n-                let (lo, hi) = fixup_lo_hi(span_label.span);\n+                let label = label.as_ref().map(|m| emitter.translate_message(m, args).to_string());\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {\n@@ -2257,23 +2285,17 @@ impl FileWithAnnotatedLines {\n                         line_end: hi.line,\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n-                        is_primary: span_label.is_primary,\n-                        label: span_label\n-                            .label\n-                            .as_ref()\n-                            .map(|m| emitter.translate_message(m, args).to_string()),\n+                        is_primary,\n+                        label,\n                         overlaps_exactly: false,\n                     };\n                     multiline_annotations.push((lo.file, ml));\n                 } else {\n                     let ann = Annotation {\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n-                        is_primary: span_label.is_primary,\n-                        label: span_label\n-                            .label\n-                            .as_ref()\n-                            .map(|m| emitter.translate_message(m, args).to_string()),\n+                        is_primary,\n+                        label,\n                         annotation_type: AnnotationType::Singleline,\n                     };\n                     add_annotation_to_file(&mut output, lo.file, lo.line, ann);"}, {"sha": "6f159663e80cfffd37e1be7866b7bdca8d78a694", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,3 +1,11 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+\n+use crate::errors::{\n+    ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n+    AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n+    MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n+    ResolveRelativePath, TakesNoArguments,\n+};\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n@@ -789,26 +797,16 @@ impl SyntaxExtension {\n             .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp, \"macros cannot have const stability attributes\")\n-                .span_label(sp, \"invalid const stability attribute\")\n-                .span_label(\n-                    sess.source_map().guess_head_span(span),\n-                    \"const stability attribute affects this macro\",\n-                )\n-                .emit();\n+            sess.emit_err(MacroConstStability {\n+                span: sp,\n+                head_span: sess.source_map().guess_head_span(span),\n+            });\n         }\n         if let Some((_, sp)) = body_stability {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp, \"macros cannot have body stability attributes\")\n-                .span_label(sp, \"invalid body stability attribute\")\n-                .span_label(\n-                    sess.source_map().guess_head_span(span),\n-                    \"body stability attribute affects this macro\",\n-                )\n-                .emit();\n+            sess.emit_err(MacroBodyStability {\n+                span: sp,\n+                head_span: sess.source_map().guess_head_span(span),\n+            });\n         }\n \n         SyntaxExtension {\n@@ -1200,13 +1198,11 @@ pub fn resolve_path(\n                 .expect(\"attempting to resolve a file path in an external file\"),\n             FileName::DocTest(path, _) => path,\n             other => {\n-                return Err(parse_sess.span_diagnostic.struct_span_err(\n+                return Err(ResolveRelativePath {\n                     span,\n-                    &format!(\n-                        \"cannot resolve relative path in non-file source `{}`\",\n-                        parse_sess.source_map().filename_for_diagnostics(&other)\n-                    ),\n-                ));\n+                    path: parse_sess.source_map().filename_for_diagnostics(&other).to_string(),\n+                }\n+                .into_diagnostic(&parse_sess.span_diagnostic));\n             }\n         };\n         result.pop();\n@@ -1222,6 +1218,8 @@ pub fn resolve_path(\n /// The returned bool indicates whether an applicable suggestion has already been\n /// added to the diagnostic to avoid emitting multiple suggestions. `Err(None)`\n /// indicates that an ast error was encountered.\n+// FIXME(Nilstrieb) Make this function setup translatable\n+#[allow(rustc::untranslatable_diagnostic)]\n pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n     expr: P<ast::Expr>,\n@@ -1280,9 +1278,9 @@ pub fn expr_to_string(\n /// compilation should call\n /// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n /// done as rarely as possible).\n-pub fn check_zero_tts(cx: &ExtCtxt<'_>, sp: Span, tts: TokenStream, name: &str) {\n+pub fn check_zero_tts(cx: &ExtCtxt<'_>, span: Span, tts: TokenStream, name: &str) {\n     if !tts.is_empty() {\n-        cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n+        cx.emit_err(TakesNoArguments { span, name });\n     }\n }\n \n@@ -1304,31 +1302,27 @@ pub fn parse_expr(p: &mut parser::Parser<'_>) -> Option<P<ast::Expr>> {\n /// expect exactly one string literal, or emit an error and return `None`.\n pub fn get_single_str_from_tts(\n     cx: &mut ExtCtxt<'_>,\n-    sp: Span,\n+    span: Span,\n     tts: TokenStream,\n     name: &str,\n ) -> Option<Symbol> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n+        cx.emit_err(OnlyOneArgument { span, name });\n         return None;\n     }\n     let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n+        cx.emit_err(OnlyOneArgument { span, name });\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s)\n }\n \n /// Extracts comma-separated expressions from `tts`.\n /// On error, emit it, and return `None`.\n-pub fn get_exprs_from_tts(\n-    cx: &mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Option<Vec<P<ast::Expr>>> {\n+pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>, tts: TokenStream) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n@@ -1343,7 +1337,7 @@ pub fn get_exprs_from_tts(\n             continue;\n         }\n         if p.token != token::Eof {\n-            cx.span_err(sp, \"expected token: `,`\");\n+            cx.emit_err(ExpectedCommaInList { span: p.token.span });\n             return None;\n         }\n     }\n@@ -1353,64 +1347,58 @@ pub fn get_exprs_from_tts(\n pub fn parse_macro_name_and_helper_attrs(\n     diag: &rustc_errors::Handler,\n     attr: &Attribute,\n-    descr: &str,\n+    macro_type: &str,\n ) -> Option<(Symbol, Vec<Symbol>)> {\n     // Once we've located the `#[proc_macro_derive]` attribute, verify\n     // that it's of the form `#[proc_macro_derive(Foo)]` or\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n     let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n-        diag.span_err(attr.span, \"attribute must have either one or two arguments\");\n+        diag.emit_err(AttrNoArguments { span: attr.span });\n         return None;\n     }\n     let Some(trait_attr) = list[0].meta_item() else {\n-        diag.span_err(list[0].span(), \"not a meta item\");\n+        diag.emit_err(NotAMetaItem {span: list[0].span()});\n         return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n         _ => {\n-            diag.span_err(trait_attr.span, \"must only be one word\");\n+            diag.emit_err(OnlyOneWord { span: trait_attr.span });\n             return None;\n         }\n     };\n \n     if !trait_ident.name.can_be_raw() {\n-        diag.span_err(\n-            trait_attr.span,\n-            &format!(\"`{}` cannot be a name of {} macro\", trait_ident, descr),\n-        );\n+        diag.emit_err(CannotBeNameOfMacro { span: trait_attr.span, trait_ident, macro_type });\n     }\n \n     let attributes_attr = list.get(1);\n     let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n         if !attr.has_name(sym::attributes) {\n-            diag.span_err(attr.span(), \"second argument must be `attributes`\");\n+            diag.emit_err(ArgumentNotAttributes { span: attr.span() });\n         }\n         attr.meta_item_list()\n             .unwrap_or_else(|| {\n-                diag.span_err(attr.span(), \"attribute must be of form: `attributes(foo, bar)`\");\n+                diag.emit_err(AttributesWrongForm { span: attr.span() });\n                 &[]\n             })\n             .iter()\n             .filter_map(|attr| {\n                 let Some(attr) = attr.meta_item() else {\n-                    diag.span_err(attr.span(), \"not a meta item\");\n+                    diag.emit_err(AttributeMetaItem { span: attr.span() });\n                     return None;\n                 };\n \n                 let ident = match attr.ident() {\n                     Some(ident) if attr.is_word() => ident,\n                     _ => {\n-                        diag.span_err(attr.span, \"must only be one word\");\n+                        diag.emit_err(AttributeSingleWord { span: attr.span });\n                         return None;\n                     }\n                 };\n                 if !ident.name.can_be_raw() {\n-                    diag.span_err(\n-                        attr.span,\n-                        &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n-                    );\n+                    diag.emit_err(HelperAttributeNameInvalid { span: attr.span, name: ident });\n                 }\n \n                 Some(ident.name)"}, {"sha": "f4c6f3386ade23ce244e629ce715ce72a37d83e7", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,5 +1,9 @@\n //! Conditional compilation stripping.\n \n+use crate::errors::{\n+    FeatureIncludedInEdition, FeatureNotAllowed, FeatureRemoved, FeatureRemovedReason, InvalidCfg,\n+    MalformedFeatureAttribute, MalformedFeatureAttributeHelp, RemoveExprNotSupported,\n+};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrTokenStream, AttrTokenTree};\n@@ -10,7 +14,6 @@ use rustc_ast::{self as ast, AttrStyle, Attribute, HasAttrs, HasTokens, MetaItem\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n@@ -33,18 +36,12 @@ pub struct StripUnconfigured<'a> {\n     pub lint_node_id: NodeId,\n }\n \n-fn get_features(\n-    sess: &Session,\n-    span_handler: &Handler,\n-    krate_attrs: &[ast::Attribute],\n-) -> Features {\n-    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n-        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n-        err.span_label(span, \"feature has been removed\");\n-        if let Some(reason) = reason {\n-            err.note(reason);\n-        }\n-        err.emit();\n+fn get_features(sess: &Session, krate_attrs: &[ast::Attribute]) -> Features {\n+    fn feature_removed(sess: &Session, span: Span, reason: Option<&str>) {\n+        sess.emit_err(FeatureRemoved {\n+            span,\n+            reason: reason.map(|reason| FeatureRemovedReason { reason }),\n+        });\n     }\n \n     fn active_features_up_to(edition: Edition) -> impl Iterator<Item = &'static Feature> {\n@@ -117,34 +114,34 @@ fn get_features(\n             continue;\n         };\n \n-        let bad_input = |span| {\n-            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n-        };\n-\n         for mi in list {\n             let name = match mi.ident() {\n                 Some(ident) if mi.is_word() => ident.name,\n                 Some(ident) => {\n-                    bad_input(mi.span())\n-                        .span_suggestion(\n-                            mi.span(),\n-                            \"expected just one word\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    sess.emit_err(MalformedFeatureAttribute {\n+                        span: mi.span(),\n+                        help: MalformedFeatureAttributeHelp::Suggestion {\n+                            span: mi.span(),\n+                            suggestion: ident.name,\n+                        },\n+                    });\n                     continue;\n                 }\n                 None => {\n-                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    sess.emit_err(MalformedFeatureAttribute {\n+                        span: mi.span(),\n+                        help: MalformedFeatureAttributeHelp::Label { span: mi.span() },\n+                    });\n                     continue;\n                 }\n             };\n \n-            if let Some(edition) = edition_enabled_features.get(&name) {\n-                let msg =\n-                    &format!(\"the feature `{}` is included in the Rust {} edition\", name, edition);\n-                span_handler.struct_span_warn_with_code(mi.span(), msg, error_code!(E0705)).emit();\n+            if let Some(&edition) = edition_enabled_features.get(&name) {\n+                sess.emit_warning(FeatureIncludedInEdition {\n+                    span: mi.span(),\n+                    feature: name,\n+                    edition,\n+                });\n                 continue;\n             }\n \n@@ -159,7 +156,7 @@ fn get_features(\n                 if let FeatureState::Removed { reason } | FeatureState::Stabilized { reason } =\n                     state\n                 {\n-                    feature_removed(span_handler, mi.span(), *reason);\n+                    feature_removed(sess, mi.span(), *reason);\n                     continue;\n                 }\n             }\n@@ -173,14 +170,7 @@ fn get_features(\n \n             if let Some(allowed) = sess.opts.unstable_opts.allow_features.as_ref() {\n                 if allowed.iter().all(|f| name.as_str() != f) {\n-                    struct_span_err!(\n-                        span_handler,\n-                        mi.span(),\n-                        E0725,\n-                        \"the feature `{}` is not in the list of allowed features\",\n-                        name\n-                    )\n-                    .emit();\n+                    sess.emit_err(FeatureNotAllowed { span: mi.span(), name });\n                     continue;\n                 }\n             }\n@@ -221,7 +211,7 @@ pub fn features(\n         }\n         Some(attrs) => {\n             krate.attrs = attrs;\n-            let features = get_features(sess, diag, &krate.attrs);\n+            let features = get_features(sess, &krate.attrs);\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n@@ -503,8 +493,7 @@ impl<'a> StripUnconfigured<'a> {\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(*a)) {\n-            let msg = \"removing an expression is not supported in this position\";\n-            self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n+            self.sess.emit_err(RemoveExprNotSupported { span: attr.span });\n         }\n \n         self.process_cfg_attrs(expr);\n@@ -513,27 +502,26 @@ impl<'a> StripUnconfigured<'a> {\n }\n \n pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a MetaItem> {\n-    let error = |span, msg, suggestion: &str| {\n-        let mut err = sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n-        if !suggestion.is_empty() {\n-            err.span_suggestion(\n-                span,\n-                \"expected syntax is\",\n-                suggestion,\n-                Applicability::HasPlaceholders,\n-            );\n-        }\n-        err.emit();\n-        None\n-    };\n     let span = meta_item.span;\n     match meta_item.meta_item_list() {\n-        None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n-        Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n-        Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+        None => {\n+            sess.emit_err(InvalidCfg::NotFollowedByParens { span });\n+            None\n+        }\n+        Some([]) => {\n+            sess.emit_err(InvalidCfg::NoPredicate { span });\n+            None\n+        }\n+        Some([_, .., l]) => {\n+            sess.emit_err(InvalidCfg::MultiplePredicates { span: l.span() });\n+            None\n+        }\n         Some([single]) => match single.meta_item() {\n             Some(meta_item) => Some(meta_item),\n-            None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+            None => {\n+                sess.emit_err(InvalidCfg::PredicateLiteral { span: single.span() });\n+                None\n+            }\n         },\n     }\n }"}, {"sha": "afe5169d3f5c0b616754ddf8ac7fa80ebd12b894", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 324, "deletions": 2, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,6 +1,10 @@\n+use rustc_ast::ast;\n use rustc_macros::Diagnostic;\n-use rustc_span::symbol::MacroRulesNormalizedIdent;\n-use rustc_span::Span;\n+use rustc_session::Limit;\n+use rustc_span::edition::Edition;\n+use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent};\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n \n #[derive(Diagnostic)]\n #[diag(expand_expr_repeat_no_syntax_vars)]\n@@ -46,3 +50,321 @@ pub(crate) struct MetaVarsDifSeqMatchers {\n     pub span: Span,\n     pub msg: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_resolve_relative_path)]\n+pub(crate) struct ResolveRelativePath {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_macro_const_stability)]\n+pub(crate) struct MacroConstStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(label2)]\n+    pub head_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_macro_body_stability)]\n+pub(crate) struct MacroBodyStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(label2)]\n+    pub head_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attr_no_arguments)]\n+pub(crate) struct AttrNoArguments {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_not_a_meta_item)]\n+pub(crate) struct NotAMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_only_one_word)]\n+pub(crate) struct OnlyOneWord {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_cannot_be_name_of_macro)]\n+pub(crate) struct CannotBeNameOfMacro<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub trait_ident: Ident,\n+    pub macro_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_arg_not_attributes)]\n+pub(crate) struct ArgumentNotAttributes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attributes_wrong_form)]\n+pub(crate) struct AttributesWrongForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attribute_meta_item)]\n+pub(crate) struct AttributeMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attribute_single_word)]\n+pub(crate) struct AttributeSingleWord {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_helper_attribute_name_invalid)]\n+pub(crate) struct HelperAttributeNameInvalid {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_expected_comma_in_list)]\n+pub(crate) struct ExpectedCommaInList {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_only_one_argument)]\n+pub(crate) struct OnlyOneArgument<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_takes_no_arguments)]\n+pub(crate) struct TakesNoArguments<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_included_in_edition, code = \"E0705\")]\n+pub(crate) struct FeatureIncludedInEdition {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub edition: Edition,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_removed, code = \"E0557\")]\n+pub(crate) struct FeatureRemoved<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: Option<FeatureRemovedReason<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(reason)]\n+pub(crate) struct FeatureRemovedReason<'a> {\n+    pub reason: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_not_allowed, code = \"E0725\")]\n+pub(crate) struct FeatureNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_recursion_limit_reached)]\n+#[help]\n+pub(crate) struct RecursionLimitReached<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: String,\n+    pub suggested_limit: Limit,\n+    pub crate_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_malformed_feature_attribute, code = \"E0556\")]\n+pub(crate) struct MalformedFeatureAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub help: MalformedFeatureAttributeHelp,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MalformedFeatureAttributeHelp {\n+    #[label(expected)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(expected, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion: Symbol,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_remove_expr_not_supported)]\n+pub(crate) struct RemoveExprNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum InvalidCfg {\n+    #[diag(expand_invalid_cfg_no_parens)]\n+    NotFollowedByParens {\n+        #[primary_span]\n+        #[suggestion(\n+            expand_invalid_cfg_expected_syntax,\n+            code = \"cfg(/* predicate */)\",\n+            applicability = \"has-placeholders\"\n+        )]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_no_predicate)]\n+    NoPredicate {\n+        #[primary_span]\n+        #[suggestion(\n+            expand_invalid_cfg_expected_syntax,\n+            code = \"cfg(/* predicate */)\",\n+            applicability = \"has-placeholders\"\n+        )]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_multiple_predicates)]\n+    MultiplePredicates {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_predicate_literal)]\n+    PredicateLiteral {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_wrong_fragment_kind)]\n+pub(crate) struct WrongFragmentKind<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'a str,\n+    pub name: &'a ast::Path,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_unsupported_key_value)]\n+pub(crate) struct UnsupportedKeyValue {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_incomplete_parse)]\n+#[note]\n+pub(crate) struct IncompleteParse<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub token: Cow<'a, str>,\n+    #[label]\n+    pub label_span: Span,\n+    pub macro_path: &'a ast::Path,\n+    pub kind_name: &'a str,\n+\n+    #[suggestion(\n+        suggestion_add_semi,\n+        style = \"verbose\",\n+        code = \";\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub add_semicolon: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_remove_node_not_supported)]\n+pub(crate) struct RemoveNodeNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_circular)]\n+pub(crate) struct ModuleCircular {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modules: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_in_block)]\n+pub(crate) struct ModuleInBlock {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub name: Option<ModuleInBlockName>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(note)]\n+pub(crate) struct ModuleInBlockName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_file_not_found, code = \"E0583\")]\n+#[help]\n+pub(crate) struct ModuleFileNotFound {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+    pub default_path: String,\n+    pub secondary_path: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_multiple_candidates, code = \"E0761\")]\n+#[help]\n+pub(crate) struct ModuleMultipleCandidates {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+    pub default_path: String,\n+    pub secondary_path: String,\n+}"}, {"sha": "e26c16dcd7ee7784e4597cddbb6f073c9ea56657", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,5 +1,9 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n+use crate::errors::{\n+    IncompleteParse, RecursionLimitReached, RemoveExprNotSupported, RemoveNodeNotSupported,\n+    UnsupportedKeyValue, WrongFragmentKind,\n+};\n use crate::hygiene::SyntaxContext;\n use crate::mbe::diagnostics::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n@@ -18,7 +22,7 @@ use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::PResult;\n use rustc_feature::Features;\n use rustc_parse::parser::{\n     AttemptLocalParseRecovery, CommaRecoveryMode, ForceCollect, Parser, RecoverColon, RecoverComma,\n@@ -606,29 +610,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Limit(0) => Limit(2),\n             limit => limit * 2,\n         };\n-        self.cx\n-            .struct_span_err(\n-                expn_data.call_site,\n-                &format!(\"recursion limit reached while expanding `{}`\", expn_data.kind.descr()),\n-            )\n-            .help(&format!(\n-                \"consider increasing the recursion limit by adding a \\\n-                 `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n-                suggested_limit, self.cx.ecfg.crate_name,\n-            ))\n-            .emit();\n+\n+        self.cx.emit_err(RecursionLimitReached {\n+            span: expn_data.call_site,\n+            descr: expn_data.kind.descr(),\n+            suggested_limit,\n+            crate_name: &self.cx.ecfg.crate_name,\n+        });\n+\n         self.cx.trace_macros_diag();\n     }\n \n     /// A macro's expansion does not fit in this fragment kind.\n     /// For example, a non-type macro in a type position.\n     fn error_wrong_fragment_kind(&mut self, kind: AstFragmentKind, mac: &ast::MacCall, span: Span) {\n-        let msg = format!(\n-            \"non-{kind} macro in {kind} position: {path}\",\n-            kind = kind.name(),\n-            path = pprust::path_to_string(&mac.path),\n-        );\n-        self.cx.span_err(span, &msg);\n+        self.cx.emit_err(WrongFragmentKind { span, kind: kind.name(), name: &mac.path });\n+\n         self.cx.trace_macros_diag();\n     }\n \n@@ -707,7 +704,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let AttrArgs::Eq(..) = attr_item.args {\n-                        self.cx.span_err(span, \"key-value macro attributes are not supported\");\n+                        self.cx.emit_err(UnsupportedKeyValue { span });\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();\n                     let Ok(tok_result) = expander.expand(self.cx, span, inner_tokens, tokens) else {\n@@ -729,9 +726,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 }\n                             };\n                             if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n-                                let msg =\n-                                    \"removing an expression is not supported in this position\";\n-                                self.cx.span_err(span, msg);\n+                                self.cx.emit_err(RemoveExprNotSupported { span });\n                                 fragment_kind.dummy(span)\n                             } else {\n                                 fragment_kind.expect_from_annotatables(items)\n@@ -939,38 +934,32 @@ pub fn parse_ast_fragment<'a>(\n }\n \n pub fn ensure_complete_parse<'a>(\n-    this: &mut Parser<'a>,\n+    parser: &mut Parser<'a>,\n     macro_path: &ast::Path,\n     kind_name: &str,\n     span: Span,\n ) {\n-    if this.token != token::Eof {\n-        let token = pprust::token_to_string(&this.token);\n-        let msg = format!(\"macro expansion ignores token `{}` and any following\", token);\n+    if parser.token != token::Eof {\n+        let token = pprust::token_to_string(&parser.token);\n         // Avoid emitting backtrace info twice.\n-        let def_site_span = this.token.span.with_ctxt(SyntaxContext::root());\n-        let mut err = this.struct_span_err(def_site_span, &msg);\n-        err.span_label(span, \"caused by the macro expansion here\");\n-        let msg = format!(\n-            \"the usage of `{}!` is likely invalid in {} context\",\n-            pprust::path_to_string(macro_path),\n-            kind_name,\n-        );\n-        err.note(&msg);\n+        let def_site_span = parser.token.span.with_ctxt(SyntaxContext::root());\n \n-        let semi_span = this.sess.source_map().next_point(span);\n-        match this.sess.source_map().span_to_snippet(semi_span) {\n+        let semi_span = parser.sess.source_map().next_point(span);\n+        let add_semicolon = match parser.sess.source_map().span_to_snippet(semi_span) {\n             Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n-                err.span_suggestion(\n-                    span.shrink_to_hi(),\n-                    \"you might be missing a semicolon here\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                Some(span.shrink_to_hi())\n             }\n-            _ => {}\n-        }\n-        err.emit();\n+            _ => None,\n+        };\n+\n+        parser.sess.emit_err(IncompleteParse {\n+            span: def_site_span,\n+            token,\n+            label_span: span,\n+            macro_path,\n+            kind_name,\n+            add_semicolon,\n+        });\n     }\n }\n \n@@ -1766,9 +1755,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         if self.expand_cfg_true(node, attr, pos) {\n                             continue;\n                         }\n-                        let msg =\n-                            format!(\"removing {} is not supported in this position\", Node::descr());\n-                        self.cx.span_err(span, &msg);\n+\n+                        self.cx.emit_err(RemoveNodeNotSupported { span, descr: Node::descr() });\n                         continue;\n                     }\n                     sym::cfg_attr => {"}, {"sha": "897268566358a5b0fae9d68c08e4c6655a3e57b5", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -10,6 +10,7 @@\n #![feature(rustc_attrs)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -31,8 +32,13 @@ pub mod config;\n pub mod errors;\n pub mod expand;\n pub mod module;\n+\n+// FIXME(Nilstrieb) Translate proc_macro diagnostics\n+#[allow(rustc::untranslatable_diagnostic)]\n pub mod proc_macro;\n \n+// FIXME(Nilstrieb) Translate macro_rules diagnostics\n+#[allow(rustc::untranslatable_diagnostic)]\n pub(crate) mod mbe;\n \n // HACK(Centril, #64197): These shouldn't really be here."}, {"sha": "07f47a9c3a4f2c80f9097d22e55b2581440f5135", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,13 +1,17 @@\n use crate::base::ModuleData;\n+use crate::errors::{\n+    ModuleCircular, ModuleFileNotFound, ModuleInBlock, ModuleInBlockName, ModuleMultipleCandidates,\n+};\n use rustc_ast::ptr::P;\n use rustc_ast::{token, AttrVec, Attribute, Inline, Item, ModSpans};\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_parse::new_parser_from_file;\n use rustc_parse::validate_attr;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use std::iter::once;\n \n use std::path::{self, Path, PathBuf};\n \n@@ -242,57 +246,41 @@ pub fn default_submod_path<'a>(\n \n impl ModError<'_> {\n     fn report(self, sess: &Session, span: Span) -> ErrorGuaranteed {\n-        let diag = &sess.parse_sess.span_diagnostic;\n         match self {\n             ModError::CircularInclusion(file_paths) => {\n-                let mut msg = String::from(\"circular modules: \");\n-                for file_path in &file_paths {\n-                    msg.push_str(&file_path.display().to_string());\n-                    msg.push_str(\" -> \");\n-                }\n-                msg.push_str(&file_paths[0].display().to_string());\n-                diag.struct_span_err(span, &msg)\n-            }\n-            ModError::ModInBlock(ident) => {\n-                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n-                let mut err = diag.struct_span_err(span, msg);\n-                if let Some(ident) = ident {\n-                    let note =\n-                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n-                    err.span_note(span, &note);\n-                }\n-                err\n+                let path_to_string = |path: &PathBuf| path.display().to_string();\n+\n+                let paths = file_paths\n+                    .iter()\n+                    .map(path_to_string)\n+                    .chain(once(path_to_string(&file_paths[0])))\n+                    .collect::<Vec<_>>();\n+\n+                let modules = paths.join(\" -> \");\n+\n+                sess.emit_err(ModuleCircular { span, modules })\n             }\n-            ModError::FileNotFound(ident, default_path, secondary_path) => {\n-                let mut err = struct_span_err!(\n-                    diag,\n+            ModError::ModInBlock(ident) => sess.emit_err(ModuleInBlock {\n+                span,\n+                name: ident.map(|name| ModuleInBlockName { span, name }),\n+            }),\n+            ModError::FileNotFound(name, default_path, secondary_path) => {\n+                sess.emit_err(ModuleFileNotFound {\n                     span,\n-                    E0583,\n-                    \"file not found for module `{}`\",\n-                    ident,\n-                );\n-                err.help(&format!(\n-                    \"to create the module `{}`, create file \\\"{}\\\" or \\\"{}\\\"\",\n-                    ident,\n-                    default_path.display(),\n-                    secondary_path.display(),\n-                ));\n-                err\n+                    name,\n+                    default_path: default_path.display().to_string(),\n+                    secondary_path: secondary_path.display().to_string(),\n+                })\n             }\n-            ModError::MultipleCandidates(ident, default_path, secondary_path) => {\n-                let mut err = struct_span_err!(\n-                    diag,\n+            ModError::MultipleCandidates(name, default_path, secondary_path) => {\n+                sess.emit_err(ModuleMultipleCandidates {\n                     span,\n-                    E0761,\n-                    \"file for module `{}` found at both \\\"{}\\\" and \\\"{}\\\"\",\n-                    ident,\n-                    default_path.display(),\n-                    secondary_path.display(),\n-                );\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n+                    name,\n+                    default_path: default_path.display().to_string(),\n+                    secondary_path: secondary_path.display().to_string(),\n+                })\n             }\n-            ModError::ParserError(err) => err,\n-        }.emit()\n+            ModError::ParserError(mut err) => err.emit(),\n+        }\n     }\n }"}, {"sha": "8f3bea29ffd2897ee30178c82969f485fcb9c8b3", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -154,6 +154,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n             false,\n         );\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n+        #[allow(rustc::untranslatable_diagnostic)]\n         handler.span_err(msp, \"foo\");\n \n         assert!("}, {"sha": "6d8e78a0f185dc6a16c577b6bb2a6c386f51389a", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -394,7 +394,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(instruction_set, Normal, template!(List: \"set\"), ErrorPreceding),\n     gated!(\n         no_sanitize, Normal,\n-        template!(List: \"address, memory, thread\"), DuplicatesOk,\n+        template!(List: \"address, kcfi, memory, thread\"), DuplicatesOk,\n         experimental!(no_sanitize)\n     ),\n     gated!(no_coverage, Normal, template!(Word), WarnFollowing, experimental!(no_coverage)),"}, {"sha": "72288e5bc761f0e4ba9566e1f02c4d44d57f5420", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -955,7 +955,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n                     .struct_span_err(\n                         attr.span,\n                         \"the `#[rustc_must_implement_one_of]` attribute must be \\\n-                        used with at least 2 args\",\n+                         used with at least 2 args\",\n                     )\n                     .emit();\n \n@@ -987,7 +987,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n                             tcx.sess\n                                 .struct_span_err(\n                                     item.span,\n-                                    \"This function doesn't have a default implementation\",\n+                                    \"function doesn't have a default implementation\",\n                                 )\n                                 .span_note(attr_span, \"required by this annotation\")\n                                 .emit();\n@@ -999,17 +999,17 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n                     }\n                     Some(item) => {\n                         tcx.sess\n-                            .struct_span_err(item.span, \"Not a function\")\n+                            .struct_span_err(item.span, \"not a function\")\n                             .span_note(attr_span, \"required by this annotation\")\n                             .note(\n-                                \"All `#[rustc_must_implement_one_of]` arguments \\\n-                            must be associated function names\",\n+                                \"all `#[rustc_must_implement_one_of]` arguments must be associated \\\n+                                 function names\",\n                             )\n                             .emit();\n                     }\n                     None => {\n                         tcx.sess\n-                            .struct_span_err(ident.span, \"Function not found in this trait\")\n+                            .struct_span_err(ident.span, \"function not found in this trait\")\n                             .emit();\n                     }\n                 }\n@@ -1027,11 +1027,8 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n             for ident in &*list {\n                 if let Some(dup) = set.insert(ident.name, ident.span) {\n                     tcx.sess\n-                        .struct_span_err(vec![dup, ident.span], \"Functions names are duplicated\")\n-                        .note(\n-                            \"All `#[rustc_must_implement_one_of]` arguments \\\n-                            must be unique\",\n-                        )\n+                        .struct_span_err(vec![dup, ident.span], \"functions names are duplicated\")\n+                        .note(\"all `#[rustc_must_implement_one_of]` arguments must be unique\")\n                         .emit();\n \n                     no_dups = false;\n@@ -1849,6 +1846,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n                     } else if item.has_name(sym::cfi) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                    } else if item.has_name(sym::kcfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n                     } else if item.has_name(sym::memory) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n                     } else if item.has_name(sym::memtag) {\n@@ -1862,7 +1861,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                     } else {\n                         tcx.sess\n                             .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n                             .emit();\n                     }\n                 }"}, {"sha": "cb4c35c0ce177e527e1bab8feba86b319ce53878", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -78,7 +78,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                     let generics = tcx.generics_of(parent_def_id.to_def_id());\n                     let param_def_idx = generics.param_def_id_to_index[&param_id.to_def_id()];\n                     // In the above example this would be .params[..N#0]\n-                    let params = generics.params[..param_def_idx as usize].to_owned();\n+                    let params = generics.params_to(param_def_idx as usize, tcx).to_owned();\n                     let param_def_id_to_index =\n                         params.iter().map(|param| (param.def_id, param.index)).collect();\n "}, {"sha": "6763e06c0cfeed38a2a5c83f7fecb58c47beb825", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        error: Option<TypeError<'_>>,\n+        error: Option<TypeError<'tcx>>,\n     ) {\n         let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n         match (self.tcx.hir().find(parent), error) {\n@@ -286,6 +286,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.downgrade_to_delayed_bug();\n                 }\n             }\n+            (\n+                Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Binary(_, lhs, rhs), ..\n+                })),\n+                Some(TypeError::Sorts(ExpectedFound { expected, .. })),\n+            ) if rhs.hir_id == expr.hir_id\n+                && self.typeck_results.borrow().expr_ty_adjusted_opt(lhs) == Some(expected) =>\n+            {\n+                err.span_label(lhs.span, &format!(\"expected because this is `{expected}`\"));\n+            }\n             _ => {}\n         }\n     }"}, {"sha": "987559d7e47243ead6b12e2762ae7716b0d41010", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 660, "changes": 662, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -56,22 +56,17 @@ use crate::infer::ExpectedFound;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n-use crate::errors::SuggAddLetForLetChains;\n-use hir::intravisit::{walk_expr, walk_stmt};\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n@@ -84,6 +79,7 @@ use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod suggest;\n \n pub(crate) mod need_type_info;\n pub use need_type_info::TypeAnnotationNeeded;\n@@ -807,87 +803,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n-    fn suggest_remove_semi_or_return_binding(\n-        &self,\n-        err: &mut Diagnostic,\n-        first_id: Option<hir::HirId>,\n-        first_ty: Ty<'tcx>,\n-        first_span: Span,\n-        second_id: Option<hir::HirId>,\n-        second_ty: Ty<'tcx>,\n-        second_span: Span,\n-    ) {\n-        let remove_semicolon = [\n-            (first_id, self.resolve_vars_if_possible(second_ty)),\n-            (second_id, self.resolve_vars_if_possible(first_ty)),\n-        ]\n-        .into_iter()\n-        .find_map(|(id, ty)| {\n-            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n-            self.could_remove_semicolon(blk, ty)\n-        });\n-        match remove_semicolon {\n-            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n-                err.multipart_suggestion(\n-                    \"consider removing this semicolon and boxing the expressions\",\n-                    vec![\n-                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (first_span.shrink_to_hi(), \")\".to_string()),\n-                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                        (second_span.shrink_to_hi(), \")\".to_string()),\n-                        (sp, String::new()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            Some((sp, StatementAsExpression::CorrectType)) => {\n-                err.span_suggestion_short(\n-                    sp,\n-                    \"consider removing this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            None => {\n-                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n-                    if let Some(id) = id\n-                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n-                        && self.consider_returning_binding(blk, ty, err)\n-                    {\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn suggest_boxing_for_return_impl_trait(\n-        &self,\n-        err: &mut Diagnostic,\n-        return_sp: Span,\n-        arm_spans: impl Iterator<Item = Span>,\n-    ) {\n-        err.multipart_suggestion(\n-            \"you could change the return type to be a boxed trait object\",\n-            vec![\n-                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n-                (return_sp.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-        let sugg = arm_spans\n-            .flat_map(|sp| {\n-                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n-                    .into_iter()\n-            })\n-            .collect::<Vec<_>>();\n-        err.multipart_suggestion(\n-            \"if you change the return type to expect trait objects, box the returned expressions\",\n-            sugg,\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-\n     /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n     /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n     /// populate `other_value` with `other_ty`.\n@@ -1944,310 +1859,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         debug!(?diag);\n     }\n \n-    fn suggest_tuple_pattern(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n-        // some modifications due to that being in typeck and this being in infer.\n-        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n-            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n-                let compatible_variants: Vec<_> = expected_adt\n-                    .variants()\n-                    .iter()\n-                    .filter(|variant| {\n-                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n-                    })\n-                    .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n-                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n-                            let variant_path =\n-                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n-                            // FIXME #56861: DRYer prelude filtering\n-                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n-                                if let Some((_, path)) = path.split_once(\"::\") {\n-                                    return Some(path.to_string());\n-                                }\n-                            }\n-                            Some(variant_path)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .collect();\n-                match &compatible_variants[..] {\n-                    [] => {}\n-                    [variant] => {\n-                        diag.multipart_suggestion_verbose(\n-                            &format!(\"try wrapping the pattern in `{}`\", variant),\n-                            vec![\n-                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                (cause.span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {\n-                        // More than one matching variant.\n-                        diag.multipart_suggestions(\n-                            &format!(\n-                                \"try wrapping the pattern in a variant of `{}`\",\n-                                self.tcx.def_path_str(expected_adt.did())\n-                            ),\n-                            compatible_variants.into_iter().map(|variant| {\n-                                vec![\n-                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n-                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n-                                ]\n-                            }),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// A possible error is to forget to add `.await` when using futures:\n-    ///\n-    /// ```compile_fail,E0308\n-    /// async fn make_u32() -> u32 {\n-    ///     22\n-    /// }\n-    ///\n-    /// fn take_u32(x: u32) {}\n-    ///\n-    /// async fn foo() {\n-    ///     let x = make_u32();\n-    ///     take_u32(x);\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n-    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n-    /// `.await` to the tail of the expression.\n-    fn suggest_await_on_expect_found(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n-            exp_span, exp_found.expected, exp_found.found,\n-        );\n-\n-        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n-            return;\n-        }\n-\n-        match (\n-            self.get_impl_future_output_ty(exp_found.expected),\n-            self.get_impl_future_output_ty(exp_found.found),\n-        ) {\n-            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n-                .code()\n-            {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.multipart_suggestion(\n-                        \"consider `await`ing on both `Future`s\",\n-                        vec![\n-                            (then_span.shrink_to_hi(), \".await\".to_string()),\n-                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                        ],\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    prior_arms,\n-                    ..\n-                }) => {\n-                    if let [.., arm_span] = &prior_arms[..] {\n-                        diag.multipart_suggestion(\n-                            \"consider `await`ing on both `Future`s\",\n-                            vec![\n-                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n-                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        diag.help(\"consider `await`ing on both `Future`s\");\n-                    }\n-                }\n-                _ => {\n-                    diag.help(\"consider `await`ing on both `Future`s\");\n-                }\n-            },\n-            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n-                diag.span_suggestion_verbose(\n-                    exp_span.shrink_to_hi(),\n-                    \"consider `await`ing on the `Future`\",\n-                    \".await\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n-            {\n-                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n-                    let then_span = self.find_block_span_from_hir_id(*then_id);\n-                    diag.span_suggestion_verbose(\n-                        then_span.shrink_to_hi(),\n-                        \"consider `await`ing on the `Future`\",\n-                        \".await\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                    ref prior_arms,\n-                    ..\n-                }) => {\n-                    diag.multipart_suggestion_verbose(\n-                        \"consider `await`ing on the `Future`\",\n-                        prior_arms\n-                            .iter()\n-                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n-                            .collect(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => {}\n-            },\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_accessing_field_where_appropriate(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        debug!(\n-            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n-            cause, exp_found\n-        );\n-        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n-            if expected_def.is_enum() {\n-                return;\n-            }\n-\n-            if let Some((name, ty)) = expected_def\n-                .non_enum_variant()\n-                .fields\n-                .iter()\n-                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n-                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n-            {\n-                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        let suggestion = if expected_def.is_struct() {\n-                            format!(\"{}.{}\", snippet, name)\n-                        } else if expected_def.is_union() {\n-                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n-                        } else {\n-                            return;\n-                        };\n-                        diag.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"you might have meant to use field `{}` whose type is `{}`\",\n-                                name, ty\n-                            ),\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n-    /// suggests it.\n-    fn suggest_as_ref_where_appropriate(\n-        &self,\n-        span: Span,\n-        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n-        diag: &mut Diagnostic,\n-    ) {\n-        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n-            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n-        {\n-            diag.span_suggestion(\n-                span,\n-                msg,\n-                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n-                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    }\n-\n-    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n-        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (expected.kind(), found.kind())\n-        {\n-            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n-                if exp_def == &found_def {\n-                    let have_as_ref = &[\n-                        (\n-                            sym::Option,\n-                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n-                        `.as_ref()`\",\n-                        ),\n-                        (\n-                            sym::Result,\n-                            \"you can convert from `&Result<T, E>` to \\\n-                        `Result<&T, &E>` using `.as_ref()`\",\n-                        ),\n-                    ];\n-                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n-                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n-                    }) {\n-                        let mut show_suggestion = true;\n-                        for (exp_ty, found_ty) in\n-                            iter::zip(exp_substs.types(), found_substs.types())\n-                        {\n-                            match *exp_ty.kind() {\n-                                ty::Ref(_, exp_ty, _) => {\n-                                    match (exp_ty.kind(), found_ty.kind()) {\n-                                        (_, ty::Param(_))\n-                                        | (_, ty::Infer(_))\n-                                        | (ty::Param(_), _)\n-                                        | (ty::Infer(_), _) => {}\n-                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n-                                        _ => show_suggestion = false,\n-                                    };\n-                                }\n-                                ty::Param(_) | ty::Infer(_) => {}\n-                                _ => show_suggestion = false,\n-                            }\n-                        }\n-                        if show_suggestion {\n-                            return Some(*msg);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n     pub fn report_and_explain_type_error(\n         &self,\n         trace: TypeTrace<'tcx>,\n@@ -2361,67 +1972,6 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag\n     }\n \n-    /// Try to find code with pattern `if Some(..) = expr`\n-    /// use a `visitor` to mark the `if` which its span contains given error span,\n-    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n-    fn suggest_let_for_letchains(\n-        &self,\n-        err: &mut Diagnostic,\n-        cause: &ObligationCause<'_>,\n-        span: Span,\n-    ) {\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.get_parent_node(cause.body_id);\n-        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n-            let hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n-                }) = node {\n-        let body = hir.body(*body_id);\n-\n-        /// Find the if expression with given span\n-        struct IfVisitor {\n-            pub result: bool,\n-            pub found_if: bool,\n-            pub err_span: Span,\n-        }\n-\n-        impl<'v> Visitor<'v> for IfVisitor {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n-                if self.result { return; }\n-                match ex.kind {\n-                    hir::ExprKind::If(cond, _, _) => {\n-                        self.found_if = true;\n-                        walk_expr(self, cond);\n-                        self.found_if = false;\n-                    }\n-                    _ => walk_expr(self, ex),\n-                }\n-            }\n-\n-            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n-                if let hir::StmtKind::Local(hir::Local {\n-                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n-                    }) = &ex.kind\n-                    && self.found_if\n-                    && span.eq(&self.err_span) {\n-                        self.result = true;\n-                }\n-                walk_stmt(self, ex);\n-            }\n-\n-            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n-                hir::intravisit::walk_body(self, body);\n-            }\n-        }\n-\n-        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n-        visitor.visit_body(&body);\n-        if visitor.result {\n-                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n-            }\n-        }\n-    }\n-\n     fn emit_tuple_wrap_err(\n         &self,\n         err: &mut Diagnostic,\n@@ -3253,211 +2803,3 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n-    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n-    /// is enough to fix the error.\n-    pub fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return None;\n-        }\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            _ if last_expr_ty.references_error() => return None,\n-            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => return None,\n-        };\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n-    /// Suggest returning a local binding with a compatible type if the block\n-    /// has no return expression.\n-    pub fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n-        let blk = blk.innermost_block();\n-        // Do not suggest if we have a tail expr.\n-        if blk.expr.is_some() {\n-            return false;\n-        }\n-        let mut shadowed = FxIndexSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self\n-                    .typeck_results\n-                    .as_ref()\n-                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.same_type_modulo_infer(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                true\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-}"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_region.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_region.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,427 @@\n+use crate::errors::RegionOriginNote;\n+use crate::infer::error_reporting::{note_and_explain_region, TypeErrCtxt};\n+use crate::infer::{self, SubregionOrigin};\n+use rustc_errors::{\n+    fluent, struct_span_err, AddToDiagnostic, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::{self, Region};\n+\n+use super::ObligationCauseAsDiagArg;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n+        match *origin {\n+            infer::Subtype(ref trace) => RegionOriginNote::WithRequirement {\n+                span: trace.cause.span,\n+                requirement: ObligationCauseAsDiagArg(trace.cause.clone()),\n+                expected_found: self.values_str(trace.values),\n+            }\n+            .add_to_diagnostic(err),\n+            infer::Reborrow(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reborrow,\n+                    name: &var_name.to_string(),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateObjectBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_data_borrowed,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_reference_outlives_referent,\n+                    name: &self.ty_to_string(ty),\n+                    continues: false,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                RegionOriginNote::WithName {\n+                    span,\n+                    msg: fluent::infer_relate_param_bound,\n+                    name: &self.ty_to_string(ty),\n+                    continues: opt_span.is_some(),\n+                }\n+                .add_to_diagnostic(err);\n+                if let Some(span) = opt_span {\n+                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n+                        .add_to_diagnostic(err);\n+                }\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CompareImplItemObligation { span, .. } => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n+                    .add_to_diagnostic(err);\n+            }\n+            infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n+                self.note_region_origin(err, &parent);\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                RegionOriginNote::Plain {\n+                    span,\n+                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n+                }\n+                .add_to_diagnostic(err);\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_concrete_failure(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        match origin {\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n+                let mut err = self.report_and_explain_type_error(trace, terr);\n+                match (*sub, *sup) {\n+                    (ty::RePlaceholder(_), ty::RePlaceholder(_)) => {}\n+                    (ty::RePlaceholder(_), _) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"\",\n+                            sup,\n+                            \" doesn't meet the lifetime requirements\",\n+                            None,\n+                        );\n+                    }\n+                    (_, ty::RePlaceholder(_)) => {\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"the required lifetime does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                    _ => {\n+                        note_and_explain_region(self.tcx, &mut err, \"\", sup, \"...\", None);\n+                        note_and_explain_region(\n+                            self.tcx,\n+                            &mut err,\n+                            \"...does not necessarily outlive \",\n+                            sub,\n+                            \"\",\n+                            None,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+            infer::Reborrow(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0312,\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the reference is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...but the borrowed content is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0313,\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n+                    var_name\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \", var_name),\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateObjectBound(span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0476,\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"object type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"source pointer is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::RelateParamBound(span, ty, opt_span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0477,\n+                    \"the type `{}` does not fulfill the required lifetime\",\n+                    self.ty_to_string(ty)\n+                );\n+                match *sub {\n+                    ty::ReStatic => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must satisfy \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                    _ => note_and_explain_region(\n+                        self.tcx,\n+                        &mut err,\n+                        \"type must outlive \",\n+                        sub,\n+                        if opt_span.is_some() { \" as required by this binding\" } else { \"\" },\n+                        opt_span,\n+                    ),\n+                }\n+                err\n+            }\n+            infer::RelateRegionParamBound(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime parameter instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime parameter must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::DataBorrowed(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0490,\n+                    \"a value of type `{}` is borrowed for too long\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the type is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the borrow lasts for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::ReferenceOutlivesReferent(ty, span) => {\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0491,\n+                    \"in type `{}`, reference has a longer lifetime than the data it references\",\n+                    self.ty_to_string(ty)\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"the pointer is valid for \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but the referenced data is only valid for \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+            infer::CompareImplItemObligation { span, impl_item_def_id, trait_item_def_id } => self\n+                .report_extra_impl_obligation(\n+                    span,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                    &format!(\"`{}: {}`\", sup, sub),\n+                ),\n+            infer::CheckAssociatedTypeBounds { impl_item_def_id, trait_item_def_id, parent } => {\n+                let mut err = self.report_concrete_failure(*parent, sub, sup);\n+\n+                let trait_item_span = self.tcx.def_span(trait_item_def_id);\n+                let item_name = self.tcx.item_name(impl_item_def_id.to_def_id());\n+                err.span_label(\n+                    trait_item_span,\n+                    format!(\"definition of `{}` from trait\", item_name),\n+                );\n+\n+                let trait_predicates = self.tcx.explicit_predicates_of(trait_item_def_id);\n+                let impl_predicates = self.tcx.explicit_predicates_of(impl_item_def_id);\n+\n+                let impl_predicates: rustc_data_structures::fx::FxHashSet<_> =\n+                    impl_predicates.predicates.into_iter().map(|(pred, _)| pred).collect();\n+                let clauses: Vec<_> = trait_predicates\n+                    .predicates\n+                    .into_iter()\n+                    .filter(|&(pred, _)| !impl_predicates.contains(pred))\n+                    .map(|(pred, _)| format!(\"{}\", pred))\n+                    .collect();\n+\n+                if !clauses.is_empty() {\n+                    let generics = self.tcx.hir().get_generics(impl_item_def_id).unwrap();\n+                    let where_clause_span = generics.tail_span_for_predicate_suggestion();\n+\n+                    let suggestion = format!(\n+                        \"{} {}\",\n+                        generics.add_where_or_trailing_comma(),\n+                        clauses.join(\", \"),\n+                    );\n+                    err.span_suggestion(\n+                        where_clause_span,\n+                        &format!(\n+                            \"try copying {} from the trait\",\n+                            if clauses.len() > 1 { \"these clauses\" } else { \"this clause\" }\n+                        ),\n+                        suggestion,\n+                        rustc_errors::Applicability::MaybeIncorrect,\n+                    );\n+                }\n+\n+                err\n+            }\n+            infer::AscribeUserTypeProvePredicate(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"lifetime instantiated with \",\n+                    sup,\n+                    \"\",\n+                    None,\n+                );\n+                note_and_explain_region(\n+                    self.tcx,\n+                    &mut err,\n+                    \"but lifetime must outlive \",\n+                    sub,\n+                    \"\",\n+                    None,\n+                );\n+                err\n+            }\n+        }\n+    }\n+\n+    pub(super) fn report_placeholder_failure(\n+        &self,\n+        placeholder_origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        // I can't think how to do better than this right now. -nikomatsakis\n+        debug!(?placeholder_origin, ?sub, ?sup, \"report_placeholder_failure\");\n+        match placeholder_origin {\n+            infer::Subtype(box ref trace)\n+                if matches!(\n+                    &trace.cause.code().peel_derives(),\n+                    ObligationCauseCode::BindingObligation(..)\n+                        | ObligationCauseCode::ExprBindingObligation(..)\n+                ) =>\n+            {\n+                // Hack to get around the borrow checker because trace.cause has an `Rc`.\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..) =\n+                    &trace.cause.code().peel_derives()\n+                {\n+                    let span = *span;\n+                    let mut err = self.report_concrete_failure(placeholder_origin, sub, sup);\n+                    err.span_note(span, \"the lifetime requirement is introduced here\");\n+                    err\n+                } else {\n+                    unreachable!()\n+                }\n+            }\n+            infer::Subtype(box trace) => {\n+                let terr = TypeError::RegionsPlaceholderMismatch;\n+                return self.report_and_explain_type_error(trace, terr);\n+            }\n+            _ => return self.report_concrete_failure(placeholder_origin, sub, sup),\n+        }\n+    }\n+}"}, {"sha": "73b5a2cc4ad233e6ba2c5a1b1750916e3dfc55b0", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "added", "additions": 672, "deletions": 0, "changes": 672, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,672 @@\n+use hir::def::CtorKind;\n+use hir::intravisit::{walk_expr, walk_stmt, Visitor};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::{Applicability, Diagnostic};\n+use rustc_hir as hir;\n+use rustc_middle::traits::{\n+    IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n+    StatementAsExpression,\n+};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self as ty, Ty, TypeVisitable};\n+use rustc_span::{sym, BytePos, Span};\n+\n+use crate::errors::SuggAddLetForLetChains;\n+\n+use super::TypeErrCtxt;\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub(super) fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let remove_semicolon = [\n+            (first_id, self.resolve_vars_if_possible(second_ty)),\n+            (second_id, self.resolve_vars_if_possible(first_ty)),\n+        ]\n+        .into_iter()\n+        .find_map(|(id, ty)| {\n+            let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+            self.could_remove_semicolon(blk, ty)\n+        });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(super) fn suggest_boxing_for_return_impl_trait(\n+        &self,\n+        err: &mut Diagnostic,\n+        return_sp: Span,\n+        arm_spans: impl Iterator<Item = Span>,\n+    ) {\n+        err.multipart_suggestion(\n+            \"you could change the return type to be a boxed trait object\",\n+            vec![\n+                (return_sp.with_hi(return_sp.lo() + BytePos(4)), \"Box<dyn\".to_string()),\n+                (return_sp.shrink_to_hi(), \">\".to_string()),\n+            ],\n+            Applicability::MaybeIncorrect,\n+        );\n+        let sugg = arm_spans\n+            .flat_map(|sp| {\n+                [(sp.shrink_to_lo(), \"Box::new(\".to_string()), (sp.shrink_to_hi(), \")\".to_string())]\n+                    .into_iter()\n+            })\n+            .collect::<Vec<_>>();\n+        err.multipart_suggestion(\n+            \"if you change the return type to expect trait objects, box the returned expressions\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n+    pub(super) fn suggest_tuple_pattern(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n+        // some modifications due to that being in typeck and this being in infer.\n+        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n+            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n+                let compatible_variants: Vec<_> = expected_adt\n+                    .variants()\n+                    .iter()\n+                    .filter(|variant| {\n+                        variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n+                    })\n+                    .filter_map(|variant| {\n+                        let sole_field = &variant.fields[0];\n+                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                            let variant_path =\n+                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n+                            // FIXME #56861: DRYer prelude filtering\n+                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n+                                if let Some((_, path)) = path.split_once(\"::\") {\n+                                    return Some(path.to_string());\n+                                }\n+                            }\n+                            Some(variant_path)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect();\n+                match &compatible_variants[..] {\n+                    [] => {}\n+                    [variant] => {\n+                        diag.multipart_suggestion_verbose(\n+                            &format!(\"try wrapping the pattern in `{}`\", variant),\n+                            vec![\n+                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                (cause.span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {\n+                        // More than one matching variant.\n+                        diag.multipart_suggestions(\n+                            &format!(\n+                                \"try wrapping the pattern in a variant of `{}`\",\n+                                self.tcx.def_path_str(expected_adt.did())\n+                            ),\n+                            compatible_variants.into_iter().map(|variant| {\n+                                vec![\n+                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n+                                ]\n+                            }),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// A possible error is to forget to add `.await` when using futures:\n+    ///\n+    /// ```compile_fail,E0308\n+    /// async fn make_u32() -> u32 {\n+    ///     22\n+    /// }\n+    ///\n+    /// fn take_u32(x: u32) {}\n+    ///\n+    /// async fn foo() {\n+    ///     let x = make_u32();\n+    ///     take_u32(x);\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the found type `T` implements `Future<Output=U>` where `U` is the\n+    /// expected type. If this is the case, and we are inside of an async body, it suggests adding\n+    /// `.await` to the tail of the expression.\n+    pub(super) fn suggest_await_on_expect_found(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_await_on_expect_found: exp_span={:?}, expected_ty={:?}, found_ty={:?}\",\n+            exp_span, exp_found.expected, exp_found.found,\n+        );\n+\n+        if let ObligationCauseCode::CompareImplItemObligation { .. } = cause.code() {\n+            return;\n+        }\n+\n+        match (\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n+        ) {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.multipart_suggestion(\n+                        \"consider `await`ing on both `Future`s\",\n+                        vec![\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n+                            (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    prior_arms,\n+                    ..\n+                }) => {\n+                    if let [.., arm_span] = &prior_arms[..] {\n+                        diag.multipart_suggestion(\n+                            \"consider `await`ing on both `Future`s\",\n+                            vec![\n+                                (arm_span.shrink_to_hi(), \".await\".to_string()),\n+                                (exp_span.shrink_to_hi(), \".await\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        diag.help(\"consider `await`ing on both `Future`s\");\n+                    }\n+                }\n+                _ => {\n+                    diag.help(\"consider `await`ing on both `Future`s\");\n+                }\n+            },\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n+                diag.span_suggestion_verbose(\n+                    exp_span.shrink_to_hi(),\n+                    \"consider `await`ing on the `Future`\",\n+                    \".await\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                    ref prior_arms,\n+                    ..\n+                }) => {\n+                    diag.multipart_suggestion_verbose(\n+                        \"consider `await`ing on the `Future`\",\n+                        prior_arms\n+                            .iter()\n+                            .map(|arm| (arm.shrink_to_hi(), \".await\".to_string()))\n+                            .collect(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+    }\n+\n+    pub(super) fn suggest_accessing_field_where_appropriate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\n+            \"suggest_accessing_field_where_appropriate(cause={:?}, exp_found={:?})\",\n+            cause, exp_found\n+        );\n+        if let ty::Adt(expected_def, expected_substs) = exp_found.expected.kind() {\n+            if expected_def.is_enum() {\n+                return;\n+            }\n+\n+            if let Some((name, ty)) = expected_def\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n+                .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n+            {\n+                if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        let suggestion = if expected_def.is_struct() {\n+                            format!(\"{}.{}\", snippet, name)\n+                        } else if expected_def.is_union() {\n+                            format!(\"unsafe {{ {}.{} }}\", snippet, name)\n+                        } else {\n+                            return;\n+                        };\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"you might have meant to use field `{}` whose type is `{}`\",\n+                                name, ty\n+                            ),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When encountering a case where `.as_ref()` on a `Result` or `Option` would be appropriate,\n+    /// suggests it.\n+    pub(super) fn suggest_as_ref_where_appropriate(\n+        &self,\n+        span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && let Some(msg) = self.should_suggest_as_ref(exp_found.expected, exp_found.found)\n+        {\n+            diag.span_suggestion(\n+                span,\n+                msg,\n+                // HACK: fix issue# 100605, suggesting convert from &Option<T> to Option<&T>, remove the extra `&`\n+                format!(\"{}.as_ref()\", snippet.trim_start_matches('&')),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+\n+    pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n+        if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n+            (expected.kind(), found.kind())\n+        {\n+            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n+                if exp_def == &found_def {\n+                    let have_as_ref = &[\n+                        (\n+                            sym::Option,\n+                            \"you can convert from `&Option<T>` to `Option<&T>` using \\\n+                        `.as_ref()`\",\n+                        ),\n+                        (\n+                            sym::Result,\n+                            \"you can convert from `&Result<T, E>` to \\\n+                        `Result<&T, &E>` using `.as_ref()`\",\n+                        ),\n+                    ];\n+                    if let Some(msg) = have_as_ref.iter().find_map(|(name, msg)| {\n+                        self.tcx.is_diagnostic_item(*name, exp_def.did()).then_some(msg)\n+                    }) {\n+                        let mut show_suggestion = true;\n+                        for (exp_ty, found_ty) in\n+                            std::iter::zip(exp_substs.types(), found_substs.types())\n+                        {\n+                            match *exp_ty.kind() {\n+                                ty::Ref(_, exp_ty, _) => {\n+                                    match (exp_ty.kind(), found_ty.kind()) {\n+                                        (_, ty::Param(_))\n+                                        | (_, ty::Infer(_))\n+                                        | (ty::Param(_), _)\n+                                        | (ty::Infer(_), _) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ => show_suggestion = false,\n+                                    };\n+                                }\n+                                ty::Param(_) | ty::Infer(_) => {}\n+                                _ => show_suggestion = false,\n+                            }\n+                        }\n+                        if show_suggestion {\n+                            return Some(*msg);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Try to find code with pattern `if Some(..) = expr`\n+    /// use a `visitor` to mark the `if` which its span contains given error span,\n+    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n+    pub(super) fn suggest_let_for_letchains(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'_>,\n+        span: Span,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let fn_hir_id = hir.get_parent_node(cause.body_id);\n+        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+            let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n+                }) = node {\n+        let body = hir.body(*body_id);\n+\n+        /// Find the if expression with given span\n+        struct IfVisitor {\n+            pub result: bool,\n+            pub found_if: bool,\n+            pub err_span: Span,\n+        }\n+\n+        impl<'v> Visitor<'v> for IfVisitor {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if self.result { return; }\n+                match ex.kind {\n+                    hir::ExprKind::If(cond, _, _) => {\n+                        self.found_if = true;\n+                        walk_expr(self, cond);\n+                        self.found_if = false;\n+                    }\n+                    _ => walk_expr(self, ex),\n+                }\n+            }\n+\n+            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                if let hir::StmtKind::Local(hir::Local {\n+                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n+                    }) = &ex.kind\n+                    && self.found_if\n+                    && span.eq(&self.err_span) {\n+                        self.result = true;\n+                }\n+                walk_stmt(self, ex);\n+            }\n+\n+            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+                hir::intravisit::walk_body(self, body);\n+            }\n+        }\n+\n+        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n+        visitor.visit_body(&body);\n+        if visitor.result {\n+                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.typeck_results.as_ref()?.expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if std::iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxIndexSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .typeck_results\n+                    .as_ref()\n+                    .and_then(|typeck_results| typeck_results.node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "2ccbd164faaf16d1926814d2319190848bb0cee7", "filename": "compiler/rustc_infer/src/infer/note.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnote.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,203 @@\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    fn note_error_origin(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n+        terr: TypeError<'tcx>,\n+    ) {\n+        match *cause.code() {\n+            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n+                let ty = self.resolve_vars_if_possible(root_ty);\n+                if !matches!(ty.kind(), ty::Infer(ty::InferTy::TyVar(_) | ty::InferTy::FreshTy(_)))\n+                {\n+                    // don't show type `_`\n+                    if span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+                        && let ty::Adt(def, substs) = ty.kind()\n+                        && Some(def.did()) == self.tcx.get_diagnostic_item(sym::Option)\n+                    {\n+                        err.span_label(span, format!(\"this is an iterator with items of type `{}`\", substs.type_at(0)));\n+                    } else {\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n+                }\n+                }\n+                if let Some(ty::error::ExpectedFound { found, .. }) = exp_found\n+                    && ty.is_box() && ty.boxed_ty() == found\n+                    && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n+                {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider dereferencing the boxed value\",\n+                        format!(\"*{}\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n+                err.span_label(span, \"expected due to this\");\n+            }\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n+                source,\n+                ref prior_arms,\n+                scrut_hir_id,\n+                opt_suggest_box_span,\n+                scrut_span,\n+                ..\n+            }) => match source {\n+                hir::MatchSource::TryDesugar => {\n+                    if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n+                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n+                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n+                            let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n+                            self.typeck_results.as_ref().and_then(|typeck_results| {\n+                                typeck_results.expr_ty_opt(arg_expr)\n+                            })\n+                        } else {\n+                            bug!(\"try desugaring w/out call expr as scrutinee\");\n+                        };\n+\n+                        match scrut_ty {\n+                            Some(ty) if expected == ty => {\n+                                let source_map = self.tcx.sess.source_map();\n+                                err.span_suggestion(\n+                                    source_map.end_point(cause.span),\n+                                    \"try removing this `?`\",\n+                                    \"\",\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n+                    let t = self.resolve_vars_if_possible(match exp_found {\n+                        Some(ty::error::ExpectedFound { expected, .. }) => expected,\n+                        _ => prior_arm_ty,\n+                    });\n+                    let source_map = self.tcx.sess.source_map();\n+                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n+                    if prior_arms.len() <= 4 {\n+                        for sp in prior_arms {\n+                            any_multiline_arm |= source_map.is_multiline(*sp);\n+                            err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n+                        }\n+                    } else if let Some(sp) = prior_arms.last() {\n+                        any_multiline_arm |= source_map.is_multiline(*sp);\n+                        err.span_label(\n+                            *sp,\n+                            format!(\"this and all prior arms are found to be of type `{}`\", t),\n+                        );\n+                    }\n+                    let outer_error_span = if any_multiline_arm {\n+                        // Cover just `match` and the scrutinee expression, not\n+                        // the entire match body, to reduce diagram noise.\n+                        cause.span.shrink_to_lo().to(scrut_span)\n+                    } else {\n+                        cause.span\n+                    };\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(outer_error_span, msg);\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n+                        // Get return type span and point to it.\n+                        self.suggest_boxing_for_return_impl_trait(\n+                            err,\n+                            ret_sp,\n+                            prior_arms.iter().chain(std::iter::once(&arm_span)).map(|s| *s),\n+                        );\n+                    }\n+                }\n+            },\n+            ObligationCauseCode::IfExpression(box IfExpressionCause {\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n+                opt_suggest_box_span,\n+            }) => {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(else_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n+                    err.span_label(sp, \"`if` and `else` have incompatible types\");\n+                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n+                if let Some(ret_sp) = opt_suggest_box_span {\n+                    self.suggest_boxing_for_return_impl_trait(\n+                        err,\n+                        ret_sp,\n+                        [then_span, else_span].into_iter(),\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::LetElse => {\n+                err.help(\"try adding a diverging expression, such as `return` or `panic!(..)`\");\n+                err.help(\"...or use `match` instead of `let...else`\");\n+            }\n+            _ => {\n+                if let ObligationCauseCode::BindingObligation(_, span)\n+                | ObligationCauseCode::ExprBindingObligation(_, span, ..)\n+                = cause.code().peel_derives()\n+                    && let TypeError::RegionsPlaceholderMismatch = terr\n+                {\n+                    err.span_note( * span,\n+                    \"the lifetime requirement is introduced here\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> InferCtxt<'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.innermost_block();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+}"}, {"sha": "89d9450cf4e89a0b6335647b5bf5f2446f7207bd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -805,9 +805,9 @@ pub fn create_global_ctxt<'tcx>(\n     });\n \n     let ty::ResolverOutputs {\n-        definitions,\n         global_ctxt: untracked_resolutions,\n         ast_lowering: untracked_resolver_for_lowering,\n+        untracked,\n     } = resolver_outputs;\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n@@ -817,8 +817,8 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                definitions,\n                 untracked_resolutions,\n+                untracked,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),"}, {"sha": "0932eee92373d764361d9a87249d6693c9c353cd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -53,7 +53,8 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::{Abi, VariantIdx};\n-use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n+use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n+use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -96,6 +97,7 @@ fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n }\n \n impl EarlyLintPass for WhileTrue {\n+    #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::While(cond, _, label) = &e.kind\n             && let cond = pierce_parens(cond)\n@@ -360,6 +362,7 @@ impl EarlyLintPass for UnsafeCode {\n         }\n     }\n \n+    #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n@@ -582,6 +585,7 @@ impl MissingDoc {\n }\n \n impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n+    #[inline]\n     fn enter_lint_attrs(&mut self, _cx: &LateContext<'_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n@@ -750,10 +754,39 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         if def.has_dtor(cx.tcx) {\n             return;\n         }\n+\n+        // If the type contains a raw pointer, it may represent something like a handle,\n+        // and recommending Copy might be a bad idea.\n+        for field in def.all_fields() {\n+            let did = field.did;\n+            if cx.tcx.type_of(did).is_unsafe_ptr() {\n+                return;\n+            }\n+        }\n         let param_env = ty::ParamEnv::empty();\n         if ty.is_copy_modulo_regions(cx.tcx, param_env) {\n             return;\n         }\n+\n+        // We shouldn't recommend implementing `Copy` on stateful things,\n+        // such as iterators.\n+        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator) {\n+            if cx.tcx.infer_ctxt().build().type_implements_trait(iter_trait, [ty], param_env)\n+                == EvaluationResult::EvaluatedToOk\n+            {\n+                return;\n+            }\n+        }\n+\n+        // Default value of clippy::trivially_copy_pass_by_ref\n+        const MAX_SIZE: u64 = 256;\n+\n+        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes()) {\n+            if size > MAX_SIZE {\n+                return;\n+            }\n+        }\n+\n         if can_type_implement_copy(\n             cx.tcx,\n             param_env,"}, {"sha": "5d81370c35acfc71bf1d06cc5e65dbaa0e952dcc", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -37,7 +37,9 @@ pub struct EarlyContextAndPasses<'a> {\n }\n \n impl<'a> EarlyContextAndPasses<'a> {\n-    fn check_id(&mut self, id: ast::NodeId) {\n+    // This always-inlined function is for the hot call site.\n+    #[inline(always)]\n+    fn inlined_check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n             let BufferedEarlyLint { span, msg, node_id: _, lint_id, diagnostic } = early_lint;\n             self.context.lookup_with_diagnostics(\n@@ -50,6 +52,11 @@ impl<'a> EarlyContextAndPasses<'a> {\n         }\n     }\n \n+    // This non-inlined function is for the cold call sites.\n+    fn check_id(&mut self, id: ast::NodeId) {\n+        self.inlined_check_id(id)\n+    }\n+\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -61,7 +68,7 @@ impl<'a> EarlyContextAndPasses<'a> {\n         debug!(?id);\n         let push = self.context.builder.push(attrs, is_crate_node, None);\n \n-        self.check_id(id);\n+        self.inlined_check_id(id);\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n         run_early_passes!(self, enter_lint_attrs, attrs);\n         f(self);"}, {"sha": "dc2f5c0e2967e86e45c838e288272132b5eb4bf4", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -121,6 +121,7 @@ impl EarlyLintPass for HiddenUnicodeCodepoints {\n         }\n     }\n \n+    #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         // byte strings are already handled well enough by `EscapeError::NonAsciiCharInByteString`\n         match &expr.kind {"}, {"sha": "1990a74841bc2211ed1dc272a14abb1f35f11ee9", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -127,6 +127,7 @@ fn lint_mod(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n+// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n early_lint_methods!(\n     declare_combined_early_lint_pass,\n     [\n@@ -137,6 +138,9 @@ early_lint_methods!(\n     ]\n );\n \n+// Declare `BuiltinCombinedEarlyLintPass`, a lint pass that combines multiple\n+// lint passes into a single pass for maximum speed. Each `check_foo` method\n+// within this pass simply calls `check_foo` once per listed lint.\n early_lint_methods!(\n     declare_combined_early_lint_pass,\n     [\n@@ -162,7 +166,9 @@ early_lint_methods!(\n     ]\n );\n \n-// FIXME: Make a separate lint type which do not require typeck tables\n+// FIXME: Make a separate lint type which does not require typeck tables.\n+\n+// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n late_lint_methods!(\n     declare_combined_late_lint_pass,\n     [\n@@ -179,10 +185,10 @@ late_lint_methods!(\n             // Keeps a global list of foreign declarations.\n             ClashingExternDeclarations: ClashingExternDeclarations::new(),\n         ]\n-    ],\n-    ['tcx]\n+    ]\n );\n \n+// See the comment on `BuiltinCombinedEarlyLintPass`, which is similar.\n late_lint_methods!(\n     declare_combined_late_lint_pass,\n     [\n@@ -229,8 +235,7 @@ late_lint_methods!(\n             NamedAsmLabels: NamedAsmLabels,\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n         ]\n-    ],\n-    ['tcx]\n+    ]\n );\n \n pub fn new_lint_store(internal_lints: bool) -> LintStore {"}, {"sha": "00922cef38462963380b7dddd502e4fdc20bf3da", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -9,49 +9,49 @@ use rustc_span::Span;\n \n #[macro_export]\n macro_rules! late_lint_methods {\n-    ($macro:path, $args:tt, [$hir:tt]) => (\n-        $macro!($args, [$hir], [\n-            fn check_body(a: &$hir hir::Body<$hir>);\n-            fn check_body_post(a: &$hir hir::Body<$hir>);\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            fn check_body(a: &'tcx hir::Body<'tcx>);\n+            fn check_body_post(a: &'tcx hir::Body<'tcx>);\n             fn check_crate();\n             fn check_crate_post();\n-            fn check_mod(a: &$hir hir::Mod<$hir>, b: hir::HirId);\n-            fn check_foreign_item(a: &$hir hir::ForeignItem<$hir>);\n-            fn check_item(a: &$hir hir::Item<$hir>);\n-            fn check_item_post(a: &$hir hir::Item<$hir>);\n-            fn check_local(a: &$hir hir::Local<$hir>);\n-            fn check_block(a: &$hir hir::Block<$hir>);\n-            fn check_block_post(a: &$hir hir::Block<$hir>);\n-            fn check_stmt(a: &$hir hir::Stmt<$hir>);\n-            fn check_arm(a: &$hir hir::Arm<$hir>);\n-            fn check_pat(a: &$hir hir::Pat<$hir>);\n-            fn check_expr(a: &$hir hir::Expr<$hir>);\n-            fn check_expr_post(a: &$hir hir::Expr<$hir>);\n-            fn check_ty(a: &$hir hir::Ty<$hir>);\n-            fn check_generic_param(a: &$hir hir::GenericParam<$hir>);\n-            fn check_generics(a: &$hir hir::Generics<$hir>);\n-            fn check_poly_trait_ref(a: &$hir hir::PolyTraitRef<$hir>);\n+            fn check_mod(a: &'tcx hir::Mod<'tcx>, b: hir::HirId);\n+            fn check_foreign_item(a: &'tcx hir::ForeignItem<'tcx>);\n+            fn check_item(a: &'tcx hir::Item<'tcx>);\n+            fn check_item_post(a: &'tcx hir::Item<'tcx>);\n+            fn check_local(a: &'tcx hir::Local<'tcx>);\n+            fn check_block(a: &'tcx hir::Block<'tcx>);\n+            fn check_block_post(a: &'tcx hir::Block<'tcx>);\n+            fn check_stmt(a: &'tcx hir::Stmt<'tcx>);\n+            fn check_arm(a: &'tcx hir::Arm<'tcx>);\n+            fn check_pat(a: &'tcx hir::Pat<'tcx>);\n+            fn check_expr(a: &'tcx hir::Expr<'tcx>);\n+            fn check_expr_post(a: &'tcx hir::Expr<'tcx>);\n+            fn check_ty(a: &'tcx hir::Ty<'tcx>);\n+            fn check_generic_param(a: &'tcx hir::GenericParam<'tcx>);\n+            fn check_generics(a: &'tcx hir::Generics<'tcx>);\n+            fn check_poly_trait_ref(a: &'tcx hir::PolyTraitRef<'tcx>);\n             fn check_fn(\n-                a: rustc_hir::intravisit::FnKind<$hir>,\n-                b: &$hir hir::FnDecl<$hir>,\n-                c: &$hir hir::Body<$hir>,\n+                a: rustc_hir::intravisit::FnKind<'tcx>,\n+                b: &'tcx hir::FnDecl<'tcx>,\n+                c: &'tcx hir::Body<'tcx>,\n                 d: Span,\n                 e: hir::HirId);\n-            fn check_trait_item(a: &$hir hir::TraitItem<$hir>);\n-            fn check_impl_item(a: &$hir hir::ImplItem<$hir>);\n-            fn check_impl_item_post(a: &$hir hir::ImplItem<$hir>);\n-            fn check_struct_def(a: &$hir hir::VariantData<$hir>);\n-            fn check_field_def(a: &$hir hir::FieldDef<$hir>);\n-            fn check_variant(a: &$hir hir::Variant<$hir>);\n-            fn check_path(a: &hir::Path<$hir>, b: hir::HirId);\n-            fn check_attribute(a: &$hir ast::Attribute);\n+            fn check_trait_item(a: &'tcx hir::TraitItem<'tcx>);\n+            fn check_impl_item(a: &'tcx hir::ImplItem<'tcx>);\n+            fn check_impl_item_post(a: &'tcx hir::ImplItem<'tcx>);\n+            fn check_struct_def(a: &'tcx hir::VariantData<'tcx>);\n+            fn check_field_def(a: &'tcx hir::FieldDef<'tcx>);\n+            fn check_variant(a: &'tcx hir::Variant<'tcx>);\n+            fn check_path(a: &hir::Path<'tcx>, b: hir::HirId);\n+            fn check_attribute(a: &'tcx ast::Attribute);\n \n             /// Called when entering a syntax node that can have lint attributes such\n             /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-            fn enter_lint_attrs(a: &$hir [ast::Attribute]);\n+            fn enter_lint_attrs(a: &'tcx [ast::Attribute]);\n \n             /// Counterpart to `enter_lint_attrs`.\n-            fn exit_lint_attrs(a: &$hir [ast::Attribute]);\n+            fn exit_lint_attrs(a: &'tcx [ast::Attribute]);\n         ]);\n     )\n }\n@@ -66,21 +66,23 @@ macro_rules! late_lint_methods {\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n \n macro_rules! declare_late_lint_pass {\n-    ([], [$hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        pub trait LateLintPass<$hir>: LintPass {\n-            $(#[inline(always)] fn $name(&mut self, _: &LateContext<$hir>, $(_: $arg),*) {})*\n+    ([], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        pub trait LateLintPass<'tcx>: LintPass {\n+            $(#[inline(always)] fn $name(&mut self, _: &LateContext<'tcx>, $(_: $arg),*) {})*\n         }\n     )\n }\n \n-late_lint_methods!(declare_late_lint_pass, [], ['tcx]);\n+// Declare the `LateLintPass` trait, which contains empty default definitions\n+// for all the `check_*` methods.\n+late_lint_methods!(declare_late_lint_pass, []);\n \n impl LateLintPass<'_> for HardwiredLints {}\n \n #[macro_export]\n macro_rules! expand_combined_late_lint_pass_method {\n-    ([$($passes:ident),*], $self: ident, $name: ident, $params:tt) => ({\n-        $($self.$passes.$name $params;)*\n+    ([$($pass:ident),*], $self: ident, $name: ident, $params:tt) => ({\n+        $($self.$pass.$name $params;)*\n     })\n }\n \n@@ -95,28 +97,28 @@ macro_rules! expand_combined_late_lint_pass_methods {\n \n #[macro_export]\n macro_rules! declare_combined_late_lint_pass {\n-    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n+    ([$v:vis $name:ident, [$($pass:ident: $constructor:expr,)*]], $methods:tt) => (\n         #[allow(non_snake_case)]\n         $v struct $name {\n-            $($passes: $passes,)*\n+            $($pass: $pass,)*\n         }\n \n         impl $name {\n             $v fn new() -> Self {\n                 Self {\n-                    $($passes: $constructor,)*\n+                    $($pass: $constructor,)*\n                 }\n             }\n \n             $v fn get_lints() -> LintArray {\n                 let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                $(lints.extend_from_slice(&$pass::get_lints());)*\n                 lints\n             }\n         }\n \n         impl<'tcx> LateLintPass<'tcx> for $name {\n-            expand_combined_late_lint_pass_methods!([$($passes),*], $methods);\n+            expand_combined_late_lint_pass_methods!([$($pass),*], $methods);\n         }\n \n         #[allow(rustc::lint_pass_impl_without_macro)]\n@@ -176,12 +178,14 @@ macro_rules! declare_early_lint_pass {\n     )\n }\n \n+// Declare the `EarlyLintPass` trait, which contains empty default definitions\n+// for all the `check_*` methods.\n early_lint_methods!(declare_early_lint_pass, []);\n \n #[macro_export]\n macro_rules! expand_combined_early_lint_pass_method {\n-    ([$($passes:ident),*], $self: ident, $name: ident, $params:tt) => ({\n-        $($self.$passes.$name $params;)*\n+    ([$($pass:ident),*], $self: ident, $name: ident, $params:tt) => ({\n+        $($self.$pass.$name $params;)*\n     })\n }\n \n@@ -196,28 +200,28 @@ macro_rules! expand_combined_early_lint_pass_methods {\n \n #[macro_export]\n macro_rules! declare_combined_early_lint_pass {\n-    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], $methods:tt) => (\n+    ([$v:vis $name:ident, [$($pass:ident: $constructor:expr,)*]], $methods:tt) => (\n         #[allow(non_snake_case)]\n         $v struct $name {\n-            $($passes: $passes,)*\n+            $($pass: $pass,)*\n         }\n \n         impl $name {\n             $v fn new() -> Self {\n                 Self {\n-                    $($passes: $constructor,)*\n+                    $($pass: $constructor,)*\n                 }\n             }\n \n             $v fn get_lints() -> LintArray {\n                 let mut lints = Vec::new();\n-                $(lints.extend_from_slice(&$passes::get_lints());)*\n+                $(lints.extend_from_slice(&$pass::get_lints());)*\n                 lints\n             }\n         }\n \n         impl EarlyLintPass for $name {\n-            expand_combined_early_lint_pass_methods!([$($passes),*], $methods);\n+            expand_combined_early_lint_pass_methods!([$($pass),*], $methods);\n         }\n \n         #[allow(rustc::lint_pass_impl_without_macro)]"}, {"sha": "dc352778f1d1bcdab92dea9ea4f68f698fc02f2e", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -617,7 +617,10 @@ trait UnusedDelimLint {\n         lhs_needs_parens\n             || (followed_by_block\n                 && match &inner.kind {\n-                    ExprKind::Ret(_) | ExprKind::Break(..) | ExprKind::Yield(..) => true,\n+                    ExprKind::Ret(_)\n+                    | ExprKind::Break(..)\n+                    | ExprKind::Yield(..)\n+                    | ExprKind::Yeet(..) => true,\n                     ExprKind::Range(_lhs, Some(rhs), _limits) => {\n                         matches!(rhs.kind, ExprKind::Block(..))\n                     }\n@@ -946,6 +949,7 @@ impl UnusedParens {\n }\n \n impl EarlyLintPass for UnusedParens {\n+    #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         match e.kind {\n             ExprKind::Let(ref pat, _, _) | ExprKind::ForLoop(ref pat, ..) => {\n@@ -1164,6 +1168,7 @@ impl EarlyLintPass for UnusedBraces {\n         <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n+    #[inline]\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         <Self as UnusedDelimLint>::check_expr(self, cx, e);\n "}, {"sha": "0b3c057345a67d9a532e4b15e041f353b88f1743", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -238,18 +238,20 @@ fn main() {\n \n     if !is_crossed {\n         cmd.arg(\"--system-libs\");\n-    } else if target.contains(\"windows-gnu\") {\n-        println!(\"cargo:rustc-link-lib=shell32\");\n-        println!(\"cargo:rustc-link-lib=uuid\");\n-    } else if target.contains(\"netbsd\") || target.contains(\"haiku\") || target.contains(\"darwin\") {\n-        println!(\"cargo:rustc-link-lib=z\");\n-    } else if target.starts_with(\"arm\")\n+    }\n+\n+    if (target.starts_with(\"arm\") && !target.contains(\"freebsd\"))\n         || target.starts_with(\"mips-\")\n         || target.starts_with(\"mipsel-\")\n         || target.starts_with(\"powerpc-\")\n     {\n         // 32-bit targets need to link libatomic.\n         println!(\"cargo:rustc-link-lib=atomic\");\n+    } else if target.contains(\"windows-gnu\") {\n+        println!(\"cargo:rustc-link-lib=shell32\");\n+        println!(\"cargo:rustc-link-lib=uuid\");\n+    } else if target.contains(\"netbsd\") || target.contains(\"haiku\") || target.contains(\"darwin\") {\n+        println!(\"cargo:rustc-link-lib=z\");\n     }\n     cmd.args(&components);\n "}, {"sha": "5831d4693f18bbf12ae6436080ed59f8c8ce550b", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1476,13 +1476,13 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n \n extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n-                                          OperandBundleDef *Bundle) {\n+                                          OperandBundleDef **OpBundles,\n+                                          unsigned NumOpBundles) {\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n-  unsigned Len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n-      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n+      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs),\n+      makeArrayRef(*OpBundles, NumOpBundles)));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetInstrProfIncrementIntrinsic(LLVMModuleRef M) {\n@@ -1522,14 +1522,14 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                     LLVMValueRef *Args, unsigned NumArgs,\n                     LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,\n-                    OperandBundleDef *Bundle, const char *Name) {\n+                    OperandBundleDef **OpBundles, unsigned NumOpBundles,\n+                    const char *Name) {\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n-  unsigned Len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),\n                                       makeArrayRef(unwrap(Args), NumArgs),\n-                                      Bundles, Name));\n+                                      makeArrayRef(*OpBundles, NumOpBundles),\n+                                      Name));\n }\n \n extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,"}, {"sha": "01d7f3e03c50a5520d5c4d5f3efe1bd8a7d67d9d", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n@@ -68,11 +68,12 @@ impl std::fmt::Debug for CStore {\n pub struct CrateLoader<'a> {\n     // Immutable configuration.\n     sess: &'a Session,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n+    definitions: ReadGuard<'a, Definitions>,\n     local_crate_name: Symbol,\n     // Mutable output.\n-    cstore: CStore,\n-    used_extern_options: FxHashSet<Symbol>,\n+    cstore: &'a mut CStore,\n+    used_extern_options: &'a mut FxHashSet<Symbol>,\n }\n \n pub enum LoadedMacro {\n@@ -239,47 +240,49 @@ impl CStore {\n             );\n         }\n     }\n+\n+    pub fn new(sess: &Session) -> CStore {\n+        let mut stable_crate_ids = FxHashMap::default();\n+        stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n+        CStore {\n+            // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n+            // order to make array indices in `metas` match with the\n+            // corresponding `CrateNum`. This first entry will always remain\n+            // `None`.\n+            metas: IndexVec::from_elem_n(None, 1),\n+            injected_panic_runtime: None,\n+            allocator_kind: None,\n+            alloc_error_handler_kind: None,\n+            has_global_allocator: false,\n+            has_alloc_error_handler: false,\n+            stable_crate_ids,\n+            unused_externs: Vec::new(),\n+        }\n+    }\n }\n \n impl<'a> CrateLoader<'a> {\n     pub fn new(\n         sess: &'a Session,\n-        metadata_loader: Box<MetadataLoaderDyn>,\n+        metadata_loader: &'a MetadataLoaderDyn,\n         local_crate_name: Symbol,\n+        cstore: &'a mut CStore,\n+        definitions: ReadGuard<'a, Definitions>,\n+        used_extern_options: &'a mut FxHashSet<Symbol>,\n     ) -> Self {\n-        let mut stable_crate_ids = FxHashMap::default();\n-        stable_crate_ids.insert(sess.local_stable_crate_id(), LOCAL_CRATE);\n-\n         CrateLoader {\n             sess,\n             metadata_loader,\n             local_crate_name,\n-            cstore: CStore {\n-                // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n-                // order to make array indices in `metas` match with the\n-                // corresponding `CrateNum`. This first entry will always remain\n-                // `None`.\n-                metas: IndexVec::from_elem_n(None, 1),\n-                injected_panic_runtime: None,\n-                allocator_kind: None,\n-                alloc_error_handler_kind: None,\n-                has_global_allocator: false,\n-                has_alloc_error_handler: false,\n-                stable_crate_ids,\n-                unused_externs: Vec::new(),\n-            },\n-            used_extern_options: Default::default(),\n+            cstore,\n+            used_extern_options,\n+            definitions,\n         }\n     }\n-\n     pub fn cstore(&self) -> &CStore {\n         &self.cstore\n     }\n \n-    pub fn into_cstore(self) -> CStore {\n-        self.cstore\n-    }\n-\n     fn existing_match(&self, name: Symbol, hash: Option<Svh>, kind: PathKind) -> Option<CrateNum> {\n         for (cnum, data) in self.cstore.iter_crate_data() {\n             if data.name() != name {\n@@ -989,7 +992,6 @@ impl<'a> CrateLoader<'a> {\n     pub fn process_extern_crate(\n         &mut self,\n         item: &ast::Item,\n-        definitions: &Definitions,\n         def_id: LocalDefId,\n     ) -> Option<CrateNum> {\n         match item.kind {\n@@ -1013,7 +1015,7 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind)?;\n \n-                let path_len = definitions.def_path(def_id).data.len();\n+                let path_len = self.definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {"}, {"sha": "9d0ccfeb16898309ae374f4b6b392e032eb4d550", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -629,6 +629,9 @@ impl CrateStore for CStore {\n     fn as_any(&self) -> &dyn Any {\n         self\n     }\n+    fn untracked_as_any(&mut self) -> &mut dyn Any {\n+        self\n+    }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol {\n         self.get_crate_data(cnum).root.name"}, {"sha": "0450abed51b0652338a9bd7799d0dd2e566c62db", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::hir::nested_filter;\n use rustc_span::def_id::StableCrateId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n #[inline]\n@@ -1162,7 +1162,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n                 .filter_map(|(def_id, info)| {\n                     let _ = info.as_owner()?;\n                     let def_path_hash = definitions.def_path_hash(def_id);\n-                    let span = resolutions.source_span.get(def_id).unwrap_or(&DUMMY_SP);\n+                    let span = tcx.source_span(def_id);\n                     debug_assert_eq!(span.parent(), None);\n                     Some((def_path_hash, span))\n                 })"}, {"sha": "3f6e29ad611c911daf807d72be51dc5eb6e00780", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -141,8 +141,6 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_attrs = |tcx, id| {\n         tcx.hir_crate(()).owners[id.def_id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs)\n     };\n-    providers.source_span =\n-        |tcx, def_id| tcx.resolutions(()).source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n     providers.def_span = |tcx, def_id| {\n         let def_id = def_id.expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "99e59c770d754152140eaf8b6558fc370b6344dc", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -6,6 +6,7 @@\n use super::{BasicBlock, Constant, Field, Local, SwitchTargets, UserTypeProjection};\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n+use crate::traits::Reveal;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty};\n@@ -100,6 +101,13 @@ impl MirPhase {\n             MirPhase::Runtime(RuntimePhase::Optimized) => \"runtime-optimized\",\n         }\n     }\n+\n+    pub fn reveal(&self) -> Reveal {\n+        match *self {\n+            MirPhase::Built | MirPhase::Analysis(_) => Reveal::UserFacing,\n+            MirPhase::Runtime(_) => Reveal::All,\n+        }\n+    }\n }\n \n /// See [`MirPhase::Analysis`].\n@@ -518,12 +526,6 @@ pub enum TerminatorKind<'tcx> {\n     SwitchInt {\n         /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n-\n-        /// The type of value being tested.\n-        /// This is always the same as the type of `discr`.\n-        /// FIXME: remove this redundant information. Currently, it is relied on by pretty-printing.\n-        switch_ty: Ty<'tcx>,\n-\n         targets: SwitchTargets,\n     },\n "}, {"sha": "013a1bccd3bd1fd85af72a5a31db156e4e0c3416", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,6 +1,3 @@\n-use crate::mir;\n-use crate::mir::interpret::Scalar;\n-use crate::ty::{self, Ty, TyCtxt};\n use smallvec::{smallvec, SmallVec};\n \n use super::{BasicBlock, InlineAsmOperand, Operand, SourceInfo, TerminatorKind};\n@@ -131,17 +128,8 @@ impl<'tcx> Terminator<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    pub fn if_(\n-        tcx: TyCtxt<'tcx>,\n-        cond: Operand<'tcx>,\n-        t: BasicBlock,\n-        f: BasicBlock,\n-    ) -> TerminatorKind<'tcx> {\n-        TerminatorKind::SwitchInt {\n-            discr: cond,\n-            switch_ty: tcx.types.bool,\n-            targets: SwitchTargets::static_if(0, f, t),\n-        }\n+    pub fn if_(cond: Operand<'tcx>, t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n+        TerminatorKind::SwitchInt { discr: cond, targets: SwitchTargets::static_if(0, f, t) }\n     }\n \n     pub fn successors(&self) -> Successors<'_> {\n@@ -264,11 +252,9 @@ impl<'tcx> TerminatorKind<'tcx> {\n         }\n     }\n \n-    pub fn as_switch(&self) -> Option<(&Operand<'tcx>, Ty<'tcx>, &SwitchTargets)> {\n+    pub fn as_switch(&self) -> Option<(&Operand<'tcx>, &SwitchTargets)> {\n         match self {\n-            TerminatorKind::SwitchInt { discr, switch_ty, targets } => {\n-                Some((discr, *switch_ty, targets))\n-            }\n+            TerminatorKind::SwitchInt { discr, targets } => Some((discr, targets)),\n             _ => None,\n         }\n     }\n@@ -403,21 +389,12 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Abort | Unreachable | GeneratorDrop => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            SwitchInt { ref targets, switch_ty, .. } => ty::tls::with(|tcx| {\n-                let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift(switch_ty).unwrap();\n-                let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n-                targets\n-                    .values\n-                    .iter()\n-                    .map(|&u| {\n-                        mir::ConstantKind::from_scalar(tcx, Scalar::from_uint(u, size), switch_ty)\n-                            .to_string()\n-                            .into()\n-                    })\n-                    .chain(iter::once(\"otherwise\".into()))\n-                    .collect()\n-            }),\n+            SwitchInt { ref targets, .. } => targets\n+                .values\n+                .iter()\n+                .map(|&u| Cow::Owned(u.to_string()))\n+                .chain(iter::once(\"otherwise\".into()))\n+                .collect(),\n             Call { target: Some(_), cleanup: Some(_), .. } => {\n                 vec![\"return\".into(), \"unwind\".into()]\n             }"}, {"sha": "2ee3f551529f986c44525f9857994b4a29cbafba", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -477,11 +477,9 @@ macro_rules! make_mir_visitor {\n \n                     TerminatorKind::SwitchInt {\n                         discr,\n-                        switch_ty,\n                         targets: _\n                     } => {\n                         self.visit_operand(discr, location);\n-                        self.visit_ty($(& $mutability)? *switch_ty, TyContext::Location(location));\n                     }\n \n                     TerminatorKind::Drop {"}, {"sha": "ab512804330b9f647ca9bc14edf2e0d698b53b4a", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -43,6 +43,8 @@ rustc_queries! {\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n+        // Accesses untracked data\n+        eval_always\n         desc { \"getting the source span\" }\n     }\n "}, {"sha": "7d4971d1e9e62d6fb5166ed9a5e248ea44164d2d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 34, "deletions": 66, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -35,7 +35,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, RwLock, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n use rustc_data_structures::unord::UnordSet;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{\n@@ -59,7 +59,7 @@ use rustc_query_system::dep_graph::DepNodeIndex;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_session::cstore::{CrateStoreDyn, Untracked};\n use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n@@ -182,20 +182,12 @@ impl<'tcx> CtxtInterners<'tcx> {\n     /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n-    fn intern_ty(\n-        &self,\n-        kind: TyKind<'tcx>,\n-        sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n-    ) -> Ty<'tcx> {\n+    fn intern_ty(&self, kind: TyKind<'tcx>, sess: &Session, untracked: &Untracked) -> Ty<'tcx> {\n         Ty(Interned::new_unchecked(\n             self.type_\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_kind(&kind);\n-                    let stable_hash =\n-                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n+                    let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);\n \n                     InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n                         internee: kind,\n@@ -212,9 +204,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         flags: &ty::flags::FlagComputation,\n         sess: &'a Session,\n-        definitions: &'a rustc_hir::definitions::Definitions,\n-        cstore: &'a CrateStoreDyn,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n+        untracked: &'a Untracked,\n         val: &T,\n     ) -> Fingerprint {\n         // It's impossible to hash inference variables (and will ICE), so we don't need to try to cache them.\n@@ -223,7 +213,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             Fingerprint::ZERO\n         } else {\n             let mut hasher = StableHasher::new();\n-            let mut hcx = StableHashingContext::new(sess, definitions, cstore, source_span);\n+            let mut hcx = StableHashingContext::new(sess, untracked);\n             val.hash_stable(&mut hcx, &mut hasher);\n             hasher.finish()\n         }\n@@ -234,17 +224,14 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         kind: Binder<'tcx, PredicateKind<'tcx>>,\n         sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n+        untracked: &Untracked,\n     ) -> Predicate<'tcx> {\n         Predicate(Interned::new_unchecked(\n             self.predicate\n                 .intern(kind, |kind| {\n                     let flags = super::flags::FlagComputation::for_predicate(kind);\n \n-                    let stable_hash =\n-                        self.stable_hash(&flags, sess, definitions, cstore, source_span, &kind);\n+                    let stable_hash = self.stable_hash(&flags, sess, untracked, &kind);\n \n                     InternedInSet(self.arena.alloc(WithCachedTypeInfo {\n                         internee: kind,\n@@ -962,11 +949,9 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,\n         sess: &Session,\n-        definitions: &rustc_hir::definitions::Definitions,\n-        cstore: &CrateStoreDyn,\n-        source_span: &IndexVec<LocalDefId, Span>,\n+        untracked: &Untracked,\n     ) -> CommonTypes<'tcx> {\n-        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore, source_span);\n+        let mk = |ty| interners.intern_ty(ty, sess, untracked);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1112,8 +1097,7 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n-    definitions: RwLock<Definitions>,\n-\n+    untracked: Untracked,\n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n     /// The entire crate as AST. This field serves as the input for the hir_crate query,\n@@ -1278,8 +1262,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        definitions: Definitions,\n         untracked_resolutions: ty::ResolverGlobalCtxt,\n+        untracked: Untracked,\n         krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1292,14 +1276,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.emit_fatal(err);\n         });\n         let interners = CtxtInterners::new(arena);\n-        let common_types = CommonTypes::new(\n-            &interners,\n-            s,\n-            &definitions,\n-            &*untracked_resolutions.cstore,\n-            // This is only used to create a stable hashing context.\n-            &untracked_resolutions.source_span,\n-        );\n+        let common_types = CommonTypes::new(&interners, s, &untracked);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n \n@@ -1310,11 +1287,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             hir_arena,\n             interners,\n             dep_graph,\n-            definitions: RwLock::new(definitions),\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            untracked,\n             untracked_resolutions,\n             untracked_crate: Steal::new(krate),\n             on_disk_cache,\n@@ -1428,7 +1405,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_key(id)\n+            self.untracked.cstore.def_key(id)\n         }\n     }\n \n@@ -1442,7 +1419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path(id)\n+            self.untracked.cstore.def_path(id)\n         }\n     }\n \n@@ -1452,7 +1429,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1461,7 +1438,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n+            self.untracked.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1472,7 +1449,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.untracked.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1487,11 +1464,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n+            self.untracked.definitions.read().local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &*self.untracked_resolutions.cstore;\n+            let cstore = &*self.untracked.cstore;\n             let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n             cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n@@ -1505,7 +1482,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &*self.untracked_resolutions.cstore;\n+            let cstore = &*self.untracked.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1547,7 +1524,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         // This is fine because:\n         // - those queries are `eval_always` so we won't miss their result changing;\n         // - this write will have happened before these queries are called.\n-        let key = self.definitions.write().create_def(parent, data);\n+        let key = self.untracked.definitions.write().create_def(parent, data);\n \n         let feed = TyCtxtFeed { tcx: self.tcx, key };\n         feed.def_span(self.span);\n@@ -1561,7 +1538,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // definitions change.\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n-        let definitions = &self.definitions;\n+        let definitions = &self.untracked.definitions;\n         std::iter::from_generator(|| {\n             let mut i = 0;\n \n@@ -1585,7 +1562,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n+        let definitions = self.untracked.definitions.leak();\n         definitions.def_path_table()\n     }\n \n@@ -1597,43 +1574,36 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().hir_crate(());\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n         // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n-        let definitions = self.definitions.leak();\n+        let definitions = self.untracked.definitions.leak();\n         definitions.def_path_hash_to_def_index_map()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.untracked_resolutions.cstore\n+        &*self.untracked.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn definitions_untracked(self) -> ReadGuard<'tcx, Definitions> {\n-        self.definitions.read()\n+        self.untracked.definitions.read()\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n-        self.untracked_resolutions.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n+        self.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n     }\n \n     #[inline(always)]\n     pub fn with_stable_hashing_context<R>(\n         self,\n         f: impl FnOnce(StableHashingContext<'_>) -> R,\n     ) -> R {\n-        let definitions = self.definitions_untracked();\n-        let hcx = StableHashingContext::new(\n-            self.sess,\n-            &*definitions,\n-            &*self.untracked_resolutions.cstore,\n-            &self.untracked_resolutions.source_span,\n-        );\n-        f(hcx)\n+        f(StableHashingContext::new(self.sess, &self.untracked))\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2427,10 +2397,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_ty(\n             st,\n             self.sess,\n-            &self.definitions.read(),\n-            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n-            &self.untracked_resolutions.source_span,\n+            &self.untracked,\n         )\n     }\n \n@@ -2439,10 +2407,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.interners.intern_predicate(\n             binder,\n             self.sess,\n-            &self.definitions.read(),\n-            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n-            &self.untracked_resolutions.source_span,\n+            &self.untracked,\n         )\n     }\n \n@@ -3124,4 +3090,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         // We want to check if the panic handler was defined in this crate\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };\n+    providers.source_span =\n+        |tcx, def_id| tcx.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n }"}, {"sha": "2e70ac256a71973a768abfcd73cb943e66293cbf", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -234,6 +234,15 @@ impl<'tcx> Generics {\n         }\n     }\n \n+    pub fn params_to(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx [GenericParamDef] {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[..index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .params_to(param_index, tcx)\n+        }\n+    }\n+\n     /// Returns the `GenericParamDef` associated with this `EarlyBoundRegion`.\n     pub fn region_param(\n         &'tcx self,"}, {"sha": "659d99f025da03a469729b0f070448ac23cfc240", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -40,13 +40,12 @@ use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n-use rustc_hir::definitions::Definitions;\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_session::cstore::CrateStoreDyn;\n+use rustc_session::cstore::Untracked;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n@@ -150,21 +149,18 @@ mod sty;\n pub type RegisteredTools = FxHashSet<Ident>;\n \n pub struct ResolverOutputs {\n-    pub definitions: Definitions,\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n+    pub untracked: Untracked,\n }\n \n #[derive(Debug)]\n pub struct ResolverGlobalCtxt {\n-    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     pub expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    /// Reference span for definitions.\n-    pub source_span: IndexVec<LocalDefId, Span>,\n     pub effective_visibilities: EffectiveVisibilities,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxIndexSet<LocalDefId>,"}, {"sha": "9ea8dc6e69fdde0b172103282cd1c384bd3fb5b2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,6 +1,7 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -15,6 +16,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, IntegerType, Size, TargetDataLayout};\n@@ -692,6 +694,80 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }\n+\n+    /// Returns names of captured upvars for closures and generators.\n+    ///\n+    /// Here are some examples:\n+    ///  - `name__field1__field2` when the upvar is captured by value.\n+    ///  - `_ref__name__field` when the upvar is captured by reference.\n+    ///\n+    /// For generators this only contains upvars that are shared by all states.\n+    pub fn closure_saved_names_of_captured_variables(\n+        self,\n+        def_id: DefId,\n+    ) -> SmallVec<[String; 16]> {\n+        let body = self.optimized_mir(def_id);\n+\n+        body.var_debug_info\n+            .iter()\n+            .filter_map(|var| {\n+                let is_ref = match var.value {\n+                    mir::VarDebugInfoContents::Place(place)\n+                        if place.local == mir::Local::new(1) =>\n+                    {\n+                        // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n+                        // implies whether the variable is captured by value or by reference.\n+                        matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n+                    }\n+                    _ => return None,\n+                };\n+                let prefix = if is_ref { \"_ref__\" } else { \"\" };\n+                Some(prefix.to_owned() + var.name.as_str())\n+            })\n+            .collect()\n+    }\n+\n+    // FIXME(eddyb) maybe precompute this? Right now it's computed once\n+    // per generator monomorphization, but it doesn't depend on substs.\n+    pub fn generator_layout_and_saved_local_names(\n+        self,\n+        def_id: DefId,\n+    ) -> (\n+        &'tcx ty::GeneratorLayout<'tcx>,\n+        IndexVec<mir::GeneratorSavedLocal, Option<rustc_span::Symbol>>,\n+    ) {\n+        let tcx = self;\n+        let body = tcx.optimized_mir(def_id);\n+        let generator_layout = body.generator_layout().unwrap();\n+        let mut generator_saved_local_names =\n+            IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+        let state_arg = mir::Local::new(1);\n+        for var in &body.var_debug_info {\n+            let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n+            if place.local != state_arg {\n+                continue;\n+            }\n+            match place.projection[..] {\n+                [\n+                    // Deref of the `Pin<&mut Self>` state argument.\n+                    mir::ProjectionElem::Field(..),\n+                    mir::ProjectionElem::Deref,\n+                    // Field of a variant of the state.\n+                    mir::ProjectionElem::Downcast(_, variant),\n+                    mir::ProjectionElem::Field(field, _),\n+                ] => {\n+                    let name = &mut generator_saved_local_names\n+                        [generator_layout.variant_fields[variant][field]];\n+                    if name.is_none() {\n+                        name.replace(var.name);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        (generator_layout, generator_saved_local_names)\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}, {"sha": "38b1fa91d0a6794ec3cb6dc42ef0330607542825", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     LogicalOp::And => (else_block, shortcircuit_block),\n                     LogicalOp::Or => (shortcircuit_block, else_block),\n                 };\n-                let term = TerminatorKind::if_(this.tcx, lhs, blocks.0, blocks.1);\n+                let term = TerminatorKind::if_(lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n                 this.cfg.push_assign_constant("}, {"sha": "e90db2c7d05e7ba294af411f7f76ed6a2c2649a6", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 let then_block = this.cfg.start_new_block();\n                 let else_block = this.cfg.start_new_block();\n-                let term = TerminatorKind::if_(this.tcx, operand, then_block, else_block);\n+                let term = TerminatorKind::if_(operand, then_block, else_block);\n \n                 let source_info = this.source_info(expr_span);\n                 this.cfg.terminate(block, source_info, term);"}, {"sha": "6d5a98342d2936730549754f62fcacdadd06bcae", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -203,7 +203,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     self.source_info(match_start_span),\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Move(discr),\n-                        switch_ty: discr_ty,\n                         targets: switch_targets,\n                     },\n                 );\n@@ -221,7 +220,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         0 => (second_bb, first_bb),\n                         v => span_bug!(test.span, \"expected boolean value but got {:?}\", v),\n                     };\n-                    TerminatorKind::if_(self.tcx, Operand::Copy(place), true_bb, false_bb)\n+                    TerminatorKind::if_(Operand::Copy(place), true_bb, false_bb)\n                 } else {\n                     // The switch may be inexhaustive so we have a catch all block\n                     debug_assert_eq!(options.len() + 1, target_blocks.len());\n@@ -232,7 +231,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n-                        switch_ty,\n                         targets: switch_targets,\n                     }\n                 };\n@@ -378,7 +376,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             block,\n             source_info,\n-            TerminatorKind::if_(self.tcx, Operand::Move(result), success_block, fail_block),\n+            TerminatorKind::if_(Operand::Move(result), success_block, fail_block),\n         );\n     }\n \n@@ -482,7 +480,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.terminate(\n             eq_block,\n             source_info,\n-            TerminatorKind::if_(self.tcx, Operand::Move(eq_result), success_block, fail_block),\n+            TerminatorKind::if_(Operand::Move(eq_result), success_block, fail_block),\n         );\n     }\n "}, {"sha": "8610792c0eb5d24be0eced169c40d1d141ec3a4e", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -596,7 +596,6 @@ where\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n                     discr: Operand::Move(discr),\n-                    switch_ty: discr_ty,\n                     targets: SwitchTargets::new(\n                         values.iter().copied().zip(blocks.iter().copied()),\n                         *blocks.last().unwrap(),\n@@ -716,7 +715,7 @@ where\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n-                kind: TerminatorKind::if_(tcx, move_(can_go), succ, drop_block),\n+                kind: TerminatorKind::if_(move_(can_go), succ, drop_block),\n             }),\n         };\n         let loop_block = self.elaborator.patch().new_block(loop_block);\n@@ -781,7 +780,6 @@ where\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n                     discr: move_(elem_size),\n-                    switch_ty: tcx.types.usize,\n                     targets: SwitchTargets::static_if(\n                         0,\n                         self.drop_loop_pair(ety, false, len),\n@@ -1021,7 +1019,7 @@ where\n             DropStyle::Static => on_set,\n             DropStyle::Conditional | DropStyle::Open => {\n                 let flag = self.elaborator.get_drop_flag(self.path).unwrap();\n-                let term = TerminatorKind::if_(self.tcx(), flag, on_set, on_unset);\n+                let term = TerminatorKind::if_(flag, on_set, on_unset);\n                 self.new_block(unwind, term)\n             }\n         }"}, {"sha": "5ff6b9e7e69b4f8257a49d4190a996da6b75e017", "filename": "compiler/rustc_mir_dataflow/src/framework/direction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fdirection.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -261,7 +261,7 @@ impl Direction for Backward {\n                     propagate(pred, &tmp);\n                 }\n \n-                mir::TerminatorKind::SwitchInt { targets: _, ref discr, switch_ty: _ } => {\n+                mir::TerminatorKind::SwitchInt { targets: _, ref discr } => {\n                     let mut applier = BackwardSwitchIntEdgeEffectsApplier {\n                         body,\n                         pred,\n@@ -577,7 +577,7 @@ impl Direction for Forward {\n                 }\n             }\n \n-            SwitchInt { ref targets, ref discr, switch_ty: _ } => {\n+            SwitchInt { ref targets, ref discr } => {\n                 let mut applier = ForwardSwitchIntEdgeEffectsApplier {\n                     exit_state,\n                     targets,"}, {"sha": "40eefda4f076326002a270044b1526f9988110c3", "filename": "compiler/rustc_mir_transform/src/const_goto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_goto.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -82,8 +82,9 @@ impl<'tcx> Visitor<'tcx> for ConstGotoOptimizationFinder<'_, 'tcx> {\n                 }\n \n                 let target_bb_terminator = target_bb.terminator();\n-                let (discr, switch_ty, targets) = target_bb_terminator.kind.as_switch()?;\n+                let (discr, targets) = target_bb_terminator.kind.as_switch()?;\n                 if discr.place() == Some(*place) {\n+                    let switch_ty = place.ty(self.body.local_decls(), self.tcx).ty;\n                     // We now know that the Switch matches on the const place, and it is statementless\n                     // Now find which value in the Switch matches the const value.\n                     let const_value ="}, {"sha": "eba6a2b34e47ddb11379dc589c7090db1611b18d", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::graph::WithSuccessors;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::CoverageKind;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty;\n use rustc_span::{self, BytePos, Pos, Span, DUMMY_SP};\n \n // All `TEMP_BLOCK` targets should be replaced before calling `to_body() -> mir::Body`.\n@@ -47,7 +47,6 @@ struct MockBlocks<'tcx> {\n     blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     dummy_place: Place<'tcx>,\n     next_local: usize,\n-    bool_ty: Ty<'tcx>,\n }\n \n impl<'tcx> MockBlocks<'tcx> {\n@@ -56,7 +55,6 @@ impl<'tcx> MockBlocks<'tcx> {\n             blocks: IndexVec::new(),\n             dummy_place: Place { local: RETURN_PLACE, projection: ty::List::empty() },\n             next_local: 0,\n-            bool_ty: TyCtxt::BOOL_TY_FOR_UNIT_TESTING,\n         }\n     }\n \n@@ -157,7 +155,6 @@ impl<'tcx> MockBlocks<'tcx> {\n     fn switchint(&mut self, some_from_block: Option<BasicBlock>) -> BasicBlock {\n         let switchint_kind = TerminatorKind::SwitchInt {\n             discr: Operand::Move(Place::from(self.new_temp())),\n-            switch_ty: self.bool_ty, // just a dummy value\n             targets: SwitchTargets::static_if(0, TEMP_BLOCK, TEMP_BLOCK),\n         };\n         self.add_block_from(some_from_block, switchint_kind)"}, {"sha": "8a7b027ddda7eb91316f612be8995748d6729fdf", "filename": "compiler/rustc_mir_transform/src/early_otherwise_branch.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fearly_otherwise_branch.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -121,7 +121,6 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n \n             let TerminatorKind::SwitchInt {\n                 discr: parent_op,\n-                switch_ty: parent_ty,\n                 targets: parent_targets\n             } = &bbs[parent].terminator().kind else {\n                 unreachable!()\n@@ -132,6 +131,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n                 Operand::Copy(x) => Operand::Copy(*x),\n                 Operand::Constant(x) => Operand::Constant(x.clone()),\n             };\n+            let parent_ty = parent_op.ty(body.local_decls(), tcx);\n             let statements_before = bbs[parent].statements.len();\n             let parent_end = Location { block: parent, statement_index: statements_before };\n \n@@ -153,7 +153,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n             // create temp to store inequality comparison between the two discriminants, `_t` in\n             // example above\n             let nequal = BinOp::Ne;\n-            let comp_res_type = nequal.ty(tcx, *parent_ty, opt_data.child_ty);\n+            let comp_res_type = nequal.ty(tcx, parent_ty, opt_data.child_ty);\n             let comp_temp = patch.new_temp(comp_res_type, opt_data.child_source.span);\n             patch.add_statement(parent_end, StatementKind::StorageLive(comp_temp));\n \n@@ -181,7 +181,6 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n                 kind: TerminatorKind::SwitchInt {\n                     // switch on the first discriminant, so we can mark the second one as dead\n                     discr: parent_op,\n-                    switch_ty: opt_data.child_ty,\n                     targets: eq_targets,\n                 },\n             }));\n@@ -193,12 +192,7 @@ impl<'tcx> MirPass<'tcx> for EarlyOtherwiseBranch {\n             let false_case = eq_bb;\n             patch.patch_terminator(\n                 parent,\n-                TerminatorKind::if_(\n-                    tcx,\n-                    Operand::Move(Place::from(comp_temp)),\n-                    true_case,\n-                    false_case,\n-                ),\n+                TerminatorKind::if_(Operand::Move(Place::from(comp_temp)), true_case, false_case),\n             );\n \n             // generate StorageDead for the second_discriminant_temp not in use anymore\n@@ -319,11 +313,11 @@ fn evaluate_candidate<'tcx>(\n     let bbs = &body.basic_blocks;\n     let TerminatorKind::SwitchInt {\n         targets,\n-        switch_ty: parent_ty,\n-        ..\n+        discr: parent_discr,\n     } = &bbs[parent].terminator().kind else {\n         return None\n     };\n+    let parent_ty = parent_discr.ty(body.local_decls(), tcx);\n     let parent_dest = {\n         let poss = targets.otherwise();\n         // If the fallthrough on the parent is trivially unreachable, we can let the\n@@ -339,12 +333,12 @@ fn evaluate_candidate<'tcx>(\n     let (_, child) = targets.iter().next()?;\n     let child_terminator = &bbs[child].terminator();\n     let TerminatorKind::SwitchInt {\n-        switch_ty: child_ty,\n         targets: child_targets,\n-        ..\n+        discr: child_discr,\n     } = &child_terminator.kind else {\n         return None\n     };\n+    let child_ty = child_discr.ty(body.local_decls(), tcx);\n     if child_ty != parent_ty {\n         return None;\n     }\n@@ -372,7 +366,7 @@ fn evaluate_candidate<'tcx>(\n     Some(OptimizationData {\n         destination,\n         child_place: *child_place,\n-        child_ty: *child_ty,\n+        child_ty,\n         child_source: child_terminator.source_info,\n     })\n }"}, {"sha": "c08593afe9d88ff900b6c116ffcd8183cc0b89d4", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -877,11 +877,7 @@ fn insert_switch<'tcx>(\n     let (assign, discr) = transform.get_discr(body);\n     let switch_targets =\n         SwitchTargets::new(cases.iter().map(|(i, bb)| ((*i) as u128, *bb)), default_block);\n-    let switch = TerminatorKind::SwitchInt {\n-        discr: Operand::Move(discr),\n-        switch_ty: transform.discr_ty,\n-        targets: switch_targets,\n-    };\n+    let switch = TerminatorKind::SwitchInt { discr: Operand::Move(discr), targets: switch_targets };\n \n     let source_info = SourceInfo::outermost(body.span);\n     body.basic_blocks_mut().raw.insert("}, {"sha": "ce05db5b762ac9a48d3b2d15f6b3be72a3a5d526", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -55,18 +55,17 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                 continue;\n             }\n \n-            let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {\n+            let (discr, val, first, second) = match bbs[bb_idx].terminator().kind {\n                 TerminatorKind::SwitchInt {\n                     discr: ref discr @ (Operand::Copy(_) | Operand::Move(_)),\n-                    switch_ty,\n                     ref targets,\n                     ..\n                 } if targets.iter().len() == 1 => {\n                     let (value, target) = targets.iter().next().unwrap();\n                     if target == targets.otherwise() {\n                         continue;\n                     }\n-                    (discr, value, switch_ty, target, targets.otherwise())\n+                    (discr, value, target, targets.otherwise())\n                 }\n                 // Only optimize switch int statements\n                 _ => continue,\n@@ -105,10 +104,11 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             }\n             // Take ownership of items now that we know we can optimize.\n             let discr = discr.clone();\n+            let discr_ty = discr.ty(&body.local_decls, tcx);\n \n             // Introduce a temporary for the discriminant value.\n             let source_info = bbs[bb_idx].terminator().source_info;\n-            let discr_local = body.local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n+            let discr_local = body.local_decls.push(LocalDecl::new(discr_ty, source_info.span));\n \n             // We already checked that first and second are different blocks,\n             // and bb_idx has a different terminator from both of them.\n@@ -130,10 +130,10 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                             (*f).clone()\n                         } else {\n                             // Different value between blocks. Make value conditional on switch condition.\n-                            let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n+                            let size = tcx.layout_of(param_env.and(discr_ty)).unwrap().size;\n                             let const_cmp = Operand::const_from_scalar(\n                                 tcx,\n-                                switch_ty,\n+                                discr_ty,\n                                 rustc_const_eval::interpret::Scalar::from_uint(val, size),\n                                 rustc_span::DUMMY_SP,\n                             );"}, {"sha": "f92a0e826dcdfb6dcf55e264235d07e360a5137f", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -548,7 +548,6 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n                 statements.push(statement);\n                 *kind = TerminatorKind::SwitchInt {\n                     discr: Operand::Move(temp),\n-                    switch_ty: discr_ty,\n                     targets: SwitchTargets::new(cases.into_iter(), unreachable),\n                 };\n             }"}, {"sha": "8164b3052786aa1ea07d979f6607ca8988f6b9ef", "filename": "compiler/rustc_mir_transform/src/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -24,12 +24,9 @@ impl<'tcx> MirPass<'tcx> for SimplifyConstCondition {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt {\n-                    discr: Operand::Constant(ref c),\n-                    switch_ty,\n-                    ref targets,\n-                    ..\n+                    discr: Operand::Constant(ref c), ref targets, ..\n                 } => {\n-                    let constant = c.literal.try_eval_bits(tcx, param_env, switch_ty);\n+                    let constant = c.literal.try_eval_bits(tcx, param_env, c.ty());\n                     if let Some(constant) = constant {\n                         let target = targets.target_for_value(constant);\n                         TerminatorKind::Goto { target }"}, {"sha": "dcad1518eb63eb0d853037b109b9b7d800b727c8", "filename": "compiler/rustc_mir_transform/src/simplify_comparison_integral.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -127,11 +127,8 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n             let targets = SwitchTargets::new(iter::once((new_value, bb_cond)), bb_otherwise);\n \n             let terminator = bb.terminator_mut();\n-            terminator.kind = TerminatorKind::SwitchInt {\n-                discr: Operand::Move(opt.to_switch_on),\n-                switch_ty: opt.branch_value_ty,\n-                targets,\n-            };\n+            terminator.kind =\n+                TerminatorKind::SwitchInt { discr: Operand::Move(opt.to_switch_on), targets };\n         }\n \n         for (idx, bb_idx) in storage_deads_to_remove {"}, {"sha": "06deca2fffb4889cc447878136b545a0243de852", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -76,7 +76,7 @@ where\n     let terminator = match terminator_kind {\n         // This will unconditionally run into an unreachable and is therefore unreachable as well.\n         TerminatorKind::Goto { target } if is_unreachable(*target) => TerminatorKind::Unreachable,\n-        TerminatorKind::SwitchInt { targets, discr, switch_ty } => {\n+        TerminatorKind::SwitchInt { targets, discr } => {\n             let otherwise = targets.otherwise();\n \n             // If all targets are unreachable, we can be unreachable as well.\n@@ -110,11 +110,7 @@ where\n                     return None;\n                 }\n \n-                TerminatorKind::SwitchInt {\n-                    discr: discr.clone(),\n-                    switch_ty: *switch_ty,\n-                    targets: new_targets,\n-                }\n+                TerminatorKind::SwitchInt { discr: discr.clone(), targets: new_targets }\n             } else {\n                 // If the otherwise branch is reachable, we don't want to delete any unreachable branches.\n                 return None;"}, {"sha": "72da398d3fc1984282fd422763c3fb0a73fe7da5", "filename": "compiler/rustc_parse_format/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2FCargo.toml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -5,3 +5,4 @@ edition = \"2021\"\n \n [dependencies]\n rustc_lexer = { path = \"../rustc_lexer\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "9cbe04c1288effe53ad31e764541f49ef032a23a", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -58,13 +58,13 @@ impl InnerOffset {\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n     String(&'a str),\n     /// This describes that formatting should process the next argument (as\n     /// specified inside) for emission.\n-    NextArgument(Argument<'a>),\n+    NextArgument(Box<Argument<'a>>),\n }\n \n /// Representation of an argument specification.\n@@ -244,7 +244,7 @@ impl<'a> Iterator for Parser<'a> {\n                         } else {\n                             self.suggest_positional_arg_instead_of_captured_arg(arg);\n                         }\n-                        Some(NextArgument(arg))\n+                        Some(NextArgument(Box::new(arg)))\n                     }\n                 }\n                 '}' => {\n@@ -908,5 +908,9 @@ fn find_skips_from_snippet(\n     (skips, true)\n }\n \n+// Assert a reasonable size for `Piece`\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Piece<'_>, 16);\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "2992ba845ab16aab0b3da5da04096c2978ce9900", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -76,51 +76,51 @@ fn invalid_precision() {\n fn format_nothing() {\n     same(\n         \"{}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     );\n }\n #[test]\n fn format_position() {\n     same(\n         \"{3}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     );\n }\n #[test]\n fn format_position_nothing_else() {\n     same(\n         \"{3:}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     );\n }\n #[test]\n fn format_named() {\n     same(\n         \"{name}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentNamed(\"name\"),\n             position_span: InnerSpan { start: 2, end: 6 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     )\n }\n #[test]\n fn format_type() {\n     same(\n         \"{3:x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n@@ -134,14 +134,14 @@ fn format_type() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n }\n #[test]\n fn format_align_fill() {\n     same(\n         \"{3:>}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n@@ -155,11 +155,11 @@ fn format_align_fill() {\n                 ty: \"\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{3:0<}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n@@ -173,11 +173,11 @@ fn format_align_fill() {\n                 ty: \"\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{3:*<abcd}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(3),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n@@ -191,14 +191,14 @@ fn format_align_fill() {\n                 ty: \"abcd\",\n                 ty_span: Some(InnerSpan::new(6, 10)),\n             },\n-        })],\n+        }))],\n     );\n }\n #[test]\n fn format_counts() {\n     same(\n         \"{:10x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -212,11 +212,11 @@ fn format_counts() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:10$.10x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -230,11 +230,11 @@ fn format_counts() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{1:0$.10x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentIs(1),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: FormatSpec {\n@@ -248,11 +248,11 @@ fn format_counts() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:.*x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(1),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -266,11 +266,11 @@ fn format_counts() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:.10$x}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -284,11 +284,11 @@ fn format_counts() {\n                 ty: \"x\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:a$.b$?}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -302,11 +302,11 @@ fn format_counts() {\n                 ty: \"?\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:.4}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -320,14 +320,14 @@ fn format_counts() {\n                 ty: \"\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     )\n }\n #[test]\n fn format_flags() {\n     same(\n         \"{:-}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -341,11 +341,11 @@ fn format_flags() {\n                 ty: \"\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n     same(\n         \"{:+#}\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 2 },\n             format: FormatSpec {\n@@ -359,7 +359,7 @@ fn format_flags() {\n                 ty: \"\",\n                 ty_span: None,\n             },\n-        })],\n+        }))],\n     );\n }\n #[test]\n@@ -368,7 +368,7 @@ fn format_mixture() {\n         \"abcd {3:x} efg\",\n         &[\n             String(\"abcd \"),\n-            NextArgument(Argument {\n+            NextArgument(Box::new(Argument {\n                 position: ArgumentIs(3),\n                 position_span: InnerSpan { start: 7, end: 8 },\n                 format: FormatSpec {\n@@ -382,7 +382,7 @@ fn format_mixture() {\n                     ty: \"x\",\n                     ty_span: None,\n                 },\n-            }),\n+            })),\n             String(\" efg\"),\n         ],\n     );\n@@ -391,18 +391,18 @@ fn format_mixture() {\n fn format_whitespace() {\n     same(\n         \"{ }\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 3 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     );\n     same(\n         \"{  }\",\n-        &[NextArgument(Argument {\n+        &[NextArgument(Box::new(Argument {\n             position: ArgumentImplicitlyIs(0),\n             position_span: InnerSpan { start: 2, end: 4 },\n             format: fmtdflt(),\n-        })],\n+        }))],\n     );\n }"}, {"sha": "163da59edd5c7378fe43f9f8c565ae1237d72693", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -6,9 +6,8 @@ use rustc_data_structures::stable_hasher::{HashStable, HashingControls, StableHa\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::definitions::{DefPathHash, Definitions};\n-use rustc_index::vec::IndexVec;\n-use rustc_session::cstore::CrateStore;\n+use rustc_hir::definitions::DefPathHash;\n+use rustc_session::cstore::Untracked;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n@@ -20,9 +19,7 @@ use rustc_span::{BytePos, CachingSourceMapView, SourceFile, Span, SpanData, DUMM\n /// things (e.g., each `DefId`/`DefPath` is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n-    definitions: &'a Definitions,\n-    cstore: &'a dyn CrateStore,\n-    source_span: &'a IndexVec<LocalDefId, Span>,\n+    untracked: &'a Untracked,\n     // The value of `-Z incremental-ignore-spans`.\n     // This field should only be used by `unstable_opts_incremental_ignore_span`\n     incremental_ignore_spans: bool,\n@@ -49,19 +46,12 @@ pub(super) enum BodyResolver<'tcx> {\n \n impl<'a> StableHashingContext<'a> {\n     #[inline]\n-    pub fn new(\n-        sess: &'a Session,\n-        definitions: &'a Definitions,\n-        cstore: &'a dyn CrateStore,\n-        source_span: &'a IndexVec<LocalDefId, Span>,\n-    ) -> Self {\n+    pub fn new(sess: &'a Session, untracked: &'a Untracked) -> Self {\n         let hash_spans_initial = !sess.opts.unstable_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             body_resolver: BodyResolver::Forbidden,\n-            definitions,\n-            cstore,\n-            source_span,\n+            untracked,\n             incremental_ignore_spans: sess.opts.unstable_opts.incremental_ignore_spans,\n             caching_source_map: None,\n             raw_source_map: sess.source_map(),\n@@ -100,13 +90,13 @@ impl<'a> StableHashingContext<'a> {\n         if let Some(def_id) = def_id.as_local() {\n             self.local_def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.def_path_hash(def_id)\n         }\n     }\n \n     #[inline]\n     pub fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n-        self.definitions.def_path_hash(def_id)\n+        self.untracked.definitions.read().def_path_hash(def_id)\n     }\n \n     #[inline]\n@@ -156,7 +146,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        *self.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n+        *self.untracked.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n     }\n \n     #[inline]"}, {"sha": "f4a6a08df1c8514fe24987fce26eb2827b7afcc4", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -836,12 +836,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         } else if orig_name == Some(kw::SelfLower) {\n             Some(self.r.graph_root)\n         } else {\n-            self.r.crate_loader.process_extern_crate(item, &self.r.definitions, local_def_id).map(\n-                |crate_id| {\n-                    self.r.extern_crate_map.insert(local_def_id, crate_id);\n-                    self.r.expect_module(crate_id.as_def_id())\n-                },\n-            )\n+            let crate_id = self.r.crate_loader().process_extern_crate(item, local_def_id);\n+            crate_id.map(|crate_id| {\n+                self.r.extern_crate_map.insert(local_def_id, crate_id);\n+                self.r.expect_module(crate_id.as_def_id())\n+            })\n         }\n         .map(|module| {\n             let used = self.process_macro_use_imports(item, module);"}, {"sha": "37771693417b35a8c60d0e571ed98f7dab77a718", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -153,7 +153,7 @@ impl<'a> Resolver<'a> {\n             if !candidates.is_empty() {\n                 show_candidates(\n                     &self.session,\n-                    &self.source_span,\n+                    &self.untracked.source_span,\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -682,7 +682,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     show_candidates(\n                         &self.session,\n-                        &self.source_span,\n+                        &self.untracked.source_span,\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -1298,7 +1298,8 @@ impl<'a> Resolver<'a> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name) {\n+                let crate_id = self.crate_loader().maybe_process_path_extern(ident.name);\n+                if let Some(crate_id) = crate_id {\n                     let crate_root = self.expect_module(crate_id.as_def_id());\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n                         lookup_ident,\n@@ -1335,7 +1336,7 @@ impl<'a> Resolver<'a> {\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n             &self.session,\n-            &self.source_span,\n+            &self.untracked.source_span,\n             err,\n             None,\n             &import_suggestions,"}, {"sha": "b8efa3f8b2743336dc894dcbac137b8a0047da94", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -107,7 +107,7 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 r.effective_visibilities.update_eff_vis(\n                     r.local_def_id(node_id),\n                     eff_vis,\n-                    ResolverTree(&r.definitions, &r.crate_loader),\n+                    ResolverTree(&r.untracked),\n                 )\n             }\n         }"}, {"sha": "4d896b055268e975ab284861e93a8c85a4e70cda", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             if let Some(candidate) = &err.candidate {\n                 import_candidates(\n                     self.r.session,\n-                    &self.r.source_span,\n+                    &self.r.untracked.source_span,\n                     &mut diag,\n                     Some(err.span),\n                     &candidate,"}, {"sha": "d43983ea8150faf15db202c7b8a242a770c81c97", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1663,8 +1663,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         if !module.no_implicit_prelude {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n-                                self.r.crate_loader.maybe_process_path_extern(ident.name).and_then(\n-                                    |crate_id| {\n+                                self.r\n+                                    .crate_loader()\n+                                    .maybe_process_path_extern(ident.name)\n+                                    .and_then(|crate_id| {\n                                         let crate_mod =\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n \n@@ -1673,8 +1675,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                                         } else {\n                                             None\n                                         }\n-                                    },\n-                                )\n+                                    })\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {"}, {"sha": "24e4b5bdd3f50d8f84e8d3f435062eb401e9de07", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,7 +29,7 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, RwLock};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n@@ -46,7 +46,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, MetadataLoaderDyn, Untracked};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -866,11 +866,8 @@ struct MacroData {\n pub struct Resolver<'a> {\n     session: &'a Session,\n \n-    definitions: Definitions,\n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n-    /// Reference span for definitions.\n-    source_span: IndexVec<LocalDefId, Span>,\n \n     graph_root: Module<'a>,\n \n@@ -954,7 +951,10 @@ pub struct Resolver<'a> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    crate_loader: CrateLoader<'a>,\n+    local_crate_name: Symbol,\n+    metadata_loader: Box<MetadataLoaderDyn>,\n+    untracked: Untracked,\n+    used_extern_options: FxHashSet<Symbol>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n     /// A small map keeping true kinds of built-in macros that appear to be fn-like on\n@@ -1112,15 +1112,15 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n /// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n /// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n #[derive(Clone, Copy)]\n-struct ResolverTree<'a, 'b>(&'a Definitions, &'a CrateLoader<'b>);\n+struct ResolverTree<'a>(&'a Untracked);\n \n-impl DefIdTree for ResolverTree<'_, '_> {\n+impl DefIdTree for ResolverTree<'_> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        let ResolverTree(definitions, crate_loader) = self;\n+        let ResolverTree(Untracked { definitions, cstore, .. }) = self;\n         match id.as_local() {\n-            Some(id) => definitions.def_key(id).parent,\n-            None => crate_loader.cstore().def_key(id).parent,\n+            Some(id) => definitions.read().def_key(id).parent,\n+            None => cstore.as_any().downcast_ref::<CStore>().unwrap().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n@@ -1129,7 +1129,7 @@ impl DefIdTree for ResolverTree<'_, '_> {\n impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        ResolverTree(&self.definitions, &self.crate_loader).opt_parent(id)\n+        ResolverTree(&self.untracked).opt_parent(id)\n     }\n }\n \n@@ -1156,10 +1156,10 @@ impl Resolver<'_> {\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.definitions.def_key(self.node_id_to_def_id[&node_id]),\n+            self.untracked.definitions.read().def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.definitions.create_def(parent, data);\n+        let def_id = self.untracked.definitions.write().create_def(parent, data);\n \n         // Create the definition.\n         if expn_id != ExpnId::root() {\n@@ -1168,7 +1168,7 @@ impl Resolver<'_> {\n \n         // A relative span's parent must be an absolute span.\n         debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.source_span.push(span);\n+        let _id = self.untracked.source_span.push(span);\n         debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n@@ -1258,9 +1258,7 @@ impl<'a> Resolver<'a> {\n         let mut resolver = Resolver {\n             session,\n \n-            definitions,\n             expn_that_defined: Default::default(),\n-            source_span,\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1311,7 +1309,14 @@ impl<'a> Resolver<'a> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n+            metadata_loader,\n+            local_crate_name: crate_name,\n+            used_extern_options: Default::default(),\n+            untracked: Untracked {\n+                cstore: Box::new(CStore::new(session)),\n+                source_span,\n+                definitions: RwLock::new(definitions),\n+            },\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             builtin_macro_kinds: Default::default(),\n@@ -1402,9 +1407,6 @@ impl<'a> Resolver<'a> {\n \n     pub fn into_outputs(self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        let definitions = self.definitions;\n-        let cstore = Box::new(self.crate_loader.into_cstore());\n-        let source_span = self.source_span;\n         let expn_that_defined = self.expn_that_defined;\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n@@ -1416,9 +1418,8 @@ impl<'a> Resolver<'a> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let effective_visibilities = self.effective_visibilities;\n+        let untracked = self.untracked;\n         let global_ctxt = ResolverGlobalCtxt {\n-            cstore,\n-            source_span,\n             expn_that_defined,\n             visibilities,\n             has_pub_restricted,\n@@ -1453,16 +1454,16 @@ impl<'a> Resolver<'a> {\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n         };\n-        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n+        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n     }\n \n     pub fn clone_outputs(&self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        let definitions = self.definitions.clone();\n+        let definitions = self.untracked.definitions.clone();\n         let cstore = Box::new(self.cstore().clone());\n+        let untracked =\n+            Untracked { cstore, source_span: self.untracked.source_span.clone(), definitions };\n         let global_ctxt = ResolverGlobalCtxt {\n-            cstore,\n-            source_span: self.source_span.clone(),\n             expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n             has_pub_restricted: self.has_pub_restricted,\n@@ -1497,20 +1498,26 @@ impl<'a> Resolver<'a> {\n             builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n             lifetime_elision_allowed: self.lifetime_elision_allowed.clone(),\n         };\n-        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n+        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(\n-            self.session,\n-            &self.definitions,\n-            self.crate_loader.cstore(),\n-            &self.source_span,\n+        StableHashingContext::new(self.session, &self.untracked)\n+    }\n+\n+    pub fn crate_loader(&mut self) -> CrateLoader<'_> {\n+        CrateLoader::new(\n+            &self.session,\n+            &*self.metadata_loader,\n+            self.local_crate_name,\n+            &mut *self.untracked.cstore.untracked_as_any().downcast_mut().unwrap(),\n+            self.untracked.definitions.read(),\n+            &mut self.used_extern_options,\n         )\n     }\n \n     pub fn cstore(&self) -> &CStore {\n-        self.crate_loader.cstore()\n+        self.untracked.cstore.as_any().downcast_ref().unwrap()\n     }\n \n     fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n@@ -1553,7 +1560,7 @@ impl<'a> Resolver<'a> {\n             self.session.time(\"resolve_main\", || self.resolve_main());\n             self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n             self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n-            self.session.time(\"resolve_postprocess\", || self.crate_loader.postprocess(krate));\n+            self.session.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n         });\n     }\n \n@@ -1871,10 +1878,10 @@ impl<'a> Resolver<'a> {\n             } else {\n                 let crate_id = if finalize {\n                     let Some(crate_id) =\n-                        self.crate_loader.process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n+                        self.crate_loader().process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n                     crate_id\n                 } else {\n-                    self.crate_loader.maybe_process_path_extern(ident.name)?\n+                    self.crate_loader().maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.expect_module(crate_id.as_def_id());\n                 let vis = ty::Visibility::<LocalDefId>::Public;\n@@ -1946,14 +1953,14 @@ impl<'a> Resolver<'a> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.source_span[def_id])\n+        def_id.as_local().map(|def_id| self.untracked.source_span[def_id])\n     }\n \n     /// Retrieves the name of the given `DefId`.\n     #[inline]\n     pub fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n         let def_key = match def_id.as_local() {\n-            Some(def_id) => self.definitions.def_key(def_id),\n+            Some(def_id) => self.untracked.definitions.read().def_key(def_id),\n             None => self.cstore().def_key(def_id),\n         };\n         def_key.get_opt_name()"}, {"sha": "b5b1602c5e0d38ad3971cb62c3c19524412063a9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -455,7 +455,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     }\n \n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n-        self.crate_loader.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n     }\n \n     fn declare_proc_macro(&mut self, id: NodeId) {"}, {"sha": "d8db86c5f6216e1643d7b1e33d881135cf096fb1", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,6 +13,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "1085bce44758fe7235929e8c7ca2b703f23cbae3", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,7 +19,7 @@ pub enum SizeKind {\n     Min,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FieldInfo {\n     pub name: Symbol,\n     pub offset: u64,\n@@ -33,6 +33,7 @@ pub enum DataTypeKind {\n     Union,\n     Enum,\n     Closure,\n+    Generator,\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n@@ -114,7 +115,7 @@ impl CodeStats {\n \n             let struct_like = match kind {\n                 DataTypeKind::Struct | DataTypeKind::Closure => true,\n-                DataTypeKind::Enum | DataTypeKind::Union => false,\n+                DataTypeKind::Enum | DataTypeKind::Union | DataTypeKind::Generator => false,\n             };\n             for (i, variant_info) in variants.into_iter().enumerate() {\n                 let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;"}, {"sha": "7f926f7d8bc4a2cb2cd25871384eff142e0324a8", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -6,9 +6,10 @@ use crate::search_paths::PathKind;\n use crate::utils::NativeLibKind;\n use crate::Session;\n use rustc_ast as ast;\n-use rustc_data_structures::sync::{self, MetadataRef};\n-use rustc_hir::def_id::{CrateNum, DefId, StableCrateId, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n+use rustc_data_structures::sync::{self, MetadataRef, RwLock};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, StableCrateId, LOCAL_CRATE};\n+use rustc_hir::definitions::{DefKey, DefPath, DefPathHash, Definitions};\n+use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -217,6 +218,7 @@ pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n /// during resolve)\n pub trait CrateStore: std::fmt::Debug {\n     fn as_any(&self) -> &dyn Any;\n+    fn untracked_as_any(&mut self) -> &mut dyn Any;\n \n     // Foreign definitions.\n     // This information is safe to access, since it's hashed as part of the DefPathHash, which incr.\n@@ -249,3 +251,11 @@ pub trait CrateStore: std::fmt::Debug {\n }\n \n pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n+\n+#[derive(Debug)]\n+pub struct Untracked {\n+    pub cstore: Box<CrateStoreDyn>,\n+    /// Reference span for definitions.\n+    pub source_span: IndexVec<LocalDefId, Span>,\n+    pub definitions: RwLock<Definitions>,\n+}"}, {"sha": "dab9c736d14d59d496f8bbed8b2e2d52f57a5980", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -368,7 +368,7 @@ mod desc {\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n     pub const parse_oom_strategy: &str = \"either `panic` or `abort`\";\n     pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n+    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n     pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n@@ -675,6 +675,7 @@ mod parse {\n                 *slot |= match s {\n                     \"address\" => SanitizerSet::ADDRESS,\n                     \"cfi\" => SanitizerSet::CFI,\n+                    \"kcfi\" => SanitizerSet::KCFI,\n                     \"leak\" => SanitizerSet::LEAK,\n                     \"memory\" => SanitizerSet::MEMORY,\n                     \"memtag\" => SanitizerSet::MEMTAG,"}, {"sha": "8859b76d28972f7b36005f035f591300f22e9b79", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -686,6 +686,10 @@ impl Session {\n         self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n     }\n \n+    pub fn is_sanitizer_kcfi_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::KCFI)\n+    }\n+\n     /// Check whether this compile session and crate type use static crt.\n     pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n         if !self.target.crt_static_respected {\n@@ -1544,6 +1548,14 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         }\n     }\n \n+    // LLVM CFI and KCFI are mutually exclusive\n+    if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n+        sess.emit_err(CannotMixAndMatchSanitizers {\n+            first: \"cfi\".to_string(),\n+            second: \"kcfi\".to_string(),\n+        });\n+    }\n+\n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n             sess.emit_warning(StackProtectorNotSupportedForTarget {"}, {"sha": "335bfc3302f27c34bd0dada4f2e93840574a55f0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -491,6 +491,10 @@ impl SpanData {\n     pub fn is_dummy(self) -> bool {\n         self.lo.0 == 0 && self.hi.0 == 0\n     }\n+    #[inline]\n+    pub fn is_visible(self, sm: &SourceMap) -> bool {\n+        !self.is_dummy() && sm.is_span_accessible(self.span())\n+    }\n     /// Returns `true` if `self` fully encloses `other`.\n     pub fn contains(self, other: Self) -> bool {\n         self.lo <= other.lo && other.hi <= self.hi\n@@ -556,6 +560,11 @@ impl Span {\n         self.data_untracked().is_dummy()\n     }\n \n+    #[inline]\n+    pub fn is_visible(self, sm: &SourceMap) -> bool {\n+        self.data_untracked().is_visible(sm)\n+    }\n+\n     /// Returns `true` if this span comes from any kind of macro, desugaring or inlining.\n     #[inline]\n     pub fn from_expansion(self) -> bool {"}, {"sha": "1fcf8c7a8bf13f06543603c5a9d1ff120861c01a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -828,6 +828,7 @@ symbols! {\n         item_like_imports,\n         iter,\n         iter_repeat,\n+        kcfi,\n         keyword,\n         kind,\n         kreg,"}, {"sha": "4e447eab02e7c9d7e9dd581355282fa6a52de6c9", "filename": "compiler/rustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2FCargo.toml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -10,6 +10,7 @@ bitflags = \"1.2.1\"\n tracing = \"0.1\"\n punycode = \"0.4.0\"\n rustc-demangle = \"0.1.21\"\n+twox-hash = \"1.6.3\"\n \n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "53983bed718922b3521462a88794d327bd5eceae", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -3,6 +3,8 @@\n \n use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n use rustc_target::abi::call::FnAbi;\n+use std::hash::Hasher;\n+use twox_hash::XxHash64;\n \n mod typeid_itanium_cxx_abi;\n use typeid_itanium_cxx_abi::TypeIdOptions;\n@@ -16,3 +18,25 @@ pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>)\n pub fn typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> String {\n     typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS)\n }\n+\n+/// Returns an LLVM KCFI type metadata identifier for the specified FnAbi.\n+pub fn kcfi_typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> u32 {\n+    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n+    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(\n+        typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, TypeIdOptions::NO_OPTIONS).as_bytes(),\n+    );\n+    hash.finish() as u32\n+}\n+\n+/// Returns an LLVM KCFI type metadata identifier for the specified FnSig.\n+pub fn kcfi_typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> u32 {\n+    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n+    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(\n+        typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS).as_bytes(),\n+    );\n+    hash.finish() as u32\n+}"}, {"sha": "aca52e1478eb8ac44fd5294ac34a65422d27ec73", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_none.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -6,13 +6,16 @@\n //\n // For example, `-C target-cpu=cortex-a53`.\n \n-use super::{Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, Target, TargetOptions};\n+use super::{\n+    Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, SanitizerSet, Target, TargetOptions,\n+};\n \n pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::Yes),\n         linker: Some(\"rust-lld\".into()),\n         features: \"+strict-align,+neon,+fp-armv8\".into(),\n+        supported_sanitizers: SanitizerSet::KCFI,\n         relocation_model: RelocModel::Static,\n         disable_redzone: true,\n         max_atomic_width: Some(128),"}, {"sha": "fc6a2edabb763c89de1dad368dfecf7b17154b2a", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -204,7 +204,7 @@ pub fn macos_llvm_target(arch: Arch) -> String {\n fn link_env_remove(arch: Arch, os: &'static str) -> StaticCow<[StaticCow<str>]> {\n     // Apple platforms only officially support macOS as a host for any compilation.\n     //\n-    // If building for macOS, we go ahead and remove any erronous environment state\n+    // If building for macOS, we go ahead and remove any erroneous environment state\n     // that's only applicable to cross-OS compilation. Always leave anything for the\n     // host OS alone though.\n     if os == \"macos\" {"}, {"sha": "1db1d7e85adcc5fde9d05b5d4f354e13b225f718", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -804,7 +804,7 @@ impl ToJson for StackProbeType {\n \n bitflags::bitflags! {\n     #[derive(Default, Encodable, Decodable)]\n-    pub struct SanitizerSet: u8 {\n+    pub struct SanitizerSet: u16 {\n         const ADDRESS = 1 << 0;\n         const LEAK    = 1 << 1;\n         const MEMORY  = 1 << 2;\n@@ -813,6 +813,7 @@ bitflags::bitflags! {\n         const CFI     = 1 << 5;\n         const MEMTAG  = 1 << 6;\n         const SHADOWCALLSTACK = 1 << 7;\n+        const KCFI    = 1 << 8;\n     }\n }\n \n@@ -824,6 +825,7 @@ impl SanitizerSet {\n         Some(match self {\n             SanitizerSet::ADDRESS => \"address\",\n             SanitizerSet::CFI => \"cfi\",\n+            SanitizerSet::KCFI => \"kcfi\",\n             SanitizerSet::LEAK => \"leak\",\n             SanitizerSet::MEMORY => \"memory\",\n             SanitizerSet::MEMTAG => \"memtag\",\n@@ -859,6 +861,7 @@ impl IntoIterator for SanitizerSet {\n         [\n             SanitizerSet::ADDRESS,\n             SanitizerSet::CFI,\n+            SanitizerSet::KCFI,\n             SanitizerSet::LEAK,\n             SanitizerSet::MEMORY,\n             SanitizerSet::MEMTAG,\n@@ -2327,6 +2330,7 @@ impl Target {\n                             base.$key_name |= match s.as_str() {\n                                 Some(\"address\") => SanitizerSet::ADDRESS,\n                                 Some(\"cfi\") => SanitizerSet::CFI,\n+                                Some(\"kcfi\") => SanitizerSet::KCFI,\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n                                 Some(\"memory\") => SanitizerSet::MEMORY,\n                                 Some(\"memtag\") => SanitizerSet::MEMTAG,"}, {"sha": "a0476d542e6424a1fb3ba2593dd88c3fcc406cf4", "filename": "compiler/rustc_target/src/spec/wasm32_wasi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_wasi.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -104,6 +104,10 @@ pub fn target() -> Target {\n     // `args::args()` makes the WASI API calls itself.\n     options.main_needs_argc_argv = false;\n \n+    // And, WASI mangles the name of \"main\" to distinguish between different\n+    // signatures.\n+    options.entry_name = \"__main_void\".into();\n+\n     Target {\n         llvm_target: \"wasm32-wasi\".into(),\n         pointer_width: 32,"}, {"sha": "32060c35c11b835da211d0dee16e652294082cd8", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -5,7 +5,7 @@\n // features.\n \n use super::{Cc, CodeModel, LinkerFlavor, Lld, PanicStrategy};\n-use super::{RelroLevel, StackProbeType, Target, TargetOptions};\n+use super::{RelroLevel, SanitizerSet, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let opts = TargetOptions {\n@@ -20,6 +20,7 @@ pub fn target() -> Target {\n         features:\n             \"-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float\"\n                 .into(),\n+        supported_sanitizers: SanitizerSet::KCFI,\n         disable_redzone: true,\n         panic_strategy: PanicStrategy::Abort,\n         code_model: Some(CodeModel::Kernel),"}, {"sha": "443d57aaf3dce8cc63b9606b1786b5be6d963e14", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2413,19 +2413,19 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::ExprBindingObligation(item_def_id, span, ..) => {\n                 let item_name = tcx.def_path_str(item_def_id);\n                 let mut multispan = MultiSpan::from(span);\n+                let sm = tcx.sess.source_map();\n                 if let Some(ident) = tcx.opt_item_ident(item_def_id) {\n-                    let sm = tcx.sess.source_map();\n                     let same_line =\n                         match (sm.lookup_line(ident.span.hi()), sm.lookup_line(span.lo())) {\n                             (Ok(l), Ok(r)) => l.line == r.line,\n                             _ => true,\n                         };\n-                    if !ident.span.is_dummy() && !ident.span.overlaps(span) && !same_line {\n+                    if ident.span.is_visible(sm) && !ident.span.overlaps(span) && !same_line {\n                         multispan.push_span_label(ident.span, \"required by a bound in this\");\n                     }\n                 }\n                 let descr = format!(\"required by a bound in `{}`\", item_name);\n-                if !span.is_dummy() {\n+                if span.is_visible(sm) {\n                     let msg = format!(\"required by this bound in `{}`\", item_name);\n                     multispan.push_span_label(span, msg);\n                     err.span_note(multispan, &descr);"}, {"sha": "ea4bf42c515b5fb5a7aa83413b4d3eca80236736", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 366, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -4,7 +4,6 @@\n \n pub mod auto_trait;\n mod chalk_fulfill;\n-pub mod codegen;\n mod coherence;\n pub mod const_evaluatable;\n mod engine;\n@@ -20,25 +19,21 @@ mod select;\n mod specialize;\n mod structural_match;\n mod util;\n+mod vtable;\n pub mod wf;\n \n-use crate::errors::DumpVTableEntries;\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{\n-    self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeSuperVisitable, VtblEntry,\n-};\n+use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_span::{sym, Span};\n-use smallvec::SmallVec;\n+use rustc_span::Span;\n \n use std::fmt::Debug;\n use std::ops::ControlFlow;\n@@ -567,369 +562,12 @@ fn is_impossible_method<'tcx>(\n     false\n }\n \n-#[derive(Clone, Debug)]\n-enum VtblSegment<'tcx> {\n-    MetadataDSA,\n-    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n-}\n-\n-/// Prepare the segments for a vtable\n-fn prepare_vtable_segments<'tcx, T>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n-) -> Option<T> {\n-    // The following constraints holds for the final arrangement.\n-    // 1. The whole virtual table of the first direct super trait is included as the\n-    //    the prefix. If this trait doesn't have any super traits, then this step\n-    //    consists of the dsa metadata.\n-    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n-    //    other super traits except those already included as part of the first\n-    //    direct super trait virtual table.\n-    // 3. finally, the own methods of this trait.\n-\n-    // This has the advantage that trait upcasting to the first direct super trait on each level\n-    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n-    // while not using too much extra memory.\n-\n-    // For a single inheritance relationship like this,\n-    //   D --> C --> B --> A\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, D\n-\n-    // For a multiple inheritance relationship like this,\n-    //   D --> C --> A\n-    //           \\-> B\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D\n-\n-    // For a diamond inheritance relationship like this,\n-    //   D --> B --> A\n-    //     \\-> C -/\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, C, C-vptr, D\n-\n-    // For a more complex inheritance relationship like this:\n-    //   O --> G --> C --> A\n-    //     \\     \\     \\-> B\n-    //     |     |-> F --> D\n-    //     |           \\-> E\n-    //     |-> N --> J --> H\n-    //           \\     \\-> I\n-    //           |-> M --> K\n-    //                 \\-> L\n-    // The resulting vtable will consists of these segments:\n-    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n-    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n-    //  N, N-vptr, O\n-\n-    // emit dsa segment first.\n-    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n-        return Some(v);\n-    }\n-\n-    let mut emit_vptr_on_new_entry = false;\n-    let mut visited = util::PredicateSet::new(tcx);\n-    let predicate = trait_ref.without_const().to_predicate(tcx);\n-    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n-        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n-    visited.insert(predicate);\n-\n-    // the main traversal loop:\n-    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n-    // that each node is emitted after all its descendents have been emitted.\n-    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n-    // this is done on the fly.\n-    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n-    // stops after it finds a node that has a next-sibling node.\n-    // This next-sibling node will used as the starting point of next slice.\n-\n-    // Example:\n-    // For a diamond inheritance relationship like this,\n-    //   D#1 --> B#0 --> A#0\n-    //     \\-> C#1 -/\n-\n-    // Starting point 0 stack [D]\n-    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n-    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n-    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n-    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n-    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n-    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n-    // Loop run #1: Stack after exiting out is []. Now the function exits.\n-\n-    loop {\n-        // dive deeper into the stack, recording the path\n-        'diving_in: loop {\n-            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n-                let inner_most_trait_ref = *inner_most_trait_ref;\n-                let mut direct_super_traits_iter = tcx\n-                    .super_predicates_of(inner_most_trait_ref.def_id())\n-                    .predicates\n-                    .into_iter()\n-                    .filter_map(move |(pred, _)| {\n-                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n-                    });\n-\n-                'diving_in_skip_visited_traits: loop {\n-                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n-                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n-                            // We're throwing away potential constness of super traits here.\n-                            // FIXME: handle ~const super traits\n-                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n-                            stack.push((\n-                                next_super_trait,\n-                                emit_vptr_on_new_entry,\n-                                Some(direct_super_traits_iter),\n-                            ));\n-                            break 'diving_in_skip_visited_traits;\n-                        } else {\n-                            continue 'diving_in_skip_visited_traits;\n-                        }\n-                    } else {\n-                        break 'diving_in;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Other than the left-most path, vptr should be emitted for each trait.\n-        emit_vptr_on_new_entry = true;\n-\n-        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n-        'exiting_out: loop {\n-            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n-                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n-                    trait_ref: *inner_most_trait_ref,\n-                    emit_vptr: *emit_vptr,\n-                }) {\n-                    return Some(v);\n-                }\n-\n-                'exiting_out_skip_visited_traits: loop {\n-                    if let Some(siblings) = siblings_opt {\n-                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n-                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n-                                // We're throwing away potential constness of super traits here.\n-                                // FIXME: handle ~const super traits\n-                                let next_inner_most_trait_ref =\n-                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n-                                *inner_most_trait_ref = next_inner_most_trait_ref;\n-                                *emit_vptr = emit_vptr_on_new_entry;\n-                                break 'exiting_out;\n-                            } else {\n-                                continue 'exiting_out_skip_visited_traits;\n-                            }\n-                        }\n-                    }\n-                    stack.pop();\n-                    continue 'exiting_out;\n-                }\n-            }\n-            // all done\n-            return None;\n-        }\n-    }\n-}\n-\n-fn dump_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    sp: Span,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-    entries: &[VtblEntry<'tcx>],\n-) {\n-    tcx.sess.emit_err(DumpVTableEntries {\n-        span: sp,\n-        trait_ref,\n-        entries: format!(\"{:#?}\", entries),\n-    });\n-}\n-\n-fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n-    let trait_methods = tcx\n-        .associated_items(trait_def_id)\n-        .in_definition_order()\n-        .filter(|item| item.kind == ty::AssocKind::Fn);\n-    // Now list each method's DefId (for within its trait).\n-    let own_entries = trait_methods.filter_map(move |trait_method| {\n-        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n-        let def_id = trait_method.def_id;\n-\n-        // Some methods cannot be called on an object; skip those.\n-        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n-            debug!(\"own_existential_vtable_entry: not vtable safe\");\n-            return None;\n-        }\n-\n-        Some(def_id)\n-    });\n-\n-    tcx.arena.alloc_from_iter(own_entries.into_iter())\n-}\n-\n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-fn vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [VtblEntry<'tcx>] {\n-    debug!(\"vtable_entries({:?})\", trait_ref);\n-\n-    let mut entries = vec![];\n-\n-    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n-        match segment {\n-            VtblSegment::MetadataDSA => {\n-                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n-            }\n-            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                let existential_trait_ref = trait_ref\n-                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n-\n-                // Lookup the shape of vtable for the trait.\n-                let own_existential_entries =\n-                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n-\n-                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n-                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n-\n-                    // The method may have some early-bound lifetimes; add regions for those.\n-                    let substs = trait_ref.map_bound(|trait_ref| {\n-                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                            GenericParamDefKind::Type { .. }\n-                            | GenericParamDefKind::Const { .. } => {\n-                                trait_ref.substs[param.index as usize]\n-                            }\n-                        })\n-                    });\n-\n-                    // The trait type may have higher-ranked lifetimes in it;\n-                    // erase them if they appear, so that we get the type\n-                    // at some particular call site.\n-                    let substs = tcx\n-                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n-\n-                    // It's possible that the method relies on where-clauses that\n-                    // do not hold for this particular set of type parameters.\n-                    // Note that this method could then never be called, so we\n-                    // do not want to try and codegen it, in that case (see #23435).\n-                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-                    if impossible_predicates(tcx, predicates.predicates) {\n-                        debug!(\"vtable_entries: predicates do not hold\");\n-                        return VtblEntry::Vacant;\n-                    }\n-\n-                    let instance = ty::Instance::resolve_for_vtable(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        def_id,\n-                        substs,\n-                    )\n-                    .expect(\"resolution failed during building vtable representation\");\n-                    VtblEntry::Method(instance)\n-                });\n-\n-                entries.extend(own_entries);\n-\n-                if emit_vptr {\n-                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n-                }\n-            }\n-        }\n-\n-        ControlFlow::Continue(())\n-    };\n-\n-    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n-\n-    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n-        let sp = tcx.def_span(trait_ref.def_id());\n-        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n-    }\n-\n-    tcx.arena.alloc_from_iter(entries.into_iter())\n-}\n-\n-/// Find slot base for trait methods within vtable entries of another trait\n-fn vtable_trait_first_method_offset<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n-        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n-    ),\n-) -> usize {\n-    let (trait_to_be_found, trait_owning_vtable) = key;\n-\n-    // #90177\n-    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n-\n-    let vtable_segment_callback = {\n-        let mut vtable_base = 0;\n-\n-        move |segment| {\n-            match segment {\n-                VtblSegment::MetadataDSA => {\n-                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n-                }\n-                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n-                        return ControlFlow::Break(vtable_base);\n-                    }\n-                    vtable_base += util::count_own_vtable_entries(tcx, trait_ref);\n-                    if emit_vptr {\n-                        vtable_base += 1;\n-                    }\n-                }\n-            }\n-            ControlFlow::Continue(())\n-        }\n-    };\n-\n-    if let Some(vtable_base) =\n-        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n-    {\n-        vtable_base\n-    } else {\n-        bug!(\"Failed to find info for expected trait in vtable\");\n-    }\n-}\n-\n-/// Find slot offset for trait vptr within vtable entries of another trait\n-pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (\n-        Ty<'tcx>, // trait object type whose trait owning vtable\n-        Ty<'tcx>, // trait object for supertrait\n-    ),\n-) -> Option<usize> {\n-    let (source, target) = key;\n-    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n-    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n-\n-    // this has been typecked-before, so diagnostics is not really needed.\n-    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n-\n-    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n-\n-    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n-        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n-            implsrc_traitcasting.vtable_vptr_slot\n-        }\n-        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers) {\n     object_safety::provide(providers);\n-    structural_match::provide(providers);\n+    vtable::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,\n-        codegen_select_candidate: codegen::codegen_select_candidate,\n-        own_existential_vtable_entries,\n-        vtable_entries,\n-        vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         is_impossible_method,\n         ..*providers"}, {"sha": "fda415155c469b556c3206ad8223431625388eaa", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,14 +19,18 @@ use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::vtable::{\n+    count_own_vtable_entries, prepare_vtable_segments, vtable_trait_first_method_offset,\n+    VtblSegment,\n+};\n use crate::traits::{\n     BuiltinDerivedObligation, ImplDerivedObligation, ImplDerivedObligationCause, ImplSource,\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceConstDestructData, ImplSourceFnPointerData, ImplSourceFutureData,\n     ImplSourceGeneratorData, ImplSourceObjectData, ImplSourceTraitAliasData,\n     ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized, ObjectCastObligation,\n     Obligation, ObligationCause, OutputTypeParameterMismatch, PredicateObligation, Selection,\n-    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented, VtblSegment,\n+    SelectionError, TraitNotObjectSafe, TraitObligation, Unimplemented,\n };\n \n use super::BuiltinImplConditions;\n@@ -583,7 +587,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(?nested, \"object nested obligations\");\n \n-        let vtable_base = super::super::vtable_trait_first_method_offset(\n+        let vtable_base = vtable_trait_first_method_offset(\n             tcx,\n             (unnormalized_upcast_trait_ref, ty::Binder::dummy(object_trait_ref)),\n         );\n@@ -904,7 +908,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         vptr_offset += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                     }\n                     VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n-                        vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);\n+                        vptr_offset += count_own_vtable_entries(tcx, trait_ref);\n                         if trait_ref == upcast_trait_ref {\n                             if emit_vptr {\n                                 return ControlFlow::Break(Some(vptr_offset));\n@@ -923,8 +927,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let vtable_vptr_slot =\n-            super::super::prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback)\n-                .unwrap();\n+            prepare_vtable_segments(tcx, source_trait_ref, vtable_segment_callback).unwrap();\n \n         Ok(ImplSourceTraitUpcastingData { upcast_trait_ref, vtable_vptr_slot, nested })\n     }"}, {"sha": "4dc08e0f9dab0da99be2c049b08e755c9f7c5b04", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,10 +1,5 @@\n-use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::{ObligationCause, ObligationCtxt};\n-\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::lang_items::LangItem;\n-use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_span::Span;\n use std::ops::ControlFlow;\n@@ -59,41 +54,6 @@ pub fn search_for_adt_const_param_violation<'tcx>(\n         .break_value()\n }\n \n-/// This method returns true if and only if `adt_ty` itself has been marked as\n-/// eligible for structural-match: namely, if it implements both\n-/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n-/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n-///\n-/// Note that this does *not* recursively check if the substructure of `adt_ty`\n-/// implements the traits.\n-fn type_marked_structural<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    adt_ty: Ty<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> bool {\n-    let ocx = ObligationCtxt::new(infcx);\n-    // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id =\n-        infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n-    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n-    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n-    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let structural_teq_def_id =\n-        infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n-    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n-\n-    // We deliberately skip *reporting* fulfillment errors (via\n-    // `report_fulfillment_errors`), for two reasons:\n-    //\n-    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n-    //    (a trait which is solely meant as an implementation detail\n-    //    for now), and\n-    //\n-    // 2. We are sometimes doing future-incompatibility lints for\n-    //    now, so we do not want unconditional errors here.\n-    ocx.select_all_or_error().is_empty()\n-}\n-\n /// This implements the traversal over the structure of a given type to try to\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n@@ -249,11 +209,3 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n         })\n     }\n }\n-\n-pub fn provide(providers: &mut Providers) {\n-    providers.has_structural_eq_impls = |tcx, ty| {\n-        let infcx = tcx.infer_ctxt().build();\n-        let cause = ObligationCause::dummy();\n-        type_marked_structural(&infcx, ty, cause)\n-    };\n-}"}, {"sha": "f3ca6a6c779a06b9ca34b584dde18fe5775f0516", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -261,16 +261,6 @@ pub fn upcast_choices<'tcx>(\n     supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n }\n \n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> usize {\n-    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n-}\n-\n /// Given an upcast trait object described by `object`, returns the\n /// index of the method `method_def_id` (which should be part of\n /// `object.upcast_trait_ref`) within the vtable for `object`."}, {"sha": "41ce6cdf789da381d32e3ec2f158faf63045afe9", "filename": "compiler/rustc_trait_selection/src/traits/vtable.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fvtable.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,386 @@\n+use crate::errors::DumpVTableEntries;\n+use crate::traits::{impossible_predicates, is_vtable_safe_method};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_infer::traits::util::PredicateSet;\n+use rustc_infer::traits::ImplSource;\n+use rustc_middle::ty::visit::TypeVisitable;\n+use rustc_middle::ty::InternalSubsts;\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n+use rustc_span::{sym, Span};\n+use smallvec::SmallVec;\n+\n+use std::fmt::Debug;\n+use std::ops::ControlFlow;\n+\n+#[derive(Clone, Debug)]\n+pub(super) enum VtblSegment<'tcx> {\n+    MetadataDSA,\n+    TraitOwnEntries { trait_ref: ty::PolyTraitRef<'tcx>, emit_vptr: bool },\n+}\n+\n+/// Prepare the segments for a vtable\n+pub(super) fn prepare_vtable_segments<'tcx, T>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    mut segment_visitor: impl FnMut(VtblSegment<'tcx>) -> ControlFlow<T>,\n+) -> Option<T> {\n+    // The following constraints holds for the final arrangement.\n+    // 1. The whole virtual table of the first direct super trait is included as the\n+    //    the prefix. If this trait doesn't have any super traits, then this step\n+    //    consists of the dsa metadata.\n+    // 2. Then comes the proper pointer metadata(vptr) and all own methods for all\n+    //    other super traits except those already included as part of the first\n+    //    direct super trait virtual table.\n+    // 3. finally, the own methods of this trait.\n+\n+    // This has the advantage that trait upcasting to the first direct super trait on each level\n+    // is zero cost, and to another trait includes only replacing the pointer with one level indirection,\n+    // while not using too much extra memory.\n+\n+    // For a single inheritance relationship like this,\n+    //   D --> C --> B --> A\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, D\n+\n+    // For a multiple inheritance relationship like this,\n+    //   D --> C --> A\n+    //           \\-> B\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D\n+\n+    // For a diamond inheritance relationship like this,\n+    //   D --> B --> A\n+    //     \\-> C -/\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, C, C-vptr, D\n+\n+    // For a more complex inheritance relationship like this:\n+    //   O --> G --> C --> A\n+    //     \\     \\     \\-> B\n+    //     |     |-> F --> D\n+    //     |           \\-> E\n+    //     |-> N --> J --> H\n+    //           \\     \\-> I\n+    //           |-> M --> K\n+    //                 \\-> L\n+    // The resulting vtable will consists of these segments:\n+    //  DSA, A, B, B-vptr, C, D, D-vptr, E, E-vptr, F, F-vptr, G,\n+    //  H, H-vptr, I, I-vptr, J, J-vptr, K, K-vptr, L, L-vptr, M, M-vptr,\n+    //  N, N-vptr, O\n+\n+    // emit dsa segment first.\n+    if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::MetadataDSA) {\n+        return Some(v);\n+    }\n+\n+    let mut emit_vptr_on_new_entry = false;\n+    let mut visited = PredicateSet::new(tcx);\n+    let predicate = trait_ref.without_const().to_predicate(tcx);\n+    let mut stack: SmallVec<[(ty::PolyTraitRef<'tcx>, _, _); 5]> =\n+        smallvec![(trait_ref, emit_vptr_on_new_entry, None)];\n+    visited.insert(predicate);\n+\n+    // the main traversal loop:\n+    // basically we want to cut the inheritance directed graph into a few non-overlapping slices of nodes\n+    // that each node is emitted after all its descendents have been emitted.\n+    // so we convert the directed graph into a tree by skipping all previously visited nodes using a visited set.\n+    // this is done on the fly.\n+    // Each loop run emits a slice - it starts by find a \"childless\" unvisited node, backtracking upwards, and it\n+    // stops after it finds a node that has a next-sibling node.\n+    // This next-sibling node will used as the starting point of next slice.\n+\n+    // Example:\n+    // For a diamond inheritance relationship like this,\n+    //   D#1 --> B#0 --> A#0\n+    //     \\-> C#1 -/\n+\n+    // Starting point 0 stack [D]\n+    // Loop run #0: Stack after diving in is [D B A], A is \"childless\"\n+    // after this point, all newly visited nodes won't have a vtable that equals to a prefix of this one.\n+    // Loop run #0: Emitting the slice [B A] (in reverse order), B has a next-sibling node, so this slice stops here.\n+    // Loop run #0: Stack after exiting out is [D C], C is the next starting point.\n+    // Loop run #1: Stack after diving in is [D C], C is \"childless\", since its child A is skipped(already emitted).\n+    // Loop run #1: Emitting the slice [D C] (in reverse order). No one has a next-sibling node.\n+    // Loop run #1: Stack after exiting out is []. Now the function exits.\n+\n+    loop {\n+        // dive deeper into the stack, recording the path\n+        'diving_in: loop {\n+            if let Some((inner_most_trait_ref, _, _)) = stack.last() {\n+                let inner_most_trait_ref = *inner_most_trait_ref;\n+                let mut direct_super_traits_iter = tcx\n+                    .super_predicates_of(inner_most_trait_ref.def_id())\n+                    .predicates\n+                    .into_iter()\n+                    .filter_map(move |(pred, _)| {\n+                        pred.subst_supertrait(tcx, &inner_most_trait_ref).to_opt_poly_trait_pred()\n+                    });\n+\n+                'diving_in_skip_visited_traits: loop {\n+                    if let Some(next_super_trait) = direct_super_traits_iter.next() {\n+                        if visited.insert(next_super_trait.to_predicate(tcx)) {\n+                            // We're throwing away potential constness of super traits here.\n+                            // FIXME: handle ~const super traits\n+                            let next_super_trait = next_super_trait.map_bound(|t| t.trait_ref);\n+                            stack.push((\n+                                next_super_trait,\n+                                emit_vptr_on_new_entry,\n+                                Some(direct_super_traits_iter),\n+                            ));\n+                            break 'diving_in_skip_visited_traits;\n+                        } else {\n+                            continue 'diving_in_skip_visited_traits;\n+                        }\n+                    } else {\n+                        break 'diving_in;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Other than the left-most path, vptr should be emitted for each trait.\n+        emit_vptr_on_new_entry = true;\n+\n+        // emit innermost item, move to next sibling and stop there if possible, otherwise jump to outer level.\n+        'exiting_out: loop {\n+            if let Some((inner_most_trait_ref, emit_vptr, siblings_opt)) = stack.last_mut() {\n+                if let ControlFlow::Break(v) = (segment_visitor)(VtblSegment::TraitOwnEntries {\n+                    trait_ref: *inner_most_trait_ref,\n+                    emit_vptr: *emit_vptr,\n+                }) {\n+                    return Some(v);\n+                }\n+\n+                'exiting_out_skip_visited_traits: loop {\n+                    if let Some(siblings) = siblings_opt {\n+                        if let Some(next_inner_most_trait_ref) = siblings.next() {\n+                            if visited.insert(next_inner_most_trait_ref.to_predicate(tcx)) {\n+                                // We're throwing away potential constness of super traits here.\n+                                // FIXME: handle ~const super traits\n+                                let next_inner_most_trait_ref =\n+                                    next_inner_most_trait_ref.map_bound(|t| t.trait_ref);\n+                                *inner_most_trait_ref = next_inner_most_trait_ref;\n+                                *emit_vptr = emit_vptr_on_new_entry;\n+                                break 'exiting_out;\n+                            } else {\n+                                continue 'exiting_out_skip_visited_traits;\n+                            }\n+                        }\n+                    }\n+                    stack.pop();\n+                    continue 'exiting_out;\n+                }\n+            }\n+            // all done\n+            return None;\n+        }\n+    }\n+}\n+\n+fn dump_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sp: Span,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    entries: &[VtblEntry<'tcx>],\n+) {\n+    tcx.sess.emit_err(DumpVTableEntries {\n+        span: sp,\n+        trait_ref,\n+        entries: format!(\"{:#?}\", entries),\n+    });\n+}\n+\n+fn own_existential_vtable_entries<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId) -> &'tcx [DefId] {\n+    let trait_methods = tcx\n+        .associated_items(trait_def_id)\n+        .in_definition_order()\n+        .filter(|item| item.kind == ty::AssocKind::Fn);\n+    // Now list each method's DefId (for within its trait).\n+    let own_entries = trait_methods.filter_map(move |trait_method| {\n+        debug!(\"own_existential_vtable_entry: trait_method={:?}\", trait_method);\n+        let def_id = trait_method.def_id;\n+\n+        // Some methods cannot be called on an object; skip those.\n+        if !is_vtable_safe_method(tcx, trait_def_id, &trait_method) {\n+            debug!(\"own_existential_vtable_entry: not vtable safe\");\n+            return None;\n+        }\n+\n+        Some(def_id)\n+    });\n+\n+    tcx.arena.alloc_from_iter(own_entries.into_iter())\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+fn vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [VtblEntry<'tcx>] {\n+    debug!(\"vtable_entries({:?})\", trait_ref);\n+\n+    let mut entries = vec![];\n+\n+    let vtable_segment_callback = |segment| -> ControlFlow<()> {\n+        match segment {\n+            VtblSegment::MetadataDSA => {\n+                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n+            }\n+            VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                let existential_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+\n+                // Lookup the shape of vtable for the trait.\n+                let own_existential_entries =\n+                    tcx.own_existential_vtable_entries(existential_trait_ref.def_id());\n+\n+                let own_entries = own_existential_entries.iter().copied().map(|def_id| {\n+                    debug!(\"vtable_entries: trait_method={:?}\", def_id);\n+\n+                    // The method may have some early-bound lifetimes; add regions for those.\n+                    let substs = trait_ref.map_bound(|trait_ref| {\n+                        InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                            GenericParamDefKind::Type { .. }\n+                            | GenericParamDefKind::Const { .. } => {\n+                                trait_ref.substs[param.index as usize]\n+                            }\n+                        })\n+                    });\n+\n+                    // The trait type may have higher-ranked lifetimes in it;\n+                    // erase them if they appear, so that we get the type\n+                    // at some particular call site.\n+                    let substs = tcx\n+                        .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), substs);\n+\n+                    // It's possible that the method relies on where-clauses that\n+                    // do not hold for this particular set of type parameters.\n+                    // Note that this method could then never be called, so we\n+                    // do not want to try and codegen it, in that case (see #23435).\n+                    let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+                    if impossible_predicates(tcx, predicates.predicates) {\n+                        debug!(\"vtable_entries: predicates do not hold\");\n+                        return VtblEntry::Vacant;\n+                    }\n+\n+                    let instance = ty::Instance::resolve_for_vtable(\n+                        tcx,\n+                        ty::ParamEnv::reveal_all(),\n+                        def_id,\n+                        substs,\n+                    )\n+                    .expect(\"resolution failed during building vtable representation\");\n+                    VtblEntry::Method(instance)\n+                });\n+\n+                entries.extend(own_entries);\n+\n+                if emit_vptr {\n+                    entries.push(VtblEntry::TraitVPtr(trait_ref));\n+                }\n+            }\n+        }\n+\n+        ControlFlow::Continue(())\n+    };\n+\n+    let _ = prepare_vtable_segments(tcx, trait_ref, vtable_segment_callback);\n+\n+    if tcx.has_attr(trait_ref.def_id(), sym::rustc_dump_vtable) {\n+        let sp = tcx.def_span(trait_ref.def_id());\n+        dump_vtable_entries(tcx, sp, trait_ref, &entries);\n+    }\n+\n+    tcx.arena.alloc_from_iter(entries.into_iter())\n+}\n+\n+/// Find slot base for trait methods within vtable entries of another trait\n+pub(super) fn vtable_trait_first_method_offset<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        ty::PolyTraitRef<'tcx>, // trait_to_be_found\n+        ty::PolyTraitRef<'tcx>, // trait_owning_vtable\n+    ),\n+) -> usize {\n+    let (trait_to_be_found, trait_owning_vtable) = key;\n+\n+    // #90177\n+    let trait_to_be_found_erased = tcx.erase_regions(trait_to_be_found);\n+\n+    let vtable_segment_callback = {\n+        let mut vtable_base = 0;\n+\n+        move |segment| {\n+            match segment {\n+                VtblSegment::MetadataDSA => {\n+                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n+                }\n+                VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n+                    if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {\n+                        return ControlFlow::Break(vtable_base);\n+                    }\n+                    vtable_base += count_own_vtable_entries(tcx, trait_ref);\n+                    if emit_vptr {\n+                        vtable_base += 1;\n+                    }\n+                }\n+            }\n+            ControlFlow::Continue(())\n+        }\n+    };\n+\n+    if let Some(vtable_base) =\n+        prepare_vtable_segments(tcx, trait_owning_vtable, vtable_segment_callback)\n+    {\n+        vtable_base\n+    } else {\n+        bug!(\"Failed to find info for expected trait in vtable\");\n+    }\n+}\n+\n+/// Find slot offset for trait vptr within vtable entries of another trait\n+pub(crate) fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        Ty<'tcx>, // trait object type whose trait owning vtable\n+        Ty<'tcx>, // trait object for supertrait\n+    ),\n+) -> Option<usize> {\n+    let (source, target) = key;\n+    assert!(matches!(&source.kind(), &ty::Dynamic(..)) && !source.needs_infer());\n+    assert!(matches!(&target.kind(), &ty::Dynamic(..)) && !target.needs_infer());\n+\n+    // this has been typecked-before, so diagnostics is not really needed.\n+    let unsize_trait_did = tcx.require_lang_item(LangItem::Unsize, None);\n+\n+    let trait_ref = tcx.mk_trait_ref(unsize_trait_did, [source, target]);\n+\n+    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n+        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n+            implsrc_traitcasting.vtable_vptr_slot\n+        }\n+        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n+    }\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub(crate) fn count_own_vtable_entries<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> usize {\n+    tcx.own_existential_vtable_entries(trait_ref.def_id()).len()\n+}\n+\n+pub(super) fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers {\n+        own_existential_vtable_entries,\n+        vtable_entries,\n+        vtable_trait_upcasting_coercion_new_vptr_slot,\n+        ..*providers\n+    };\n+}"}, {"sha": "f8f74b732efd3c20c0653b9d742afe596202bbb7", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -3,15 +3,15 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n-use crate::traits::error_reporting::TypeErrCtxtExt;\n-use crate::traits::{\n-    ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n-    Unimplemented,\n-};\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_infer::traits::FulfillmentErrorCode;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::{\n+    ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine, TraitEngineExt,\n+    Unimplemented,\n+};\n \n /// Attempts to resolve an obligation to an `ImplSource`. The result is\n /// a shallow `ImplSource` resolution, meaning that we do not", "previous_filename": "compiler/rustc_trait_selection/src/traits/codegen.rs"}, {"sha": "9aa26667e7bf461ef3059ade70551ccff81ee75e", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -12,6 +12,7 @@ extern crate tracing;\n extern crate rustc_middle;\n \n mod chalk;\n+mod codegen;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod implied_outlives_bounds;\n@@ -31,4 +32,5 @@ pub fn provide(p: &mut Providers) {\n     normalize_projection_ty::provide(p);\n     normalize_erasing_regions::provide(p);\n     type_op::provide(p);\n+    p.codegen_select_candidate = codegen::codegen_select_candidate;\n }"}, {"sha": "d644cbccea11b2df6c5080a2191ad3c1c8b8f4f1", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -85,7 +85,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 bound_vars,\n             )\n         }\n-        ty::Generator(_, substs, _) => {\n+        ty::Generator(did, substs, _) => {\n             let sig = substs.as_generator().poly_sig();\n \n             let bound_vars = tcx.mk_bound_variable_kinds(\n@@ -104,10 +104,22 @@ fn fn_sig_for_fn_abi<'tcx>(\n             let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n             let sig = sig.skip_binder();\n-            let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-            let state_adt_ref = tcx.adt_def(state_did);\n-            let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-            let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+            // The `FnSig` and the `ret_ty` here is for a generators main\n+            // `Generator::resume(...) -> GeneratorState` function in case we\n+            // have an ordinary generator, or the `Future::poll(...) -> Poll`\n+            // function in case this is a special generator backing an async construct.\n+            let ret_ty = if tcx.generator_is_async(did) {\n+                let state_did = tcx.require_lang_item(LangItem::Poll, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n+                tcx.mk_adt(state_adt_ref, state_substs)\n+            } else {\n+                let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                tcx.mk_adt(state_adt_ref, state_substs)\n+            };\n+\n             ty::Binder::bind_with_vars(\n                 tcx.mk_fn_sig(\n                     [env_ty, sig.resume_ty].iter(),"}, {"sha": "f4672a70072b2b30ce8435d350d898bfa2e8c4c3", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 116, "deletions": 27, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,3 +1,4 @@\n+use hir::def_id::DefId;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -6,7 +7,7 @@ use rustc_middle::ty::layout::{\n     IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n };\n use rustc_middle::ty::{\n-    self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n+    self, subst::SubstsRef, AdtDef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::Symbol;\n@@ -814,27 +815,39 @@ fn record_layout_for_printing_outlined<'tcx>(\n         );\n     };\n \n-    let adt_def = match *layout.ty.kind() {\n-        ty::Adt(ref adt_def, _) => {\n+    match *layout.ty.kind() {\n+        ty::Adt(adt_def, _) => {\n             debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n-            adt_def\n+            let adt_kind = adt_def.adt_kind();\n+            let adt_packed = adt_def.repr().pack.is_some();\n+            let (variant_infos, opt_discr_size) = variant_info_for_adt(cx, layout, adt_def);\n+            record(adt_kind.into(), adt_packed, opt_discr_size, variant_infos);\n+        }\n+\n+        ty::Generator(def_id, substs, _) => {\n+            debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n+            // Generators always have a begin/poisoned/end state with additional suspend points\n+            let (variant_infos, opt_discr_size) =\n+                variant_info_for_generator(cx, layout, def_id, substs);\n+            record(DataTypeKind::Generator, false, opt_discr_size, variant_infos);\n         }\n \n         ty::Closure(..) => {\n             debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n             record(DataTypeKind::Closure, false, None, vec![]);\n-            return;\n         }\n \n         _ => {\n             debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n-            return;\n         }\n     };\n+}\n \n-    let adt_kind = adt_def.adt_kind();\n-    let adt_packed = adt_def.repr().pack.is_some();\n-\n+fn variant_info_for_adt<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    adt_def: AdtDef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n     let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n         let mut min_size = Size::ZERO;\n         let field_info: Vec<_> = flds\n@@ -843,10 +856,7 @@ fn record_layout_for_printing_outlined<'tcx>(\n             .map(|(i, &name)| {\n                 let field_layout = layout.field(cx, i);\n                 let offset = layout.fields.offset(i);\n-                let field_end = offset + field_layout.size;\n-                if min_size < field_end {\n-                    min_size = field_end;\n-                }\n+                min_size = min_size.max(offset + field_layout.size);\n                 FieldInfo {\n                     name,\n                     offset: offset.bytes(),\n@@ -871,16 +881,9 @@ fn record_layout_for_printing_outlined<'tcx>(\n                 debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n                 let variant_def = &adt_def.variant(index);\n                 let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                record(\n-                    adt_kind.into(),\n-                    adt_packed,\n-                    None,\n-                    vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n-                );\n+                (vec![build_variant_info(Some(variant_def.name), &fields, layout)], None)\n             } else {\n-                // (This case arises for *empty* enums; so give it\n-                // zero variants.)\n-                record(adt_kind.into(), adt_packed, None, vec![]);\n+                (vec![], None)\n             }\n         }\n \n@@ -898,15 +901,101 @@ fn record_layout_for_printing_outlined<'tcx>(\n                     build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n                 })\n                 .collect();\n-            record(\n-                adt_kind.into(),\n-                adt_packed,\n+\n+            (\n+                variant_infos,\n                 match tag_encoding {\n                     TagEncoding::Direct => Some(tag.size(cx)),\n                     _ => None,\n                 },\n-                variant_infos,\n-            );\n+            )\n         }\n     }\n }\n+\n+fn variant_info_for_generator<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    def_id: DefId,\n+    substs: ty::SubstsRef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n+    let Variants::Multiple { tag, ref tag_encoding, .. } = layout.variants else {\n+        return (vec![], None);\n+    };\n+\n+    let (generator, state_specific_names) = cx.tcx.generator_layout_and_saved_local_names(def_id);\n+    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n+\n+    let mut upvars_size = Size::ZERO;\n+    let upvar_fields: Vec<_> = substs\n+        .as_generator()\n+        .upvar_tys()\n+        .zip(upvar_names)\n+        .enumerate()\n+        .map(|(field_idx, (_, name))| {\n+            let field_layout = layout.field(cx, field_idx);\n+            let offset = layout.fields.offset(field_idx);\n+            upvars_size = upvars_size.max(offset + field_layout.size);\n+            FieldInfo {\n+                name: Symbol::intern(&name),\n+                offset: offset.bytes(),\n+                size: field_layout.size.bytes(),\n+                align: field_layout.align.abi.bytes(),\n+            }\n+        })\n+        .collect();\n+\n+    let variant_infos: Vec<_> = generator\n+        .variant_fields\n+        .iter_enumerated()\n+        .map(|(variant_idx, variant_def)| {\n+            let variant_layout = layout.for_variant(cx, variant_idx);\n+            let mut variant_size = Size::ZERO;\n+            let fields = variant_def\n+                .iter()\n+                .enumerate()\n+                .map(|(field_idx, local)| {\n+                    let field_layout = variant_layout.field(cx, field_idx);\n+                    let offset = variant_layout.fields.offset(field_idx);\n+                    // The struct is as large as the last field's end\n+                    variant_size = variant_size.max(offset + field_layout.size);\n+                    FieldInfo {\n+                        name: state_specific_names.get(*local).copied().flatten().unwrap_or(\n+                            Symbol::intern(&format!(\".generator_field{}\", local.as_usize())),\n+                        ),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n+                    }\n+                })\n+                .chain(upvar_fields.iter().copied())\n+                .collect();\n+\n+            // If the variant has no state-specific fields, then it's the size of the upvars.\n+            if variant_size == Size::ZERO {\n+                variant_size = upvars_size;\n+            }\n+            // We need to add the discriminant size back into min_size, since it is subtracted\n+            // later during printing.\n+            variant_size += match tag_encoding {\n+                TagEncoding::Direct => tag.size(cx),\n+                _ => Size::ZERO,\n+            };\n+\n+            VariantInfo {\n+                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(variant_idx))),\n+                kind: SizeKind::Exact,\n+                size: variant_size.bytes(),\n+                align: variant_layout.align.abi.bytes(),\n+                fields,\n+            }\n+        })\n+        .collect();\n+    (\n+        variant_infos,\n+        match tag_encoding {\n+            TagEncoding::Direct => Some(tag.size(cx)),\n+            _ => None,\n+        },\n+    )\n+}"}, {"sha": "7ad5cbc01ccf25293c116f05025bca179b33d0e3", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,6 +29,7 @@ mod layout;\n mod layout_sanity_check;\n mod needs_drop;\n pub mod representability;\n+mod structural_match;\n mod ty;\n \n pub fn provide(providers: &mut Providers) {\n@@ -42,4 +43,5 @@ pub fn provide(providers: &mut Providers) {\n     representability::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);\n+    structural_match::provide(providers);\n }"}, {"sha": "a55bb7e7e904d224b8d1f70b492a695f90719509", "filename": "compiler/rustc_ty_utils/src/structural_match.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fstructural_match.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,44 @@\n+use rustc_hir::lang_items::LangItem;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n+\n+/// This method returns true if and only if `adt_ty` itself has been marked as\n+/// eligible for structural-match: namely, if it implements both\n+/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n+/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n+///\n+/// Note that this does *not* recursively check if the substructure of `adt_ty`\n+/// implements the traits.\n+fn has_structural_eq_impls<'tcx>(tcx: TyCtxt<'tcx>, adt_ty: Ty<'tcx>) -> bool {\n+    let ref infcx = tcx.infer_ctxt().build();\n+    let cause = ObligationCause::dummy();\n+\n+    let ocx = ObligationCtxt::new(infcx);\n+    // require `#[derive(PartialEq)]`\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n+    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n+    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n+    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n+    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n+\n+    // We deliberately skip *reporting* fulfillment errors (via\n+    // `report_fulfillment_errors`), for two reasons:\n+    //\n+    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n+    //    (a trait which is solely meant as an implementation detail\n+    //    for now), and\n+    //\n+    // 2. We are sometimes doing future-incompatibility lints for\n+    //    now, so we do not want unconditional errors here.\n+    ocx.select_all_or_error().is_empty()\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.has_structural_eq_impls = has_structural_eq_impls;\n+}"}, {"sha": "5e1d2f2e314ff904173d04c224797cd2b017b5f2", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -35,17 +35,16 @@ changelog-seen = 2\n # Unless you're developing for a target where Rust CI doesn't build a compiler\n # toolchain or changing LLVM locally, you probably want to set this to true.\n #\n-# This is false by default so that distributions don't unexpectedly download\n-# LLVM from the internet.\n-#\n # All tier 1 targets are currently supported; set this to `\"if-available\"` if\n # you are not sure whether you're on a tier 1 target.\n #\n # We also currently only support this when building LLVM for the build triple.\n #\n # Note that many of the LLVM options are not currently supported for\n # downloading. Currently only the \"assertions\" option can be toggled.\n-#download-ci-llvm = false\n+#\n+# Defaults to \"if-available\" when `channel = \"dev\"` and \"false\" otherwise.\n+#download-ci-llvm = \"if-available\"\n \n # Indicates whether LLVM rebuild should be skipped when running bootstrap. If\n # this is `false` then the compiler's LLVM will be rebuilt whenever the built"}, {"sha": "e54880e8652305b7f173d08f48aae0b18276212d", "filename": "library/alloc/src/collections/vec_deque/into_iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Finto_iter.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -25,6 +25,10 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(super) fn new(inner: VecDeque<T, A>) -> Self {\n         IntoIter { inner }\n     }\n+\n+    pub(super) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        self.inner\n+    }\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]"}, {"sha": "4b9bd74d3924f49a93abb03a3e56b645566de6cf", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -55,6 +55,10 @@ use self::spec_extend::SpecExtend;\n \n mod spec_extend;\n \n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -586,6 +590,38 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }\n     }\n \n+    /// Creates a `VecDeque` from a raw allocation, when the initialized\n+    /// part of that allocation forms a *contiguous* subslice thereof.\n+    ///\n+    /// For use by `vec::IntoIter::into_vecdeque`\n+    ///\n+    /// # Safety\n+    ///\n+    /// All the usual requirements on the allocated memory like in\n+    /// `Vec::from_raw_parts_in`, but takes a *range* of elements that are\n+    /// initialized rather than only supporting `0..len`.  Requires that\n+    /// `initialized.start` \u2264 `initialized.end` \u2264 `capacity`.\n+    #[inline]\n+    pub(crate) unsafe fn from_contiguous_raw_parts_in(\n+        ptr: *mut T,\n+        initialized: Range<usize>,\n+        capacity: usize,\n+        alloc: A,\n+    ) -> Self {\n+        debug_assert!(initialized.start <= initialized.end);\n+        debug_assert!(initialized.end <= capacity);\n+\n+        // SAFETY: Our safety precondition guarantees the range length won't wrap,\n+        // and that the allocation is valid for use in `RawVec`.\n+        unsafe {\n+            VecDeque {\n+                head: initialized.start,\n+                len: initialized.end.unchecked_sub(initialized.start),\n+                buf: RawVec::from_raw_parts_in(ptr, capacity, alloc),\n+            }\n+        }\n+    }\n+\n     /// Provides a reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n@@ -2699,18 +2735,8 @@ impl<T, A: Allocator> IndexMut<usize> for VecDeque<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> FromIterator<T> for VecDeque<T> {\n-    #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {\n-        // Since converting is O(1) now, might as well re-use that logic\n-        // (including things like the `vec::IntoIter`\u2192`Vec` specialization)\n-        // especially as that could save us some monomorphiziation work\n-        // if one uses the same iterators (like slice ones) with both.\n-        return from_iter_via_vec(iter.into_iter());\n-\n-        #[inline]\n-        fn from_iter_via_vec<U>(iter: impl Iterator<Item = U>) -> VecDeque<U> {\n-            Vec::from_iter(iter).into()\n-        }\n+        SpecFromIter::spec_from_iter(iter.into_iter())\n     }\n }\n "}, {"sha": "7650492ebdad1500c4167bfcc69f6f53998bb35c", "filename": "library/alloc/src/collections/vec_deque/spec_from_iter.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,33 @@\n+use super::{IntoIter, VecDeque};\n+\n+/// Specialization trait used for `VecDeque::from_iter`\n+pub(super) trait SpecFromIter<T, I> {\n+    fn spec_from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for VecDeque<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_from_iter(iterator: I) -> Self {\n+        // Since converting is O(1) now, just re-use the `Vec` logic for\n+        // anything where we can't do something extra-special for `VecDeque`,\n+        // especially as that could save us some monomorphiziation work\n+        // if one uses the same iterators (like slice ones) with both.\n+        crate::vec::Vec::from_iter(iterator).into()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, crate::vec::IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: crate::vec::IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for VecDeque<T> {\n+    #[inline]\n+    fn spec_from_iter(iterator: IntoIter<T>) -> Self {\n+        iterator.into_vecdeque()\n+    }\n+}"}, {"sha": "6bcde6d899ce81776fe8dc55c20d528daec84472", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,6 +1,8 @@\n #[cfg(not(no_global_oom_handling))]\n use super::AsVecIntoIter;\n use crate::alloc::{Allocator, Global};\n+#[cfg(not(no_global_oom_handling))]\n+use crate::collections::VecDeque;\n use crate::raw_vec::RawVec;\n use core::array;\n use core::fmt;\n@@ -132,6 +134,33 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     pub(crate) fn forget_remaining_elements(&mut self) {\n         self.ptr = self.end;\n     }\n+\n+    #[cfg(not(no_global_oom_handling))]\n+    #[inline]\n+    pub(crate) fn into_vecdeque(self) -> VecDeque<T, A> {\n+        // Keep our `Drop` impl from dropping the elements and the allocator\n+        let mut this = ManuallyDrop::new(self);\n+\n+        // SAFETY: This allocation originally came from a `Vec`, so it passes\n+        // all those checks.  We have `this.buf` \u2264 `this.ptr` \u2264 `this.end`,\n+        // so the `sub_ptr`s below cannot wrap, and will produce a well-formed\n+        // range.  `end` \u2264 `buf + cap`, so the range will be in-bounds.\n+        // Taking `alloc` is ok because nothing else is going to look at it,\n+        // since our `Drop` impl isn't going to run so there's no more code.\n+        unsafe {\n+            let buf = this.buf.as_ptr();\n+            let initialized = if T::IS_ZST {\n+                // All the pointers are the same for ZSTs, so it's fine to\n+                // say that they're all at the beginning of the \"allocation\".\n+                0..this.len()\n+            } else {\n+                this.ptr.sub_ptr(buf)..this.end.sub_ptr(buf)\n+            };\n+            let cap = this.cap;\n+            let alloc = ManuallyDrop::take(&mut this.alloc);\n+            VecDeque::from_contiguous_raw_parts_in(buf, initialized, cap, alloc)\n+        }\n+    }\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]"}, {"sha": "0b8f5281b785cab4af103238d5125bc1660f358c", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1736,3 +1736,39 @@ fn test_resize_keeps_reserved_space_from_item() {\n     d.resize(1, v);\n     assert_eq!(d[0].capacity(), 1234);\n }\n+\n+#[test]\n+fn test_collect_from_into_iter_keeps_allocation() {\n+    let mut v = Vec::with_capacity(13);\n+    v.extend(0..7);\n+    check(v.as_ptr(), v.last().unwrap(), v.into_iter());\n+\n+    let mut v = VecDeque::with_capacity(13);\n+    v.extend(0..7);\n+    check(&v[0], &v[v.len() - 1], v.into_iter());\n+\n+    fn check(buf: *const i32, last: *const i32, mut it: impl Iterator<Item = i32>) {\n+        assert_eq!(it.next(), Some(0));\n+        assert_eq!(it.next(), Some(1));\n+\n+        let mut v: VecDeque<i32> = it.collect();\n+        assert_eq!(v.capacity(), 13);\n+        assert_eq!(v.as_slices().0.as_ptr(), buf.wrapping_add(2));\n+        assert_eq!(&v[v.len() - 1] as *const _, last);\n+\n+        assert_eq!(v.as_slices(), ([2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(7);\n+        assert_eq!(v.as_slices(), ([7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+        v.push_front(8);\n+        assert_eq!(v.as_slices(), ([8, 7, 2, 3, 4, 5, 6].as_slice(), [].as_slice()));\n+\n+        // Now that we've adding thing in place of the two that we removed from\n+        // the front of the iterator, we're back to matching the buffer pointer.\n+        assert_eq!(v.as_slices().0.as_ptr(), buf);\n+        assert_eq!(&v[v.len() - 1] as *const _, last);\n+\n+        v.push_front(9);\n+        assert_eq!(v.as_slices(), ([9].as_slice(), [8, 7, 2, 3, 4, 5, 6].as_slice()));\n+        assert_eq!(v.capacity(), 13);\n+    }\n+}"}, {"sha": "398437d9a023dcb7e386d669e30615f88d869cd7", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -176,7 +176,6 @@ pub struct AssertParamIsCopy<T: Copy + ?Sized> {\n /// are implemented in `traits::SelectionContext::copy_clone_conditions()`\n /// in `rustc_trait_selection`.\n mod impls {\n-\n     use super::Clone;\n \n     macro_rules! impl_clone {\n@@ -185,7 +184,7 @@ mod impls {\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                 #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n                 impl const Clone for $t {\n-                    #[inline]\n+                    #[inline(always)]\n                     fn clone(&self) -> Self {\n                         *self\n                     }\n@@ -213,7 +212,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n     impl<T: ?Sized> const Clone for *const T {\n-        #[inline]\n+        #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n         }\n@@ -222,7 +221,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n     impl<T: ?Sized> const Clone for *mut T {\n-        #[inline]\n+        #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n         }\n@@ -232,7 +231,7 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n     impl<T: ?Sized> const Clone for &T {\n-        #[inline]\n+        #[inline(always)]\n         #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {\n             *self"}, {"sha": "f95b880df34d37b3b3fc2a8b920bcde4bf6186c5", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -99,7 +99,7 @@ pub use num::FloatToInt;\n /// ```\n #[stable(feature = \"convert_id\", since = \"1.33.0\")]\n #[rustc_const_stable(feature = \"const_identity\", since = \"1.33.0\")]\n-#[inline]\n+#[inline(always)]\n pub const fn identity<T>(x: T) -> T {\n     x\n }\n@@ -789,29 +789,31 @@ where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> AsRef<[T]> for [T] {\n+    #[inline(always)]\n     fn as_ref(&self) -> &[T] {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> AsMut<[T]> for [T] {\n+    #[inline(always)]\n     fn as_mut(&mut self) -> &mut [T] {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<str> for str {\n-    #[inline]\n+    #[inline(always)]\n     fn as_ref(&self) -> &str {\n         self\n     }\n }\n \n #[stable(feature = \"as_mut_str_for_str\", since = \"1.51.0\")]\n impl AsMut<str> for str {\n-    #[inline]\n+    #[inline(always)]\n     fn as_mut(&mut self) -> &mut str {\n         self\n     }"}, {"sha": "e8d724ab1ef4eed662ac5ab2810878e6ee8e2904", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -160,7 +160,7 @@ pub const unsafe fn unreachable_unchecked() -> ! {\n /// ```\n ///\n /// [`thread::yield_now`]: ../../std/thread/fn.yield_now.html\n-#[inline]\n+#[inline(always)]\n #[stable(feature = \"renamed_spin_loop\", since = \"1.49.0\")]\n pub fn spin_loop() {\n     #[cfg(target_arch = \"x86\")]\n@@ -345,6 +345,7 @@ pub const fn black_box<T>(dummy: T) -> T {\n #[unstable(feature = \"hint_must_use\", issue = \"94745\")]\n #[rustc_const_unstable(feature = \"hint_must_use\", issue = \"94745\")]\n #[must_use] // <-- :)\n+#[inline(always)]\n pub const fn must_use<T>(value: T) -> T {\n     value\n }"}, {"sha": "e31669b3924202db05ee2cceb8289ceae1075105", "filename": "library/core/src/iter/traits/accum.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Faccum.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -10,6 +10,10 @@ use crate::num::Wrapping;\n /// [`sum()`]: Iterator::sum\n /// [`FromIterator`]: iter::FromIterator\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+#[rustc_on_unimplemented(\n+    message = \"a value of type `{Self}` cannot be made by summing an iterator over elements of type `{A}`\",\n+    label = \"value of type `{Self}` cannot be made by summing a `std::iter::Iterator<Item={A}>`\"\n+)]\n pub trait Sum<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// \"summing up\" the items.\n@@ -27,6 +31,10 @@ pub trait Sum<A = Self>: Sized {\n /// [`product()`]: Iterator::product\n /// [`FromIterator`]: iter::FromIterator\n #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+#[rustc_on_unimplemented(\n+    message = \"a value of type `{Self}` cannot be made by multiplying all elements of type `{A}` from an iterator\",\n+    label = \"value of type `{Self}` cannot be made by multiplying all elements from a `std::iter::Iterator<Item={A}>`\"\n+)]\n pub trait Product<A = Self>: Sized {\n     /// Method which takes an iterator and generates `Self` from the elements by\n     /// multiplying the items."}, {"sha": "eb2a92f4644d11e8bc903cceb47ac527afbde4eb", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -17,10 +17,10 @@\n //! should have some resemblance to multiplication (and share expected\n //! properties like associativity).\n //!\n-//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n-//! evaluate their second operand if it contributes to the result. Since this\n-//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n-//! overloadable operators.\n+//! Note that the `&&` and `||` operators are currently not supported for\n+//! overloading. Due to their short circuiting nature, they require a different\n+//! design from traits for other operators like [`BitAnd`]. Designs for them are\n+//! under discussion.\n //!\n //! Many of the operators take their operands by value. In non-generic\n //! contexts involving built-in types, this is usually not a problem."}, {"sha": "d348135991a231a2f560b8886ecd72a7d999234e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -45,7 +45,7 @@ impl<T: ?Sized> *const T {\n     /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[rustc_const_stable(feature = \"const_ptr_cast\", since = \"1.38.0\")]\n-    #[inline]\n+    #[inline(always)]\n     pub const fn cast<U>(self) -> *const U {\n         self as _\n     }\n@@ -95,6 +95,7 @@ impl<T: ?Sized> *const T {\n     /// refactored.\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n+    #[inline(always)]\n     pub const fn cast_mut(self) -> *mut T {\n         self as _\n     }\n@@ -126,6 +127,7 @@ impl<T: ?Sized> *const T {\n         note = \"replaced by the `exposed_addr` method, or update your code \\\n             to follow the strict provenance rules using its APIs\"\n     )]\n+    #[inline(always)]\n     pub fn to_bits(self) -> usize\n     where\n         T: Sized,\n@@ -155,6 +157,7 @@ impl<T: ?Sized> *const T {\n             your code to follow the strict provenance rules using its APIs\"\n     )]\n     #[allow(fuzzy_provenance_casts)] // this is an unstable and semi-deprecated cast function\n+    #[inline(always)]\n     pub fn from_bits(bits: usize) -> Self\n     where\n         T: Sized,\n@@ -186,7 +189,7 @@ impl<T: ?Sized> *const T {\n     /// might change in the future (including possibly weakening this so it becomes wholly\n     /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn addr(self) -> usize\n     where\n@@ -223,7 +226,7 @@ impl<T: ?Sized> *const T {\n     ///\n     /// [`from_exposed_addr`]: from_exposed_addr\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn expose_addr(self) -> usize\n     where"}, {"sha": "48b2e88da28413d0e96c45f7ed9f9e974f046076", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -613,7 +613,7 @@ pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n /// [module documentation][crate::ptr] for details.\n #[must_use]\n-#[inline]\n+#[inline(always)]\n #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n #[allow(fuzzy_provenance_casts)] // this *is* the strict provenance API one should use instead\n@@ -651,7 +651,7 @@ where\n /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n /// [module documentation][crate::ptr] for details.\n #[must_use]\n-#[inline]\n+#[inline(always)]\n #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n #[allow(fuzzy_provenance_casts)] // this *is* the strict provenance API one should use instead\n@@ -1769,7 +1769,7 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n /// (which is what the `PartialEq for &T` implementation does).\n ///\n /// When comparing wide pointers, both the address and the metadata are tested for equality.\n-/// However, note that comparing trait object pointers (`*const dyn Trait`) is unrealiable: pointers\n+/// However, note that comparing trait object pointers (`*const dyn Trait`) is unreliable: pointers\n /// to values of the same underlying type can compare inequal (because vtables are duplicated in\n /// multiple codegen units), and pointers to values of *different* underlying type can compare equal\n /// (since identical vtables can be deduplicated within a codegen unit).\n@@ -1801,7 +1801,7 @@ pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usiz\n /// assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n /// ```\n #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-#[inline]\n+#[inline(always)]\n pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n     a == b\n }"}, {"sha": "c924a90b1ff3596bf773b9b11de3235de1e65e13", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -100,6 +100,7 @@ impl<T: ?Sized> *mut T {\n     /// [`cast_mut`]: #method.cast_mut\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n+    #[inline(always)]\n     pub const fn cast_const(self) -> *const T {\n         self as _\n     }\n@@ -132,6 +133,7 @@ impl<T: ?Sized> *mut T {\n         note = \"replaced by the `exposed_addr` method, or update your code \\\n             to follow the strict provenance rules using its APIs\"\n     )]\n+    #[inline(always)]\n     pub fn to_bits(self) -> usize\n     where\n         T: Sized,\n@@ -161,6 +163,7 @@ impl<T: ?Sized> *mut T {\n             update your code to follow the strict provenance rules using its APIs\"\n     )]\n     #[allow(fuzzy_provenance_casts)] // this is an unstable and semi-deprecated cast function\n+    #[inline(always)]\n     pub fn from_bits(bits: usize) -> Self\n     where\n         T: Sized,\n@@ -192,7 +195,7 @@ impl<T: ?Sized> *mut T {\n     /// might change in the future (including possibly weakening this so it becomes wholly\n     /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn addr(self) -> usize\n     where\n@@ -229,7 +232,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// [`from_exposed_addr_mut`]: from_exposed_addr_mut\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn expose_addr(self) -> usize\n     where"}, {"sha": "c4348169c78c7e391e975f6d67cd9415264e8aa9", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -330,7 +330,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[rustc_const_stable(feature = \"const_nonnull_as_ptr\", since = \"1.32.0\")]\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     pub const fn as_ptr(self) -> *mut T {\n         self.pointer as *mut T\n     }\n@@ -378,7 +378,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a reference.\n@@ -429,7 +429,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_as_ref\", issue = \"91822\")]\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     pub const unsafe fn as_mut<'a>(&mut self) -> &'a mut T {\n         // SAFETY: the caller must guarantee that `self` meets all the\n         // requirements for a mutable reference.\n@@ -703,7 +703,7 @@ impl<T> NonNull<[T]> {\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n impl<T: ?Sized> const Clone for NonNull<T> {\n-    #[inline]\n+    #[inline(always)]\n     fn clone(&self) -> Self {\n         *self\n     }"}, {"sha": "d9281a9252c08057e162462071a9eb59d1355d5a", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -465,7 +465,7 @@ impl<T> [T] {\n     /// [`as_mut_ptr`]: slice::as_mut_ptr\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_slice_as_ptr\", since = \"1.32.0\")]\n-    #[inline]\n+    #[inline(always)]\n     #[must_use]\n     pub const fn as_ptr(&self) -> *const T {\n         self as *const [T] as *const T\n@@ -495,7 +495,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n     #[rustc_allow_const_fn_unstable(const_mut_refs)]\n-    #[inline]\n+    #[inline(always)]\n     #[must_use]\n     pub const fn as_mut_ptr(&mut self) -> *mut T {\n         self as *mut [T] as *mut T\n@@ -3468,10 +3468,11 @@ impl<T> [T] {\n     /// maintained.\n     ///\n     /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n-    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n-    /// length possible for a given type and input slice, but only your algorithm's performance\n-    /// should depend on that, not its correctness. It is permissible for all of the input data to\n-    /// be returned as the prefix or suffix slice.\n+    /// slice of a new type, and the suffix slice. How exactly the slice is split up is not\n+    /// specified; the middle part may be smaller than necessary. However, if this fails to return a\n+    /// maximal middle part, that is because code is running in a context where performance does not\n+    /// matter, such as a sanitizer attempting to find alignment bugs. Regular code running\n+    /// in a default (debug or release) execution *will* return a maximal middle part.\n     ///\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything.\n@@ -3529,10 +3530,11 @@ impl<T> [T] {\n     /// types is maintained.\n     ///\n     /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n-    /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n-    /// length possible for a given type and input slice, but only your algorithm's performance\n-    /// should depend on that, not its correctness. It is permissible for all of the input data to\n-    /// be returned as the prefix or suffix slice.\n+    /// slice of a new type, and the suffix slice. How exactly the slice is split up is not\n+    /// specified; the middle part may be smaller than necessary. However, if this fails to return a\n+    /// maximal middle part, that is because code is running in a context where performance does not\n+    /// matter, such as a sanitizer attempting to find alignment bugs. Regular code running\n+    /// in a default (debug or release) execution *will* return a maximal middle part.\n     ///\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything."}, {"sha": "45fd2caae52f4f27efe70ac4054c9660fc3bec99", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -396,7 +396,7 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"rustc_str_as_ptr\", since = \"1.32.0\")]\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     pub const fn as_ptr(&self) -> *const u8 {\n         self as *const str as *const u8\n     }\n@@ -411,7 +411,7 @@ impl str {\n     /// modified in a way that it remains valid UTF-8.\n     #[stable(feature = \"str_as_mut_ptr\", since = \"1.36.0\")]\n     #[must_use]\n-    #[inline]\n+    #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut u8 {\n         self as *mut str as *mut u8\n     }"}, {"sha": "4748ac9d97ef8fda19d11f2d2f48e403ef466fae", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1551,3 +1551,19 @@ fn hiberfil_sys() {\n     fs::metadata(hiberfil).unwrap();\n     assert_eq!(true, hiberfil.exists());\n }\n+\n+/// Test that two different ways of obtaining the FileType give the same result.\n+/// Cf. https://github.com/rust-lang/rust/issues/104900\n+#[test]\n+fn test_eq_direntry_metadata() {\n+    let tmpdir = tmpdir();\n+    let file_path = tmpdir.join(\"file\");\n+    File::create(file_path).unwrap();\n+    for e in fs::read_dir(tmpdir.path()).unwrap() {\n+        let e = e.unwrap();\n+        let p = e.path();\n+        let ft1 = e.file_type().unwrap();\n+        let ft2 = p.metadata().unwrap().file_type();\n+        assert_eq!(ft1, ft2);\n+    }\n+}"}, {"sha": "63e070207cd707cca701b47e7db0ca5e05b6b4eb", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -34,6 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n \n mod condvar;"}, {"sha": "579f758c6cc339fe10f5eb65192851c5e48bf15c", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -65,39 +65,36 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n+    use super::super::thread_parker::Parker;\n+    use crate::pin::Pin;\n     use crate::sync::Arc;\n \n-    pub struct Notifier(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Notifier(Arc<Parker>);\n \n     impl Notifier {\n         /// Notify the waiter. The waiter is either notified right away (if\n         /// currently blocked in `Waiter::wait()`) or later when it calls the\n         /// `Waiter::wait()` method.\n         pub fn notify(self) {\n-            let mut guard = self.0.lock();\n-            *guard.lock_var_mut() = true;\n-            let _ = WaitQueue::notify_one(guard);\n+            Pin::new(&*self.0).unpark()\n         }\n     }\n \n-    pub struct Waiter(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Waiter(Arc<Parker>);\n \n     impl Waiter {\n         /// Wait for a notification. If `Notifier::notify()` has already been\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            let guard = self.0.lock();\n-            if *guard.lock_var() {\n-                return;\n-            }\n-            WaitQueue::wait(guard, || {});\n+            // This is not actually `unsafe`, but it uses the `Parker` API,\n+            // which needs `unsafe` on some platforms.\n+            unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(SpinMutex::new(WaitVariable::new(false)));\n+        let inner = Arc::new(Parker::new_internal());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,107 @@\n+//! Thread parking based on SGX events.\n+\n+use super::abi::{thread, usercalls};\n+use crate::io::ErrorKind;\n+use crate::pin::Pin;\n+use crate::ptr::{self, NonNull};\n+use crate::sync::atomic::AtomicPtr;\n+use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n+// be valid pointers\n+const EMPTY: *mut u8 = ptr::invalid_mut(1);\n+const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n+\n+pub struct Parker {\n+    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n+    /// A state change to NOTIFIED must be done with release ordering\n+    /// and be observed with acquire ordering so that operations after\n+    /// `thread::park` returns will not occur before the unpark message\n+    /// was sent.\n+    state: AtomicPtr<u8>,\n+}\n+\n+impl Parker {\n+    /// Construct the thread parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        unsafe { parker.write(Parker::new_internal()) }\n+    }\n+\n+    pub(super) fn new_internal() -> Parker {\n+        Parker { state: AtomicPtr::new(EMPTY) }\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let mut prev = EMPTY;\n+            loop {\n+                // Guard against changing TCS addresses by always setting the state to\n+                // the current value.\n+                let tcs = thread::current().as_ptr();\n+                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n+                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+                    assert!(event & EV_UNPARK == EV_UNPARK);\n+                    prev = tcs;\n+                } else {\n+                    // The state was definitely changed by another thread at this point.\n+                    // The only time this occurs is when the state is changed to NOTIFIED.\n+                    // We observed this change with acquire ordering, so we can simply\n+                    // change the state to EMPTY with a relaxed store.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // At this point, the token was definately read with acquire ordering,\n+        // so this can be a relaxed store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+        let tcs = thread::current().as_ptr();\n+\n+        if self.state.load(Acquire) != NOTIFIED {\n+            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n+                match usercalls::wait(EV_UNPARK, timeout) {\n+                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n+                    Err(e) => {\n+                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+                    }\n+                }\n+\n+                // Swap to provide acquire ordering even if the timeout occurred\n+                // before the token was set. This situation can result in spurious\n+                // wakeups on the next call to `park_timeout`, but it is better to let\n+                // those be handled by the user than do some perhaps unnecessary, but\n+                // always expensive guarding.\n+                self.state.swap(EMPTY, Acquire);\n+                return;\n+            }\n+        }\n+\n+        // The token was already read with `acquire` ordering, this can be a store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+\n+        if !matches!(state, EMPTY | NOTIFIED) {\n+            // There is a thread waiting, wake it up.\n+            let tcs = NonNull::new(state).unwrap();\n+            // This will fail if the thread has already terminated or its TCS is destroyed\n+            // by the time the signal is sent, but that is fine. If another thread receives\n+            // the same TCS, it will receive this notification as a spurious wakeup, but\n+            // all users of `wait` should and (internally) do guard against those where\n+            // necessary.\n+            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n+        }\n+    }\n+}"}, {"sha": "fb8d06c66820cf0b47a41a48cfdfd8064d3c7f5f", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -332,11 +332,23 @@ pub struct FileTimes {\n     modified: Option<SystemTime>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, Eq, Debug)]\n pub struct FileType {\n     mode: mode_t,\n }\n \n+impl PartialEq for FileType {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.masked() == other.masked()\n+    }\n+}\n+\n+impl core::hash::Hash for FileType {\n+    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n+        self.masked().hash(state);\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct DirBuilder {\n     mode: mode_t,\n@@ -548,7 +560,11 @@ impl FileType {\n     }\n \n     pub fn is(&self, mode: mode_t) -> bool {\n-        self.mode & libc::S_IFMT == mode\n+        self.masked() == mode\n+    }\n+\n+    fn masked(&self) -> mode_t {\n+        self.mode & libc::S_IFMT\n     }\n }\n "}, {"sha": "6ecf5bdcf86d2bf792695eb1720f3c10c403eadf", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -136,7 +136,7 @@ impl Thread {\n \n         unsafe {\n             // Available since glibc 2.12, musl 1.1.16, and uClibc 1.0.20.\n-            let name = truncate_cstr(name, TASK_COMM_LEN);\n+            let name = truncate_cstr::<{ TASK_COMM_LEN }>(name);\n             let res = libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n             // We have no good way of propagating errors here, but in debug-builds let's check that this actually worked.\n             debug_assert_eq!(res, 0);\n@@ -153,7 +153,7 @@ impl Thread {\n     #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n-            let name = truncate_cstr(name, libc::MAXTHREADNAMESIZE);\n+            let name = truncate_cstr::<{ libc::MAXTHREADNAMESIZE }>(name);\n             let res = libc::pthread_setname_np(name.as_ptr());\n             // We have no good way of propagating errors here, but in debug-builds let's check that this actually worked.\n             debug_assert_eq!(res, 0);\n@@ -285,17 +285,12 @@ impl Drop for Thread {\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n-fn truncate_cstr(cstr: &CStr, max_with_nul: usize) -> crate::borrow::Cow<'_, CStr> {\n-    use crate::{borrow::Cow, ffi::CString};\n-\n-    if cstr.to_bytes_with_nul().len() > max_with_nul {\n-        let bytes = cstr.to_bytes()[..max_with_nul - 1].to_vec();\n-        // SAFETY: the non-nul bytes came straight from a CStr.\n-        // (CString will add the terminating nul.)\n-        Cow::Owned(unsafe { CString::from_vec_unchecked(bytes) })\n-    } else {\n-        Cow::Borrowed(cstr)\n+fn truncate_cstr<const MAX_WITH_NUL: usize>(cstr: &CStr) -> [libc::c_char; MAX_WITH_NUL] {\n+    let mut result = [0; MAX_WITH_NUL];\n+    for (src, dst) in cstr.to_bytes().iter().zip(&mut result[..MAX_WITH_NUL - 1]) {\n+        *dst = *src as libc::c_char;\n     }\n+    result\n }\n \n pub fn available_parallelism() -> io::Result<NonZeroUsize> {"}, {"sha": "08a2bdd82298b9f622e5589ff2550d20ccd0658a", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -16,6 +16,8 @@ cfg_if::cfg_if! {\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parker::Parker;\n+    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}, {"sha": "3f551dc119b5d5ef6730dd343abca2c739555754", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -744,6 +744,7 @@ impl<'a> Builder<'a> {\n                 install::RustDemangler,\n                 install::Clippy,\n                 install::Miri,\n+                install::LlvmTools,\n                 install::Analysis,\n                 install::Src,\n                 install::Rustc"}, {"sha": "960fbdf75380448983b1f3650b9fd66b95dc3df8", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -3,6 +3,9 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n+#[cfg(test)]\n+mod tests;\n+\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n@@ -696,7 +699,7 @@ define_config! {\n     }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Debug, Deserialize)]\n #[serde(untagged)]\n enum StringOrBool {\n     String(String),\n@@ -822,6 +825,29 @@ impl Config {\n     }\n \n     pub fn parse(args: &[String]) -> Config {\n+        #[cfg(test)]\n+        let get_toml = |_: &_| TomlConfig::default();\n+        #[cfg(not(test))]\n+        let get_toml = |file: &Path| {\n+            let contents =\n+                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n+            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n+            // TomlConfig and sub types to be monomorphized 5x by toml.\n+            match toml::from_str(&contents)\n+                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n+            {\n+                Ok(table) => table,\n+                Err(err) => {\n+                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n+                    crate::detail_exit(2);\n+                }\n+            }\n+        };\n+\n+        Self::parse_inner(args, get_toml)\n+    }\n+\n+    fn parse_inner<'a>(args: &[String], get_toml: impl 'a + Fn(&Path) -> TomlConfig) -> Config {\n         let flags = Flags::parse(&args);\n         let mut config = Config::default_opts();\n \n@@ -907,25 +933,6 @@ impl Config {\n \n         config.stage0_metadata = t!(serde_json::from_slice::<Stage0Metadata>(&stage0_json));\n \n-        #[cfg(test)]\n-        let get_toml = |_| TomlConfig::default();\n-        #[cfg(not(test))]\n-        let get_toml = |file: &Path| {\n-            let contents =\n-                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n-            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n-            // TomlConfig and sub types to be monomorphized 5x by toml.\n-            match toml::from_str(&contents)\n-                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n-            {\n-                Ok(table) => table,\n-                Err(err) => {\n-                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n-                    crate::detail_exit(2);\n-                }\n-            }\n-        };\n-\n         // Read from `--config`, then `RUST_BOOTSTRAP_CONFIG`, then `./config.toml`, then `config.toml` in the root directory.\n         let toml_path = flags\n             .config\n@@ -1063,6 +1070,79 @@ impl Config {\n         let mut optimize = None;\n         let mut ignore_git = None;\n \n+        if let Some(rust) = toml.rust {\n+            debug = rust.debug;\n+            debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n+            overflow_checks = rust.overflow_checks;\n+            overflow_checks_std = rust.overflow_checks_std;\n+            debug_logging = rust.debug_logging;\n+            debuginfo_level = rust.debuginfo_level;\n+            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n+            debuginfo_level_std = rust.debuginfo_level_std;\n+            debuginfo_level_tools = rust.debuginfo_level_tools;\n+            debuginfo_level_tests = rust.debuginfo_level_tests;\n+            config.rust_split_debuginfo = rust\n+                .split_debuginfo\n+                .as_deref()\n+                .map(SplitDebuginfo::from_str)\n+                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n+                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n+            optimize = rust.optimize;\n+            ignore_git = rust.ignore_git;\n+            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n+            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n+            set(&mut config.codegen_tests, rust.codegen_tests);\n+            set(&mut config.rust_rpath, rust.rpath);\n+            set(&mut config.jemalloc, rust.jemalloc);\n+            set(&mut config.test_compare_mode, rust.test_compare_mode);\n+            set(&mut config.backtrace, rust.backtrace);\n+            set(&mut config.channel, rust.channel);\n+            config.description = rust.description;\n+            set(&mut config.rust_dist_src, rust.dist_src);\n+            set(&mut config.verbose_tests, rust.verbose_tests);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n+            set(&mut config.use_lld, rust.use_lld);\n+            set(&mut config.lld_enabled, rust.lld);\n+            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n+            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n+            config.rustc_default_linker = rust.default_linker;\n+            config.musl_root = rust.musl_root.map(PathBuf::from);\n+            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n+            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n+            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n+            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n+            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n+            set(&mut config.control_flow_guard, rust.control_flow_guard);\n+            config.llvm_libunwind_default = rust\n+                .llvm_libunwind\n+                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n+\n+            if let Some(ref backends) = rust.codegen_backends {\n+                config.rust_codegen_backends =\n+                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n+            }\n+\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n+            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n+            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n+            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n+\n+            config.rust_lto = rust\n+                .lto\n+                .as_deref()\n+                .map(|value| RustcLto::from_str(value).unwrap())\n+                .unwrap_or_default();\n+        } else {\n+            config.rust_profile_use = flags.rust_profile_use;\n+            config.rust_profile_generate = flags.rust_profile_generate;\n+        }\n+\n         if let Some(llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => config.ccache = Some(s.to_string()),\n@@ -1099,13 +1179,17 @@ impl Config {\n             config.llvm_polly = llvm.polly.unwrap_or(false);\n             config.llvm_clang = llvm.clang.unwrap_or(false);\n             config.llvm_build_config = llvm.build_config.clone().unwrap_or(Default::default());\n+\n+            let asserts = llvm_assertions.unwrap_or(false);\n             config.llvm_from_ci = match llvm.download_ci_llvm {\n                 Some(StringOrBool::String(s)) => {\n                     assert!(s == \"if-available\", \"unknown option `{}` for download-ci-llvm\", s);\n-                    crate::native::is_ci_llvm_available(&config, llvm_assertions.unwrap_or(false))\n+                    crate::native::is_ci_llvm_available(&config, asserts)\n                 }\n                 Some(StringOrBool::Bool(b)) => b,\n-                None => false,\n+                None => {\n+                    config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, asserts)\n+                }\n             };\n \n             if config.llvm_from_ci {\n@@ -1145,79 +1229,9 @@ impl Config {\n                 // the link step) with each stage.\n                 config.llvm_link_shared.set(Some(true));\n             }\n-        }\n-\n-        if let Some(rust) = toml.rust {\n-            debug = rust.debug;\n-            debug_assertions = rust.debug_assertions;\n-            debug_assertions_std = rust.debug_assertions_std;\n-            overflow_checks = rust.overflow_checks;\n-            overflow_checks_std = rust.overflow_checks_std;\n-            debug_logging = rust.debug_logging;\n-            debuginfo_level = rust.debuginfo_level;\n-            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n-            debuginfo_level_std = rust.debuginfo_level_std;\n-            debuginfo_level_tools = rust.debuginfo_level_tools;\n-            debuginfo_level_tests = rust.debuginfo_level_tests;\n-            config.rust_split_debuginfo = rust\n-                .split_debuginfo\n-                .as_deref()\n-                .map(SplitDebuginfo::from_str)\n-                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n-                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n-            optimize = rust.optimize;\n-            ignore_git = rust.ignore_git;\n-            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n-            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n-            set(&mut config.codegen_tests, rust.codegen_tests);\n-            set(&mut config.rust_rpath, rust.rpath);\n-            set(&mut config.jemalloc, rust.jemalloc);\n-            set(&mut config.test_compare_mode, rust.test_compare_mode);\n-            set(&mut config.backtrace, rust.backtrace);\n-            set(&mut config.channel, rust.channel);\n-            config.description = rust.description;\n-            set(&mut config.rust_dist_src, rust.dist_src);\n-            set(&mut config.verbose_tests, rust.verbose_tests);\n-            // in the case \"false\" is set explicitly, do not overwrite the command line args\n-            if let Some(true) = rust.incremental {\n-                config.incremental = true;\n-            }\n-            set(&mut config.use_lld, rust.use_lld);\n-            set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n-            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n-            config.rustc_default_linker = rust.default_linker;\n-            config.musl_root = rust.musl_root.map(PathBuf::from);\n-            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n-            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n-            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n-            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n-            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n-            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n-            set(&mut config.control_flow_guard, rust.control_flow_guard);\n-            config.llvm_libunwind_default = rust\n-                .llvm_libunwind\n-                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n-\n-            if let Some(ref backends) = rust.codegen_backends {\n-                config.rust_codegen_backends =\n-                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n-            }\n-\n-            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n-            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n-            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n-            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n-            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n-\n-            config.rust_lto = rust\n-                .lto\n-                .as_deref()\n-                .map(|value| RustcLto::from_str(value).unwrap())\n-                .unwrap_or_default();\n         } else {\n-            config.rust_profile_use = flags.rust_profile_use;\n-            config.rust_profile_generate = flags.rust_profile_generate;\n+            config.llvm_from_ci =\n+                config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, false);\n         }\n \n         if let Some(t) = toml.target {"}, {"sha": "c30c9131745c81e2f41cf8277852685ac1df579c", "filename": "src/bootstrap/config/tests.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,24 @@\n+use super::{Config, TomlConfig};\n+use std::path::Path;\n+\n+fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n+    |&_| toml::from_str(config).unwrap()\n+}\n+\n+fn parse(config: &str) -> Config {\n+    Config::parse_inner(&[\"check\".to_owned(), \"--config=/does/not/exist\".to_owned()], toml(config))\n+}\n+\n+#[test]\n+fn download_ci_llvm() {\n+    let parse_llvm = |s| parse(s).llvm_from_ci;\n+    let if_available = parse_llvm(\"llvm.download-ci-llvm = \\\"if-available\\\"\");\n+\n+    assert!(parse_llvm(\"llvm.download-ci-llvm = true\"));\n+    assert!(!parse_llvm(\"llvm.download-ci-llvm = false\"));\n+    assert_eq!(parse_llvm(\"\"), if_available);\n+    assert_eq!(parse_llvm(\"rust.channel = \\\"dev\\\"\"), if_available);\n+    assert!(!parse_llvm(\"rust.channel = \\\"stable\\\"\"));\n+}\n+\n+// FIXME: add test for detecting `src` and `out`"}, {"sha": "48ae2fe448de2070ddcfd37b57b99434386b5ba4", "filename": "src/bootstrap/defaults/config.user.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -7,3 +7,7 @@ test-stage = 2\n doc-stage = 2\n # When compiling from source, you usually want all tools.\n extended = true\n+\n+[llvm]\n+# Most users installing from source want to build all parts of the project from source, not just rustc itself.\n+download-ci-llvm = false"}, {"sha": "c53d0d7e4cb7c03964ec1f2364c6a7a2600cadfa", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -205,6 +205,12 @@ install!((self, builder, _config),\n             .expect(\"missing miri\");\n         install_sh(builder, \"miri\", self.compiler.stage, Some(self.target), &tarball);\n     };\n+    LlvmTools, alias = \"llvm-tools\", Self::should_build(_config), only_hosts: true, {\n+        let tarball = builder\n+            .ensure(dist::LlvmTools { target: self.target })\n+            .expect(\"missing llvm-tools\");\n+        install_sh(builder, \"llvm-tools\", self.compiler.stage, Some(self.target), &tarball);\n+    };\n     Rustfmt, alias = \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n         if let Some(tarball) = builder.ensure(dist::Rustfmt {\n             compiler: self.compiler,"}, {"sha": "570fe6484e3db32aa436633f4ebde35d369b57a0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1639,10 +1639,10 @@ fn chmod(_path: &Path, _perms: u32) {}\n /// If the test is running and code is an error code, it will cause a panic.\n fn detail_exit(code: i32) -> ! {\n     // if in test and code is an error code, panic with status code provided\n-    if cfg!(test) && code != 0 {\n+    if cfg!(test) {\n         panic!(\"status code: {}\", code);\n     } else {\n-        //otherwise,exit with provided status code\n+        // otherwise,exit with provided status code\n         std::process::exit(code);\n     }\n }"}, {"sha": "6b7b32a8bc77f85c4a7eb5b84892d9b5cbfae844", "filename": "src/ci/docker/host-x86_64/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64le-linux%2FDockerfile?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -24,5 +24,5 @@ ENV \\\n \n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-profiler --disable-docs\n ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "9bbf9e28fffe2bdec384da186e4f2b1eec2f417b", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,6 +14,9 @@ This feature allows for use of one of following sanitizers:\n   forward-edge control flow protection.\n * [HWAddressSanitizer](#hwaddresssanitizer) a memory error detector similar to\n   AddressSanitizer, but based on partial hardware assistance.\n+* [KernelControlFlowIntegrity](#kernelcontrolflowintegrity) LLVM Kernel Control\n+  Flow Integrity (KCFI) provides forward-edge control flow protection for\n+  operating systems kernels.\n * [LeakSanitizer](#leaksanitizer) a run-time memory leak detector.\n * [MemorySanitizer](#memorysanitizer) a detector of uninitialized reads.\n * [MemTagSanitizer](#memtagsanitizer) fast memory error detector based on\n@@ -502,6 +505,32 @@ Registers where the failure occurred (pc 0xaaaae0ae4a98):\n SUMMARY: HWAddressSanitizer: tag-mismatch (/.../main+0x54a94)\n ```\n \n+# KernelControlFlowIntegrity\n+\n+The LLVM Kernel Control Flow Integrity (CFI) support to the Rust compiler\n+initially provides forward-edge control flow protection for operating systems\n+kernels for Rust-compiled code only by aggregating function pointers in groups\n+identified by their return and parameter types. (See [LLVM commit cff5bef \"KCFI\n+sanitizer\"](https://github.com/llvm/llvm-project/commit/cff5bef948c91e4919de8a5fb9765e0edc13f3de).)\n+\n+Forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed\n+binaries\" (i.e., for when C or C++ and Rust -compiled code share the same\n+virtual address space) will be provided in later work by defining and using\n+compatible type identifiers (see Type metadata in the design document in the\n+tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+LLVM KCFI can be enabled with `-Zsanitizer=kcfi`.\n+\n+LLVM KCFI is supported on the following targets:\n+\n+* `aarch64-linux-android`\n+* `aarch64-unknown-linux-gnu`\n+* `x86_64-linux-android`\n+* `x86_64-unknown-linux-gnu`\n+\n+See the [Clang KernelControlFlowIntegrity documentation][clang-kcfi] for more\n+details.\n+\n # LeakSanitizer\n \n LeakSanitizer is run-time memory leak detector.\n@@ -693,6 +722,7 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n [clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n [clang-cfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html\n [clang-hwasan]: https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html\n+[clang-kcfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html#fsanitize-kcfi\n [clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n [clang-scs]: https://clang.llvm.org/docs/ShadowCallStack.html"}, {"sha": "56b40d8c66baffa627ab03e1a9b83788b73d276d", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -69,6 +69,8 @@ pub(crate) struct Options {\n     pub(crate) input: PathBuf,\n     /// The name of the crate being documented.\n     pub(crate) crate_name: Option<String>,\n+    /// Whether or not this is a bin crate\n+    pub(crate) bin_crate: bool,\n     /// Whether or not this is a proc-macro crate\n     pub(crate) proc_macro_crate: bool,\n     /// How to format errors and warnings.\n@@ -176,6 +178,7 @@ impl fmt::Debug for Options {\n         f.debug_struct(\"Options\")\n             .field(\"input\", &self.input)\n             .field(\"crate_name\", &self.crate_name)\n+            .field(\"bin_crate\", &self.bin_crate)\n             .field(\"proc_macro_crate\", &self.proc_macro_crate)\n             .field(\"error_format\", &self.error_format)\n             .field(\"libs\", &self.libs)\n@@ -667,6 +670,7 @@ impl Options {\n             None => OutputFormat::default(),\n         };\n         let crate_name = matches.opt_str(\"crate-name\");\n+        let bin_crate = crate_types.contains(&CrateType::Executable);\n         let proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n         let playground_url = matches.opt_str(\"playground-url\");\n         let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n@@ -718,6 +722,7 @@ impl Options {\n             rustc_feature::UnstableFeatures::from_environment(crate_name.as_deref());\n         let options = Options {\n             input,\n+            bin_crate,\n             proc_macro_crate,\n             error_format,\n             diagnostic_width,"}, {"sha": "36d15ec3b8640cde9642b080ffe1db218dc848a7", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2957,14 +2957,23 @@ fn render_call_locations(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Ite\n \n     // The call locations are output in sequence, so that sequence needs to be determined.\n     // Ideally the most \"relevant\" examples would be shown first, but there's no general algorithm\n-    // for determining relevance. Instead, we prefer the smallest examples being likely the easiest to\n-    // understand at a glance.\n+    // for determining relevance. We instead proxy relevance with the following heuristics:\n+    //   1. Code written to be an example is better than code not written to be an example, e.g.\n+    //      a snippet from examples/foo.rs is better than src/lib.rs. We don't know the Cargo\n+    //      directory structure in Rustdoc, so we proxy this by prioritizing code that comes from\n+    //      a --crate-type bin.\n+    //   2. Smaller examples are better than large examples. So we prioritize snippets that have\n+    //      the smallest number of lines in their enclosing item.\n+    //   3. Finally we sort by the displayed file name, which is arbitrary but prevents the\n+    //      ordering of examples from randomly changing between Rustdoc invocations.\n     let ordered_locations = {\n-        let sort_criterion = |(_, call_data): &(_, &CallData)| {\n+        fn sort_criterion<'a>(\n+            (_, call_data): &(&PathBuf, &'a CallData),\n+        ) -> (bool, u32, &'a String) {\n             // Use the first location because that's what the user will see initially\n             let (lo, hi) = call_data.locations[0].enclosing_item.byte_span;\n-            hi - lo\n-        };\n+            (!call_data.is_bin, hi - lo, &call_data.display_name)\n+        }\n \n         let mut locs = call_locations.iter().collect::<Vec<_>>();\n         locs.sort_by_key(sort_criterion);"}, {"sha": "91162ca4892ca0a43caa71b64d54696bee1a69a7", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 52, "deletions": 35, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -212,7 +212,7 @@ pre.rust a,\n .mobile-topbar h2 a,\n h1 a,\n .search-results a,\n-.item-left .stab,\n+.stab,\n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: var(--main-color);\n }\n@@ -630,22 +630,16 @@ pre, .rustdoc.source .example-wrap {\n \n .docblock table {\n \tmargin: .5em 0;\n-\twidth: calc(100% - 2px);\n-\toverflow-x: auto;\n-\tdisplay: block;\n \tborder-collapse: collapse;\n }\n \n-.docblock table td {\n+.docblock table td, .docblock table th {\n \tpadding: .5em;\n-\tborder: 1px dashed var(--border-color);\n-\tvertical-align: top;\n+\tborder: 1px solid var(--border-color);\n }\n \n-.docblock table th {\n-\tpadding: .5em;\n-\ttext-align: left;\n-\tborder: 1px solid var(--border-color);\n+.docblock table tbody tr:nth-child(2n) {\n+\tbackground: var(--table-alt-row-background-color);\n }\n \n /* Shift \"where ...\" part of method or fn definition down a line */\n@@ -966,22 +960,29 @@ so that we can apply CSS-filters to change the arrow color in themes */\n }\n \n .item-info .stab {\n-\twidth: fit-content;\n \t/* This min-height is needed to unify the height of the stab elements because some of them\n \t   have emojis.\n \t*/\n \tmin-height: 36px;\n \tdisplay: flex;\n-\talign-items: center;\n-\twhite-space: pre-wrap;\n-}\n-.stab {\n \tpadding: 3px;\n \tmargin-bottom: 5px;\n+}\n+.item-left .stab {\n+\tmargin-left: 0.3125em;\n+}\n+.stab {\n+\tpadding: 0 2px;\n \tfont-size: 0.875rem;\n \tfont-weight: normal;\n \tcolor: var(--main-color);\n \tbackground-color: var(--stab-background-color);\n+\twidth: fit-content;\n+\talign-items: center;\n+\twhite-space: pre-wrap;\n+\tborder-radius: 3px;\n+\tdisplay: inline-flex;\n+\tvertical-align: text-bottom;\n }\n \n .stab.portability > code {\n@@ -994,12 +995,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tmargin-right: 0.3rem;\n }\n \n-/* This is to prevent the `.stab` elements to overflow the .docblock elements. */\n-.docblock .stab {\n-\tpadding: 0 0.125em;\n-\tmargin-bottom: 0;\n-}\n-\n /* Black one-pixel outline around emoji shapes */\n .emoji {\n \ttext-shadow:\n@@ -1009,16 +1004,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t\t0 -1px 0 black;\n }\n \n-.item-left .stab {\n-\tborder-radius: 3px;\n-\tdisplay: inline-block;\n-\tline-height: 1.2;\n-\tmargin-bottom: 0;\n-\tmargin-left: 0.3125em;\n-\tpadding: 2px;\n-\tvertical-align: text-bottom;\n-}\n-\n .module-item.unstable,\n .import-item.unstable {\n \topacity: 0.65;\n@@ -1748,7 +1733,6 @@ in storage.js\n \t\ttop: 100px;\n \t\twidth: 30px;\n \t\tfont-size: 1.5rem;\n-\t\ttext-align: center;\n \t\tpadding: 0;\n \t\tz-index: 10;\n \t\tborder-top-right-radius: 3px;\n@@ -1813,6 +1797,22 @@ in storage.js\n \t}\n }\n \n+/* Should have min-width: (N + 1)px where N is the mobile breakpoint above. */\n+@media (min-width: 701px) {\n+\t/* Places file-link for a scraped example on top of the example to save space.\n+\t   We only do this on large screens so the file-link doesn't overlap too much\n+\t\t with the example's content. */\n+\t.scraped-example-title {\n+\t\tposition: absolute;\n+\t\tz-index: 10;\n+\t\tbackground: var(--main-background-color);\n+\t\tbottom: 8px;\n+\t\tright: 5px;\n+\t\tpadding: 2px 4px;\n+\t\tbox-shadow: 0 0 4px var(--main-background-color);\n+\t}\n+}\n+\n @media print {\n \tnav.sidebar, nav.sub, .out-of-band, a.srclink, #copy-path,\n \tdetails.rustdoc-toggle[open] > summary::before, details.rustdoc-toggle > summary::before,\n@@ -1899,6 +1899,11 @@ in storage.js\n \tborder-radius: 50px;\n }\n \n+.scraped-example {\n+\t/* So .scraped-example-title can be positioned absolutely */\n+\tposition: relative;\n+}\n+\n .scraped-example .code-wrapper {\n \tposition: relative;\n \tdisplay: flex;\n@@ -1908,18 +1913,30 @@ in storage.js\n }\n \n .scraped-example:not(.expanded) .code-wrapper {\n-\tmax-height: 240px;\n+\t/* scrape-examples.js has a constant DEFAULT_MAX_LINES (call it N) for the number\n+\t * of lines shown in the un-expanded example code viewer. This pre needs to have\n+\t * a max-height equal to line-height * N. The line-height is currently 1.5em,\n+\t * and we include additional 10px for padding. */\n+\t max-height: calc(1.5em * 5 + 10px);\n }\n \n .scraped-example:not(.expanded) .code-wrapper pre {\n \toverflow-y: hidden;\n-\tmax-height: 240px;\n \tpadding-bottom: 0;\n+\t/* See above comment, should be the same max-height. */\n+\tmax-height: calc(1.5em * 5 + 10px);\n+}\n+\n+.more-scraped-examples .scraped-example:not(.expanded) .code-wrapper,\n+.more-scraped-examples .scraped-example:not(.expanded) .code-wrapper pre {\n+\t/* See above comment, except this height is based on HIDDEN_MAX_LINES. */\n+\tmax-height: calc(1.5em * 10 + 10px);\n }\n \n .scraped-example .code-wrapper .next,\n .scraped-example .code-wrapper .prev,\n .scraped-example .code-wrapper .expand {\n+\tcolor: var(--main-color);\n \tposition: absolute;\n \ttop: 0.25em;\n \tz-index: 1;"}, {"sha": "eba845bf5a91565f2219f56f71c9eeb8701526a2", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -87,6 +87,7 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--crate-search-hover-border: #e0e0e0;\n \t--source-sidebar-background-selected: #14191f;\n \t--source-sidebar-background-hover: #14191f;\n+\t--table-alt-row-background-color: #191f26;\n }\n \n h1, h2, h3, h4 {\n@@ -159,11 +160,6 @@ body.source .example-wrap pre.rust a {\n \tbackground: #333;\n }\n \n-.module-item .stab,\n-.import-item .stab {\n-\tcolor: #000;\n-}\n-\n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: #788797;\n }"}, {"sha": "d945e956c533e20b52fea54d922924363acd449d", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -82,6 +82,7 @@\n \t--crate-search-hover-border: #2196f3;\n \t--source-sidebar-background-selected: #333;\n \t--source-sidebar-background-hover: #444;\n+\t--table-alt-row-background-color: #2A2A2A;\n }\n \n .content .item-info::before { color: #ccc; }"}, {"sha": "58955a79316af3f2485c68e681ba9ac247454934", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -79,6 +79,7 @@\n \t--crate-search-hover-border: #717171;\n \t--source-sidebar-background-selected: #fff;\n \t--source-sidebar-background-hover: #e0e0e0;\n+\t--table-alt-row-background-color: #F5F5F5;\n }\n \n .content .item-info::before { color: #ccc; }"}, {"sha": "152116089c7fc2c6f1c400f7f353fb16d879e66d", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -622,7 +622,7 @@ function loadCss(cssUrl) {\n         const innerToggle = document.getElementById(toggleAllDocsId);\n         removeClass(innerToggle, \"will-expand\");\n         onEachLazy(document.getElementsByClassName(\"rustdoc-toggle\"), e => {\n-            if (!hasClass(e, \"type-contents-toggle\")) {\n+            if (!hasClass(e, \"type-contents-toggle\") && !hasClass(e, \"more-examples-toggle\")) {\n                 e.open = true;\n             }\n         });"}, {"sha": "7a3a9c5f3400190fb62ec8ea3ee904171a06d048", "filename": "src/librustdoc/html/static/js/scrape-examples.js", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fscrape-examples.js?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -3,33 +3,41 @@\n \"use strict\";\n \n (function() {\n-    // Number of lines shown when code viewer is not expanded\n-    const MAX_LINES = 10;\n+    // Number of lines shown when code viewer is not expanded.\n+    // DEFAULT is the first example shown by default, while HIDDEN is\n+    // the examples hidden beneath the \"More examples\" toggle.\n+    //\n+    // NOTE: these values MUST be synchronized with certain rules in rustdoc.css!\n+    const DEFAULT_MAX_LINES = 5;\n+    const HIDDEN_MAX_LINES = 10;\n \n     // Scroll code block to the given code location\n-    function scrollToLoc(elt, loc) {\n+    function scrollToLoc(elt, loc, isHidden) {\n         const lines = elt.querySelector(\".src-line-numbers\");\n         let scrollOffset;\n \n         // If the block is greater than the size of the viewer,\n         // then scroll to the top of the block. Otherwise scroll\n         // to the middle of the block.\n-        if (loc[1] - loc[0] > MAX_LINES) {\n+        const maxLines = isHidden ? HIDDEN_MAX_LINES : DEFAULT_MAX_LINES;\n+        if (loc[1] - loc[0] > maxLines) {\n             const line = Math.max(0, loc[0] - 1);\n             scrollOffset = lines.children[line].offsetTop;\n         } else {\n             const wrapper = elt.querySelector(\".code-wrapper\");\n             const halfHeight = wrapper.offsetHeight / 2;\n-            const offsetMid = (lines.children[loc[0]].offsetTop\n-                             + lines.children[loc[1]].offsetTop) / 2;\n+            const offsetTop = lines.children[loc[0]].offsetTop;\n+            const lastLine = lines.children[loc[1]];\n+            const offsetBot = lastLine.offsetTop + lastLine.offsetHeight;\n+            const offsetMid = (offsetTop + offsetBot) / 2;\n             scrollOffset = offsetMid - halfHeight;\n         }\n \n         lines.scrollTo(0, scrollOffset);\n         elt.querySelector(\".rust\").scrollTo(0, scrollOffset);\n     }\n \n-    function updateScrapedExample(example) {\n+    function updateScrapedExample(example, isHidden) {\n         const locs = JSON.parse(example.attributes.getNamedItem(\"data-locs\").textContent);\n         let locIndex = 0;\n         const highlights = Array.prototype.slice.call(example.querySelectorAll(\".highlight\"));\n@@ -40,7 +48,7 @@\n             const onChangeLoc = changeIndex => {\n                 removeClass(highlights[locIndex], \"focus\");\n                 changeIndex();\n-                scrollToLoc(example, locs[locIndex][0]);\n+                scrollToLoc(example, locs[locIndex][0], isHidden);\n                 addClass(highlights[locIndex], \"focus\");\n \n                 const url = locs[locIndex][1];\n@@ -70,19 +78,19 @@\n             expandButton.addEventListener(\"click\", () => {\n                 if (hasClass(example, \"expanded\")) {\n                     removeClass(example, \"expanded\");\n-                    scrollToLoc(example, locs[0][0]);\n+                    scrollToLoc(example, locs[0][0], isHidden);\n                 } else {\n                     addClass(example, \"expanded\");\n                 }\n             });\n         }\n \n         // Start with the first example in view\n-        scrollToLoc(example, locs[0][0]);\n+        scrollToLoc(example, locs[0][0], isHidden);\n     }\n \n     const firstExamples = document.querySelectorAll(\".scraped-example-list > .scraped-example\");\n-    onEachLazy(firstExamples, updateScrapedExample);\n+    onEachLazy(firstExamples, el => updateScrapedExample(el, false));\n     onEachLazy(document.querySelectorAll(\".more-examples-toggle\"), toggle => {\n         // Allow users to click the left border of the <details> section to close it,\n         // since the section can be large and finding the [+] button is annoying.\n@@ -99,7 +107,7 @@\n             // depends on offsetHeight, a property that requires an element to be visible to\n             // compute correctly.\n             setTimeout(() => {\n-                onEachLazy(moreExamples, updateScrapedExample);\n+                onEachLazy(moreExamples, el => updateScrapedExample(el, true));\n             });\n         }, {once: true});\n     });"}, {"sha": "002d19ec9b67dae6c0b3724e6b46aac4213f9766", "filename": "src/librustdoc/html/static/scrape-examples-help.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fscrape-examples-help.md", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fscrape-examples-help.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fscrape-examples-help.md?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,4 +1,4 @@\n-Rustdoc will automatically scrape examples of documented items from the `examples/` directory of a project. These examples will be included within the generated documentation for that item. For example, if your library contains a public function:\n+Rustdoc will automatically scrape examples of documented items from a project's source code. These examples will be included within the generated documentation for that item. For example, if your library contains a public function:\n \n ```rust\n // src/lib.rs\n@@ -16,6 +16,7 @@ fn main() {\n \n Then this code snippet will be included in the documentation for `a_func`.\n \n+\n ## How to read scraped examples\n \n Scraped examples are shown as blocks of code from a given file. The relevant item will be highlighted. If the file is larger than a couple lines, only a small window will be shown which you can expand by clicking &varr; in the top-right. If a file contains multiple instances of an item, you can use the &pr; and &sc; buttons to toggle through each instance.\n@@ -25,7 +26,7 @@ If there is more than one file that contains examples, then you should click \"Mo\n \n ## How Rustdoc scrapes examples\n \n-When you run `cargo doc`, Rustdoc will analyze all the crates that match Cargo's `--examples` filter for instances of items that occur in the crates being documented. Then Rustdoc will include the source code of these instances in the generated documentation.\n+When you run `cargo doc -Zunstable-options -Zrustdoc-scrape-examples`, Rustdoc will analyze all the documented crates for uses of documented items. Then Rustdoc will include the source code of these instances in the generated documentation.\n \n Rustdoc has a few techniques to ensure this doesn't overwhelm documentation readers, and that it doesn't blow up the page size:\n "}, {"sha": "ef1d7da5a341cf8ca191f171ba22dba6cd462abc", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -674,7 +674,7 @@ type MainResult = Result<(), ErrorGuaranteed>;\n \n fn wrap_return(diag: &rustc_errors::Handler, res: Result<(), String>) -> MainResult {\n     match res {\n-        Ok(()) => Ok(()),\n+        Ok(()) => diag.has_errors().map_or(Ok(()), Err),\n         Err(err) => {\n             let reported = diag.struct_err(&err).emit();\n             Err(reported)\n@@ -689,7 +689,7 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n ) -> MainResult {\n     match formats::run_format::<T>(krate, renderopts, cache, tcx) {\n-        Ok(_) => Ok(()),\n+        Ok(_) => tcx.sess.has_errors().map_or(Ok(()), Err),\n         Err(e) => {\n             let mut msg =\n                 tcx.sess.struct_err(&format!(\"couldn't generate documentation: {}\", e.error));\n@@ -774,6 +774,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n     let output_format = options.output_format;\n     let externs = options.externs.clone();\n     let scrape_examples_options = options.scrape_examples_options.clone();\n+    let bin_crate = options.bin_crate;\n \n     let config = core::create_config(options);\n \n@@ -832,7 +833,14 @@ fn main_args(at_args: &[String]) -> MainResult {\n                 info!(\"finished with rustc\");\n \n                 if let Some(options) = scrape_examples_options {\n-                    return scrape_examples::run(krate, render_opts, cache, tcx, options);\n+                    return scrape_examples::run(\n+                        krate,\n+                        render_opts,\n+                        cache,\n+                        tcx,\n+                        options,\n+                        bin_crate,\n+                    );\n                 }\n \n                 cache.crate_version = crate_version;"}, {"sha": "f2ee99cd9d4943e1e1a576d1c26a52d1f8881541", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -110,6 +110,7 @@ pub(crate) struct CallData {\n     pub(crate) url: String,\n     pub(crate) display_name: String,\n     pub(crate) edition: Edition,\n+    pub(crate) is_bin: bool,\n }\n \n pub(crate) type FnCallLocations = FxHashMap<PathBuf, CallData>;\n@@ -122,6 +123,7 @@ struct FindCalls<'a, 'tcx> {\n     cx: Context<'tcx>,\n     target_crates: Vec<CrateNum>,\n     calls: &'a mut AllCallLocations,\n+    bin_crate: bool,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for FindCalls<'a, 'tcx>\n@@ -245,7 +247,9 @@ where\n                 let mk_call_data = || {\n                     let display_name = file_path.display().to_string();\n                     let edition = call_span.edition();\n-                    CallData { locations: Vec::new(), url, display_name, edition }\n+                    let is_bin = self.bin_crate;\n+\n+                    CallData { locations: Vec::new(), url, display_name, edition, is_bin }\n                 };\n \n                 let fn_key = tcx.def_path_hash(*def_id);\n@@ -274,6 +278,7 @@ pub(crate) fn run(\n     cache: formats::cache::Cache,\n     tcx: TyCtxt<'_>,\n     options: ScrapeExamplesOptions,\n+    bin_crate: bool,\n ) -> interface::Result<()> {\n     let inner = move || -> Result<(), String> {\n         // Generates source files for examples\n@@ -300,7 +305,8 @@ pub(crate) fn run(\n \n         // Run call-finder on all items\n         let mut calls = FxHashMap::default();\n-        let mut finder = FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx, target_crates };\n+        let mut finder =\n+            FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx, target_crates, bin_crate };\n         tcx.hir().visit_all_item_likes_in_crate(&mut finder);\n \n         // The visitor might have found a type error, which we need to"}, {"sha": "b90ef104ce72a3fd2c2a28744066d545c42d6b34", "filename": "src/test/codegen/catch-unwind.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fcatch-unwind.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,6 +8,8 @@\n // On riscv the closure is another function, placed before fn foo so CHECK can't\n // find it\n // ignore-riscv64 FIXME\n+// On s390x the closure is also in another function\n+// ignore-s390x FIXME\n \n #![crate_type = \"lib\"]\n #![feature(c_unwind)]"}, {"sha": "d54ac9e33bce27c865b75cfe9ee4e859e43a2488", "filename": "src/test/codegen/issue-105386-ub-in-debuginfo.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fissue-105386-ub-in-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fissue-105386-ub-in-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-105386-ub-in-debuginfo.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: --crate-type=lib -O -Cdebuginfo=2 -Cno-prepopulate-passes\n+// min-llvm-version: 15.0 # this test uses opaque pointer notation\n+#![feature(stmt_expr_attributes)]\n+\n+pub struct S([usize; 8]);\n+\n+#[no_mangle]\n+pub fn outer_function(x: S, y: S) -> usize {\n+    (#[inline(always)]|| {\n+        let _z = x;\n+        y.0[0]\n+    })()\n+}\n+\n+// Check that we do not attempt to load from the spilled arg before it is assigned to\n+// when generating debuginfo.\n+// CHECK-LABEL: @outer_function\n+// CHECK: [[spill:%.*]] = alloca %\"[closure@{{.*.rs}}:9:23: 9:25]\"\n+// CHECK-NOT: [[ptr_tmp:%.*]] = getelementptr inbounds %\"[closure@{{.*.rs}}:9:23: 9:25]\", ptr [[spill]]\n+// CHECK-NOT: [[load:%.*]] = load ptr, ptr\n+// CHECK: call void @llvm.lifetime.start{{.*}}({{.*}}, ptr [[spill]])\n+// CHECK: call void @llvm.memcpy{{.*}}(ptr {{align .*}} [[spill]], ptr {{align .*}} %x"}, {"sha": "78ebbccfce1950fe372e1dc74f9f9723d6f92cdf", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -12,7 +12,7 @@ mod aux_mod;\n include!(\"aux_mod.rs\");\n \n // Here we check that the expansion of the file!() macro is mapped.\n-// CHECK: @alloc2 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>, align 1\n+// CHECK: @alloc2 = private unnamed_addr constant <{ [34 x i8] }> <{ [34 x i8] c\"/the/src/remap_path_prefix/main.rs\" }>\n pub static FILE_PATH: &'static str = file!();\n \n fn main() {"}, {"sha": "f733de12b3537097f21a0f4a3cea52185d7c18d0", "filename": "src/test/codegen/repr-transparent-aggregates-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,6 +8,7 @@\n // ignore-powerpc\n // ignore-powerpc64\n // ignore-riscv64 see codegen/riscv-abi\n+// ignore-s390x\n // ignore-windows\n // See repr-transparent.rs\n "}, {"sha": "4f2313ce47a979be33140172948c254831e8b538", "filename": "src/test/codegen/repr-transparent.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,6 +2,7 @@\n \n // ignore-riscv64 riscv64 has an i128 type used with test_Vector\n // see codegen/riscv-abi for riscv functiona call tests\n+// ignore-s390x s390x with default march passes vector types per reference\n \n #![crate_type=\"lib\"]\n #![feature(repr_simd, transparent_unions)]"}, {"sha": "c2eb852aec3c7662c1a7e1a3f92d23ecb3229631", "filename": "src/test/codegen/sanitizer-kcfi-add-kcfi-flag.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,11 @@\n+// Verifies that \"kcfi\" module flag is added.\n+//\n+// needs-sanitizer-kcfi\n+// compile-flags: -Ctarget-feature=-crt-static -Zsanitizer=kcfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"kcfi\", i32 1}"}, {"sha": "0afd9727517edf4c4e74930b08c9e87425250938", "filename": "src/test/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,47 @@\n+// Verifies that KCFI type metadata for functions are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE1:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg){{.*}}[ \"kcfi\"(i32 -1666898348) ]\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE2:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg1, i32 %arg2){{.*}}[ \"kcfi\"(i32 -1789026986) ]\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE3:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg1, i32 %arg2, i32 %arg3){{.*}}[ \"kcfi\"(i32 1248878270) ]\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i32 653723426}\n+// CHECK: ![[TYPE2]] = !{i32 412174924}\n+// CHECK: ![[TYPE3]] = !{i32 -636668840}"}, {"sha": "98a6761f8abbb3261bf660427bc97392f6891431", "filename": "src/test/codegen/uninit-consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funinit-consts.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@ pub struct PartiallyUninit {\n \n // CHECK: [[FULLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [10 x i8] }> undef\n \n-// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [4 x i8], [12 x i8] }> <{ [4 x i8] c\"\\EF\\BE\\AD\\DE\", [12 x i8] undef }>, align 4\n+// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [4 x i8], [12 x i8] }> <{ [4 x i8] c\"{{\\\\EF\\\\BE\\\\AD\\\\DE|\\\\DE\\\\AD\\\\BE\\\\EF}}\", [12 x i8] undef }>, align 4\n \n // This shouldn't contain undef, since it contains more chunks\n // than the default value of uninit_const_chunk_threshold."}, {"sha": "9780332d8bf18813d2658000920e92e91f7e8824", "filename": "src/test/mir-opt/76803_regression.encode.SimplifyBranchSame.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2F76803_regression.encode.SimplifyBranchSame.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,7 +8,7 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/76803_regression.rs:+1:11: +1:12\n-          switchInt(move _2) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/76803_regression.rs:+1:5: +1:12\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/76803_regression.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "0af5d82d31540debb60c201f5201332058981578", "filename": "src/test/mir-opt/bool_compare.opt1.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt1.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt1.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbool_compare.opt1.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Ne(move _3, const true);    // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n +         _2 = Not(move _3);               // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n           StorageDead(_3);                 // scope 0 at $DIR/bool_compare.rs:+1:16: +1:17\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n       }\n   \n       bb1: {"}, {"sha": "f5d1febd991cd5aef3f2964c80372d1966e8fd5b", "filename": "src/test/mir-opt/bool_compare.opt2.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt2.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt2.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbool_compare.opt2.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Ne(const true, move _3);    // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n +         _2 = Not(move _3);               // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n           StorageDead(_3);                 // scope 0 at $DIR/bool_compare.rs:+1:16: +1:17\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:17\n       }\n   \n       bb1: {"}, {"sha": "e7432adac7d9d366e75830c62b45d8f9ae3ff569", "filename": "src/test/mir-opt/bool_compare.opt3.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt3.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt3.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbool_compare.opt3.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Eq(move _3, const false);   // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n +         _2 = Not(move _3);               // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n           StorageDead(_3);                 // scope 0 at $DIR/bool_compare.rs:+1:17: +1:18\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n       }\n   \n       bb1: {"}, {"sha": "6b3e27772f71c978b4bd06feb76e83cf5d0226a0", "filename": "src/test/mir-opt/bool_compare.opt4.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt4.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbool_compare.opt4.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbool_compare.opt4.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Eq(const false, move _3);   // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n +         _2 = Not(move _3);               // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n           StorageDead(_3);                 // scope 0 at $DIR/bool_compare.rs:+1:17: +1:18\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/bool_compare.rs:+1:8: +1:18\n       }\n   \n       bb1: {"}, {"sha": "628a33f1020a5f625d333a536f9c795061a24d79", "filename": "src/test/mir-opt/building/issue_101867.main.built.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_101867.main.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_101867.main.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_101867.main.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -27,7 +27,7 @@ fn main() -> () {\n         StorageLive(_5);                 // scope 1 at $DIR/issue_101867.rs:+2:14: +2:15\n         FakeRead(ForMatchedPlace(None), _1); // scope 1 at $DIR/issue_101867.rs:+2:19: +2:20\n         _6 = discriminant(_1);           // scope 1 at $DIR/issue_101867.rs:+2:19: +2:20\n-        switchInt(move _6) -> [1_isize: bb4, otherwise: bb3]; // scope 1 at $DIR/issue_101867.rs:+2:9: +2:16\n+        switchInt(move _6) -> [1: bb4, otherwise: bb3]; // scope 1 at $DIR/issue_101867.rs:+2:9: +2:16\n     }\n \n     bb1: {"}, {"sha": "de5e4c0f6ed48dc33a50002ebb2bb8edc0b9f33c", "filename": "src/test/mir-opt/building/issue_49232.main.built.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_49232.main.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_49232.main.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fissue_49232.main.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -25,7 +25,7 @@ fn main() -> () {\n         StorageLive(_3);                 // scope 0 at $DIR/issue_49232.rs:+3:19: +3:23\n         _3 = const true;                 // scope 0 at $DIR/issue_49232.rs:+3:19: +3:23\n         FakeRead(ForMatchedPlace(None), _3); // scope 0 at $DIR/issue_49232.rs:+3:19: +3:23\n-        switchInt(_3) -> [false: bb3, otherwise: bb4]; // scope 0 at $DIR/issue_49232.rs:+3:13: +3:23\n+        switchInt(_3) -> [0: bb3, otherwise: bb4]; // scope 0 at $DIR/issue_49232.rs:+3:13: +3:23\n     }\n \n     bb3: {"}, {"sha": "cb36bc64da69597809b68fdb2dac704c6ff7accc", "filename": "src/test/mir-opt/building/match_false_edges.full_tested_match.built.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -28,7 +28,7 @@ fn full_tested_match() -> () {\n         _2 = Option::<i32>::Some(const 42_i32); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n         FakeRead(ForMatchedPlace(None), _2); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n         _3 = discriminant(_2);           // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n-        switchInt(move _3) -> [0_isize: bb1, 1_isize: bb2, otherwise: bb4]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:27\n+        switchInt(move _3) -> [0: bb1, 1: bb2, otherwise: bb4]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:27\n     }\n \n     bb1: {\n@@ -60,7 +60,7 @@ fn full_tested_match() -> () {\n     }\n \n     bb6: {\n-        switchInt(move _7) -> [false: bb8, otherwise: bb7]; // scope 0 at $DIR/match_false_edges.rs:+2:20: +2:27\n+        switchInt(move _7) -> [0: bb8, otherwise: bb7]; // scope 0 at $DIR/match_false_edges.rs:+2:20: +2:27\n     }\n \n     bb7: {"}, {"sha": "7f8755faac6cf78f146d55ec9a291ced6ae387dc", "filename": "src/test/mir-opt/building/match_false_edges.full_tested_match2.built.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match2.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match2.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.full_tested_match2.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -28,7 +28,7 @@ fn full_tested_match2() -> () {\n         _2 = Option::<i32>::Some(const 42_i32); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n         FakeRead(ForMatchedPlace(None), _2); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n         _3 = discriminant(_2);           // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:27\n-        switchInt(move _3) -> [0_isize: bb1, 1_isize: bb2, otherwise: bb4]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:27\n+        switchInt(move _3) -> [0: bb1, 1: bb2, otherwise: bb4]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:27\n     }\n \n     bb1: {\n@@ -66,7 +66,7 @@ fn full_tested_match2() -> () {\n     }\n \n     bb6: {\n-        switchInt(move _7) -> [false: bb8, otherwise: bb7]; // scope 0 at $DIR/match_false_edges.rs:+2:20: +2:27\n+        switchInt(move _7) -> [0: bb8, otherwise: bb7]; // scope 0 at $DIR/match_false_edges.rs:+2:20: +2:27\n     }\n \n     bb7: {"}, {"sha": "e8b93f4371ecbadb05ce0c559300d80d3de25c31", "filename": "src/test/mir-opt/building/match_false_edges.main.built.after.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.main.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.main.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fmatch_false_edges.main.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -39,7 +39,7 @@ fn main() -> () {\n         _2 = Option::<i32>::Some(const 1_i32); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:26\n         FakeRead(ForMatchedPlace(None), _2); // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:26\n         _4 = discriminant(_2);           // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:26\n-        switchInt(move _4) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:26\n+        switchInt(move _4) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:26\n     }\n \n     bb1: {\n@@ -56,7 +56,7 @@ fn main() -> () {\n \n     bb4: {\n         _3 = discriminant(_2);           // scope 0 at $DIR/match_false_edges.rs:+1:19: +1:26\n-        switchInt(move _3) -> [1_isize: bb6, otherwise: bb5]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:26\n+        switchInt(move _3) -> [1: bb6, otherwise: bb5]; // scope 0 at $DIR/match_false_edges.rs:+1:13: +1:26\n     }\n \n     bb5: {\n@@ -87,7 +87,7 @@ fn main() -> () {\n     }\n \n     bb9: {\n-        switchInt(move _8) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/match_false_edges.rs:+2:21: +2:28\n+        switchInt(move _8) -> [0: bb11, otherwise: bb10]; // scope 0 at $DIR/match_false_edges.rs:+2:21: +2:28\n     }\n \n     bb10: {\n@@ -134,7 +134,7 @@ fn main() -> () {\n     }\n \n     bb15: {\n-        switchInt(move _12) -> [false: bb17, otherwise: bb16]; // scope 0 at $DIR/match_false_edges.rs:+4:20: +4:29\n+        switchInt(move _12) -> [0: bb17, otherwise: bb16]; // scope 0 at $DIR/match_false_edges.rs:+4:20: +4:29\n     }\n \n     bb16: {"}, {"sha": "aa2fd46320e137fa281c34109ea89ed27f5187b7", "filename": "src/test/mir-opt/building/simple_match.match_bool.built.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fsimple_match.match_bool.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fbuilding%2Fsimple_match.match_bool.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbuilding%2Fsimple_match.match_bool.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -6,7 +6,7 @@ fn match_bool(_1: bool) -> usize {\n \n     bb0: {\n         FakeRead(ForMatchedPlace(None), _1); // scope 0 at $DIR/simple_match.rs:+1:11: +1:12\n-        switchInt(_1) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/simple_match.rs:+1:5: +1:12\n+        switchInt(_1) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/simple_match.rs:+1:5: +1:12\n     }\n \n     bb1: {"}, {"sha": "a717d1bbd12f2c2ab965969cdebd33d9fdd30efa", "filename": "src/test/mir-opt/const_goto.issue_77355_opt.ConstGoto.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto.issue_77355_opt.ConstGoto.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto.issue_77355_opt.ConstGoto.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_goto.issue_77355_opt.ConstGoto.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -11,9 +11,9 @@\n       bb0: {\n -         StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n -         _3 = discriminant(_1);           // scope 0 at $DIR/const_goto.rs:+1:17: +1:20\n--         switchInt(move _3) -> [1_isize: bb2, 2_isize: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+-         switchInt(move _3) -> [1: bb2, 2: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n +         _2 = discriminant(_1);           // scope 0 at $DIR/const_goto.rs:+1:17: +1:20\n-+         switchInt(move _2) -> [1_isize: bb2, 2_isize: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         switchInt(move _2) -> [1: bb2, 2: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n@@ -29,7 +29,7 @@\n -     }\n - \n -     bb3: {\n--         switchInt(move _2) -> [false: bb5, otherwise: bb4]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+-         switchInt(move _2) -> [0: bb5, otherwise: bb4]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n -     }\n - \n -     bb4: {"}, {"sha": "24be8c9b86845b8147db55dbfe373cf695a6eebb", "filename": "src/test/mir-opt/const_goto_const_eval_fail.f.ConstGoto.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto_const_eval_fail.f.ConstGoto.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto_const_eval_fail.f.ConstGoto.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_goto_const_eval_fail.f.ConstGoto.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -10,7 +10,7 @@\n           StorageLive(_1);                 // scope 0 at $DIR/const_goto_const_eval_fail.rs:+1:11: +6:6\n           StorageLive(_2);                 // scope 0 at $DIR/const_goto_const_eval_fail.rs:+2:15: +2:16\n           _2 = const A;                    // scope 0 at $DIR/const_goto_const_eval_fail.rs:+2:15: +2:16\n-          switchInt(_2) -> [1_i32: bb2, 2_i32: bb2, 3_i32: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+2:9: +2:16\n+          switchInt(_2) -> [1: bb2, 2: bb2, 3: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+2:9: +2:16\n       }\n   \n       bb1: {\n@@ -21,11 +21,11 @@\n       bb2: {\n           _1 = const B;                    // scope 0 at $DIR/const_goto_const_eval_fail.rs:+3:26: +3:27\n -         goto -> bb3;                     // scope 0 at $DIR/const_goto_const_eval_fail.rs:+3:26: +3:27\n-+         switchInt(_1) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+1:5: +6:6\n++         switchInt(_1) -> [0: bb4, otherwise: bb3]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+1:5: +6:6\n       }\n   \n       bb3: {\n--         switchInt(_1) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+1:5: +6:6\n+-         switchInt(_1) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/const_goto_const_eval_fail.rs:+1:5: +6:6\n -     }\n - \n -     bb4: {"}, {"sha": "f54577259431da796336b9c52d937c479de6e213", "filename": "src/test/mir-opt/const_goto_storage.match_nested_if.ConstGoto.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_goto_storage.match_nested_if.ConstGoto.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -23,10 +23,10 @@\n -         StorageLive(_5);                 // scope 0 at $DIR/const_goto_storage.rs:+2:21: +2:52\n -         StorageLive(_6);                 // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n -         _6 = const true;                 // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n--         switchInt(move _6) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n+-         switchInt(move _6) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n +         StorageLive(_2);                 // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n +         _2 = const true;                 // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n-+         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n++         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/const_goto_storage.rs:+2:24: +2:28\n       }\n   \n       bb1: {\n@@ -41,7 +41,7 @@\n - \n -     bb3: {\n -         StorageDead(_6);                 // scope 0 at $DIR/const_goto_storage.rs:+2:51: +2:52\n--         switchInt(move _5) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/const_goto_storage.rs:+2:21: +2:52\n+-         switchInt(move _5) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/const_goto_storage.rs:+2:21: +2:52\n -     }\n - \n -     bb4: {\n@@ -56,7 +56,7 @@\n - \n -     bb6: {\n -         StorageDead(_5);                 // scope 0 at $DIR/const_goto_storage.rs:+2:75: +2:76\n--         switchInt(move _4) -> [false: bb8, otherwise: bb7]; // scope 0 at $DIR/const_goto_storage.rs:+2:18: +2:76\n+-         switchInt(move _4) -> [0: bb8, otherwise: bb7]; // scope 0 at $DIR/const_goto_storage.rs:+2:18: +2:76\n -     }\n - \n -     bb7: {\n@@ -70,7 +70,7 @@\n -     }\n - \n -     bb9: {\n--         switchInt(move _3) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/const_goto_storage.rs:+2:15: +6:10\n+-         switchInt(move _3) -> [0: bb11, otherwise: bb10]; // scope 0 at $DIR/const_goto_storage.rs:+2:15: +6:10\n -     }\n - \n -     bb10: {"}, {"sha": "147670f8a915c4681eb853556097617f52ebf063", "filename": "src/test/mir-opt/const_prop/control_flow_simplification.hello.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcontrol_flow_simplification.hello.ConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -9,8 +9,8 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n           _1 = const _;                    // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n--         switchInt(move _1) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n-+         switchInt(const false) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n+-         switchInt(move _1) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n++         switchInt(const false) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/control_flow_simplification.rs:+1:8: +1:21\n       }\n   \n       bb1: {"}, {"sha": "b4dccecc67265e74d5191fa6930acf8b1ee8e307", "filename": "src/test/mir-opt/const_prop/discriminant.main.ConstProp.32bit.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -21,13 +21,13 @@\n           ((_3 as Some).0: bool) = const true; // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n           discriminant(_3) = 1;            // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n -         _4 = discriminant(_3);           // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n--         switchInt(move _4) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+-         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n-+         switchInt(const 1_isize) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb1: {\n-          switchInt(((_3 as Some).0: bool)) -> [false: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+          switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb2: {"}, {"sha": "b4dccecc67265e74d5191fa6930acf8b1ee8e307", "filename": "src/test/mir-opt/const_prop/discriminant.main.ConstProp.64bit.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -21,13 +21,13 @@\n           ((_3 as Some).0: bool) = const true; // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n           discriminant(_3) = 1;            // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n -         _4 = discriminant(_3);           // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n--         switchInt(move _4) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+-         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n-+         switchInt(const 1_isize) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n++         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb1: {\n-          switchInt(((_3 as Some).0: bool)) -> [false: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n+          switchInt(((_3 as Some).0: bool)) -> [0: bb3, otherwise: bb2]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n       }\n   \n       bb2: {"}, {"sha": "ddc1a4493dbbf697a02a4a41f868e8fc83c7e8cb", "filename": "src/test/mir-opt/const_prop/switch_int.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.ConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,8 +8,8 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/switch_int.rs:+1:11: +1:12\n           _1 = const 1_i32;                // scope 0 at $DIR/switch_int.rs:+1:11: +1:12\n--         switchInt(_1) -> [1_i32: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n-+         switchInt(const 1_i32) -> [1_i32: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n+-         switchInt(_1) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n++         switchInt(const 1_i32) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "09c47ee6e8309deaa6504a8c0f9d55faefc55223", "filename": "src/test/mir-opt/const_prop/switch_int.main.SimplifyConstCondition-after-const-prop.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fswitch_int.main.SimplifyConstCondition-after-const-prop.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,7 +8,7 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/switch_int.rs:+1:11: +1:12\n           _1 = const 1_i32;                // scope 0 at $DIR/switch_int.rs:+1:11: +1:12\n--         switchInt(const 1_i32) -> [1_i32: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n+-         switchInt(const 1_i32) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n +         goto -> bb2;                     // scope 0 at $DIR/switch_int.rs:+1:5: +1:12\n       }\n   "}, {"sha": "c4d389b2d764818426147cf1822148f1d089174d", "filename": "src/test/mir-opt/coverage_graphviz.main.InstrumentCoverage.0.dot", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcoverage_graphviz.main.InstrumentCoverage.0.dot?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -7,7 +7,7 @@ digraph Cov_0_3 {\n     bcb1__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb1</td></tr><tr><td align=\"left\" balign=\"left\">Expression(bcb0 + bcb3) at 10:5-11:17<br align=\"left\"/>    11:12-11:17: @2.Call: _2 = bar() -&gt; [return: bb3, unwind: bb6]</td></tr><tr><td align=\"left\" balign=\"left\">bb1: FalseUnwind<br align=\"left\"/>bb2: Call</td></tr><tr><td align=\"left\" balign=\"left\">bb3: SwitchInt</td></tr></table>>];\n     bcb0__Cov_0_3 [shape=\"none\", label=<<table border=\"0\" cellborder=\"1\" cellspacing=\"0\"><tr><td bgcolor=\"gray\" align=\"center\" colspan=\"1\">bcb0</td></tr><tr><td align=\"left\" balign=\"left\"></td></tr><tr><td align=\"left\" balign=\"left\">Counter(bcb0) at 9:1-9:11<br align=\"left\"/>    </td></tr><tr><td align=\"left\" balign=\"left\">bb0: Goto</td></tr></table>>];\n     bcb3__Cov_0_3 -> bcb1__Cov_0_3 [label=<>];\n-    bcb1__Cov_0_3 -> bcb3__Cov_0_3 [label=<false>];\n+    bcb1__Cov_0_3 -> bcb3__Cov_0_3 [label=<0>];\n     bcb1__Cov_0_3 -> bcb2__Cov_0_3 [label=<otherwise>];\n     bcb0__Cov_0_3 -> bcb1__Cov_0_3 [label=<>];\n }"}, {"sha": "fce18fae4362f17224dfcc0ed6213575176167c5", "filename": "src/test/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fenum.main.DataflowConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -28,7 +28,7 @@\n           discriminant(_1) = 0;            // scope 0 at $DIR/enum.rs:+1:13: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n           _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n-          switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n+          switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n       }\n   \n       bb1: {"}, {"sha": "32489b4bd6bfeb57987277e2e1fe14fea90ea0a8", "filename": "src/test/mir-opt/dataflow-const-prop/if.main.DataflowConstProp.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fif.main.DataflowConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -42,8 +42,8 @@\n +         _4 = const 1_i32;                // scope 1 at $DIR/if.rs:+2:16: +2:17\n +         _3 = const true;                 // scope 1 at $DIR/if.rs:+2:16: +2:22\n           StorageDead(_4);                 // scope 1 at $DIR/if.rs:+2:21: +2:22\n--         switchInt(move _3) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n-+         switchInt(const true) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n+-         switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n++         switchInt(const true) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/if.rs:+2:16: +2:22\n       }\n   \n       bb1: {\n@@ -73,8 +73,8 @@\n +         _9 = const 1_i32;                // scope 3 at $DIR/if.rs:+5:16: +5:17\n +         _8 = const true;                 // scope 3 at $DIR/if.rs:+5:16: +5:22\n           StorageDead(_9);                 // scope 3 at $DIR/if.rs:+5:21: +5:22\n--         switchInt(move _8) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n-+         switchInt(const true) -> [false: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n+-         switchInt(move _8) -> [0: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n++         switchInt(const true) -> [0: bb5, otherwise: bb4]; // scope 3 at $DIR/if.rs:+5:16: +5:22\n       }\n   \n       bb4: {"}, {"sha": "5a87884977c39bc3b8aa7f711dc2159561ac4ef8", "filename": "src/test/mir-opt/dataflow-const-prop/issue_81605.f.DataflowConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fissue_81605.f.DataflowConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -10,8 +10,8 @@\n           StorageLive(_1);                 // scope 0 at $DIR/issue_81605.rs:+1:9: +1:33\n           StorageLive(_2);                 // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n           _2 = const true;                 // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n-+         switchInt(const true) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n++         switchInt(const true) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/issue_81605.rs:+1:12: +1:16\n       }\n   \n       bb1: {"}, {"sha": "80f8905adc92d93ae714a7b326a16ec22e6f11cd", "filename": "src/test/mir-opt/dead-store-elimination/cycle.cycle.DeadStoreElimination.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdead-store-elimination%2Fcycle.cycle.DeadStoreElimination.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -37,8 +37,8 @@\n       }\n   \n       bb2: {\n--         switchInt(move _5) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n-+         switchInt(move _4) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n+-         switchInt(move _5) -> [0: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n++         switchInt(move _4) -> [0: bb4, otherwise: bb3]; // scope 0 at $DIR/cycle.rs:+3:11: +3:17\n       }\n   \n       bb3: {"}, {"sha": "210d3849e18a106bb1e76987b5934588e335ba34", "filename": "src/test/mir-opt/deaggregator_test_enum_2.test1.Deaggregator.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test_enum_2.test1.Deaggregator.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -12,7 +12,7 @@\n       bb0: {\n           StorageLive(_3);                 // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n           _3 = _1;                         // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n-          switchInt(move _3) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n+          switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/deaggregator_test_enum_2.rs:+1:8: +1:9\n       }\n   \n       bb1: {"}, {"sha": "3b1f81175cbfcc49148618d7a177f8522b0e7c8b", "filename": "src/test/mir-opt/deduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeduplicate_blocks.is_line_doc_comment_2.DeduplicateBlocks.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -28,44 +28,44 @@\n           _7 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:+2:9: +2:37\n           _8 = const 4_usize;              // scope 0 at $DIR/deduplicate_blocks.rs:+2:9: +2:37\n           _9 = Ge(move _7, move _8);       // scope 0 at $DIR/deduplicate_blocks.rs:+2:9: +2:37\n-          switchInt(move _9) -> [false: bb6, otherwise: bb2]; // scope 0 at $DIR/deduplicate_blocks.rs:+2:9: +2:37\n+          switchInt(move _9) -> [0: bb6, otherwise: bb2]; // scope 0 at $DIR/deduplicate_blocks.rs:+2:9: +2:37\n       }\n   \n       bb2: {\n-          switchInt((*_2)[0 of 4]) -> [47_u8: bb3, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+          switchInt((*_2)[0 of 4]) -> [47: bb3, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb3: {\n-          switchInt((*_2)[1 of 4]) -> [47_u8: bb4, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+          switchInt((*_2)[1 of 4]) -> [47: bb4, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb4: {\n-          switchInt((*_2)[2 of 4]) -> [47_u8: bb5, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+          switchInt((*_2)[2 of 4]) -> [47: bb5, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb5: {\n--         switchInt((*_2)[3 of 4]) -> [47_u8: bb11, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n-+         switchInt((*_2)[3 of 4]) -> [47_u8: bb10, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+-         switchInt((*_2)[3 of 4]) -> [47: bb11, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n++         switchInt((*_2)[3 of 4]) -> [47: bb10, otherwise: bb6]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb6: {\n           _4 = Len((*_2));                 // scope 0 at $DIR/deduplicate_blocks.rs:+3:9: +3:31\n           _5 = const 3_usize;              // scope 0 at $DIR/deduplicate_blocks.rs:+3:9: +3:31\n           _6 = Ge(move _4, move _5);       // scope 0 at $DIR/deduplicate_blocks.rs:+3:9: +3:31\n-          switchInt(move _6) -> [false: bb10, otherwise: bb7]; // scope 0 at $DIR/deduplicate_blocks.rs:+3:9: +3:31\n+          switchInt(move _6) -> [0: bb10, otherwise: bb7]; // scope 0 at $DIR/deduplicate_blocks.rs:+3:9: +3:31\n       }\n   \n       bb7: {\n-          switchInt((*_2)[0 of 3]) -> [47_u8: bb8, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+          switchInt((*_2)[0 of 3]) -> [47: bb8, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb8: {\n-          switchInt((*_2)[1 of 3]) -> [47_u8: bb9, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+          switchInt((*_2)[1 of 3]) -> [47: bb9, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb9: {\n--         switchInt((*_2)[2 of 3]) -> [47_u8: bb12, 33_u8: bb13, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n-+         switchInt((*_2)[2 of 3]) -> [47_u8: bb11, 33_u8: bb11, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n+-         switchInt((*_2)[2 of 3]) -> [47: bb12, 33: bb13, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n++         switchInt((*_2)[2 of 3]) -> [47: bb11, 33: bb11, otherwise: bb10]; // scope 0 at $DIR/deduplicate_blocks.rs:+1:5: +1:23\n       }\n   \n       bb10: {"}, {"sha": "9597a0c835fddd26907f92f59533943e9eb7b009", "filename": "src/test/mir-opt/deref-patterns/string.foo.PreCodegen.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderef-patterns%2Fstring.foo.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -17,7 +17,7 @@ fn foo(_1: Option<String>) -> i32 {\n         _7 = const false;                // scope 0 at $DIR/string.rs:+1:11: +1:12\n         _7 = const true;                 // scope 0 at $DIR/string.rs:+1:11: +1:12\n         _5 = discriminant(_1);           // scope 0 at $DIR/string.rs:+1:11: +1:12\n-        switchInt(move _5) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/string.rs:+1:5: +1:12\n+        switchInt(move _5) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/string.rs:+1:5: +1:12\n     }\n \n     bb1: {\n@@ -47,7 +47,7 @@ fn foo(_1: Option<String>) -> i32 {\n     }\n \n     bb4: {\n-        switchInt(move _4) -> [false: bb1, otherwise: bb5]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n+        switchInt(move _4) -> [0: bb1, otherwise: bb5]; // scope 0 at $DIR/string.rs:+2:14: +2:17\n     }\n \n     bb5: {\n@@ -69,6 +69,6 @@ fn foo(_1: Option<String>) -> i32 {\n     }\n \n     bb9: {\n-        switchInt(_7) -> [false: bb7, otherwise: bb8]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n+        switchInt(_7) -> [0: bb7, otherwise: bb8]; // scope 0 at $DIR/string.rs:+5:1: +5:2\n     }\n }"}, {"sha": "fa3eeedc40fffee479371c748617291fe96cd852", "filename": "src/test/mir-opt/derefer_complex_case.main.Derefer.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderefer_complex_case.main.Derefer.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderefer_complex_case.main.Derefer.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderefer_complex_case.main.Derefer.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -62,7 +62,7 @@\n       bb3: {\n           StorageDead(_8);                 // scope 1 at $DIR/derefer_complex_case.rs:+1:25: +1:26\n           _10 = discriminant(_7);          // scope 1 at $DIR/derefer_complex_case.rs:+1:17: +1:26\n-          switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 1 at $DIR/derefer_complex_case.rs:+1:17: +1:26\n+          switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 1 at $DIR/derefer_complex_case.rs:+1:17: +1:26\n       }\n   \n       bb4: {"}, {"sha": "ab2388d1323a85cb6f0ab499ef9c1915fa0c6fc3", "filename": "src/test/mir-opt/derefer_terminator_test.main.Derefer.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderefer_terminator_test.main.Derefer.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fderefer_terminator_test.main.Derefer.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fderefer_terminator_test.main.Derefer.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -54,11 +54,11 @@\n           _6 = &_7;                        // scope 2 at $DIR/derefer_terminator_test.rs:+3:18: +3:21\n           _5 = &_6;                        // scope 2 at $DIR/derefer_terminator_test.rs:+3:17: +3:21\n           _4 = &_5;                        // scope 2 at $DIR/derefer_terminator_test.rs:+3:15: +3:22\n--         switchInt((*(*(*(*_4))))) -> [false: bb3, otherwise: bb4]; // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n+-         switchInt((*(*(*(*_4))))) -> [0: bb3, otherwise: bb4]; // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n +         _10 = deref_copy (*_4);          // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n +         _11 = deref_copy (*_10);         // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n +         _12 = deref_copy (*_11);         // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n-+         switchInt((*_12)) -> [false: bb3, otherwise: bb4]; // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n++         switchInt((*_12)) -> [0: bb3, otherwise: bb4]; // scope 2 at $DIR/derefer_terminator_test.rs:+3:5: +3:22\n       }\n   \n       bb3: {"}, {"sha": "9c729663265e087f5507fb2b769c4d0acbc81eaf", "filename": "src/test/mir-opt/dest-prop/branch.foo.DestinationPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdest-prop%2Fbranch.foo.DestinationPropagation.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -37,7 +37,7 @@\n       }\n   \n       bb2: {\n-          switchInt(move _3) -> [false: bb4, otherwise: bb3]; // scope 1 at $DIR/branch.rs:+3:16: +3:22\n+          switchInt(move _3) -> [0: bb4, otherwise: bb3]; // scope 1 at $DIR/branch.rs:+3:16: +3:22\n       }\n   \n       bb3: {"}, {"sha": "98a02ee38dd1769b2e6bd0cf5bcac0f74b14b2eb", "filename": "src/test/mir-opt/early_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt1.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -31,13 +31,13 @@\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _7) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _10 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _11 = Ne(_7, move _10);          // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageDead(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(move _11) -> [false: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(move _11) -> [0: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   \n       bb1: {\n@@ -49,7 +49,7 @@\n   \n       bb2: {\n -         _6 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _6) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _6) -> [1: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n -     }\n - \n -     bb3: {\n@@ -72,7 +72,7 @@\n + \n +     bb4: {\n +         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(_7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(_7) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   }\n   "}, {"sha": "aa75c44b809a90543004dbd7f49c9ec9d949953c", "filename": "src/test/mir-opt/early_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt2.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -32,18 +32,18 @@\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _8 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _8) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _8) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _11 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_12);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _12 = Ne(_8, move _11);          // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(move _12) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(move _12) -> [0: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   \n       bb1: {\n -         _6 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _6) -> [0_isize: bb5, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _6) -> [0: bb5, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n -     }\n - \n -     bb2: {\n@@ -55,7 +55,7 @@\n   \n -     bb3: {\n -         _7 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _7) -> [1_isize: bb4, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _7) -> [1: bb4, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n -     }\n - \n -     bb4: {\n@@ -86,7 +86,7 @@\n + \n +     bb5: {\n +         StorageDead(_12);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(_8) -> [0_isize: bb3, 1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(_8) -> [0: bb3, 1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   }\n   "}, {"sha": "cea6ff7cd05e07bd02d4a2c46194cb30969f9908", "filename": "src/test/mir-opt/early_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch.opt3.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -31,13 +31,13 @@\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch.rs:+1:16: +1:17\n           _7 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _7) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _10 = discriminant((_3.1: std::option::Option<bool>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageLive(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         _11 = Ne(_7, move _10);          // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n +         StorageDead(_10);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(move _11) -> [false: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(move _11) -> [0: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   \n       bb1: {\n@@ -49,7 +49,7 @@\n   \n       bb2: {\n -         _6 = discriminant((_3.1: std::option::Option<bool>)); // scope 0 at $DIR/early_otherwise_branch.rs:+1:11: +1:17\n--         switchInt(move _6) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n+-         switchInt(move _6) -> [1: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n -     }\n - \n -     bb3: {\n@@ -72,7 +72,7 @@\n + \n +     bb4: {\n +         StorageDead(_11);                // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n-+         switchInt(_7) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n++         switchInt(_7) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch.rs:+1:5: +1:17\n       }\n   }\n   "}, {"sha": "b90d70ce43aa0ca0d884663a1a775d85a3a3edf6", "filename": "src/test/mir-opt/early_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_3_element_tuple.opt1.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -42,13 +42,13 @@\n           StorageDead(_6);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:19: +1:20\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:19: +1:20\n           _10 = discriminant((_4.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n--         switchInt(move _10) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n+-         switchInt(move _10) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n +         StorageLive(_14);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n +         _14 = discriminant((_4.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n +         StorageLive(_15);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n +         _15 = Ne(_10, move _14);         // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n +         StorageDead(_14);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n-+         switchInt(move _15) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n++         switchInt(move _15) -> [0: bb5, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n       }\n   \n       bb1: {\n@@ -61,13 +61,13 @@\n   \n       bb2: {\n -         _9 = discriminant((_4.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n--         switchInt(move _9) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n+-         switchInt(move _9) -> [1: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n -     }\n - \n -     bb3: {\n           _8 = discriminant((_4.2: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:11: +1:20\n--         switchInt(move _8) -> [1_isize: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n-+         switchInt(move _8) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n+-         switchInt(move _8) -> [1: bb4, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n++         switchInt(move _8) -> [1: bb3, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n       }\n   \n -     bb4: {\n@@ -94,7 +94,7 @@\n + \n +     bb5: {\n +         StorageDead(_15);                // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n-+         switchInt(_10) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n++         switchInt(_10) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_3_element_tuple.rs:+1:5: +1:20\n       }\n   }\n   "}, {"sha": "9edd1a39f45f9b050f4a50d1d1c5875461e45ffe", "filename": "src/test/mir-opt/early_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_68867.try_sum.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -80,13 +80,13 @@\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:23: +5:24\n           _34 = deref_copy (_4.0: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           _11 = discriminant((*_34));      // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          switchInt(move _11) -> [0_isize: bb1, 1_isize: bb3, 2_isize: bb4, 3_isize: bb5, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n+          switchInt(move _11) -> [0: bb1, 1: bb3, 2: bb4, 3: bb5, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n       }\n   \n       bb1: {\n           _35 = deref_copy (_4.1: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           _7 = discriminant((*_35));       // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          switchInt(move _7) -> [0_isize: bb6, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n+          switchInt(move _7) -> [0: bb6, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n       }\n   \n       bb2: {\n@@ -104,19 +104,19 @@\n       bb3: {\n           _36 = deref_copy (_4.1: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           _8 = discriminant((*_36));       // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          switchInt(move _8) -> [1_isize: bb7, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n+          switchInt(move _8) -> [1: bb7, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n       }\n   \n       bb4: {\n           _37 = deref_copy (_4.1: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           _9 = discriminant((*_37));       // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          switchInt(move _9) -> [2_isize: bb8, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n+          switchInt(move _9) -> [2: bb8, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n       }\n   \n       bb5: {\n           _38 = deref_copy (_4.1: &ViewportPercentageLength); // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n           _10 = discriminant((*_38));      // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:14: +5:24\n-          switchInt(move _10) -> [3_isize: bb9, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n+          switchInt(move _10) -> [3: bb9, otherwise: bb2]; // scope 0 at $DIR/early_otherwise_branch_68867.rs:+5:8: +5:24\n       }\n   \n       bb6: {"}, {"sha": "82d8b2fc5a463a740edb395c2c44968a2269f016", "filename": "src/test/mir-opt/early_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_noopt.noopt1.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -38,12 +38,12 @@\n           StorageDead(_5);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:16: +1:17\n           StorageDead(_4);                 // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:16: +1:17\n           _8 = discriminant((_3.0: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n-          switchInt(move _8) -> [0_isize: bb1, 1_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n+          switchInt(move _8) -> [0: bb1, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n       }\n   \n       bb1: {\n           _6 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n-          switchInt(move _6) -> [0_isize: bb2, 1_isize: bb7, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n+          switchInt(move _6) -> [0: bb2, 1: bb7, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n       }\n   \n       bb2: {\n@@ -57,7 +57,7 @@\n   \n       bb4: {\n           _7 = discriminant((_3.1: std::option::Option<u32>)); // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:11: +1:17\n-          switchInt(move _7) -> [0_isize: bb6, 1_isize: bb5, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n+          switchInt(move _7) -> [0: bb6, 1: bb5, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_noopt.rs:+1:5: +1:17\n       }\n   \n       bb5: {"}, {"sha": "a3fa2529b1868cb8a113059fb620c811a71b2633", "filename": "src/test/mir-opt/early_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_deref_ptr.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n   \n       bb0: {\n           _3 = discriminant(_1);           // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+1:11: +1:12\n-          switchInt(move _3) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+1:5: +1:12\n+          switchInt(move _3) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+1:5: +1:12\n       }\n   \n       bb1: {\n@@ -24,7 +24,7 @@\n   \n       bb2: {\n           _4 = discriminant((*_2));        // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+3:26: +3:28\n-          switchInt(move _4) -> [1_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+3:20: +3:28\n+          switchInt(move _4) -> [1: bb4, otherwise: bb3]; // scope 0 at $DIR/early_otherwise_branch_soundness.rs:+3:20: +3:28\n       }\n   \n       bb3: {"}, {"sha": "6d0224b547f4fe2036ac730d6e5b289ac1627328", "filename": "src/test/mir-opt/early_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fearly_otherwise_branch_soundness.no_downcast.EarlyOtherwiseBranch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -12,13 +12,13 @@\n   \n       bb0: {\n           _3 = discriminant((*_1));        // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n-          switchInt(move _3) -> [1_isize: bb1, otherwise: bb3]; // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n+          switchInt(move _3) -> [1: bb1, otherwise: bb3]; // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n       }\n   \n       bb1: {\n           _4 = deref_copy (((*_1) as Some).0: &E<'_>); // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n           _2 = discriminant((*_4));        // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n-          switchInt(move _2) -> [1_isize: bb2, otherwise: bb3]; // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n+          switchInt(move _2) -> [1: bb2, otherwise: bb3]; // scope 1 at $DIR/early_otherwise_branch_soundness.rs:+1:12: +1:31\n       }\n   \n       bb2: {"}, {"sha": "8b542a7c19d63ae1f189275a83713485de931875", "filename": "src/test/mir-opt/equal_true.opt.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fequal_true.opt.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fequal_true.opt.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fequal_true.opt.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Eq(move _3, const true);    // scope 0 at $DIR/equal_true.rs:+1:8: +1:17\n +         _2 = move _3;                    // scope 0 at $DIR/equal_true.rs:+1:8: +1:17\n           StorageDead(_3);                 // scope 0 at $DIR/equal_true.rs:+1:16: +1:17\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/equal_true.rs:+1:8: +1:17\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/equal_true.rs:+1:8: +1:17\n       }\n   \n       bb1: {"}, {"sha": "ab955049965ada01ad44a6744c897e80d9f3fcdf", "filename": "src/test/mir-opt/exponential_or.match_tuple.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,7 +19,7 @@ fn match_tuple(_1: (u32, bool, Option<i32>, u32)) -> u32 {\n \n     bb0: {\n         FakeRead(ForMatchedPlace(None), _1); // scope 0 at $DIR/exponential_or.rs:+1:11: +1:12\n-        switchInt((_1.0: u32)) -> [1_u32: bb2, 4_u32: bb2, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:15: +2:20\n+        switchInt((_1.0: u32)) -> [1: bb2, 4: bb2, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:15: +2:20\n     }\n \n     bb1: {\n@@ -29,31 +29,31 @@ fn match_tuple(_1: (u32, bool, Option<i32>, u32)) -> u32 {\n \n     bb2: {\n         _2 = discriminant((_1.2: std::option::Option<i32>)); // scope 0 at $DIR/exponential_or.rs:+2:37: +2:55\n-        switchInt(move _2) -> [0_isize: bb4, 1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:37: +2:55\n+        switchInt(move _2) -> [0: bb4, 1: bb3, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:37: +2:55\n     }\n \n     bb3: {\n-        switchInt((((_1.2: std::option::Option<i32>) as Some).0: i32)) -> [1_i32: bb4, 8_i32: bb4, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:37: +2:55\n+        switchInt((((_1.2: std::option::Option<i32>) as Some).0: i32)) -> [1: bb4, 8: bb4, otherwise: bb1]; // scope 0 at $DIR/exponential_or.rs:+2:37: +2:55\n     }\n \n     bb4: {\n         _5 = Le(const 6_u32, (_1.3: u32)); // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n-        switchInt(move _5) -> [false: bb6, otherwise: bb5]; // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n+        switchInt(move _5) -> [0: bb6, otherwise: bb5]; // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n     }\n \n     bb5: {\n         _6 = Le((_1.3: u32), const 9_u32); // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n-        switchInt(move _6) -> [false: bb6, otherwise: bb8]; // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n+        switchInt(move _6) -> [0: bb6, otherwise: bb8]; // scope 0 at $DIR/exponential_or.rs:+2:62: +2:67\n     }\n \n     bb6: {\n         _3 = Le(const 13_u32, (_1.3: u32)); // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n-        switchInt(move _3) -> [false: bb1, otherwise: bb7]; // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n+        switchInt(move _3) -> [0: bb1, otherwise: bb7]; // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n     }\n \n     bb7: {\n         _4 = Le((_1.3: u32), const 16_u32); // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n-        switchInt(move _4) -> [false: bb1, otherwise: bb8]; // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n+        switchInt(move _4) -> [0: bb1, otherwise: bb8]; // scope 0 at $DIR/exponential_or.rs:+2:70: +2:77\n     }\n \n     bb8: {"}, {"sha": "c1c2cde71ab5b38f485885cd7f3a60bc4f13ad37", "filename": "src/test/mir-opt/funky_arms.float_to_exponential_common.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -47,7 +47,7 @@\n       bb1: {\n           StorageDead(_5);                 // scope 0 at $DIR/funky_arms.rs:+4:36: +4:37\n           StorageLive(_6);                 // scope 1 at $DIR/funky_arms.rs:+8:9: +8:13\n-          switchInt(_4) -> [false: bb3, otherwise: bb2]; // scope 1 at $DIR/funky_arms.rs:+8:16: +8:32\n+          switchInt(_4) -> [0: bb3, otherwise: bb2]; // scope 1 at $DIR/funky_arms.rs:+8:16: +8:32\n       }\n   \n       bb2: {\n@@ -75,7 +75,7 @@\n       bb5: {\n           StorageDead(_8);                 // scope 3 at $DIR/funky_arms.rs:+13:44: +13:45\n           _9 = discriminant(_7);           // scope 3 at $DIR/funky_arms.rs:+13:12: +13:27\n-          switchInt(move _9) -> [1_isize: bb6, otherwise: bb8]; // scope 3 at $DIR/funky_arms.rs:+13:12: +13:27\n+          switchInt(move _9) -> [1: bb6, otherwise: bb8]; // scope 3 at $DIR/funky_arms.rs:+13:12: +13:27\n       }\n   \n       bb6: {"}, {"sha": "a8e090020c3d31bb70ee083e59d02adc982a4d36", "filename": "src/test/mir-opt/generator_drop_cleanup.main-{closure#0}.generator_drop.0.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_drop_cleanup.main-%7Bclosure%230%7D.generator_drop.0.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,7 +29,7 @@ fn main::{closure#0}(_1: *mut [generator@$DIR/generator_drop_cleanup.rs:10:15: 1\n \n     bb0: {\n         _8 = discriminant((*_1));        // scope 0 at $DIR/generator_drop_cleanup.rs:+0:15: +3:6\n-        switchInt(move _8) -> [0_u32: bb7, 3_u32: bb10, otherwise: bb11]; // scope 0 at $DIR/generator_drop_cleanup.rs:+0:15: +3:6\n+        switchInt(move _8) -> [0: bb7, 3: bb10, otherwise: bb11]; // scope 0 at $DIR/generator_drop_cleanup.rs:+0:15: +3:6\n     }\n \n     bb1: {"}, {"sha": "b3d3c768a5dd9a22ded6107eec3ec9f87c196c3c", "filename": "src/test/mir-opt/generator_tiny.main-{closure#0}.generator_resume.0.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator_tiny.main-%7Bclosure%230%7D.generator_resume.0.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -32,7 +32,7 @@ fn main::{closure#0}(_1: Pin<&mut [generator@$DIR/generator_tiny.rs:19:16: 19:24\n \n     bb0: {\n         _11 = discriminant((*(_1.0: &mut [generator@$DIR/generator_tiny.rs:19:16: 19:24]))); // scope 0 at $DIR/generator_tiny.rs:+0:16: +6:6\n-        switchInt(move _11) -> [0_u32: bb1, 3_u32: bb5, otherwise: bb6]; // scope 0 at $DIR/generator_tiny.rs:+0:16: +6:6\n+        switchInt(move _11) -> [0: bb1, 3: bb5, otherwise: bb6]; // scope 0 at $DIR/generator_tiny.rs:+0:16: +6:6\n     }\n \n     bb1: {"}, {"sha": "de4235c9e9e935f7e65cf743d98593365495d122", "filename": "src/test/mir-opt/if_condition_int.dont_opt_bool.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_bool.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_bool.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_bool.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -9,7 +9,7 @@\n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n           _2 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n       }\n   \n       bb1: {"}, {"sha": "754c6579af08fc3c91bc1a645e18e45ebe6090ba", "filename": "src/test/mir-opt/if_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_opt_floats.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,7 +13,7 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n           _2 = Eq(move _3, const -42f32);  // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:18\n           StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:17: +1:18\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:18\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:18\n       }\n   \n       bb1: {"}, {"sha": "ff23839e29179fa1bb413e5ac09d2ac5820f2800", "filename": "src/test/mir-opt/if_condition_int.dont_remove_comparison.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_remove_comparison.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_remove_comparison.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.dont_remove_comparison.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -20,10 +20,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:13: +1:14\n -         _2 = Eq(move _3, const 17_i8);   // scope 0 at $DIR/if_condition_int.rs:+1:13: +1:20\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:19: +1:20\n--         switchInt(_2) -> [false: bb2, otherwise: bb1]; // scope 1 at $DIR/if_condition_int.rs:+2:5: +2:12\n+-         switchInt(_2) -> [0: bb2, otherwise: bb1]; // scope 1 at $DIR/if_condition_int.rs:+2:5: +2:12\n +         _2 = Eq(_3, const 17_i8);        // scope 0 at $DIR/if_condition_int.rs:+1:13: +1:20\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:19: +1:20\n-+         switchInt(move _3) -> [17_i8: bb1, otherwise: bb2]; // scope 1 at $DIR/if_condition_int.rs:+2:5: +2:12\n++         switchInt(move _3) -> [17: bb1, otherwise: bb2]; // scope 1 at $DIR/if_condition_int.rs:+2:5: +2:12\n       }\n   \n       bb1: {"}, {"sha": "5964d76a4b96f24149c2bddbf3081d38f05a1cbe", "filename": "src/test/mir-opt/if_condition_int.opt_char.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_char.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_char.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_char.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,10 +13,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n -         _2 = Eq(move _3, const 'x');     // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:15: +1:16\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:15: +1:16\n-+         switchInt(move _3) -> ['x': bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n++         switchInt(move _3) -> [120: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n       }\n   \n       bb1: {"}, {"sha": "98918cc743ce0efb6ad9f3661b30b3f4a21c9178", "filename": "src/test/mir-opt/if_condition_int.opt_i8.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_i8.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_i8.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_i8.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,10 +13,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n -         _2 = Eq(move _3, const 42_i8);   // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n-+         switchInt(move _3) -> [42_i8: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n++         switchInt(move _3) -> [42: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n       }\n   \n       bb1: {"}, {"sha": "db38140b8d00b576c2bdbe4626894202908cb8d2", "filename": "src/test/mir-opt/if_condition_int.opt_multiple_ifs.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_multiple_ifs.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_multiple_ifs.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_multiple_ifs.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -15,10 +15,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n -         _2 = Eq(move _3, const 42_u32);  // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n-+         switchInt(move _3) -> [42_u32: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n++         switchInt(move _3) -> [42: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n       }\n   \n       bb1: {\n@@ -34,10 +34,10 @@\n           _5 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:16\n -         _4 = Ne(move _5, const 21_u32);  // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n -         StorageDead(_5);                 // scope 0 at $DIR/if_condition_int.rs:+3:21: +3:22\n--         switchInt(move _4) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n+-         switchInt(move _4) -> [0: bb4, otherwise: bb3]; // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+3:21: +3:22\n-+         switchInt(move _5) -> [21_u32: bb4, otherwise: bb3]; // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n++         switchInt(move _5) -> [21: bb4, otherwise: bb3]; // scope 0 at $DIR/if_condition_int.rs:+3:15: +3:22\n       }\n   \n       bb3: {"}, {"sha": "1a1ac4caafaf0ee363dbd4097aab1cf5137604de", "filename": "src/test/mir-opt/if_condition_int.opt_negative.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_negative.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_negative.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_negative.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,10 +13,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n -         _2 = Eq(move _3, const -42_i32); // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:15: +1:16\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:15: +1:16\n-+         switchInt(move _3) -> [-42_i32: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n++         switchInt(move _3) -> [4294967254: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:16\n       }\n   \n       bb1: {"}, {"sha": "fc3f50227dcb93718c1e48496ecc29160c5d905c", "filename": "src/test/mir-opt/if_condition_int.opt_u32.SimplifyComparisonIntegral.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_u32.SimplifyComparisonIntegral.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_u32.SimplifyComparisonIntegral.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fif_condition_int.opt_u32.SimplifyComparisonIntegral.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,10 +13,10 @@\n           _3 = _1;                         // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:9\n -         _2 = Eq(move _3, const 42_u32);  // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n -         StorageDead(_3);                 // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n--         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n+-         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n +         nop;                             // scope 0 at $DIR/if_condition_int.rs:+1:14: +1:15\n-+         switchInt(move _3) -> [42_u32: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n++         switchInt(move _3) -> [42: bb1, otherwise: bb2]; // scope 0 at $DIR/if_condition_int.rs:+1:8: +1:15\n       }\n   \n       bb1: {"}, {"sha": "b787a19f4b21c0d9c82050872e791553984abcbc", "filename": "src/test/mir-opt/inline/inline_diverging.g.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.g.Inline.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,7 +19,7 @@\n           _3 = _1;                         // scope 0 at $DIR/inline_diverging.rs:+1:8: +1:9\n           _2 = Gt(move _3, const 0_i32);   // scope 0 at $DIR/inline_diverging.rs:+1:8: +1:13\n           StorageDead(_3);                 // scope 0 at $DIR/inline_diverging.rs:+1:12: +1:13\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/inline_diverging.rs:+1:8: +1:13\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/inline_diverging.rs:+1:8: +1:13\n       }\n   \n       bb1: {"}, {"sha": "bd21405f14b3fcc663cbefef4caa0fb860c690d1", "filename": "src/test/mir-opt/inline/inline_generator.main.Inline.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_generator.main.Inline.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -72,7 +72,7 @@\n +         _7 = const false;                // scope 0 at $DIR/inline_generator.rs:+1:14: +1:46\n +         _10 = deref_copy (_2.0: &mut [generator@$DIR/inline_generator.rs:15:5: 15:8]); // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n +         _9 = discriminant((*_10));       // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n-+         switchInt(move _9) -> [0_u32: bb3, 1_u32: bb8, 3_u32: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n++         switchInt(move _9) -> [0: bb3, 1: bb8, 3: bb7, otherwise: bb9]; // scope 6 at $DIR/inline_generator.rs:15:5: 15:41\n       }\n   \n -     bb3: {\n@@ -92,7 +92,7 @@\n + \n +     bb3: {\n +         StorageLive(_8);                 // scope 6 at $DIR/inline_generator.rs:15:17: 15:39\n-+         switchInt(move _7) -> [false: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n++         switchInt(move _7) -> [0: bb5, otherwise: bb4]; // scope 6 at $DIR/inline_generator.rs:15:20: 15:21\n +     }\n + \n +     bb4: {"}, {"sha": "36ddb189e0d3365eabea7fa2a977a89d9cb29fdf", "filename": "src/test/mir-opt/inline/inline_shims.drop.Inline.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_shims.drop.Inline.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -39,7 +39,7 @@\n +         StorageLive(_6);                 // scope 2 at $DIR/inline_shims.rs:+2:14: +2:40\n +         StorageLive(_7);                 // scope 2 at $DIR/inline_shims.rs:+2:14: +2:40\n +         _6 = discriminant((*_5));        // scope 3 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-+         switchInt(move _6) -> [0_isize: bb2, otherwise: bb3]; // scope 3 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n++         switchInt(move _6) -> [0: bb2, otherwise: bb3]; // scope 3 at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n       }\n   \n       bb2: {"}, {"sha": "2f6f5f87efcc7a8c911a53a449660f9f0b61c53f", "filename": "src/test/mir-opt/instrument_coverage.main.InstrumentCoverage.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage.main.InstrumentCoverage.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -26,7 +26,7 @@\n       }\n   \n       bb3: {\n-          switchInt(move _2) -> [false: bb5, otherwise: bb4]; // scope 0 at /the/src/instrument_coverage.rs:+2:12: +2:17\n+          switchInt(move _2) -> [0: bb5, otherwise: bb4]; // scope 0 at /the/src/instrument_coverage.rs:+2:12: +2:17\n       }\n   \n       bb4: {"}, {"sha": "b0d5b291b6cb55c734a24f0f43c19eed94c4b341", "filename": "src/test/mir-opt/issue_38669.main.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_38669.main.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_38669.main.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_38669.main.SimplifyCfg-initial.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -26,7 +26,7 @@ fn main() -> () {\n         StorageLive(_3);                 // scope 1 at $DIR/issue_38669.rs:+3:9: +5:10\n         StorageLive(_4);                 // scope 1 at $DIR/issue_38669.rs:+3:12: +3:24\n         _4 = _1;                         // scope 1 at $DIR/issue_38669.rs:+3:12: +3:24\n-        switchInt(move _4) -> [false: bb4, otherwise: bb3]; // scope 1 at $DIR/issue_38669.rs:+3:12: +3:24\n+        switchInt(move _4) -> [0: bb4, otherwise: bb3]; // scope 1 at $DIR/issue_38669.rs:+3:12: +3:24\n     }\n \n     bb3: {"}, {"sha": "c2ea3ac502f89dc3f89446f4700bea44444d19a4", "filename": "src/test/mir-opt/issue_41110.main.ElaborateDrops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41110.main.ElaborateDrops.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -65,6 +65,6 @@ fn main() -> () {\n     }\n \n     bb8 (cleanup): {\n-        switchInt(_5) -> [false: bb6, otherwise: bb7]; // scope 0 at $DIR/issue_41110.rs:+1:27: +1:28\n+        switchInt(_5) -> [0: bb6, otherwise: bb7]; // scope 0 at $DIR/issue_41110.rs:+1:27: +1:28\n     }\n }"}, {"sha": "82989c3f071b43d39f022ca6dadc2e802aa7404e", "filename": "src/test/mir-opt/issue_41110.test.ElaborateDrops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41110.test.ElaborateDrops.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -96,6 +96,6 @@ fn test() -> () {\n     }\n \n     bb14 (cleanup): {\n-        switchInt(_6) -> [false: bb10, otherwise: bb13]; // scope 0 at $DIR/issue_41110.rs:+5:1: +5:2\n+        switchInt(_6) -> [0: bb10, otherwise: bb13]; // scope 0 at $DIR/issue_41110.rs:+5:1: +5:2\n     }\n }"}, {"sha": "00504273245b1d2a9acb320e5a5929061fb6a401", "filename": "src/test/mir-opt/issue_41888.main.ElaborateDrops.after.mir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41888.main.ElaborateDrops.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -33,7 +33,7 @@ fn main() -> () {\n     }\n \n     bb1: {\n-        switchInt(move _2) -> [false: bb7, otherwise: bb2]; // scope 1 at $DIR/issue_41888.rs:+2:8: +2:14\n+        switchInt(move _2) -> [0: bb7, otherwise: bb2]; // scope 1 at $DIR/issue_41888.rs:+2:8: +2:14\n     }\n \n     bb2: {\n@@ -52,7 +52,7 @@ fn main() -> () {\n     bb4: {\n         StorageDead(_3);                 // scope 1 at $DIR/issue_41888.rs:+3:19: +3:20\n         _5 = discriminant(_1);           // scope 2 at $DIR/issue_41888.rs:+4:16: +4:24\n-        switchInt(move _5) -> [0_isize: bb5, otherwise: bb6]; // scope 2 at $DIR/issue_41888.rs:+4:16: +4:24\n+        switchInt(move _5) -> [0: bb5, otherwise: bb6]; // scope 2 at $DIR/issue_41888.rs:+4:16: +4:24\n     }\n \n     bb5: {\n@@ -134,19 +134,19 @@ fn main() -> () {\n \n     bb19: {\n         _10 = discriminant(_1);          // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n-        switchInt(move _10) -> [0_isize: bb15, otherwise: bb17]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n+        switchInt(move _10) -> [0: bb15, otherwise: bb17]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n     }\n \n     bb20: {\n-        switchInt(_7) -> [false: bb15, otherwise: bb19]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n+        switchInt(_7) -> [0: bb15, otherwise: bb19]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n     }\n \n     bb21 (cleanup): {\n         _11 = discriminant(_1);          // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n-        switchInt(move _11) -> [0_isize: bb16, otherwise: bb18]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n+        switchInt(move _11) -> [0: bb16, otherwise: bb18]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n     }\n \n     bb22 (cleanup): {\n-        switchInt(_7) -> [false: bb12, otherwise: bb21]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n+        switchInt(_7) -> [0: bb12, otherwise: bb21]; // scope 0 at $DIR/issue_41888.rs:+9:1: +9:2\n     }\n }"}, {"sha": "adfa3a7733b1d6ed1819c1b7a829d2939c7fade5", "filename": "src/test/mir-opt/issue_62289.test.ElaborateDrops.before.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_62289.test.ElaborateDrops.before.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -52,7 +52,7 @@ fn test() -> Option<Box<u32>> {\n     bb2: {\n         StorageDead(_7);                 // scope 0 at $DIR/issue_62289.rs:+1:19: +1:20\n         _8 = discriminant(_6);           // scope 0 at $DIR/issue_62289.rs:+1:15: +1:20\n-        switchInt(move _8) -> [0_isize: bb3, 1_isize: bb5, otherwise: bb4]; // scope 0 at $DIR/issue_62289.rs:+1:15: +1:20\n+        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4]; // scope 0 at $DIR/issue_62289.rs:+1:15: +1:20\n     }\n \n     bb3: {"}, {"sha": "17b81633991fec12dfa7ead2aa8edb71d8080e89", "filename": "src/test/mir-opt/issue_73223.main.SimplifyArmIdentity.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -116,7 +116,7 @@\n           StorageDead(_17);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _15 = Not(move _16);             // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           StorageDead(_16);                // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-          switchInt(move _15) -> [false: bb5, otherwise: bb4]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+          switchInt(move _15) -> [0: bb5, otherwise: bb4]; // scope 4 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb4: {"}, {"sha": "3e035c18db862f3adcda96875dce95195dda1ca9", "filename": "src/test/mir-opt/issue_99325.main.built.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_99325.main.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissue_99325.main.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_99325.main.built.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -109,7 +109,7 @@ fn main() -> () {\n         StorageDead(_12);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _10 = Not(move _11);             // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_11);                // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        switchInt(move _10) -> [false: bb4, otherwise: bb3]; // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        switchInt(move _10) -> [0: bb4, otherwise: bb3]; // scope 1 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n     }\n \n     bb3: {\n@@ -218,7 +218,7 @@ fn main() -> () {\n         StorageDead(_33);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _31 = Not(move _32);             // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_32);                // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        switchInt(move _31) -> [false: bb13, otherwise: bb12]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        switchInt(move _31) -> [0: bb13, otherwise: bb12]; // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n     }\n \n     bb12: {"}, {"sha": "e0d6b58f229c4a63be620ad3d46b16ac70629b9e", "filename": "src/test/mir-opt/issues/issue_59352.num_to_digit.PreCodegen.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_59352.num_to_digit.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -47,7 +47,7 @@ fn num_to_digit(_1: char) -> u32 {\n \n     bb2: {\n         _7 = discriminant(_2);           // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n-        switchInt(move _7) -> [0_isize: bb6, 1_isize: bb8, otherwise: bb7]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n+        switchInt(move _7) -> [0: bb6, 1: bb8, otherwise: bb7]; // scope 3 at $SRC_DIR/core/src/option.rs:LL:COL\n     }\n \n     bb3: {\n@@ -66,7 +66,7 @@ fn num_to_digit(_1: char) -> u32 {\n         StorageDead(_4);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageDead(_5);                 // scope 1 at $SRC_DIR/core/src/char/methods.rs:LL:COL\n         StorageDead(_3);                 // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n-        switchInt(move _9) -> [1_isize: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n+        switchInt(move _9) -> [1: bb1, otherwise: bb3]; // scope 0 at $DIR/issue_59352.rs:+2:8: +2:23\n     }\n \n     bb6: {"}, {"sha": "1c69a6232d60631e30f8b36dc538819916abf6bc", "filename": "src/test/mir-opt/issues/issue_75439.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissues%2Fissue_75439.foo.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -32,15 +32,15 @@\n   \n       bb1: {\n           StorageDead(_3);                 // scope 2 at $DIR/issue_75439.rs:+2:52: +2:53\n-          switchInt(_2[0 of 4]) -> [0_u32: bb2, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          switchInt(_2[0 of 4]) -> [0: bb2, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb2: {\n-          switchInt(_2[1 of 4]) -> [0_u32: bb3, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          switchInt(_2[1 of 4]) -> [0: bb3, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb3: {\n-          switchInt(_2[2 of 4]) -> [0_u32: bb5, 4294901760_u32: bb6, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n+          switchInt(_2[2 of 4]) -> [0: bb5, 4294901760: bb6, otherwise: bb8]; // scope 3 at $DIR/issue_75439.rs:+4:12: +4:30\n       }\n   \n       bb4: {"}, {"sha": "4ee2dae49b3f34652228d4b6b1379a4249313edf", "filename": "src/test/mir-opt/loop_test.main.SimplifyCfg-promote-consts.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -16,7 +16,7 @@ fn main() -> () {\n         StorageLive(_1);                 // scope 0 at $DIR/loop_test.rs:+4:5: +6:6\n         StorageLive(_2);                 // scope 0 at $DIR/loop_test.rs:+4:8: +4:12\n         _2 = const true;                 // scope 0 at $DIR/loop_test.rs:+4:8: +4:12\n-        switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/loop_test.rs:+4:8: +4:12\n+        switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/loop_test.rs:+4:8: +4:12\n     }\n \n     bb1: {"}, {"sha": "9bc7060e958ebf56c4083692fc647fcc9d746149", "filename": "src/test/mir-opt/lower_array_len.array_bound.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound.NormalizeArrayLen.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -38,7 +38,7 @@\n           _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n           StorageDead(_5);                 // scope 0 at $DIR/lower_array_len.rs:+1:26: +1:27\n           StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:26: +1:27\n-          switchInt(move _3) -> [false: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n+          switchInt(move _3) -> [0: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n       }\n   \n       bb2: {"}, {"sha": "cf427cfd1e6dbb7a71c4b57401847c4b37cc500a", "filename": "src/test/mir-opt/lower_array_len.array_bound_mut.NormalizeArrayLen.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len.array_bound_mut.NormalizeArrayLen.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -41,7 +41,7 @@\n           _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n           StorageDead(_5);                 // scope 0 at $DIR/lower_array_len.rs:+1:26: +1:27\n           StorageDead(_4);                 // scope 0 at $DIR/lower_array_len.rs:+1:26: +1:27\n-          switchInt(move _3) -> [false: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n+          switchInt(move _3) -> [0: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_array_len.rs:+1:8: +1:27\n       }\n   \n       bb2: {"}, {"sha": "701c2ad705af2997fdf4e501f706819260a5bd27", "filename": "src/test/mir-opt/lower_array_len_e2e.array_bound.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,7 +19,7 @@ fn array_bound(_1: usize, _2: &[u8; N]) -> u8 {\n         _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n         StorageDead(_5);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n         StorageDead(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n-        switchInt(move _3) -> [false: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n+        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n     }\n \n     bb1: {"}, {"sha": "0440cfce2893f152437667e746632f89763ecb4b", "filename": "src/test/mir-opt/lower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_array_len_e2e.array_bound_mut.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -22,7 +22,7 @@ fn array_bound_mut(_1: usize, _2: &mut [u8; N]) -> u8 {\n         _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n         StorageDead(_5);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n         StorageDead(_4);                 // scope 0 at $DIR/lower_array_len_e2e.rs:+1:26: +1:27\n-        switchInt(move _3) -> [false: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n+        switchInt(move _3) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/lower_array_len_e2e.rs:+1:8: +1:27\n     }\n \n     bb1: {"}, {"sha": "2b0370cf35800c3f157f81008023abdd6348d4c6", "filename": "src/test/mir-opt/lower_slice_len.bound.LowerSliceLenCalls.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_slice_len.bound.LowerSliceLenCalls.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Flower_slice_len.bound.LowerSliceLenCalls.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_slice_len.bound.LowerSliceLenCalls.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -33,7 +33,7 @@\n           _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_slice_len.rs:+1:8: +1:27\n           StorageDead(_5);                 // scope 0 at $DIR/lower_slice_len.rs:+1:26: +1:27\n           StorageDead(_4);                 // scope 0 at $DIR/lower_slice_len.rs:+1:26: +1:27\n-          switchInt(move _3) -> [false: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_slice_len.rs:+1:8: +1:27\n+          switchInt(move _3) -> [0: bb4, otherwise: bb2]; // scope 0 at $DIR/lower_slice_len.rs:+1:8: +1:27\n       }\n   \n       bb2: {"}, {"sha": "84e4d35f908170560e24550e7d6239ecd7cdeae1", "filename": "src/test/mir-opt/match_arm_scopes.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatch_arm_scopes.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatch_arm_scopes.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_arm_scopes.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -32,26 +32,26 @@\n   \n       bb0: {\n -         FakeRead(ForMatchedPlace(None), _2); // scope 0 at $DIR/match_arm_scopes.rs:+1:11: +1:16\n--         switchInt((_2.0: bool)) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n-+         switchInt((_2.0: bool)) -> [false: bb5, otherwise: bb1]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n+-         switchInt((_2.0: bool)) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n++         switchInt((_2.0: bool)) -> [0: bb5, otherwise: bb1]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n       }\n   \n       bb1: {\n -         falseEdge -> [real: bb8, imaginary: bb3]; // scope 0 at $DIR/match_arm_scopes.rs:+2:9: +2:22\n-+         switchInt((_2.1: bool)) -> [false: bb10, otherwise: bb2]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n++         switchInt((_2.1: bool)) -> [0: bb10, otherwise: bb2]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n       }\n   \n       bb2: {\n--         switchInt((_2.1: bool)) -> [false: bb3, otherwise: bb4]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n-+         switchInt((_2.0: bool)) -> [false: bb3, otherwise: bb17]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n+-         switchInt((_2.1: bool)) -> [0: bb3, otherwise: bb4]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n++         switchInt((_2.0: bool)) -> [0: bb3, otherwise: bb17]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n       }\n   \n       bb3: {\n -         falseEdge -> [real: bb13, imaginary: bb5]; // scope 0 at $DIR/match_arm_scopes.rs:+2:25: +2:38\n -     }\n - \n -     bb4: {\n--         switchInt((_2.0: bool)) -> [false: bb6, otherwise: bb5]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n+-         switchInt((_2.0: bool)) -> [0: bb6, otherwise: bb5]; // scope 0 at $DIR/match_arm_scopes.rs:+1:5: +1:16\n -     }\n - \n -     bb5: {\n@@ -85,8 +85,8 @@\n           StorageLive(_9);                 // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n           StorageLive(_10);                // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n           _10 = _1;                        // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n--         switchInt(move _10) -> [false: bb10, otherwise: bb9]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n-+         switchInt(move _10) -> [false: bb7, otherwise: bb6]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n+-         switchInt(move _10) -> [0: bb10, otherwise: bb9]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n++         switchInt(move _10) -> [0: bb7, otherwise: bb6]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n       }\n   \n -     bb9: {\n@@ -101,8 +101,8 @@\n -     bb10: {\n +     bb7: {\n           _9 = (*_6);                      // scope 0 at $DIR/match_arm_scopes.rs:+2:70: +2:71\n--         switchInt(move _9) -> [false: bb12, otherwise: bb11]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n-+         switchInt(move _9) -> [false: bb9, otherwise: bb8]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n+-         switchInt(move _9) -> [0: bb12, otherwise: bb11]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n++         switchInt(move _9) -> [0: bb9, otherwise: bb8]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n       }\n   \n -     bb11: {\n@@ -142,8 +142,8 @@\n           StorageLive(_12);                // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n           StorageLive(_13);                // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n           _13 = _1;                        // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n--         switchInt(move _13) -> [false: bb15, otherwise: bb14]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n-+         switchInt(move _13) -> [false: bb12, otherwise: bb11]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n+-         switchInt(move _13) -> [0: bb15, otherwise: bb14]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n++         switchInt(move _13) -> [0: bb12, otherwise: bb11]; // scope 0 at $DIR/match_arm_scopes.rs:+2:45: +2:49\n       }\n   \n -     bb14: {\n@@ -158,8 +158,8 @@\n -     bb15: {\n +     bb12: {\n           _12 = (*_6);                     // scope 0 at $DIR/match_arm_scopes.rs:+2:70: +2:71\n--         switchInt(move _12) -> [false: bb17, otherwise: bb16]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n-+         switchInt(move _12) -> [false: bb14, otherwise: bb13]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n+-         switchInt(move _12) -> [0: bb17, otherwise: bb16]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n++         switchInt(move _12) -> [0: bb14, otherwise: bb13]; // scope 0 at $DIR/match_arm_scopes.rs:+2:42: +2:73\n       }\n   \n -     bb16: {"}, {"sha": "d51dbf4258c541ba8eb8bde8b49c1fdd325f335c", "filename": "src/test/mir-opt/match_test.main.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatch_test.main.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatch_test.main.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_test.main.SimplifyCfg-initial.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -28,12 +28,12 @@ fn main() -> () {\n         StorageLive(_3);                 // scope 2 at $DIR/match_test.rs:+6:5: +11:6\n         FakeRead(ForMatchedPlace(None), _1); // scope 2 at $DIR/match_test.rs:+6:11: +6:12\n         _6 = Le(const 0_i32, _1);        // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n-        switchInt(move _6) -> [false: bb4, otherwise: bb1]; // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n+        switchInt(move _6) -> [0: bb4, otherwise: bb1]; // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n     }\n \n     bb1: {\n         _7 = Lt(_1, const 10_i32);       // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n-        switchInt(move _7) -> [false: bb4, otherwise: bb2]; // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n+        switchInt(move _7) -> [0: bb4, otherwise: bb2]; // scope 2 at $DIR/match_test.rs:+7:9: +7:14\n     }\n \n     bb2: {\n@@ -47,20 +47,20 @@ fn main() -> () {\n \n     bb4: {\n         _4 = Le(const 10_i32, _1);       // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n-        switchInt(move _4) -> [false: bb7, otherwise: bb5]; // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n+        switchInt(move _4) -> [0: bb7, otherwise: bb5]; // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n     }\n \n     bb5: {\n         _5 = Le(_1, const 20_i32);       // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n-        switchInt(move _5) -> [false: bb7, otherwise: bb6]; // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n+        switchInt(move _5) -> [0: bb7, otherwise: bb6]; // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n     }\n \n     bb6: {\n         falseEdge -> [real: bb12, imaginary: bb8]; // scope 2 at $DIR/match_test.rs:+8:9: +8:16\n     }\n \n     bb7: {\n-        switchInt(_1) -> [-1_i32: bb8, otherwise: bb3]; // scope 2 at $DIR/match_test.rs:+6:5: +6:12\n+        switchInt(_1) -> [4294967295: bb8, otherwise: bb3]; // scope 2 at $DIR/match_test.rs:+6:5: +6:12\n     }\n \n     bb8: {\n@@ -71,7 +71,7 @@ fn main() -> () {\n         _8 = &shallow _1;                // scope 2 at $DIR/match_test.rs:+6:11: +6:12\n         StorageLive(_9);                 // scope 2 at $DIR/match_test.rs:+7:18: +7:19\n         _9 = _2;                         // scope 2 at $DIR/match_test.rs:+7:18: +7:19\n-        switchInt(move _9) -> [false: bb11, otherwise: bb10]; // scope 2 at $DIR/match_test.rs:+7:18: +7:19\n+        switchInt(move _9) -> [0: bb11, otherwise: bb10]; // scope 2 at $DIR/match_test.rs:+7:18: +7:19\n     }\n \n     bb10: {"}, {"sha": "be91b0bfe6820f1ea61ef4ee00ab1d9ca4109a06", "filename": "src/test/mir-opt/matches_reduce_branches.bar.MatchBranchSimplification.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.bar.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -33,7 +33,7 @@\n           StorageLive(_4);                 // scope 2 at $DIR/matches_reduce_branches.rs:+3:9: +3:10\n           StorageLive(_5);                 // scope 3 at $DIR/matches_reduce_branches.rs:+4:9: +4:10\n           StorageLive(_6);                 // scope 4 at $DIR/matches_reduce_branches.rs:+6:5: +21:6\n--         switchInt(_1) -> [7_i32: bb2, otherwise: bb1]; // scope 4 at $DIR/matches_reduce_branches.rs:+6:5: +6:12\n+-         switchInt(_1) -> [7: bb2, otherwise: bb1]; // scope 4 at $DIR/matches_reduce_branches.rs:+6:5: +6:12\n -     }\n - \n -     bb1: {"}, {"sha": "aa8092ece663a7e53b8cd3efa017ffc6cf763c8e", "filename": "src/test/mir-opt/matches_reduce_branches.foo.MatchBranchSimplification.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.foo.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -11,12 +11,12 @@\n       bb0: {\n           StorageLive(_2);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           _3 = discriminant(_1);           // scope 0 at $DIR/matches_reduce_branches.rs:+1:17: +1:20\n--         switchInt(move _3) -> [0_isize: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+-         switchInt(move _3) -> [0: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n +         StorageLive(_4);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n +         _4 = move _3;                    // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n +         _2 = Eq(_4, const 0_isize);      // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n +         StorageDead(_4);                 // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-+         switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n++         switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n       }\n   \n       bb1: {\n@@ -30,7 +30,7 @@\n -     }\n - \n -     bb3: {\n--         switchInt(move _2) -> [false: bb5, otherwise: bb4]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+-         switchInt(move _2) -> [0: bb5, otherwise: bb4]; // scope 0 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n -     }\n - \n -     bb4: {"}, {"sha": "193104dd30e7e3e711c46390732435ce5cfd704e", "filename": "src/test/mir-opt/matches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_reduce_branches.match_nested_if.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -26,7 +26,7 @@\n           StorageLive(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:21: +2:52\n           StorageLive(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:24: +2:28\n           _6 = const true;                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:24: +2:28\n--         switchInt(move _6) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:24: +2:28\n+-         switchInt(move _6) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:24: +2:28\n -     }\n - \n -     bb1: {\n@@ -45,7 +45,7 @@\n +         _5 = Ne(_7, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:+2:45: +2:50\n +         StorageDead(_7);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:24: +2:28\n           StorageDead(_6);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:51: +2:52\n--         switchInt(move _5) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:21: +2:52\n+-         switchInt(move _5) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:21: +2:52\n -     }\n - \n -     bb4: {\n@@ -64,7 +64,7 @@\n +         _4 = Ne(_8, const false);        // scope 0 at $DIR/matches_reduce_branches.rs:+2:69: +2:74\n +         StorageDead(_8);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:21: +2:52\n           StorageDead(_5);                 // scope 0 at $DIR/matches_reduce_branches.rs:+2:75: +2:76\n--         switchInt(move _4) -> [false: bb8, otherwise: bb7]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:18: +2:76\n+-         switchInt(move _4) -> [0: bb8, otherwise: bb7]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:18: +2:76\n -     }\n - \n -     bb7: {\n@@ -78,7 +78,7 @@\n -     }\n - \n -     bb9: {\n--         switchInt(move _3) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:15: +6:10\n+-         switchInt(move _3) -> [0: bb11, otherwise: bb10]; // scope 0 at $DIR/matches_reduce_branches.rs:+2:15: +6:10\n -     }\n - \n -     bb10: {"}, {"sha": "3766d99a43b3b01d2f8f27702da114456e8a324e", "filename": "src/test/mir-opt/matches_u8.exhaustive_match.MatchBranchSimplification.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,7 +8,7 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/matches_u8.rs:+1:11: +1:12\n-          switchInt(move _2) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/matches_u8.rs:+1:5: +1:12\n+          switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/matches_u8.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "b5146cd539f396425714f2d50d210e96e6a8e4b1", "filename": "src/test/mir-opt/matches_u8.exhaustive_match_i8.MatchBranchSimplification.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match_i8.MatchBranchSimplification.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match_i8.MatchBranchSimplification.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatches_u8.exhaustive_match_i8.MatchBranchSimplification.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,7 +8,7 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/matches_u8.rs:+1:11: +1:12\n-          switchInt(move _2) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/matches_u8.rs:+1:5: +1:12\n+          switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/matches_u8.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "8e6564a38b0bbbaafe2dfd25125cdb4c2efefaf2", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.32bit.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.32bit.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -62,7 +62,7 @@ fn main() -> () {\n         FakeRead(ForLet(None), _6);      // bb1[4]: scope 2 at $DIR/region_subtyping_basic.rs:+3:9: +3:10\n         StorageLive(_7);                 // bb1[5]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n         _7 = const ConstValue(Scalar(0x01): bool); // bb1[6]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n-        switchInt(move _7) -> [ConstValue(Scalar(0x00): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n+        switchInt(move _7) -> [0: bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n     }\n \n     bb2: {"}, {"sha": "74d44c6741a92747b01cf35d5f7d1b52324ff91e", "filename": "src/test/mir-opt/nll/region_subtyping_basic.main.nll.0.64bit.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion_subtyping_basic.main.nll.0.64bit.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -62,7 +62,7 @@ fn main() -> () {\n         FakeRead(ForLet(None), _6);      // bb1[4]: scope 2 at $DIR/region_subtyping_basic.rs:+3:9: +3:10\n         StorageLive(_7);                 // bb1[5]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n         _7 = const ConstValue(Scalar(0x01): bool); // bb1[6]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n-        switchInt(move _7) -> [ConstValue(Scalar(0x00): bool): bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n+        switchInt(move _7) -> [0: bb4, otherwise: bb2]; // bb1[7]: scope 3 at $DIR/region_subtyping_basic.rs:+4:8: +4:12\n     }\n \n     bb2: {"}, {"sha": "69327b7afac7ec3d59cce6f5f5eb20af5501da9a", "filename": "src/test/mir-opt/no_drop_for_inactive_variant.unwrap.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fno_drop_for_inactive_variant.unwrap.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fno_drop_for_inactive_variant.unwrap.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fno_drop_for_inactive_variant.unwrap.SimplifyCfg-elaborate-drops.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -15,7 +15,7 @@ fn unwrap(_1: Option<T>) -> T {\n \n     bb0: {\n         _2 = discriminant(_1);           // scope 0 at $DIR/no_drop_for_inactive_variant.rs:+1:11: +1:14\n-        switchInt(move _2) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/no_drop_for_inactive_variant.rs:+1:5: +1:14\n+        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/no_drop_for_inactive_variant.rs:+1:5: +1:14\n     }\n \n     bb1: {"}, {"sha": "b558c35ac1eeb8a6331e65622ab69bc4364e4cc3", "filename": "src/test/mir-opt/not_equal_false.opt.InstCombine.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnot_equal_false.opt.InstCombine.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@\n -         _2 = Ne(move _3, const false);   // scope 0 at $DIR/not_equal_false.rs:+1:8: +1:18\n +         _2 = move _3;                    // scope 0 at $DIR/not_equal_false.rs:+1:8: +1:18\n           StorageDead(_3);                 // scope 0 at $DIR/not_equal_false.rs:+1:17: +1:18\n-          switchInt(move _2) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/not_equal_false.rs:+1:8: +1:18\n+          switchInt(move _2) -> [0: bb2, otherwise: bb1]; // scope 0 at $DIR/not_equal_false.rs:+1:8: +1:18\n       }\n   \n       bb1: {"}, {"sha": "bb5920b28ca9456e0aae3e953ae2baa5de7d13b5", "filename": "src/test/mir-opt/remove_fake_borrows.match_guard.CleanupNonCodegenStatements.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.match_guard.CleanupNonCodegenStatements.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.match_guard.CleanupNonCodegenStatements.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_fake_borrows.match_guard.CleanupNonCodegenStatements.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -16,7 +16,7 @@\n -         FakeRead(ForMatchedPlace(None), _1); // scope 0 at $DIR/remove_fake_borrows.rs:+1:11: +1:12\n +         nop;                             // scope 0 at $DIR/remove_fake_borrows.rs:+1:11: +1:12\n           _3 = discriminant(_1);           // scope 0 at $DIR/remove_fake_borrows.rs:+1:11: +1:12\n-          switchInt(move _3) -> [1_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/remove_fake_borrows.rs:+1:5: +1:12\n+          switchInt(move _3) -> [1: bb2, otherwise: bb1]; // scope 0 at $DIR/remove_fake_borrows.rs:+1:5: +1:12\n       }\n   \n       bb1: {\n@@ -25,7 +25,7 @@\n       }\n   \n       bb2: {\n-          switchInt((*(*((_1 as Some).0: &&i32)))) -> [0_i32: bb3, otherwise: bb1]; // scope 0 at $DIR/remove_fake_borrows.rs:+1:5: +1:12\n+          switchInt((*(*((_1 as Some).0: &&i32)))) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/remove_fake_borrows.rs:+1:5: +1:12\n       }\n   \n       bb3: {\n@@ -43,7 +43,7 @@\n +         nop;                             // scope 0 at $DIR/remove_fake_borrows.rs:+1:11: +1:12\n           StorageLive(_8);                 // scope 0 at $DIR/remove_fake_borrows.rs:+2:20: +2:21\n           _8 = _2;                         // scope 0 at $DIR/remove_fake_borrows.rs:+2:20: +2:21\n-          switchInt(move _8) -> [false: bb6, otherwise: bb5]; // scope 0 at $DIR/remove_fake_borrows.rs:+2:20: +2:21\n+          switchInt(move _8) -> [0: bb6, otherwise: bb5]; // scope 0 at $DIR/remove_fake_borrows.rs:+2:20: +2:21\n       }\n   \n       bb5: {"}, {"sha": "ed1d0b87f603373ada39bd462539ebbf2207f29a", "filename": "src/test/mir-opt/remove_storage_markers.main.RemoveStorageMarkers.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fremove_storage_markers.main.RemoveStorageMarkers.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -63,7 +63,7 @@\n       bb3: {\n -         StorageDead(_8);                 // scope 2 at $DIR/remove_storage_markers.rs:+2:18: +2:19\n           _10 = discriminant(_7);          // scope 2 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n-          switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 2 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n+          switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 2 at $DIR/remove_storage_markers.rs:+2:14: +2:19\n       }\n   \n       bb4: {"}, {"sha": "19b726e74845392e72cec5427d02ef1543fd047d", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -145,7 +145,7 @@ fn array_casts() -> () {\n         StorageDead(_24);                // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _22 = Not(move _23);             // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         StorageDead(_23);                // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-        switchInt(move _22) -> [false: bb4, otherwise: bb3]; // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+        switchInt(move _22) -> [0: bb4, otherwise: bb3]; // scope 7 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n     }\n \n     bb3: {"}, {"sha": "6ae16bdb5b88a6b673807d83b9a32fedf2c0b6c6", "filename": "src/test/mir-opt/separate_const_switch.identity.SeparateConstSwitch.diff", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.identity.SeparateConstSwitch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -53,14 +53,14 @@\n           StorageLive(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n           _4 = _1;                         // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:9\n           _10 = discriminant(_4);          // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n--         switchInt(move _10) -> [0_isize: bb7, 1_isize: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n-+         switchInt(move _10) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n+-         switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n++         switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n       }\n   \n       bb1: {\n -         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n -         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n--         switchInt(move _5) -> [0_isize: bb2, 1_isize: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n+-         switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n -     }\n - \n -     bb2: {\n@@ -118,7 +118,7 @@\n -         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n +         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n +         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(move _5) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n++         switchInt(move _5) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       }\n   \n -     bb6: {\n@@ -140,7 +140,7 @@\n -         goto -> bb1;                     // scope 5 at $SRC_DIR/core/src/result.rs:LL:COL\n +         StorageDead(_4);                 // scope 0 at $DIR/separate_const_switch.rs:+1:9: +1:10\n +         _5 = discriminant(_3);           // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n-+         switchInt(move _5) -> [0_isize: bb1, 1_isize: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n++         switchInt(move _5) -> [0: bb1, 1: bb3, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+1:8: +1:10\n       }\n   \n -     bb8: {"}, {"sha": "8cc0c6a18353c2b8ea33f0c5c25d065a6b1a0ff2", "filename": "src/test/mir-opt/separate_const_switch.too_complex.SeparateConstSwitch.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fseparate_const_switch.too_complex.SeparateConstSwitch.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -30,7 +30,7 @@\n       bb0: {\n           StorageLive(_2);                 // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n           _3 = discriminant(_1);           // scope 0 at $DIR/separate_const_switch.rs:+6:15: +6:16\n-          switchInt(move _3) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+6:9: +6:16\n+          switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/separate_const_switch.rs:+6:9: +6:16\n       }\n   \n       bb1: {\n@@ -45,7 +45,7 @@\n           StorageDead(_6);                 // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n -         goto -> bb4;                     // scope 0 at $DIR/separate_const_switch.rs:+8:43: +8:44\n +         _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n-+         switchInt(move _8) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n++         switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n       }\n   \n       bb2: {\n@@ -67,8 +67,8 @@\n - \n -     bb4: {\n           _8 = discriminant(_2);           // scope 0 at $DIR/separate_const_switch.rs:+5:11: +10:6\n--         switchInt(move _8) -> [0_isize: bb7, 1_isize: bb5, otherwise: bb6]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n-+         switchInt(move _8) -> [0_isize: bb6, 1_isize: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n+-         switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n++         switchInt(move _8) -> [0: bb6, 1: bb4, otherwise: bb5]; // scope 0 at $DIR/separate_const_switch.rs:+5:5: +10:6\n       }\n   \n -     bb5: {"}, {"sha": "8eb1aa1f3b3d0cf85b697f543aa937b6aad37f9d", "filename": "src/test/mir-opt/simplify_cfg.main.SimplifyCfg-early-opt.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-early-opt.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-early-opt.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-early-opt.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -25,9 +25,9 @@\n       }\n   \n -     bb3: {\n--         switchInt(move _2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n+-         switchInt(move _2) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n +     bb2: {\n-+         switchInt(move _2) -> [false: bb4, otherwise: bb3]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n++         switchInt(move _2) -> [0: bb4, otherwise: bb3]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n       }\n   \n -     bb4: {"}, {"sha": "1e66b1f703e3fea1d8bd151d44b25e8239460f10", "filename": "src/test/mir-opt/simplify_cfg.main.SimplifyCfg-initial.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-initial.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-initial.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_cfg.main.SimplifyCfg-initial.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -26,7 +26,7 @@\n       }\n   \n       bb3: {\n-          switchInt(move _2) -> [false: bb5, otherwise: bb4]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n+          switchInt(move _2) -> [0: bb5, otherwise: bb4]; // scope 0 at $DIR/simplify_cfg.rs:+2:12: +2:17\n       }\n   \n       bb4: {"}, {"sha": "aea0114744352d0b7a2af771f2cdc8db318a670d", "filename": "src/test/mir-opt/simplify_if.main.SimplifyConstCondition-after-const-prop.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.main.SimplifyConstCondition-after-const-prop.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -9,7 +9,7 @@\n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/simplify_if.rs:+1:8: +1:13\n           _1 = const false;                // scope 0 at $DIR/simplify_if.rs:+1:8: +1:13\n--         switchInt(const false) -> [false: bb3, otherwise: bb1]; // scope 0 at $DIR/simplify_if.rs:+1:8: +1:13\n+-         switchInt(const false) -> [0: bb3, otherwise: bb1]; // scope 0 at $DIR/simplify_if.rs:+1:8: +1:13\n +         goto -> bb3;                     // scope 0 at $DIR/simplify_if.rs:+1:8: +1:13\n       }\n   "}, {"sha": "a2b55229303d39446a364aadbf2e0025cb202825", "filename": "src/test/mir-opt/simplify_locals_fixedpoint.foo.SimplifyLocals.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_locals_fixedpoint.foo.SimplifyLocals.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,12 +29,12 @@\n           StorageDead(_3);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:68: +1:69\n           StorageDead(_2);                 // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:68: +1:69\n           _5 = discriminant((_1.0: std::option::Option<u8>)); // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n-          switchInt(move _5) -> [1_isize: bb1, otherwise: bb3]; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n+          switchInt(move _5) -> [1: bb1, otherwise: bb3]; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n       }\n   \n       bb1: {\n           _4 = discriminant((_1.1: std::option::Option<T>)); // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n-          switchInt(move _4) -> [0_isize: bb2, otherwise: bb3]; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n+          switchInt(move _4) -> [0: bb2, otherwise: bb3]; // scope 1 at $DIR/simplify_locals_fixedpoint.rs:+1:12: +1:27\n       }\n   \n       bb2: {"}, {"sha": "9ec138dd82f44b43230b458e4f785038b6d45e92", "filename": "src/test/mir-opt/simplify_locals_removes_unused_discriminant_reads.map.SimplifyLocals.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_discriminant_reads.map.SimplifyLocals.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_discriminant_reads.map.SimplifyLocals.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_locals_removes_unused_discriminant_reads.map.SimplifyLocals.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -18,7 +18,7 @@\n -         _5 = const false;                // scope 0 at $DIR/simplify_locals_removes_unused_discriminant_reads.rs:+1:11: +1:12\n -         _5 = const true;                 // scope 0 at $DIR/simplify_locals_removes_unused_discriminant_reads.rs:+1:11: +1:12\n           _2 = discriminant(_1);           // scope 0 at $DIR/simplify_locals_removes_unused_discriminant_reads.rs:+1:11: +1:12\n-          switchInt(move _2) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_locals_removes_unused_discriminant_reads.rs:+1:5: +1:12\n+          switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_locals_removes_unused_discriminant_reads.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "f00ac5716a7517c7b29f56dc48688ca8ee37784e", "filename": "src/test/mir-opt/simplify_match.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_match.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsimplify_match.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match.main.ConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -16,8 +16,8 @@\n -         _1 = _2;                         // scope 1 at $DIR/simplify_match.rs:+1:28: +1:29\n +         _1 = const false;                // scope 1 at $DIR/simplify_match.rs:+1:28: +1:29\n           StorageDead(_2);                 // scope 0 at $DIR/simplify_match.rs:+1:30: +1:31\n--         switchInt(_1) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:+1:5: +1:31\n-+         switchInt(const false) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:+1:5: +1:31\n+-         switchInt(_1) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:+1:5: +1:31\n++         switchInt(const false) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:+1:5: +1:31\n       }\n   \n       bb1: {"}, {"sha": "391b00effacfa0577a60e22008770449fab227a6", "filename": "src/test/mir-opt/slice_drop_shim.core.ptr-drop_in_place.[String].AddMovesForPackedDrops.before.mir", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -37,7 +37,7 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n \n     bb4 (cleanup): {\n         _6 = Eq(_4, _3);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _6) -> [false: bb3, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _6) -> [0: bb3, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb5: {\n@@ -48,7 +48,7 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n \n     bb6: {\n         _8 = Eq(_4, _3);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _8) -> [false: bb5, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _8) -> [0: bb5, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb7: {\n@@ -68,7 +68,7 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n \n     bb10 (cleanup): {\n         _12 = Eq(_9, _10);               // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _12) -> [false: bb9, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _12) -> [0: bb9, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb11: {\n@@ -79,7 +79,7 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n \n     bb12: {\n         _14 = Eq(_9, _10);               // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _14) -> [false: bb11, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _14) -> [0: bb11, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb13: {\n@@ -96,6 +96,6 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n     bb15: {\n         _2 = SizeOf(std::string::String); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         _3 = Len((*_1));                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _2) -> [0_usize: bb8, otherwise: bb14]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _2) -> [0: bb8, otherwise: bb14]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n }"}, {"sha": "a5488c1ec7bfee1f31c4ae7fc8d7ab3331b345ab", "filename": "src/test/mir-opt/sroa.enums.ScalarReplacementOfAggregates.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsroa.enums.ScalarReplacementOfAggregates.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fsroa.enums.ScalarReplacementOfAggregates.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsroa.enums.ScalarReplacementOfAggregates.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -21,7 +21,7 @@\n           discriminant(_2) = 1;            // scope 1 at $DIR/sroa.rs:+1:22: +1:29\n           StorageDead(_3);                 // scope 1 at $DIR/sroa.rs:+1:28: +1:29\n           _4 = discriminant(_2);           // scope 1 at $DIR/sroa.rs:+1:12: +1:19\n-          switchInt(move _4) -> [1_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/sroa.rs:+1:12: +1:19\n+          switchInt(move _4) -> [1: bb1, otherwise: bb2]; // scope 1 at $DIR/sroa.rs:+1:12: +1:19\n       }\n   \n       bb1: {"}, {"sha": "b254bfeb7c992500212de9570d51fd6ae98b8dbc", "filename": "src/test/mir-opt/try_identity_e2e.new.PreCodegen.after.mir", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.new.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -26,7 +26,7 @@ fn new(_1: Result<T, E>) -> Result<T, E> {\n     bb0: {\n         StorageLive(_2);                 // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n         _3 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+3:19: +3:20\n-        switchInt(move _3) -> [0_isize: bb2, 1_isize: bb1, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:20\n+        switchInt(move _3) -> [0: bb2, 1: bb1, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+3:13: +3:20\n     }\n \n     bb1: {\n@@ -35,7 +35,7 @@ fn new(_1: Result<T, E>) -> Result<T, E> {\n         ((_2 as Break).0: E) = move _5;  // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n         discriminant(_2) = 1;            // scope 2 at $DIR/try_identity_e2e.rs:+5:27: +5:48\n         _6 = discriminant(_2);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-        switchInt(move _6) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n+        switchInt(move _6) -> [0: bb5, 1: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n     }\n \n     bb2: {\n@@ -44,7 +44,7 @@ fn new(_1: Result<T, E>) -> Result<T, E> {\n         ((_2 as Continue).0: T) = move _4; // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n         discriminant(_2) = 0;            // scope 1 at $DIR/try_identity_e2e.rs:+4:26: +4:50\n         _6 = discriminant(_2);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +7:10\n-        switchInt(move _6) -> [0_isize: bb5, 1_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n+        switchInt(move _6) -> [0: bb5, 1: bb3, otherwise: bb4]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +7:10\n     }\n \n     bb3: {"}, {"sha": "cdbc0681cb8a363ae2acadeeb236c7718ad3c00a", "filename": "src/test/mir-opt/try_identity_e2e.old.PreCodegen.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ftry_identity_e2e.old.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -15,7 +15,7 @@ fn old(_1: Result<T, E>) -> Result<T, E> {\n \n     bb0: {\n         _2 = discriminant(_1);           // scope 0 at $DIR/try_identity_e2e.rs:+2:15: +2:16\n-        switchInt(move _2) -> [0_isize: bb3, 1_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +2:16\n+        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 0 at $DIR/try_identity_e2e.rs:+2:9: +2:16\n     }\n \n     bb1: {"}, {"sha": "39ec05277595518ba60e39de7973cdbb8b998c71", "filename": "src/test/mir-opt/uninhabited_enum_branching.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -18,7 +18,7 @@ fn main() -> () {\n         Deinit(_2);                      // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n         discriminant(_2) = 2;            // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n         _3 = discriminant(_2);           // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n-        switchInt(move _3) -> [2_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n+        switchInt(move _3) -> [2: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n     }\n \n     bb1: {\n@@ -36,7 +36,7 @@ fn main() -> () {\n         Deinit(_7);                      // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n         discriminant(_7) = 0;            // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n         _8 = discriminant(_7);           // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n-        switchInt(move _8) -> [4_isize: bb5, 5_isize: bb3, otherwise: bb4]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:5: +7:19\n+        switchInt(move _8) -> [4: bb5, 5: bb3, otherwise: bb4]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:5: +7:19\n     }\n \n     bb2: {"}, {"sha": "598413a1d82de896744266987d7f71afe96793b8", "filename": "src/test/mir-opt/uninhabited_enum_branching.main.UninhabitedEnumBranching.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.UninhabitedEnumBranching.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.UninhabitedEnumBranching.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching.main.UninhabitedEnumBranching.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -19,8 +19,8 @@\n           Deinit(_2);                      // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n           discriminant(_2) = 2;            // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n           _3 = discriminant(_2);           // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:11: +1:19\n--         switchInt(move _3) -> [0_isize: bb3, 1_isize: bb4, 2_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n-+         switchInt(move _3) -> [2_isize: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n+-         switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n++         switchInt(move _3) -> [2: bb1, otherwise: bb2]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+1:5: +1:19\n       }\n   \n       bb1: {\n@@ -65,7 +65,7 @@\n           Deinit(_7);                      // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n           discriminant(_7) = 0;            // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n           _8 = discriminant(_7);           // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:11: +7:19\n-          switchInt(move _8) -> [4_isize: bb8, 5_isize: bb6, otherwise: bb7]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:5: +7:19\n+          switchInt(move _8) -> [4: bb8, 5: bb6, otherwise: bb7]; // scope 0 at $DIR/uninhabited_enum_branching.rs:+7:5: +7:19\n       }\n   \n       bb6: {"}, {"sha": "c8cd6f6c1ea1d69950ee8f65accd39fb1acdaf6f", "filename": "src/test/mir-opt/uninhabited_enum_branching2.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.SimplifyCfg-after-uninhabited-enum-branching.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -32,7 +32,7 @@ fn main() -> () {\n         StorageLive(_4);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n         _4 = &(_1.1: Test1);             // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n         _5 = discriminant((*_4));        // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n-        switchInt(move _5) -> [2_isize: bb3, 3_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n+        switchInt(move _5) -> [2: bb3, 3: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n     }\n \n     bb1: {\n@@ -66,7 +66,7 @@ fn main() -> () {\n         StorageDead(_3);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+8:6: +8:7\n         StorageLive(_9);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +15:6\n         _10 = discriminant((_1.1: Test1)); // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:11: +10:21\n-        switchInt(move _10) -> [2_isize: bb7, 3_isize: bb5, otherwise: bb6]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n+        switchInt(move _10) -> [2: bb7, 3: bb5, otherwise: bb6]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n     }\n \n     bb5: {"}, {"sha": "2aee6d2681d642466be5cab4bb5b8b93da629ea4", "filename": "src/test/mir-opt/uninhabited_enum_branching2.main.UninhabitedEnumBranching.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.UninhabitedEnumBranching.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.UninhabitedEnumBranching.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_enum_branching2.main.UninhabitedEnumBranching.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -33,8 +33,8 @@\n           StorageLive(_4);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n           _4 = &(_1.1: Test1);             // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n           _5 = discriminant((*_4));        // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:11: +3:22\n--         switchInt(move _5) -> [0_isize: bb3, 1_isize: bb4, 2_isize: bb5, 3_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n-+         switchInt(move _5) -> [2_isize: bb5, 3_isize: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n+-         switchInt(move _5) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n++         switchInt(move _5) -> [2: bb5, 3: bb1, otherwise: bb2]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+3:5: +3:22\n       }\n   \n       bb1: {\n@@ -87,8 +87,8 @@\n           StorageDead(_3);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+8:6: +8:7\n           StorageLive(_9);                 // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +15:6\n           _10 = discriminant((_1.1: Test1)); // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:11: +10:21\n--         switchInt(move _10) -> [0_isize: bb9, 1_isize: bb10, 2_isize: bb11, 3_isize: bb7, otherwise: bb8]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n-+         switchInt(move _10) -> [2_isize: bb11, 3_isize: bb7, otherwise: bb8]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n+-         switchInt(move _10) -> [0: bb9, 1: bb10, 2: bb11, 3: bb7, otherwise: bb8]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n++         switchInt(move _10) -> [2: bb11, 3: bb7, otherwise: bb8]; // scope 1 at $DIR/uninhabited_enum_branching2.rs:+10:5: +10:21\n       }\n   \n       bb7: {"}, {"sha": "58e085dd041972089317a9e7964b4ea9c64c0107", "filename": "src/test/mir-opt/uninhabited_fallthrough_elimination.eliminate_fallthrough.UninhabitedEnumBranching.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.eliminate_fallthrough.UninhabitedEnumBranching.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.eliminate_fallthrough.UninhabitedEnumBranching.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.eliminate_fallthrough.UninhabitedEnumBranching.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,8 +8,8 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:11: +1:12\n--         switchInt(move _2) -> [1_isize: bb3, 2_isize: bb2, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n-+         switchInt(move _2) -> [1_isize: bb3, 2_isize: bb2, otherwise: bb5]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n+-         switchInt(move _2) -> [1: bb3, 2: bb2, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n++         switchInt(move _2) -> [1: bb3, 2: bb2, otherwise: bb5]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "e765851eb78b7a75d50d871407ce6e196744ec57", "filename": "src/test/mir-opt/uninhabited_fallthrough_elimination.keep_fallthrough.UninhabitedEnumBranching.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.keep_fallthrough.UninhabitedEnumBranching.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.keep_fallthrough.UninhabitedEnumBranching.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funinhabited_fallthrough_elimination.keep_fallthrough.UninhabitedEnumBranching.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -8,8 +8,8 @@\n   \n       bb0: {\n           _2 = discriminant(_1);           // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:11: +1:12\n--         switchInt(move _2) -> [0_isize: bb2, 1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n-+         switchInt(move _2) -> [1_isize: bb3, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n+-         switchInt(move _2) -> [0: bb2, 1: bb3, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n++         switchInt(move _2) -> [1: bb3, otherwise: bb1]; // scope 0 at $DIR/uninhabited_fallthrough_elimination.rs:+1:5: +1:12\n       }\n   \n       bb1: {"}, {"sha": "848bff1d4920c18695bb801134b4d80c0b90b75c", "filename": "src/test/mir-opt/unreachable.main.UnreachablePropagation.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable.main.UnreachablePropagation.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -27,8 +27,8 @@\n   \n       bb1: {\n           _2 = discriminant(_1);           // scope 1 at $DIR/unreachable.rs:+1:12: +1:20\n--         switchInt(move _2) -> [1_isize: bb2, otherwise: bb6]; // scope 1 at $DIR/unreachable.rs:+1:12: +1:20\n-+         switchInt(move _2) -> [1_isize: bb2, otherwise: bb3]; // scope 1 at $DIR/unreachable.rs:+1:12: +1:20\n+-         switchInt(move _2) -> [1: bb2, otherwise: bb6]; // scope 1 at $DIR/unreachable.rs:+1:12: +1:20\n++         switchInt(move _2) -> [1: bb2, otherwise: bb3]; // scope 1 at $DIR/unreachable.rs:+1:12: +1:20\n       }\n   \n       bb2: {\n@@ -38,7 +38,7 @@\n -         StorageLive(_5);                 // scope 2 at $DIR/unreachable.rs:+4:9: +8:10\n -         StorageLive(_6);                 // scope 2 at $DIR/unreachable.rs:+4:12: +4:16\n -         _6 = const true;                 // scope 2 at $DIR/unreachable.rs:+4:12: +4:16\n--         switchInt(move _6) -> [false: bb4, otherwise: bb3]; // scope 2 at $DIR/unreachable.rs:+4:12: +4:16\n+-         switchInt(move _6) -> [0: bb4, otherwise: bb3]; // scope 2 at $DIR/unreachable.rs:+4:12: +4:16\n +         unreachable;                     // scope 2 at $DIR/unreachable.rs:+4:12: +4:16\n       }\n   "}, {"sha": "fb778470e532323d8958c6dfc3001ec7b5a39bf3", "filename": "src/test/mir-opt/unreachable_diverging.main.UnreachablePropagation.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funreachable_diverging.main.UnreachablePropagation.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -29,7 +29,7 @@\n   \n       bb1: {\n           _3 = discriminant(_2);           // scope 2 at $DIR/unreachable_diverging.rs:+2:12: +2:22\n-          switchInt(move _3) -> [1_isize: bb2, otherwise: bb6]; // scope 2 at $DIR/unreachable_diverging.rs:+2:12: +2:22\n+          switchInt(move _3) -> [1: bb2, otherwise: bb6]; // scope 2 at $DIR/unreachable_diverging.rs:+2:12: +2:22\n       }\n   \n       bb2: {\n@@ -38,7 +38,7 @@\n           StorageLive(_5);                 // scope 2 at $DIR/unreachable_diverging.rs:+3:9: +5:10\n           StorageLive(_6);                 // scope 2 at $DIR/unreachable_diverging.rs:+3:12: +3:13\n           _6 = _1;                         // scope 2 at $DIR/unreachable_diverging.rs:+3:12: +3:13\n-          switchInt(move _6) -> [false: bb4, otherwise: bb3]; // scope 2 at $DIR/unreachable_diverging.rs:+3:12: +3:13\n+          switchInt(move _6) -> [0: bb4, otherwise: bb3]; // scope 2 at $DIR/unreachable_diverging.rs:+3:12: +3:13\n       }\n   \n       bb3: {"}, {"sha": "984ef476e10209d4e5f830ccabc9f1af04a989ef", "filename": "src/test/mir-opt/while_let_loops.change_loop_body.ConstProp.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile_let_loops.change_loop_body.ConstProp.diff?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -24,13 +24,13 @@\n           Deinit(_3);                      // scope 2 at $DIR/while_let_loops.rs:+2:28: +2:32\n           discriminant(_3) = 0;            // scope 2 at $DIR/while_let_loops.rs:+2:28: +2:32\n -         _4 = discriminant(_3);           // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n--         switchInt(move _4) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n+-         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n +         _4 = const 0_isize;              // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n-+         switchInt(const 0_isize) -> [1_isize: bb1, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n++         switchInt(const 0_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n       }\n   \n       bb1: {\n-          switchInt(((_3 as Some).0: u32)) -> [0_u32: bb2, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n+          switchInt(((_3 as Some).0: u32)) -> [0: bb2, otherwise: bb3]; // scope 2 at $DIR/while_let_loops.rs:+2:15: +2:25\n       }\n   \n       bb2: {"}, {"sha": "1556c240dc57a4335f848ca05289bff38cb366a6", "filename": "src/test/mir-opt/while_storage.while_loop.PreCodegen.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fwhile_storage.while_loop.PreCodegen.after.mir?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -24,7 +24,7 @@ fn while_loop(_1: bool) -> () {\n \n     bb2: {\n         StorageDead(_3);                 // scope 0 at $DIR/while_storage.rs:+1:21: +1:22\n-        switchInt(move _2) -> [false: bb7, otherwise: bb3]; // scope 0 at $DIR/while_storage.rs:+1:11: +1:22\n+        switchInt(move _2) -> [0: bb7, otherwise: bb3]; // scope 0 at $DIR/while_storage.rs:+1:11: +1:22\n     }\n \n     bb3: {\n@@ -39,7 +39,7 @@ fn while_loop(_1: bool) -> () {\n \n     bb4: {\n         StorageDead(_5);                 // scope 0 at $DIR/while_storage.rs:+2:22: +2:23\n-        switchInt(move _4) -> [false: bb6, otherwise: bb5]; // scope 0 at $DIR/while_storage.rs:+2:12: +2:23\n+        switchInt(move _4) -> [0: bb6, otherwise: bb5]; // scope 0 at $DIR/while_storage.rs:+2:12: +2:23\n     }\n \n     bb5: {"}, {"sha": "57497f5205384cc5883a6809b4c29feb75cfd921", "filename": "src/test/run-make/issue-71519/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frun-make%2Fissue-71519%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frun-make%2Fissue-71519%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-71519%2FMakefile?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,6 +2,7 @@ include ../../run-make-fulldeps/tools.mk\n \n # ignore-msvc\n # needs-rust-lld\n+# ignore-s390x lld does not yet support s390x as target\n all:\n \tRUSTC_LOG=rustc_codegen_ssa::back::link=info $(RUSTC) -Z gcc-ld=lld -C link-args=-Wl,-v main.rs 2> $(TMPDIR)/output.txt\n \t$(CGREP) -e \"^LLD [0-9]+\\.[0-9]+\\.[0-9]+\" < $(TMPDIR)/output.txt"}, {"sha": "60292835bc0bf3ad3860310857470d9126f752a4", "filename": "src/test/rustdoc-gui/basic.goml", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30e435907e324d679943b21c94fc8e7a9ddd7348/src%2Ftest%2Frustdoc-gui%2Fbasic.goml", "raw_url": "https://github.com/rust-lang/rust/raw/30e435907e324d679943b21c94fc8e7a9ddd7348/src%2Ftest%2Frustdoc-gui%2Fbasic.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fbasic.goml?ref=30e435907e324d679943b21c94fc8e7a9ddd7348", "patch": "@@ -1,4 +0,0 @@\n-goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n-assert: (\"#functions\")\n-goto: \"./struct.Foo.html\"\n-assert: (\"div.item-decl\")"}, {"sha": "8645c1b1949e3f79533a5d76345bea8aec5285b6", "filename": "src/test/rustdoc-gui/docblock-table.goml", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fdocblock-table.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fdocblock-table.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fdocblock-table.goml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,3 +2,50 @@ goto: \"file://\" + |DOC_PATH| + \"/test_docs/doc_block_table/struct.DocBlockTable.\n \n compare-elements-css: (\".impl-items .docblock table th\", \".top-doc .docblock table th\", [\"border\"])\n compare-elements-css: (\".impl-items .docblock table td\", \".top-doc .docblock table td\", [\"border\"])\n+\n+define-function: (\n+    \"check-colors\",\n+    (theme, border_color, zebra_stripe_color),\n+    [\n+        (\"local-storage\", {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": |theme|}),\n+        (\"reload\"),\n+        (\"assert-css\", (\".top-doc .docblock table tbody tr:nth-child(1)\", {\n+            \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        })),\n+        (\"assert-css\", (\".top-doc .docblock table tbody tr:nth-child(2)\", {\n+            \"background-color\": |zebra_stripe_color|,\n+        })),\n+        (\"assert-css\", (\".top-doc .docblock table tbody tr:nth-child(3)\", {\n+            \"background-color\": \"rgba(0, 0, 0, 0)\",\n+        })),\n+        (\"assert-css\", (\".top-doc .docblock table tbody tr:nth-child(4)\", {\n+            \"background-color\": |zebra_stripe_color|,\n+        })),\n+        (\"assert-css\", (\".top-doc .docblock table td\", {\n+            \"border-style\": \"solid\",\n+            \"border-width\": \"1px\",\n+            \"border-color\": |border_color|,\n+        })),\n+        (\"assert-css\", (\".top-doc .docblock table th\", {\n+            \"border-style\": \"solid\",\n+            \"border-width\": \"1px\",\n+            \"border-color\": |border_color|,\n+        })),\n+    ]\n+)\n+\n+call-function: (\"check-colors\", {\n+    \"theme\": \"dark\",\n+    \"border_color\": \"rgb(224, 224, 224)\",\n+    \"zebra_stripe_color\": \"rgb(42, 42, 42)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"ayu\",\n+    \"border_color\": \"rgb(92, 103, 115)\",\n+    \"zebra_stripe_color\": \"rgb(25, 31, 38)\",\n+})\n+call-function: (\"check-colors\", {\n+    \"theme\": \"light\",\n+    \"border_color\": \"rgb(224, 224, 224)\",\n+    \"zebra_stripe_color\": \"rgb(245, 245, 245)\",\n+})"}, {"sha": "bba518db099a49693956915158ffb3e224478716", "filename": "src/test/rustdoc-gui/scrape-examples-button-focus.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-button-focus.goml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,5 +1,6 @@\n goto: \"file://\" + |DOC_PATH| + \"/scrape_examples/fn.test.html\"\n \n+// The next/prev buttons vertically scroll the code viewport between examples\n store-property: (initialScrollTop, \".scraped-example-list > .scraped-example pre\", \"scrollTop\")\n focus: \".scraped-example-list > .scraped-example .next\"\n press-key: \"Enter\"\n@@ -12,6 +13,7 @@ assert-property: (\".scraped-example-list > .scraped-example pre\", {\n \t\"scrollTop\": |initialScrollTop|\n })\n \n+// The expand button increases the scrollHeight of the minimized code viewport\n store-property: (smallOffsetHeight, \".scraped-example-list > .scraped-example pre\", \"offsetHeight\")\n assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n \t\"scrollHeight\": |smallOffsetHeight|"}, {"sha": "ee720afb788fe03ff01af8a69c262c45e97c3cbf", "filename": "src/test/rustdoc-gui/scrape-examples-toggle.goml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-toggle.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-toggle.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fscrape-examples-toggle.goml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,14 @@\n+goto: \"file://\" + |DOC_PATH| + \"/scrape_examples/fn.test_many.html\"\n+\n+// Clicking \"More examples...\" will open additional examples\n+assert-attribute-false: (\".more-examples-toggle\", {\"open\": \"\"})\n+click: \".more-examples-toggle\"\n+assert-attribute: (\".more-examples-toggle\", {\"open\": \"\"})\n+\n+// Toggling all docs will close additional examples\n+click: \"#toggle-all-docs\"\n+assert-attribute-false: (\".more-examples-toggle\", {\"open\": \"\"})\n+\n+// After re-opening the docs, the additional examples should stay closed\n+click: \"#toggle-all-docs\"\n+assert-attribute-false: (\".more-examples-toggle\", {\"open\": \"\"})"}, {"sha": "d6eeab803dfec3c7e9399be5f87f4cb3ba903b54", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -343,6 +343,9 @@ pub mod doc_block_table {\n     /// | header1                  | header2                  |\n     /// |--------------------------|--------------------------|\n     /// | Lorem Ipsum, Lorem Ipsum | Lorem Ipsum, Lorem Ipsum |\n+    /// | Lorem Ipsum, Lorem Ipsum | Lorem Ipsum, Lorem Ipsum |\n+    /// | Lorem Ipsum, Lorem Ipsum | Lorem Ipsum, Lorem Ipsum |\n+    /// | Lorem Ipsum, Lorem Ipsum | Lorem Ipsum, Lorem Ipsum |\n     pub struct DocBlockTable {}\n \n     impl DocBlockTableTrait for DocBlockTable {"}, {"sha": "aaed8440a40bd44807ac174149a1128732eba65e", "filename": "src/test/rustdoc-gui/stab-badge.goml", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fstab-badge.goml", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-gui%2Fstab-badge.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fstab-badge.goml?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,41 @@\n+// All stability badges should have rounded corners and colored backgrounds.\n+goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n+show-text: true\n+define-function: (\n+\t\"check-badge\",\n+\t(theme, background, color),\n+\t[\n+        (\"local-storage\", {\"rustdoc-use-system-theme\": \"false\", \"rustdoc-theme\": |theme|}),\n+        (\"goto\", \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"),\n+\t\t(\"assert\", (\".docblock .stab\")),\n+\t\t(\"assert\", (\".item-table .stab\")),\n+\t\t(\"assert-css\", (\".stab\", {\n+\t\t\t\"border-radius\": \"3px\",\n+\t\t\t\"color\": |color|,\n+\t\t\t\"background-color\": |background|,\n+\t\t})),\n+        (\"goto\", \"file://\" + |DOC_PATH| + \"/test_docs/fn.replaced_function.html\"),\n+\t\t(\"assert\", (\".item-info .stab\")),\n+\t\t(\"assert-css\", (\".stab\", {\n+\t\t\t\"border-radius\": \"3px\",\n+\t\t\t\"color\": |color|,\n+\t\t\t\"background-color\": |background|,\n+\t\t})),\n+\t]\n+)\n+\n+call-function: (\"check-badge\", {\n+\t\"theme\": \"ayu\",\n+\t\"color\": \"rgb(197, 197, 197)\",\n+\t\"background\": \"rgb(49, 69, 89)\",\n+})\n+call-function: (\"check-badge\", {\n+\t\"theme\": \"dark\",\n+\t\"color\": \"rgb(221, 221, 221)\",\n+\t\"background\": \"rgb(49, 69, 89)\",\n+})\n+call-function: (\"check-badge\", {\n+\t\"theme\": \"light\",\n+\t\"color\": \"rgb(0, 0, 0)\",\n+\t\"background\": \"rgb(255, 245, 214)\",\n+})"}, {"sha": "0dd3bcaa2895d7ce4a25e8e27dd9b66d4217c7e3", "filename": "src/test/rustdoc-ui/const-evalutation-ice.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -7,4 +7,5 @@ pub struct S {\n     s: Cell<usize>\n }\n \n-pub const N: usize = 0 - (mem::size_of::<S>() != 4) as usize;\n+pub const N: usize = 0 - (mem::size_of::<S>() != 400) as usize;\n+//~^ ERROR evaluation of constant value failed", "previous_filename": "src/test/rustdoc/const-evalutation-ice.rs"}, {"sha": "5d9c16c076529e047261dc06b9bb1f5d4e8cde1c", "filename": "src/test/rustdoc-ui/const-evalutation-ice.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fconst-evalutation-ice.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-evalutation-ice.rs:10:22\n+   |\n+LL | pub const N: usize = 0 - (mem::size_of::<S>() != 400) as usize;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "14b7b17e04d3af476d66cc25a0c917976f8b0e53", "filename": "src/test/rustdoc-ui/doc-cfg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,7 +2,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/doc-cfg.rs:3:7\n    |\n LL | #[doc(cfg(), cfg(foo, bar))]\n-   |       ^^^^^\n+   |       ^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/doc-cfg.rs:3:23\n@@ -14,7 +14,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/doc-cfg.rs:7:7\n    |\n LL | #[doc(cfg())]\n-   |       ^^^^^\n+   |       ^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/doc-cfg.rs:8:16"}, {"sha": "1b03bc3af9c72d8c4fbbc0d84141233aedf7b078", "filename": "src/test/ui/borrowck/issue-81899.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-81899.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,15 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-81899.rs:11:5\n    |\n-LL | const _CONST: &[u8] = &f(&[], |_| {});\n-   |                        -------------- inside `_CONST` at $DIR/issue-81899.rs:4:24\n-...\n+LL |     panic!()\n+   |     ^^^^^^^^ the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:11:5\n+   |\n+note: inside `f::<[closure@$DIR/issue-81899.rs:4:31: 4:34]>`\n+  --> $DIR/issue-81899.rs:11:5\n+   |\n LL |     panic!()\n    |     ^^^^^^^^\n-   |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-81899.rs:11:5\n-   |     inside `f::<[closure@$DIR/issue-81899.rs:4:31: 4:34]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n+note: inside `_CONST`\n+  --> $DIR/issue-81899.rs:4:24\n    |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   |                        ^^^^^^^^^^^^^^\n    = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used"}, {"sha": "a5a571c6d4df09036758caf0ffe792cba65a8e02", "filename": "src/test/ui/borrowck/issue-88434-minimal-example.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-minimal-example.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,15 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-88434-minimal-example.rs:10:5\n    |\n-LL | const _CONST: &() = &f(&|_| {});\n-   |                      ---------- inside `_CONST` at $DIR/issue-88434-minimal-example.rs:3:22\n-...\n+LL |     panic!()\n+   |     ^^^^^^^^ the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:10:5\n+   |\n+note: inside `f::<[closure@$DIR/issue-88434-minimal-example.rs:3:25: 3:28]>`\n+  --> $DIR/issue-88434-minimal-example.rs:10:5\n+   |\n LL |     panic!()\n    |     ^^^^^^^^\n-   |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-minimal-example.rs:10:5\n-   |     inside `f::<[closure@$DIR/issue-88434-minimal-example.rs:3:25: 3:28]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n+note: inside `_CONST`\n+  --> $DIR/issue-88434-minimal-example.rs:3:22\n    |\n+LL | const _CONST: &() = &f(&|_| {});\n+   |                      ^^^^^^^^^^\n    = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used"}, {"sha": "00023c459a8e7228b6e5c4bcd3250debddb2c507", "filename": "src/test/ui/borrowck/issue-88434-removal-index-should-be-less.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-88434-removal-index-should-be-less.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,15 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-88434-removal-index-should-be-less.rs:10:5\n    |\n-LL | const _CONST: &[u8] = &f(&[], |_| {});\n-   |                        -------------- inside `_CONST` at $DIR/issue-88434-removal-index-should-be-less.rs:3:24\n-...\n+LL |     panic!()\n+   |     ^^^^^^^^ the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:10:5\n+   |\n+note: inside `f::<[closure@$DIR/issue-88434-removal-index-should-be-less.rs:3:31: 3:34]>`\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:10:5\n+   |\n LL |     panic!()\n    |     ^^^^^^^^\n-   |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/issue-88434-removal-index-should-be-less.rs:10:5\n-   |     inside `f::<[closure@$DIR/issue-88434-removal-index-should-be-less.rs:3:31: 3:34]>` at $SRC_DIR/std/src/panic.rs:LL:COL\n+note: inside `_CONST`\n+  --> $DIR/issue-88434-removal-index-should-be-less.rs:3:24\n    |\n+LL | const _CONST: &[u8] = &f(&[], |_| {});\n+   |                        ^^^^^^^^^^^^^^\n    = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: erroneous constant used"}, {"sha": "d5b4349c00f6f090078578a84fefd5fffa3fb040", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -14,7 +14,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/cfg-attr-syntax-validation.rs:7:1\n    |\n LL | #[cfg()]\n-   | ^^^^^^^^\n+   | ^^^^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/cfg-attr-syntax-validation.rs:10:10"}, {"sha": "d8b23bc01a96dc40d8c2eac272745c8bf8e56be7", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-105257.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.rs?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,9 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait Trait<T> {\n+    fn fnc<const N: usize = \"\">(&self) {} //~ERROR defaults for const parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions\n+    fn foo<const N: usize = { std::mem::size_of::<T>() }>(&self) {} //~ERROR defaults for const parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions\n+}\n+\n+fn main() {}"}, {"sha": "ed7a8cb19a4a5fc45b7d3e1b0a4c64e22adf16fb", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-105257.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-105257.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -0,0 +1,14 @@\n+error: defaults for const parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions\n+  --> $DIR/issue-105257.rs:5:12\n+   |\n+LL |     fn fnc<const N: usize = \"\">(&self) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n+\n+error: defaults for const parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions\n+  --> $DIR/issue-105257.rs:6:12\n+   |\n+LL |     fn foo<const N: usize = { std::mem::size_of::<T>() }>(&self) {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "029528c3a8172772da0aa816061918b95613641e", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-79518-default_trait_method_normalization.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-79518-default_trait_method_normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-79518-default_trait_method_normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-79518-default_trait_method_normalization.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-79518-default_trait_method_normalization.rs:16:32\n    |\n LL |         Self::AssocInstance == [(); std::mem::size_of::<Self::Assoc>()];\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found array `[(); _]`\n+   |         -------------------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected associated type, found array `[(); _]`\n+   |         |\n+   |         expected because this is `<Self as Foo>::Assoc`\n    |\n    = note: expected associated type `<Self as Foo>::Assoc`\n                         found array `[(); _]`"}, {"sha": "bf1b411ee7ccfdffe5485386a183c7ac81dd9376", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-80742.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-80742.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,15 +2,18 @@ error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     size_of called on unsized type `dyn Debug`\n-   |     inside `std::mem::size_of::<dyn Debug>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ size_of called on unsized type `dyn Debug`\n+   |\n+note: inside `std::mem::size_of::<dyn Debug>`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n-  ::: $DIR/issue-80742.rs:22:10\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `Inline::<dyn Debug>::{constant#0}`\n+  --> $DIR/issue-80742.rs:22:10\n    |\n LL |     [u8; size_of::<T>() + 1]: ,\n-   |          -------------- inside `Inline::<dyn Debug>::{constant#0}` at $DIR/issue-80742.rs:22:10\n+   |          ^^^^^^^^^^^^^^\n \n error[E0599]: the function or associated item `new` exists for struct `Inline<dyn Debug>`, but its trait bounds were not satisfied\n   --> $DIR/issue-80742.rs:30:36\n@@ -33,15 +36,18 @@ error[E0080]: evaluation of `Inline::<dyn std::fmt::Debug>::{constant#0}` failed\n   --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n LL |     intrinsics::size_of::<T>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     size_of called on unsized type `dyn Debug`\n-   |     inside `std::mem::size_of::<dyn Debug>` at $SRC_DIR/core/src/mem/mod.rs:LL:COL\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ size_of called on unsized type `dyn Debug`\n+   |\n+note: inside `std::mem::size_of::<dyn Debug>`\n+  --> $SRC_DIR/core/src/mem/mod.rs:LL:COL\n    |\n-  ::: $DIR/issue-80742.rs:14:10\n+LL |     intrinsics::size_of::<T>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `Inline::<dyn Debug>::{constant#0}`\n+  --> $DIR/issue-80742.rs:14:10\n    |\n LL |     [u8; size_of::<T>() + 1]: ,\n-   |          -------------- inside `Inline::<dyn Debug>::{constant#0}` at $DIR/issue-80742.rs:14:10\n+   |          ^^^^^^^^^^^^^^\n \n error[E0277]: the size for values of type `dyn Debug` cannot be known at compilation time\n   --> $DIR/issue-80742.rs:30:15"}, {"sha": "d4b486376cac822ddf8dd2dc2f7825755b1773f1", "filename": "src/test/ui/const-generics/issues/issue-100313.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-100313.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,14 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-100313.rs:10:13\n    |\n+LL |             *(B as *const bool as *mut bool) = false;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ writing to alloc7 which is read-only\n+   |\n+note: inside `T::<&true>::set_false`\n+  --> $DIR/issue-100313.rs:10:13\n+   |\n LL |             *(B as *const bool as *mut bool) = false;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |             |\n-   |             writing to alloc7 which is read-only\n-   |             inside `T::<&true>::set_false` at $DIR/issue-100313.rs:10:13\n-...\n+note: inside `_`\n+  --> $DIR/issue-100313.rs:18:5\n+   |\n LL |     x.set_false();\n-   |     ------------- inside `_` at $DIR/issue-100313.rs:18:5\n+   |     ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "563f3ffd6744f0650cab1cd129d4688a99440c0f", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,43 +2,52 @@ error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |         inside `std::slice::from_raw_parts::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:18:34\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S0`\n+  --> $DIR/forbidden_slices.rs:18:34\n    |\n LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                  ------------------------------ inside `S0` at $DIR/forbidden_slices.rs:18:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |         inside `std::slice::from_raw_parts::<'_, ()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, ()>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:19:33\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S1`\n+  --> $DIR/forbidden_slices.rs:19:33\n    |\n LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                 ------------------------------ inside `S1` at $DIR/forbidden_slices.rs:19:33\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |         inside `std::slice::from_raw_parts::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:22:34\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S2`\n+  --> $DIR/forbidden_slices.rs:22:34\n    |\n LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n-   |                                  ---------------------- inside `S2` at $DIR/forbidden_slices.rs:22:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:25:1\n@@ -89,72 +98,85 @@ error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |         inside `std::slice::from_raw_parts::<'_, u64>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n-  ::: $DIR/forbidden_slices.rs:43:5\n+note: inside `std::slice::from_raw_parts::<'_, u64>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S8`\n+  --> $DIR/forbidden_slices.rs:43:5\n    |\n LL |     from_raw_parts(ptr, 1)\n-   |     ---------------------- inside `S8` at $DIR/forbidden_slices.rs:43:5\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:46:34\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R0`\n+  --> $DIR/forbidden_slices.rs:46:34\n    |\n LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                  ---------------------------------------- inside `R0` at $DIR/forbidden_slices.rs:46:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |         inside `ptr::const_ptr::<impl *const ()>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, ()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, ()>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:47:33\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R1`\n+  --> $DIR/forbidden_slices.rs:47:33\n    |\n LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                 ---------------------------------------- inside `R1` at $DIR/forbidden_slices.rs:47:33\n-   |\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |\n+note: inside `ptr::const_ptr::<impl *const u32>::offset`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |                  inside `ptr::const_ptr::<impl *const u32>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-...\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  --------------------------- inside `ptr::const_ptr::<impl *const u32>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::add`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:50:25\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R2`\n+  --> $DIR/forbidden_slices.rs:50:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(2))\n-   |                         ---------- inside `R2` at $DIR/forbidden_slices.rs:50:25\n+   |                         ^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:52:1\n@@ -204,57 +226,68 @@ LL | pub static R7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |\n+note: inside `ptr::const_ptr::<impl *const u64>::offset`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |                  inside `ptr::const_ptr::<impl *const u64>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-...\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  --------------------------- inside `ptr::const_ptr::<impl *const u64>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u64>::add`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:74:25\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R8`\n+  --> $DIR/forbidden_slices.rs:74:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n-   |                         ---------- inside `R8` at $DIR/forbidden_slices.rs:74:25\n+   |                         ^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:79:34\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R9`\n+  --> $DIR/forbidden_slices.rs:79:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n-   |                                  ----------------------------------------------- inside `R9` at $DIR/forbidden_slices.rs:79:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:80:35\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R10`\n+  --> $DIR/forbidden_slices.rs:80:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n-   |                                   ------------------------ inside `R10` at $DIR/forbidden_slices.rs:80:35\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 18 previous errors\n "}, {"sha": "43529d57f4021aabc40869804ed85b177fece5ac", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 110, "deletions": 77, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,43 +2,52 @@ error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |         inside `std::slice::from_raw_parts::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:18:34\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S0`\n+  --> $DIR/forbidden_slices.rs:18:34\n    |\n LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                  ------------------------------ inside `S0` at $DIR/forbidden_slices.rs:18:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n-   |         inside `std::slice::from_raw_parts::<'_, ()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: null pointer is a dangling pointer (it has no provenance)\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, ()>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:19:33\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S1`\n+  --> $DIR/forbidden_slices.rs:19:33\n    |\n LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n-   |                                 ------------------------------ inside `S1` at $DIR/forbidden_slices.rs:19:33\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |         inside `std::slice::from_raw_parts::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |\n+note: inside `std::slice::from_raw_parts::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:22:34\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S2`\n+  --> $DIR/forbidden_slices.rs:22:34\n    |\n LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n-   |                                  ---------------------- inside `S2` at $DIR/forbidden_slices.rs:22:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:25:1\n@@ -89,72 +98,85 @@ error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n LL |         &*ptr::slice_from_raw_parts(data, len)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |         inside `std::slice::from_raw_parts::<'_, u64>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n    |\n-  ::: $DIR/forbidden_slices.rs:43:5\n+note: inside `std::slice::from_raw_parts::<'_, u64>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `S8`\n+  --> $DIR/forbidden_slices.rs:43:5\n    |\n LL |     from_raw_parts(ptr, 1)\n-   |     ---------------------- inside `S8` at $DIR/forbidden_slices.rs:43:5\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:46:34\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R0`\n+  --> $DIR/forbidden_slices.rs:46:34\n    |\n LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                  ---------------------------------------- inside `R0` at $DIR/forbidden_slices.rs:46:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |         inside `ptr::const_ptr::<impl *const ()>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const ()>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, ()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, ()>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:47:33\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R1`\n+  --> $DIR/forbidden_slices.rs:47:33\n    |\n LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n-   |                                 ---------------------------------------- inside `R1` at $DIR/forbidden_slices.rs:47:33\n-   |\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |\n+note: inside `ptr::const_ptr::<impl *const u32>::offset`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds pointer arithmetic: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n-   |                  inside `ptr::const_ptr::<impl *const u32>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-...\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  --------------------------- inside `ptr::const_ptr::<impl *const u32>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::add`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:50:25\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R2`\n+  --> $DIR/forbidden_slices.rs:50:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(2))\n-   |                         ---------- inside `R2` at $DIR/forbidden_slices.rs:50:25\n+   |                         ^^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/forbidden_slices.rs:52:1\n@@ -204,57 +226,68 @@ LL | pub static R7: &[u16] = unsafe {\n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |\n+note: inside `ptr::const_ptr::<impl *const u64>::offset`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n LL |         unsafe { intrinsics::offset(self, count) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  out-of-bounds pointer arithmetic: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n-   |                  inside `ptr::const_ptr::<impl *const u64>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-...\n-LL |         unsafe { self.offset(count as isize) }\n-   |                  --------------------------- inside `ptr::const_ptr::<impl *const u64>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u64>::add`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:74:25\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R8`\n+  --> $DIR/forbidden_slices.rs:74:25\n    |\n LL |     from_ptr_range(ptr..ptr.add(1))\n-   |                         ---------- inside `R8` at $DIR/forbidden_slices.rs:74:25\n+   |                         ^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:79:34\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R9`\n+  --> $DIR/forbidden_slices.rs:79:34\n    |\n LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n-   |                                  ----------------------------------------------- inside `R9` at $DIR/forbidden_slices.rs:79:34\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: could not evaluate static initializer\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                  |\n-   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n-   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n    |\n-  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+note: inside `ptr::const_ptr::<impl *const u32>::sub_ptr`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n-   |                                          ------------------------------ inside `from_ptr_range::<'_, u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `from_ptr_range::<'_, u32>`\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n    |\n-  ::: $DIR/forbidden_slices.rs:80:35\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `R10`\n+  --> $DIR/forbidden_slices.rs:80:35\n    |\n LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n-   |                                   ------------------------ inside `R10` at $DIR/forbidden_slices.rs:80:35\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 18 previous errors\n "}, {"sha": "bca29b4688136542bae551591938a27e90fa9de1", "filename": "src/test/ui/const-ptr/out_of_bounds_read.stderr", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fout_of_bounds_read.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -2,53 +2,62 @@ error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n-   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-  ::: $DIR/out_of_bounds_read.rs:12:33\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `_READ`\n+  --> $DIR/out_of_bounds_read.rs:12:33\n    |\n LL |     const _READ: u32 = unsafe { ptr::read(PAST_END_PTR) };\n-   |                                 ----------------------- inside `_READ` at $DIR/out_of_bounds_read.rs:12:33\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n-   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n    |\n-  ::: $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-LL |         unsafe { read(self) }\n-   |                  ---------- inside `ptr::const_ptr::<impl *const u32>::read` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `ptr::const_ptr::<impl *const u32>::read`\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/out_of_bounds_read.rs:13:39\n+LL |         unsafe { read(self) }\n+   |                  ^^^^^^^^^^\n+note: inside `_CONST_READ`\n+  --> $DIR/out_of_bounds_read.rs:13:39\n    |\n LL |     const _CONST_READ: u32 = unsafe { PAST_END_PTR.read() };\n-   |                                       ------------------- inside `_CONST_READ` at $DIR/out_of_bounds_read.rs:13:39\n+   |                                       ^^^^^^^^^^^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n-   |         inside `std::ptr::read::<u32>` at $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access failed: alloc5 has size 4, so pointer to 4 bytes starting at offset 4 is out-of-bounds\n+   |\n+note: inside `std::ptr::read::<u32>`\n+  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-  ::: $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n+LL |         copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: inside `ptr::mut_ptr::<impl *mut u32>::read`\n+  --> $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n    |\n LL |         unsafe { read(self) }\n-   |                  ---------- inside `ptr::mut_ptr::<impl *mut u32>::read` at $SRC_DIR/core/src/ptr/mut_ptr.rs:LL:COL\n-   |\n-  ::: $DIR/out_of_bounds_read.rs:14:37\n+   |                  ^^^^^^^^^^\n+note: inside `_MUT_READ`\n+  --> $DIR/out_of_bounds_read.rs:14:37\n    |\n LL |     const _MUT_READ: u32 = unsafe { (PAST_END_PTR as *mut u32).read() };\n-   |                                     --------------------------------- inside `_MUT_READ` at $DIR/out_of_bounds_read.rs:14:37\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "0734f479f9897b41a2190df93da3462fab41698e", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.stderr", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,26 +1,36 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/const_fn_ptr_fail2.rs:9:5\n    |\n+LL |     x(y)\n+   |     ^^^^ calling non-const function `double`\n+   |\n+note: inside `bar`\n+  --> $DIR/const_fn_ptr_fail2.rs:9:5\n+   |\n LL |     x(y)\n    |     ^^^^\n-   |     |\n-   |     calling non-const function `double`\n-   |     inside `bar` at $DIR/const_fn_ptr_fail2.rs:9:5\n-...\n+note: inside `Y`\n+  --> $DIR/const_fn_ptr_fail2.rs:14:18\n+   |\n LL | const Y: usize = bar(X, 2); // FIXME: should fail to typeck someday\n-   |                  --------- inside `Y` at $DIR/const_fn_ptr_fail2.rs:14:18\n+   |                  ^^^^^^^^^\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/const_fn_ptr_fail2.rs:9:5\n    |\n+LL |     x(y)\n+   |     ^^^^ calling non-const function `double`\n+   |\n+note: inside `bar`\n+  --> $DIR/const_fn_ptr_fail2.rs:9:5\n+   |\n LL |     x(y)\n    |     ^^^^\n-   |     |\n-   |     calling non-const function `double`\n-   |     inside `bar` at $DIR/const_fn_ptr_fail2.rs:9:5\n-...\n+note: inside `Z`\n+  --> $DIR/const_fn_ptr_fail2.rs:15:18\n+   |\n LL | const Z: usize = bar(double, 2); // FIXME: should fail to typeck someday\n-   |                  -------------- inside `Z` at $DIR/const_fn_ptr_fail2.rs:15:18\n+   |                  ^^^^^^^^^^^^^^\n \n warning: skipping const checks\n    |"}, {"sha": "846458176d6fd79fc1fb710ace41c55912adc867", "filename": "src/test/ui/consts/const-eval/const_panic_track_caller.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_track_caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_track_caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_track_caller.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,14 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/const_panic_track_caller.rs:15:5\n    |\n+LL |     b()\n+   |     ^^^ the evaluated program panicked at 'hey', $DIR/const_panic_track_caller.rs:15:5\n+   |\n+note: inside `c`\n+  --> $DIR/const_panic_track_caller.rs:15:5\n+   |\n LL |     b()\n    |     ^^^\n-   |     |\n-   |     the evaluated program panicked at 'hey', $DIR/const_panic_track_caller.rs:15:5\n-   |     inside `c` at $DIR/const_panic_track_caller.rs:15:5\n-...\n+note: inside `X`\n+  --> $DIR/const_panic_track_caller.rs:21:16\n+   |\n LL | const X: u32 = c();\n-   |                --- inside `X` at $DIR/const_panic_track_caller.rs:21:16\n+   |                ^^^\n \n error: aborting due to previous error\n "}, {"sha": "8f3b3d5f700a22c037f5519126495dd722befa7d", "filename": "src/test/ui/consts/const-eval/heap/alloc_intrinsic_errors.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_errors.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,14 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/alloc_intrinsic_errors.rs:9:17\n    |\n-LL | const FOO: i32 = foo();\n-   |                  ----- inside `FOO` at $DIR/alloc_intrinsic_errors.rs:6:18\n-...\n+LL |         let _ = intrinsics::const_allocate(4, 3) as *mut i32;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ align has to be a power of 2, `3` is not a power of 2\n+   |\n+note: inside `foo`\n+  --> $DIR/alloc_intrinsic_errors.rs:9:17\n+   |\n LL |         let _ = intrinsics::const_allocate(4, 3) as *mut i32;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                 |\n-   |                 align has to be a power of 2, `3` is not a power of 2\n-   |                 inside `foo` at $DIR/alloc_intrinsic_errors.rs:9:17\n+note: inside `FOO`\n+  --> $DIR/alloc_intrinsic_errors.rs:6:18\n+   |\n+LL | const FOO: i32 = foo();\n+   |                  ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "759ce15ab1b5d30e74961ac7077802d0f0d8317e", "filename": "src/test/ui/consts/const-eval/unwind-abort.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funwind-abort.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -1,15 +1,19 @@\n error[E0080]: evaluation of constant value failed\n   --> $DIR/unwind-abort.rs:4:5\n    |\n+LL |     panic!()\n+   |     ^^^^^^^^ the evaluated program panicked at 'explicit panic', $DIR/unwind-abort.rs:4:5\n+   |\n+note: inside `foo`\n+  --> $DIR/unwind-abort.rs:4:5\n+   |\n LL |     panic!()\n    |     ^^^^^^^^\n-   |     |\n-   |     the evaluated program panicked at 'explicit panic', $DIR/unwind-abort.rs:4:5\n-   |     inside `foo` at $SRC_DIR/std/src/panic.rs:LL:COL\n-...\n-LL | const _: () = foo();\n-   |               ----- inside `_` at $DIR/unwind-abort.rs:7:15\n+note: inside `_`\n+  --> $DIR/unwind-abort.rs:7:15\n    |\n+LL | const _: () = foo();\n+   |               ^^^^^\n    = note: this error originates in the macro `$crate::panic::panic_2015` which comes from the expansion of the macro `panic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "9710bf476ecc913b26808998c73240d9bad37f3f", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f25d8a6189afa3e99b5babb75f948e3039069fbb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=f25d8a6189afa3e99b5babb75f948e3039069fbb", "patch": "@@ -13,14 +13,19 @@ LL |     unsafe { std::mem::transmute(()) }\n error[E0080]: evaluation of constant value failed\n   --> $DIR/validate_uninhabited_zsts.rs:4:14\n    |\n+LL |     unsafe { std::mem::transmute(()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n+   |\n+note: inside `foo`\n+  --> $DIR/validate_uninhabited_zsts.rs:4:14\n+   |\n LL |     unsafe { std::mem::transmute(()) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^\n-   |              |\n-   |              transmuting to uninhabited type\n-   |              inside `foo` at $DIR/validate_uninhabited_zsts.rs:4:14\n-...\n+note: inside `FOO`\n+  --> $DIR/validate_uninhabited_zsts.rs:19:33\n+   |\n LL | const FOO: [empty::Empty; 3] = [foo(); 3];\n-   |                                 ----- inside `FOO` at $DIR/validate_uninhabited_zsts.rs:19:33\n+   |                                 ^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_uninhabited_zsts.rs:21:1"}]}