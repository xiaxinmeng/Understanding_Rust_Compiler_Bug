{"sha": "0d8d9186563637f493ac7691268319373251b18a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOGQ5MTg2NTYzNjM3ZjQ5M2FjNzY5MTI2ODMxOTM3MzI1MWIxOGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-02T20:59:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:46:13Z"}, "message": "add skeleton for macro-aware name resolutions", "tree": {"sha": "ed5c887e53ee7896c719c58cb1463ce2d57f7432", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed5c887e53ee7896c719c58cb1463ce2d57f7432"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d8d9186563637f493ac7691268319373251b18a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8d9186563637f493ac7691268319373251b18a", "html_url": "https://github.com/rust-lang/rust/commit/0d8d9186563637f493ac7691268319373251b18a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d8d9186563637f493ac7691268319373251b18a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65e763fa84ae70ec9cee13f434acaae5371ad8e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/65e763fa84ae70ec9cee13f434acaae5371ad8e5", "html_url": "https://github.com/rust-lang/rust/commit/65e763fa84ae70ec9cee13f434acaae5371ad8e5"}], "stats": {"total": 782, "additions": 773, "deletions": 9}, "files": [{"sha": "2b1001d488b18682a6b7053aa30b01e645f3deb1", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -124,6 +124,10 @@ impl CrateGraph {\n         self.arena.is_empty()\n     }\n \n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = CrateId> + 'a {\n+        self.arena.keys().map(|it| *it)\n+    }\n+\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n         self.arena[&crate_id].file_id\n     }"}, {"sha": "e805ddcba285a6722a1e93117d8fbd0fbac57cbb", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -200,8 +200,14 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationIntener<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl PersistentHirDatabase>, ast: &N) -> Self {\n         let items = ctx.db.file_items(ctx.file_id);\n-        let raw =\n-            SourceItemId { file_id: ctx.file_id, item_id: items.id_of(ctx.file_id, ast.syntax()) };\n+        let item_id = items.id_of(ctx.file_id, ast.syntax());\n+        Self::from_source_item_id_unchecked(ctx, item_id)\n+    }\n+    fn from_source_item_id_unchecked(\n+        ctx: LocationCtx<&impl PersistentHirDatabase>,\n+        item_id: SourceFileItemId,\n+    ) -> Self {\n+        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n         let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n \n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n@@ -309,9 +315,7 @@ impl SourceFileItems {\n         file_id: HirFileId,\n     ) -> Arc<SourceFileItems> {\n         let source_file = db.hir_parse(file_id);\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        res.init(&source_file);\n-        Arc::new(res)\n+        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n     }\n \n     pub(crate) fn file_item_query(\n@@ -324,18 +328,23 @@ impl SourceFileItems {\n             .to_owned()\n     }\n \n-    fn init(&mut self, source_file: &SourceFile) {\n+    pub(crate) fn from_source_file(\n+        source_file: &SourceFile,\n+        file_id: HirFileId,\n+    ) -> SourceFileItems {\n+        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n         // By walking the tree in bread-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n         // trait does not change ids of top-level items, which helps caching.\n         bfs(source_file.syntax(), |it| {\n             if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                self.alloc(module_item.syntax());\n+                res.alloc(module_item.syntax());\n             } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                self.alloc(macro_call.syntax());\n+                res.alloc(macro_call.syntax());\n             }\n-        })\n+        });\n+        res\n     }\n \n     fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {"}, {"sha": "4d0f40e857daf75e66a22c13d79533b0338bf223", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -289,6 +289,15 @@ impl LinkId {\n     }\n }\n \n+pub(crate) fn resolve_module_declaration(\n+    db: &impl PersistentHirDatabase,\n+    file_id: HirFileId,\n+    name: &Name,\n+    is_root: bool,\n+) -> Option<FileId> {\n+    resolve_submodule(db, file_id, name, is_root).0.first().map(|it| *it)\n+}\n+\n fn resolve_submodule(\n     db: &impl PersistentHirDatabase,\n     file_id: HirFileId,"}, {"sha": "06bafa6f068270756a2ae19e28e73e2d50dfd791", "filename": "crates/ra_hir/src/name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -64,6 +64,7 @@ impl Name {\n             \"str\" => KnownName::Str,\n             \"Self\" => KnownName::SelfType,\n             \"self\" => KnownName::SelfParam,\n+            \"macro_rules\" => KnownName::MacroRules,\n             _ => return None,\n         };\n         Some(name)\n@@ -122,4 +123,6 @@ pub(crate) enum KnownName {\n \n     SelfType,\n     SelfParam,\n+\n+    MacroRules,\n }"}, {"sha": "6f98ac071a70f4707f7f9c6e49b0374fd60772eb", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -15,6 +15,7 @@\n //! so that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n pub(crate) mod lower;\n+mod crate_def_map;\n \n use std::{time, sync::Arc};\n "}, {"sha": "ea9b4fb50f99cb929175358bd11ff6eba0ec2269", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -0,0 +1,204 @@\n+/// This module implements new import-resolution/macro expansion algorithm.\n+///\n+/// The result of this module is `CrateDefMap`: a datastructure which contains:\n+///\n+///   * a tree of modules for the crate\n+///   * for each module, a set of items visible in the module (directly declared\n+///     or imported)\n+///\n+/// Note that `CrateDefMap` contains fully macro expanded code.\n+///\n+/// Computing `CrateDefMap` can be partitioned into several logically\n+/// independent \"phases\". The phases are mutually recursive though, there's no\n+/// stric ordering.\n+///\n+/// ## Collecting RawItems\n+///\n+///  This happens in the `raw` module, which parses a single source file into a\n+///  set of top-level items. Nested importa are desugared to flat imports in\n+///  this phase. Macro calls are represented as a triple of (Path, Option<Name>,\n+///  TokenTree).\n+///\n+/// ## Collecting Modules\n+///\n+/// This happens in the `collector` module. In this phase, we recursively walk\n+/// tree of modules, collect raw items from submodules, populate module scopes\n+/// with defined items (so, we assign item ids in this phase) and record the set\n+/// of unresovled imports and macros.\n+///\n+/// While we walk tree of modules, we also record macro_rules defenitions and\n+/// expand calls to macro_rules defined macros.\n+///\n+/// ## Resolving Imports\n+///\n+/// TBD\n+///\n+/// ## Resolving Macros\n+///\n+/// While macro_rules from the same crate use a global mutable namespace, macros\n+/// from other crates (including proc-macros) can be used with `foo::bar!`\n+/// syntax.\n+///\n+/// TBD;\n+mod raw;\n+mod collector;\n+\n+use rustc_hash::FxHashMap;\n+use ra_arena::{Arena};\n+\n+use crate::{\n+    Name,\n+    module_tree::ModuleId,\n+    nameres::ModuleScope,\n+};\n+\n+#[derive(Default, Debug)]\n+struct ModuleData {\n+    parent: Option<ModuleId>,\n+    children: FxHashMap<Name, ModuleId>,\n+    scope: ModuleScope,\n+}\n+\n+/// Contans all top-level defs from a macro-expanded crate\n+#[derive(Debug)]\n+pub(crate) struct CrateDefMap {\n+    root: ModuleId,\n+    modules: Arena<ModuleId, ModuleData>,\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::sync::Arc;\n+\n+    use ra_db::SourceDatabase;\n+    use insta::assert_snapshot_matches;\n+\n+    use crate::{Crate, mock::MockDatabase, nameres::Resolution};\n+\n+    use super::*;\n+\n+    fn compute_crate_def_map(fixture: &str) -> Arc<CrateDefMap> {\n+        let db = MockDatabase::with_files(fixture);\n+        let crate_id = db.crate_graph().iter().next().unwrap();\n+        let krate = Crate { crate_id };\n+        collector::crate_def_map_query(&db, krate)\n+    }\n+\n+    fn render_crate_def_map(map: &CrateDefMap) -> String {\n+        let mut buf = String::new();\n+        go(&mut buf, map, \"\\ncrate\", map.root);\n+        return buf;\n+\n+        fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: ModuleId) {\n+            *buf += path;\n+            *buf += \"\\n\";\n+            for (name, res) in map.modules[module].scope.items.iter() {\n+                *buf += &format!(\"{}: {}\\n\", name, dump_resolution(res))\n+            }\n+            for (name, child) in map.modules[module].children.iter() {\n+                let path = path.to_string() + &format!(\"::{}\", name);\n+                go(buf, map, &path, *child);\n+            }\n+        }\n+\n+        fn dump_resolution(resolution: &Resolution) -> &'static str {\n+            match (resolution.def.types.is_some(), resolution.def.values.is_some()) {\n+                (true, true) => \"t v\",\n+                (true, false) => \"t\",\n+                (false, true) => \"v\",\n+                (false, false) => \"_\",\n+            }\n+        }\n+    }\n+\n+    fn def_map(fixtute: &str) -> String {\n+        let dm = compute_crate_def_map(fixtute);\n+        render_crate_def_map(&dm)\n+    }\n+\n+    #[test]\n+    fn crate_def_map_smoke_test() {\n+        let map = def_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct S;\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+            fn f() {}\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+            enum E { V }\n+        \",\n+        );\n+        assert_snapshot_matches!(\n+        map,\n+            @r###\"\n+crate\n+S: t v\n+\n+crate::foo\n+f: v\n+\n+crate::foo::bar\n+Baz: t v\n+E: t\n+\"###\n+        )\n+    }\n+\n+    #[test]\n+    fn macro_rules_are_globally_visible() {\n+        let map = def_map(\n+            \"\n+            //- /lib.rs\n+            macro_rules! structs {\n+                ($($i:ident),*) => {\n+                    $(struct $i { field: u32 } )*\n+                }\n+            }\n+            structs!(Foo);\n+            mod nested;\n+\n+            //- /nested.rs\n+            structs!(Bar, Baz);\n+        \",\n+        );\n+        assert_snapshot_matches!(map, @r###\"\n+crate\n+Foo: t v\n+\n+crate::nested\n+Bar: t v\n+Baz: t v\n+\"###);\n+    }\n+\n+    #[test]\n+    fn macro_rules_can_define_modules() {\n+        let map = def_map(\n+            \"\n+            //- /lib.rs\n+            macro_rules! m {\n+                ($name:ident) => { mod $name;  }\n+            }\n+            m!(n1);\n+\n+            //- /n1.rs\n+            m!(n2)\n+            //- /n1/n2.rs\n+            struct X;\n+        \",\n+        );\n+        assert_snapshot_matches!(map, @r###\"\n+crate\n+\n+crate::n1\n+\n+crate::n1::n2\n+X: t v\n+\"###);\n+    }\n+}"}, {"sha": "46bef3dbeb1de6a6e1e3235d6db13eac04a1a82d", "filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -0,0 +1,256 @@\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+use ra_arena::Arena;\n+\n+use crate::{\n+    Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n+    Crate, PersistentHirDatabase, HirFileId, Name, Path,\n+    KnownName,\n+    nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n+    module_tree::resolve_module_declaration,\n+};\n+\n+use super::{CrateDefMap, ModuleId, ModuleData, raw};\n+\n+#[allow(unused)]\n+pub(crate) fn crate_def_map_query(\n+    db: &impl PersistentHirDatabase,\n+    krate: Crate,\n+) -> Arc<CrateDefMap> {\n+    let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n+    let root = modules.alloc(ModuleData::default());\n+    let mut collector = DefCollector {\n+        db,\n+        krate,\n+        def_map: CrateDefMap { modules, root },\n+        unresolved_imports: Vec::new(),\n+        unexpanded_macros: Vec::new(),\n+        global_macro_scope: FxHashMap::default(),\n+    };\n+    collector.collect();\n+    let def_map = collector.finish();\n+    Arc::new(def_map)\n+}\n+\n+/// Walks the tree of module recursively\n+struct DefCollector<DB> {\n+    db: DB,\n+    krate: Crate,\n+    def_map: CrateDefMap,\n+    unresolved_imports: Vec<(ModuleId, raw::Import)>,\n+    unexpanded_macros: Vec<(ModuleId, MacroCallId, tt::Subtree)>,\n+    global_macro_scope: FxHashMap<Name, mbe::MacroRules>,\n+}\n+\n+/// Walks a single module, populating defs, imports and macros\n+struct ModCollector<'a, D> {\n+    def_collector: D,\n+    module_id: ModuleId,\n+    file_id: HirFileId,\n+    raw_items: &'a raw::RawItems,\n+}\n+\n+impl<'a, DB> DefCollector<&'a DB>\n+where\n+    DB: PersistentHirDatabase,\n+{\n+    fn collect(&mut self) {\n+        let crate_graph = self.db.crate_graph();\n+        let file_id = crate_graph.crate_root(self.krate.crate_id());\n+        let raw_items = raw::RawItems::raw_items_query(self.db, file_id);\n+        let module_id = self.def_map.root;\n+        ModCollector {\n+            def_collector: &mut *self,\n+            module_id,\n+            file_id: file_id.into(),\n+            raw_items: &raw_items,\n+        }\n+        .collect(raw_items.items());\n+\n+        // main name resolution fixed-point loop.\n+        let mut i = 0;\n+        loop {\n+            match (self.resolve_imports(), self.resolve_macros()) {\n+                (ReachedFixedPoint::Yes, ReachedFixedPoint::Yes) => break,\n+                _ => i += 1,\n+            }\n+            if i == 1000 {\n+                log::error!(\"diverging name resolution\");\n+                break;\n+            }\n+        }\n+    }\n+\n+    fn define_macro(&mut self, name: Name, tt: &tt::Subtree) {\n+        if let Ok(rules) = mbe::MacroRules::parse(tt) {\n+            self.global_macro_scope.insert(name, rules);\n+        }\n+    }\n+\n+    fn alloc_module(&mut self) -> ModuleId {\n+        self.def_map.modules.alloc(ModuleData::default())\n+    }\n+\n+    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n+        // Resolves imports, filling-in module scopes\n+        ReachedFixedPoint::Yes\n+    }\n+\n+    fn resolve_macros(&mut self) -> ReachedFixedPoint {\n+        // Resolve macros, calling into `expand_macro` to actually do the\n+        // expansion.\n+        ReachedFixedPoint::Yes\n+    }\n+\n+    #[allow(unused)]\n+    fn expand_macro(&mut self, idx: usize, rules: &mbe::MacroRules) {\n+        let (module_id, call_id, arg) = self.unexpanded_macros.swap_remove(idx);\n+        if let Ok(tt) = rules.expand(&arg) {\n+            self.collect_macro_expansion(module_id, call_id, tt);\n+        }\n+    }\n+\n+    fn collect_macro_expansion(\n+        &mut self,\n+        module_id: ModuleId,\n+        macro_call_id: MacroCallId,\n+        expansion: tt::Subtree,\n+    ) {\n+        // XXX: this **does not** go through a database, because we can't\n+        // identify macro_call without adding the whole state of name resolution\n+        // as a parameter to the query.\n+        //\n+        // So, we run the queries \"manually\" and we must ensure that\n+        // `db.hir_parse(macro_call_id)` returns the same source_file.\n+        let file_id: HirFileId = macro_call_id.into();\n+        let source_file = mbe::token_tree_to_ast_item_list(&expansion);\n+\n+        let raw_items = raw::RawItems::from_source_file(&source_file, file_id);\n+        ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n+            .collect(raw_items.items())\n+    }\n+\n+    fn finish(self) -> CrateDefMap {\n+        self.def_map\n+    }\n+}\n+\n+impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n+where\n+    DB: PersistentHirDatabase,\n+{\n+    fn collect(&mut self, items: &[raw::RawItem]) {\n+        for item in items {\n+            match *item {\n+                raw::RawItem::Module(m) => self.collect_module(&self.raw_items[m]),\n+                raw::RawItem::Import(import) => {\n+                    self.def_collector.unresolved_imports.push((self.module_id, import))\n+                }\n+                raw::RawItem::Def(def) => self.define_def(&self.raw_items[def]),\n+                raw::RawItem::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n+            }\n+        }\n+    }\n+\n+    fn collect_module(&mut self, module: &raw::ModuleData) {\n+        match module {\n+            // inline module, just recurse\n+            raw::ModuleData::Definition { name, items } => {\n+                let module_id = self.push_child_module(name.clone());\n+                ModCollector {\n+                    def_collector: &mut *self.def_collector,\n+                    module_id,\n+                    file_id: self.file_id,\n+                    raw_items: self.raw_items,\n+                }\n+                .collect(&*items);\n+            }\n+            // out of line module, resovle, parse and recurse\n+            raw::ModuleData::Declaration { name } => {\n+                let module_id = self.push_child_module(name.clone());\n+                let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n+                if let Some(file_id) =\n+                    resolve_module_declaration(self.def_collector.db, self.file_id, name, is_root)\n+                {\n+                    let raw_items = raw::RawItems::raw_items_query(self.def_collector.db, file_id);\n+                    ModCollector {\n+                        def_collector: &mut *self.def_collector,\n+                        module_id,\n+                        file_id: file_id.into(),\n+                        raw_items: &raw_items,\n+                    }\n+                    .collect(raw_items.items())\n+                }\n+            }\n+        }\n+    }\n+\n+    fn push_child_module(&mut self, name: Name) -> ModuleId {\n+        let res = self.def_collector.alloc_module();\n+        self.def_collector.def_map.modules[res].parent = Some(self.module_id);\n+        self.def_collector.def_map.modules[self.module_id].children.insert(name, res);\n+        res\n+    }\n+\n+    fn define_def(&mut self, def: &raw::DefData) {\n+        let module = Module { krate: self.def_collector.krate, module_id: self.module_id };\n+        let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n+        macro_rules! id {\n+            () => {\n+                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+            };\n+        }\n+        let name = def.name.clone();\n+        let def: PerNs<ModuleDef> = match def.kind {\n+            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n+            raw::DefKind::Struct => {\n+                let s = Struct { id: id!() }.into();\n+                PerNs::both(s, s)\n+            }\n+            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n+            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n+            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n+            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n+            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+        };\n+        let resolution = Resolution { def, import: None };\n+        self.def_collector.def_map.modules[self.module_id].scope.items.insert(name, resolution);\n+    }\n+\n+    fn collect_macro(&mut self, mac: &raw::MacroData) {\n+        // Case 1: macro rules, define a macro in crate-global mutable scope\n+        if is_macro_rules(&mac.path) {\n+            if let Some(name) = &mac.name {\n+                self.def_collector.define_macro(name.clone(), &mac.arg)\n+            }\n+            return;\n+        }\n+\n+        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n+        let macro_call_id = MacroCallLoc {\n+            module: Module { krate: self.def_collector.krate, module_id: self.module_id },\n+            source_item_id,\n+        }\n+        .id(self.def_collector.db);\n+\n+        // Case 2: try to expand macro_rules from this crate, triggering\n+        // recursive item collection.\n+        if let Some(rules) =\n+            mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n+        {\n+            if let Ok(tt) = rules.expand(&mac.arg) {\n+                self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, tt);\n+            }\n+            return;\n+        }\n+\n+        // Case 3: path to a macro from another crate, expand during name resolution\n+        self.def_collector.unexpanded_macros.push((self.module_id, macro_call_id, mac.arg.clone()))\n+    }\n+}\n+\n+fn is_macro_rules(path: &Path) -> bool {\n+    path.as_ident().and_then(Name::as_known_name) == Some(KnownName::MacroRules)\n+}"}, {"sha": "cec2484ebc1c77c58f2cb2d1d9745bb29133b107", "filename": "crates/ra_hir/src/nameres/crate_def_map/raw.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d8d9186563637f493ac7691268319373251b18a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs?ref=0d8d9186563637f493ac7691268319373251b18a", "patch": "@@ -0,0 +1,278 @@\n+use std::{\n+    sync::Arc,\n+    ops::Index,\n+};\n+\n+use ra_db::FileId;\n+use ra_arena::{Arena, impl_arena_id, RawId};\n+use ra_syntax::{\n+    AstNode, SourceFile,\n+    ast::{self, NameOwner, AttrsOwner},\n+};\n+\n+use crate::{\n+    PersistentHirDatabase, Name, AsName, Path, HirFileId,\n+    ids::{SourceFileItemId, SourceFileItems},\n+};\n+\n+#[derive(Default, PartialEq, Eq)]\n+pub(crate) struct RawItems {\n+    modules: Arena<Module, ModuleData>,\n+    imports: Arena<Import, ImportData>,\n+    defs: Arena<Def, DefData>,\n+    macros: Arena<Macro, MacroData>,\n+    /// items for top-level module\n+    items: Vec<RawItem>,\n+}\n+\n+impl RawItems {\n+    pub(crate) fn items(&self) -> &[RawItem] {\n+        &self.items\n+    }\n+\n+    pub(crate) fn raw_items_query(db: &impl PersistentHirDatabase, file_id: FileId) -> RawItems {\n+        let mut collector = RawItemsCollector {\n+            raw_items: RawItems::default(),\n+            source_file_items: db.file_items(file_id.into()),\n+        };\n+        let source_file = db.parse(file_id);\n+        collector.process_module(None, &*source_file);\n+        collector.raw_items\n+    }\n+\n+    // We can't use queries during name resolution for fear of cycles, so this\n+    // is a query-less variant of the above function.\n+    pub(crate) fn from_source_file(source_file: &SourceFile, file_id: HirFileId) -> RawItems {\n+        let source_file_items = SourceFileItems::from_source_file(source_file, file_id);\n+        let mut collector = RawItemsCollector {\n+            raw_items: RawItems::default(),\n+            source_file_items: Arc::new(source_file_items),\n+        };\n+        collector.process_module(None, &*source_file);\n+        collector.raw_items\n+    }\n+}\n+\n+impl Index<Module> for RawItems {\n+    type Output = ModuleData;\n+    fn index(&self, idx: Module) -> &ModuleData {\n+        &self.modules[idx]\n+    }\n+}\n+\n+impl Index<Import> for RawItems {\n+    type Output = ImportData;\n+    fn index(&self, idx: Import) -> &ImportData {\n+        &self.imports[idx]\n+    }\n+}\n+\n+impl Index<Def> for RawItems {\n+    type Output = DefData;\n+    fn index(&self, idx: Def) -> &DefData {\n+        &self.defs[idx]\n+    }\n+}\n+\n+impl Index<Macro> for RawItems {\n+    type Output = MacroData;\n+    fn index(&self, idx: Macro) -> &MacroData {\n+        &self.macros[idx]\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub(crate) enum RawItem {\n+    Module(Module),\n+    Import(Import),\n+    Def(Def),\n+    Macro(Macro),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Module(RawId);\n+impl_arena_id!(Module);\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) enum ModuleData {\n+    Declaration { name: Name },\n+    Definition { name: Name, items: Vec<RawItem> },\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Import(RawId);\n+impl_arena_id!(Import);\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct ImportData {\n+    path: Path,\n+    alias: Option<Name>,\n+    is_glob: bool,\n+    is_prelude: bool,\n+    is_extern_crate: bool,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Def(RawId);\n+impl_arena_id!(Def);\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct DefData {\n+    pub(crate) source_item_id: SourceFileItemId,\n+    pub(crate) name: Name,\n+    pub(crate) kind: DefKind,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub(crate) enum DefKind {\n+    Function,\n+    Struct,\n+    Enum,\n+    Const,\n+    Static,\n+    Trait,\n+    TypeAlias,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub(crate) struct Macro(RawId);\n+impl_arena_id!(Macro);\n+\n+#[derive(PartialEq, Eq)]\n+pub(crate) struct MacroData {\n+    pub(crate) source_item_id: SourceFileItemId,\n+    pub(crate) path: Path,\n+    pub(crate) name: Option<Name>,\n+    pub(crate) arg: tt::Subtree,\n+}\n+\n+struct RawItemsCollector {\n+    raw_items: RawItems,\n+    source_file_items: Arc<SourceFileItems>,\n+}\n+\n+impl RawItemsCollector {\n+    fn process_module(&mut self, current_module: Option<Module>, body: &impl ast::ModuleItemOwner) {\n+        for item_or_macro in body.items_with_macros() {\n+            match item_or_macro {\n+                ast::ItemOrMacro::Macro(m) => self.add_macro(current_module, m),\n+                ast::ItemOrMacro::Item(item) => self.add_item(current_module, item),\n+            }\n+        }\n+    }\n+\n+    fn add_item(&mut self, current_module: Option<Module>, item: &ast::ModuleItem) {\n+        let (kind, name) = match item.kind() {\n+            ast::ModuleItemKind::Module(module) => {\n+                self.add_module(current_module, module);\n+                return;\n+            }\n+            ast::ModuleItemKind::UseItem(use_item) => {\n+                self.add_use_item(current_module, use_item);\n+                return;\n+            }\n+            ast::ModuleItemKind::ExternCrateItem(extern_crate) => {\n+                self.add_extern_crate_item(current_module, extern_crate);\n+                return;\n+            }\n+            ast::ModuleItemKind::ImplBlock(_) => {\n+                // impls don't participate in name resolution\n+                return;\n+            }\n+            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n+            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n+            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n+            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n+            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n+            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n+            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+        };\n+        if let Some(name) = name {\n+            let name = name.as_name();\n+            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n+            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            self.push_item(current_module, RawItem::Def(def))\n+        }\n+    }\n+\n+    fn add_module(&mut self, current_module: Option<Module>, module: &ast::Module) {\n+        let name = match module.name() {\n+            Some(it) => it.as_name(),\n+            None => return,\n+        };\n+        if module.has_semi() {\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name });\n+            self.push_item(current_module, RawItem::Module(item));\n+            return;\n+        }\n+\n+        if let Some(item_list) = module.item_list() {\n+            let item =\n+                self.raw_items.modules.alloc(ModuleData::Definition { name, items: Vec::new() });\n+            self.process_module(Some(item), item_list);\n+            self.push_item(current_module, RawItem::Module(item));\n+        }\n+    }\n+\n+    fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {\n+        let is_prelude = use_item\n+            .attrs()\n+            .any(|attr| attr.as_atom().map(|s| s == \"prelude_import\").unwrap_or(false));\n+\n+        Path::expand_use_item(use_item, |path, segment, alias| {\n+            let import = self.raw_items.imports.alloc(ImportData {\n+                path,\n+                alias,\n+                is_glob: segment.is_none(),\n+                is_prelude,\n+                is_extern_crate: false,\n+            });\n+            self.push_item(current_module, RawItem::Import(import))\n+        })\n+    }\n+\n+    fn add_extern_crate_item(\n+        &mut self,\n+        current_module: Option<Module>,\n+        extern_crate: &ast::ExternCrateItem,\n+    ) {\n+        if let Some(name_ref) = extern_crate.name_ref() {\n+            let path = Path::from_name_ref(name_ref);\n+            let alias = extern_crate.alias().and_then(|a| a.name()).map(AsName::as_name);\n+            let import = self.raw_items.imports.alloc(ImportData {\n+                path,\n+                alias,\n+                is_glob: false,\n+                is_prelude: false,\n+                is_extern_crate: true,\n+            });\n+            self.push_item(current_module, RawItem::Import(import))\n+        }\n+    }\n+\n+    fn add_macro(&mut self, current_module: Option<Module>, m: &ast::MacroCall) {\n+        let (path, arg) = match (\n+            m.path().and_then(Path::from_ast),\n+            m.token_tree().and_then(mbe::ast_to_token_tree),\n+        ) {\n+            (Some(path), Some((token_tree, _token_map))) => (path, token_tree),\n+            _ => return,\n+        };\n+\n+        let name = m.name().map(|it| it.as_name());\n+        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, arg, name });\n+        self.push_item(current_module, RawItem::Macro(m));\n+    }\n+\n+    fn push_item(&mut self, current_module: Option<Module>, item: RawItem) {\n+        match current_module {\n+            Some(module) => match &mut self.raw_items.modules[module] {\n+                ModuleData::Definition { items, .. } => items,\n+                ModuleData::Declaration { .. } => unreachable!(),\n+            },\n+            None => &mut self.raw_items.items,\n+        }\n+        .push(item)\n+    }\n+}"}]}