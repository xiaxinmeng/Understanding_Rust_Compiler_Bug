{"sha": "9857eaa4dfc1a103369b423b12cac1993a8d9e96", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NTdlYWE0ZGZjMWExMDMzNjliNDIzYjEyY2FjMTk5M2E4ZDllOTY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-25T15:44:45Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:10Z"}, "message": "Nuke ConstInt and Const*size", "tree": {"sha": "8dce236499fc6728f2b07e1a4c0c73bc0bdaaa29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dce236499fc6728f2b07e1a4c0c73bc0bdaaa29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9857eaa4dfc1a103369b423b12cac1993a8d9e96", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53IACgkQpp+NIls6\n19lu1w//Vq7ahdlRbdCpkxVEzRQyL8kwavd8AmVSHZL07TSqVmT/j2czTKihMSWQ\nvMS3/k7G1bkoMSN8S1dK8+VIxSZeDVlOn2sKWygiAQ1VU4jXyqrSblXHWSPVbi1X\n4RYPtuq3SnHAqFSMKbULzfrq82nXOgPIjJcYJSJVvwYvjvkWtQ5OZxltaPb4ZEAi\nGBtoCl6QziMyrc8myOtJT+b5VB2phgZajDFp3AeaYcnaAryUtaUGAG6jMgdDDZF2\n4R59rC7RSCumkU3BxiieDU9o2+BpOgirnV5zlc4G5gQtEN4PRJEOarcutMkZ452S\n262eWysIA0fU1lRTirsRFhd/hejAd1M904Us00KkyWC9fasavl9xnZj7Ka3LtKkW\nDpZU8Jk7ecojNJWlUo1g88QMbL4W7vxAXeidRaJioBQNVlcMy4TXPm7Txgck8ZD6\nK7lO278q//zCc3IJBM5o8XEHDD/V9n4XJ1rOXkLp4ISQBgPJJHQ99IQkE8O/of4y\nJ0NTEKtw0X39SivZdfyx+mlY+NGMSJ0LVN7TTGA65pVNNdUxJJyblV/+kriE1qAO\nCQYBW51T2pbXe1x+qCjhuEUB/To9kj9qmNJe7nmHTVlDTxgY0ckwmLxFkqtKGU6K\nx84VbNTI1xZFymob8134qK8Msl9v9k23pxjHUzqvoG/ovka/QP8=\n=tjkc\n-----END PGP SIGNATURE-----", "payload": "tree 8dce236499fc6728f2b07e1a4c0c73bc0bdaaa29\nparent 3b8d2e0016884fdc56e3e2208235606d999990a8\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516895085 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494450 +0100\n\nNuke ConstInt and Const*size\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9857eaa4dfc1a103369b423b12cac1993a8d9e96", "html_url": "https://github.com/rust-lang/rust/commit/9857eaa4dfc1a103369b423b12cac1993a8d9e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9857eaa4dfc1a103369b423b12cac1993a8d9e96/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8d2e0016884fdc56e3e2208235606d999990a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8d2e0016884fdc56e3e2208235606d999990a8", "html_url": "https://github.com/rust-lang/rust/commit/3b8d2e0016884fdc56e3e2208235606d999990a8"}], "stats": {"total": 1260, "additions": 159, "deletions": 1101}, "files": [{"sha": "5f3ff461c0c7ec5a28309a77c093c019c9e6bc5f", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -16,33 +16,6 @@ impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n     bits\n });\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {\n-    I8(val),\n-    I16(val),\n-    I32(val),\n-    I64(val),\n-    I128(val),\n-    Isize(val),\n-    U8(val),\n-    U16(val),\n-    U32(val),\n-    U64(val),\n-    U128(val),\n-    Usize(val)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstIsize {\n-    Is16(i16),\n-    Is32(i32),\n-    Is64(i64)\n-});\n-\n-impl_stable_hash_for!(enum ::rustc_const_math::ConstUsize {\n-    Us16(i16),\n-    Us32(i32),\n-    Us64(i64)\n-});\n-\n impl_stable_hash_for!(enum ::rustc_const_math::ConstMathErr {\n     NotInRange,\n     CmpBetweenUnequalTypes,"}, {"sha": "06d4540a455e8ff4b95cc3ae42260e0bef00d2d8", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use rustc_const_math::ConstInt;\n-\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, layout};\n use ty::subst::Substs;\n@@ -56,18 +54,6 @@ impl<'tcx> ConstVal<'tcx> {\n             None => bug!(\"expected constant u64, got {:#?}\", self),\n         }\n     }\n-    pub fn unwrap_usize<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> ConstUsize {\n-        match *self {\n-            ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n-                assert_eq!(b as u64 as u128, b);\n-                match ConstUsize::new(b as u64, tcx.sess.target.usize_ty) {\n-                    Ok(val) => val,\n-                    Err(e) => bug!(\"{:#?} is not a usize {:?}\", self, e),\n-                }\n-            },\n-            _ => bug!(\"expected constant u64, got {:#?}\", self),\n-        }\n-    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "e39765699f9be01dd05b48a289b74ddde9819f72", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -15,7 +15,7 @@\n use graphviz::IntoCow;\n use middle::const_val::ConstVal;\n use middle::region;\n-use rustc_const_math::{ConstUsize, ConstMathErr};\n+use rustc_const_math::ConstMathErr;\n use rustc_data_structures::sync::{Lrc};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n@@ -1563,7 +1563,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, ConstUsize),\n+    Repeat(Operand<'tcx>, u64),\n \n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),"}, {"sha": "7d232ac20bfd52a0f55495b08f9fa7a0174f841b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> Rvalue<'tcx> {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Repeat(ref operand, count) => {\n-                tcx.mk_array_const_usize(operand.ty(local_decls, tcx), count)\n+                tcx.mk_array(operand.ty(local_decls, tcx), count)\n             }\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "650af8dc4d903fa41ab133d94ef5b40bad093ebc", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -12,7 +12,6 @@ use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty, GeneratorInterior};\n use mir::*;\n-use rustc_const_math::ConstUsize;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -243,12 +242,6 @@ macro_rules! make_mir_visitor {\n                 self.super_generator_interior(interior);\n             }\n \n-            fn visit_const_usize(&mut self,\n-                                 const_usize: & $($mutability)* ConstUsize,\n-                                 _: Location) {\n-                self.super_const_usize(const_usize);\n-            }\n-\n             fn visit_local_decl(&mut self,\n                                 local: Local,\n                                 local_decl: & $($mutability)* LocalDecl<'tcx>) {\n@@ -529,10 +522,8 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(operand, location);\n                     }\n \n-                    Rvalue::Repeat(ref $($mutability)* value,\n-                                   ref $($mutability)* length) => {\n+                    Rvalue::Repeat(ref $($mutability)* value, _) => {\n                         self.visit_operand(value, location);\n-                        self.visit_const_usize(length, location);\n                     }\n \n                     Rvalue::Ref(ref $($mutability)* r, bk, ref $($mutability)* path) => {\n@@ -789,9 +780,6 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_usize(&mut self, _const_usize: & $($mutability)* ConstUsize) {\n-            }\n-\n             // Convenience methods\n \n             fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {"}, {"sha": "8c508c2f17c81350a31c17388dc1a81f2d52e92c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -54,7 +54,6 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, DroplessArena};\n-use rustc_const_math::ConstUsize;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n@@ -2096,13 +2095,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        let n = ConstUsize::new(n, self.sess.target.usize_ty).unwrap();\n-        self.mk_array_const_usize(ty, n)\n-    }\n-\n-    pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n-            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.as_u64().into()))),\n+            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.into()))),\n             ty: self.types.usize\n         })))\n     }"}, {"sha": "b02f221bb8132cc2eec52ba9927754e420c7fe6f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -1537,7 +1537,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     if variants[i].iter().any(|f| f.abi == Abi::Uninhabited) {\n                         continue;\n                     }\n-                    let x = discr.to_u128_unchecked() as i128;\n+                    let x = discr.val as i128;\n                     if x < min { min = x; }\n                     if x > max { max = x; }\n                 }"}, {"sha": "cb09687a6573cc3e48238dd2985c8988c44da7f4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -32,7 +32,7 @@ use session::CrateDisambiguator;\n use traits;\n use ty;\n use ty::subst::{Subst, Substs};\n-use ty::util::IntTypeExt;\n+use ty::util::{IntTypeExt, Discr};\n use ty::walk::TypeWalker;\n use util::common::ErrorReported;\n use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n@@ -53,7 +53,6 @@ use syntax::attr;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n-use rustc_const_math::ConstInt;\n \n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n@@ -1826,13 +1825,13 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn discriminants(&'a self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                         -> impl Iterator<Item=ConstInt> + 'a {\n+                         -> impl Iterator<Item=Discr<'tcx>> + 'a {\n         let param_env = ParamEnv::empty(traits::Reveal::UserFacing);\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n-        let mut prev_discr = None::<ConstInt>;\n+        let mut prev_discr = None::<Discr<'tcx>>;\n         self.variants.iter().map(move |v| {\n-            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+            let mut discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 let instance = ty::Instance::new(expr_did, substs);\n@@ -1846,12 +1845,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                         ..\n                     }) => {\n                         trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                        use syntax::attr::IntType;\n-                        discr = match repr_type {\n-                            IntType::SignedInt(int_type) => ConstInt::new_signed(\n-                                b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n-                            IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n-                                b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                        discr = Discr {\n+                            val: b,\n+                            ty: repr_type.to_ty(tcx),\n                         };\n                     }\n                     _ => {\n@@ -1877,7 +1873,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn discriminant_for_variant(&self,\n                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                     variant_index: usize)\n-                                    -> ConstInt {\n+                                    -> Discr<'tcx> {\n         let param_env = ParamEnv::empty(traits::Reveal::UserFacing);\n         let repr_type = self.repr.discr_type();\n         let mut explicit_value = repr_type.initial_discriminant(tcx.global_tcx());\n@@ -1901,12 +1897,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                             ..\n                         }) => {\n                             trace!(\"discriminants: {} ({:?})\", b, repr_type);\n-                            use syntax::attr::IntType;\n-                            explicit_value = match repr_type {\n-                                IntType::SignedInt(int_type) => ConstInt::new_signed(\n-                                    b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n-                                IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n-                                    b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                            explicit_value = Discr {\n+                                val: b,\n+                                ty: repr_type.to_ty(tcx),\n                             };\n                             break;\n                         }\n@@ -1925,18 +1918,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n         }\n-        let discr = explicit_value.to_u128_unchecked()\n-            .wrapping_add((variant_index - explicit_index) as u128);\n-        match repr_type {\n-            attr::UnsignedInt(ty) => {\n-                ConstInt::new_unsigned_truncating(discr, ty,\n-                                                  tcx.sess.target.usize_ty)\n-            }\n-            attr::SignedInt(ty) => {\n-                ConstInt::new_signed_truncating(discr as i128, ty,\n-                                                tcx.sess.target.isize_ty)\n-            }\n-        }\n+        explicit_value.checked_add(tcx, (variant_index - explicit_index) as u128).0\n     }\n \n     pub fn destructor(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Destructor> {"}, {"sha": "e65a3b620c3889bbd8ea5cdf5b8855a72fd543f7", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 90, "deletions": 68, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -26,57 +26,95 @@ use util::common::ErrorReported;\n use middle::lang_items;\n use mir::interpret::{Value, PrimVal};\n \n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n                                            HashStable};\n use rustc_data_structures::fx::FxHashMap;\n-use std::cmp;\n+use std::{cmp, fmt};\n use std::hash::Hash;\n use std::intrinsics;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, UintTy, IntTy};\n use syntax::attr::{self, SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n-type Disr = ConstInt;\n-\n-pub trait IntTypeExt {\n-    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr>;\n-    fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+#[derive(Copy, Clone, Debug)]\n+pub struct Discr<'tcx> {\n+    pub val: u128,\n+    pub ty: Ty<'tcx>\n }\n \n+impl<'tcx> fmt::Display for Discr<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        if self.ty.is_signed() {\n+            write!(fmt, \"{}\", self.val as i128)\n+        } else {\n+            write!(fmt, \"{}\", self.val)\n+        }\n+    }\n+}\n \n-macro_rules! typed_literal {\n-    ($tcx:expr, $ty:expr, $lit:expr) => {\n-        match $ty {\n-            SignedInt(ast::IntTy::I8)    => ConstInt::I8($lit),\n-            SignedInt(ast::IntTy::I16)   => ConstInt::I16($lit),\n-            SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n-            SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n-            SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n-            SignedInt(ast::IntTy::Isize) => match $tcx.sess.target.isize_ty {\n-                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n-                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n-                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n-                _ => bug!(),\n-            },\n-            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8($lit),\n-            UnsignedInt(ast::UintTy::U16) => ConstInt::U16($lit),\n-            UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n-            UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n-            UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n-            UnsignedInt(ast::UintTy::Usize) => match $tcx.sess.target.usize_ty {\n-                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n-                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n-                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n-                _ => bug!(),\n-            },\n+impl<'tcx> Discr<'tcx> {\n+    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n+    pub fn wrap_incr<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        self.checked_add(tcx, 1).0\n+    }\n+    pub fn checked_add<'a, 'gcx>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, n: u128) -> (Self, bool) {\n+        let ty = match self.ty.sty {\n+            TyInt(IntTy::Isize) => tcx.mk_mach_int(tcx.sess.target.isize_ty),\n+            TyUint(UintTy::Usize) => tcx.mk_mach_uint(tcx.sess.target.usize_ty),\n+            _ => self.ty,\n+        };\n+        let (min, max) = match ty.sty {\n+            TyInt(IntTy::I8)  => (i8::min_value() as i128 as u128, i8::max_value() as u128),\n+            TyInt(IntTy::I16) => (i16::min_value() as i128 as u128, i16::max_value() as u128),\n+            TyInt(IntTy::I32) => (i32::min_value() as i128 as u128, i32::max_value() as u128),\n+            TyInt(IntTy::I64) => (i64::min_value() as i128 as u128, i64::max_value() as u128),\n+            TyInt(IntTy::I128) => (i128::min_value() as i128 as u128, i128::max_value() as u128),\n+            TyInt(IntTy::Isize) => unreachable!(),\n+            TyUint(UintTy::U8)  => (u8::min_value() as u128, u8::max_value() as u128),\n+            TyUint(UintTy::U16) => (u16::min_value() as u128, u16::max_value() as u128),\n+            TyUint(UintTy::U32) => (u32::min_value() as u128, u32::max_value() as u128),\n+            TyUint(UintTy::U64) => (u64::min_value() as u128, u64::max_value() as u128),\n+            TyUint(UintTy::U128) => (u128::min_value() as u128, u128::max_value()),\n+            TyUint(UintTy::Usize) => unreachable!(),\n+            _ => bug!(\"not a valid discriminant type: {}\", ty)\n+        };\n+        if ty.is_signed() {\n+            let val = self.val as i128;\n+            let n = n as i128;\n+            let max = max as i128;\n+            let min = min as i128;\n+            let oflo = val > max - n;\n+            let val = if oflo {\n+                min + (n - (max - val))\n+            } else {\n+                val + n\n+            };\n+            (Self {\n+                val: val as u128,\n+                ty: self.ty,\n+            }, oflo)\n+        } else {\n+            let oflo = self.val > max - n;\n+            let val = if oflo {\n+                min + (n - (max - self.val))\n+            } else {\n+                self.val + n\n+            };\n+            (Self {\n+                val,\n+                ty: self.ty,\n+            }, oflo)\n         }\n     }\n }\n \n+pub trait IntTypeExt {\n+    fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Discr<'tcx>>)\n+                           -> Option<Discr<'tcx>>;\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx>;\n+}\n+\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n@@ -95,33 +133,26 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        typed_literal!(tcx, *self, 0)\n-    }\n-\n-    fn assert_ty_matches(&self, val: Disr) {\n-        match (*self, val) {\n-            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n-            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n-            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n-            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n-            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n-            (SignedInt(ast::IntTy::Isize), ConstInt::Isize(_)) => {},\n-            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n-            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n-            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n-            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n-            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n-            (UnsignedInt(ast::UintTy::Usize), ConstInt::Usize(_)) => {},\n-            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Discr<'tcx> {\n+        Discr {\n+            val: 0,\n+            ty: self.to_ty(tcx)\n         }\n     }\n \n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr> {\n+    fn disr_incr<'a, 'tcx>(\n+        &self,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        val: Option<Discr<'tcx>>,\n+    ) -> Option<Discr<'tcx>> {\n         if let Some(val) = val {\n-            self.assert_ty_matches(val);\n-            (val + typed_literal!(tcx, *self, 1)).ok()\n+            assert_eq!(self.to_ty(tcx), val.ty);\n+            let (new, oflo) = val.checked_add(tcx, 1);\n+            if oflo {\n+                None\n+            } else {\n+                Some(new)\n+            }\n         } else {\n             Some(self.initial_discriminant(tcx))\n         }\n@@ -682,15 +713,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn const_usize(&self, val: u16) -> ConstInt {\n-        match self.sess.target.usize_ty {\n-            ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(val as u16)),\n-            ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(val as u32)),\n-            ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(val as u64)),\n-            _ => bug!(),\n-        }\n-    }\n-\n     /// Return whether the node pointed to by def_id is a static item, and its mutability\n     pub fn is_static(&self, def_id: DefId) -> Option<hir::Mutability> {\n         if let Some(node) = self.hir.get_if_local(def_id) {"}, {"sha": "4ec27d7ade560ce620f5560d429a134cff929e52", "filename": "src/librustc_const_math/int.rs", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=3b8d2e0016884fdc56e3e2208235606d999990a8", "patch": "@@ -1,590 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cmp::Ordering;\n-use syntax::attr::IntType;\n-use syntax::ast::{IntTy, UintTy};\n-\n-use super::isize::*;\n-use super::usize::*;\n-use super::err::*;\n-\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstInt {\n-    I8(i8),\n-    I16(i16),\n-    I32(i32),\n-    I64(i64),\n-    I128(i128),\n-    Isize(ConstIsize),\n-    U8(u8),\n-    U16(u16),\n-    U32(u32),\n-    U64(u64),\n-    U128(u128),\n-    Usize(ConstUsize),\n-}\n-pub use self::ConstInt::*;\n-\n-\n-macro_rules! bounds {\n-    ($ct: ty, $($t:ident $min:ident $max:ident)*) => {\n-        $(\n-            pub const $min: $ct = $t::min_value() as $ct;\n-            pub const $max: $ct = $t::max_value() as $ct;\n-        )*\n-    };\n-    ($ct: ty: $min_val: expr, $($t:ident $min:ident $max:ident)*) => {\n-        $(\n-            pub const $min: $ct = $min_val;\n-            pub const $max: $ct = $t::max_value() as $ct;\n-        )*\n-    }\n-}\n-\n-mod ubounds {\n-    #![allow(dead_code)]\n-    bounds!{u128: 0,\n-        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n-        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n-        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n-        // arbitrary host/target combinations\n-    }\n-}\n-\n-mod ibounds {\n-    #![allow(dead_code)]\n-    bounds!(i128, u64 U64MIN U64MAX);\n-\n-    pub const U128MIN: i128 = 0;\n-    pub const U128MAX: i128 = i128::max_value();\n-\n-    bounds!{i128,\n-        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n-        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n-        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n-        // arbitrary host/target combinations\n-    }\n-}\n-\n-impl ConstInt {\n-    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n-    /// not happen.\n-    pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n-        match ty {\n-            UintTy::U8 if val <= ubounds::U8MAX => Some(U8(val as u8)),\n-            UintTy::U16 if val <= ubounds::U16MAX => Some(U16(val as u16)),\n-            UintTy::U32 if val <= ubounds::U32MAX => Some(U32(val as u32)),\n-            UintTy::U64 if val <= ubounds::U64MAX => Some(U64(val as u64)),\n-            UintTy::Usize if val <= ubounds::U64MAX => ConstUsize::new(val as u64, usize_ty).ok()\n-                .map(Usize),\n-            UintTy::U128 => Some(U128(val)),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new signed ConstInt with matching type while also checking that overflow does\n-    /// not happen.\n-    pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n-        match ty {\n-            IntTy::I8 if val <= ibounds::I8MAX => Some(I8(val as i8)),\n-            IntTy::I16 if val <= ibounds::I16MAX => Some(I16(val as i16)),\n-            IntTy::I32 if val <= ibounds::I32MAX => Some(I32(val as i32)),\n-            IntTy::I64 if val <= ibounds::I64MAX => Some(I64(val as i64)),\n-            IntTy::Isize if val <= ibounds::I64MAX => ConstIsize::new(val as i64, isize_ty).ok()\n-                .map(Isize),\n-            IntTy::I128 => Some(I128(val)),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new unsigned ConstInt with matching type.\n-    pub fn new_unsigned_truncating(val: u128, ty: UintTy, usize_ty: UintTy) -> ConstInt {\n-        match ty {\n-            UintTy::U8 => U8(val as u8),\n-            UintTy::U16 => U16(val as u16),\n-            UintTy::U32 => U32(val as u32),\n-            UintTy::U64 => U64(val as u64),\n-            UintTy::Usize => Usize(ConstUsize::new_truncating(val, usize_ty)),\n-            UintTy::U128 => U128(val)\n-        }\n-    }\n-\n-    /// Creates a new signed ConstInt with matching type.\n-    pub fn new_signed_truncating(val: i128, ty: IntTy, isize_ty: IntTy) -> ConstInt {\n-        match ty {\n-            IntTy::I8 => I8(val as i8),\n-            IntTy::I16 => I16(val as i16),\n-            IntTy::I32 => I32(val as i32),\n-            IntTy::I64 => I64(val as i64),\n-            IntTy::Isize => Isize(ConstIsize::new_truncating(val, isize_ty)),\n-            IntTy::I128 => I128(val)\n-        }\n-    }\n-\n-    /// Description of the type, not the value\n-    pub fn description(&self) -> &'static str {\n-        match *self {\n-            I8(_) => \"i8\",\n-            I16(_) => \"i16\",\n-            I32(_) => \"i32\",\n-            I64(_) => \"i64\",\n-            I128(_) => \"i128\",\n-            Isize(_) => \"isize\",\n-            U8(_) => \"u8\",\n-            U16(_) => \"u16\",\n-            U32(_) => \"u32\",\n-            U64(_) => \"u64\",\n-            U128(_) => \"u128\",\n-            Usize(_) => \"usize\",\n-        }\n-    }\n-\n-    /// Erases the type and returns a u128.\n-    /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n-    pub fn to_u128_unchecked(self) -> u128 {\n-        match self {\n-            I8(i) => i as i128 as u128,\n-            I16(i) => i as i128 as u128,\n-            I32(i) => i as i128 as u128,\n-            I64(i) => i as i128 as u128,\n-            I128(i) => i as i128 as u128,\n-            Isize(Is16(i)) => i as i128 as u128,\n-            Isize(Is32(i)) => i as i128 as u128,\n-            Isize(Is64(i)) => i as i128 as u128,\n-            U8(i) => i as u128,\n-            U16(i) => i as u128,\n-            U32(i) => i as u128,\n-            U64(i) => i as u128,\n-            U128(i) => i as u128,\n-            Usize(Us16(i)) => i as u128,\n-            Usize(Us32(i)) => i as u128,\n-            Usize(Us64(i)) => i as u128,\n-        }\n-    }\n-\n-    /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n-    pub fn to_u32(&self) -> Option<u32> {\n-        self.to_u128().and_then(|v| if v <= u32::max_value() as u128 {\n-            Some(v as u32)\n-        } else {\n-            None\n-        })\n-    }\n-\n-    /// Converts the value to a `u64` if it's in the range 0...std::u64::MAX\n-    pub fn to_u64(&self) -> Option<u64> {\n-        self.to_u128().and_then(|v| if v <= u64::max_value() as u128 {\n-            Some(v as u64)\n-        } else {\n-            None\n-        })\n-    }\n-\n-    /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n-    pub fn to_u128(&self) -> Option<u128> {\n-        match *self {\n-            I8(v) if v >= 0 => Some(v as u128),\n-            I16(v) if v >= 0 => Some(v as u128),\n-            I32(v) if v >= 0 => Some(v as u128),\n-            I64(v) if v >= 0 => Some(v as u128),\n-            I128(v) if v >= 0 => Some(v as u128),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u128),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u128),\n-            Isize(Is64(v)) if v >= 0 => Some(v as u128),\n-            U8(v) => Some(v as u128),\n-            U16(v) => Some(v as u128),\n-            U32(v) => Some(v as u128),\n-            U64(v) => Some(v as u128),\n-            U128(v) => Some(v as u128),\n-            Usize(Us16(v)) => Some(v as u128),\n-            Usize(Us32(v)) => Some(v as u128),\n-            Usize(Us64(v)) => Some(v as u128),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn is_negative(&self) -> bool {\n-        match *self {\n-            I8(v) => v < 0,\n-            I16(v) => v < 0,\n-            I32(v) => v < 0,\n-            I64(v) => v < 0,\n-            I128(v) => v < 0,\n-            Isize(Is16(v)) => v < 0,\n-            Isize(Is32(v)) => v < 0,\n-            Isize(Is64(v)) => v < 0,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Compares the values if they are of the same type\n-    pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n-        match (self, rhs) {\n-            (I8(a), I8(b)) => Ok(a.cmp(&b)),\n-            (I16(a), I16(b)) => Ok(a.cmp(&b)),\n-            (I32(a), I32(b)) => Ok(a.cmp(&b)),\n-            (I64(a), I64(b)) => Ok(a.cmp(&b)),\n-            (I128(a), I128(b)) => Ok(a.cmp(&b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(a.cmp(&b)),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n-            (U8(a), U8(b)) => Ok(a.cmp(&b)),\n-            (U16(a), U16(b)) => Ok(a.cmp(&b)),\n-            (U32(a), U32(b)) => Ok(a.cmp(&b)),\n-            (U64(a), U64(b)) => Ok(a.cmp(&b)),\n-            (U128(a), U128(b)) => Ok(a.cmp(&b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n-            _ => Err(CmpBetweenUnequalTypes),\n-        }\n-    }\n-\n-    /// Adds 1 to the value and wraps around if the maximum for the type is reached\n-    pub fn wrap_incr(self) -> Self {\n-        macro_rules! add1 {\n-            ($e:expr) => { ($e).wrapping_add(1) }\n-        }\n-        match self {\n-            ConstInt::I8(i) => ConstInt::I8(add1!(i)),\n-            ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n-            ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n-            ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n-            ConstInt::I128(i) => ConstInt::I128(add1!(i)),\n-            ConstInt::Isize(ConstIsize::Is16(i)) => ConstInt::Isize(ConstIsize::Is16(add1!(i))),\n-            ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n-            ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n-            ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n-            ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n-            ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n-            ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n-            ConstInt::U128(i) => ConstInt::U128(add1!(i)),\n-            ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n-            ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n-            ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n-        }\n-    }\n-\n-    pub fn int_type(self) -> IntType {\n-        match self {\n-            ConstInt::I8(_) => IntType::SignedInt(IntTy::I8),\n-            ConstInt::I16(_) => IntType::SignedInt(IntTy::I16),\n-            ConstInt::I32(_) => IntType::SignedInt(IntTy::I32),\n-            ConstInt::I64(_) => IntType::SignedInt(IntTy::I64),\n-            ConstInt::I128(_) => IntType::SignedInt(IntTy::I128),\n-            ConstInt::Isize(_) => IntType::SignedInt(IntTy::Isize),\n-            ConstInt::U8(_) => IntType::UnsignedInt(UintTy::U8),\n-            ConstInt::U16(_) => IntType::UnsignedInt(UintTy::U16),\n-            ConstInt::U32(_) => IntType::UnsignedInt(UintTy::U32),\n-            ConstInt::U64(_) => IntType::UnsignedInt(UintTy::U64),\n-            ConstInt::U128(_) => IntType::UnsignedInt(UintTy::U128),\n-            ConstInt::Usize(_) => IntType::UnsignedInt(UintTy::Usize),\n-        }\n-    }\n-}\n-\n-impl ::std::cmp::PartialOrd for ConstInt {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        self.try_cmp(*other).ok()\n-    }\n-}\n-\n-impl ::std::cmp::Ord for ConstInt {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        self.try_cmp(*other).unwrap()\n-    }\n-}\n-\n-impl ::std::fmt::Display for ConstInt {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match *self {\n-            I8(i) => write!(fmt, \"{}i8\", i),\n-            I16(i) => write!(fmt, \"{}i16\", i),\n-            I32(i) => write!(fmt, \"{}i32\", i),\n-            I64(i) => write!(fmt, \"{}i64\", i),\n-            I128(i) => write!(fmt, \"{}i128\", i),\n-            Isize(i) => write!(fmt, \"{}isize\", i),\n-            U8(i) => write!(fmt, \"{}u8\", i),\n-            U16(i) => write!(fmt, \"{}u16\", i),\n-            U32(i) => write!(fmt, \"{}u32\", i),\n-            U64(i) => write!(fmt, \"{}u64\", i),\n-            U128(i) => write!(fmt, \"{}u128\", i),\n-            Usize(i) => write!(fmt, \"{}usize\", i),\n-        }\n-    }\n-}\n-\n-macro_rules! overflowing {\n-    ($e:expr, $err:expr) => {{\n-        if $e.1 {\n-            return Err(Overflow($err));\n-        } else {\n-            $e.0\n-        }\n-    }}\n-}\n-\n-macro_rules! impl_binop {\n-    ($op:ident, $func:ident, $checked_func:ident) => {\n-        impl ::std::ops::$op for ConstInt {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n-                    (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n-                    (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n-                    (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n-                    (I128(a), I128(b)) => a.$checked_func(b).map(I128),\n-                    (Isize(Is16(a)), Isize(Is16(b))) => a.$checked_func(b).map(Is16).map(Isize),\n-                    (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n-                    (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n-                    (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n-                    (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n-                    (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n-                    (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n-                    (U128(a), U128(b)) => a.$checked_func(b).map(U128),\n-                    (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n-                    (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n-                    (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n-                    _ => return Err(UnequalTypes(Op::$op)),\n-                }.ok_or(Overflow(Op::$op))\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! derive_binop {\n-    ($op:ident, $func:ident) => {\n-        impl ::std::ops::$op for ConstInt {\n-            type Output = Result<Self, ConstMathErr>;\n-            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n-                    (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n-                    (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n-                    (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n-                    (I128(a), I128(b)) => Ok(I128(a.$func(b))),\n-                    (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a.$func(b)))),\n-                    (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n-                    (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n-                    (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n-                    (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n-                    (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n-                    (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n-                    (U128(a), U128(b)) => Ok(U128(a.$func(b))),\n-                    (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n-                    (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n-                    (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n-                    _ => Err(UnequalTypes(Op::$op)),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_binop!(Add, add, checked_add);\n-impl_binop!(Sub, sub, checked_sub);\n-impl_binop!(Mul, mul, checked_mul);\n-derive_binop!(BitAnd, bitand);\n-derive_binop!(BitOr, bitor);\n-derive_binop!(BitXor, bitxor);\n-\n-const I128_MIN: i128 = ::std::i128::MIN;\n-\n-fn check_division(\n-    lhs: ConstInt,\n-    rhs: ConstInt,\n-    op: Op,\n-    zerr: ConstMathErr,\n-) -> Result<(), ConstMathErr> {\n-    match (lhs, rhs) {\n-        (I8(_), I8(0)) => Err(zerr),\n-        (I16(_), I16(0)) => Err(zerr),\n-        (I32(_), I32(0)) => Err(zerr),\n-        (I64(_), I64(0)) => Err(zerr),\n-        (I128(_), I128(0)) => Err(zerr),\n-        (Isize(_), Isize(Is16(0))) => Err(zerr),\n-        (Isize(_), Isize(Is32(0))) => Err(zerr),\n-        (Isize(_), Isize(Is64(0))) => Err(zerr),\n-\n-        (U8(_), U8(0)) => Err(zerr),\n-        (U16(_), U16(0)) => Err(zerr),\n-        (U32(_), U32(0)) => Err(zerr),\n-        (U64(_), U64(0)) => Err(zerr),\n-        (U128(_), U128(0)) => Err(zerr),\n-        (Usize(_), Usize(Us16(0))) => Err(zerr),\n-        (Usize(_), Usize(Us32(0))) => Err(zerr),\n-        (Usize(_), Usize(Us64(0))) => Err(zerr),\n-\n-        (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n-        (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n-        (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n-        (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n-        (I128(I128_MIN), I128(-1)) => Err(Overflow(op)),\n-        (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n-        (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n-        (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-\n-        _ => Ok(()),\n-    }\n-}\n-\n-impl ::std::ops::Div for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = (self, rhs);\n-        check_division(lhs, rhs, Op::Div, DivisionByZero)?;\n-        match (lhs, rhs) {\n-            (I8(a), I8(b)) => Ok(I8(a/b)),\n-            (I16(a), I16(b)) => Ok(I16(a/b)),\n-            (I32(a), I32(b)) => Ok(I32(a/b)),\n-            (I64(a), I64(b)) => Ok(I64(a/b)),\n-            (I128(a), I128(b)) => Ok(I128(a/b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n-\n-            (U8(a), U8(b)) => Ok(U8(a/b)),\n-            (U16(a), U16(b)) => Ok(U16(a/b)),\n-            (U32(a), U32(b)) => Ok(U32(a/b)),\n-            (U64(a), U64(b)) => Ok(U64(a/b)),\n-            (U128(a), U128(b)) => Ok(U128(a/b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n-\n-            _ => Err(UnequalTypes(Op::Div)),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Rem for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = (self, rhs);\n-        // should INT_MIN%-1 be zero or an error?\n-        check_division(lhs, rhs, Op::Rem, RemainderByZero)?;\n-        match (lhs, rhs) {\n-            (I8(a), I8(b)) => Ok(I8(a%b)),\n-            (I16(a), I16(b)) => Ok(I16(a%b)),\n-            (I32(a), I32(b)) => Ok(I32(a%b)),\n-            (I64(a), I64(b)) => Ok(I64(a%b)),\n-            (I128(a), I128(b)) => Ok(I128(a%b)),\n-            (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n-            (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n-            (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n-\n-            (U8(a), U8(b)) => Ok(U8(a%b)),\n-            (U16(a), U16(b)) => Ok(U16(a%b)),\n-            (U32(a), U32(b)) => Ok(U32(a%b)),\n-            (U64(a), U64(b)) => Ok(U64(a%b)),\n-            (U128(a), U128(b)) => Ok(U128(a%b)),\n-            (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n-            (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n-            (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n-\n-            _ => Err(UnequalTypes(Op::Rem)),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Shl<ConstInt> for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn shl(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            U128(a) => Ok(U128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Shr<ConstInt> for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn shr(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let b = rhs.to_u32().ok_or(ShiftNegative)?;\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            U128(a) => Ok(U128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Neg for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn neg(self) -> Result<Self, ConstMathErr> {\n-        match self {\n-            I8(a) => Ok(I8(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            I128(a) => Ok(I128(overflowing!(a.overflowing_neg(), Op::Neg))),\n-            Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n-            a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n-            U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n-        }\n-    }\n-}\n-\n-impl ::std::ops::Not for ConstInt {\n-    type Output = Result<Self, ConstMathErr>;\n-    fn not(self) -> Result<Self, ConstMathErr> {\n-        match self {\n-            I8(a) => Ok(I8(!a)),\n-            I16(a) => Ok(I16(!a)),\n-            I32(a) => Ok(I32(!a)),\n-            I64(a) => Ok(I64(!a)),\n-            I128(a) => Ok(I128(!a)),\n-            Isize(Is16(a)) => Ok(Isize(Is16(!a))),\n-            Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n-            Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n-            U8(a) => Ok(U8(!a)),\n-            U16(a) => Ok(U16(!a)),\n-            U32(a) => Ok(U32(!a)),\n-            U64(a) => Ok(U64(!a)),\n-            U128(a) => Ok(U128(!a)),\n-            Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n-            Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n-            Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n-        }\n-    }\n-}"}, {"sha": "18acc782775d8adb2b2c6c0f6755782ae5282548", "filename": "src/librustc_const_math/isize.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fisize.rs?ref=3b8d2e0016884fdc56e3e2208235606d999990a8", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use super::err::*;\n-\n-/// Depending on the target only one variant is ever used in a compilation.\n-/// Anything else is an error. This invariant is checked at several locations\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstIsize {\n-    Is16(i16),\n-    Is32(i32),\n-    Is64(i64),\n-}\n-pub use self::ConstIsize::*;\n-\n-impl ::std::fmt::Display for ConstIsize {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{}\", self.as_i64())\n-    }\n-}\n-\n-impl ConstIsize {\n-    pub fn as_i64(self) -> i64 {\n-        match self {\n-            Is16(i) => i as i64,\n-            Is32(i) => i as i64,\n-            Is64(i) => i,\n-        }\n-    }\n-    pub fn new(i: i64, isize_ty: ast::IntTy) -> Result<Self, ConstMathErr> {\n-        match isize_ty {\n-            ast::IntTy::I16 if i as i16 as i64 == i => Ok(Is16(i as i16)),\n-            ast::IntTy::I16 => Err(LitOutOfRange(ast::IntTy::Isize)),\n-            ast::IntTy::I32 if i as i32 as i64 == i => Ok(Is32(i as i32)),\n-            ast::IntTy::I32 => Err(LitOutOfRange(ast::IntTy::Isize)),\n-            ast::IntTy::I64 => Ok(Is64(i)),\n-            _ => unreachable!(),\n-        }\n-    }\n-    pub fn new_truncating(i: i128, isize_ty: ast::IntTy) -> Self {\n-        match isize_ty {\n-            ast::IntTy::I16 => Is16(i as i16),\n-            ast::IntTy::I32 => Is32(i as i32),\n-            ast::IntTy::I64 => Is64(i as i64),\n-            _ => unreachable!(),\n-        }\n-    }\n-}"}, {"sha": "5555e727a955233be677bd64abeee2afe863d9ba", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -29,13 +29,7 @@ extern crate syntax;\n extern crate serialize as rustc_serialize; // used by deriving\n \n mod float;\n-mod int;\n-mod usize;\n-mod isize;\n mod err;\n \n pub use float::*;\n-pub use int::*;\n-pub use usize::*;\n-pub use isize::*;\n pub use err::{ConstMathErr, Op};"}, {"sha": "56995f08f05b855d9c339baffbb8d9a8a6cb1c5e", "filename": "src/librustc_const_math/usize.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b8d2e0016884fdc56e3e2208235606d999990a8/src%2Flibrustc_const_math%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fusize.rs?ref=3b8d2e0016884fdc56e3e2208235606d999990a8", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::ast;\n-use super::err::*;\n-\n-/// Depending on the target only one variant is ever used in a compilation.\n-/// Anything else is an error. This invariant is checked at several locations\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, Hash, Eq, PartialEq)]\n-pub enum ConstUsize {\n-    Us16(u16),\n-    Us32(u32),\n-    Us64(u64),\n-}\n-pub use self::ConstUsize::*;\n-\n-impl ::std::fmt::Display for ConstUsize {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        write!(fmt, \"{}\", self.as_u64())\n-    }\n-}\n-\n-impl ConstUsize {\n-    pub fn as_u64(self) -> u64 {\n-        match self {\n-            Us16(i) => i as u64,\n-            Us32(i) => i as u64,\n-            Us64(i) => i,\n-        }\n-    }\n-    pub fn new(i: u64, usize_ty: ast::UintTy) -> Result<Self, ConstMathErr> {\n-        match usize_ty {\n-            ast::UintTy::U16 if i as u16 as u64 == i => Ok(Us16(i as u16)),\n-            ast::UintTy::U16 => Err(ULitOutOfRange(ast::UintTy::Usize)),\n-            ast::UintTy::U32 if i as u32 as u64 == i => Ok(Us32(i as u32)),\n-            ast::UintTy::U32 => Err(ULitOutOfRange(ast::UintTy::Usize)),\n-            ast::UintTy::U64 => Ok(Us64(i)),\n-            _ => unreachable!(),\n-        }\n-    }\n-    pub fn new_truncating(i: u128, usize_ty: ast::UintTy) -> Self {\n-        match usize_ty {\n-            ast::UintTy::U16 => Us16(i as u16),\n-            ast::UintTy::U32 => Us32(i as u32),\n-            ast::UintTy::U64 => Us64(i as u64),\n-            _ => unreachable!(),\n-        }\n-    }\n-}"}, {"sha": "059fd9111b689f0aada1c4a48f285e19861bb1b6", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -1316,7 +1316,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n \n-            Rvalue::Repeat(operand, const_usize) => if const_usize.as_u64() > 1 {\n+            Rvalue::Repeat(operand, len) => if *len > 1 {\n                 let operand_ty = operand.ty(mir, tcx);\n \n                 let trait_ref = ty::TraitRef {"}, {"sha": "e2cc58b1fb050c78ee910364d2e586306329243e", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -10,16 +10,13 @@\n \n //! See docs in build/expr/mod.rs\n \n-use std;\n-\n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n-use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n use rustc::ty::{self, Ty};\n@@ -385,31 +382,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let literal = match ty.sty {\n-            ty::TyInt(ity) => {\n-                let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(-1),\n-                    ast::IntTy::I16 => ConstInt::I16(-1),\n-                    ast::IntTy::I32 => ConstInt::I32(-1),\n-                    ast::IntTy::I64 => ConstInt::I64(-1),\n-                    ast::IntTy::I128 => ConstInt::I128(-1),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let val = ConstIsize::new(-1, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.to_u128_unchecked()))),\n-                        ty\n-                    })\n-                }\n-            }\n-            _ => {\n-                span_bug!(span, \"Invalid type for neg_1_literal: `{:?}`\", ty)\n-            }\n+        let literal = Literal::Value {\n+            value: self.hir.tcx().mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(-1i128 as u128))),\n+                ty\n+            })\n         };\n \n         self.literal_operand(span, ty, literal)\n@@ -419,30 +396,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = match ty.sty {\n             ty::TyInt(ity) => {\n+                let ity = match ity {\n+                    ast::IntTy::Isize => self.hir.tcx().sess.target.isize_ty,\n+                    other => other,\n+                };\n                 let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(i8::min_value()),\n-                    ast::IntTy::I16 => ConstInt::I16(i16::min_value()),\n-                    ast::IntTy::I32 => ConstInt::I32(i32::min_value()),\n-                    ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n-                    ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let min = match int_ty {\n-                            ast::IntTy::I16 => std::i16::MIN as i64,\n-                            ast::IntTy::I32 => std::i32::MIN as i64,\n-                            ast::IntTy::I64 => std::i64::MIN,\n-                            _ => unreachable!()\n-                        };\n-                        let val = ConstIsize::new(min, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n+                    ast::IntTy::I8  => i8::min_value() as i128,\n+                    ast::IntTy::I16 => i16::min_value() as i128,\n+                    ast::IntTy::I32 => i32::min_value() as i128,\n+                    ast::IntTy::I64 => i64::min_value() as i128,\n+                    ast::IntTy::I128 => i128::min_value() as i128,\n+                    ast::IntTy::Isize => unreachable!(),\n                 };\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(\n-                            val.to_u128_unchecked()\n-                        ))),\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val as u128))),\n                         ty\n                     })\n                 }"}, {"sha": "09579eaecb2dee8160e538f922e0f6fc2bb2c0e9", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n                     target_blocks.place_back() <- if variants.contains(idx) {\n-                        values.push(discr.to_u128_unchecked());\n+                        values.push(discr.val);\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n                         if otherwise_block.is_none() {"}, {"sha": "0b8a96332b0f4f19cab6dde65bc84a2eb52cb6f0", "filename": "src/librustc_mir/const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         ).unwrap();\n                         let variant_index = adt_def\n                             .discriminants(self.tcx)\n-                            .position(|var| var.to_u128_unchecked() == discr)\n+                            .position(|var| var.val == discr)\n                             .unwrap();\n                         PatternKind::Variant {\n                             adt_def,"}, {"sha": "6b5a5c5984216763471ca5d8db218f5742cc094e", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -523,10 +523,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 promoted: None\n             };\n             let count = match cx.tcx.at(c.span).const_eval(cx.param_env.and(global_id)) {\n-                Ok(cv) => cv.val.unwrap_usize(cx.tcx),\n+                Ok(cv) => cv.val.unwrap_u64(),\n                 Err(e) => {\n                     e.report(cx.tcx, cx.tcx.def_span(def_id), \"array length\");\n-                    ConstUsize::new(0, cx.tcx.sess.target.usize_ty).unwrap()\n+                    0\n                 },\n             };\n "}, {"sha": "0b59ce9e117b8cde6c1f4e5ea40a3346371ae6e2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n-use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc_const_math::ConstFloat;\n use rustc_data_structures::sync::Lrc;\n use rustc::mir::interpret::{Value, PrimVal};\n \n@@ -115,16 +115,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn usize_literal(&mut self, value: u64) -> Literal<'tcx> {\n-        match ConstUsize::new(value, self.tcx.sess.target.usize_ty) {\n-            Ok(val) => {\n-                Literal::Value {\n-                    value: self.tcx.mk_const(ty::Const {\n-                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.as_u64() as u128))),\n-                        ty: self.tcx.types.usize\n-                    })\n-                }\n-            }\n-            Err(_) => bug!(\"usize literal out of range for target\"),\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value as u128))),\n+                ty: self.tcx.types.usize\n+            })\n         }\n     }\n "}, {"sha": "a7cfa94f6961d8bfe6753ff98c79ec9d725a73e8", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -14,7 +14,6 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc_const_math::ConstUsize;\n use rustc::mir::{BinOp, BorrowKind, Field, Literal, UnOp};\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n@@ -246,7 +245,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Repeat {\n         value: ExprRef<'tcx>,\n-        count: ConstUsize,\n+        count: u64,\n     },\n     Array {\n         fields: Vec<ExprRef<'tcx>>,"}, {"sha": "08152019003f15e6f09d37df617f2257dedb20f1", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -760,7 +760,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n                     trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(self.tcx).collect::<Vec<_>>());\n                     if adt_def.discriminants(self.tcx).all(|v| {\n-                        discr_val != v.to_u128_unchecked()\n+                        discr_val != v.val\n                     })\n                     {\n                         return err!(InvalidDiscriminant);\n@@ -916,7 +916,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             layout::Variants::Tagged { .. } => {\n                 let discr_val = dest_ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(self.tcx, variant_index)\n-                    .to_u128_unchecked();\n+                    .val;\n \n                 let (discr_dest, discr) = self.place_field(dest, mir::Field::new(0), layout)?;\n                 self.write_primval(discr_dest, PrimVal::Bytes(discr_val), discr.ty)?;"}, {"sha": "9aff7fa2a2c7197ebda90676db98a0cce551ad4e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -16,7 +16,6 @@ use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n-use rustc_const_math::ConstUsize;\n use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -508,13 +507,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: {\n-                        let value = ConstUsize::new(\n-                            value,\n-                            self.tcx.sess.target.usize_ty,\n-                        ).unwrap().as_u64();\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into())))\n-                    },\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into()))),\n                     ty: self.tcx.types.usize,\n                 })\n             }"}, {"sha": "458dd488409e4101cd9872867028871f16cc5b00", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -426,7 +426,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                     variant_path,\n                     &adt.variants[variant_index],\n                     substs);\n-                values.push(discr.to_u128().unwrap());\n+                values.push(discr.val);\n                 if let Unwind::To(unwind) = unwind {\n                     // We can't use the half-ladder from the original\n                     // drop ladder, because this breaks the"}, {"sha": "4a4ce63cc1d4e7f6c81dfcefdcc2dcd36b604a08", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -12,7 +12,6 @@\n // pieces of MIR. The resulting numbers are good approximations but not\n // completely accurate (some things might be counted twice, others missed).\n \n-use rustc_const_math::{ConstUsize};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, Local, LocalDecl};\n use rustc::mir::{Place, PlaceElem, PlaceProjection};\n@@ -265,13 +264,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.super_const(constant);\n     }\n \n-    fn visit_const_usize(&mut self,\n-                         const_usize: &ConstUsize,\n-                         _: Location) {\n-        self.record(\"ConstUsize\", const_usize);\n-        self.super_const_usize(const_usize);\n-    }\n-\n     fn visit_local_decl(&mut self,\n                         local: Local,\n                         local_decl: &LocalDecl<'tcx>) {"}, {"sha": "bae9fe8bd1b0da271f0f19795f56f7d4f4d6760f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -334,14 +334,6 @@ pub fn cast_shift_expr_rhs(\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    cast_shift_rhs(op,\n-                   lhs,\n-                   rhs,\n-                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n-                   |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n-}\n-\n fn cast_shift_rhs<F, G>(op: hir::BinOp_,\n                         lhs: ValueRef,\n                         rhs: ValueRef,"}, {"sha": "d20b51ca0fdf4fd3606ceb58b7d0d7efa1590254", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -1378,7 +1378,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    discr.to_u128_unchecked() as u64)\n+                    discr.val as u64)\n             }\n         })\n         .collect();"}, {"sha": "954abf4c5d7039e4046b09529fc540d81d998063", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 108, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -9,132 +9,25 @@\n // except according to those terms.\n \n use llvm::{self, ValueRef};\n-use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::middle::const_val::{ConstVal, ConstEvalErr};\n use rustc_mir::interpret::{read_target_uint, const_val_field};\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::mir::interpret::{Allocation, GlobalId, MemoryPointer, PrimVal, Value as MiriValue};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Scalar};\n-use base;\n use builder::Builder;\n use common::{CodegenCx};\n use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n-use common::const_to_opt_u128;\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n \n use super::super::callee;\n use super::FunctionCx;\n \n-fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n-    match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_u128(value, true)\n-            .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n-                                                   tcx.sess.target.isize_ty)),\n-        ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n-            .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n-                                                     tcx.sess.target.usize_ty)),\n-        _ => None\n-\n-    }\n-}\n-\n-pub fn const_scalar_binop(op: mir::BinOp,\n-                          lhs: ValueRef,\n-                          rhs: ValueRef,\n-                          input_ty: Ty) -> ValueRef {\n-    assert!(!input_ty.is_simd());\n-    let is_float = input_ty.is_fp();\n-    let signed = input_ty.is_signed();\n-\n-    unsafe {\n-        match op {\n-            mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n-            mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n-\n-            mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n-            mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n-\n-            mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n-            mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n-\n-            mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n-            mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n-            mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n-\n-            mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n-            mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n-            mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n-\n-            mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n-            mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n-            mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n-            mir::BinOp::Shl    => {\n-                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                llvm::LLVMConstShl(lhs, rhs)\n-            }\n-            mir::BinOp::Shr    => {\n-                let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n-                if signed { llvm::LLVMConstAShr(lhs, rhs) }\n-                else      { llvm::LLVMConstLShr(lhs, rhs) }\n-            }\n-            mir::BinOp::Eq | mir::BinOp::Ne |\n-            mir::BinOp::Lt | mir::BinOp::Le |\n-            mir::BinOp::Gt | mir::BinOp::Ge => {\n-                if is_float {\n-                    let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n-                    llvm::LLVMConstFCmp(cmp, lhs, rhs)\n-                } else {\n-                    let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n-                                                                signed);\n-                    llvm::LLVMConstICmp(cmp, lhs, rhs)\n-                }\n-            }\n-            mir::BinOp::Offset => unreachable!(\"BinOp::Offset in const-eval!\")\n-        }\n-    }\n-}\n-\n-pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                            op: mir::BinOp,\n-                                            lllhs: ValueRef,\n-                                            llrhs: ValueRef,\n-                                            input_ty: Ty<'tcx>)\n-                                            -> Option<(ValueRef, bool)> {\n-    if let (Some(lhs), Some(rhs)) = (to_const_int(lllhs, input_ty, tcx),\n-                                     to_const_int(llrhs, input_ty, tcx)) {\n-        let result = match op {\n-            mir::BinOp::Add => lhs + rhs,\n-            mir::BinOp::Sub => lhs - rhs,\n-            mir::BinOp::Mul => lhs * rhs,\n-            mir::BinOp::Shl => lhs << rhs,\n-            mir::BinOp::Shr => lhs >> rhs,\n-            _ => {\n-                bug!(\"Operator `{:?}` is not a checkable operator\", op)\n-            }\n-        };\n-\n-        let of = match result {\n-            Ok(_) => false,\n-            Err(ConstMathErr::Overflow(_)) |\n-            Err(ConstMathErr::ShiftNegative) => true,\n-            Err(err) => {\n-                bug!(\"Operator `{:?}` on `{:?}` and `{:?}` errored: {}\",\n-                     op, lhs, rhs, err.description());\n-            }\n-        };\n-\n-        Some((const_scalar_binop(op, lllhs, llrhs, input_ty), of))\n-    } else {\n-        None\n-    }\n-}\n-\n pub fn primval_to_llvm(cx: &CodegenCx,\n                        cv: PrimVal,\n                        scalar: &Scalar,"}, {"sha": "b340d91b02708edf0eed3de96b9ff70c8cfb8cfd", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -328,7 +328,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 let ptr = self.project_field(bx, 0);\n                 let to = self.layout.ty.ty_adt_def().unwrap()\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n-                    .to_u128_unchecked() as u64;\n+                    .val as u64;\n                 bx.store(C_int(ptr.layout.llvm_type(bx.cx), to as i64),\n                     ptr.llval, ptr.align);\n             }"}, {"sha": "fa0514952d21373761aaedae3770c94a8f5cafe9", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -30,7 +30,6 @@ use type_of::LayoutLlvmExt;\n use value::Value;\n \n use super::{FunctionCx, LocalRef};\n-use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n \n@@ -122,7 +121,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     }\n                 }\n \n-                let count = count.as_u64();\n                 let count = C_usize(bx.cx, count);\n                 let end = dest.project_index(&bx, count).llval;\n \n@@ -645,14 +643,6 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n             return OperandValue::Pair(val, C_bool(bx.cx, false));\n         }\n \n-        // First try performing the operation on constants, which\n-        // will only succeed if both operands are constant.\n-        // This is necessary to determine when an overflow Assert\n-        // will always panic at runtime, and produce a warning.\n-        if let Some((val, of)) = const_scalar_checked_binop(bx.tcx(), op, lhs, rhs, input_ty) {\n-            return OperandValue::Pair(val, C_bool(bx.cx, of));\n-        }\n-\n         let (val, of) = match op {\n             // These are checked using intrinsics\n             mir::BinOp::Add | mir::BinOp::Sub | mir::BinOp::Mul => {"}, {"sha": "4e1fd987d90dae047edba813c88ba9bc0d1906b0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -100,7 +100,8 @@ use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n-use rustc::ty::util::{Representability, IntTypeExt};\n+use rustc::ty::util::{Representability, IntTypeExt, Discr};\n+use rustc::ty::layout::LayoutOf;\n use errors::{DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n@@ -133,7 +134,6 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Node;\n use rustc::hir::{self, PatKind};\n use rustc::middle::lang_items;\n-use rustc_const_math::ConstInt;\n \n mod autoderef;\n pub mod dropck;\n@@ -1632,10 +1632,10 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let mut disr_vals: Vec<ConstInt> = Vec::new();\n+    let mut disr_vals: Vec<Discr<'tcx>> = Vec::new();\n     for (discr, v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x == discr) {\n+        if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_i_node_id = tcx.hir.as_local_node_id(def.variants[i].did).unwrap();\n             let variant_i = tcx.hir.expect_variant(variant_i_node_id);\n             let i_span = match variant_i.node.disr_expr {"}, {"sha": "b040bd014e30fb9adc063a601f11d4b8df83a7af", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -39,8 +39,7 @@ use rustc::ty::maps::Providers;\n use rustc::ty::util::IntTypeExt;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n-\n-use rustc_const_math::ConstInt;\n+use rustc::ty::util::Discr;\n \n use syntax::{abi, ast};\n use syntax::ast::MetaItemKind;\n@@ -516,11 +515,11 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n-    let mut prev_discr = None::<ConstInt>;\n+    let mut prev_discr = None::<Discr<'tcx>>;\n \n     // fill the discriminant values and field types\n     for variant in variants {\n-        let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr());\n+        let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n             let substs = Substs::identity_for_item(tcx, expr_did);\n@@ -535,19 +534,17 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // so we need to report the real error\n             if let Err(ref err) = result {\n                 err.report(tcx, variant.span, \"enum discriminant\");\n-}\n+            }\n \n             match result {\n+                // FIXME: just use `to_raw_bits` here?\n                 Ok(&ty::Const {\n                     val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n                     ..\n                 }) => {\n-                    use syntax::attr::IntType;\n-                    Some(match repr_type {\n-                        IntType::SignedInt(int_type) => ConstInt::new_signed(\n-                            b as i128, int_type, tcx.sess.target.isize_ty).unwrap(),\n-                        IntType::UnsignedInt(uint_type) => ConstInt::new_unsigned(\n-                            b, uint_type, tcx.sess.target.usize_ty).unwrap(),\n+                    Some(Discr {\n+                        val: b,\n+                        ty: initial.ty,\n                     })\n                 }\n                 _ => None"}, {"sha": "bc295941147467eabe3e199ed6ce55916abe517f", "filename": "src/test/compile-fail/issue-27592.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27592.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -26,4 +26,5 @@ fn main() {\n     write(|| format_args!(\"{}\", String::from(\"Hello world\")));\n     //~^ ERROR borrowed value does not live long enough\n     //~| ERROR borrowed value does not live long enough\n+    //~| ERROR borrowed value does not live long enough\n }"}, {"sha": "7e696c97595aad27cee4a6b1f5eebb38a9497f96", "filename": "src/test/ui/issue-15524.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Ftest%2Fui%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9857eaa4dfc1a103369b423b12cac1993a8d9e96/src%2Ftest%2Fui%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-15524.rs?ref=9857eaa4dfc1a103369b423b12cac1993a8d9e96", "patch": "@@ -13,13 +13,13 @@ const N: isize = 1;\n enum Foo {\n     A = 1,\n     B = 1,\n-    //~^ ERROR discriminant value `1isize` already exists\n+    //~^ ERROR discriminant value `1` already exists\n     C = 0,\n     D,\n-    //~^ ERROR discriminant value `1isize` already exists\n+    //~^ ERROR discriminant value `1` already exists\n \n     E = N,\n-    //~^ ERROR discriminant value `1isize` already exists\n+    //~^ ERROR discriminant value `1` already exists\n \n }\n "}]}