{"sha": "3b50455c61847c4a417b5fb002a5258dbaf4a868", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiNTA0NTVjNjE4NDdjNGE0MTdiNWZiMDAyYTUyNThkYmFmNGE4Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T04:09:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-29T04:09:02Z"}, "message": "Auto merge of #50357 - seanmonstar:arc-weak-null, r=KodrAus\n\nArc: remove unused allocation from Weak::new()\n\nIt seems non-obvious that calling `Weak::new()` actually allocates space for the entire size of `T`, even though you can **never** access that data from such a constructed weak pointer. Besides that, if someone were to create many `Weak:new()`s, they could be unknowingly wasting a bunch of memory.\n\nThis change makes it so that `Weak::new()` allocates no memory at all. Instead, it is created with a null pointer. The only things done with a `Weak` are trying to upgrade, cloning, and dropping, meaning there are very few places that the code actually needs to check if the pointer is null.", "tree": {"sha": "38bb73d53a70ba02f37d41a922644f61cf735936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38bb73d53a70ba02f37d41a922644f61cf735936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b50455c61847c4a417b5fb002a5258dbaf4a868", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b50455c61847c4a417b5fb002a5258dbaf4a868", "html_url": "https://github.com/rust-lang/rust/commit/3b50455c61847c4a417b5fb002a5258dbaf4a868", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b50455c61847c4a417b5fb002a5258dbaf4a868/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "775ce974979dc180c127bf0fb4ad9cab382d16ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/775ce974979dc180c127bf0fb4ad9cab382d16ef", "html_url": "https://github.com/rust-lang/rust/commit/775ce974979dc180c127bf0fb4ad9cab382d16ef"}, {"sha": "24ce2597823640726aa302a12a4de787a1fe1f05", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ce2597823640726aa302a12a4de787a1fe1f05", "html_url": "https://github.com/rust-lang/rust/commit/24ce2597823640726aa302a12a4de787a1fe1f05"}], "stats": {"total": 56, "additions": 36, "deletions": 20}, "files": [{"sha": "2abd9c85c5754f140beb33dcd8ac148969375215", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3b50455c61847c4a417b5fb002a5258dbaf4a868/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b50455c61847c4a417b5fb002a5258dbaf4a868/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=3b50455c61847c4a417b5fb002a5258dbaf4a868", "patch": "@@ -23,7 +23,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n@@ -43,6 +43,9 @@ use vec::Vec;\n /// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n+/// A sentinel value that is used for the pointer of `Weak::new()`.\n+const WEAK_EMPTY: usize = 1;\n+\n /// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n /// Reference Counted'.\n ///\n@@ -235,6 +238,10 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is actually not truly \"non-null\". A `Weak::new()` will set this\n+    // to a sentinel value, instead of needing to allocate some space in the\n+    // heap.\n     ptr: NonNull<ArcInner<T>>,\n }\n \n@@ -1011,8 +1018,8 @@ impl Arc<Any + Send + Sync> {\n }\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1029,11 +1036,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                ptr: Box::into_raw_non_null(box ArcInner {\n-                    strong: atomic::AtomicUsize::new(0),\n-                    weak: atomic::AtomicUsize::new(1),\n-                    data: uninitialized(),\n-                }),\n+                ptr: NonNull::new_unchecked(WEAK_EMPTY as *mut _),\n             }\n         }\n     }\n@@ -1070,7 +1073,11 @@ impl<T: ?Sized> Weak<T> {\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n         // We use a CAS loop to increment the strong count instead of a\n         // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = self.inner();\n+        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n+            return None;\n+        } else {\n+            unsafe { self.ptr.as_ref() }\n+        };\n \n         // Relaxed load because any write of 0 that we can observe\n         // leaves the field in a permanently zero state (so a\n@@ -1092,17 +1099,15 @@ impl<T: ?Sized> Weak<T> {\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n-                Ok(_) => return Some(Arc { ptr: self.ptr, phantom: PhantomData }),\n+                Ok(_) => return Some(Arc {\n+                    // null checked above\n+                    ptr: self.ptr,\n+                    phantom: PhantomData,\n+                }),\n                 Err(old) => n = old,\n             }\n         }\n     }\n-\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // See comments above for why this is \"safe\"\n-        unsafe { self.ptr.as_ref() }\n-    }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -1120,11 +1125,16 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n+        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n+            return Weak { ptr: self.ptr };\n+        } else {\n+            unsafe { self.ptr.as_ref() }\n+        };\n         // See comments in Arc::clone() for why this is relaxed.  This can use a\n         // fetch_add (ignoring the lock) because the weak count is only locked\n         // where are *no other* weak pointers in existence. (So we can't be\n         // running this code in that case).\n-        let old_size = self.inner().weak.fetch_add(1, Relaxed);\n+        let old_size = inner.weak.fetch_add(1, Relaxed);\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n@@ -1139,8 +1149,8 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1193,7 +1203,13 @@ impl<T: ?Sized> Drop for Weak<T> {\n         // weak count can only be locked if there was precisely one weak ref,\n         // meaning that drop could only subsequently run ON that remaining weak\n         // ref, which can only happen after the lock is released.\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+        let inner = if self.ptr.as_ptr() as *const u8 as usize == WEAK_EMPTY {\n+            return;\n+        } else {\n+            unsafe { self.ptr.as_ref() }\n+        };\n+\n+        if inner.weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n                 Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))"}]}