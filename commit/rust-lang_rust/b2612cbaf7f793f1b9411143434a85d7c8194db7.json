{"sha": "b2612cbaf7f793f1b9411143434a85d7c8194db7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjEyY2JhZjdmNzkzZjFiOTQxMTE0MzQzNGE4NWQ3YzgxOTRkYjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T15:15:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-28T10:49:02Z"}, "message": "don't tag new memory inside memory.rs; add machine hook to tag new memory", "tree": {"sha": "bbf09030e3fdccb81acfe6ae83941f01c69ca937", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbf09030e3fdccb81acfe6ae83941f01c69ca937"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2612cbaf7f793f1b9411143434a85d7c8194db7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2612cbaf7f793f1b9411143434a85d7c8194db7", "html_url": "https://github.com/rust-lang/rust/commit/b2612cbaf7f793f1b9411143434a85d7c8194db7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2612cbaf7f793f1b9411143434a85d7c8194db7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff3b29fc54b9eb430040d80f164f347746508997", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff3b29fc54b9eb430040d80f164f347746508997", "html_url": "https://github.com/rust-lang/rust/commit/ff3b29fc54b9eb430040d80f164f347746508997"}], "stats": {"total": 68, "additions": 44, "deletions": 24}, "files": [{"sha": "f951674ab7396f0a29aef52d7285d66d0598238f", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -32,7 +32,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value, Scalar, ConstValue,\n+    PlaceTy, MemPlace, OpTy, Operand, Value, Scalar, ConstValue, Pointer,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -426,7 +426,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     #[inline(always)]\n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Self::PointerTag>> {\n         // We do not use a tag so we can just cheaply forward the reference\n@@ -465,6 +465,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n             &ecx.stack[..],\n         )\n     }\n+\n+    #[inline(always)]\n+    fn tag_new_allocation(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        _kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer> {\n+        Ok(ptr)\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "b2c8cba480259d6bf4a83c940a425b69c487c039", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                        let fn_ptr = self.memory.create_fn_alloc(instance?).with_default_tag();\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     ref other => bug!(\"reify fn pointer on {:?}\", other),\n@@ -143,7 +143,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance);\n+                        let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                         let val = Value::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_value(val, dest)?;\n                     }"}, {"sha": "bc7ad16dc97bc7b59caee2cd1b65736c9652f362", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -334,7 +334,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n-        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n+        let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n "}, {"sha": "7811dcb0663d5249d4d48bf088b43d5b2ea6ada0", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -81,6 +81,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Tag tracked alongside every pointer.  This is used to implement \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n+    /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n \n     /// Extra data stored in every allocation.\n@@ -151,13 +152,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n     /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the appropriate tags on each pointer.\n+    /// the right type for this machine.\n     ///\n     /// This should avoid copying if no work has to be done! If this returns an owned\n-    /// allocation (because a copy had to be done to add the tags), machine memory will\n+    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n@@ -204,6 +205,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n+    /// Add the tag for a newly allocated pointer.\n+    fn tag_new_allocation(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer<Self::PointerTag>>;\n+\n     /// Executed when evaluating the `&` operator: Creating a new reference.\n     /// This has the chance to adjust the tag.  It should not change anything else!\n     /// `mutability` can be `None` in case a raw ptr is being created."}, {"sha": "982463740974a95b0a9e298364e07b53c53410d1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -117,12 +117,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance)).with_default_tag()\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n+        Pointer::from(self.tcx.alloc_map.lock().create_fn_alloc(instance))\n     }\n \n-    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer<M::PointerTag> {\n-        Pointer::from(self.tcx.allocate_bytes(bytes)).with_default_tag()\n+    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n+        Pointer::from(self.tcx.allocate_bytes(bytes))\n     }\n \n     pub fn allocate_with(\n@@ -140,9 +140,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n-        let ptr = Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?);\n-        Ok(ptr.with_default_tag())\n+    ) -> EvalResult<'tcx, Pointer> {\n+        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?))\n     }\n \n     pub fn reallocate(\n@@ -153,17 +152,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, Pointer> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n \n-        // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n+        // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n+        // FIXME: Do something more efficient.\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n         self.copy(\n             ptr.into(),\n             old_align,\n-            new_ptr.into(),\n+            new_ptr.with_default_tag().into(),\n             new_align,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n@@ -347,7 +347,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Some(AllocType::Memory(mem)) => {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n-                return Ok(M::static_with_default_tag(mem))\n+                return Ok(M::adjust_static_allocation(mem))\n             }\n             Some(AllocType::Function(..)) => {\n                 return err!(DerefFunctionPointer)\n@@ -381,7 +381,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             if let ConstValue::ByRef(_, allocation, _) = const_val.val {\n                 // We got tcx memory. Let the machine figure out whether and how to\n                 // turn that into memory with the right pointer tag.\n-                M::static_with_default_tag(allocation)\n+                M::adjust_static_allocation(allocation)\n             } else {\n                 bug!(\"Matching on non-ByRef static\")\n             }"}, {"sha": "0eae2bfb226c614fa47c7f7549e032895d1985fa", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -856,6 +856,8 @@ where\n     }\n \n     /// Make sure that a place is in memory, and return where it is.\n+    /// If the place currently refers to a local that doesn't yet have a matching allocation,\n+    /// create such an allocation.\n     /// This is essentially `force_to_memplace`.\n     pub fn force_allocation(\n         &mut self,\n@@ -899,10 +901,11 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         if layout.is_unsized() {\n             assert!(self.tcx.features().unsized_locals, \"cannot alloc memory for unsized type\");\n-            // FIXME: What should we do here?\n+            // FIXME: What should we do here? We should definitely also tag!\n             Ok(MPlaceTy::dangling(layout, &self))\n         } else {\n             let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n+            let ptr = M::tag_new_allocation(self, ptr, kind)?;\n             Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n         }\n     }"}, {"sha": "c189ec0ca5c7717231defc15f5b7d33678c8a1b5", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2612cbaf7f793f1b9411143434a85d7c8194db7/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b2612cbaf7f793f1b9411143434a85d7c8194db7", "patch": "@@ -54,10 +54,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Vtable,\n-        )?;\n+        )?.with_default_tag();\n \n         let drop = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n+        let drop = self.memory.create_fn_alloc(drop).with_default_tag();\n         self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n                 let instance = self.resolve(def_id, substs)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), &self)?;\n                 self.memory.write_ptr_sized(method_ptr, ptr_align, Scalar::Ptr(fn_ptr).into())?;\n             }"}]}