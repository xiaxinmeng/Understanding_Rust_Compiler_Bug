{"sha": "48d17f54d34c5457e88ef7ffa234601c6e342a70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZDE3ZjU0ZDM0YzU0NTdlODhlZjdmZmEyMzQ2MDFjNmUzNDJhNzA=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-09T21:15:37Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:53:01Z"}, "message": "Rebase onto master", "tree": {"sha": "e4f5171d79745ec7243c13afe4a9d56d97634e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4f5171d79745ec7243c13afe4a9d56d97634e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d17f54d34c5457e88ef7ffa234601c6e342a70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d17f54d34c5457e88ef7ffa234601c6e342a70", "html_url": "https://github.com/rust-lang/rust/commit/48d17f54d34c5457e88ef7ffa234601c6e342a70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d17f54d34c5457e88ef7ffa234601c6e342a70/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9814149c93ddec27d38028667f67f75d469c3cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9814149c93ddec27d38028667f67f75d469c3cc", "html_url": "https://github.com/rust-lang/rust/commit/a9814149c93ddec27d38028667f67f75d469c3cc"}], "stats": {"total": 184, "additions": 86, "deletions": 98}, "files": [{"sha": "4da191e8bf8a48b6aae8fd9d1ba6f5adad52ec0a", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48d17f54d34c5457e88ef7ffa234601c6e342a70/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d17f54d34c5457e88ef7ffa234601c6e342a70/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=48d17f54d34c5457e88ef7ffa234601c6e342a70", "patch": "@@ -723,11 +723,8 @@ impl Rewrite for ast::Arm {\n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n         if context.config.max_width > line_start + comma.len() + 4 {\n-            let inner_offset = line_start + 4;\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            if let Some(ref body_str) = body.rewrite(context,\n-                                                     budget,\n-                                                     line_start + 4) {\n+            if let Some(ref body_str) = body.rewrite(context, budget, line_start + 4) {\n                 if first_line_width(body_str) <= budget {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n@@ -928,8 +925,12 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         None => return Err(Ordering::Greater),\n     };\n     let offset = offset + extra_offset + 1;\n-    let inner_indent = expr_indent(context, offset);\n-    let inner_context = context.overflow_context(inner_indent - context.block_indent);\n+    let block_indent = if args.len() == 1 {\n+        context.block_indent\n+    } else {\n+        offset\n+    };\n+    let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n \n     let items = itemize_list(context.codemap,\n                              args.iter(),\n@@ -953,21 +954,6 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     Ok(format!(\"{}({})\", callee_str, list_str))\n }\n \n-macro_rules! block_indent_helper {\n-    ($name:ident, $option:ident) => (\n-        fn $name(context: &RewriteContext, offset: usize) -> usize {\n-            match context.config.$option {\n-                BlockIndentStyle::Inherit => context.block_indent,\n-                BlockIndentStyle::Tabbed => context.block_indent + context.config.tab_spaces,\n-                BlockIndentStyle::Visual => offset,\n-            }\n-        }\n-    );\n-}\n-\n-block_indent_helper!(expr_indent, expr_indent_style);\n-block_indent_helper!(closure_indent, closure_indent_style);\n-\n fn rewrite_paren(context: &RewriteContext,\n                  subexpr: &ast::Expr,\n                  width: usize,"}, {"sha": "3435bd8170b9a4f281b87d89ac0c4b25d445c627", "filename": "src/lists.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/48d17f54d34c5457e88ef7ffa234601c6e342a70/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d17f54d34c5457e88ef7ffa234601c6e342a70/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=48d17f54d34c5457e88ef7ffa234601c6e342a70", "patch": "@@ -269,18 +269,21 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     fn next(&mut self) -> Option<Self::Item> {\n         let white_space: &[_] = &[' ', '\\t'];\n \n-        self.inner.next().map(|item| {\n-            let mut new_lines = false;\n-            // Pre-comment\n-            let pre_snippet = self.codemap.span_to_snippet(codemap::mk_sp(self.prev_span_end,\n-                                                                          (self.get_lo)(&item)))\n-                                          .unwrap();\n-            let trimmed_pre_snippet = pre_snippet.trim();\n-            let pre_comment = if !trimmed_pre_snippet.is_empty() {\n-                Some(trimmed_pre_snippet.to_owned())\n-            } else {\n-                None\n-            };\n+        self.inner\n+            .next()\n+            .map(|item| {\n+                let mut new_lines = false;\n+                // Pre-comment\n+                let pre_snippet = self.codemap\n+                                      .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n+                                                                      (self.get_lo)(&item)))\n+                                      .unwrap();\n+                let trimmed_pre_snippet = pre_snippet.trim();\n+                let pre_comment = if !trimmed_pre_snippet.is_empty() {\n+                    Some(trimmed_pre_snippet.to_owned())\n+                } else {\n+                    None\n+                };\n \n                 // Post-comment\n                 let next_start = match self.inner.peek() {\n@@ -300,76 +303,75 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n \n                         match (block_open_index, newline_index) {\n                             // Separator before comment, with the next item on same line.\n-                        // Comment belongs to next item.\n-                        (Some(i), None) if i > separator_index => {\n-                            separator_index + 1\n-                        }\n-                        // Block-style post-comment before the separator.\n-                        (Some(i), None) => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n+                            // Comment belongs to next item.\n+                            (Some(i), None) if i > separator_index => {\n+                                separator_index + 1\n+                            }\n+                            // Block-style post-comment before the separator.\n+                            (Some(i), None) => {\n+                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                         separator_index + 1)\n+                            }\n+                            // Block-style post-comment. Either before or after the separator.\n+                            (Some(i), Some(j)) if i < j => {\n+                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                         separator_index + 1)\n+                            }\n+                            // Potential *single* line comment.\n+                            (_, Some(j)) => j + 1,\n+                            _ => post_snippet.len(),\n                         }\n-                        // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => {\n-                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                     separator_index + 1)\n-                        }\n-                        // Potential *single* line comment.\n-                        (_, Some(j)) => j + 1,\n-                        _ => post_snippet.len()\n                     }\n-                },\n-                None => {\n-                    post_snippet.find_uncommented(self.terminator)\n-                                .unwrap_or(post_snippet.len())\n-                }\n-            };\n-\n-            if !post_snippet.is_empty() && comment_end > 0 {\n-                // Account for extra whitespace between items. This is fiddly\n-                // because of the way we divide pre- and post- comments.\n-\n-                // Everything from the separator to the next item.\n-                let test_snippet = &post_snippet[comment_end-1..];\n-                let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n-                // From the end of the first line of comments.\n-                let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet.find(|c: char| !c.is_whitespace())\n-                                        .unwrap_or(test_snippet.len());\n-                // From the end of the first line of comments to the next non-whitespace char.\n-                let test_snippet = &test_snippet[..first];\n-\n-                if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n-                    // There were multiple line breaks which got trimmed to nothing.\n-                    new_lines = true;\n+                    None => {\n+                        post_snippet.find_uncommented(self.terminator).unwrap_or(post_snippet.len())\n+                    }\n+                };\n+\n+                if !post_snippet.is_empty() && comment_end > 0 {\n+                    // Account for extra whitespace between items. This is fiddly\n+                    // because of the way we divide pre- and post- comments.\n+\n+                    // Everything from the separator to the next item.\n+                    let test_snippet = &post_snippet[comment_end-1..];\n+                    let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n+                    // From the end of the first line of comments.\n+                    let test_snippet = &test_snippet[first_newline..];\n+                    let first = test_snippet.find(|c: char| !c.is_whitespace())\n+                                            .unwrap_or(test_snippet.len());\n+                    // From the end of the first line of comments to the next non-whitespace char.\n+                    let test_snippet = &test_snippet[..first];\n+\n+                    if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n+                        // There were multiple line breaks which got trimmed to nothing.\n+                        new_lines = true;\n+                    }\n                 }\n-            }\n \n-            // Cleanup post-comment: strip separators and whitespace.\n-            self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-            let post_snippet = post_snippet[..comment_end].trim();\n+                // Cleanup post-comment: strip separators and whitespace.\n+                self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n+                let post_snippet = post_snippet[..comment_end].trim();\n \n-            let post_snippet_trimmed = if post_snippet.starts_with(',') {\n-                post_snippet[1..].trim_matches(white_space)\n-            } else if post_snippet.ends_with(\",\") {\n-                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-            } else {\n-                post_snippet\n-            };\n+                let post_snippet_trimmed = if post_snippet.starts_with(',') {\n+                    post_snippet[1..].trim_matches(white_space)\n+                } else if post_snippet.ends_with(\",\") {\n+                    post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+                } else {\n+                    post_snippet\n+                };\n \n-            let post_comment = if !post_snippet_trimmed.is_empty() {\n-                Some(post_snippet_trimmed.to_owned())\n-            } else {\n-                None\n-            };\n-\n-            ListItem {\n-                pre_comment: pre_comment,\n-                item: (self.get_item_string)(&item),\n-                post_comment: post_comment,\n-                new_lines: new_lines,\n-            }\n-        })\n+                let post_comment = if !post_snippet_trimmed.is_empty() {\n+                    Some(post_snippet_trimmed.to_owned())\n+                } else {\n+                    None\n+                };\n+\n+                ListItem {\n+                    pre_comment: pre_comment,\n+                    item: (self.get_item_string)(&item),\n+                    post_comment: post_comment,\n+                    new_lines: new_lines,\n+                }\n+            })\n     }\n }\n "}, {"sha": "5cfbb5a70728160897064d281ead78dac1fc7c18", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=48d17f54d34c5457e88ef7ffa234601c6e342a70", "patch": "@@ -57,7 +57,7 @@ fn foo() {\n // Test that a match on an overflow line is laid out properly.\n fn main() {\n     let sub_span =\n-        match self.span.sub_span_after_keywooooooooooooooooooooord(use_item.span, keywords::As) {\n+        match xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx {\n             Some(sub_span) => Some(sub_span),\n             None => sub_span,\n         };"}]}