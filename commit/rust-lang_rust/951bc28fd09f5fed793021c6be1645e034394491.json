{"sha": "951bc28fd09f5fed793021c6be1645e034394491", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MWJjMjhmZDA5ZjVmZWQ3OTMwMjFjNmJlMTY0NWUwMzQzOTQ0OTE=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-05-31T16:36:51Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-06-11T20:48:25Z"}, "message": "Stablize the alloc module without changing stability of its contents.", "tree": {"sha": "c873a453750330eec8a9512623ac33caee5efa63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c873a453750330eec8a9512623ac33caee5efa63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/951bc28fd09f5fed793021c6be1645e034394491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/951bc28fd09f5fed793021c6be1645e034394491", "html_url": "https://github.com/rust-lang/rust/commit/951bc28fd09f5fed793021c6be1645e034394491", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/951bc28fd09f5fed793021c6be1645e034394491/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9fd063edb4f6783fbd91a82a0f61626dacf8dad", "html_url": "https://github.com/rust-lang/rust/commit/e9fd063edb4f6783fbd91a82a0f61626dacf8dad"}], "stats": {"total": 69, "additions": 51, "deletions": 18}, "files": [{"sha": "fc3d0151ec03e08e793c7e7edaaf29bcb5b0c003", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/951bc28fd09f5fed793021c6be1645e034394491/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951bc28fd09f5fed793021c6be1645e034394491/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=951bc28fd09f5fed793021c6be1645e034394491", "patch": "@@ -10,17 +10,13 @@\n \n //! Memory allocation APIs\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n use core::usize;\n \n+#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n pub use core::alloc::*;\n \n@@ -44,6 +40,7 @@ extern \"Rust\" {\n /// This type implements the [`Alloc`] trait by forwarding calls\n /// to the allocator registered with the `#[global_allocator]` attribute\n /// if there is one, or the `std` crate\u2019s default.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n \n@@ -119,6 +116,7 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n     __rust_alloc_zeroed(layout.size(), layout.align())\n }\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for Global {\n     #[inline]\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n@@ -188,6 +186,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n /// and abort the process.\n /// It can be replaced with [`std::alloc::set_oom_hook`]\n /// and [`std::alloc::take_oom_hook`].\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[rustc_allocator_nounwind]\n pub fn oom(layout: Layout) -> ! {\n     #[allow(improper_ctypes)]"}, {"sha": "ae9f77d35cfea7840a69229a1f401fcc81fdebbd", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/951bc28fd09f5fed793021c6be1645e034394491/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951bc28fd09f5fed793021c6be1645e034394491/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=951bc28fd09f5fed793021c6be1645e034394491", "patch": "@@ -10,12 +10,7 @@\n \n //! Memory allocation APIs\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use cmp;\n use fmt;\n@@ -24,11 +19,13 @@ use usize;\n use ptr::{self, NonNull};\n use num::NonZeroUsize;\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[cfg(stage0)]\n pub type Opaque = u8;\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Debug)]\n pub struct Excess(pub NonNull<u8>, pub usize);\n \n@@ -49,6 +46,7 @@ fn size_align<T>() -> (usize, usize) {\n /// requests have positive size. A caller to the `Alloc::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n@@ -74,6 +72,7 @@ impl Layout {\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n         if !align.is_power_of_two() {\n@@ -109,20 +108,24 @@ impl Layout {\n     ///\n     /// This function is unsafe as it does not verify the preconditions from\n     /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn size(&self) -> usize { self.size_ }\n \n     /// The minimum byte alignment for a memory block of this layout.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn align(&self) -> usize { self.align_.get() }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n@@ -139,6 +142,7 @@ impl Layout {\n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n@@ -166,6 +170,7 @@ impl Layout {\n     /// Panics if the combination of `self.size()` and the given `align`\n     /// violates the conditions listed in\n     /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align)).unwrap()\n@@ -187,6 +192,7 @@ impl Layout {\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n     /// satisfy this constraint is to ensure `align <= self.align()`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n@@ -223,6 +229,7 @@ impl Layout {\n     /// of each element in the array.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n         let padded_size = self.size().checked_add(self.padding_needed_for(self.align()))\n@@ -248,6 +255,7 @@ impl Layout {\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_align = cmp::max(self.align(), next.align());\n@@ -274,6 +282,7 @@ impl Layout {\n     /// aligned.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n         let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n@@ -295,6 +304,7 @@ impl Layout {\n     ///  `extend`.)\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n@@ -306,6 +316,7 @@ impl Layout {\n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n@@ -320,12 +331,14 @@ impl Layout {\n /// The parameters given to `Layout::from_size_align`\n /// or some other `Layout` constructor\n /// do not satisfy its documented constraints.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct LayoutErr {\n     private: ()\n }\n \n // (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl fmt::Display for LayoutErr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"invalid parameters to Layout::from_size_align\")\n@@ -336,10 +349,12 @@ impl fmt::Display for LayoutErr {\n /// that may be due to resource exhaustion or to\n /// something wrong when combining the given input arguments with this\n /// allocator.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct AllocErr;\n \n // (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl fmt::Display for AllocErr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"memory allocation failed\")\n@@ -350,16 +365,19 @@ impl fmt::Display for AllocErr {\n /// `shrink_in_place` were unable to reuse the given memory block for\n /// a requested layout.\n // FIXME: should this be in libcore or liballoc?\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct CannotReallocInPlace;\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl CannotReallocInPlace {\n     pub fn description(&self) -> &str {\n         \"cannot reallocate allocator's memory in place\"\n     }\n }\n \n // (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl fmt::Display for CannotReallocInPlace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.description())\n@@ -449,6 +467,7 @@ impl From<LayoutErr> for CollectionAllocErr {\n /// * `Layout` queries and calculations in general must be correct. Callers of\n ///   this trait are allowed to rely on the contracts defined on each method,\n ///   and implementors must ensure such contracts remain true.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait GlobalAlloc {\n     /// Allocate memory as described by the given `layout`.\n     ///\n@@ -664,6 +683,7 @@ pub unsafe trait GlobalAlloc {\n ///\n /// Note that this list may get tweaked over time as clarifications are made in\n /// the future.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait Alloc {\n \n     // (Note: some existing allocators have unspecified but well-defined"}, {"sha": "1a4869f87c9684d268d7a7983f8f274b76c04539", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/951bc28fd09f5fed793021c6be1645e034394491/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951bc28fd09f5fed793021c6be1645e034394491/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=951bc28fd09f5fed793021c6be1645e034394491", "patch": "@@ -10,17 +10,20 @@\n \n //! Memory allocation APIs\n \n-#![unstable(issue = \"32838\", feature = \"allocator_api\")]\n-\n-#[doc(inline)] pub use alloc_crate::alloc::{Global, Layout, oom};\n-#[doc(inline)] pub use alloc_crate::alloc::{alloc, alloc_zeroed, dealloc, realloc};\n-#[doc(inline)] pub use alloc_system::System;\n-#[doc(inline)] pub use core::alloc::*;\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::sync::atomic::{AtomicPtr, Ordering};\n use core::{mem, ptr};\n use sys_common::util::dumb_print;\n \n+#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n+#[doc(inline)]\n+pub use alloc_crate::alloc::*;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[doc(inline)]\n+pub use alloc_system::System;\n+\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n \n /// Registers a custom OOM hook, replacing any that was previously registered.\n@@ -34,6 +37,7 @@ static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n /// about the allocation that failed.\n ///\n /// The OOM hook is a global resource.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub fn set_oom_hook(hook: fn(Layout)) {\n     HOOK.store(hook as *mut (), Ordering::SeqCst);\n }\n@@ -43,6 +47,7 @@ pub fn set_oom_hook(hook: fn(Layout)) {\n /// *See also the function [`set_oom_hook`].*\n ///\n /// If no custom hook is registered, the default hook will be returned.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub fn take_oom_hook() -> fn(Layout) {\n     let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);\n     if hook.is_null() {\n@@ -59,6 +64,7 @@ fn default_oom_hook(layout: Layout) {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[lang = \"oom\"]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub extern fn rust_oom(layout: Layout) -> ! {\n     let hook = HOOK.load(Ordering::SeqCst);\n     let hook: fn(Layout) = if hook.is_null() {\n@@ -73,6 +79,7 @@ pub extern fn rust_oom(layout: Layout) -> ! {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub mod __default_lib_allocator {\n     use super::{System, Layout, GlobalAlloc};\n     // for symbol names src/librustc/middle/allocator.rs"}, {"sha": "b1b1a9a1fbf8e7d5789f4e155f89e7b26c866f25", "filename": "src/test/compile-fail/lint-stability-fields.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/951bc28fd09f5fed793021c6be1645e034394491/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/951bc28fd09f5fed793021c6be1645e034394491/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs?ref=951bc28fd09f5fed793021c6be1645e034394491", "patch": "@@ -18,6 +18,11 @@\n mod cross_crate {\n     extern crate lint_stability_fields;\n \n+    mod reexport {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub use super::lint_stability_fields::*;\n+    }\n+\n     use self::lint_stability_fields::*;\n \n     pub fn foo() {\n@@ -73,6 +78,8 @@ mod cross_crate {\n             // the patterns are all fine:\n             { .. } = x;\n \n+        // Unstable items are still unstable even when used through a stable \"pub use\".\n+        let x = reexport::Unstable2(1, 2, 3); //~ ERROR use of unstable\n \n         let x = Unstable2(1, 2, 3); //~ ERROR use of unstable\n "}]}