{"sha": "b1c7a46c0db2cd73575792aebe08108b53289d80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYzdhNDZjMGRiMmNkNzM1NzU3OTJhZWJlMDgxMDhiNTMyODlkODA=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-19T22:00:11Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2015-08-20T00:00:15Z"}, "message": "Turn TimedOut into a BarrierWaitResult style opaque type", "tree": {"sha": "8294ae7a04a01b8cd19d4e93de51988d88478e2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8294ae7a04a01b8cd19d4e93de51988d88478e2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1c7a46c0db2cd73575792aebe08108b53289d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1c7a46c0db2cd73575792aebe08108b53289d80", "html_url": "https://github.com/rust-lang/rust/commit/b1c7a46c0db2cd73575792aebe08108b53289d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1c7a46c0db2cd73575792aebe08108b53289d80/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46156de5f1d8a4ebfb874d170ba6844462b5781b", "url": "https://api.github.com/repos/rust-lang/rust/commits/46156de5f1d8a4ebfb874d170ba6844462b5781b", "html_url": "https://github.com/rust-lang/rust/commit/46156de5f1d8a4ebfb874d170ba6844462b5781b"}], "stats": {"total": 63, "additions": 25, "deletions": 38}, "files": [{"sha": "981bcf5e0b5fb803c44d6d3a2fcebe62b373262b", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b1c7a46c0db2cd73575792aebe08108b53289d80/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c7a46c0db2cd73575792aebe08108b53289d80/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=b1c7a46c0db2cd73575792aebe08108b53289d80", "patch": "@@ -22,17 +22,12 @@ use time::Duration;\n /// due to a time out or not.\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n #[unstable(feature = \"wait_timeout\", reason = \"newly added\")]\n-pub enum TimedOut {\n-    /// The wait timed out.\n-    Yes,\n-    /// The wait did not time out.\n-    No\n-}\n+pub struct WaitTimeoutResult(bool);\n \n-impl TimedOut {\n-    /// Returns `true` iff the value of `self` is `Yes`.\n+impl WaitTimeoutResult {\n+    /// Returns whether the wait was known to have timed out.\n     pub fn timed_out(&self) -> bool {\n-        *self == TimedOut::Yes\n+        self.0\n     }\n }\n \n@@ -188,16 +183,16 @@ impl Condvar {\n     /// preemption or platform differences that may not cause the maximum\n     /// amount of time waited to be precisely `dur`.\n     ///\n-    /// The returned `TimedOut` value indicates if the timeout is known to have\n-    /// elapsed.\n+    /// The returned `WaitTimeoutResult` value indicates if the timeout is\n+    /// known to have elapsed.\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n     #[unstable(feature = \"wait_timeout\", reason = \"waiting for Duration\",\n                issue = \"27772\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, TimedOut)> {\n+                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n             me.inner.wait_timeout(guard, dur)\n@@ -217,7 +212,7 @@ impl Condvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, TimedOut)>\n+                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n@@ -297,10 +292,10 @@ impl StaticCondvar {\n     pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n         match self.wait_timeout(guard, Duration::from_millis(ms as u64)) {\n-            Ok((guard, timed_out)) => Ok((guard, timed_out == TimedOut::No)),\n+            Ok((guard, timed_out)) => Ok((guard, !timed_out.timed_out())),\n             Err(poison) => {\n                 let (guard, timed_out) = poison.into_inner();\n-                Err(PoisonError::new((guard, timed_out == TimedOut::No)))\n+                Err(PoisonError::new((guard, !timed_out.timed_out())))\n             }\n         }\n     }\n@@ -315,21 +310,17 @@ impl StaticCondvar {\n     pub fn wait_timeout<'a, T>(&'static self,\n                                guard: MutexGuard<'a, T>,\n                                timeout: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, TimedOut)> {\n-        let (poisoned, success) = unsafe {\n+                               -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n+        let (poisoned, result) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = if self.inner.wait_timeout(lock, timeout) {\n-                TimedOut::No\n-            } else {\n-                TimedOut::Yes\n-            };\n-            (mutex::guard_poison(&guard).get(), success)\n+            let success = self.inner.wait_timeout(lock, timeout);\n+            (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n         };\n         if poisoned {\n-            Err(PoisonError::new((guard, success)))\n+            Err(PoisonError::new((guard, result)))\n         } else {\n-            Ok((guard, success))\n+            Ok((guard, result))\n         }\n     }\n \n@@ -347,7 +338,7 @@ impl StaticCondvar {\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        mut f: F)\n-                                       -> LockResult<(MutexGuard<'a, T>, TimedOut)>\n+                                       -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         // This could be made more efficient by pushing the implementation into\n         // sys::condvar\n@@ -361,7 +352,7 @@ impl StaticCondvar {\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n             let (new_guard_result, timed_out) = if consumed > dur {\n-                (Ok(guard), TimedOut::Yes)\n+                (Ok(guard), WaitTimeoutResult(true))\n             } else {\n                 match self.wait_timeout(guard, dur - consumed) {\n                     Ok((new_guard, timed_out)) => (Ok(new_guard), timed_out),\n@@ -372,21 +363,17 @@ impl StaticCondvar {\n                 }\n             };\n             guard_result = new_guard_result;\n-            if timed_out == TimedOut::Yes {\n+            if timed_out.timed_out() {\n                 let result = f(guard_result\n                                     .as_mut()\n                                     .map(|g| &mut **g)\n                                     .map_err(|e| PoisonError::new(&mut **e.get_mut())));\n-                let result = if result {\n-                    TimedOut::No\n-                } else {\n-                    TimedOut::Yes\n-                };\n+                let result = WaitTimeoutResult(!result);\n                 return poison::map_result(guard_result, |g| (g, result));\n             }\n         }\n \n-        poison::map_result(guard_result, |g| (g, TimedOut::No))\n+        poison::map_result(guard_result, |g| (g, WaitTimeoutResult(false)))\n     }\n \n     /// Wakes up one blocked thread on this condvar.\n@@ -443,7 +430,7 @@ mod tests {\n \n     use super::StaticCondvar;\n     use sync::mpsc::channel;\n-    use sync::{StaticMutex, Condvar, Mutex, Arc, TimedOut};\n+    use sync::{StaticMutex, Condvar, Mutex, Arc};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n     use time::Duration;\n@@ -544,7 +531,7 @@ mod tests {\n         let (g, timed_out) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n             false\n         }).unwrap();\n-        assert_eq!(timed_out, TimedOut::Yes);\n+        assert!(timed_out.timed_out());\n \n         let (tx, rx) = channel();\n         let _t = thread::spawn(move || {\n@@ -577,7 +564,7 @@ mod tests {\n                 _ => true,\n             }\n         }).unwrap();\n-        assert_eq!(timed_out, TimedOut::No);\n+        assert!(!timed_out.timed_out());\n     }\n \n     #[test]"}, {"sha": "ae21503cf6746d31318698d6b7aa9ca3505c489c", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1c7a46c0db2cd73575792aebe08108b53289d80/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1c7a46c0db2cd73575792aebe08108b53289d80/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=b1c7a46c0db2cd73575792aebe08108b53289d80", "patch": "@@ -21,7 +21,7 @@ pub use alloc::arc::{Arc, Weak};\n pub use core::atomic;\n \n pub use self::barrier::{Barrier, BarrierWaitResult};\n-pub use self::condvar::{Condvar, StaticCondvar, TimedOut, CONDVAR_INIT};\n+pub use self::condvar::{Condvar, StaticCondvar, WaitTimeoutResult, CONDVAR_INIT};\n pub use self::mutex::MUTEX_INIT;\n pub use self::mutex::{Mutex, MutexGuard, StaticMutex};\n pub use self::once::{Once, ONCE_INIT};"}]}