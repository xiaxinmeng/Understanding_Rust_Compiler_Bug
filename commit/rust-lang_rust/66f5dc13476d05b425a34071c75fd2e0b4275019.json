{"sha": "66f5dc13476d05b425a34071c75fd2e0b4275019", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZjVkYzEzNDc2ZDA1YjQyNWEzNDA3MWM3NWZkMmUwYjQyNzUwMTk=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-09-18T14:32:52Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2015-09-19T10:50:52Z"}, "message": "VecDeque: Use power of two capacity even for zero sized types\n\nVecDeque depends on using a power of two capacity. Use the largest\npossible power of two capacity for ZSTs.", "tree": {"sha": "90d4ab421453c0716c03289c8d8424fece1b6167", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d4ab421453c0716c03289c8d8424fece1b6167"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66f5dc13476d05b425a34071c75fd2e0b4275019", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66f5dc13476d05b425a34071c75fd2e0b4275019", "html_url": "https://github.com/rust-lang/rust/commit/66f5dc13476d05b425a34071c75fd2e0b4275019", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66f5dc13476d05b425a34071c75fd2e0b4275019/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff04117064ddee95f425c49f22c8aa5a3a665d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff04117064ddee95f425c49f22c8aa5a3a665d4", "html_url": "https://github.com/rust-lang/rust/commit/cff04117064ddee95f425c49f22c8aa5a3a665d4"}], "stats": {"total": 41, "additions": 40, "deletions": 1}, "files": [{"sha": "4ee9787c9ec8a5c727bf93d2059e04436d79e7d3", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/66f5dc13476d05b425a34071c75fd2e0b4275019/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66f5dc13476d05b425a34071c75fd2e0b4275019/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=66f5dc13476d05b425a34071c75fd2e0b4275019", "patch": "@@ -21,9 +21,11 @@\n use core::cmp::Ordering;\n use core::fmt;\n use core::iter::{repeat, FromIterator};\n+use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::slice;\n+use core::usize;\n \n use core::hash::{Hash, Hasher};\n use core::cmp;\n@@ -32,6 +34,7 @@ use alloc::raw_vec::RawVec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n+const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n \n /// `VecDeque` is a growable ring buffer, which can be used as a\n /// double-ended queue efficiently.\n@@ -83,7 +86,12 @@ impl<T> VecDeque<T> {\n     /// Marginally more convenient\n     #[inline]\n     fn cap(&self) -> usize {\n-        self.buf.cap()\n+        if mem::size_of::<T>() == 0 {\n+            // For zero sized types, we are always at maximum capacity\n+            MAXIMUM_ZST_CAPACITY\n+        } else {\n+            self.buf.cap()\n+        }\n     }\n \n     /// Turn ptr into a slice\n@@ -1465,6 +1473,7 @@ impl<T: Clone> VecDeque<T> {\n #[inline]\n fn wrap_index(index: usize, size: usize) -> usize {\n     // size is always a power of 2\n+    debug_assert!(size.is_power_of_two());\n     index & (size - 1)\n }\n \n@@ -2032,4 +2041,34 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn test_zst_push() {\n+        const N: usize = 8;\n+\n+        // Zero sized type\n+        struct Zst;\n+\n+        // Test that for all possible sequences of push_front / push_back,\n+        // we end up with a deque of the correct size\n+\n+        for len in 0..N {\n+            let mut tester = VecDeque::with_capacity(len);\n+            assert_eq!(tester.len(), 0);\n+            assert!(tester.capacity() >= len);\n+            for case in 0..(1 << len) {\n+                assert_eq!(tester.len(), 0);\n+                for bit in 0..len {\n+                    if case & (1 << bit) != 0 {\n+                        tester.push_front(Zst);\n+                    } else {\n+                        tester.push_back(Zst);\n+                    }\n+                }\n+                assert_eq!(tester.len(), len);\n+                assert_eq!(tester.iter().count(), len);\n+                tester.clear();\n+            }\n+        }\n+    }\n }"}]}