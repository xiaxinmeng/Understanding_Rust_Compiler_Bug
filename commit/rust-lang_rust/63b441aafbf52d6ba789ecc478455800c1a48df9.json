{"sha": "63b441aafbf52d6ba789ecc478455800c1a48df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYjQ0MWFhZmJmNTJkNmJhNzg5ZWNjNDc4NDU1ODAwYzFhNDhkZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T08:34:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-19T08:34:50Z"}, "message": "Auto merge of #73498 - RalfJung:rollup-1mfjcju, r=RalfJung\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #70740 (Enabling static-pie for musl)\n - #72331 (Report error when casting an C-like enum implementing Drop)\n - #72486 (Fix asinh of negative values)\n - #72497 (tag/niche terminology cleanup)\n - #72999 (Create self-contained directory and move there some of external binaries/libs)\n - #73130 (Remove const prop for indirects)\n - #73142 (Ensure std benchmarks get tested.)\n - #73305 (Disallow loading crates with non-ascii identifier name.)\n - #73346 (Add rust specific features to print target features)\n - #73362 (Test that bounds checks are elided when slice len is checked up-front)\n - #73459 (Reduce pointer casts in Box::into_boxed_slice)\n - #73464 (Document format correction)\n - #73479 (Minor tweaks to liballoc)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "522aba5368c067b64995b45a91f3e4e5587bfe3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/522aba5368c067b64995b45a91f3e4e5587bfe3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63b441aafbf52d6ba789ecc478455800c1a48df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63b441aafbf52d6ba789ecc478455800c1a48df9", "html_url": "https://github.com/rust-lang/rust/commit/63b441aafbf52d6ba789ecc478455800c1a48df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63b441aafbf52d6ba789ecc478455800c1a48df9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39c7787ba246353178e099373b9240be0d9e603", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39c7787ba246353178e099373b9240be0d9e603", "html_url": "https://github.com/rust-lang/rust/commit/a39c7787ba246353178e099373b9240be0d9e603"}, {"sha": "028c908991125742c4acc38b7a3108a1d1133771", "url": "https://api.github.com/repos/rust-lang/rust/commits/028c908991125742c4acc38b7a3108a1d1133771", "html_url": "https://github.com/rust-lang/rust/commit/028c908991125742c4acc38b7a3108a1d1133771"}], "stats": {"total": 1038, "additions": 682, "deletions": 356}, "files": [{"sha": "afcf0dcac7e55341e4764ce8a8ba513dd92a855b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 112, "deletions": 52, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -23,7 +23,7 @@ use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n use crate::util::{exe, is_dylib, symlink_dir};\n-use crate::{Compiler, GitRepo, Mode};\n+use crate::{Compiler, DependencyType, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -74,6 +74,7 @@ impl Step for Std {\n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n+            copy_self_contained_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n                 compiler: compiler_to_use,\n@@ -83,7 +84,8 @@ impl Step for Std {\n             return;\n         }\n \n-        target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n+        target_deps.extend(copy_third_party_objects(builder, &compiler, target));\n+        target_deps.extend(copy_self_contained_objects(builder, &compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n@@ -109,21 +111,76 @@ impl Step for Std {\n     }\n }\n \n+fn copy_and_stamp(\n+    builder: &Builder<'_>,\n+    libdir: &Path,\n+    sourcedir: &Path,\n+    name: &str,\n+    target_deps: &mut Vec<(PathBuf, DependencyType)>,\n+    dependency_type: DependencyType,\n+) {\n+    let target = libdir.join(name);\n+    builder.copy(&sourcedir.join(name), &target);\n+\n+    target_deps.push((target, dependency_type));\n+}\n+\n /// Copies third party objects needed by various targets.\n fn copy_third_party_objects(\n     builder: &Builder<'_>,\n     compiler: &Compiler,\n     target: Interned<String>,\n-) -> Vec<PathBuf> {\n+) -> Vec<(PathBuf, DependencyType)> {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n-\n     let mut target_deps = vec![];\n \n-    let mut copy_and_stamp = |sourcedir: &Path, name: &str| {\n-        let target = libdir.join(name);\n-        builder.copy(&sourcedir.join(name), &target);\n-        target_deps.push(target);\n+    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n+    //\n+    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n+    // libunwind requires support for rwlock and printing to stderr,\n+    // which is provided by std for this target.\n+    if target == \"x86_64-fortanix-unknown-sgx\" {\n+        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n+        let src =\n+            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n+        copy_and_stamp(\n+            builder,\n+            &*libdir,\n+            Path::new(&src),\n+            \"libunwind.a\",\n+            &mut target_deps,\n+            DependencyType::Target,\n+        );\n+    }\n+\n+    if builder.config.sanitizers && compiler.stage != 0 {\n+        // The sanitizers are only copied in stage1 or above,\n+        // to avoid creating dependency on LLVM.\n+        target_deps.extend(\n+            copy_sanitizers(builder, &compiler, target)\n+                .into_iter()\n+                .map(|d| (d, DependencyType::Target)),\n+        );\n+    }\n+\n+    target_deps\n+}\n+\n+/// Copies third party objects needed by various targets for self-contained linkage.\n+fn copy_self_contained_objects(\n+    builder: &Builder<'_>,\n+    compiler: &Compiler,\n+    target: Interned<String>,\n+) -> Vec<(PathBuf, DependencyType)> {\n+    // cfg(bootstrap)\n+    // Remove when upgrading bootstrap compiler.\n+    let libdir_self_contained = if compiler.stage == 0 {\n+        builder.sysroot_libdir(*compiler, target).to_path_buf()\n+    } else {\n+        builder.sysroot_libdir(*compiler, target).join(\"self-contained\")\n     };\n+    t!(fs::create_dir_all(&libdir_self_contained));\n+    let mut target_deps = vec![];\n \n     // Copies the CRT objects.\n     //\n@@ -135,29 +192,32 @@ fn copy_third_party_objects(\n     if target.contains(\"musl\") {\n         let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n         for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n-            copy_and_stamp(&srcdir, obj);\n+            copy_and_stamp(\n+                builder,\n+                &libdir_self_contained,\n+                &srcdir,\n+                obj,\n+                &mut target_deps,\n+                DependencyType::TargetSelfContained,\n+            );\n         }\n     } else if target.ends_with(\"-wasi\") {\n         let srcdir = builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\");\n-        copy_and_stamp(&srcdir, \"crt1.o\");\n-    }\n-\n-    // Copies libunwind.a compiled to be linked with x86_64-fortanix-unknown-sgx.\n-    //\n-    // This target needs to be linked to Fortanix's port of llvm's libunwind.\n-    // libunwind requires support for rwlock and printing to stderr,\n-    // which is provided by std for this target.\n-    if target == \"x86_64-fortanix-unknown-sgx\" {\n-        let src_path_env = \"X86_FORTANIX_SGX_LIBS\";\n-        let src =\n-            env::var(src_path_env).unwrap_or_else(|_| panic!(\"{} not found in env\", src_path_env));\n-        copy_and_stamp(Path::new(&src), \"libunwind.a\");\n-    }\n-\n-    if builder.config.sanitizers && compiler.stage != 0 {\n-        // The sanitizers are only copied in stage1 or above,\n-        // to avoid creating dependency on LLVM.\n-        target_deps.extend(copy_sanitizers(builder, &compiler, target));\n+        copy_and_stamp(\n+            builder,\n+            &libdir_self_contained,\n+            &srcdir,\n+            \"crt1.o\",\n+            &mut target_deps,\n+            DependencyType::TargetSelfContained,\n+        );\n+    } else if target.contains(\"windows-gnu\") {\n+        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+            let src = compiler_file(builder, builder.cc(target), target, obj);\n+            let target = libdir_self_contained.join(obj);\n+            builder.copy(&src, &target);\n+            target_deps.push((target, DependencyType::TargetSelfContained));\n+        }\n     }\n \n     target_deps\n@@ -335,7 +395,7 @@ pub struct StartupObjects {\n }\n \n impl Step for StartupObjects {\n-    type Output = Vec<PathBuf>;\n+    type Output = Vec<(PathBuf, DependencyType)>;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n@@ -354,7 +414,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder<'_>) -> Vec<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Vec<(PathBuf, DependencyType)> {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"windows-gnu\") {\n@@ -388,14 +448,7 @@ impl Step for StartupObjects {\n \n             let target = sysroot_dir.join((*file).to_string() + \".o\");\n             builder.copy(dst_file, &target);\n-            target_deps.push(target);\n-        }\n-\n-        for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            let src = compiler_file(builder, builder.cc(target), target, obj);\n-            let target = sysroot_dir.join(obj);\n-            builder.copy(&src, &target);\n-            target_deps.push(target);\n+            target_deps.push((target, DependencyType::Target));\n         }\n \n         target_deps\n@@ -808,14 +861,17 @@ pub fn add_to_sysroot(\n     sysroot_host_dst: &Path,\n     stamp: &Path,\n ) {\n+    let self_contained_dst = &sysroot_dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&sysroot_dst));\n     t!(fs::create_dir_all(&sysroot_host_dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if host {\n-            builder.copy(&path, &sysroot_host_dst.join(path.file_name().unwrap()));\n-        } else {\n-            builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n-        }\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        let dst = match dependency_type {\n+            DependencyType::Host => sysroot_host_dst,\n+            DependencyType::Target => sysroot_dst,\n+            DependencyType::TargetSelfContained => self_contained_dst,\n+        };\n+        builder.copy(&path, &dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -824,7 +880,7 @@ pub fn run_cargo(\n     cargo: Cargo,\n     tail_args: Vec<String>,\n     stamp: &Path,\n-    additional_target_deps: Vec<PathBuf>,\n+    additional_target_deps: Vec<(PathBuf, DependencyType)>,\n     is_check: bool,\n ) -> Vec<PathBuf> {\n     if builder.config.dry_run {\n@@ -875,15 +931,15 @@ pub fn run_cargo(\n             if filename.starts_with(&host_root_dir) {\n                 // Unless it's a proc macro used in the compiler\n                 if crate_types.iter().any(|t| t == \"proc-macro\") {\n-                    deps.push((filename.to_path_buf(), true));\n+                    deps.push((filename.to_path_buf(), DependencyType::Host));\n                 }\n                 continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n-                deps.push((filename.to_path_buf(), false));\n+                deps.push((filename.to_path_buf(), DependencyType::Target));\n                 continue;\n             }\n \n@@ -935,17 +991,21 @@ pub fn run_cargo(\n             let candidate = format!(\"{}.lib\", path_to_add);\n             let candidate = PathBuf::from(candidate);\n             if candidate.exists() {\n-                deps.push((candidate, false));\n+                deps.push((candidate, DependencyType::Target));\n             }\n         }\n-        deps.push((path_to_add.into(), false));\n+        deps.push((path_to_add.into(), DependencyType::Target));\n     }\n \n-    deps.extend(additional_target_deps.into_iter().map(|d| (d, false)));\n+    deps.extend(additional_target_deps);\n     deps.sort();\n     let mut new_contents = Vec::new();\n-    for (dep, proc_macro) in deps.iter() {\n-        new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n+    for (dep, dependency_type) in deps.iter() {\n+        new_contents.extend(match *dependency_type {\n+            DependencyType::Host => b\"h\",\n+            DependencyType::Target => b\"t\",\n+            DependencyType::TargetSelfContained => b\"s\",\n+        });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }"}, {"sha": "8a2463d378fdb8642cea130e3bd1c10fb5bbd3ba", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -22,7 +22,7 @@ use crate::channel;\n use crate::compile;\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, timeit};\n-use crate::{Compiler, Mode, LLVM_TOOLS};\n+use crate::{Compiler, DependencyType, Mode, LLVM_TOOLS};\n use time::{self, Timespec};\n \n pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n@@ -306,7 +306,12 @@ fn make_win_dist(\n     }\n \n     //Copy platform tools to platform-specific bin directory\n-    let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n+    let target_bin_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"bin\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n         builder.copy_to_folder(&src, &target_bin_dir);\n@@ -321,7 +326,12 @@ fn make_win_dist(\n     );\n \n     //Copy platform libs to platform-specific lib directory\n-    let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n+    let target_lib_dir = plat_root\n+        .join(\"lib\")\n+        .join(\"rustlib\")\n+        .join(target_triple)\n+        .join(\"lib\")\n+        .join(\"self-contained\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n         builder.copy_to_folder(&src, &target_lib_dir);\n@@ -652,9 +662,13 @@ fn skip_host_target_lib(builder: &Builder<'_>, compiler: Compiler) -> bool {\n /// Copy stamped files into an image's `target/lib` directory.\n fn copy_target_libs(builder: &Builder<'_>, target: &str, image: &Path, stamp: &Path) {\n     let dst = image.join(\"lib/rustlib\").join(target).join(\"lib\");\n+    let self_contained_dst = dst.join(\"self-contained\");\n     t!(fs::create_dir_all(&dst));\n-    for (path, host) in builder.read_stamp_file(stamp) {\n-        if !host || builder.config.build == target {\n+    t!(fs::create_dir_all(&self_contained_dst));\n+    for (path, dependency_type) in builder.read_stamp_file(stamp) {\n+        if dependency_type == DependencyType::TargetSelfContained {\n+            builder.copy(&path, &self_contained_dst.join(path.file_name().unwrap()));\n+        } else if dependency_type == DependencyType::Target || builder.config.build == target {\n             builder.copy(&path, &dst.join(path.file_name().unwrap()));\n         }\n     }"}, {"sha": "db861cb7013713c040677ba0ffbfaf37a4ded2c6", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -280,6 +280,17 @@ impl Crate {\n     }\n }\n \n+/// When building Rust various objects are handled differently.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum DependencyType {\n+    /// Libraries originating from proc-macros.\n+    Host,\n+    /// Typical Rust libraries.\n+    Target,\n+    /// Non Rust libraries and objects shipped to ease usage of certain targets.\n+    TargetSelfContained,\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -1097,7 +1108,7 @@ impl Build {\n         ret\n     }\n \n-    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, bool)> {\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<(PathBuf, DependencyType)> {\n         if self.config.dry_run {\n             return Vec::new();\n         }\n@@ -1110,9 +1121,14 @@ impl Build {\n             if part.is_empty() {\n                 continue;\n             }\n-            let host = part[0] as char == 'h';\n+            let dependency_type = match part[0] as char {\n+                'h' => DependencyType::Host,\n+                's' => DependencyType::TargetSelfContained,\n+                't' => DependencyType::Target,\n+                _ => unreachable!(),\n+            };\n             let path = PathBuf::from(t!(str::from_utf8(&part[1..])));\n-            paths.push((path, host));\n+            paths.push((path, dependency_type));\n         }\n         paths\n     }"}, {"sha": "914195f015b5a83daf9325285aa6074c61c79dec", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -25,6 +25,7 @@ path = \"../liballoc/tests/lib.rs\"\n [[bench]]\n name = \"collectionsbenches\"\n path = \"../liballoc/benches/lib.rs\"\n+test = true\n \n [[bench]]\n name = \"vec_deque_append_bench\""}, {"sha": "ab0dde0ada660ecbf08ede47a4e0f58a6191e3bf", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -248,7 +248,7 @@ impl<T> Box<T> {\n     #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n     pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n         // *mut T and *mut [T; 1] have the same size and alignment\n-        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1] as *mut [T]) }\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1]) }\n     }\n }\n "}, {"sha": "f16cac05ea03993f6ce314ae289a6a8caec8b69c", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1639,7 +1639,7 @@ impl<T: Default> Vec<T> {\n     }\n }\n \n-// This code generalises `extend_with_{element,default}`.\n+// This code generalizes `extend_with_{element,default}`.\n trait ExtendWith<T> {\n     fn next(&mut self) -> T;\n     fn last(self) -> T;\n@@ -1837,7 +1837,7 @@ unsafe trait IsZero {\n }\n \n macro_rules! impl_is_zero {\n-    ($t: ty, $is_zero: expr) => {\n+    ($t:ty, $is_zero:expr) => {\n         unsafe impl IsZero for $t {\n             #[inline]\n             fn is_zero(&self) -> bool {\n@@ -2362,9 +2362,9 @@ macro_rules! __impl_slice_eq1 {\n __impl_slice_eq1! { [] Vec<A>, Vec<B>, }\n __impl_slice_eq1! { [] Vec<A>, &[B], }\n __impl_slice_eq1! { [] Vec<A>, &mut [B], }\n+__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n __impl_slice_eq1! { [] Cow<'_, [A]>, &[B], A: Clone }\n __impl_slice_eq1! { [] Cow<'_, [A]>, &mut [B], A: Clone }\n-__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n __impl_slice_eq1! { [const N: usize] Vec<A>, [B; N], [B; N]: LengthAtMost32 }\n __impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], [B; N]: LengthAtMost32 }\n "}, {"sha": "42c555cafac86f187ddeb681fe62eecf85e86c9d", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -19,6 +19,7 @@ path = \"../libcore/tests/lib.rs\"\n [[bench]]\n name = \"corebenches\"\n path = \"../libcore/benches/lib.rs\"\n+test = true\n \n [dev-dependencies]\n rand = \"0.7\""}, {"sha": "de4ef7949f344a6842fe1d7c8d2a3214f59e18a1", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1,3 +1,5 @@\n+// wasm32 does not support benches (no time).\n+#![cfg(not(target_arch = \"wasm32\"))]\n #![feature(flt2dec)]\n #![feature(test)]\n "}, {"sha": "8a957a729fb68b496a2efab490e0a7a45fca892a", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1,4 +1,4 @@\n-use self::EnumDiscriminantInfo::*;\n+use self::EnumTagInfo::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n \n@@ -40,7 +40,7 @@ use rustc_middle::{bug, span_bug};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::{Interner, Symbol};\n use rustc_span::{self, SourceFile, SourceFileHash, Span};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, HasDataLayout, Integer, LayoutOf};\n+use rustc_target::abi::{Abi, Align, HasDataLayout, Integer, LayoutOf, TagEncoding};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{Primitive, Size, VariantIdx, Variants};\n \n@@ -1335,7 +1335,7 @@ fn generator_layout_and_saved_local_names(\n struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyAndLayout<'tcx>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n }\n@@ -1385,7 +1385,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     cx,\n                     self.layout,\n                     variant_info,\n-                    NoDiscriminant,\n+                    NoTag,\n                     self_metadata,\n                     self.span,\n                 );\n@@ -1409,19 +1409,19 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 }]\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field,\n                 ref variants,\n                 ..\n             } => {\n-                let discriminant_info = if fallback {\n-                    RegularDiscriminant {\n-                        discr_field: Field::from(discr_index),\n-                        discr_type_metadata: self.discriminant_type_metadata.unwrap(),\n+                let tag_info = if fallback {\n+                    RegularTag {\n+                        tag_field: Field::from(tag_field),\n+                        tag_type_metadata: self.tag_type_metadata.unwrap(),\n                     }\n                 } else {\n                     // This doesn't matter in this case.\n-                    NoDiscriminant\n+                    NoTag\n                 };\n                 variants\n                     .iter_enumerated()\n@@ -1432,7 +1432,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                             cx,\n                             variant,\n                             variant_info,\n-                            discriminant_info,\n+                            tag_info,\n                             self_metadata,\n                             self.span,\n                         );\n@@ -1467,11 +1467,11 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     .collect()\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { ref niche_variants, niche_start, dataful_variant },\n-                ref discr,\n+                tag_encoding:\n+                    TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n+                ref tag,\n                 ref variants,\n-                discr_index,\n+                tag_field,\n             } => {\n                 if fallback {\n                     let variant = self.layout.for_variant(cx, dataful_variant);\n@@ -1480,7 +1480,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         variant,\n                         variant_info_for(dataful_variant),\n-                        OptimizedDiscriminant,\n+                        OptimizedTag,\n                         self.containing_scope,\n                         self.span,\n                     );\n@@ -1524,8 +1524,8 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                         cx,\n                         &mut name,\n                         self.layout,\n-                        self.layout.fields.offset(discr_index),\n-                        self.layout.field(cx, discr_index).size,\n+                        self.layout.fields.offset(tag_field),\n+                        self.layout.field(cx, tag_field).size,\n                     );\n                     variant_info_for(*niche_variants.start()).map_struct_name(|variant_name| {\n                         name.push_str(variant_name);\n@@ -1552,7 +1552,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                     cx,\n                                     variant,\n                                     variant_info,\n-                                    OptimizedDiscriminant,\n+                                    OptimizedTag,\n                                     self_metadata,\n                                     self.span,\n                                 );\n@@ -1573,7 +1573,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 let value = (i.as_u32() as u128)\n                                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                                     .wrapping_add(niche_start);\n-                                let value = truncate(value, discr.value.size(cx));\n+                                let value = truncate(value, tag.value.size(cx));\n                                 // NOTE(eddyb) do *NOT* remove this assert, until\n                                 // we pass the full 128-bit value to LLVM, otherwise\n                                 // truncation will be silent and remain undetected.\n@@ -1603,7 +1603,7 @@ struct VariantMemberDescriptionFactory<'ll, 'tcx> {\n     /// Cloned from the `layout::Struct` describing the variant.\n     offsets: Vec<Size>,\n     args: Vec<(String, Ty<'tcx>)>,\n-    discriminant_type_metadata: Option<&'ll DIType>,\n+    tag_type_metadata: Option<&'ll DIType>,\n     span: Span,\n }\n \n@@ -1617,7 +1617,7 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n                 MemberDescription {\n                     name: name.to_string(),\n                     type_metadata: if use_enum_fallback(cx) {\n-                        match self.discriminant_type_metadata {\n+                        match self.tag_type_metadata {\n                             // Discriminant is always the first field of our variant\n                             // when using the enum fallback.\n                             Some(metadata) if i == 0 => metadata,\n@@ -1637,11 +1637,14 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n+// FIXME: terminology here should be aligned with `abi::TagEncoding`.\n+// `OptimizedTag` is `TagEncoding::Niche`, `RegularTag` is `TagEncoding::Direct`.\n+// `NoTag` should be removed; users should use `Option<EnumTagInfo>` instead.\n #[derive(Copy, Clone)]\n-enum EnumDiscriminantInfo<'ll> {\n-    RegularDiscriminant { discr_field: Field, discr_type_metadata: &'ll DIType },\n-    OptimizedDiscriminant,\n-    NoDiscriminant,\n+enum EnumTagInfo<'ll> {\n+    RegularTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n+    OptimizedTag,\n+    NoTag,\n }\n \n #[derive(Copy, Clone)]\n@@ -1706,7 +1709,7 @@ fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n-    discriminant_info: EnumDiscriminantInfo<'ll>,\n+    discriminant_info: EnumTagInfo<'ll>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n@@ -1722,12 +1725,12 @@ fn describe_enum_variant(\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularDiscriminant { discr_field, .. } => {\n+            RegularTag { tag_field, .. } => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n-                let offset = enum_layout.fields.offset(discr_field.as_usize());\n+                let offset = enum_layout.fields.offset(tag_field.as_usize());\n                 let args =\n-                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, discr_field.as_usize()).ty);\n+                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n@@ -1757,8 +1760,8 @@ fn describe_enum_variant(\n     let member_description_factory = VariantMDF(VariantMemberDescriptionFactory {\n         offsets,\n         args,\n-        discriminant_type_metadata: match discriminant_info {\n-            RegularDiscriminant { discr_type_metadata, .. } => Some(discr_type_metadata),\n+        tag_type_metadata: match discriminant_info {\n+            RegularTag { tag_type_metadata, .. } => Some(tag_type_metadata),\n             _ => None,\n         },\n         span,\n@@ -1880,18 +1883,18 @@ fn prepare_enum_metadata(\n \n     if let (\n         &Abi::Scalar(_),\n-        &Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. },\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. },\n     ) = (&layout.abi, &layout.variants)\n     {\n-        return FinalMetadata(discriminant_type_metadata(discr.value));\n+        return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. }\n-            | Variants::Multiple { discr_kind: DiscriminantKind::Niche { .. }, .. } => None,\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, ref discr, .. } => {\n-                Some(discriminant_type_metadata(discr.value))\n+            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+                Some(discriminant_type_metadata(tag.value))\n             }\n         };\n \n@@ -1927,7 +1930,7 @@ fn prepare_enum_metadata(\n             EnumMDF(EnumMemberDescriptionFactory {\n                 enum_type,\n                 layout,\n-                discriminant_type_metadata,\n+                tag_type_metadata: discriminant_type_metadata,\n                 containing_scope,\n                 span,\n             }),\n@@ -1943,24 +1946,21 @@ fn prepare_enum_metadata(\n         Variants::Single { .. } => None,\n \n         Variants::Multiple {\n-            discr_kind: DiscriminantKind::Niche { .. },\n-            ref discr,\n-            discr_index,\n-            ..\n+            tag_encoding: TagEncoding::Niche { .. }, ref tag, tag_field, ..\n         } => {\n             // Find the integer type of the correct size.\n-            let size = discr.value.size(cx);\n-            let align = discr.value.align(cx);\n+            let size = tag.value.size(cx);\n+            let align = tag.value.align(cx);\n \n-            let discr_type = match discr.value {\n+            let tag_type = match tag.value {\n                 Int(t, _) => t,\n                 F32 => Integer::I32,\n                 F64 => Integer::I64,\n                 Pointer => cx.data_layout().ptr_sized_integer(),\n             }\n             .to_ty(cx.tcx, false);\n \n-            let discr_metadata = basic_type_metadata(cx, discr_type);\n+            let tag_metadata = basic_type_metadata(cx, tag_type);\n             unsafe {\n                 Some(llvm::LLVMRustDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -1971,17 +1971,15 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.abi.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n-                    discr_metadata,\n+                    tag_metadata,\n                 ))\n             }\n         }\n \n-        Variants::Multiple {\n-            discr_kind: DiscriminantKind::Tag, ref discr, discr_index, ..\n-        } => {\n-            let discr_type = discr.value.to_ty(cx.tcx);\n+        Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, tag_field, .. } => {\n+            let discr_type = tag.value.to_ty(cx.tcx);\n             let (size, align) = cx.size_and_align_of(discr_type);\n \n             let discr_metadata = basic_type_metadata(cx, discr_type);\n@@ -1995,7 +1993,7 @@ fn prepare_enum_metadata(\n                     UNKNOWN_LINE_NUMBER,\n                     size.bits(),\n                     align.bits() as u32,\n-                    layout.fields.offset(discr_index).bits(),\n+                    layout.fields.offset(tag_field).bits(),\n                     DIFlags::FlagArtificial,\n                     discr_metadata,\n                 ))\n@@ -2081,7 +2079,7 @@ fn prepare_enum_metadata(\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n             layout,\n-            discriminant_type_metadata: None,\n+            tag_type_metadata: None,\n             containing_scope,\n             span,\n         }),"}, {"sha": "1eef86f6c931c8e73daba26ac482c558456411da", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1075,6 +1075,10 @@ fn get_object_file_path(sess: &Session, name: &str) -> PathBuf {\n     if file_path.exists() {\n         return file_path;\n     }\n+    let file_path = fs.get_selfcontained_lib_path().join(name);\n+    if file_path.exists() {\n+        return file_path;\n+    }\n     for search_path in fs.search_paths() {\n         let file_path = search_path.dir.join(name);\n         if file_path.exists() {\n@@ -1470,6 +1474,9 @@ fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session) {\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();\n     cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n+\n+    let lib_path = sess.target_filesearch(PathKind::All).get_selfcontained_lib_path();\n+    cmd.include_path(&fix_windows_verbatim_for_gcc(&lib_path));\n }\n \n /// Add options making relocation sections in the produced ELF files read-only"}, {"sha": "0c8638b673d4fbdab5269a40588e22b2d458ba34", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::layout::{HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape, Int};\n+use rustc_target::abi::{Abi, Align, FieldsShape, Int, TagEncoding};\n use rustc_target::abi::{LayoutOf, VariantIdx, Variants};\n \n #[derive(Copy, Clone, Debug)]\n@@ -199,7 +199,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n-        let (discr_scalar, discr_kind, discr_index) = match self.layout.variants {\n+        let (tag_scalar, tag_encoding, tag_field) = match self.layout.variants {\n             Variants::Single { index } => {\n                 let discr_val = self\n                     .layout\n@@ -208,33 +208,33 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     .map_or(index.as_u32() as u128, |discr| discr.val);\n                 return bx.cx().const_uint_big(cast_to, discr_val);\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n         // Read the tag/niche-encoded discriminant from memory.\n-        let encoded_discr = self.project_field(bx, discr_index);\n-        let encoded_discr = bx.load_operand(encoded_discr);\n+        let tag = self.project_field(bx, tag_field);\n+        let tag = bx.load_operand(tag);\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n-        match *discr_kind {\n-            DiscriminantKind::Tag => {\n-                let signed = match discr_scalar.value {\n+        match *tag_encoding {\n+            TagEncoding::Direct => {\n+                let signed = match tag_scalar.value {\n                     // We use `i1` for bytes that are always `0` or `1`,\n                     // e.g., `#[repr(i8)] enum E { A, B }`, but we can't\n                     // let LLVM interpret the `i1` as signed, because\n                     // then `i1 1` (i.e., `E::B`) is effectively `i8 -1`.\n-                    Int(_, signed) => !discr_scalar.is_bool() && signed,\n+                    Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(encoded_discr.immediate(), cast_to, signed)\n+                bx.intcast(tag.immediate(), cast_to, signed)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Rebase from niche values to discriminants, and check\n                 // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(encoded_discr.layout);\n-                let encoded_discr = encoded_discr.immediate();\n+                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n+                let tag = tag.immediate();\n \n                 // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n                 // that is, if `n = niche_variants.end() - niche_variants.start()`,\n@@ -248,9 +248,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 let relative_discr = if niche_start == 0 {\n                     // Avoid subtracting `0`, which wouldn't work for pointers.\n                     // FIXME(eddyb) check the actual primitive type here.\n-                    encoded_discr\n+                    tag\n                 } else {\n-                    bx.sub(encoded_discr, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n                 };\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n                 let is_niche = {\n@@ -312,8 +312,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n             Variants::Single { index } => {\n                 assert_eq!(index, variant_index);\n             }\n-            Variants::Multiple { discr_kind: DiscriminantKind::Tag, discr_index, .. } => {\n-                let ptr = self.project_field(bx, discr_index);\n+            Variants::Multiple { tag_encoding: TagEncoding::Direct, tag_field, .. } => {\n+                let ptr = self.project_field(bx, tag_field);\n                 let to =\n                     self.layout.ty.discriminant_for_variant(bx.tcx(), variant_index).unwrap().val;\n                 bx.store(\n@@ -323,9 +323,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 );\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag_field,\n                 ..\n             } => {\n                 if variant_index != dataful_variant {\n@@ -339,7 +339,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                         bx.memset(self.llval, fill_byte, size, self.align, MemFlags::empty());\n                     }\n \n-                    let niche = self.project_field(bx, discr_index);\n+                    let niche = self.project_field(bx, tag_field);\n                     let niche_llty = bx.cx().immediate_backend_type(niche.layout);\n                     let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                     let niche_value = (niche_value as u128).wrapping_add(niche_start);"}, {"sha": "d1445f1b2c4a3c3b642cce36e0d18653cdf64141", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::{DiscriminantKind, Integer, LayoutOf, VariantIdx, Variants};\n+use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n use rustc_target::spec::abi::Abi;\n \n use log::debug;\n@@ -1056,15 +1056,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             };\n             let (variants, tag) = match layout.variants {\n                 Variants::Multiple {\n-                    discr_kind: DiscriminantKind::Tag,\n-                    ref discr,\n+                    tag_encoding: TagEncoding::Direct,\n+                    ref tag,\n                     ref variants,\n                     ..\n-                } => (variants, discr),\n+                } => (variants, tag),\n                 _ => return,\n             };\n \n-            let discr_size = tag.value.size(&cx.tcx).bytes();\n+            let tag_size = tag.value.size(&cx.tcx).bytes();\n \n             debug!(\n                 \"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n@@ -1078,8 +1078,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 .iter()\n                 .zip(variants)\n                 .map(|(variant, variant_layout)| {\n-                    // Subtract the size of the enum discriminant.\n-                    let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n+                    // Subtract the size of the enum tag.\n+                    let bytes = variant_layout.size.bytes().saturating_sub(tag_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\", variant.ident, bytes);\n                     bytes"}, {"sha": "57b14ac747f8d57f0f0ed391318849eaecff6c38", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -452,6 +452,14 @@ impl<'a> CrateLoader<'a> {\n         if dep.is_none() {\n             self.used_extern_options.insert(name);\n         }\n+        if !name.as_str().is_ascii() {\n+            self.sess\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"cannot load a crate with a non-ascii name `{}`\", name,),\n+                )\n+                .emit();\n+        }\n         self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n     }\n "}, {"sha": "abbbbf7fbd6a46bc3fde0b300403334fda4983d6", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -390,8 +390,8 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     InvalidBool(u8),\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n-    /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(Scalar),\n+    /// The tag of an enum does not encode an actual discriminant.\n+    InvalidTag(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,\n@@ -463,7 +463,7 @@ impl fmt::Display for UndefinedBehaviorInfo<'_> {\n             InvalidChar(c) => {\n                 write!(f, \"interpreting an invalid 32-bit value as a char: 0x{:08x}\", c)\n             }\n-            InvalidDiscriminant(val) => write!(f, \"enum value has invalid discriminant: {}\", val),\n+            InvalidTag(val) => write!(f, \"enum value has invalid tag: {}\", val),\n             InvalidFunctionPointer(p) => {\n                 write!(f, \"using {} as function pointer but it does not point to a function\", p)\n             }"}, {"sha": "80f919d0c032916f608ed0323a3e70efa175b5f3", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -974,13 +974,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                             return Ok(tcx.intern_layout(Layout {\n                                 variants: Variants::Multiple {\n-                                    discr: niche_scalar,\n-                                    discr_kind: DiscriminantKind::Niche {\n+                                    tag: niche_scalar,\n+                                    tag_encoding: TagEncoding::Niche {\n                                         dataful_variant: i,\n                                         niche_variants,\n                                         niche_start,\n                                     },\n-                                    discr_index: 0,\n+                                    tag_field: 0,\n                                     variants: st,\n                                 },\n                                 fields: FieldsShape::Arbitrary {\n@@ -1216,9 +1216,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 tcx.intern_layout(Layout {\n                     variants: Variants::Multiple {\n-                        discr: tag,\n-                        discr_kind: DiscriminantKind::Tag,\n-                        discr_index: 0,\n+                        tag,\n+                        tag_encoding: TagEncoding::Direct,\n+                        tag_field: 0,\n                         variants: layout_variants,\n                     },\n                     fields: FieldsShape::Arbitrary {\n@@ -1399,15 +1399,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Build a prefix layout, including \"promoting\" all ineligible\n         // locals as part of the prefix. We compute the layout of all of\n         // these fields at once to get optimal packing.\n-        let discr_index = substs.as_generator().prefix_tys().count();\n+        let tag_index = substs.as_generator().prefix_tys().count();\n \n         // `info.variant_fields` already accounts for the reserved variants, so no need to add them.\n         let max_discr = (info.variant_fields.len() - 1) as u128;\n         let discr_int = Integer::fit_unsigned(max_discr);\n         let discr_int_ty = discr_int.to_ty(tcx, false);\n-        let discr = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n-        let discr_layout = self.tcx.intern_layout(Layout::scalar(self, discr.clone()));\n-        let discr_layout = TyAndLayout { ty: discr_int_ty, layout: discr_layout };\n+        let tag = Scalar { value: Primitive::Int(discr_int, false), valid_range: 0..=max_discr };\n+        let tag_layout = self.tcx.intern_layout(Layout::scalar(self, tag.clone()));\n+        let tag_layout = TyAndLayout { ty: discr_int_ty, layout: tag_layout };\n \n         let promoted_layouts = ineligible_locals\n             .iter()\n@@ -1418,7 +1418,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             .as_generator()\n             .prefix_tys()\n             .map(|ty| self.layout_of(ty))\n-            .chain(iter::once(Ok(discr_layout)))\n+            .chain(iter::once(Ok(tag_layout)))\n             .chain(promoted_layouts)\n             .collect::<Result<Vec<_>, _>>()?;\n         let prefix = self.univariant_uninterned(\n@@ -1441,7 +1441,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 // \"a\" (`0..b_start`) and \"b\" (`b_start..`) correspond to\n                 // \"outer\" and \"promoted\" fields respectively.\n-                let b_start = (discr_index + 1) as u32;\n+                let b_start = (tag_index + 1) as u32;\n                 let offsets_b = offsets.split_off(b_start as usize);\n                 let offsets_a = offsets;\n \n@@ -1558,9 +1558,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n         let layout = tcx.intern_layout(Layout {\n             variants: Variants::Multiple {\n-                discr,\n-                discr_kind: DiscriminantKind::Tag,\n-                discr_index,\n+                tag: tag,\n+                tag_encoding: TagEncoding::Direct,\n+                tag_field: tag_index,\n                 variants,\n             },\n             fields: outer_fields,\n@@ -1680,7 +1680,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n             }\n \n-            Variants::Multiple { ref discr, ref discr_kind, .. } => {\n+            Variants::Multiple { ref tag, ref tag_encoding, .. } => {\n                 debug!(\n                     \"print-type-size `{:#?}` adt general variants def {}\",\n                     layout.ty,\n@@ -1702,8 +1702,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 record(\n                     adt_kind.into(),\n                     adt_packed,\n-                    match discr_kind {\n-                        DiscriminantKind::Tag => Some(discr.value.size(self)),\n+                    match tag_encoding {\n+                        TagEncoding::Direct => Some(tag.value.size(self)),\n                         _ => None,\n                     },\n                     variant_infos,\n@@ -2028,11 +2028,11 @@ where\n \n     fn field(this: TyAndLayout<'tcx>, cx: &C, i: usize) -> C::TyAndLayout {\n         let tcx = cx.tcx();\n-        let discr_layout = |discr: &Scalar| -> C::TyAndLayout {\n-            let layout = Layout::scalar(cx, discr.clone());\n+        let tag_layout = |tag: &Scalar| -> C::TyAndLayout {\n+            let layout = Layout::scalar(cx, tag.clone());\n             MaybeResult::from(Ok(TyAndLayout {\n                 layout: tcx.intern_layout(layout),\n-                ty: discr.value.to_ty(tcx),\n+                ty: tag.value.to_ty(tcx),\n             }))\n         };\n \n@@ -2109,9 +2109,9 @@ where\n                     .unwrap()\n                     .nth(i)\n                     .unwrap(),\n-                Variants::Multiple { ref discr, discr_index, .. } => {\n-                    if i == discr_index {\n-                        return discr_layout(discr);\n+                Variants::Multiple { ref tag, tag_field, .. } => {\n+                    if i == tag_field {\n+                        return tag_layout(tag);\n                     }\n                     substs.as_generator().prefix_tys().nth(i).unwrap()\n                 }\n@@ -2128,9 +2128,9 @@ where\n                     Variants::Single { index } => def.variants[index].fields[i].ty(tcx, substs),\n \n                     // Discriminant field for enums (where applicable).\n-                    Variants::Multiple { ref discr, .. } => {\n+                    Variants::Multiple { ref tag, .. } => {\n                         assert_eq!(i, 0);\n-                        return discr_layout(discr);\n+                        return tag_layout(tag);\n                     }\n                 }\n             }\n@@ -2207,10 +2207,10 @@ where\n                     // using more niches than just null (e.g., the first page of\n                     // the address space, or unaligned pointers).\n                     Variants::Multiple {\n-                        discr_kind: DiscriminantKind::Niche { dataful_variant, .. },\n-                        discr_index,\n+                        tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+                        tag_field,\n                         ..\n-                    } if this.fields.offset(discr_index) == offset => {\n+                    } if this.fields.offset(tag_field) == offset => {\n                         Some(this.for_variant(cx, dataful_variant))\n                     }\n                     _ => Some(this),"}, {"sha": "cab13d379a2ccead0845ab7735d5ae4aaedf30e9", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -293,7 +293,6 @@ pub enum InternKind {\n     Static(hir::Mutability),\n     Constant,\n     Promoted,\n-    ConstProp,\n }\n \n /// Intern `ret` and everything it references.\n@@ -314,9 +313,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     let base_intern_mode = match intern_kind {\n         InternKind::Static(mutbl) => InternMode::Static(mutbl),\n         // FIXME: what about array lengths, array initializers?\n-        InternKind::Constant | InternKind::ConstProp | InternKind::Promoted => {\n-            InternMode::ConstBase\n-        }\n+        InternKind::Constant | InternKind::Promoted => InternMode::ConstBase,\n     };\n \n     // Type based interning.\n@@ -358,7 +355,10 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             Err(error) => {\n                 ecx.tcx.sess.delay_span_bug(\n                     ecx.tcx.span,\n-                    \"error during interning should later cause validation failure\",\n+                    &format!(\n+                        \"error during interning should later cause validation failure: {}\",\n+                        error\n+                    ),\n                 );\n                 // Some errors shouldn't come up because creating them causes\n                 // an allocation, which we should avoid. When that happens,\n@@ -399,7 +399,7 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n                     // immutability is so important.\n                     alloc.mutability = Mutability::Not;\n                 }\n-                InternKind::Constant | InternKind::ConstProp => {\n+                InternKind::Constant => {\n                     // If it's a constant, we should not have any \"leftovers\" as everything\n                     // is tracked by const-checking.\n                     // FIXME: downgrade this to a warning? It rejects some legitimate consts,"}, {"sha": "35e433c4bd5cd28a3b20844619fce6db1f27297e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n+use rustc_target::abi::{Abi, HasDataLayout, LayoutOf, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n@@ -587,7 +587,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", op.layout);\n-\n         // Get type and layout of the discriminant.\n         let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n         trace!(\"discriminant type: {:?}\", discr_layout.ty);\n@@ -596,10 +595,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This is not to be confused with its \"variant index\", which is just determining its position in the\n         // declared list of variants -- they can differ with explicitly assigned discriminants.\n         // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n-        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n-        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n-        // rather confusing.\n-        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n+        // straight-forward (`TagEncoding::Direct`) or with a niche (`TagEncoding::Niche`).\n+        let (tag_scalar_layout, tag_encoding, tag_field) = match op.layout.variants {\n             Variants::Single { index } => {\n                 let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n@@ -615,8 +612,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 return Ok((discr, index));\n             }\n-            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n-                (discr, discr_kind, discr_index)\n+            Variants::Multiple { ref tag, ref tag_encoding, tag_field, .. } => {\n+                (tag, tag_encoding, tag_field)\n             }\n         };\n \n@@ -633,21 +630,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n         // Read tag and sanity-check `tag_layout`.\n-        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_field)?)?;\n         assert_eq!(tag_layout.size, tag_val.layout.size);\n         assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n         let tag_val = tag_val.to_scalar()?;\n         trace!(\"tag value: {:?}\", tag_val);\n \n         // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *tag_kind {\n-            DiscriminantKind::Tag => {\n+        Ok(match *tag_encoding {\n+            TagEncoding::Direct => {\n                 let tag_bits = self\n                     .force_bits(tag_val, tag_layout.size)\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                    .map_err(|_| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Cast bits from tag layout to discriminant layout.\n-                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n-                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n+                let discr_bits = discr_val.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n@@ -661,11 +658,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                .ok_or_else(|| err_ub!(InvalidTag(tag_val.erase_tag())))?;\n                 // Return the cast value, and the index.\n-                (discr_val_cast, index.0)\n+                (discr_val, index.0)\n             }\n-            DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+            TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n@@ -677,7 +674,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n+                            throw_ub!(InvalidTag(tag_val.erase_tag()))\n                         }\n                         dataful_variant\n                     }"}, {"sha": "396aec0a8f89f79a49d549ab07c0f5ac525c0519", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -9,7 +9,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::{self, Ty};\n-use rustc_target::abi::{Abi, Align, DiscriminantKind, FieldsShape};\n+use rustc_target::abi::{Abi, Align, FieldsShape, TagEncoding};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, VariantIdx, Variants};\n \n use super::{\n@@ -1045,7 +1045,8 @@ where\n         MPlaceTy { mplace, layout }\n     }\n \n-    pub fn write_discriminant_index(\n+    /// Writes the discriminant of the given variant.\n+    pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n@@ -1061,9 +1062,9 @@ where\n                 assert_eq!(index, variant_index);\n             }\n             Variants::Multiple {\n-                discr_kind: DiscriminantKind::Tag,\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding: TagEncoding::Direct,\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1075,17 +1076,17 @@ where\n                 // raw discriminants for enums are isize or bigger during\n                 // their computation, but the in-memory tag is the smallest possible\n                 // representation\n-                let size = discr_layout.value.size(self);\n-                let discr_val = truncate(discr_val, size);\n+                let size = tag_layout.value.size(self);\n+                let tag_val = truncate(discr_val, size);\n \n-                let discr_dest = self.place_field(dest, discr_index)?;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n+                let tag_dest = self.place_field(dest, tag_field)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;\n             }\n             Variants::Multiple {\n-                discr_kind:\n-                    DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start },\n-                discr: ref discr_layout,\n-                discr_index,\n+                tag_encoding:\n+                    TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start },\n+                tag: ref tag_layout,\n+                tag_field,\n                 ..\n             } => {\n                 // No need to validate that the discriminant here because the\n@@ -1098,19 +1099,19 @@ where\n                         .checked_sub(variants_start)\n                         .expect(\"overflow computing relative variant idx\");\n                     // We need to use machine arithmetic when taking into account `niche_start`:\n-                    // discr_val = variant_index_relative + niche_start_val\n-                    let discr_layout = self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                    let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                    // tag_val = variant_index_relative + niche_start_val\n+                    let tag_layout = self.layout_of(tag_layout.value.to_int_ty(*self.tcx))?;\n+                    let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                     let variant_index_relative_val =\n-                        ImmTy::from_uint(variant_index_relative, discr_layout);\n-                    let discr_val = self.binary_op(\n+                        ImmTy::from_uint(variant_index_relative, tag_layout);\n+                    let tag_val = self.binary_op(\n                         mir::BinOp::Add,\n                         variant_index_relative_val,\n                         niche_start_val,\n                     )?;\n                     // Write result.\n-                    let niche_dest = self.place_field(dest, discr_index)?;\n-                    self.write_immediate(*discr_val, niche_dest)?;\n+                    let niche_dest = self.place_field(dest, tag_field)?;\n+                    self.write_immediate(*tag_val, niche_dest)?;\n                 }\n             }\n         }"}, {"sha": "18f9bbd2e315086bdb978d3eb11da7811a47e537", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -88,7 +88,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             SetDiscriminant { place, variant_index } => {\n                 let dest = self.eval_place(**place)?;\n-                self.write_discriminant_index(*variant_index, dest)?;\n+                self.write_discriminant(*variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -179,7 +179,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant_index(variant_index, dest)?;\n+                        self.write_discriminant(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {"}, {"sha": "3bb9ba37120582fda0f770298e2daa4ba3c84c98", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -208,8 +208,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     fn aggregate_field_path_elem(&mut self, layout: TyAndLayout<'tcx>, field: usize) -> PathElem {\n         // First, check if we are projecting to a variant.\n         match layout.variants {\n-            Variants::Multiple { discr_index, .. } => {\n-                if discr_index == field {\n+            Variants::Multiple { tag_field, .. } => {\n+                if tag_field == field {\n                     return match layout.ty.kind {\n                         ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n                         ty::Generator(..) => PathElem::GeneratorTag,\n@@ -697,8 +697,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         try_validation!(\n             self.walk_value(op),\n             self.path,\n-            err_ub!(InvalidDiscriminant(val)) =>\n-                { \"{}\", val } expected { \"a valid enum discriminant\" },\n+            err_ub!(InvalidTag(val)) =>\n+                { \"{}\", val } expected { \"a valid enum tag\" },\n             err_unsup!(ReadPointerAsBytes) =>\n                 { \"a pointer\" } expected { \"plain (non-pointer) bytes\" },\n         );"}, {"sha": "17ca918d32c9f6e3438a43bef0c0b545d04aec9b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -27,9 +27,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, compile_time_machine, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy,\n-    Immediate, InternKind, InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy,\n-    Operand as InterpOperand, PlaceTy, Pointer, ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n+    LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n+    ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -702,11 +702,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 ScalarMaybeUninit::Scalar(l),\n                 ScalarMaybeUninit::Scalar(r),\n             )) => l.is_bits() && r.is_bits(),\n-            interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n-                let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false);\n-                true\n-            }\n             _ => false,\n         }\n     }"}, {"sha": "5586b82b0edc082f8c5001b0516ee001b5963a52", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -41,6 +41,10 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n+    pub fn get_selfcontained_lib_path(&self) -> PathBuf {\n+        self.get_lib_path().join(\"self-contained\")\n+    }\n+\n     pub fn search<F>(&self, mut pick: F)\n     where\n         F: FnMut(&SearchPathFile, PathKind) -> FileMatch,\n@@ -94,7 +98,7 @@ impl<'a> FileSearch<'a> {\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        vec![p]\n+        vec![p.clone(), p.join(\"self-contained\")]\n     }\n }\n "}, {"sha": "5a8f5c1b9fbca8685a1caf87f5c12624ab1fcdcc", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -534,6 +534,16 @@ declare_lint! {\n     @feature_gate = sym::unsafe_block_in_unsafe_fn;\n }\n \n+declare_lint! {\n+    pub CENUM_IMPL_DROP_CAST,\n+    Warn,\n+    \"a C-like enum implementing Drop is cast\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #73333 <https://github.com/rust-lang/rust/issues/73333>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -607,6 +617,7 @@ declare_lint_pass! {\n         ASM_SUB_REGISTER,\n         UNSAFE_OP_IN_UNSAFE_FN,\n         INCOMPLETE_INCLUDE,\n+        CENUM_IMPL_DROP_CAST,\n     ]\n }\n "}, {"sha": "c79e9bb28900882ed0a41860f628a477d56b16a8", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -809,25 +809,30 @@ pub enum Variants {\n     /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n     Single { index: VariantIdx },\n \n-    /// Enum-likes with more than one inhabited variant: for each case there is\n-    /// a struct, and they all have space reserved for the discriminant.\n-    /// For enums this is the sole field of the layout.\n+    /// Enum-likes with more than one inhabited variant: each variant comes with\n+    /// a *discriminant* (usually the same as the variant index but the user can\n+    /// assign explicit discriminant values).  That discriminant is encoded\n+    /// as a *tag* on the machine.  The layout of each variant is\n+    /// a struct, and they all have space reserved for the tag.\n+    /// For enums, the tag is the sole field of the layout.\n     Multiple {\n-        discr: Scalar,\n-        discr_kind: DiscriminantKind,\n-        discr_index: usize,\n+        tag: Scalar,\n+        tag_encoding: TagEncoding,\n+        tag_field: usize,\n         variants: IndexVec<VariantIdx, Layout>,\n     },\n }\n \n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n-pub enum DiscriminantKind {\n-    /// Integer tag holding the discriminant value itself.\n-    Tag,\n+pub enum TagEncoding {\n+    /// The tag directly stores the discriminant, but possibly with a smaller layout\n+    /// (so converting the tag to the discriminant can require sign extension).\n+    Direct,\n \n     /// Niche (values invalid for a type) encoding the discriminant:\n-    /// the variant `dataful_variant` contains a niche at an arbitrary\n-    /// offset (field `discr_index` of the enum), which for a variant with\n+    /// Discriminant and variant index coincide.\n+    /// The variant `dataful_variant` contains a niche at an arbitrary\n+    /// offset (field `tag_field` of the enum), which for a variant with\n     /// discriminant `d` is set to\n     /// `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///"}, {"sha": "3a22290da68583ceef070dcdfa1898d6237b42b5", "filename": "src/librustc_target/spec/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_linux_musl.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -6,6 +6,7 @@ pub fn target() -> TargetResult {\n     base.max_atomic_width = Some(64);\n     base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n     base.stack_probes = true;\n+    base.static_position_independent_executables = true;\n \n     Ok(Target {\n         llvm_target: \"x86_64-unknown-linux-musl\".to_string(),"}, {"sha": "1ea7bf25ef2ed67436f99a84f428ef3c200efe8a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -678,7 +678,10 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n \n             // prim -> prim\n-            (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),\n+            (Int(CEnum), Int(_)) => {\n+                self.cenum_impl_drop_lint(fcx);\n+                Ok(CastKind::EnumCast)\n+            }\n             (Int(Char) | Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n@@ -775,11 +778,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 // Coerce to a raw pointer so that we generate AddressOf in MIR.\n                 let array_ptr_type = fcx.tcx.mk_ptr(m_expr);\n                 fcx.try_coerce(self.expr, self.expr_ty, array_ptr_type, AllowTwoPhase::No)\n-                    .unwrap_or_else(|_| bug!(\n+                    .unwrap_or_else(|_| {\n+                        bug!(\n                         \"could not cast from reference to array to pointer to array ({:?} to {:?})\",\n                         self.expr_ty,\n                         array_ptr_type,\n-                    ));\n+                    )\n+                    });\n \n                 // this will report a type mismatch if needed\n                 fcx.demand_eqtype(self.span, ety, m_cast.ty);\n@@ -809,6 +814,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             Err(err) => Err(err),\n         }\n     }\n+\n+    fn cenum_impl_drop_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+        if let ty::Adt(d, _) = self.expr_ty.kind {\n+            if d.has_dtor(fcx.tcx) {\n+                fcx.tcx.struct_span_lint_hir(\n+                    lint::builtin::CENUM_IMPL_DROP_CAST,\n+                    self.expr.hir_id,\n+                    self.span,\n+                    |err| {\n+                        err.build(&format!(\n+                            \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                            self.expr_ty, self.cast_ty\n+                        ))\n+                        .emit();\n+                    },\n+                );\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "490afb5a0438f9088c545d4ede084e4b3797d927", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -74,3 +74,8 @@ std_detect_dlsym_getauxval = []\n threads = 125\n # Maximum heap size\n heap_size = 0x8000000\n+\n+[[bench]]\n+name = \"stdbenches\"\n+path = \"benches/lib.rs\"\n+test = true"}, {"sha": "b392d6e7226d2d7bba2080ebefae53cd89626c45", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -832,11 +832,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f32 {\n-        if self == Self::NEG_INFINITY {\n-            Self::NEG_INFINITY\n-        } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n-        }\n+        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -1413,6 +1409,8 @@ mod tests {\n         assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n         assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n         assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n+        // regression test for the catastrophic cancellation fixed in 72486\n+        assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n     }\n \n     #[test]"}, {"sha": "72268d2cc2f984be863501d2e4df84197d3fbb61", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -834,11 +834,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn asinh(self) -> f64 {\n-        if self == Self::NEG_INFINITY {\n-            Self::NEG_INFINITY\n-        } else {\n-            (self + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n-        }\n+        (self.abs() + ((self * self) + 1.0).sqrt()).ln().copysign(self)\n     }\n \n     /// Inverse hyperbolic cosine function.\n@@ -1442,6 +1438,8 @@ mod tests {\n         // issue 63271\n         assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n         assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n+        // regression test for the catastrophic cancellation fixed in 72486\n+        assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n     }\n \n     #[test]"}, {"sha": "e4d714936047e71b03807c2afc5e24deb6eb87a7", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -242,7 +242,8 @@ pub trait PermissionsExt {\n     ///     let permissions = metadata.permissions();\n     ///\n     ///     println!(\"permissions: {:o}\", permissions.mode());\n-    ///     Ok(()) }\n+    ///     Ok(())\n+    /// }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&self) -> u32;\n@@ -262,7 +263,8 @@ pub trait PermissionsExt {\n     ///\n     ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n     ///     assert_eq!(permissions.mode(), 0o644);\n-    ///     Ok(()) }\n+    ///     Ok(())\n+    /// }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn set_mode(&mut self, mode: u32);"}, {"sha": "323bd26c698a33e2cb72815d5ab444d44893035d", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -424,6 +424,12 @@ extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n   printf(\"Available features for this target:\\n\");\n   for (auto &Feature : FeatTable)\n     printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n+  printf(\"\\nRust-specific features:\\n\");\n+  printf(\"    %-*s - %s.\\n\",\n+    MaxFeatLen,\n+    \"crt-static\",\n+    \"Enables libraries with C Run-time Libraries(CRT) to be statically linked\"\n+  );\n   printf(\"\\n\");\n \n   printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\""}, {"sha": "8ade583b5712732466153f2161f43fa49d0d7141", "filename": "src/test/codegen/issue-69101-bounds-check.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-69101-bounds-check.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,44 @@\n+// no-system-llvm\n+// compile-flags: -O\n+// ignore-debug: the debug assertions get in the way\n+#![crate_type = \"lib\"]\n+\n+// Make sure no bounds checks are emitted in the loop when upfront slicing\n+// ensures that the slices are big enough.\n+// In particular, bounds checks were not always optimized out if the upfront\n+// check was for a greater len than the loop requires.\n+// (i.e. `already_sliced_no_bounds_check` was not always optimized even when\n+// `already_sliced_no_bounds_check_exact` was)\n+// CHECK-LABEL: @already_sliced_no_bounds_check\n+#[no_mangle]\n+pub fn already_sliced_no_bounds_check(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK-NOT: panic_bounds_check\n+    let _ = (&a[..2048], &b[..2048], &mut c[..2048]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}\n+\n+// CHECK-LABEL: @already_sliced_no_bounds_check_exact\n+#[no_mangle]\n+pub fn already_sliced_no_bounds_check_exact(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK-NOT: panic_bounds_check\n+    let _ = (&a[..1024], &b[..1024], &mut c[..1024]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}\n+\n+// Make sure we're checking for the right thing: there can be a panic if the slice is too small.\n+// CHECK-LABEL: @already_sliced_bounds_check\n+#[no_mangle]\n+pub fn already_sliced_bounds_check(a: &[u8], b: &[u8], c: &mut [u8]) {\n+    // CHECK: slice_index_len_fail\n+    // CHECK: panic_bounds_check\n+    let _ = (&a[..1023], &b[..2048], &mut c[..2048]);\n+    for i in 0..1024 {\n+        c[i] = a[i] ^ b[i];\n+    }\n+}"}, {"sha": "13e8eb3e44e1aeb03471c8e2506a38b054bd7601", "filename": "src/test/mir-opt/const_prop/discriminant.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -1,5 +1,10 @@\n // compile-flags: -O\n \n+// FIXME(wesleywiser): Ideally, we could const-prop away all of this and just be left with\n+// `let x = 42` but that doesn't work because const-prop doesn't support `Operand::Indirect`\n+// and `InterpCx::eval_place()` always forces an allocation which creates the `Indirect`.\n+// Fixing either of those will allow us to const-prop this away.\n+\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n // EMIT_MIR rustc.main.ConstProp.diff\n fn main() {"}, {"sha": "1c873f53f378a1fa4962928eac7be68df58490c8", "filename": "src/test/mir-opt/const_prop/discriminant/32bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F32bit%2Frustc.main.ConstProp.diff?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -2,100 +2,93 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:5:11: 5:11\n-      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:6:21: 6:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:10:11: 10:11\n+      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:11:21: 11:31\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:6:9: 6:10\n+          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:11:9: 11:10\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n--         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-+         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n+          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+-         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n++         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n                                            // ty::Const\n -                                          // + ty: bool\n +                                          // + ty: std::option::Option<bool>\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n--                                          // + span: $DIR/discriminant.rs:6:39: 6:43\n+-                                          // + span: $DIR/discriminant.rs:11:39: 11:43\n -                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n--         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n--         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n-+                                          // + span: $DIR/discriminant.rs:6:34: 6:44\n+-         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n+-         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n++                                          // + span: $DIR/discriminant.rs:11:34: 11:44\n +                                          // + literal: Const { ty: std::option::Option<bool>, val: Value(Scalar(0x01)) }\n-+         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x00000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x00000001)) }\n-+         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x00000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x00000001)) }\n       }\n   \n       bb1: {\n-          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:6:59: 6:61\n+          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:11:59: 11:61\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000000a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:59: 6:61\n+                                           // + span: $DIR/discriminant.rs:11:59: 11:61\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000000a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb2: {\n--         switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+         switchInt(const true) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x01))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:26: 6:30\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:11:26: 11:30\n       }\n   \n       bb3: {\n-          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:6:47: 6:49\n+          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:11:47: 11:49\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:47: 6:49\n+                                           // + span: $DIR/discriminant.rs:11:47: 11:49\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb4: {\n-          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:6:13: 6:68\n+          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:11:13: 11:68\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000000))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:67: 6:68\n+                                           // + span: $DIR/discriminant.rs:11:67: 11:68\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:6:67: 6:68\n-          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:6:68: 6:69\n-          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:5:11: 7:2\n+          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:11:67: 11:68\n+          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:11:68: 11:69\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:10:11: 12:2\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:5:11: 7:2\n+                                           // + span: $DIR/discriminant.rs:10:11: 12:2\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:7:1: 7:2\n-          return;                          // scope 0 at $DIR/discriminant.rs:7:2: 7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:12:1: 12:2\n+          return;                          // scope 0 at $DIR/discriminant.rs:12:2: 12:2\n       }\n   }\n   "}, {"sha": "75b4b7e5a62bab836ca891969e06599a1278a3fd", "filename": "src/test/mir-opt/const_prop/discriminant/64bit/rustc.main.ConstProp.diff", "status": "modified", "additions": 34, "deletions": 41, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fdiscriminant%2F64bit%2Frustc.main.ConstProp.diff?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -2,100 +2,93 @@\n + // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:5:11: 5:11\n-      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:6:21: 6:31\n+      let mut _0: ();                      // return place in scope 0 at $DIR/discriminant.rs:10:11: 10:11\n+      let _1: i32;                         // in scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+      let mut _3: std::option::Option<bool>; // in scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+      let mut _4: isize;                   // in scope 0 at $DIR/discriminant.rs:11:21: 11:31\n       scope 1 {\n-          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:6:9: 6:10\n+          debug x => _1;                   // in scope 1 at $DIR/discriminant.rs:11:9: 11:10\n       }\n   \n       bb0: {\n-          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:6:9: 6:10\n-          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n-          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n--         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n-+         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:6:34: 6:44\n+          StorageLive(_1);                 // scope 0 at $DIR/discriminant.rs:11:9: 11:10\n+          StorageLive(_2);                 // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n+          StorageLive(_3);                 // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n+-         _3 = std::option::Option::<bool>::Some(const true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n++         _3 = const std::option::Option::<bool>::Some(true); // scope 0 at $DIR/discriminant.rs:11:34: 11:44\n                                            // ty::Const\n -                                          // + ty: bool\n +                                          // + ty: std::option::Option<bool>\n                                            // + val: Value(Scalar(0x01))\n                                            // mir::Constant\n--                                          // + span: $DIR/discriminant.rs:6:39: 6:43\n+-                                          // + span: $DIR/discriminant.rs:11:39: 11:43\n -                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n--         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n--         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n-+                                          // + span: $DIR/discriminant.rs:6:34: 6:44\n+-         _4 = discriminant(_3);           // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n+-         switchInt(move _4) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n++                                          // + span: $DIR/discriminant.rs:11:34: 11:44\n +                                          // + literal: Const { ty: std::option::Option<bool>, val: Value(Scalar(0x01)) }\n-+         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         _4 = const 1isize;               // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x0000000000000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000001)) }\n-+         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:6:21: 6:31\n++         switchInt(const 1isize) -> [1isize: bb2, otherwise: bb1]; // scope 0 at $DIR/discriminant.rs:11:21: 11:31\n +                                          // ty::Const\n +                                          // + ty: isize\n +                                          // + val: Value(Scalar(0x0000000000000001))\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:21: 6:31\n++                                          // + span: $DIR/discriminant.rs:11:21: 11:31\n +                                          // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000001)) }\n       }\n   \n       bb1: {\n-          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:6:59: 6:61\n+          _2 = const 10i32;                // scope 0 at $DIR/discriminant.rs:11:59: 11:61\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000000a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:59: 6:61\n+                                           // + span: $DIR/discriminant.rs:11:59: 11:61\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000000a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb2: {\n--         switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+         switchInt(const true) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:6:26: 6:30\n-+                                          // ty::Const\n-+                                          // + ty: bool\n-+                                          // + val: Value(Scalar(0x01))\n-+                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:6:26: 6:30\n-+                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          switchInt(((_3 as Some).0: bool)) -> [false: bb1, otherwise: bb3]; // scope 0 at $DIR/discriminant.rs:11:26: 11:30\n       }\n   \n       bb3: {\n-          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:6:47: 6:49\n+          _2 = const 42i32;                // scope 0 at $DIR/discriminant.rs:11:47: 11:49\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:47: 6:49\n+                                           // + span: $DIR/discriminant.rs:11:47: 11:49\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n-          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:6:13: 6:64\n+          goto -> bb4;                     // scope 0 at $DIR/discriminant.rs:11:13: 11:64\n       }\n   \n       bb4: {\n-          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:6:13: 6:68\n+          _1 = Add(move _2, const 0i32);   // scope 0 at $DIR/discriminant.rs:11:13: 11:68\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000000))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:6:67: 6:68\n+                                           // + span: $DIR/discriminant.rs:11:67: 11:68\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n-          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:6:67: 6:68\n-          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:6:68: 6:69\n-          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:5:11: 7:2\n+          StorageDead(_2);                 // scope 0 at $DIR/discriminant.rs:11:67: 11:68\n+          StorageDead(_3);                 // scope 0 at $DIR/discriminant.rs:11:68: 11:69\n+          _0 = const ();                   // scope 0 at $DIR/discriminant.rs:10:11: 12:2\n                                            // ty::Const\n                                            // + ty: ()\n                                            // + val: Value(Scalar(<ZST>))\n                                            // mir::Constant\n-                                           // + span: $DIR/discriminant.rs:5:11: 7:2\n+                                           // + span: $DIR/discriminant.rs:10:11: 12:2\n                                            // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:7:1: 7:2\n-          return;                          // scope 0 at $DIR/discriminant.rs:7:2: 7:2\n+          StorageDead(_1);                 // scope 0 at $DIR/discriminant.rs:12:1: 12:2\n+          return;                          // scope 0 at $DIR/discriminant.rs:12:2: 12:2\n       }\n   }\n   "}, {"sha": "1d3cc82138927a1018c97a10d2814b05814a6602", "filename": "src/test/run-make/static-pie/Makefile", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-pie%2FMakefile?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,15 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+# only-x86_64-unknown-linux-musl\n+\n+# How to manually run this\n+# $ ./x.py test --target x86_64-unknown-linux-musl src/test/run-make/static-pie\n+\n+all:\n+\t$(RUSTC) --target $(TARGET) -C target-feature=+crt-static test-aslr.rs\n+\t# Check that no dynamic interpreter is set\n+\t! readelf -l $(call RUN_BINFILE,test-aslr) | $(CGREP) INTERP\n+\t# Check that we have a dynamic executable\n+\treadelf -l $(call RUN_BINFILE,test-aslr) | $(CGREP) DYNAMIC\n+\t# Check for address space layout randomization\n+\t$(call RUN,test-aslr) --test-aslr"}, {"sha": "f28e00f7f4cf93825df45defa08944b1fee17251", "filename": "src/test/run-make/static-pie/test-aslr.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-pie%2Ftest-aslr.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,43 @@\n+const NUM_RUNS: usize = 10;\n+\n+fn run_self(exe: &str) -> usize {\n+    use std::process::Command;\n+    let mut set = std::collections::HashSet::new();\n+\n+    let mut cmd = Command::new(exe);\n+    cmd.arg(\"--report\");\n+    (0..NUM_RUNS).for_each(|_| {\n+        set.insert(cmd.output().expect(\"failed to execute process\").stdout);\n+    });\n+    set.len()\n+}\n+\n+fn main() {\n+    let mut args = std::env::args();\n+    let arg0 = args.next().unwrap();\n+    match args.next() {\n+        Some(s) if s.eq(\"--report\") => {\n+            println!(\"main = {:#?}\", &main as *const _);\n+        }\n+        Some(s) if s.eq(\"--test-no-aslr\") => {\n+            let cnt = run_self(&arg0);\n+            if cnt != 1 {\n+                eprintln!(\"FAIL: {} most likely ASLR\", arg0);\n+                std::process::exit(1);\n+            }\n+            println!(\"PASS: {} does no ASLR\", arg0);\n+        }\n+        Some(s) if s.eq(\"--test-aslr\") => {\n+            let cnt = run_self(&arg0);\n+            if cnt != NUM_RUNS {\n+                eprintln!(\"FAIL: {} most likely no ASLR\", arg0);\n+                std::process::exit(1);\n+            }\n+            println!(\"PASS: {} does ASLR\", arg0);\n+        }\n+        Some(_) | None => {\n+            println!(\"Usage: {} --test-no-aslr | --test-aslr\", arg0);\n+            std::process::exit(1);\n+        }\n+    }\n+}"}, {"sha": "96e3d967e2c61cf8bbdabc2311d469524288ebe0", "filename": "src/test/ui/cenum_impl_drop_cast.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,18 @@\n+#![deny(cenum_impl_drop_cast)]\n+\n+enum E {\n+    A = 0,\n+}\n+\n+impl Drop for E {\n+    fn drop(&mut self) {\n+        println!(\"Drop\");\n+    }\n+}\n+\n+fn main() {\n+    let e = E::A;\n+    let i = e as u32;\n+    //~^ ERROR cannot cast enum `E` into integer `u32` because it implements `Drop`\n+    //~| WARN this was previously accepted\n+}"}, {"sha": "8d847a0c80b16fbf308f87d89886c684c024e374", "filename": "src/test/ui/cenum_impl_drop_cast.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcenum_impl_drop_cast.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,16 @@\n+error: cannot cast enum `E` into integer `u32` because it implements `Drop`\n+  --> $DIR/cenum_impl_drop_cast.rs:15:13\n+   |\n+LL |     let i = e as u32;\n+   |             ^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/cenum_impl_drop_cast.rs:1:9\n+   |\n+LL | #![deny(cenum_impl_drop_cast)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #73333 <https://github.com/rust-lang/rust/issues/73333>\n+\n+error: aborting due to previous error\n+"}, {"sha": "93dd9a53ec99f95c3595d875e208dc49bf181652", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {(\n LL | |     Union { u8: &BAR }.foo,\n LL | |     Union { u8: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum discriminant\n+   | |___^ type validation failed: encountered 0x05 at .1.<deref>, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "1f7593c6db9b6b25f66bd958265cf92a7ff1ff12", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:24:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000001, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -26,7 +26,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:42:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum discriminant\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0x00000000, but expected a valid enum tag\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "1a371c6b17000b6c93d2a491f88321ba4ee95230", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -10,15 +10,15 @@ error: layout_of(E) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=0,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {\n@@ -202,15 +202,15 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n         ],\n     },\n     variants: Multiple {\n-        discr: Scalar {\n+        tag: Scalar {\n             value: Int(\n                 I32,\n                 false,\n             ),\n             valid_range: 0..=1,\n         },\n-        discr_kind: Tag,\n-        discr_index: 0,\n+        tag_encoding: Direct,\n+        tag_field: 0,\n         variants: [\n             Layout {\n                 fields: Arbitrary {"}, {"sha": "3fb1cf9f557b2c86d71de72e61fa2c51c0895381", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,6 @@\n+#![feature(non_ascii_idents)]\n+\n+extern crate \u044c\u0430\u0433; //~ ERROR cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n+//~| ERROR can't find crate for `\u044c\u0430\u0433`\n+\n+fn main() {}"}, {"sha": "1e424237fd238480f5a37082015ed1f34df0f8f0", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-1.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,15 @@\n+error: cannot load a crate with a non-ascii name `\u044c\u0430\u0433`\n+  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n+   |\n+LL | extern crate \u044c\u0430\u0433;\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error[E0463]: can't find crate for `\u044c\u0430\u0433`\n+  --> $DIR/crate_name_nonascii_forbidden-1.rs:3:1\n+   |\n+LL | extern crate \u044c\u0430\u0433;\n+   | ^^^^^^^^^^^^^^^^^ can't find crate\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0463`."}, {"sha": "e1acdbff06189efd8b07c8f493e927ec98596900", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.rs?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,9 @@\n+// compile-flags:--extern \u043c\u0443_\u0441\u0433\u0430\u0442\u0435\n+// edition:2018\n+#![feature(non_ascii_idents)]\n+\n+use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz; //~  ERROR cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+                   //~| can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+\n+\n+fn main() {}"}, {"sha": "c06405ebb37ec6a15e736c607e7387babfb0606d", "filename": "src/test/ui/rfc-2457/crate_name_nonascii_forbidden-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b441aafbf52d6ba789ecc478455800c1a48df9/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2457%2Fcrate_name_nonascii_forbidden-2.stderr?ref=63b441aafbf52d6ba789ecc478455800c1a48df9", "patch": "@@ -0,0 +1,15 @@\n+error: cannot load a crate with a non-ascii name `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n+   |\n+LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n+   |     ^^^^^^^^\n+\n+error[E0463]: can't find crate for `\u043c\u0443_\u0441\u0433\u0430\u0442\u0435`\n+  --> $DIR/crate_name_nonascii_forbidden-2.rs:5:5\n+   |\n+LL | use \u043c\u0443_\u0441\u0433\u0430\u0442\u0435::baz;\n+   |     ^^^^^^^^ can't find crate\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0463`."}]}