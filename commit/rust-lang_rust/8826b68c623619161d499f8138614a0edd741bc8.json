{"sha": "8826b68c623619161d499f8138614a0edd741bc8", "node_id": "C_kwDOAAsO6NoAKDg4MjZiNjhjNjIzNjE5MTYxZDQ5OWY4MTM4NjE0YTBlZGQ3NDFiYzg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-19T15:39:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-19T15:39:38Z"}, "message": "Auto merge of #109346 - Dylan-DPC:rollup-vszi5bn, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #104100 (Allow using `Range` as an `Iterator` in const contexts. )\n - #105793 (Add note for mismatched types because of circular dependencies)\n - #108798 (move default backtrace setting to sys)\n - #108829 (Use Edition 2021 :pat in matches macro)\n - #108973 (Beautify pin! docs)\n - #109003 (Add `useless_anonymous_reexport` lint)\n - #109022 (read_buf_exact: on error, all read bytes are appended to the buffer)\n - #109212 (fix: don't suggest similar method when unstable)\n - #109243 (The name of NativeLib will be presented)\n - #109324 (Implement FixedSizeEncoding for UnusedGenericParams.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7919c8964a4109ee4b4e9c14dd7937d0d2f7d17c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7919c8964a4109ee4b4e9c14dd7937d0d2f7d17c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8826b68c623619161d499f8138614a0edd741bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8826b68c623619161d499f8138614a0edd741bc8", "html_url": "https://github.com/rust-lang/rust/commit/8826b68c623619161d499f8138614a0edd741bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8826b68c623619161d499f8138614a0edd741bc8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab9bb3ea368b2412531a3e8c07ba73d1dd690134", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9bb3ea368b2412531a3e8c07ba73d1dd690134", "html_url": "https://github.com/rust-lang/rust/commit/ab9bb3ea368b2412531a3e8c07ba73d1dd690134"}, {"sha": "881c9898ad329b813eebaf530b37a226bb88afd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/881c9898ad329b813eebaf530b37a226bb88afd3", "html_url": "https://github.com/rust-lang/rust/commit/881c9898ad329b813eebaf530b37a226bb88afd3"}], "stats": {"total": 727, "additions": 577, "deletions": 150}, "files": [{"sha": "6a0d0ca55c255e39e47643fe42c88d3087064c19", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -358,9 +358,9 @@ fn link_rlib<'a>(\n             let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n             let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n             packed_bundled_libs.push(wrapper_file);\n-        } else if let Some(name) = lib.name {\n+        } else {\n             let path =\n-                find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n+                find_native_static_library(lib.name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             ab.add_archive(&path, Box::new(|_| false)).unwrap_or_else(|error| {\n                 sess.emit_fatal(errors::AddNativeLibrary { library_path: path, error })});\n         }\n@@ -436,7 +436,7 @@ fn collate_raw_dylibs<'a, 'b>(\n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n             let ext = if lib.verbatim { \"\" } else { \".dll\" };\n-            let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n+            let name = format!(\"{}{}\", lib.name, ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n                 if let Some(old_import) = imports.insert(import.name, import) {\n@@ -1296,7 +1296,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n-            let name = lib.name?;\n+            let name = lib.name;\n             match lib.kind {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n@@ -1317,6 +1317,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 // These are included, no need to print them\n                 NativeLibKind::Static { bundle: None | Some(true), .. }\n                 | NativeLibKind::LinkArg\n+                | NativeLibKind::WasmImportModule\n                 | NativeLibKind::RawDylib => None,\n             }\n         })\n@@ -2275,21 +2276,18 @@ fn add_native_libs_from_crate(\n \n     let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n-        let Some(name) = lib.name else {\n-            continue;\n-        };\n         if !relevant_lib(sess, lib) {\n             continue;\n         }\n \n         // Skip if this library is the same as the last.\n-        last = if (lib.name, lib.kind, lib.verbatim) == last {\n+        last = if (Some(lib.name), lib.kind, lib.verbatim) == last {\n             continue;\n         } else {\n-            (lib.name, lib.kind, lib.verbatim)\n+            (Some(lib.name), lib.kind, lib.verbatim)\n         };\n \n-        let name = name.as_str();\n+        let name = lib.name.as_str();\n         let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n@@ -2346,6 +2344,7 @@ fn add_native_libs_from_crate(\n             NativeLibKind::RawDylib => {\n                 // Handled separately in `linker_with_args`.\n             }\n+            NativeLibKind::WasmImportModule => {}\n             NativeLibKind::LinkArg => {\n                 if link_static {\n                     cmd.arg(name);"}, {"sha": "18d17b1a0137c1e027c2dcc4029b3712a5c6b1e6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -595,7 +595,7 @@ fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, S\n \n     let mut ret = FxHashMap::default();\n     for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module());\n         let Some(module) = module else { continue };\n         ret.extend(lib.foreign_items.iter().map(|id| {\n             assert_eq!(id.krate, cnum);"}, {"sha": "81227b04e8a7efe0690b6a98db20af8883d593a3", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -118,7 +118,7 @@ bitflags::bitflags! {\n #[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: bool,"}, {"sha": "b6d39341fe7cc5ecbc04fec2ef3f63b393fa1ba6", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1028,6 +1028,15 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     true\n                 }\n             })\n+            // ensure that we don't suggest unstable methods\n+            .filter(|candidate| {\n+                // note that `DUMMY_SP` is ok here because it is only used for\n+                // suggestions and macro stuff which isn't applicable here.\n+                !matches!(\n+                    self.tcx.eval_stability(candidate.item.def_id, None, DUMMY_SP, None),\n+                    stability::EvalResult::Deny { .. }\n+                )\n+            })\n             .map(|candidate| candidate.item.ident(self.tcx))\n             .filter(|&name| set.insert(name))\n             .collect();"}, {"sha": "fd16363a1db0102b5f37a5df6cfbde53c42b5eec", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -615,9 +615,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         let report_path_match = |err: &mut Diagnostic, did1: DefId, did2: DefId| {\n-            // Only external crates, if either is from a local\n-            // module we could have false positives\n-            if !(did1.is_local() || did2.is_local()) && did1.krate != did2.krate {\n+            // Only report definitions from different crates. If both definitions\n+            // are from a local module we could have false positives, e.g.\n+            // let _ = [{struct Foo; Foo}, {struct Foo; Foo}];\n+            if did1.krate != did2.krate {\n                 let abs_path =\n                     |def_id| AbsolutePathPrinter { tcx: self.tcx }.print_def_path(def_id, &[]);\n \n@@ -629,10 +630,16 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 };\n                 if same_path().unwrap_or(false) {\n                     let crate_name = self.tcx.crate_name(did1.krate);\n-                    err.note(&format!(\n-                        \"perhaps two different versions of crate `{}` are being used?\",\n-                        crate_name\n-                    ));\n+                    let msg = if did1.is_local() || did2.is_local() {\n+                        format!(\n+                            \"the crate `{crate_name}` is compiled multiple times, possibly with different configurations\"\n+                        )\n+                    } else {\n+                        format!(\n+                            \"perhaps two different versions of crate `{crate_name}` are being used?\"\n+                        )\n+                    };\n+                    err.note(msg);\n                 }\n             }\n         };"}, {"sha": "c822237413c7039c132dac232b30a3bc7ecd34cb", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -508,3 +508,6 @@ lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its ass\n     .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n \n lint_opaque_hidden_inferred_bound_sugg = add this bound\n+\n+lint_useless_anonymous_reexport = useless anonymous re-export\n+    .note = only anonymous re-exports of traits are useful, this is {$article} `{$desc}`"}, {"sha": "c2cc2fcdf551a580d4fe094c53b5f2807c7b0ae6", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -74,6 +74,7 @@ mod opaque_hidden_inferred_bound;\n mod pass_by_value;\n mod passes;\n mod redundant_semicolon;\n+mod reexports;\n mod traits;\n mod types;\n mod unused;\n@@ -111,6 +112,7 @@ use noop_method_call::*;\n use opaque_hidden_inferred_bound::*;\n use pass_by_value::*;\n use redundant_semicolon::*;\n+use reexports::*;\n use traits::*;\n use types::*;\n use unused::*;\n@@ -242,6 +244,7 @@ late_lint_methods!(\n             OpaqueHiddenInferredBound: OpaqueHiddenInferredBound,\n             MultipleSupertraitUpcastable: MultipleSupertraitUpcastable,\n             MapUnitFn: MapUnitFn,\n+            UselessAnonymousReexport: UselessAnonymousReexport,\n         ]\n     ]\n );"}, {"sha": "46a025f41e04aec056cb2e84115b6fb2c27c670c", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1528,3 +1528,11 @@ pub struct UnusedAllocationDiag;\n #[derive(LintDiagnostic)]\n #[diag(lint_unused_allocation_mut)]\n pub struct UnusedAllocationMutDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_useless_anonymous_reexport)]\n+#[note]\n+pub struct UselessAnonymousReexportDiag {\n+    pub article: &'static str,\n+    pub desc: &'static str,\n+}"}, {"sha": "8737a57ea0264cddb1476d51411acbed456d027f", "filename": "compiler/rustc_lint/src/reexports.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_lint%2Fsrc%2Freexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Freexports.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,82 @@\n+use crate::lints::UselessAnonymousReexportDiag;\n+use crate::{LateContext, LateLintPass, LintContext};\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Item, ItemKind, UseKind};\n+use rustc_middle::ty::Visibility;\n+use rustc_span::symbol::kw;\n+use rustc_span::Span;\n+\n+declare_lint! {\n+    /// The `useless_anonymous_reexport` lint checks if anonymous re-exports\n+    /// are re-exports of traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(useless_anonymous_reexport)]\n+    ///\n+    /// mod sub {\n+    ///     pub struct Bar;\n+    /// }\n+    ///\n+    /// pub use self::sub::Bar as _;\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Anonymous re-exports are only useful if it's a re-export of a trait\n+    /// in case you want to give access to it. If you re-export any other kind,\n+    /// you won't be able to use it since its name won't be accessible.\n+    pub USELESS_ANONYMOUS_REEXPORT,\n+    Warn,\n+    \"useless anonymous re-export\"\n+}\n+\n+declare_lint_pass!(UselessAnonymousReexport => [USELESS_ANONYMOUS_REEXPORT]);\n+\n+fn emit_err(cx: &LateContext<'_>, span: Span, def_id: DefId) {\n+    let article = cx.tcx.def_descr_article(def_id);\n+    let desc = cx.tcx.def_descr(def_id);\n+    cx.emit_spanned_lint(\n+        USELESS_ANONYMOUS_REEXPORT,\n+        span,\n+        UselessAnonymousReexportDiag { article, desc },\n+    );\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for UselessAnonymousReexport {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if let ItemKind::Use(path, kind) = item.kind &&\n+            !matches!(kind, UseKind::Glob) &&\n+            item.ident.name == kw::Underscore &&\n+            // We only want re-exports. If it's just a `use X;`, then we ignore it.\n+            match cx.tcx.local_visibility(item.owner_id.def_id) {\n+                Visibility::Public => true,\n+                Visibility::Restricted(level) => {\n+                    level != cx.tcx.parent_module_from_def_id(item.owner_id.def_id)\n+                }\n+            }\n+        {\n+            for def_id in path.res.iter().filter_map(|r| r.opt_def_id()) {\n+                match cx.tcx.def_kind(def_id) {\n+                    DefKind::Trait | DefKind::TraitAlias => {}\n+                    DefKind::TyAlias => {\n+                        let ty = cx.tcx.type_of(def_id);\n+                        if !ty.0.is_trait() {\n+                            emit_err(cx, item.span, def_id);\n+                            break;\n+                        }\n+                    }\n+                    _ => {\n+                        emit_err(cx, item.span, def_id);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b855c8e433266470195b6033923ddb784f459185", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 35, "deletions": 41, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -46,7 +46,7 @@ pub fn find_native_static_library(\n }\n \n fn find_bundled_library(\n-    name: Option<Symbol>,\n+    name: Symbol,\n     verbatim: Option<bool>,\n     kind: NativeLibKind,\n     has_cfg: bool,\n@@ -58,7 +58,7 @@ fn find_bundled_library(\n     {\n         let verbatim = verbatim.unwrap_or(false);\n         let search_paths = &sess.target_filesearch(PathKind::Native).search_path_dirs();\n-        return find_native_static_library(name.unwrap().as_str(), verbatim, search_paths, sess)\n+        return find_native_static_library(name.as_str(), verbatim, search_paths, sess)\n             .file_name()\n             .and_then(|s| s.to_str())\n             .map(Symbol::intern);\n@@ -336,10 +336,16 @@ impl<'tcx> Collector<'tcx> {\n                 if name.is_some() || kind.is_some() || modifiers.is_some() || cfg.is_some() {\n                     sess.emit_err(errors::IncompatibleWasmLink { span });\n                 }\n-            } else if name.is_none() {\n-                sess.emit_err(errors::LinkRequiresName { span: m.span });\n             }\n \n+            if wasm_import_module.is_some() {\n+                (name, kind) = (wasm_import_module, Some(NativeLibKind::WasmImportModule));\n+            }\n+            let Some((name, name_span)) = name else {\n+                sess.emit_err(errors::LinkRequiresName { span: m.span });\n+                continue;\n+            };\n+\n             // Do this outside of the loop so that `import_name_type` can be specified before `kind`.\n             if let Some((_, span)) = import_name_type {\n                 if kind != Some(NativeLibKind::RawDylib) {\n@@ -349,8 +355,8 @@ impl<'tcx> Collector<'tcx> {\n \n             let dll_imports = match kind {\n                 Some(NativeLibKind::RawDylib) => {\n-                    if let Some((name, span)) = name && name.as_str().contains('\\0') {\n-                        sess.emit_err(errors::RawDylibNoNul { span });\n+                    if name.as_str().contains('\\0') {\n+                        sess.emit_err(errors::RawDylibNoNul { span: name_span });\n                     }\n                     foreign_mod_items\n                         .iter()\n@@ -389,7 +395,6 @@ impl<'tcx> Collector<'tcx> {\n                 }\n             };\n \n-            let name = name.map(|(name, _)| name);\n             let kind = kind.unwrap_or(NativeLibKind::Unspecified);\n             let filename = find_bundled_library(name, verbatim, kind, cfg.is_some(), sess);\n             self.libs.push(NativeLib {\n@@ -398,7 +403,6 @@ impl<'tcx> Collector<'tcx> {\n                 kind,\n                 cfg,\n                 foreign_module: Some(it.owner_id.to_def_id()),\n-                wasm_import_module: wasm_import_module.map(|(name, _)| name),\n                 verbatim,\n                 dll_imports,\n             });\n@@ -415,11 +419,7 @@ impl<'tcx> Collector<'tcx> {\n                 self.tcx.sess.emit_err(errors::LibFrameworkApple);\n             }\n             if let Some(ref new_name) = lib.new_name {\n-                let any_duplicate = self\n-                    .libs\n-                    .iter()\n-                    .filter_map(|lib| lib.name.as_ref())\n-                    .any(|n| n.as_str() == lib.name);\n+                let any_duplicate = self.libs.iter().any(|n| n.name.as_str() == lib.name);\n                 if new_name.is_empty() {\n                     self.tcx.sess.emit_err(errors::EmptyRenamingTarget { lib_name: &lib.name });\n                 } else if !any_duplicate {\n@@ -444,41 +444,36 @@ impl<'tcx> Collector<'tcx> {\n             let mut existing = self\n                 .libs\n                 .drain_filter(|lib| {\n-                    if let Some(lib_name) = lib.name {\n-                        if lib_name.as_str() == passed_lib.name {\n-                            // FIXME: This whole logic is questionable, whether modifiers are\n-                            // involved or not, library reordering and kind overriding without\n-                            // explicit `:rename` in particular.\n-                            if lib.has_modifiers() || passed_lib.has_modifiers() {\n-                                match lib.foreign_module {\n-                                    Some(def_id) => {\n-                                        self.tcx.sess.emit_err(errors::NoLinkModOverride {\n-                                            span: Some(self.tcx.def_span(def_id)),\n-                                        })\n-                                    }\n-                                    None => self\n-                                        .tcx\n-                                        .sess\n-                                        .emit_err(errors::NoLinkModOverride { span: None }),\n-                                };\n-                            }\n-                            if passed_lib.kind != NativeLibKind::Unspecified {\n-                                lib.kind = passed_lib.kind;\n-                            }\n-                            if let Some(new_name) = &passed_lib.new_name {\n-                                lib.name = Some(Symbol::intern(new_name));\n-                            }\n-                            lib.verbatim = passed_lib.verbatim;\n-                            return true;\n+                    if lib.name.as_str() == passed_lib.name {\n+                        // FIXME: This whole logic is questionable, whether modifiers are\n+                        // involved or not, library reordering and kind overriding without\n+                        // explicit `:rename` in particular.\n+                        if lib.has_modifiers() || passed_lib.has_modifiers() {\n+                            match lib.foreign_module {\n+                                Some(def_id) => self.tcx.sess.emit_err(errors::NoLinkModOverride {\n+                                    span: Some(self.tcx.def_span(def_id)),\n+                                }),\n+                                None => {\n+                                    self.tcx.sess.emit_err(errors::NoLinkModOverride { span: None })\n+                                }\n+                            };\n+                        }\n+                        if passed_lib.kind != NativeLibKind::Unspecified {\n+                            lib.kind = passed_lib.kind;\n+                        }\n+                        if let Some(new_name) = &passed_lib.new_name {\n+                            lib.name = Symbol::intern(new_name);\n                         }\n+                        lib.verbatim = passed_lib.verbatim;\n+                        return true;\n                     }\n                     false\n                 })\n                 .collect::<Vec<_>>();\n             if existing.is_empty() {\n                 // Add if not found\n                 let new_name: Option<&str> = passed_lib.new_name.as_deref();\n-                let name = Some(Symbol::intern(new_name.unwrap_or(&passed_lib.name)));\n+                let name = Symbol::intern(new_name.unwrap_or(&passed_lib.name));\n                 let sess = self.tcx.sess;\n                 let filename =\n                     find_bundled_library(name, passed_lib.verbatim, passed_lib.kind, false, sess);\n@@ -488,7 +483,6 @@ impl<'tcx> Collector<'tcx> {\n                     kind: passed_lib.kind,\n                     cfg: None,\n                     foreign_module: None,\n-                    wasm_import_module: None,\n                     verbatim: passed_lib.verbatim,\n                     dll_imports: Vec::new(),\n                 });"}, {"sha": "98eae70b4b708bbc35ab6c05dd4cd8ae0d4e699b", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -226,15 +226,7 @@ provide! { tcx, def_id, other, cdata,\n     lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n     params_in_repr => { table }\n-    // FIXME: Could be defaulted, but `LazyValue<UnusedGenericParams>` is not `FixedSizeEncoding`..\n-    unused_generic_params => {\n-        cdata\n-            .root\n-            .tables\n-            .unused_generic_params\n-            .get(cdata, def_id.index)\n-            .map_or_else(|| ty::UnusedGenericParams::new_all_used(), |lazy| lazy.decode((cdata, tcx)))\n-    }\n+    unused_generic_params => { cdata.root.tables.unused_generic_params.get(cdata, def_id.index) }\n     opt_def_kind => { table_direct }\n     impl_parent => { table }\n     impl_polarity => { table_direct }"}, {"sha": "19745988c5919982a884401812f7f593206e0b29", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1440,9 +1440,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let instance =\n                 ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id.to_def_id()));\n             let unused = tcx.unused_generic_params(instance);\n-            if !unused.all_used() {\n-                record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n-            }\n+            self.tables.unused_generic_params.set(def_id.local_def_index, unused);\n         }\n \n         // Encode all the deduced parameter attributes for everything that has MIR, even for items"}, {"sha": "6f20ac9e5275f211f1be1f6ce847d0354f8141ab", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -356,6 +356,7 @@ define_tables! {\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     associated_items_for_impl_trait_in_trait: Table<DefIndex, LazyArray<DefId>>,\n     opt_rpitit_info: Table<DefIndex, Option<LazyValue<ty::ImplTraitInTraitData>>>,\n+    unused_generic_params: Table<DefIndex, UnusedGenericParams>,\n \n - optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n@@ -398,7 +399,6 @@ define_tables! {\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n-    unused_generic_params: Table<DefIndex, LazyValue<UnusedGenericParams>>,\n     params_in_repr: Table<DefIndex, LazyValue<BitSet<u32>>>,\n     repr_options: Table<DefIndex, LazyValue<ReprOptions>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a"}, {"sha": "364fa74ab7b459bd31796bef39482ccc2f23c653", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -3,7 +3,7 @@ use crate::rmeta::*;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def::{CtorKind, CtorOf};\n use rustc_index::vec::Idx;\n-use rustc_middle::ty::ParameterizedOverTcx;\n+use rustc_middle::ty::{ParameterizedOverTcx, UnusedGenericParams};\n use rustc_serialize::opaque::FileEncoder;\n use rustc_serialize::Encoder as _;\n use rustc_span::hygiene::MacroKind;\n@@ -50,6 +50,16 @@ impl IsDefault for DefPathHash {\n     }\n }\n \n+impl IsDefault for UnusedGenericParams {\n+    fn is_default(&self) -> bool {\n+        // UnusedGenericParams encodes the *un*usedness as a bitset.\n+        // This means that 0 corresponds to all bits used, which is indeed the default.\n+        let is_default = self.bits() == 0;\n+        debug_assert_eq!(is_default, self.all_used());\n+        is_default\n+    }\n+}\n+\n /// Helper trait, for encoding to, and decoding from, a fixed number of bytes.\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n@@ -271,6 +281,21 @@ impl FixedSizeEncoding for bool {\n     }\n }\n \n+impl FixedSizeEncoding for UnusedGenericParams {\n+    type ByteArray = [u8; 4];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 4]) -> Self {\n+        let x: u32 = u32::from_bytes(b);\n+        UnusedGenericParams::from_bits(x)\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 4]) {\n+        self.bits().write_to_bytes(b);\n+    }\n+}\n+\n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `LazyValue<T>` impl, but in the general case we might not need / want\n // to fit every `usize` in `u32`."}, {"sha": "5fc98f01a5470ee213ba3eec3a2463bad7e67c95", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -781,6 +781,12 @@ fn needs_fn_once_adapter_shim(\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Decodable, Encodable, HashStable)]\n pub struct UnusedGenericParams(FiniteBitSet<u32>);\n \n+impl Default for UnusedGenericParams {\n+    fn default() -> Self {\n+        UnusedGenericParams::new_all_used()\n+    }\n+}\n+\n impl UnusedGenericParams {\n     pub fn new_all_unused(amount: u32) -> Self {\n         let mut bitset = FiniteBitSet::new_empty();\n@@ -807,4 +813,12 @@ impl UnusedGenericParams {\n     pub fn all_used(&self) -> bool {\n         self.0.is_empty()\n     }\n+\n+    pub fn bits(&self) -> u32 {\n+        self.0.0\n+    }\n+\n+    pub fn from_bits(bits: u32) -> UnusedGenericParams {\n+        UnusedGenericParams(FiniteBitSet(bits))\n+    }\n }"}, {"sha": "a262c06d91f039b6b47bd68a093557db315f9bd9", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -67,12 +67,11 @@ pub enum LinkagePreference {\n #[derive(Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     /// If packed_bundled_libs enabled, actual filename of library is stored.\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub foreign_module: Option<DefId>,\n-    pub wasm_import_module: Option<Symbol>,\n     pub verbatim: Option<bool>,\n     pub dll_imports: Vec<DllImport>,\n }\n@@ -81,6 +80,10 @@ impl NativeLib {\n     pub fn has_modifiers(&self) -> bool {\n         self.verbatim.is_some() || self.kind.has_modifiers()\n     }\n+\n+    pub fn wasm_import_module(&self) -> Option<Symbol> {\n+        if self.kind == NativeLibKind::WasmImportModule { Some(self.name) } else { None }\n+    }\n }\n \n /// Different ways that the PE Format can decorate a symbol name."}, {"sha": "3b3d4ca5d6b21e3c15cf8b70ec8244683eee70e0", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -37,6 +37,10 @@ pub enum NativeLibKind {\n     /// Argument which is passed to linker, relative order with libraries and other arguments\n     /// is preserved\n     LinkArg,\n+\n+    /// Module imported from WebAssembly\n+    WasmImportModule,\n+\n     /// The library kind wasn't specified, `Dylib` is currently used as a default.\n     Unspecified,\n }\n@@ -50,7 +54,10 @@ impl NativeLibKind {\n             NativeLibKind::Dylib { as_needed } | NativeLibKind::Framework { as_needed } => {\n                 as_needed.is_some()\n             }\n-            NativeLibKind::RawDylib | NativeLibKind::Unspecified | NativeLibKind::LinkArg => false,\n+            NativeLibKind::RawDylib\n+            | NativeLibKind::Unspecified\n+            | NativeLibKind::LinkArg\n+            | NativeLibKind::WasmImportModule => false,\n         }\n     }\n "}, {"sha": "f19636fba5d95fdde9209b61da38ca554b347a78", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,4 +1,5 @@\n use crate::convert::TryFrom;\n+use crate::marker::Destruct;\n use crate::mem;\n use crate::ops::{self, Try};\n \n@@ -20,7 +21,8 @@ unsafe_impl_trusted_step![char i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usi\n /// The *successor* operation moves towards values that compare greater.\n /// The *predecessor* operation moves towards values that compare lesser.\n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-pub trait Step: Clone + PartialOrd + Sized {\n+#[const_trait]\n+pub trait Step: ~const Clone + ~const PartialOrd + Sized {\n     /// Returns the number of *successor* steps required to get from `start` to `end`.\n     ///\n     /// Returns `None` if the number of steps would overflow `usize`\n@@ -234,7 +236,8 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $u_narrower {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $u_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -266,7 +269,8 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $i_narrower {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $i_narrower {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -330,7 +334,8 @@ macro_rules! step_integer_impls {\n         $(\n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $u_wider {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $u_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -355,7 +360,8 @@ macro_rules! step_integer_impls {\n \n             #[allow(unreachable_patterns)]\n             #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-            impl Step for $i_wider {\n+            #[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+            impl const Step for $i_wider {\n                 step_identical_methods!();\n \n                 #[inline]\n@@ -405,7 +411,8 @@ step_integer_impls! {\n }\n \n #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n-impl Step for char {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl const Step for char {\n     #[inline]\n     fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n         let start = start as u32;\n@@ -423,6 +430,7 @@ impl Step for char {\n     }\n \n     #[inline]\n+    #[rustc_allow_const_fn_unstable(const_try)]\n     fn forward_checked(start: char, count: usize) -> Option<char> {\n         let start = start as u32;\n         let mut res = Step::forward_checked(start, count)?;\n@@ -439,6 +447,7 @@ impl Step for char {\n     }\n \n     #[inline]\n+    #[rustc_allow_const_fn_unstable(const_try)]\n     fn backward_checked(start: char, count: usize) -> Option<char> {\n         let start = start as u32;\n         let mut res = Step::backward_checked(start, count)?;\n@@ -514,6 +523,7 @@ macro_rules! range_incl_exact_iter_impl {\n }\n \n /// Specialization implementations for `Range`.\n+#[const_trait]\n trait RangeIteratorImpl {\n     type Item;\n \n@@ -528,7 +538,7 @@ trait RangeIteratorImpl {\n     fn spec_advance_back_by(&mut self, n: usize) -> Result<(), usize>;\n }\n \n-impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n+impl<A: ~const Step + ~const Destruct> const RangeIteratorImpl for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -614,7 +624,7 @@ impl<A: Step> RangeIteratorImpl for ops::Range<A> {\n     }\n }\n \n-impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n+impl<T: ~const TrustedStep + ~const Destruct> const RangeIteratorImpl for ops::Range<T> {\n     #[inline]\n     fn spec_next(&mut self) -> Option<T> {\n         if self.start < self.end {\n@@ -702,7 +712,8 @@ impl<T: TrustedStep> RangeIteratorImpl for ops::Range<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> Iterator for ops::Range<A> {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl<A: ~const Step + ~const Destruct> const Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n@@ -812,7 +823,8 @@ range_incl_exact_iter_impl! {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n+#[rustc_const_unstable(feature = \"const_iter\", issue = \"92476\")]\n+impl<A: ~const Step + ~const Destruct> const DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         self.spec_next_back()"}, {"sha": "7a10dea500a969a7e344d79b97cf3f6c590535b0", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,3 +1,4 @@\n+use crate::marker::Destruct;\n use crate::ops::{ControlFlow, Try};\n \n /// An iterator able to yield elements from both ends.\n@@ -37,6 +38,7 @@ use crate::ops::{ControlFlow, Try};\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"DoubleEndedIterator\")]\n+#[const_trait]\n pub trait DoubleEndedIterator: Iterator {\n     /// Removes and returns an element from the end of the iterator.\n     ///\n@@ -131,7 +133,10 @@ pub trait DoubleEndedIterator: Iterator {\n     /// [`Err(k)`]: Err\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         for i in 0..n {\n             self.next_back().ok_or(i)?;\n         }\n@@ -181,6 +186,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_nth_back\", since = \"1.37.0\")]\n+    #[rustc_do_not_const_check]\n     fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n         self.advance_back_by(n).ok()?;\n         self.next_back()\n@@ -218,6 +224,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n     where\n         Self: Sized,\n@@ -289,6 +296,7 @@ pub trait DoubleEndedIterator: Iterator {\n     #[doc(alias = \"foldr\")]\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n@@ -344,6 +352,7 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n+    #[rustc_do_not_const_check]\n     fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,"}, {"sha": "6fc86550b63e75bd081303a20e46be2db8159ff8", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,5 +1,6 @@\n use crate::array;\n use crate::cmp::{self, Ordering};\n+use crate::marker::Destruct;\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n \n use super::super::try_process;\n@@ -336,8 +337,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n-    #[rustc_do_not_const_check]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         for i in 0..n {\n             self.next().ok_or(i)?;\n         }\n@@ -385,8 +388,10 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_do_not_const_check]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+    fn nth(&mut self, n: usize) -> Option<Self::Item>\n+    where\n+        Self::Item: ~const Destruct,\n+    {\n         self.advance_by(n).ok()?;\n         self.next()\n     }"}, {"sha": "c8f60defff771f7ca4a2064bd18e19e133f163f5", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -86,4 +86,5 @@ pub unsafe trait InPlaceIterable: Iterator {}\n /// for details. Consumers are free to rely on the invariants in unsafe code.\n #[unstable(feature = \"trusted_step\", issue = \"85731\")]\n #[rustc_specialization_trait]\n-pub unsafe trait TrustedStep: Step {}\n+#[const_trait]\n+pub unsafe trait TrustedStep: ~const Step {}"}, {"sha": "1076d357070ef5ee265cc807b75de0698f80021d", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -123,9 +123,11 @@\n #![feature(const_index_range_slice_index)]\n #![feature(const_inherent_unchecked_arith)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_intoiterator_identity)]\n #![feature(const_intrinsic_forget)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_iter)]\n #![feature(const_likely)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_maybe_uninit_as_mut_ptr)]"}, {"sha": "529f62f4d6cd7db5c2a53adc45f3b5b8ab3279d8", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -340,9 +340,9 @@ pub macro debug_assert_matches($($arg:tt)*) {\n #[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"matches_macro\")]\n macro_rules! matches {\n-    ($expression:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => {\n+    ($expression:expr, $pattern:pat $(if $guard:expr)? $(,)?) => {\n         match $expression {\n-            $( $pattern )|+ $( if $guard )? => true,\n+            $pattern $(if $guard)? => true,\n             _ => false\n         }\n     };"}, {"sha": "c4b89a6301965b6a6c8efbc0cbb5fe8173da189f", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1003,22 +1003,25 @@ impl<P, U> CoerceUnsized<Pin<U>> for Pin<P> where P: CoerceUnsized<U> {}\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n \n-/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning[^1] a `value: T` _locally_[^2].\n+/// Constructs a <code>[Pin]<[&mut] T></code>, by pinning a `value: T` locally.\n ///\n-/// Unlike [`Box::pin`], this does not involve a heap allocation.\n+/// Unlike [`Box::pin`], this does not create a new heap allocation. As explained\n+/// below, the element might still end up on the heap however.\n ///\n-/// [^1]: If the (type `T` of the) given value does not implement [`Unpin`], then this\n-/// effectively pins the `value` in memory, where it will be unable to be moved.\n-/// Otherwise, <code>[Pin]<[&mut] T></code> behaves like <code>[&mut] T</code>, and operations such\n-/// as [`mem::replace()`][crate::mem::replace] will allow extracting that value, and therefore,\n-/// moving it.\n-/// See [the `Unpin` section of the `pin` module][self#unpin] for more info.\n+/// The local pinning performed by this macro is usually dubbed \"stack\"-pinning.\n+/// Outside of `async` contexts locals do indeed get stored on the stack. In\n+/// `async` functions or blocks however, any locals crossing an `.await` point\n+/// are part of the state captured by the `Future`, and will use the storage of\n+/// those. That storage can either be on the heap or on the stack. Therefore,\n+/// local pinning is a more accurate term.\n ///\n-/// [^2]: This is usually dubbed \"stack\"-pinning. And whilst local values are almost always located\n-/// in the stack (_e.g._, when within the body of a non-`async` function), the truth is that inside\n-/// the body of an `async fn` or block \u2014more generally, the body of a generator\u2014 any locals crossing\n-/// an `.await` point \u2014a `yield` point\u2014 end up being part of the state captured by the `Future` \u2014by\n-/// the `Generator`\u2014, and thus will be stored wherever that one is.\n+/// If the type of the given value does not implement [`Unpin`], then this macro\n+/// pins the value in memory in a way that prevents moves. On the other hand,\n+/// if the type does implement [`Unpin`], <code>[Pin]<[&mut] T></code> behaves\n+/// like <code>[&mut] T</code>, and operations such as\n+/// [`mem::replace()`][crate::mem::replace] or [`mem::take()`](crate::mem::take)\n+/// will allow moves of the value.\n+/// See [the `Unpin` section of the `pin` module][self#unpin] for details.\n ///\n /// ## Examples\n ///\n@@ -1158,9 +1161,9 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n ///\n /// If you really need to return a pinned value, consider using [`Box::pin`] instead.\n ///\n-/// On the other hand, pinning to the stack[<sup>2</sup>](#fn2) using [`pin!`] is likely to be\n-/// cheaper than pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n-/// even needing an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n+/// On the other hand, local pinning using [`pin!`] is likely to be cheaper than\n+/// pinning into a fresh heap allocation using [`Box::pin`]. Moreover, by virtue of not\n+/// requiring an allocator, [`pin!`] is the main non-`unsafe` `#![no_std]`-compatible [`Pin`]\n /// constructor.\n ///\n /// [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin"}, {"sha": "d56687e48c96a0d15a3e56477c52219fedda8253", "filename": "library/core/tests/iter/consts.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fconsts.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,36 @@\n+#[test]\n+fn const_manual_iter() {\n+    struct S(bool);\n+\n+    impl const Iterator for S {\n+        type Item = ();\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            if self.0 == false {\n+                self.0 = true;\n+                Some(())\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+    const {\n+        let mut val = S(false);\n+        assert!(val.next().is_some());\n+        assert!(val.next().is_none());\n+        assert!(val.next().is_none());\n+    }\n+}\n+\n+#[test]\n+fn const_range() {\n+    const {\n+        let mut arr = [0; 3];\n+        for i in 0..arr.len() {\n+            arr[i] = i;\n+        }\n+        assert!(arr[0] == 0);\n+        assert!(arr[1] == 1);\n+        assert!(arr[2] == 2);\n+    }\n+}"}, {"sha": "cbb18e79e2d430de00d042d5759e565f4415a249", "filename": "library/core/tests/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -20,6 +20,8 @@ mod range;\n mod sources;\n mod traits;\n \n+mod consts;\n+\n use core::cell::Cell;\n use core::convert::TryFrom;\n use core::iter::*;"}, {"sha": "637cc6e9f629bfffc8625047e58bc1bea247d399", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -12,8 +12,11 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_convert)]\n+#![feature(const_for)]\n #![feature(const_hash)]\n #![feature(const_heap)]\n+#![feature(const_intoiterator_identity)]\n+#![feature(const_iter)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_maybe_uninit_assume_init_read)]\n #![feature(const_nonnull_new)]"}, {"sha": "4b31c552eedd2c06d84a593963a2209d8569995c", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -823,8 +823,22 @@ pub trait Read {\n \n     /// Read the exact number of bytes required to fill `cursor`.\n     ///\n-    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to\n-    /// allow use with uninitialized buffers.\n+    /// This is similar to the [`read_exact`](Read::read_exact) method, except\n+    /// that it is passed a [`BorrowedCursor`] rather than `[u8]` to allow use\n+    /// with uninitialized buffers.\n+    ///\n+    /// # Errors\n+    ///\n+    /// If this function encounters an error of the kind [`ErrorKind::Interrupted`]\n+    /// then the error is ignored and the operation will continue.\n+    ///\n+    /// If this function encounters an \"end of file\" before completely filling\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n+    ///\n+    /// If any other read error is encountered then this function immediately\n+    /// returns.\n+    ///\n+    /// If this function returns an error, all bytes read will be appended to `cursor`.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n     fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> Result<()> {\n         while cursor.capacity() > 0 {"}, {"sha": "345d72ef8678e87ccf395e1d81ec09db0ce98abe", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -308,8 +308,7 @@ pub fn get_backtrace_style() -> Option<BacktraceStyle> {\n                 BacktraceStyle::Short\n             }\n         })\n-        .unwrap_or(if cfg!(target_os = \"fuchsia\") {\n-            // Fuchsia components default to full backtrace.\n+        .unwrap_or(if crate::sys::FULL_BACKTRACE_DEFAULT {\n             BacktraceStyle::Full\n         } else {\n             BacktraceStyle::Off"}, {"sha": "e767b2866cb9bc1a3445b57c92b6c25e3d3e1b0e", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -76,3 +76,12 @@ cfg_if::cfg_if! {\n         pub mod c;\n     }\n }\n+\n+cfg_if::cfg_if! {\n+    // Fuchsia components default to full backtrace.\n+    if #[cfg(target_os = \"fuchsia\")] {\n+        pub const FULL_BACKTRACE_DEFAULT: bool = true;\n+    } else {\n+        pub const FULL_BACKTRACE_DEFAULT: bool = false;\n+    }\n+}"}, {"sha": "4d9010d3c4b3036da9f57dbcefcc61072ee67aaf", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -278,13 +278,15 @@ impl<'test> TestCx<'test> {\n             Incremental => {\n                 let revision =\n                     self.revision.expect(\"incremental tests require a list of revisions\");\n-                if revision.starts_with(\"rpass\") || revision.starts_with(\"rfail\") {\n+                if revision.starts_with(\"cpass\")\n+                    || revision.starts_with(\"rpass\")\n+                    || revision.starts_with(\"rfail\")\n+                {\n                     true\n                 } else if revision.starts_with(\"cfail\") {\n-                    // FIXME: would be nice if incremental revs could start with \"cpass\"\n                     pm.is_some()\n                 } else {\n-                    panic!(\"revision name must begin with rpass, rfail, or cfail\");\n+                    panic!(\"revision name must begin with cpass, rpass, rfail, or cfail\");\n                 }\n             }\n             mode => panic!(\"unimplemented for mode {:?}\", mode),\n@@ -384,6 +386,20 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n+    fn run_cpass_test(&self) {\n+        let emit_metadata = self.should_emit_metadata(self.pass_mode());\n+        let proc_res = self.compile_test(WillExecute::No, emit_metadata);\n+\n+        if !proc_res.status.success() {\n+            self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n+        }\n+\n+        // FIXME(#41968): Move this check to tidy?\n+        if !errors::load_errors(&self.testpaths.file, self.revision).is_empty() {\n+            self.fatal(\"compile-pass tests with expected warnings should be moved to ui/\");\n+        }\n+    }\n+\n     fn run_rpass_test(&self) {\n         let emit_metadata = self.should_emit_metadata(self.pass_mode());\n         let should_run = self.run_if_enabled();\n@@ -393,17 +409,15 @@ impl<'test> TestCx<'test> {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n+        // FIXME(#41968): Move this check to tidy?\n+        if !errors::load_errors(&self.testpaths.file, self.revision).is_empty() {\n+            self.fatal(\"run-pass tests with expected warnings should be moved to ui/\");\n+        }\n+\n         if let WillExecute::Disabled = should_run {\n             return;\n         }\n \n-        // FIXME(#41968): Move this check to tidy?\n-        let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n-        assert!(\n-            expected_errors.is_empty(),\n-            \"run-pass tests with expected warnings should be moved to ui/\"\n-        );\n-\n         let proc_res = self.exec_compiled_test();\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"test run failed!\", &proc_res);\n@@ -2913,10 +2927,11 @@ impl<'test> TestCx<'test> {\n     fn run_incremental_test(&self) {\n         // Basic plan for a test incremental/foo/bar.rs:\n         // - load list of revisions rpass1, cfail2, rpass3\n-        //   - each should begin with `rpass`, `cfail`, or `rfail`\n-        //   - if `rpass`, expect compile and execution to succeed\n+        //   - each should begin with `cpass`, `rpass`, `cfail`, or `rfail`\n+        //   - if `cpass`, expect compilation to succeed, don't execute\n+        //   - if `rpass`, expect compilation and execution to succeed\n         //   - if `cfail`, expect compilation to fail\n-        //   - if `rfail`, expect execution to fail\n+        //   - if `rfail`, expect compilation to succeed and execution to fail\n         // - create a directory build/foo/bar.incremental\n         // - compile foo/bar.rs with -C incremental=.../foo/bar.incremental and -C rpass1\n         //   - because name of revision starts with \"rpass\", expect success\n@@ -2940,7 +2955,12 @@ impl<'test> TestCx<'test> {\n             print!(\"revision={:?} props={:#?}\", revision, self.props);\n         }\n \n-        if revision.starts_with(\"rpass\") {\n+        if revision.starts_with(\"cpass\") {\n+            if self.props.should_ice {\n+                self.fatal(\"can only use should-ice in cfail tests\");\n+            }\n+            self.run_cpass_test();\n+        } else if revision.starts_with(\"rpass\") {\n             if self.props.should_ice {\n                 self.fatal(\"can only use should-ice in cfail tests\");\n             }\n@@ -2953,7 +2973,7 @@ impl<'test> TestCx<'test> {\n         } else if revision.starts_with(\"cfail\") {\n             self.run_cfail_test();\n         } else {\n-            self.fatal(\"revision name must begin with rpass, rfail, or cfail\");\n+            self.fatal(\"revision name must begin with cpass, rpass, rfail, or cfail\");\n         }\n     }\n "}, {"sha": "6b7b27fd526c3caf88a2e0b3b5ce05b9a686eab9", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -59,7 +59,6 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"library/std/src/path.rs\",\n     \"library/std/src/sys_common\", // Should only contain abstractions over platforms\n     \"library/std/src/net/test.rs\", // Utility helpers for tests\n-    \"library/std/src/panic.rs\",   // fuchsia-specific panic backtrace handling\n     \"library/std/src/personality.rs\",\n     \"library/std/src/personality/\",\n ];"}, {"sha": "0e74eb1b2f2631b561ce698b9c352c687ffba803", "filename": "tests/incremental/auxiliary/circular-dependencies-aux.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fauxiliary%2Fcircular-dependencies-aux.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,10 @@\n+// edition: 2021\n+// compile-flags: --crate-type lib --extern circular_dependencies={{build-base}}/circular-dependencies/libcircular_dependencies.rmeta --emit dep-info,metadata\n+\n+use circular_dependencies::Foo;\n+\n+pub fn consume_foo(_: Foo) {}\n+\n+pub fn produce_foo() -> Foo {\n+    Foo\n+}"}, {"sha": "10673066a9df09b2e1f9f29dc8eb836b57b3875a", "filename": "tests/incremental/circular-dependencies.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fincremental%2Fcircular-dependencies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fincremental%2Fcircular-dependencies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fincremental%2Fcircular-dependencies.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,37 @@\n+// ignore-tidy-linelength\n+// revisions: cpass1 cfail2\n+// edition: 2021\n+// [cpass1] compile-flags: --crate-type lib --emit dep-info,metadata\n+// [cfail2] aux-build: circular-dependencies-aux.rs\n+// [cfail2] compile-flags: --test --extern aux={{build-base}}/circular-dependencies/auxiliary/libcircular_dependencies_aux.rmeta -L dependency={{build-base}}/circular-dependencies\n+\n+pub struct Foo;\n+//[cfail2]~^ NOTE `Foo` is defined in the current crate\n+//[cfail2]~| NOTE `Foo` is defined in the current crate\n+//[cfail2]~| NOTE `circular_dependencies::Foo` is defined in crate `circular_dependencies`\n+//[cfail2]~| NOTE `circular_dependencies::Foo` is defined in crate `circular_dependencies`\n+\n+pub fn consume_foo(_: Foo) {}\n+//[cfail2]~^ NOTE function defined here\n+\n+pub fn produce_foo() -> Foo {\n+    Foo\n+}\n+\n+#[test]\n+fn test() {\n+    aux::consume_foo(produce_foo());\n+    //[cfail2]~^ ERROR mismatched types [E0308]\n+    //[cfail2]~| NOTE expected `circular_dependencies::Foo`, found `Foo`\n+    //[cfail2]~| NOTE arguments to this function are incorrect\n+    //[cfail2]~| NOTE `Foo` and `circular_dependencies::Foo` have similar names, but are actually distinct types\n+    //[cfail2]~| NOTE the crate `circular_dependencies` is compiled multiple times, possibly with different configurations\n+    //[cfail2]~| NOTE function defined here\n+\n+    consume_foo(aux::produce_foo());\n+    //[cfail2]~^ ERROR mismatched types [E0308]\n+    //[cfail2]~| NOTE expected `Foo`, found `circular_dependencies::Foo`\n+    //[cfail2]~| NOTE arguments to this function are incorrect\n+    //[cfail2]~| NOTE `circular_dependencies::Foo` and `Foo` have similar names, but are actually distinct types\n+    //[cfail2]~| NOTE the crate `circular_dependencies` is compiled multiple times, possibly with different configurations\n+}"}, {"sha": "0f688fa282356dca1372cd3380c296941a38180a", "filename": "tests/ui/imports/issue-99695-b.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695-b.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.fixed?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n \n     mod p {"}, {"sha": "b433997e53f6a7b8a7c77ad7c003e3e105e840db", "filename": "tests/ui/imports/issue-99695-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695-b.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n \n     mod p {"}, {"sha": "17ff409324e3401ce8acba9f80707a9c5dcdf40d", "filename": "tests/ui/imports/issue-99695.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.fixed?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "b8979bcb7345ca81c9177980271489ffae244565", "filename": "tests/ui/imports/issue-99695.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fimports%2Fissue-99695.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimports%2Fissue-99695.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n-#![allow(unused, nonstandard_style)]\n+#![allow(unused, nonstandard_style, useless_anonymous_reexport)]\n mod m {\n     #[macro_export]\n     macro_rules! nu {"}, {"sha": "2f740e55389730bf0550a9124ea68583b223e0b7", "filename": "tests/ui/linkage-attr/issue-109144.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"lib\"]\n+#[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+//~^ ERROR `#[link]` attribute requires a `name = \"string\"` argument\n+extern  {}"}, {"sha": "33187cfdbb63674aa8235a72f6c82ff50dc991c3", "filename": "tests/ui/linkage-attr/issue-109144.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flinkage-attr%2Fissue-109144.stderr?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,9 @@\n+error[E0459]: `#[link]` attribute requires a `name = \"string\"` argument\n+  --> $DIR/issue-109144.rs:2:1\n+   |\n+LL | #[link(kind = \"static\", modifiers = \"+whole-archive,+bundle\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `name` argument\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0459`."}, {"sha": "5d56ae6f969b551107c4c1466e640565128961b3", "filename": "tests/ui/lint/anonymous-reexport.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flint%2Fanonymous-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,21 @@\n+#![deny(useless_anonymous_reexport)]\n+#![crate_type = \"rlib\"]\n+\n+mod my_mod {\n+    pub trait Foo {}\n+    pub type TyFoo = dyn Foo;\n+    pub struct Bar;\n+    pub type TyBar = Bar;\n+}\n+\n+pub use self::my_mod::Foo as _;\n+pub use self::my_mod::TyFoo as _;\n+pub use self::my_mod::Bar as _; //~ ERROR\n+pub use self::my_mod::TyBar as _; //~ ERROR\n+pub use self::my_mod::{Bar as _}; //~ ERROR\n+pub use self::my_mod::{Bar as _, Foo as _}; //~ ERROR\n+pub use self::my_mod::{Bar as _, TyBar as _};\n+//~^ ERROR\n+//~| ERROR\n+#[allow(unused_imports)]\n+use self::my_mod::TyBar as _;"}, {"sha": "f4f8b41c417a438192381ae6be7717597946ab6f", "filename": "tests/ui/lint/anonymous-reexport.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Flint%2Fanonymous-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fanonymous-reexport.stderr?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,55 @@\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:13:1\n+   |\n+LL | pub use self::my_mod::Bar as _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+note: the lint level is defined here\n+  --> $DIR/anonymous-reexport.rs:1:9\n+   |\n+LL | #![deny(useless_anonymous_reexport)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:14:1\n+   |\n+LL | pub use self::my_mod::TyBar as _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:15:24\n+   |\n+LL | pub use self::my_mod::{Bar as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:16:24\n+   |\n+LL | pub use self::my_mod::{Bar as _, Foo as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:17:24\n+   |\n+LL | pub use self::my_mod::{Bar as _, TyBar as _};\n+   |                        ^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `struct`\n+\n+error: useless anonymous re-export\n+  --> $DIR/anonymous-reexport.rs:17:34\n+   |\n+LL | pub use self::my_mod::{Bar as _, TyBar as _};\n+   |                                  ^^^^^^^^^^\n+   |\n+   = note: only anonymous re-exports of traits are useful, this is a `type alias`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8804186ee1a6b915777f028ae86925e044c5b78b", "filename": "tests/ui/stability-attribute/auxiliary/similar-unstable-method.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fauxiliary%2Fsimilar-unstable-method.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,13 @@\n+#![feature(staged_api)]\n+#![stable(feature = \"libfoo\", since = \"1.0.0\")]\n+\n+#[unstable(feature = \"foo\", reason = \"...\", issue = \"none\")]\n+pub fn foo() {}\n+\n+#[stable(feature = \"libfoo\", since = \"1.0.0\")]\n+pub struct Foo;\n+\n+impl Foo {\n+    #[unstable(feature = \"foo\", reason = \"...\", issue = \"none\")]\n+    pub fn foo(&self) {}\n+}"}, {"sha": "6d052779c6d363339ac4943b468045308ca629af", "filename": "tests/ui/stability-attribute/issue-109177.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fissue-109177.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,13 @@\n+// aux-build: similar-unstable-method.rs\n+\n+extern crate similar_unstable_method;\n+\n+fn main() {\n+    // FIXME: this function should not suggest the `foo` function.\n+    similar_unstable_method::foo1();\n+    //~^ ERROR cannot find function `foo1` in crate `similar_unstable_method` [E0425]\n+\n+    let foo = similar_unstable_method::Foo;\n+    foo.foo1();\n+    //~^ ERROR no method named `foo1` found for struct `Foo` in the current scope [E0599]\n+}"}, {"sha": "9c2ac591ace05374c6259c3965ffa317e448d210", "filename": "tests/ui/stability-attribute/issue-109177.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstability-attribute%2Fissue-109177.stderr?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find function `foo1` in crate `similar_unstable_method`\n+  --> $DIR/issue-109177.rs:7:30\n+   |\n+LL |     similar_unstable_method::foo1();\n+   |                              ^^^^ help: a function with a similar name exists: `foo`\n+   |\n+  ::: $DIR/auxiliary/similar-unstable-method.rs:5:1\n+   |\n+LL | pub fn foo() {}\n+   | ------------ similarly named function `foo` defined here\n+\n+error[E0599]: no method named `foo1` found for struct `Foo` in the current scope\n+  --> $DIR/issue-109177.rs:11:9\n+   |\n+LL |     foo.foo1();\n+   |         ^^^^ method not found in `Foo`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0425, E0599.\n+For more information about an error, try `rustc --explain E0425`."}, {"sha": "e6f7dc410b6147512fcbd31fd377202cff4bf9ce", "filename": "tests/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -228,5 +228,4 @@ fn evens_squared(n: usize) -> _ {\n \n const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n //~^ ERROR the trait bound\n-//~| ERROR the trait bound\n //~| ERROR the placeholder"}, {"sha": "9144ab9e3a6bd39daea117d723c949abeaa5b094", "filename": "tests/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8826b68c623619161d499f8138614a0edd741bc8/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=8826b68c623619161d499f8138614a0edd741bc8", "patch": "@@ -437,19 +437,6 @@ LL | fn evens_squared(n: usize) -> _ {\n    |                               not allowed in type signatures\n    |                               help: replace with an appropriate return type: `impl Iterator<Item = usize>`\n \n-error[E0277]: the trait bound `std::ops::Range<{integer}>: Iterator` is not satisfied\n-  --> $DIR/typeck_type_placeholder_item.rs:229:22\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |                      ^^^^^^ `std::ops::Range<{integer}>` is not an iterator\n-   |\n-   = help: the trait `~const Iterator` is not implemented for `std::ops::Range<{integer}>`\n-note: the trait `Iterator` is implemented for `std::ops::Range<{integer}>`, but that implementation is not `const`\n-  --> $DIR/typeck_type_placeholder_item.rs:229:14\n-   |\n-LL | const _: _ = (1..10).filter(|x| x % 2 == 0).map(|x| x * x);\n-   |              ^^^^^^^\n-\n error[E0277]: the trait bound `Filter<std::ops::Range<{integer}>, [closure@$DIR/typeck_type_placeholder_item.rs:229:29: 229:32]>: Iterator` is not satisfied\n   --> $DIR/typeck_type_placeholder_item.rs:229:45\n    |\n@@ -677,7 +664,7 @@ LL |     const D: _ = 42;\n    |              not allowed in type signatures\n    |              help: replace with the correct type: `i32`\n \n-error: aborting due to 73 previous errors\n+error: aborting due to 72 previous errors\n \n Some errors have detailed explanations: E0121, E0277, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}]}