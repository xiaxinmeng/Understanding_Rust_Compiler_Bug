{"sha": "a923278c6278c63468d74772c58dbf788e88f58c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MjMyNzhjNjI3OGM2MzQ2OGQ3NDc3MmM1OGRiZjc4OGU4OGY1OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-25T14:14:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-25T14:14:04Z"}, "message": "Auto merge of #23697 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #23617, #23664, #23680, #23684, #23692, #23693\n- Failed merges:", "tree": {"sha": "52ebffa2c227d1ff4ad12aa0d9cf04a759fadff9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52ebffa2c227d1ff4ad12aa0d9cf04a759fadff9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a923278c6278c63468d74772c58dbf788e88f58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a923278c6278c63468d74772c58dbf788e88f58c", "html_url": "https://github.com/rust-lang/rust/commit/a923278c6278c63468d74772c58dbf788e88f58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a923278c6278c63468d74772c58dbf788e88f58c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "928e2e23945493a18bfc658a0adf2c06cb764e83", "url": "https://api.github.com/repos/rust-lang/rust/commits/928e2e23945493a18bfc658a0adf2c06cb764e83", "html_url": "https://github.com/rust-lang/rust/commit/928e2e23945493a18bfc658a0adf2c06cb764e83"}, {"sha": "e962a1d51e28579debb7ce0aa7e9ebaa95947218", "url": "https://api.github.com/repos/rust-lang/rust/commits/e962a1d51e28579debb7ce0aa7e9ebaa95947218", "html_url": "https://github.com/rust-lang/rust/commit/e962a1d51e28579debb7ce0aa7e9ebaa95947218"}], "stats": {"total": 190, "additions": 119, "deletions": 71}, "files": [{"sha": "e4bc6a393c4918dc4110f4d619c76c8729061823", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -563,6 +563,8 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n+    ///\n+    /// The elements are removed in arbitrary order.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]"}, {"sha": "688d730e2528744c03f49903d7928a0610384a29", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -13,25 +13,23 @@\n //! The `slice` module contains useful code to help work with slice values.\n //! Slices are a view into a block of memory represented as a pointer and a length.\n //!\n-//! ```rust\n-//! # #![feature(core)]\n+//! ```\n //! // slicing a Vec\n-//! let vec = vec!(1, 2, 3);\n-//! let int_slice = vec.as_slice();\n+//! let vec = vec![1, 2, 3];\n+//! let int_slice = &vec[..];\n //! // coercing an array to a slice\n //! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n //! ```\n //!\n //! Slices are either mutable or shared. The shared slice type is `&[T]`,\n-//! while the mutable slice type is `&mut[T]`. For example, you can mutate the\n-//! block of memory that a mutable slice points to:\n+//! while the mutable slice type is `&mut [T]`, where `T` represents the element\n+//! type. For example, you can mutate the block of memory that a mutable slice\n+//! points to:\n //!\n-//! ```rust\n-//! let x: &mut[i32] = &mut [1, 2, 3];\n+//! ```\n+//! let x = &mut [1, 2, 3];\n //! x[1] = 7;\n-//! assert_eq!(x[0], 1);\n-//! assert_eq!(x[1], 7);\n-//! assert_eq!(x[2], 3);\n+//! assert_eq!(x, &[1, 7, 3]);\n //! ```\n //!\n //! Here are some of the things this module contains:\n@@ -41,49 +39,43 @@\n //! There are several structs that are useful for slices, such as `Iter`, which\n //! represents iteration over a slice.\n //!\n-//! ## Traits\n-//!\n-//! A number of traits add methods that allow you to accomplish tasks\n-//! with slices, the most important being `SliceExt`. Other traits\n-//! apply only to slices of elements satisfying certain bounds (like\n-//! `Ord`).\n-//!\n-//! An example is the `slice` method which enables slicing syntax `[a..b]` that\n-//! returns an immutable \"view\" into a `Vec` or another slice from the index\n-//! interval `[a, b)`:\n-//!\n-//! ```rust\n-//! fn main() {\n-//!     let numbers = [0, 1, 2];\n-//!     let last_numbers = &numbers[1..3];\n-//!     // last_numbers is now &[1, 2]\n-//! }\n-//! ```\n-//!\n-//! ## Implementations of other traits\n+//! ## Trait Implementations\n //!\n //! There are several implementations of common traits for slices. Some examples\n //! include:\n //!\n //! * `Clone`\n-//! * `Eq`, `Ord` - for immutable slices whose element type are `Eq` or `Ord`.\n+//! * `Eq`, `Ord` - for slices whose element type are `Eq` or `Ord`.\n //! * `Hash` - for slices whose element type is `Hash`\n //!\n //! ## Iteration\n //!\n-//! The method `iter()` returns an iteration value for a slice. The iterator\n-//! yields references to the slice's elements, so if the element\n-//! type of the slice is `isize`, the element type of the iterator is `&isize`.\n+//! The slices implement `IntoIterator`. The iterators of yield references\n+//! to the slice elements.\n //!\n-//! ```rust\n-//! let numbers = [0, 1, 2];\n-//! for &x in numbers.iter() {\n-//!     println!(\"{} is a number!\", x);\n+//! ```\n+//! let numbers = &[0, 1, 2];\n+//! for n in numbers {\n+//!     println!(\"{} is a number!\", n);\n //! }\n //! ```\n //!\n-//! * `.iter_mut()` returns an iterator that allows modifying each value.\n-//! * Further iterators exist that split, chunk or permute the slice.\n+//! The mutable slice yields mutable references to the elements:\n+//!\n+//! ```\n+//! let mut scores = [7, 8, 9];\n+//! for score in &mut scores[..] {\n+//!     *score += 1;\n+//! }\n+//! ```\n+//!\n+//! This iterator yields mutable references to the slice's elements, so while the element\n+//! type of the slice is `i32`, the element type of the iterator is `&mut i32`.\n+//!\n+//! * `.iter()` and `.iter_mut()` are the explicit methods to return the default\n+//!   iterators.\n+//! * Further methods that return iterators are `.split()`, `.splitn()`,\n+//!   `.chunks()`, `.windows()` and more.\n \n #![doc(primitive = \"slice\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "aaa73badcac99a1b0c21bf7794b803a82317549f", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -19,7 +19,7 @@\n //! are owned elsewhere.\n //!\n //! Basic operations are implemented directly by the compiler, but more advanced\n-//! operations are defined on the [`StrExt`](trait.StrExt.html) trait.\n+//! operations are defined as methods on the `str` type.\n //!\n //! # Examples\n //!"}, {"sha": "a629e0308e98299611940545977f165618499ac2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -165,8 +165,7 @@ impl FromStr for bool {\n     /// assert!(<bool as FromStr>::from_str(\"not even a boolean\").is_err());\n     /// ```\n     ///\n-    /// Note, in many cases, the StrExt::parse() which is based on\n-    /// this FromStr::from_str() is more proper.\n+    /// Note, in many cases, the `.parse()` method on `str` is more proper.\n     ///\n     /// ```\n     /// assert_eq!(\"true\".parse(), Ok(true));\n@@ -531,7 +530,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n ///\n-/// Created with `StrExt::bytes`\n+/// Created with `str::bytes`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<slice::Iter<'a, u8>, BytesDeref>);\n@@ -1489,27 +1488,27 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n     fn as_slice(&self) -> &str { Str::as_slice(*self) }\n }\n \n-/// Return type of `StrExt::split`\n+/// Return type of `str::split`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : Split<'a, P>}\n \n-/// Return type of `StrExt::split_terminator`\n+/// Return type of `str::split_terminator`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n-/// Return type of `StrExt::splitn`\n+/// Return type of `str::splitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n-/// Return type of `StrExt::rsplit`\n+/// Return type of `str::rsplit`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplit<'a, P: Pattern<'a>>(RCharSplits<'a, P>);\n delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n \n-/// Return type of `StrExt::rsplitn`\n+/// Return type of `str::rsplitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}"}, {"sha": "c48b63cdcb6c4bccc640fff215ce3a650a90c720", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -1352,12 +1352,12 @@ impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n     fn mutate(&mut self, _: ast::NodeId, _: Span, cmt: mc::cmt, _: euv::MutateMode) {\n         match cmt.cat {\n             mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n-            mc::cat_local(vid) => self.reassigned = self.node == vid,\n+            mc::cat_local(vid) => self.reassigned |= self.node == vid,\n             mc::cat_interior(ref base_cmt, mc::InteriorField(field)) => {\n                 match base_cmt.cat {\n                     mc::cat_upvar(mc::Upvar { id: ty::UpvarId { var_id: vid, .. }, .. }) |\n                     mc::cat_local(vid) => {\n-                        self.reassigned = self.node == vid && Some(field) == self.field\n+                        self.reassigned |= self.node == vid && Some(field) == self.field\n                     },\n                     _ => {}\n                 }"}, {"sha": "ba8de6da42f72210abebe59610ea99cec0d99617", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -1766,6 +1766,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       ast::BiAdd => {\n         if is_float {\n             FAdd(bcx, lhs, rhs, binop_debug_loc)\n+        } else if is_simd {\n+            Add(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             let (newbcx, res) = with_overflow_check(\n                 bcx, OverflowOp::Add, info, lhs_t, lhs, rhs, binop_debug_loc);\n@@ -1776,6 +1778,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       ast::BiSub => {\n         if is_float {\n             FSub(bcx, lhs, rhs, binop_debug_loc)\n+        } else if is_simd {\n+            Sub(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             let (newbcx, res) = with_overflow_check(\n                 bcx, OverflowOp::Sub, info, lhs_t, lhs, rhs, binop_debug_loc);\n@@ -1786,6 +1790,8 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       ast::BiMul => {\n         if is_float {\n             FMul(bcx, lhs, rhs, binop_debug_loc)\n+        } else if is_simd {\n+            Mul(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             let (newbcx, res) = with_overflow_check(\n                 bcx, OverflowOp::Mul, info, lhs_t, lhs, rhs, binop_debug_loc);"}, {"sha": "0ed6d07bf79185331c6fb8a383cd99a44b96541b", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -631,14 +631,14 @@ pub trait BufRead: Read {\n \n /// A `Write` adaptor which will write data to multiple locations.\n ///\n-/// For more information, see `WriteExt::broadcast`.\n-#[unstable(feature = \"io\", reason = \"awaiting stability of WriteExt::broadcast\")]\n+/// For more information, see `Write::broadcast`.\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Write::broadcast\")]\n pub struct Broadcast<T, U> {\n     first: T,\n     second: U,\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of WriteExt::broadcast\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Write::broadcast\")]\n impl<T: Write, U: Write> Write for Broadcast<T, U> {\n     fn write(&mut self, data: &[u8]) -> Result<usize> {\n         let n = try!(self.first.write(data));\n@@ -654,7 +654,7 @@ impl<T: Write, U: Write> Write for Broadcast<T, U> {\n \n /// Adaptor to chain together two instances of `Read`.\n ///\n-/// For more information, see `ReadExt::chain`.\n+/// For more information, see `Read::chain`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<T, U> {\n     first: T,\n@@ -677,7 +677,7 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n \n /// Reader adaptor which limits the bytes read from an underlying reader.\n ///\n-/// For more information, see `ReadExt::take`.\n+/// For more information, see `Read::take`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Take<T> {\n     inner: T,\n@@ -730,14 +730,14 @@ impl<T: BufRead> BufRead for Take<T> {\n \n /// An adaptor which will emit all read data to a specified writer as well.\n ///\n-/// For more information see `ReadExt::tee`\n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::tee\")]\n+/// For more information see `Read::tee`\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::tee\")]\n pub struct Tee<R, W> {\n     reader: R,\n     writer: W,\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::tee\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::tee\")]\n impl<R: Read, W: Write> Read for Tee<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n         let n = try!(self.reader.read(buf));\n@@ -749,7 +749,7 @@ impl<R: Read, W: Write> Read for Tee<R, W> {\n \n /// A bridge from implementations of `Read` to an `Iterator` of `u8`.\n ///\n-/// See `ReadExt::bytes` for more information.\n+/// See `Read::bytes` for more information.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Bytes<R> {\n     inner: R,\n@@ -771,16 +771,16 @@ impl<R: Read> Iterator for Bytes<R> {\n \n /// A bridge from implementations of `Read` to an `Iterator` of `char`.\n ///\n-/// See `ReadExt::chars` for more information.\n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+/// See `Read::chars` for more information.\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n pub struct Chars<R> {\n     inner: R,\n }\n \n /// An enumeration of possible errors that can be generated from the `Chars`\n /// adapter.\n #[derive(PartialEq, Clone, Debug)]\n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n pub enum CharsError {\n     /// Variant representing that the underlying stream was read successfully\n     /// but it did not contain valid utf8 data.\n@@ -790,7 +790,7 @@ pub enum CharsError {\n     Other(Error),\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n impl<R: Read> Iterator for Chars<R> {\n     type Item = result::Result<char, CharsError>;\n \n@@ -822,7 +822,7 @@ impl<R: Read> Iterator for Chars<R> {\n     }\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n impl std_error::Error for CharsError {\n     fn description(&self) -> &str {\n         match *self {\n@@ -838,7 +838,7 @@ impl std_error::Error for CharsError {\n     }\n }\n \n-#[unstable(feature = \"io\", reason = \"awaiting stability of ReadExt::chars\")]\n+#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\")]\n impl fmt::Display for CharsError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "333ae8f26a0d7fa028429ebedeca4218b96cb6a6", "filename": "src/libstd/io/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fio%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fio%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprelude.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -18,7 +18,7 @@\n //! ```\n //!\n //! This module contains reexports of many core I/O traits such as `Read`,\n-//! `Write`, `ReadExt`, and `WriteExt`. Structures and functions are not\n+//! `Write` and `BufRead`. Structures and functions are not\n //! contained in this module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "c73d30d543ac5ebb93419d0d2e9ef1b6d9520fef", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -206,7 +206,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         if sz == 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(PathBuf::new::<OsString>(OsStringExt::from_vec(v)))\n+        Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n }\n \n@@ -232,7 +232,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n             Err(io::Error::last_os_error())\n         } else {\n             let vec = CStr::from_ptr(v).to_bytes().to_vec();\n-            Ok(PathBuf::new::<OsString>(OsStringExt::from_vec(vec)))\n+            Ok(PathBuf::from(OsString::from_vec(vec)))\n         }\n     }\n }\n@@ -345,7 +345,7 @@ pub fn args() -> Args {\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8_sel));\n             let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n-            res.push(OsString::from_str(str::from_utf8(bytes).unwrap()))\n+            res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n         }\n     }\n "}, {"sha": "5257daa047af8b1f1d99be86e7fc7256fe136a76", "filename": "src/test/run-pass/issue-23037.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Ftest%2Frun-pass%2Fissue-23037.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Ftest%2Frun-pass%2Fissue-23037.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23037.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+\n+use std::simd::i32x4;\n+fn main() {\n+    let foo = i32x4(1,2,3,4);\n+    let bar = i32x4(40,30,20,10);\n+    let baz = foo + bar;\n+    assert!(baz.0 == 41 && baz.1 == 32 && baz.2 == 23 && baz.3 == 14);\n+}"}, {"sha": "759296ad46b877ce7f979404f2b9a1bfcbf67fe0", "filename": "src/test/run-pass/match-reassign.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a923278c6278c63468d74772c58dbf788e88f58c/src%2Ftest%2Frun-pass%2Fmatch-reassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a923278c6278c63468d74772c58dbf788e88f58c/src%2Ftest%2Frun-pass%2Fmatch-reassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-reassign.rs?ref=a923278c6278c63468d74772c58dbf788e88f58c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #23698: The reassignment checker only cared\n+// about the last assigment in a match arm body\n+\n+// Use an extra function to make sure no extra assignments\n+// are introduced by macros in the match statement\n+fn check_eq(x: i32, y: i32) {\n+    assert_eq!(x, y);\n+}\n+\n+#[allow(unused_assignments)]\n+fn main() {\n+    let mut x = Box::new(1);\n+    match x {\n+        y => {\n+            x = Box::new(2);\n+            let _tmp = 1; // This assignment used to throw off the reassignment checker\n+            check_eq(*y, 1);\n+        }\n+    }\n+}"}]}