{"sha": "c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "node_id": "C_kwDOAAsO6NoAKGM3Y2U2OWZhZjJhN2VhMTZjMTVkOTIyOTg1Y2EyN2JhNzBkYTMwZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-20T11:20:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-20T11:20:26Z"}, "message": "Auto merge of #92962 - frank-king:btree_entry_no_insert, r=Amanieu\n\nBTreeMap::entry: Avoid allocating if no insertion\n\nThis PR allows the `VacantEntry` to borrow from an empty tree with no root, and to lazily allocate a new root node when the user calls `.insert(value)`.", "tree": {"sha": "0b498288a7545b780a74c411b8833fe51c8c8a2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b498288a7545b780a74c411b8833fe51c8c8a2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "html_url": "https://github.com/rust-lang/rust/commit/c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b84829750cdd74132530642623a8a5f3a7daaa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b84829750cdd74132530642623a8a5f3a7daaa9", "html_url": "https://github.com/rust-lang/rust/commit/3b84829750cdd74132530642623a8a5f3a7daaa9"}, {"sha": "2c3c891df0c4f0c29caee10c7289502ca801ff98", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3c891df0c4f0c29caee10c7289502ca801ff98", "html_url": "https://github.com/rust-lang/rust/commit/2c3c891df0c4f0c29caee10c7289502ca801ff98"}], "stats": {"total": 127, "additions": 86, "deletions": 41}, "files": [{"sha": "c178d3e3b03c918cfa83f7b36e10f776a57dbe00", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "patch": "@@ -212,7 +212,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                     let mut out_tree = clone_subtree(internal.first_edge().descend());\n \n                     {\n-                        let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n+                        let out_root = out_tree.root.as_mut().unwrap();\n                         let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n@@ -278,11 +278,12 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n+        let root_node = map.root.get_or_insert_with(Root::new).borrow_mut();\n         match root_node.search_tree::<K>(&key) {\n             Found(mut kv) => Some(mem::replace(kv.key_mut(), key)),\n             GoDown(handle) => {\n-                VacantEntry { key, handle, dormant_map, _marker: PhantomData }.insert(());\n+                VacantEntry { key, handle: Some(handle), dormant_map, _marker: PhantomData }\n+                    .insert(());\n                 None\n             }\n         }\n@@ -1032,7 +1033,7 @@ impl<K, V> BTreeMap<K, V> {\n \n         let self_iter = mem::take(self).into_iter();\n         let other_iter = mem::take(other).into_iter();\n-        let root = BTreeMap::ensure_is_owned(&mut self.root);\n+        let root = self.root.get_or_insert_with(Root::new);\n         root.append_from_sorted_iters(self_iter, other_iter, &mut self.length)\n     }\n \n@@ -1144,14 +1145,20 @@ impl<K, V> BTreeMap<K, V> {\n     where\n         K: Ord,\n     {\n-        // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n-        let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n-        match root_node.search_tree(&key) {\n-            Found(handle) => Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData }),\n-            GoDown(handle) => {\n-                Vacant(VacantEntry { key, handle, dormant_map, _marker: PhantomData })\n-            }\n+        match map.root {\n+            None => Vacant(VacantEntry { key, handle: None, dormant_map, _marker: PhantomData }),\n+            Some(ref mut root) => match root.borrow_mut().search_tree(&key) {\n+                Found(handle) => {\n+                    Occupied(OccupiedEntry { handle, dormant_map, _marker: PhantomData })\n+                }\n+                GoDown(handle) => Vacant(VacantEntry {\n+                    key,\n+                    handle: Some(handle),\n+                    dormant_map,\n+                    _marker: PhantomData,\n+                }),\n+            },\n         }\n     }\n \n@@ -2247,12 +2254,6 @@ impl<K, V> BTreeMap<K, V> {\n     pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n-\n-    /// If the root node is the empty (non-allocated) root node, allocate our\n-    /// own node. Is an associated function to avoid borrowing the entire BTreeMap.\n-    fn ensure_is_owned(root: &mut Option<Root<K, V>>) -> &mut Root<K, V> {\n-        root.get_or_insert_with(Root::new)\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "cacd06b5df153da6b6f629bc813c0ed1fb2d7202", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "patch": "@@ -40,7 +40,8 @@ impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     pub(super) key: K,\n-    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    /// `None` for a (empty) map without root\n+    pub(super) handle: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n     pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n \n     // Be invariant in `K` and `V`\n@@ -312,22 +313,33 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n-            (None, val_ptr) => {\n-                // SAFETY: We have consumed self.handle and the handle returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                map.length += 1;\n-                val_ptr\n-            }\n-            (Some(ins), val_ptr) => {\n-                drop(ins.left);\n+        let out_ptr = match self.handle {\n+            None => {\n                 // SAFETY: We have consumed self.handle and the reference returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n-                let root = map.root.as_mut().unwrap();\n-                root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);\n-                map.length += 1;\n+                let mut root = NodeRef::new_leaf();\n+                let val_ptr = root.borrow_mut().push(self.key, value) as *mut V;\n+                map.root = Some(root.forget_type());\n+                map.length = 1;\n                 val_ptr\n             }\n+            Some(handle) => match handle.insert_recursing(self.key, value) {\n+                (None, val_ptr) => {\n+                    // SAFETY: We have consumed self.handle and the handle returned.\n+                    let map = unsafe { self.dormant_map.awaken() };\n+                    map.length += 1;\n+                    val_ptr\n+                }\n+                (Some(ins), val_ptr) => {\n+                    drop(ins.left);\n+                    // SAFETY: We have consumed self.handle and the reference returned.\n+                    let map = unsafe { self.dormant_map.awaken() };\n+                    let root = map.root.as_mut().unwrap();\n+                    root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);\n+                    map.length += 1;\n+                    val_ptr\n+                }\n+            },\n         };\n         // Now that we have finished growing the tree using borrowed references,\n         // dereference the pointer to a part of it, that we picked up along the way."}, {"sha": "cc986e93698b7cd1387173fd33165235ff933b5c", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "patch": "@@ -115,8 +115,9 @@ impl<K, V> BTreeMap<K, V> {\n         K: Ord,\n     {\n         let iter = mem::take(self).into_iter();\n-        let root = BTreeMap::ensure_is_owned(&mut self.root);\n-        root.bulk_push(iter, &mut self.length);\n+        if !iter.is_empty() {\n+            self.root.insert(Root::new()).bulk_push(iter, &mut self.length);\n+        }\n     }\n }\n \n@@ -914,7 +915,7 @@ mod test_drain_filter {\n     fn empty() {\n         let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n         map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n-        assert!(map.is_empty());\n+        assert_eq!(map.height(), None);\n         map.check();\n     }\n \n@@ -1410,7 +1411,7 @@ fn test_clear() {\n         assert_eq!(map.len(), len);\n         map.clear();\n         map.check();\n-        assert!(map.is_empty());\n+        assert_eq!(map.height(), None);\n     }\n }\n \n@@ -1789,7 +1790,7 @@ fn test_occupied_entry_key() {\n     let mut a = BTreeMap::new();\n     let key = \"hello there\";\n     let value = \"value goes here\";\n-    assert!(a.is_empty());\n+    assert_eq!(a.height(), None);\n     a.insert(key, value);\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n@@ -1809,9 +1810,9 @@ fn test_vacant_entry_key() {\n     let key = \"hello there\";\n     let value = \"value goes here\";\n \n-    assert!(a.is_empty());\n+    assert_eq!(a.height(), None);\n     match a.entry(key) {\n-        Occupied(_) => panic!(),\n+        Occupied(_) => unreachable!(),\n         Vacant(e) => {\n             assert_eq!(key, *e.key());\n             e.insert(value);\n@@ -1822,6 +1823,36 @@ fn test_vacant_entry_key() {\n     a.check();\n }\n \n+#[test]\n+fn test_vacant_entry_no_insert() {\n+    let mut a = BTreeMap::<&str, ()>::new();\n+    let key = \"hello there\";\n+\n+    // Non-allocated\n+    assert_eq!(a.height(), None);\n+    match a.entry(key) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(e) => assert_eq!(key, *e.key()),\n+    }\n+    // Ensures the tree has no root.\n+    assert_eq!(a.height(), None);\n+    a.check();\n+\n+    // Allocated but still empty\n+    a.insert(key, ());\n+    a.remove(&key);\n+    assert_eq!(a.height(), Some(0));\n+    assert!(a.is_empty());\n+    match a.entry(key) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(e) => assert_eq!(key, *e.key()),\n+    }\n+    // Ensures the allocated root is not changed.\n+    assert_eq!(a.height(), Some(0));\n+    assert!(a.is_empty());\n+    a.check();\n+}\n+\n #[test]\n fn test_first_last_entry() {\n     let mut a = BTreeMap::new();"}, {"sha": "b5f0edf6b33a722b1659c5475ffbc7303193d2f3", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ce69faf2a7ea16c15d922985ca27ba70da30ee/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=c7ce69faf2a7ea16c15d922985ca27ba70da30ee", "patch": "@@ -213,7 +213,7 @@ unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type>\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Dying, K, V, Type> {}\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n-    fn new_leaf() -> Self {\n+    pub fn new_leaf() -> Self {\n         Self::from_new_leaf(LeafNode::new())\n     }\n \n@@ -619,15 +619,16 @@ impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n-    /// Adds a key-value pair to the end of the node.\n-    pub fn push(&mut self, key: K, val: V) {\n+    /// Adds a key-value pair to the end of the node, and returns\n+    /// the mutable reference of the inserted value.\n+    pub fn push(&mut self, key: K, val: V) -> &mut V {\n         let len = self.len_mut();\n         let idx = usize::from(*len);\n         assert!(idx < CAPACITY);\n         *len += 1;\n         unsafe {\n             self.key_area_mut(idx).write(key);\n-            self.val_area_mut(idx).write(val);\n+            self.val_area_mut(idx).write(val)\n         }\n     }\n }"}]}