{"sha": "cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiN2ZjZGQ1MjBkODI5N2JiYjJiZWE2ZTBhMDE3ZDFiNWRmMGI4MTk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-06T00:19:54Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-12T02:14:23Z"}, "message": "Impl and trait item sigs", "tree": {"sha": "b7f03cd9045e21d7ff7b25fdece0f4bd19d5ccb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7f03cd9045e21d7ff7b25fdece0f4bd19d5ccb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "html_url": "https://github.com/rust-lang/rust/commit/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebb0e2498edc84093003d8053a7d11e51536120", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebb0e2498edc84093003d8053a7d11e51536120", "html_url": "https://github.com/rust-lang/rust/commit/5ebb0e2498edc84093003d8053a7d11e51536120"}], "stats": {"total": 205, "additions": 178, "deletions": 27}, "files": [{"sha": "ea346d99e31b5a4ed47be3725d9a1cfb71001204", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "patch": "@@ -392,13 +392,13 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                       sig: &'l ast::MethodSig,\n                       body: Option<&'l ast::Block>,\n                       id: ast::NodeId,\n-                      name: ast::Name,\n+                      name: ast::Ident,\n                       vis: Visibility,\n                       attrs: &'l [Attribute],\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n-        if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n+        if let Some(method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n \n             let sig_str = ::make_signature(&sig.decl, &sig.generics);\n             if body.is_some() {\n@@ -424,7 +424,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             Some(id) => {\n                                 for item in self.tcx.associated_items(id) {\n                                     if item.kind == ty::AssociatedKind::Method {\n-                                        if item.name == name {\n+                                        if item.name == name.name {\n                                             decl_id = Some(item.def_id);\n                                             break;\n                                         }\n@@ -456,7 +456,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     parent: trait_id,\n                     visibility: vis,\n                     docs: docs_for_attrs(attrs),\n-                    sig: method_data.sig,\n+                    sig: sig::method_signature(id, name, sig, &self.save_ctxt),\n                     attributes: attrs.to_vec(),\n                 }.lower(self.tcx));\n             }\n@@ -581,13 +581,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                            name: ast::Name,\n                            span: Span,\n                            typ: &'l ast::Ty,\n-                           expr: &'l ast::Expr,\n+                           expr: Option<&'l ast::Expr>,\n                            parent_id: DefId,\n                            vis: Visibility,\n                            attrs: &'l [Attribute]) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n+        let value = expr.map(|e| self.span.snippet(e.span)).unwrap_or(String::new());\n \n         if !self.span.filter_generated(sub_span, span) {\n             self.dumper.variable(VariableData {\n@@ -596,20 +597,22 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 id: id,\n                 name: name.to_string(),\n                 qualname: qualname,\n-                value: self.span.snippet(expr.span),\n+                value: value,\n                 type_value: ty_to_string(&typ),\n                 scope: self.cur_scope,\n                 parent: Some(parent_id),\n                 visibility: vis,\n                 docs: docs_for_attrs(attrs),\n-                sig: None,\n+                sig: sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt),\n                 attributes: attrs.to_vec(),\n             }.lower(self.tcx));\n         }\n \n         // walk type and init value\n         self.visit_ty(typ);\n-        self.visit_expr(expr);\n+        if let Some(expr) = expr {\n+            self.visit_expr(expr);\n+        }\n     }\n \n     // FIXME tuple structs should generate tuple-specific data.\n@@ -1122,12 +1125,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span, trait_item.id);\n         match trait_item.node {\n-            ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n+            ast::TraitItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(trait_item.id,\n                                          trait_item.ident.name,\n                                          trait_item.span,\n                                          &ty,\n-                                         &expr,\n+                                         expr.as_ref().map(|e| &**e),\n                                          trait_id,\n                                          Visibility::Public,\n                                          &trait_item.attrs);\n@@ -1136,12 +1139,12 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.process_method(sig,\n                                     body.as_ref().map(|x| &**x),\n                                     trait_item.id,\n-                                    trait_item.ident.name,\n+                                    trait_item.ident,\n                                     Visibility::Public,\n                                     &trait_item.attrs,\n                                     trait_item.span);\n             }\n-            ast::TraitItemKind::Type(ref _bounds, ref default_ty) => {\n+            ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\", self.tcx.node_path_str(trait_item.id));\n@@ -1157,7 +1160,11 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         visibility: Visibility::Public,\n                         parent: Some(trait_id),\n                         docs: docs_for_attrs(&trait_item.attrs),\n-                        sig: None,\n+                        sig: sig::assoc_type_signature(trait_item.id,\n+                                                       trait_item.ident,\n+                                                       Some(bounds),\n+                                                       default_ty.as_ref().map(|ty| &**ty),\n+                                                       &self.save_ctxt),\n                         attributes: trait_item.attrs.clone(),\n                     }.lower(self.tcx));\n                 }\n@@ -1166,7 +1173,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     self.visit_ty(default_ty)\n                 }\n             }\n-            ast::TraitItemKind::Const(ref ty, None) => self.visit_ty(ty),\n             ast::TraitItemKind::Macro(_) => {}\n         }\n     }\n@@ -1179,7 +1185,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                                          impl_item.ident.name,\n                                          impl_item.span,\n                                          &ty,\n-                                         &expr,\n+                                         Some(expr),\n                                          impl_id,\n                                          From::from(&impl_item.vis),\n                                          &impl_item.attrs);\n@@ -1188,12 +1194,17 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 self.process_method(sig,\n                                     Some(body),\n                                     impl_item.id,\n-                                    impl_item.ident.name,\n+                                    impl_item.ident,\n                                     From::from(&impl_item.vis),\n                                     &impl_item.attrs,\n                                     impl_item.span);\n             }\n-            ast::ImplItemKind::Type(ref ty) => self.visit_ty(ty),\n+            ast::ImplItemKind::Type(ref ty) => {\n+                // FIXME uses of the assoc type should ideally point to this\n+                // 'def' and the name here should be a ref to the def in the\n+                // trait.\n+                self.visit_ty(ty)\n+            }\n             ast::ImplItemKind::Macro(_) => {}\n         }\n     }"}, {"sha": "4802494f08ead317b242dff8b8cceb95872dd3fd", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "patch": "@@ -369,8 +369,11 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     // FIXME would be nice to take a MethodItem here, but the ast provides both\n     // trait and impl flavours, so the caller must do the disassembly.\n-    pub fn get_method_data(&self, id: ast::NodeId,\n-                           name: ast::Name, span: Span) -> Option<FunctionData> {\n+    pub fn get_method_data(&self,\n+                           id: ast::NodeId,\n+                           name: ast::Name,\n+                           span: Span)\n+                           -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n         let (qualname, parent_scope, decl_id, vis, docs, attributes) =\n@@ -460,7 +463,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             visibility: vis,\n             parent: parent_scope,\n             docs: docs,\n-            // TODO\n             sig: None,\n             attributes: attributes,\n         })"}, {"sha": "1d03ab1383af1853505fa5edc88043e94b5702fb", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 145, "deletions": 7, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=cb7fcdd520d8297bbb2bea6e0a017d1b5df0b819", "patch": "@@ -14,7 +14,7 @@\n //\n // ```\n // fn foo(x: String) {\n-//     println!(\"{}\", x);   \n+//     println!(\"{}\", x);\n // }\n // ```\n // The signature string is something like \"fn foo(x: String) {}\" and the signature\n@@ -63,6 +63,32 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext) -> Option<Si\n     variant.node.make(0, None, scx).ok()\n }\n \n+pub fn method_signature(id: NodeId,\n+                        ident: ast::Ident,\n+                        m: &ast::MethodSig,\n+                        scx: &SaveContext)\n+                        -> Option<Signature> {\n+    make_method_signature(id, ident, m, scx).ok()\n+}\n+\n+pub fn assoc_const_signature(id: NodeId,\n+                             ident: ast::Name,\n+                             ty: &ast::Ty,\n+                             default: Option<&ast::Expr>,\n+                             scx: &SaveContext)\n+                             -> Option<Signature> {\n+    make_assoc_const_signature(id, ident, ty, default, scx).ok()\n+}\n+\n+pub fn assoc_type_signature(id: NodeId,\n+                            ident: ast::Ident,\n+                            bounds: Option<&ast::TyParamBounds>,\n+                            default: Option<&ast::Ty>,\n+                            scx: &SaveContext)\n+                            -> Option<Signature> {\n+    make_assoc_type_signature(id, ident, bounds, default, scx).ok()\n+}\n+\n type Result = ::std::result::Result<Signature, &'static str>;\n \n trait Sig {\n@@ -215,7 +241,7 @@ impl Sig for ast::Ty {\n                     format!(\"<{} as {}>::\", nested_ty.text, first)\n                 } else {\n                     // FIXME handle path instead of elipses.\n-                    format!(\"<{} as ...>::\", nested_ty.text)                    \n+                    format!(\"<{} as ...>::\", nested_ty.text)\n                 };\n \n                 let name = pprust::path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n@@ -263,7 +289,7 @@ impl Sig for ast::Ty {\n             ast::TyKind::ImplicitSelf |\n             ast::TyKind::Mac(_) => Err(\"Ty\"),\n         }\n-    }    \n+    }\n }\n \n impl Sig for ast::Item {\n@@ -497,7 +523,7 @@ impl Sig for ast::Item {\n \n                 let ty_sig = ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty_sig.text);\n-                \n+\n                 text.push_str(\" {}\");\n \n                 Ok(merge_sigs(text, vec![generics_sig, trait_sig, ty_sig]))\n@@ -582,7 +608,9 @@ impl Sig for ast::Generics {\n \n             if !l.bounds.is_empty() {\n                 l_text.push_str(\": \");\n-                let bounds = l.bounds.iter().map(|l| l.ident.to_string()).collect::<Vec<_>>().join(\" + \");\n+                let bounds = l.bounds.iter().map(|l| {\n+                    l.ident.to_string()\n+                }).collect::<Vec<_>>().join(\" + \");\n                 l_text.push_str(&bounds);\n                 // FIXME add lifetime bounds refs.\n             }\n@@ -783,5 +811,115 @@ fn name_and_generics(mut text: String,\n }\n \n \n-// TODO impl items, trait items\n-// for impl/trait sigs - function for each kind, rather than use trait.\n+fn make_assoc_type_signature(id: NodeId,\n+                             ident: ast::Ident,\n+                             bounds: Option<&ast::TyParamBounds>,\n+                             default: Option<&ast::Ty>,\n+                             scx: &SaveContext)\n+                             -> Result {\n+    let mut text = \"type \".to_owned();\n+    let name = ident.to_string();\n+    let mut defs = vec![SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: text.len(),\n+        end: text.len() + name.len(),\n+    }];\n+    let mut refs = vec![];\n+    text.push_str(&name);\n+    if let Some(bounds) = bounds {\n+        text.push_str(\": \");\n+        // FIXME should descend into bounds\n+        text.push_str(&pprust::bounds_to_string(bounds));\n+    }\n+    if let Some(default) = default {\n+        text.push_str(\" = \");\n+        let ty_sig = default.make(text.len(), Some(id), scx)?;\n+        text.push_str(&ty_sig.text);\n+        defs.extend(ty_sig.defs.into_iter());\n+        refs.extend(ty_sig.refs.into_iter());\n+    }\n+    text.push(';');\n+    Ok(Signature { text, defs, refs })\n+}\n+\n+fn make_assoc_const_signature(id: NodeId,\n+                              ident: ast::Name,\n+                              ty: &ast::Ty,\n+                              default: Option<&ast::Expr>,\n+                              scx: &SaveContext)\n+                              -> Result {\n+    let mut text = \"const \".to_owned();\n+    let name = ident.to_string();\n+    let mut defs = vec![SigElement {\n+        id: id_from_node_id(id, scx),\n+        start: text.len(),\n+        end: text.len() + name.len(),\n+    }];\n+    let mut refs = vec![];\n+    text.push_str(&name);\n+    text.push_str(\": \");\n+\n+    let ty_sig = ty.make(text.len(), Some(id), scx)?;\n+    text.push_str(&ty_sig.text);\n+    defs.extend(ty_sig.defs.into_iter());\n+    refs.extend(ty_sig.refs.into_iter());\n+\n+    if let Some(default) = default {\n+        text.push_str(\" = \");\n+        text.push_str(&pprust::expr_to_string(default));\n+    }\n+    text.push(';');\n+    Ok(Signature { text, defs, refs })\n+}\n+\n+fn make_method_signature(id: NodeId,\n+                         ident: ast::Ident,\n+                         m: &ast::MethodSig,\n+                         scx: &SaveContext)\n+                         -> Result {\n+    // FIXME code dup with function signature\n+    let mut text = String::new();\n+    if m.constness.node == ast::Constness::Const {\n+        text.push_str(\"const \");\n+    }\n+    if m.unsafety == ast::Unsafety::Unsafe {\n+        text.push_str(\"unsafe \");\n+    }\n+    if m.abi != ::syntax::abi::Abi::Rust {\n+        text.push_str(\"extern\");\n+        text.push_str(&m.abi.to_string());\n+        text.push(' ');\n+    }\n+    text.push_str(\"fn \");\n+\n+    let mut sig = name_and_generics(text,\n+                                    0,\n+                                    &m.generics,\n+                                    id,\n+                                    ident,\n+                                    scx)?;\n+\n+    sig.text.push('(');\n+    for i in &m.decl.inputs {\n+        // FIXME shoudl descend into patterns to add defs.\n+        sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+        sig.text.push_str(\": \");\n+        let nested = i.ty.make(sig.text.len(), Some(i.id), scx)?;\n+        sig.text.push_str(&nested.text);\n+        sig.text.push(',');\n+        sig.defs.extend(nested.defs.into_iter());\n+        sig.refs.extend(nested.refs.into_iter());\n+    }\n+    sig.text.push(')');\n+\n+    if let ast::FunctionRetTy::Ty(ref t) = m.decl.output {\n+        sig.text.push_str(\" -> \");\n+        let nested = t.make(sig.text.len(), None, scx)?;\n+        sig.text.push_str(&nested.text);\n+        sig.defs.extend(nested.defs.into_iter());\n+        sig.refs.extend(nested.refs.into_iter());\n+    }\n+    sig.text.push_str(\" {}\");\n+\n+    Ok(sig)\n+}"}]}