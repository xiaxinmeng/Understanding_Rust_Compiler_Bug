{"sha": "77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "node_id": "C_kwDOAAsO6NoAKDc3YmY3NjEyMDM1Y2RlYzBkMmE3YjI3ZTU0MDg3ZWQ2Y2IxOWY5ZTg", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T17:11:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-10-02T17:38:39Z"}, "message": "internal: move code to where it's used and reduce visibility", "tree": {"sha": "6c8230c2e55001f6be112a17df928f0aab30b62e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c8230c2e55001f6be112a17df928f0aab30b62e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "html_url": "https://github.com/rust-lang/rust/commit/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e504f8ae8d7e63abd4926a4ea6b1344bba3157d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e504f8ae8d7e63abd4926a4ea6b1344bba3157d1", "html_url": "https://github.com/rust-lang/rust/commit/e504f8ae8d7e63abd4926a4ea6b1344bba3157d1"}], "stats": {"total": 148, "additions": 73, "deletions": 75}, "files": [{"sha": "233ca08dc13d967c8692b8c59785380a87d6f8a8", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "patch": "@@ -63,7 +63,7 @@ use std::rc::Rc;\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, OpDelimited, OpDelimitedIter, RepeatKind, Separator},\n+    parser::{Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n@@ -750,6 +750,64 @@ fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &MetaTemplate) {\n     }\n }\n \n+impl MetaTemplate {\n+    fn iter_delimited<'a>(&'a self, delimited: Option<&'a tt::Delimiter>) -> OpDelimitedIter<'a> {\n+        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum OpDelimited<'a> {\n+    Op(&'a Op),\n+    Open,\n+    Close,\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+struct OpDelimitedIter<'a> {\n+    inner: &'a Vec<Op>,\n+    delimited: Option<&'a tt::Delimiter>,\n+    idx: usize,\n+}\n+\n+impl<'a> OpDelimitedIter<'a> {\n+    fn is_eof(&self) -> bool {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        self.idx >= len\n+    }\n+\n+    fn peek(&self) -> Option<OpDelimited<'a>> {\n+        match self.delimited {\n+            None => self.inner.get(self.idx).map(OpDelimited::Op),\n+            Some(_) => match self.idx {\n+                0 => Some(OpDelimited::Open),\n+                i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n+                i => self.inner.get(i - 1).map(OpDelimited::Op),\n+            },\n+        }\n+    }\n+\n+    fn reset(&self) -> Self {\n+        Self { inner: self.inner, idx: 0, delimited: self.delimited }\n+    }\n+}\n+\n+impl<'a> Iterator for OpDelimitedIter<'a> {\n+    type Item = OpDelimited<'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let res = self.peek();\n+        self.idx += 1;\n+        res\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n+        let remain = len.saturating_sub(self.idx);\n+        (remain, Some(remain))\n+    }\n+}\n+\n impl<'a> TtIter<'a> {\n     fn expect_separator(&mut self, separator: &Separator, idx: usize) -> bool {\n         let mut fork = self.clone();"}, {"sha": "0cce4146fb00ce1cada389931d60668ed9e4d3d1", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 14, "deletions": 74, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77bf7612035cdec0d2a7b27e54087ed6cb19f9e8/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=77bf7612035cdec0d2a7b27e54087ed6cb19f9e8", "patch": "@@ -3,84 +3,23 @@\n \n use smallvec::SmallVec;\n use syntax::SmolStr;\n-use tt::Delimiter;\n \n use crate::{tt_iter::TtIter, ParseError};\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct MetaTemplate(pub(crate) Vec<Op>);\n-\n-#[derive(Debug, Clone, Copy)]\n-pub(crate) enum OpDelimited<'a> {\n-    Op(&'a Op),\n-    Open,\n-    Close,\n-}\n-\n-#[derive(Debug, Clone, Copy)]\n-pub(crate) struct OpDelimitedIter<'a> {\n-    inner: &'a Vec<Op>,\n-    delimited: Option<&'a Delimiter>,\n-    idx: usize,\n-}\n-\n-impl<'a> OpDelimitedIter<'a> {\n-    pub(crate) fn is_eof(&self) -> bool {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n-        self.idx >= len\n-    }\n-\n-    pub(crate) fn peek(&self) -> Option<OpDelimited<'a>> {\n-        match self.delimited {\n-            None => self.inner.get(self.idx).map(OpDelimited::Op),\n-            Some(_) => match self.idx {\n-                0 => Some(OpDelimited::Open),\n-                i if i == self.inner.len() + 1 => Some(OpDelimited::Close),\n-                i => self.inner.get(i - 1).map(OpDelimited::Op),\n-            },\n-        }\n-    }\n-\n-    pub(crate) fn reset(&self) -> Self {\n-        Self { inner: self.inner, idx: 0, delimited: self.delimited }\n-    }\n-}\n-\n-impl<'a> Iterator for OpDelimitedIter<'a> {\n-    type Item = OpDelimited<'a>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let res = self.peek();\n-        self.idx += 1;\n-        res\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.inner.len() + if self.delimited.is_some() { 2 } else { 0 };\n-        let remain = len.saturating_sub(self.idx);\n-        (remain, Some(remain))\n-    }\n+pub(crate) fn parse_template(template: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n+    parse_inner(template, Mode::Template).into_iter().collect()\n }\n \n-impl<'a> MetaTemplate {\n-    pub(crate) fn iter(&self) -> impl Iterator<Item = &Op> {\n-        self.0.iter()\n-    }\n-\n-    pub(crate) fn iter_delimited(\n-        &'a self,\n-        delimited: Option<&'a Delimiter>,\n-    ) -> OpDelimitedIter<'a> {\n-        OpDelimitedIter { inner: &self.0, idx: 0, delimited }\n-    }\n+pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n+    parse_inner(pattern, Mode::Pattern).into_iter().collect()\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n     Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n-    Subtree { tokens: MetaTemplate, delimiter: Option<Delimiter> },\n+    Subtree { tokens: MetaTemplate, delimiter: Option<tt::Delimiter> },\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -97,6 +36,15 @@ pub(crate) enum Separator {\n     Puncts(SmallVec<[tt::Punct; 3]>),\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct MetaTemplate(pub(crate) Vec<Op>);\n+\n+impl MetaTemplate {\n+    pub(crate) fn iter(&self) -> impl Iterator<Item = &Op> {\n+        self.0.iter()\n+    }\n+}\n+\n // Note that when we compare a Separator, we just care about its textual value.\n impl PartialEq for Separator {\n     fn eq(&self, other: &Separator) -> bool {\n@@ -125,14 +73,6 @@ impl Separator {\n     }\n }\n \n-pub(crate) fn parse_template(template: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n-    parse_inner(template, Mode::Template).into_iter().collect()\n-}\n-\n-pub(crate) fn parse_pattern(pattern: &tt::Subtree) -> Result<Vec<Op>, ParseError> {\n-    parse_inner(pattern, Mode::Pattern).into_iter().collect()\n-}\n-\n #[derive(Clone, Copy)]\n enum Mode {\n     Pattern,"}]}