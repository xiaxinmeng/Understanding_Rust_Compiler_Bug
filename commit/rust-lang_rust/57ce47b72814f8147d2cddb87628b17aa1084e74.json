{"sha": "57ce47b72814f8147d2cddb87628b17aa1084e74", "node_id": "C_kwDOAAsO6NoAKDU3Y2U0N2I3MjgxNGY4MTQ3ZDJjZGRiODc2MjhiMTdhYTEwODRlNzQ", "commit": {"author": {"name": "carbotaniuman", "email": "41451839+carbotaniuman@users.noreply.github.com", "date": "2022-06-15T19:55:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-24T20:10:23Z"}, "message": "Handle wildcard pointers in SB", "tree": {"sha": "864f44b50de5828bca72ac4b0368e337a98fcb73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/864f44b50de5828bca72ac4b0368e337a98fcb73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57ce47b72814f8147d2cddb87628b17aa1084e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57ce47b72814f8147d2cddb87628b17aa1084e74", "html_url": "https://github.com/rust-lang/rust/commit/57ce47b72814f8147d2cddb87628b17aa1084e74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57ce47b72814f8147d2cddb87628b17aa1084e74/comments", "author": {"login": "carbotaniuman", "id": 41451839, "node_id": "MDQ6VXNlcjQxNDUxODM5", "avatar_url": "https://avatars.githubusercontent.com/u/41451839?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carbotaniuman", "html_url": "https://github.com/carbotaniuman", "followers_url": "https://api.github.com/users/carbotaniuman/followers", "following_url": "https://api.github.com/users/carbotaniuman/following{/other_user}", "gists_url": "https://api.github.com/users/carbotaniuman/gists{/gist_id}", "starred_url": "https://api.github.com/users/carbotaniuman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carbotaniuman/subscriptions", "organizations_url": "https://api.github.com/users/carbotaniuman/orgs", "repos_url": "https://api.github.com/users/carbotaniuman/repos", "events_url": "https://api.github.com/users/carbotaniuman/events{/privacy}", "received_events_url": "https://api.github.com/users/carbotaniuman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcaa7a7221b3b25a1ad6cdb30d30739e0ea4d331", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcaa7a7221b3b25a1ad6cdb30d30739e0ea4d331", "html_url": "https://github.com/rust-lang/rust/commit/dcaa7a7221b3b25a1ad6cdb30d30739e0ea4d331"}], "stats": {"total": 370, "additions": 282, "deletions": 88}, "files": [{"sha": "c2a7a34a9cc082ceedb31d08cd19cab838b6c873", "filename": "src/machine.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -489,7 +489,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     type AllocExtra = AllocExtra;\n \n     type PointerTag = Tag;\n-    type TagExtra = SbTag;\n+    type TagExtra = Option<SbTag>;\n \n     type MemoryMap =\n         MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n@@ -708,8 +708,24 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Tag::Concrete(concrete) =>\n-                intptrcast::GlobalStateInner::expose_addr(ecx, concrete.alloc_id),\n+            Tag::Concrete(ConcreteTag { alloc_id, sb }) => {\n+                intptrcast::GlobalStateInner::expose_addr(ecx, alloc_id);\n+\n+                let (size, _) =\n+                    ecx.get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead).unwrap();\n+\n+                // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n+                if let Ok(alloc_extra) = ecx.get_alloc_extra(alloc_id) {\n+                    if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n+                        stacked_borrows.ptr_exposed(\n+                            alloc_id,\n+                            sb,\n+                            alloc_range(Size::from_bytes(0), size),\n+                            ecx.machine.stacked_borrows.as_ref().unwrap(),\n+                        )?;\n+                    }\n+                }\n+            }\n             Tag::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n@@ -728,8 +744,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n         rel.map(|(alloc_id, size)| {\n             let sb = match ptr.provenance {\n-                Tag::Concrete(ConcreteTag { sb, .. }) => sb,\n-                Tag::Wildcard => SbTag::Untagged,\n+                Tag::Concrete(ConcreteTag { sb, .. }) => Some(sb),\n+                Tag::Wildcard => None,\n             };\n             (alloc_id, size, sb)\n         })"}, {"sha": "ad7569008e20c472f1bb62d2065bf6ffc000e039", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 175, "deletions": 69, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -104,6 +104,10 @@ pub struct Stack {\n     /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n     /// * Except for `Untagged`, no tag occurs in the stack more than once.\n     borrows: Vec<Item>,\n+    /// If this is `Some(id)`, then the actual current stack is unknown. What we do know\n+    /// is that `borrows` are at the top of the stack, and below it are arbitrarily many items\n+    /// whose `tag` is either `Untagged` or strictly less than `id`.\n+    unknown_bottom: Option<PtrId>,\n }\n \n /// Extra per-allocation state.\n@@ -113,6 +117,8 @@ pub struct Stacks {\n     stacks: RefCell<RangeMap<Stack>>,\n     /// Stores past operations on this allocation\n     history: RefCell<AllocHistory>,\n+    /// The set of tags that have been exposed\n+    exposed_tags: RefCell<FxHashSet<SbTag>>,\n }\n \n /// Extra global state, available to the memory access hooks.\n@@ -283,32 +289,72 @@ impl Permission {\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n     /// it is on the stack.\n-    fn find_granting(&self, access: AccessKind, tag: SbTag) -> Option<usize> {\n-        self.borrows\n+    // TODO: Doc ok with Some(index) or None if unknown_bottom used\n+    // Err if does not match\n+    fn find_granting(\n+        &self,\n+        access: AccessKind,\n+        tag: Option<SbTag>,\n+        exposed_tags: &FxHashSet<SbTag>,\n+    ) -> Result<Option<usize>, ()> {\n+        let res = self\n+            .borrows\n             .iter()\n             .enumerate() // we also need to know *where* in the stack\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n-            .find_map(\n-                |(idx, item)| {\n-                    if tag == item.tag && item.perm.grants(access) { Some(idx) } else { None }\n+            .find_map(|(idx, item)| {\n+                match tag {\n+                    Some(tag) if tag == item.tag && item.perm.grants(access) => Some(idx),\n+                    None if exposed_tags.contains(&item.tag) => Some(idx),\n+                    _ => None,\n+                }\n+            });\n+\n+        if res.is_some() {\n+            return Ok(res);\n+        }\n+\n+        match self.unknown_bottom {\n+            Some(id) =>\n+                match tag {\n+                    Some(tag) =>\n+                        match tag {\n+                            SbTag::Tagged(tag_id) if tag_id < id => Ok(None),\n+                            SbTag::Untagged => Ok(None),\n+                            _ => Err(()),\n+                        },\n+                    None => Ok(None),\n                 },\n-            )\n+            None => Err(()),\n+        }\n     }\n \n     /// Find the first write-incompatible item above the given one --\n     /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n-    fn find_first_write_incompatible(&self, granting: usize) -> usize {\n-        let perm = self.borrows[granting].perm;\n+    fn find_first_write_incompatible(&self, granting: Option<usize>) -> usize {\n+        let perm = if let Some(idx) = granting {\n+            self.borrows[idx].perm\n+        } else {\n+            // I assume this has to be it?\n+            Permission::SharedReadWrite\n+        };\n+\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n             // On a write, everything above us is incompatible.\n-            Permission::Unique => granting + 1,\n+            Permission::Unique =>\n+                if let Some(idx) = granting {\n+                    idx + 1\n+                } else {\n+                    0\n+                },\n             Permission::SharedReadWrite => {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n-                let mut idx = granting + 1;\n+                let mut idx = if let Some(idx) = granting { idx + 1 } else { 0 };\n+\n                 while let Some(item) = self.borrows.get(idx) {\n                     if item.perm == Permission::SharedReadWrite {\n                         // Go on.\n@@ -380,58 +426,67 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         access: AccessKind,\n-        tag: SbTag,\n+        tag: Option<SbTag>,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n-        let granting_idx = self.find_granting(access, tag).ok_or_else(|| {\n+        let granting_idx = self.find_granting(access, tag, exposed_tags).map_err(|_| {\n             alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n         })?;\n \n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n-        if access == AccessKind::Write {\n-            // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n-            // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n-            let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n-            for item in self.borrows.drain(first_incompatible_idx..).rev() {\n-                trace!(\"access: popping item {:?}\", item);\n-                Stack::check_protector(\n-                    &item,\n-                    Some((tag, alloc_range, offset, access)),\n-                    global,\n-                    alloc_history,\n-                )?;\n-                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n-            }\n-        } else {\n-            // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n-            // The reason this is not following the stack discipline (by removing the first Unique and\n-            // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n-            // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n-            // `SharedReadWrite` for `raw`.\n-            // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n-            // reference and use that.\n-            // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n-            for idx in ((granting_idx + 1)..self.borrows.len()).rev() {\n-                let item = &mut self.borrows[idx];\n-                if item.perm == Permission::Unique {\n-                    trace!(\"access: disabling item {:?}\", item);\n+        if let Some(tag) = tag {\n+            if access == AccessKind::Write {\n+                // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n+                // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n+                let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n+                for item in self.borrows.drain(first_incompatible_idx..).rev() {\n+                    trace!(\"access: popping item {:?}\", item);\n                     Stack::check_protector(\n-                        item,\n+                        &item,\n                         Some((tag, alloc_range, offset, access)),\n                         global,\n                         alloc_history,\n                     )?;\n-                    item.perm = Permission::Disabled;\n                     alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n                 }\n+            } else {\n+                let start_idx = if let Some(idx) = granting_idx { idx + 1 } else { 0 };\n+                // On a read, *disable* all `Unique` above the granting item.  This ensures U2 for read accesses.\n+                // The reason this is not following the stack discipline (by removing the first Unique and\n+                // everything on top of it) is that in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement\n+                // would pop the `Unique` from the reborrow of the first statement, and subsequently also pop the\n+                // `SharedReadWrite` for `raw`.\n+                // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+                // reference and use that.\n+                // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n+                for idx in (start_idx..self.borrows.len()).rev() {\n+                    let item = &mut self.borrows[idx];\n+\n+                    if item.perm == Permission::Unique {\n+                        trace!(\"access: disabling item {:?}\", item);\n+                        Stack::check_protector(\n+                            item,\n+                            Some((tag, alloc_range, offset, access)),\n+                            global,\n+                            alloc_history,\n+                        )?;\n+                        item.perm = Permission::Disabled;\n+                        alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+                    }\n+                }\n             }\n+        } else {\n+            self.borrows.clear();\n+            // TODO\n+            // self.borrows.push(ItemOrUnknown::Unknown(global.next_ptr_id));\n         }\n \n         // Done.\n@@ -442,27 +497,27 @@ impl<'tcx> Stack {\n     /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n-        tag: SbTag,\n+        tag: Option<SbTag>,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n-        self.find_granting(AccessKind::Write, tag).ok_or_else(|| {\n+        self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n             err_sb_ub(format!(\n                 \"no item granting write access for deallocation to tag {:?} at {:?} found in borrow stack\",\n                 tag, alloc_id,\n                 ),\n                 None,\n-                alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None),\n+                tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, alloc_range, offset, None)),\n             )\n         })?;\n \n         // Step 2: Remove all items.  Also checks for protectors.\n         for item in self.borrows.drain(..).rev() {\n             Stack::check_protector(&item, None, global, alloc_history)?;\n         }\n-\n         Ok(())\n     }\n \n@@ -474,21 +529,17 @@ impl<'tcx> Stack {\n     /// `range` that we are currently checking.\n     fn grant(\n         &mut self,\n-        derived_from: SbTag,\n+        derived_from: Option<SbTag>,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n+        exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n             if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n-        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n-        // We use that to determine where to put the new item.\n-        let granting_idx = self.find_granting(access, derived_from).ok_or_else(|| {\n-            alloc_history.grant_error(derived_from, new, alloc_id, alloc_range, offset, self)\n-        })?;\n \n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n@@ -498,6 +549,21 @@ impl<'tcx> Stack {\n                 access == AccessKind::Write,\n                 \"this case only makes sense for stack-like accesses\"\n             );\n+\n+            // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n+            // We use that to determine where to put the new item.\n+            let granting_idx =\n+                self.find_granting(access, derived_from, exposed_tags).map_err(|_| {\n+                    alloc_history.grant_error(\n+                        derived_from,\n+                        new,\n+                        alloc_id,\n+                        alloc_range,\n+                        offset,\n+                        self,\n+                    )\n+                })?;\n+\n             // SharedReadWrite can coexist with \"existing loans\", meaning they don't act like a write\n             // access.  Instead of popping the stack, we insert the item at the place the stack would\n             // be popped to (i.e., we insert it above all the write-compatible items).\n@@ -514,6 +580,7 @@ impl<'tcx> Stack {\n                 global,\n                 current_span,\n                 alloc_history,\n+                exposed_tags,\n             )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n@@ -522,7 +589,6 @@ impl<'tcx> Stack {\n             // This ensures U1 and F1.\n             self.borrows.len()\n         };\n-\n         // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n         if self.borrows[new_idx - 1] == new || self.borrows.get(new_idx) == Some(&new) {\n             // Optimization applies, done.\n@@ -531,7 +597,6 @@ impl<'tcx> Stack {\n             trace!(\"reborrow: adding item {:?}\", new);\n             self.borrows.insert(new_idx, new);\n         }\n-\n         Ok(())\n     }\n }\n@@ -542,24 +607,31 @@ impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n         let item = Item { perm, tag, protector: None };\n-        let stack = Stack { borrows: vec![item] };\n+        let stack = Stack { borrows: vec![item], unknown_bottom: None };\n \n         Stacks {\n             stacks: RefCell::new(RangeMap::new(size, stack)),\n             history: RefCell::new(AllocHistory::new()),\n+            exposed_tags: RefCell::new(FxHashSet::default()),\n         }\n     }\n \n     /// Call `f` on every stack in the range.\n     fn for_each(\n         &self,\n         range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(\n+            Size,\n+            &mut Stack,\n+            &mut AllocHistory,\n+            &mut FxHashSet<SbTag>,\n+        ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         let history = &mut *self.history.borrow_mut();\n+        let exposed_tags = &mut *self.exposed_tags.borrow_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history)?;\n+            f(offset, stack, history, exposed_tags)?;\n         }\n         Ok(())\n     }\n@@ -568,12 +640,18 @@ impl<'tcx> Stacks {\n     fn for_each_mut(\n         &mut self,\n         range: AllocRange,\n-        mut f: impl FnMut(Size, &mut Stack, &mut AllocHistory) -> InterpResult<'tcx>,\n+        mut f: impl FnMut(\n+            Size,\n+            &mut Stack,\n+            &mut AllocHistory,\n+            &mut FxHashSet<SbTag>,\n+        ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let stacks = self.stacks.get_mut();\n         let history = &mut *self.history.borrow_mut();\n+        let exposed_tags = self.exposed_tags.get_mut();\n         for (offset, stack) in stacks.iter_mut(range.start, range.size) {\n-            f(offset, stack, history)?;\n+            f(offset, stack, history, exposed_tags)?;\n         }\n         Ok(())\n     }\n@@ -631,11 +709,31 @@ impl Stacks {\n     }\n \n     #[inline(always)]\n-    pub fn memory_read<'tcx>(\n+    pub fn ptr_exposed<'tcx>(\n         &self,\n         alloc_id: AllocId,\n         tag: SbTag,\n         range: AllocRange,\n+        _state: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\n+            \"allocation exposed with tag {:?}: {:?}, size {}\",\n+            tag,\n+            Pointer::new(alloc_id, range.start),\n+            range.size.bytes()\n+        );\n+\n+        self.exposed_tags.borrow_mut().insert(tag);\n+\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    pub fn memory_read<'tcx>(\n+        &self,\n+        alloc_id: AllocId,\n+        tag: Option<SbTag>,\n+        range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -646,14 +744,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each(range, |offset, stack, history| {\n+        self.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.access(\n                 AccessKind::Read,\n                 tag,\n                 (alloc_id, range, offset),\n                 &mut state,\n                 &mut current_span,\n                 history,\n+                exposed_tags,\n             )\n         })\n     }\n@@ -662,7 +761,7 @@ impl Stacks {\n     pub fn memory_written<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTag,\n+        tag: Option<SbTag>,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -674,14 +773,15 @@ impl Stacks {\n             range.size.bytes()\n         );\n         let mut state = state.borrow_mut();\n-        self.for_each_mut(range, |offset, stack, history| {\n+        self.for_each_mut(range, |offset, stack, history, exposed_tags| {\n             stack.access(\n                 AccessKind::Write,\n                 tag,\n                 (alloc_id, range, offset),\n                 &mut state,\n                 &mut current_span,\n                 history,\n+                exposed_tags,\n             )\n         })\n     }\n@@ -690,14 +790,14 @@ impl Stacks {\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTag,\n+        tag: Option<SbTag>,\n         range: AllocRange,\n         state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let state = state.borrow();\n-        self.for_each_mut(range, |offset, stack, history| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &state, history)\n+        self.for_each_mut(range, |offset, stack, history, exposed_tags| {\n+            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags)\n         })?;\n         Ok(())\n     }\n@@ -749,7 +849,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Dangling slices are a common case here; it's valid to get their length but with raw\n             // pointer tagging for example all calls to get_unchecked on them are invalid.\n             if let Ok((alloc_id, base_offset, orig_tag)) = this.ptr_try_get_alloc_id(place.ptr) {\n-                log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+                if let Some(orig_tag) = orig_tag {\n+                    log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+                }\n             }\n \n             trace!(\n@@ -762,7 +864,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(());\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n-        log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+        if let Some(orig_tag) = orig_tag {\n+            log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+        }\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) =\n@@ -830,14 +934,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     let item = Item { perm, tag: new_tag, protector };\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n-                    stacked_borrows.for_each(range, |offset, stack, history| {\n+                    stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n                         stack.grant(\n                             orig_tag,\n                             item,\n                             (alloc_id, range, offset),\n                             &mut *global,\n                             current_span,\n                             history,\n+                            exposed_tags,\n                         )\n                     })\n                 })?;\n@@ -854,14 +959,15 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n-        stacked_borrows.for_each_mut(range, |offset, stack, history| {\n+        stacked_borrows.for_each_mut(range, |offset, stack, history, exposed_tags| {\n             stack.grant(\n                 orig_tag,\n                 item,\n                 (alloc_id, range, offset),\n                 &mut global,\n                 current_span,\n                 history,\n+                exposed_tags,\n             )\n         })?;\n "}, {"sha": "224954c761591bb6738513628aa926a1ddc24cb5", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -197,7 +197,7 @@ impl AllocHistory {\n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     pub fn grant_error<'tcx>(\n         &self,\n-        derived_from: SbTag,\n+        derived_from: Option<SbTag>,\n         new: Item,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n@@ -214,15 +214,17 @@ impl AllocHistory {\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, derived_from)),\n             Some(operation_summary(\"a reborrow\", alloc_id, alloc_range)),\n-            self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None),\n+            derived_from.and_then(|derived_from| {\n+                self.get_logs_relevant_to(derived_from, alloc_range, error_offset, None)\n+            }),\n         )\n     }\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n     pub fn access_error<'tcx>(\n         &self,\n         access: AccessKind,\n-        tag: SbTag,\n+        tag: Option<SbTag>,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n@@ -238,7 +240,7 @@ impl AllocHistory {\n         err_sb_ub(\n             format!(\"{}{}\", action, error_cause(stack, tag)),\n             Some(operation_summary(\"an access\", alloc_id, alloc_range)),\n-            self.get_logs_relevant_to(tag, alloc_range, error_offset, None),\n+            tag.and_then(|tag| self.get_logs_relevant_to(tag, alloc_range, error_offset, None)),\n         )\n     }\n }\n@@ -251,10 +253,14 @@ fn operation_summary(\n     format!(\"this error occurs as part of {} at {:?}{}\", operation, alloc_id, HexRange(alloc_range))\n }\n \n-fn error_cause(stack: &Stack, tag: SbTag) -> &'static str {\n-    if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n-        \", but that tag only grants SharedReadOnly permission for this location\"\n+fn error_cause(stack: &Stack, tag: Option<SbTag>) -> &'static str {\n+    if let Some(tag) = tag {\n+        if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n+            \", but that tag only grants SharedReadOnly permission for this location\"\n+        } else {\n+            \", but that tag does not exist in the borrow stack for this location\"\n+        }\n     } else {\n-        \", but that tag does not exist in the borrow stack for this location\"\n+        \", but no exposed tags are valid in the borrow stack for this location\"\n     }\n }"}, {"sha": "28e6ba6230803423ef6b459f9d1e0c8d6aa22418", "filename": "tests/fail/provenance/permissive_provenance_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fpermissive_provenance_transmute.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n use std::mem;"}, {"sha": "ad29d38dc3f7af9fe67c3c6e6e1d6b1b08cf424f", "filename": "tests/fail/provenance/ptr_int_unexposed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fprovenance%2Fptr_int_unexposed.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n fn main() {"}, {"sha": "dc9cb393b781537d722fb0d645f0585b418c28c7", "filename": "tests/pass/ptr_int_from_exposed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Fpass%2Fptr_int_from_exposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Fpass%2Fptr_int_from_exposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_from_exposed.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -Zmiri-permissive-provenance -Zmiri-disable-stacked-borrows\n+// compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n \n use std::ptr;"}, {"sha": "dc581d8af618f890ac41d531b4dad5416598463f", "filename": "tests/pass/stacked-borrows/int-to-ptr.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57ce47b72814f8147d2cddb87628b17aa1084e74/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs?ref=57ce47b72814f8147d2cddb87628b17aa1084e74", "patch": "@@ -1,6 +1,6 @@\n-fn main() {\n-    ref_raw_int_raw();\n-}\n+// compile-flags: -Zmiri-permissive-provenance\n+#![feature(strict_provenance)]\n+use std::ptr;\n \n // Just to make sure that casting a ref to raw, to int and back to raw\n // and only then using it works. This rules out ideas like \"do escape-to-raw lazily\";\n@@ -11,3 +11,69 @@ fn ref_raw_int_raw() {\n     let xraw = xref as *mut i32 as usize as *mut i32;\n     assert_eq!(unsafe { *xraw }, 3);\n }\n+\n+/// Ensure that we do not just pick the topmost possible item on int2ptr casts.\n+fn example(variant: bool) { unsafe {\n+    fn not_so_innocent(x: &mut u32) -> usize {\n+        let x_raw4 = x as *mut u32;\n+        x_raw4.expose_addr()\n+    }\n+\n+    let mut c = 42u32;\n+\n+    let x_unique1 = &mut c;\n+    // [..., Unique(1)]\n+    \n+    let x_raw2 = x_unique1 as *mut u32;\n+    let x_raw2_addr = x_raw2.expose_addr();\n+    // [..., Unique(1), SharedRW(2)]\n+    \n+    let x_unique3 = &mut *x_raw2;\n+    // [.., Unique(1), SharedRW(2), Unique(3)]\n+    \n+    assert_eq!(not_so_innocent(x_unique3), x_raw2_addr);\n+    // [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n+    \n+    // Do an int2ptr cast. This can pick tag 2 or 4 (the two previously exposed tags).\n+    // 4 is the \"obvious\" choice (topmost tag, what we used to do with untagged pointers).\n+    // And indeed if `variant == true` it is the only possible choice.\n+    // But if `variant == false` then 2 is the only possible choice!\n+    let x_wildcard = ptr::from_exposed_addr_mut::<i32>(x_raw2_addr);\n+    \n+    if variant {\n+        // If we picked 2, this will invalidate 3.\n+        *x_wildcard = 10;\n+        // Now we use 3. Only possible if above we picked 4.\n+        *x_unique3 = 12;\n+    } else {\n+        // This invalidates tag 4.\n+        *x_unique3 = 10;\n+        // Now try to write with the \"guessed\" tag; it must be 2.\n+        *x_wildcard = 12;\n+    }\n+} }\n+\n+fn test() { unsafe {\n+    let root = &mut 42;\n+    let root_raw = root as *mut i32;\n+    let addr1 = root_raw as usize;\n+    let child = &mut *root_raw;\n+    let child_raw = child as *mut i32;\n+    let addr2 = child_raw as usize;\n+    assert_eq!(addr1, addr2);\n+    // First use child.\n+    *(addr2 as *mut i32) -= 2; // picks child_raw\n+    *child -= 2;\n+    // Then use root.\n+    *(addr1 as *mut i32) += 2; // picks root_raw\n+    *root += 2;\n+    // Value should be unchanged.\n+    assert_eq!(*root, 42);\n+} }\n+\n+fn main() {\n+    ref_raw_int_raw();\n+    example(false);\n+    example(true);\n+    test();\n+}"}]}