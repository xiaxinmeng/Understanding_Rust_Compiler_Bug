{"sha": "188e471339dfe652b8ff9f3bbe4cc262a040c584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OGU0NzEzMzlkZmU2NTJiOGZmOWYzYmJlNGNjMjYyYTA0MGM1ODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T16:36:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:22:35Z"}, "message": "Another round of test fixes and merge conflicts", "tree": {"sha": "d7267619b1909f2deaf319c560a64d667d141d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7267619b1909f2deaf319c560a64d667d141d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/188e471339dfe652b8ff9f3bbe4cc262a040c584", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/188e471339dfe652b8ff9f3bbe4cc262a040c584", "html_url": "https://github.com/rust-lang/rust/commit/188e471339dfe652b8ff9f3bbe4cc262a040c584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/188e471339dfe652b8ff9f3bbe4cc262a040c584/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d425218395b4a4dd7c6e4f3d680447efd2a3abc6", "html_url": "https://github.com/rust-lang/rust/commit/d425218395b4a4dd7c6e4f3d680447efd2a3abc6"}], "stats": {"total": 438, "additions": 264, "deletions": 174}, "files": [{"sha": "d268b106e5cb676d882a3d33743da5deaf9a47c5", "filename": "src/libextra/url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -145,7 +145,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n             let mut bytes = [0, 0];\n             match rdr.read(bytes) {\n                 Some(2) => {}\n-                _ => fail2!() // XXX: malformed url?\n+                _ => fail!() // XXX: malformed url?\n             }\n             let ch = uint::parse_bytes(bytes, 16u).unwrap() as u8 as char;\n \n@@ -279,7 +279,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n                         let mut bytes = [0, 0];\n                         match rdr.read(bytes) {\n                             Some(2) => {}\n-                            _ => fail2!() // XXX: malformed?\n+                            _ => fail!() // XXX: malformed?\n                         }\n                         uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n                     }"}, {"sha": "ce5e81d41092384aba0f417d1731eb1b8ea9a1cc", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -11,7 +11,10 @@\n // rustpkg unit tests\n \n use context::{BuildContext, Context, RustcFlags};\n-use std::{io, os, run, str, task};\n+use std::{os, run, str, task};\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use extra::arc::Arc;\n use extra::arc::RWArc;\n use extra::tempfile::TempDir;\n@@ -81,8 +84,9 @@ fn git_repo_pkg_with_tag(a_tag: ~str) -> PkgId {\n }\n \n fn writeFile(file_path: &Path, contents: &str) {\n-    let out = io::file_writer(file_path, [io::Create, io::Truncate]).unwrap();\n-    out.write_line(contents);\n+    let mut out = file_path.open_writer(io::CreateOrTruncate);\n+    out.write(contents.as_bytes());\n+    out.write(['\\n' as u8]);\n }\n \n fn mk_emptier_workspace(tag: &str) -> TempDir {\n@@ -550,10 +554,11 @@ fn frob_source_file(workspace: &Path, pkgid: &PkgId, filename: &str) {\n     debug!(\"Frobbed? {:?}\", maybe_p);\n     match maybe_p {\n         Some(ref p) => {\n-            let w = io::file_writer(p, &[io::Append]);\n-            match w {\n-                Err(s) => { let _ = cond.raise((p.clone(), format!(\"Bad path: {}\", s))); }\n-                Ok(w)  => w.write_line(\"/* hi */\")\n+            do io::io_error::cond.trap(|e| {\n+                cond.raise((p.clone(), format!(\"Bad path: {}\", e.desc)));\n+            }).inside {\n+                let mut w = p.open_writer(io::Append);\n+                w.write(bytes!(\"/* hi */\\n\"));\n             }\n         }\n         None => fail!(\"frob_source_file failed to find a source file in {}\","}, {"sha": "016635339a9d900a7ebfdadbe27ed3742be5fd82", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -11,7 +11,7 @@\n extern mod rustpkg;\n extern mod rustc;\n \n-use std::{io, os, task};\n+use std::{os, task};\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n use rustpkg::workcache_support::digest_file_with_date;\n@@ -36,7 +36,7 @@ pub fn main() {\n     }\n \n     if args[2] != ~\"install\" {\n-        io::println(format!(\"Warning: I don't know how to {}\", args[2]));\n+        println(format!(\"Warning: I don't know how to {}\", args[2]));\n         return;\n     }\n "}, {"sha": "f82c585b1d156745e67484bd967a329fb084d1cc", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/pkg.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Fpkg.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -11,7 +11,10 @@\n extern mod rustpkg;\n extern mod rustc;\n \n-use std::{io, os};\n+use std::os;\n+use std::rt::io;\n+use std::rt::io::Writer;\n+use std::rt::io::file::FileInfo;\n use rustpkg::api;\n use rustpkg::version::NoVersion;\n \n@@ -42,9 +45,9 @@ pub fn main() {\n     let out_path = os::self_exe_path().expect(\"Couldn't get self_exe path\");\n \n     debug!(\"Writing file\");\n-    let file = io::file_writer(&out_path.join(\"generated.rs\"), [io::Create]).unwrap();\n-    file.write_str(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n-                   for _ in xs.iter() { assert!(true); } }\");\n+    let mut file = out_path.join(\"generated.rs\").open_writer(io::Create);\n+    file.write(\"pub fn wheeeee() { let xs = [1, 2, 3]; \\\n+                for _ in xs.iter() { assert!(true); } }\".as_bytes());\n \n     let context = api::default_context(sysroot, api::default_workspace());\n     api::install_pkg(&context, os::getcwd(), ~\"fancy-lib\", NoVersion, ~[]);"}, {"sha": "a13fc19d000a815b2bc5382a6bd57922fe230184", "filename": "src/libstd/rt/io/signal.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fsignal.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -147,6 +147,7 @@ impl Listener {\n mod test {\n     use libc;\n     use rt::io::timer;\n+    use rt::io;\n     use super::*;\n \n     // kill is only available on Unixes\n@@ -158,19 +159,19 @@ mod test {\n         }\n     }\n \n-    #[test]\n+    #[test] #[cfg(unix)]\n     fn test_io_signal_smoketest() {\n         let mut signal = Listener::new();\n         signal.register(Interrupt);\n         sigint();\n         timer::sleep(10);\n         match signal.port.recv() {\n             Interrupt => (),\n-            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n     }\n \n-    #[test]\n+    #[test] #[cfg(unix)]\n     fn test_io_signal_two_signal_one_signum() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -180,15 +181,15 @@ mod test {\n         timer::sleep(10);\n         match s1.port.recv() {\n             Interrupt => (),\n-            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n         match s1.port.recv() {\n             Interrupt => (),\n-            s => fail2!(\"Expected Interrupt, got {:?}\", s),\n+            s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n     }\n \n-    #[test]\n+    #[test] #[cfg(unix)]\n     fn test_io_signal_unregister() {\n         let mut s1 = Listener::new();\n         let mut s2 = Listener::new();\n@@ -198,16 +199,22 @@ mod test {\n         sigint();\n         timer::sleep(10);\n         if s2.port.peek() {\n-            fail2!(\"Unexpected {:?}\", s2.port.recv());\n+            fail!(\"Unexpected {:?}\", s2.port.recv());\n         }\n     }\n \n     #[cfg(windows)]\n     #[test]\n     fn test_io_signal_invalid_signum() {\n         let mut s = Listener::new();\n-        if s.register(User1) {\n-            fail2!(\"Unexpected successful registry of signum {:?}\", User1);\n+        let mut called = false;\n+        do io::io_error::cond.trap(|_| {\n+            called = true;\n+        }).inside {\n+            if s.register(User1) {\n+                fail!(\"Unexpected successful registry of signum {:?}\", User1);\n+            }\n         }\n+        assert!(called);\n     }\n }"}, {"sha": "b922e6400cc50801b91fa097cdf0505b6dee3da2", "filename": "src/libstd/rt/io/stdio.rs", "status": "modified", "additions": 99, "deletions": 34, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fstdio.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -30,20 +30,57 @@ use fmt;\n use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::rtio::{IoFactory, RtioTTY, with_local_io, RtioPipe};\n-use super::{Reader, Writer, io_error};\n+use rt::rtio::{IoFactory, RtioTTY, RtioFileStream, with_local_io,\n+               CloseAsynchronously};\n+use super::{Reader, Writer, io_error, IoError, OtherIoError};\n+\n+// And so begins the tale of acquiring a uv handle to a stdio stream on all\n+// platforms in all situations. Our story begins by splitting the world into two\n+// categories, windows and unix. Then one day the creators of unix said let\n+// there be redirection! And henceforth there was redirection away from the\n+// console for standard I/O streams.\n+//\n+// After this day, the world split into four factions:\n+//\n+// 1. Unix with stdout on a terminal.\n+// 2. Unix with stdout redirected.\n+// 3. Windows with stdout on a terminal.\n+// 4. Windows with stdout redirected.\n+//\n+// Many years passed, and then one day the nation of libuv decided to unify this\n+// world. After months of toiling, uv created three ideas: TTY, Pipe, File.\n+// These three ideas propagated throughout the lands and the four great factions\n+// decided to settle among them.\n+//\n+// The groups of 1, 2, and 3 all worked very hard towards the idea of TTY. Upon\n+// doing so, they even enhanced themselves further then their Pipe/File\n+// brethren, becoming the dominant powers.\n+//\n+// The group of 4, however, decided to work independently. They abandoned the\n+// common TTY belief throughout, and even abandoned the fledgling Pipe belief.\n+// The members of the 4th faction decided to only align themselves with File.\n+//\n+// tl;dr; TTY works on everything but when windows stdout is redirected, in that\n+//        case pipe also doesn't work, but magically file does!\n+enum StdSource {\n+    TTY(~RtioTTY),\n+    File(~RtioFileStream),\n+}\n \n #[fixed_stack_segment] #[inline(never)]\n-fn tty<T>(fd: libc::c_int, f: &fn(~RtioTTY) -> T) -> T {\n+fn src<T>(fd: libc::c_int, readable: bool, f: &fn(StdSource) -> T) -> T {\n     do with_local_io |io| {\n-        // Always pass in readable as true, otherwise libuv turns our writes\n-        // into blocking writes. We also need to dup the file descriptor because\n-        // the tty will be closed when it's dropped.\n-        match io.tty_open(unsafe { libc::dup(fd) }, true) {\n-            Ok(tty) => Some(f(tty)),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n+        let fd = unsafe { libc::dup(fd) };\n+        match io.tty_open(fd, readable) {\n+            Ok(tty) => Some(f(TTY(tty))),\n+            Err(_) => {\n+                // It's not really that desirable if these handles are closed\n+                // synchronously, and because they're squirreled away in a task\n+                // structure the destructors will be run when the task is\n+                // attempted to get destroyed. This means that if we run a\n+                // synchronous destructor we'll attempt to do some scheduling\n+                // operations which will just result in sadness.\n+                Some(f(File(io.fs_from_raw_fd(fd, CloseAsynchronously))))\n             }\n         }\n     }.unwrap()\n@@ -54,15 +91,7 @@ fn tty<T>(fd: libc::c_int, f: &fn(~RtioTTY) -> T) -> T {\n /// See `stdout()` for notes about this function.\n #[fixed_stack_segment] #[inline(never)]\n pub fn stdin() -> StdReader {\n-    do with_local_io |io| {\n-        match io.pipe_open(unsafe { libc::dup(libc::STDIN_FILENO) }) {\n-            Ok(stream) => Some(StdReader { inner: stream }),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n-                None\n-            }\n-        }\n-    }.unwrap()\n+    do src(libc::STDIN_FILENO, true) |src| { StdReader { inner: src } }\n }\n \n /// Creates a new non-blocking handle to the stdout of the current process.\n@@ -72,14 +101,14 @@ pub fn stdin() -> StdReader {\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    do tty(libc::STDOUT_FILENO) |tty| { StdWriter { inner: tty } }\n+    do src(libc::STDOUT_FILENO, false) |src| { StdWriter { inner: src } }\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    do tty(libc::STDERR_FILENO) |tty| { StdWriter { inner: tty } }\n+    do src(libc::STDERR_FILENO, false) |src| { StdWriter { inner: src } }\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted\n@@ -117,12 +146,16 @@ pub fn println_args(fmt: &fmt::Arguments) {\n \n /// Representation of a reader of a standard input stream\n pub struct StdReader {\n-    priv inner: ~RtioPipe\n+    priv inner: StdSource\n }\n \n impl Reader for StdReader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.inner.read(buf) {\n+        let ret = match self.inner {\n+            TTY(ref mut tty) => tty.read(buf),\n+            File(ref mut file) => file.read(buf).map_move(|i| i as uint),\n+        };\n+        match ret {\n             Ok(amt) => Some(amt as uint),\n             Err(e) => {\n                 io_error::cond.raise(e);\n@@ -136,7 +169,7 @@ impl Reader for StdReader {\n \n /// Representation of a writer to a standard output stream\n pub struct StdWriter {\n-    priv inner: ~RtioTTY\n+    priv inner: StdSource\n }\n \n impl StdWriter {\n@@ -151,10 +184,22 @@ impl StdWriter {\n     /// This function will raise on the `io_error` condition if an error\n     /// happens.\n     pub fn winsize(&mut self) -> Option<(int, int)> {\n-        match self.inner.get_winsize() {\n-            Ok(p) => Some(p),\n-            Err(e) => {\n-                io_error::cond.raise(e);\n+        match self.inner {\n+            TTY(ref mut tty) => {\n+                match tty.get_winsize() {\n+                    Ok(p) => Some(p),\n+                    Err(e) => {\n+                        io_error::cond.raise(e);\n+                        None\n+                    }\n+                }\n+            }\n+            File(*) => {\n+                io_error::cond.raise(IoError {\n+                    kind: OtherIoError,\n+                    desc: \"stream is not a tty\",\n+                    detail: None,\n+                });\n                 None\n             }\n         }\n@@ -168,21 +213,41 @@ impl StdWriter {\n     /// This function will raise on the `io_error` condition if an error\n     /// happens.\n     pub fn set_raw(&mut self, raw: bool) {\n-        match self.inner.set_raw(raw) {\n-            Ok(()) => {},\n-            Err(e) => io_error::cond.raise(e),\n+        match self.inner {\n+            TTY(ref mut tty) => {\n+                match tty.set_raw(raw) {\n+                    Ok(()) => {},\n+                    Err(e) => io_error::cond.raise(e),\n+                }\n+            }\n+            File(*) => {\n+                io_error::cond.raise(IoError {\n+                    kind: OtherIoError,\n+                    desc: \"stream is not a tty\",\n+                    detail: None,\n+                });\n+            }\n         }\n     }\n \n     /// Returns whether this tream is attached to a TTY instance or not.\n     ///\n     /// This is similar to libc's isatty() function\n-    pub fn isatty(&self) -> bool { self.inner.isatty() }\n+    pub fn isatty(&self) -> bool {\n+        match self.inner {\n+            TTY(ref tty) => tty.isatty(),\n+            File(*) => false,\n+        }\n+    }\n }\n \n impl Writer for StdWriter {\n     fn write(&mut self, buf: &[u8]) {\n-        match self.inner.write(buf) {\n+        let ret = match self.inner {\n+            TTY(ref mut tty) => tty.write(buf),\n+            File(ref mut file) => file.write(buf),\n+        };\n+        match ret {\n             Ok(()) => {}\n             Err(e) => io_error::cond.raise(e)\n         }"}, {"sha": "66a0676a2f410655649da3278e6e49f6749e3b7e", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -58,6 +58,20 @@ pub struct FileOpenConfig {\n     priv mode: int\n }\n \n+/// Description of what to do when a file handle is closed\n+pub enum CloseBehavior {\n+    /// Do not close this handle when the object is destroyed\n+    DontClose,\n+    /// Synchronously close the handle, meaning that the task will block when\n+    /// the handle is destroyed until it has been fully closed.\n+    CloseSynchronously,\n+    /// Asynchronously closes a handle, meaning that the task will *not* block\n+    /// when the handle is destroyed, but the handle will still get deallocated\n+    /// and cleaned up (but this will happen asynchronously on the local event\n+    /// loop).\n+    CloseAsynchronously,\n+}\n+\n pub fn with_local_io<T>(f: &fn(&mut IoFactory) -> Option<T>) -> Option<T> {\n     use rt::sched::Scheduler;\n     use rt::local::Local;\n@@ -84,7 +98,7 @@ pub trait IoFactory {\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream;\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream;\n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError>;"}, {"sha": "1ea68bb52d7e09de5d97f183ea58b7daacbca499", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -479,7 +479,6 @@ pub extern \"C\" fn rust_stack_exhausted() {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n-    use rt::logging::Logger;\n     use unstable::intrinsics;\n \n     unsafe {\n@@ -529,8 +528,12 @@ pub extern \"C\" fn rust_stack_exhausted() {\n             do Local::borrow |task: &mut Task| {\n                 let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n-                format_args!(|args| { task.logger.log(args) },\n-                             \"task '{}' has overflowed its stack\", n);\n+                // See the message below for why this is not emitted to the\n+                // task's logger. This has the additional conundrum of the\n+                // logger may not be initialized just yet, meaning that an FFI\n+                // call would happen to initialized it (calling out to libuv),\n+                // and the FFI call needs 2MB of stack when we just ran out.\n+                rterrln!(\"task '{}' has overflowed its stack\", n);\n             }\n         } else {\n             rterrln!(\"stack overflow in non-task context\");"}, {"sha": "d2ca15959b025990942f81fef6da567aa0a117e3", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -43,10 +43,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                           self.native_handle(), p, flags, mode, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn open_sync(self, loop_: &Loop, path: &CString,\n@@ -67,10 +68,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_unlink(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn unlink_sync(self, loop_: &Loop, path: &CString)\n@@ -91,10 +93,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_stat(loop_.native_handle(),\n                           self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn write(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64, cb: FsCallback) {\n@@ -104,11 +107,12 @@ impl FsRequest {\n         };\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_write(loop_.native_handle(), self.native_handle(),\n                            fd, base_ptr,\n                            len, offset, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn write_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n@@ -133,11 +137,12 @@ impl FsRequest {\n         };\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_read(loop_.native_handle(), self.native_handle(),\n                            fd, buf_ptr,\n                            len, offset, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn read_sync(self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n           -> Result<c_int, UvError> {\n@@ -160,10 +165,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        unsafe {\n+        let ret = unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n         };\n+        assert_eq!(ret, 0);\n     }\n     pub fn close_sync(self, loop_: &Loop, fd: c_int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = {\n@@ -182,21 +188,23 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_mkdir(loop_.native_handle(),\n-                          self.native_handle(), p, mode, complete_cb_ptr)\n+                           self.native_handle(), p, mode, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_rmdir(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n+                           self.native_handle(), p, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     pub fn readdir(self, loop_: &Loop, path: &CString,\n@@ -205,10 +213,11 @@ impl FsRequest {\n             let mut me = self;\n             me.req_boilerplate(Some(cb))\n         };\n-        path.with_ref(|p| unsafe {\n+        let ret = path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n-                          self.native_handle(), p, flags, complete_cb_ptr)\n+                             self.native_handle(), p, flags, complete_cb_ptr)\n         });\n+        assert_eq!(ret, 0);\n     }\n \n     // accessors/utility funcs"}, {"sha": "40f0750b2d0742d1ab0b78787387ee1e1d2cccc2", "filename": "src/libstd/rt/uv/idle.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fidle.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -20,9 +20,9 @@ impl Watcher for IdleWatcher { }\n impl IdleWatcher {\n     pub fn new(loop_: &mut Loop) -> IdleWatcher {\n         unsafe {\n-            let handle = uvll::idle_new();\n+            let handle = uvll::malloc_handle(uvll::UV_IDLE);\n             assert!(handle.is_not_null());\n-            assert!(0 == uvll::idle_init(loop_.native_handle(), handle));\n+            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n             let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher\n@@ -36,29 +36,14 @@ impl IdleWatcher {\n         }\n \n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let data = idle_watcher.get_watcher_data();\n-            let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(idle_watcher, status);\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n     pub fn restart(&mut self) {\n         unsafe {\n-            assert!(0 == uvll::idle_start(self.native_handle(), idle_cb))\n-        };\n-\n-        extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n-            let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n-            let data = idle_watcher.get_watcher_data();\n-            let cb: &IdleCallback = data.idle_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(idle_watcher, status);\n+            assert!(self.get_watcher_data().idle_cb.is_some());\n+            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n@@ -68,7 +53,7 @@ impl IdleWatcher {\n         // free\n \n         unsafe {\n-            assert!(0 == uvll::idle_stop(self.native_handle()));\n+            assert_eq!(uvll::idle_stop(self.native_handle()), 0);\n         }\n     }\n }\n@@ -82,6 +67,14 @@ impl NativeHandle<*uvll::uv_idle_t> for IdleWatcher {\n     }\n }\n \n+extern fn idle_cb(handle: *uvll::uv_idle_t, status: c_int) {\n+    let mut idle_watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n+    let data = idle_watcher.get_watcher_data();\n+    let cb: &IdleCallback = data.idle_cb.get_ref();\n+    let status = status_to_maybe_uv_error(status);\n+    (*cb)(idle_watcher, status);\n+}\n+\n #[cfg(test)]\n mod test {\n "}, {"sha": "3252c89673d6b550f2cfc4d9913b720934a85b29", "filename": "src/libstd/rt/uv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fsignal.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -51,7 +51,7 @@ impl SignalWatcher {\n             let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n             let data = watcher.get_watcher_data();\n             let cb = data.signal_cb.get_ref();\n-            (*cb)(watcher, unsafe { cast::transmute(signum as i64) });\n+            (*cb)(watcher, unsafe { cast::transmute(signum as int) });\n         }\n     }\n "}, {"sha": "29370c484eb5a06fe7fc93823ade3067c4e375e0", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -547,10 +547,10 @@ impl IoFactory for UvIoFactory {\n         Ok(~UvTimer::new(watcher, home) as ~RtioTimer)\n     }\n \n-    fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileStream {\n+    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let home = get_handle_to_current_scheduler!();\n-        ~UvFileStream::new(loop_, fd, close_on_drop, home) as ~RtioFileStream\n+        ~UvFileStream::new(loop_, fd, close, home) as ~RtioFileStream\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n@@ -590,7 +590,7 @@ impl IoFactory for UvIoFactory {\n                         let home = get_handle_to_current_scheduler!();\n                         let fd = req.get_result() as c_int;\n                         let fs = ~UvFileStream::new(\n-                            loop_, fd, true, home) as ~RtioFileStream;\n+                            loop_, fd, CloseSynchronously, home) as ~RtioFileStream;\n                         let res = Ok(fs);\n                         unsafe { (*result_cell_ptr).put_back(res); }\n                         let scheduler: ~Scheduler = Local::take();\n@@ -1482,22 +1482,22 @@ impl RtioTimer for UvTimer {\n pub struct UvFileStream {\n     priv loop_: Loop,\n     priv fd: c_int,\n-    priv close_on_drop: bool,\n-    priv home: SchedHandle\n+    priv close: CloseBehavior,\n+    priv home: SchedHandle,\n }\n \n impl HomingIO for UvFileStream {\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n impl UvFileStream {\n-    fn new(loop_: Loop, fd: c_int, close_on_drop: bool,\n+    fn new(loop_: Loop, fd: c_int, close: CloseBehavior,\n            home: SchedHandle) -> UvFileStream {\n         UvFileStream {\n             loop_: loop_,\n             fd: fd,\n-            close_on_drop: close_on_drop,\n-            home: home\n+            close: close,\n+            home: home,\n         }\n     }\n     fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n@@ -1517,9 +1517,9 @@ impl UvFileStream {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n+                }\n+            }\n+        }\n         result_cell.take()\n     }\n     fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n@@ -1539,9 +1539,9 @@ impl UvFileStream {\n                     unsafe { (*result_cell_ptr).put_back(res); }\n                     let scheduler: ~Scheduler = Local::take();\n                     scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n+                }\n+            }\n+        }\n         result_cell.take()\n     }\n     fn seek_common(&mut self, pos: i64, whence: c_int) ->\n@@ -1564,16 +1564,23 @@ impl UvFileStream {\n \n impl Drop for UvFileStream {\n     fn drop(&mut self) {\n-        if self.close_on_drop {\n-            do self.home_for_io_with_sched |self_, scheduler| {\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    let close_req = file::FsRequest::new();\n-                    do close_req.close(&self_.loop_, self_.fd) |_,_| {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    };\n-                };\n+        match self.close {\n+            DontClose => {}\n+            CloseAsynchronously => {\n+                let close_req = file::FsRequest::new();\n+                do close_req.close(&self.loop_, self.fd) |_,_| {}\n+            }\n+            CloseSynchronously => {\n+                do self.home_for_io_with_sched |self_, scheduler| {\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        let task_cell = Cell::new(task);\n+                        let close_req = file::FsRequest::new();\n+                        do close_req.close(&self_.loop_, self_.fd) |_,_| {\n+                            let scheduler: ~Scheduler = Local::take();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1750,7 +1757,6 @@ impl Drop for UvTTY {\n         // scheduler isn't available, so we can't do the normal \"take the\n         // scheduler and resume once close is done\". Instead close operations on\n         // a TTY are asynchronous.\n-\n         self.tty.close_async();\n     }\n }\n@@ -2465,7 +2471,7 @@ fn uvio_naive_print(input: &str) {\n         use libc::{STDOUT_FILENO};\n         let io = local_io();\n         {\n-            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, false);\n+            let mut fd = io.fs_from_raw_fd(STDOUT_FILENO, DontClose);\n             let write_buf = input.as_bytes();\n             fd.write(write_buf);\n         }"}, {"sha": "75e6a0c6ca552f919039677dfc68c6c2524c72af", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -235,37 +235,37 @@ pub type socklen_t = c_int;\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: socklen_t,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n     ai_addr: *sockaddr,\n-    priv ai_canonname: *char,\n+    ai_canonname: *char,\n     ai_next: *addrinfo\n }\n \n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: socklen_t,\n-    priv ai_canonname: *char,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: socklen_t,\n+    ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n \n #[cfg(windows)]\n pub struct addrinfo {\n-    priv ai_flags: c_int,\n-    priv ai_family: c_int,\n-    priv ai_socktype: c_int,\n-    priv ai_protocol: c_int,\n-    priv ai_addrlen: size_t,\n-    priv ai_canonname: *char,\n+    ai_flags: c_int,\n+    ai_family: c_int,\n+    ai_socktype: c_int,\n+    ai_protocol: c_int,\n+    ai_addrlen: size_t,\n+    ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n }\n@@ -423,18 +423,6 @@ pub unsafe fn walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void) {\n     rust_uv_walk(loop_handle, cb, arg);\n }\n \n-pub unsafe fn idle_new() -> *uv_idle_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_new()\n-}\n-\n-pub unsafe fn idle_delete(handle: *uv_idle_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_delete(handle)\n-}\n-\n pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -1028,8 +1016,6 @@ extern {\n     fn rust_uv_close(handle: *c_void, cb: uv_close_cb);\n     fn rust_uv_walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void);\n \n-    fn rust_uv_idle_new() -> *uv_idle_t;\n-    fn rust_uv_idle_delete(handle: *uv_idle_t);\n     fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n     fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n     fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;"}, {"sha": "615ba60e066c06a6c70b4bac95a4bc5e2358069c", "filename": "src/libstd/run.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -219,16 +219,27 @@ impl Process {\n         let (p, ch) = stream();\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n-            match error.take() {\n-                Some(ref mut e) => ch.send((2, e.read_to_end())),\n-                None => ch.send((2, ~[]))\n+\n+        // FIXME(#910, #8674): right now I/O is incredibly brittle when it comes\n+        //      to linked failure, so these tasks must be spawn so they're not\n+        //      affected by linked failure. If these are removed, then the\n+        //      runtime may never exit because linked failure will cause some\n+        //      SchedHandle structures to not get destroyed, meaning that\n+        //      there's always an async watcher available.\n+        do task::spawn_unlinked {\n+            do io::ignore_io_error {\n+                match error.take() {\n+                    Some(ref mut e) => ch.send((2, e.read_to_end())),\n+                    None => ch.send((2, ~[]))\n+                }\n             }\n         }\n-        do task::spawn_sched(task::SingleThreaded) {\n-            match output.take() {\n-                Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n-                None => ch_clone.send((1, ~[]))\n+        do task::spawn_unlinked {\n+            do io::ignore_io_error {\n+                match output.take() {\n+                    Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n+                    None => ch_clone.send((1, ~[]))\n+                }\n             }\n         }\n "}, {"sha": "0cbbb58d02c66d5ba4e1fbd712c59c06d7d79553", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -466,16 +466,6 @@ rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n     return (sockaddr_in6*)input->ai_addr;\n }\n \n-extern \"C\" uv_idle_t*\n-rust_uv_idle_new() {\n-  return new uv_idle_t;\n-}\n-\n-extern \"C\" void\n-rust_uv_idle_delete(uv_idle_t* handle) {\n-  delete handle;\n-}\n-\n extern \"C\" int\n rust_uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n   return uv_idle_init(loop, idle);"}, {"sha": "269da8e7882ac9fd61647b595f7828a36b8562fb", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/188e471339dfe652b8ff9f3bbe4cc262a040c584/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=188e471339dfe652b8ff9f3bbe4cc262a040c584", "patch": "@@ -98,8 +98,6 @@ rust_uv_get_base_from_buf\n rust_uv_get_len_from_buf\n rust_uv_getaddrinfo\n rust_uv_freeaddrinfo\n-rust_uv_idle_new\n-rust_uv_idle_delete\n rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop"}]}