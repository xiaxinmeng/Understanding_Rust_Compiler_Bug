{"sha": "81cda5ad4507a493d6a4d175c02bca7bf2e76c19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxY2RhNWFkNDUwN2E0OTNkNmE0ZDE3NWMwMmJjYTdiZjJlNzZjMTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-06T00:47:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-06T00:48:10Z"}, "message": "rustc: Fix a bunch of argument-passing bugs in decl_native_fn_and_pair()", "tree": {"sha": "a91f9a5948fe7d257d85210510bcb74d3cd314dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a91f9a5948fe7d257d85210510bcb74d3cd314dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81cda5ad4507a493d6a4d175c02bca7bf2e76c19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81cda5ad4507a493d6a4d175c02bca7bf2e76c19", "html_url": "https://github.com/rust-lang/rust/commit/81cda5ad4507a493d6a4d175c02bca7bf2e76c19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81cda5ad4507a493d6a4d175c02bca7bf2e76c19/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e3b096d98905062addbdef68a0838e6ef83bb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3b096d98905062addbdef68a0838e6ef83bb21", "html_url": "https://github.com/rust-lang/rust/commit/9e3b096d98905062addbdef68a0838e6ef83bb21"}], "stats": {"total": 136, "additions": 82, "deletions": 54}, "files": [{"sha": "b5cf53600c59575790441e0892fc4ef322a953d1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 82, "deletions": 54, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/81cda5ad4507a493d6a4d175c02bca7bf2e76c19/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81cda5ad4507a493d6a4d175c02bca7bf2e76c19/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=81cda5ad4507a493d6a4d175c02bca7bf2e76c19", "patch": "@@ -6723,125 +6723,149 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     // that allows types of different sizes to be returned.\n     auto rty_is_nil = ty.type_is_nil(ccx.tcx, ty.ty_fn_ret(ccx.tcx, fn_type));\n \n-    let vec[ValueRef] call_args = vec();\n-    auto arg_n = 3u;\n     auto pass_task;\n-\n-    auto lltaskptr = vp2i(bcx, fcx.lltaskptr);\n+    auto cast_to_i32;\n     alt (abi) {\n         case (ast.native_abi_rust) {\n             pass_task = true;\n-            call_args += vec(lltaskptr);\n-            for each (uint i in _uint.range(0u, num_ty_param)) {\n-                auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n-                fcx.lltydescs += vec(llarg);\n-                assert (llarg as int != 0);\n-                call_args += vec(vp2i(bcx, llarg));\n-                arg_n += 1u;\n-            }\n+            cast_to_i32 = true;\n         }\n         case (ast.native_abi_rust_intrinsic) {\n             pass_task = true;\n-            call_args += vec(lltaskptr);\n+            cast_to_i32 = false;\n         }\n         case (ast.native_abi_cdecl) {\n             pass_task = false;\n+            cast_to_i32 = true;\n         }\n         case (ast.native_abi_llvm) {\n             pass_task = false;\n-            // We handle this case below.\n+            cast_to_i32 = false;\n+        }\n+    }\n+\n+    auto lltaskptr;\n+    if (cast_to_i32) {\n+        lltaskptr = vp2i(bcx, fcx.lltaskptr);\n+    } else {\n+        lltaskptr = fcx.lltaskptr;\n+    }\n+\n+    let vec[ValueRef] call_args = vec();\n+    if (pass_task) { call_args += vec(lltaskptr); }\n+\n+    auto arg_n = 3u;\n+    for each (uint i in _uint.range(0u, num_ty_param)) {\n+        auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n+        fcx.lltydescs += vec(llarg);\n+        assert (llarg as int != 0);\n+\n+        if (cast_to_i32) {\n+            call_args += vec(vp2i(bcx, llarg));\n+        } else {\n+            call_args += vec(llarg);\n         }\n+\n+        arg_n += 1u;\n     }\n \n-    fn push_arg(@block_ctxt cx,\n-                &mutable vec[ValueRef] args,\n-                ValueRef v,\n-                ty.t t,\n-                ast.mode mode) {\n+    fn convert_arg_to_i32(@block_ctxt cx,\n+                          ValueRef v,\n+                          ty.t t,\n+                          ast.mode mode) -> ValueRef {\n         if (mode == ast.val) {\n             if (ty.type_is_integral(cx.fcx.lcx.ccx.tcx, t)) {\n                 auto lldsttype = T_int();\n                 auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n                 if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n                     llvm.LLVMGetIntTypeWidth(llsrctype)) {\n-                    args += vec(cx.build.ZExtOrBitCast(v, T_int()));\n-                } else {\n-                    args += vec(cx.build.TruncOrBitCast(v, T_int()));\n+                    ret cx.build.ZExtOrBitCast(v, T_int());\n                 }\n-                ret;\n+                ret cx.build.TruncOrBitCast(v, T_int());\n             }\n             if (ty.type_is_fp(cx.fcx.lcx.ccx.tcx, t)) {\n-                args += vec(cx.build.FPToSI(v, T_int()));\n-                ret;\n+                ret cx.build.FPToSI(v, T_int());\n             }\n         }\n \n-        args += vec(vp2i(cx, v));\n+        ret vp2i(cx, v);\n     }\n \n     fn trans_simple_native_abi(@block_ctxt bcx,\n                                str name,\n-                               vec[ty.arg] args,\n                                &mutable vec[ValueRef] call_args,\n-                               ty.t fn_type) -> tup(ValueRef, ValueRef) {\n+                               ty.t fn_type,\n+                               uint first_arg_n) -> tup(ValueRef, ValueRef) {\n         let vec[TypeRef] call_arg_tys = vec();\n-        auto i = 0u;\n-        while (i < _vec.len[ty.arg](args)) {\n-            auto call_arg = llvm.LLVMGetParam(bcx.fcx.llfn, i + 3u);\n-            call_args += vec(call_arg);\n-            call_arg_tys += vec(val_ty(call_arg));\n-            i += 1u;\n+        for (ValueRef arg in call_args) {\n+            call_arg_tys += vec(val_ty(arg));\n         }\n+\n         auto llnativefnty =\n             T_fn(call_arg_tys,\n                  type_of(bcx.fcx.lcx.ccx,\n                          ty.ty_fn_ret(bcx.fcx.lcx.ccx.tcx, fn_type)));\n+\n         auto llnativefn = get_extern_fn(bcx.fcx.lcx.ccx.externs,\n                                         bcx.fcx.lcx.ccx.llmod,\n                                         name,\n                                         lib.llvm.LLVMCCallConv,\n                                         llnativefnty);\n \n+        log_err \"calling: \" + val_str(bcx.fcx.lcx.ccx.tn, llnativefn);\n+\n+        for (ValueRef arg in call_args) {\n+            log_err \"arg: \" + val_str(bcx.fcx.lcx.ccx.tn, arg);\n+        }\n+\n         auto r = bcx.build.Call(llnativefn, call_args);\n         auto rptr = bcx.fcx.llretptr;\n         ret tup(r, rptr);\n     }\n \n+    auto args = ty.ty_fn_args(ccx.tcx, fn_type);\n+\n+    // Build up the list of arguments.\n+    let vec[tup(ValueRef, ty.t)] drop_args = vec();\n+    auto i = arg_n;\n+    for (ty.arg arg in args) {\n+        auto llarg = llvm.LLVMGetParam(fcx.llfn, i);\n+        assert (llarg as int != 0);\n+\n+        if (cast_to_i32) {\n+            auto llarg_i32 = convert_arg_to_i32(bcx, llarg, arg.ty, arg.mode);\n+            call_args += vec(llarg_i32);\n+        } else {\n+            call_args += vec(llarg);\n+        }\n+\n+        if (arg.mode == ast.val) {\n+            drop_args += vec(tup(llarg, arg.ty));\n+        }\n+\n+        i += 1u;\n+    }\n+\n     auto r;\n     auto rptr;\n-    auto args = ty.ty_fn_args(ccx.tcx, fn_type);\n     alt (abi) {\n         case (ast.native_abi_llvm) {\n-            auto result = trans_simple_native_abi(bcx, name, args, call_args,\n-                                                  fn_type);\n+            auto result = trans_simple_native_abi(bcx, name, call_args,\n+                                                  fn_type, arg_n);\n             r = result._0; rptr = result._1;\n         }\n         case (ast.native_abi_rust_intrinsic) {\n-            auto result = trans_simple_native_abi(bcx, name, args, call_args,\n-                                                  fn_type);\n+            auto external_name = \"rust_intrinsic_\" + name;\n+            auto result = trans_simple_native_abi(bcx, external_name,\n+                                                  call_args, fn_type, arg_n);\n             r = result._0; rptr = result._1;\n         }\n         case (_) {\n-            let vec[tup(ValueRef, ty.t)] drop_args = vec();\n-\n-            for (ty.arg arg in args) {\n-                auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n-                assert (llarg as int != 0);\n-                push_arg(bcx, call_args, llarg, arg.ty, arg.mode);\n-                if (arg.mode == ast.val) {\n-                    drop_args += vec(tup(llarg, arg.ty));\n-                }\n-                arg_n += 1u;\n-            }\n-\n             r = trans_native_call(bcx.build, ccx.glues, lltaskptr,\n                                   ccx.externs, ccx.tn, ccx.llmod, name,\n                                   pass_task, call_args);\n             rptr = bcx.build.BitCast(fcx.llretptr, T_ptr(T_i32()));\n \n-            for (tup(ValueRef, ty.t) d in drop_args) {\n-                bcx = drop_ty(bcx, d._0, d._1).bcx;\n-            }\n         }\n     }\n \n@@ -6850,6 +6874,10 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     // the FIXME above.\n     if (!rty_is_nil) { bcx.build.Store(r, rptr); }\n \n+    for (tup(ValueRef, ty.t) d in drop_args) {\n+        bcx = drop_ty(bcx, d._0, d._1).bcx;\n+    }\n+\n     bcx.build.RetVoid();\n \n     // Tie up the llallocas -> lltop edge."}]}