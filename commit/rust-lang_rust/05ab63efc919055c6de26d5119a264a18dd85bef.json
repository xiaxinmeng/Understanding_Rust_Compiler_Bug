{"sha": "05ab63efc919055c6de26d5119a264a18dd85bef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YWI2M2VmYzkxOTA1NWM2ZGUyNmQ1MTE5YTI2NGExOGRkODViZWY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-18T20:48:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-18T20:48:20Z"}, "message": "Rollup merge of #65472 - Zoxc:sharded-dep-graph-2, r=nikomatsakis\n\nUse a sharded dep node to dep node index map\n\nSplit out from https://github.com/rust-lang/rust/pull/61845 and based on https://github.com/rust-lang/rust/pull/63756.\n\nr? @nikomatsakis", "tree": {"sha": "ba7804525626bca64d49bd9e2fb35ab89f308662", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7804525626bca64d49bd9e2fb35ab89f308662"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05ab63efc919055c6de26d5119a264a18dd85bef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdqiUVCRBK7hj4Ov3rIwAAdHIIAACe8jHVnGreAU3IcCXqYl7K\ndMLKXfKK5HgErXp6UEs1TpuriNgrPnFAzXVVFNVKvTcNsqI6PFO9cRmuHFd6wjay\n950Fjx7Ap9MMMRItSdZMVsG6gEavrspyJFK5cCWXSAXI2w2D/Ke7Y2j0+7MUF6KE\nuZnT5LQQn5mmUESms7RvsV35OyK6G9Jmx6FuQgdSNxhtLstWoD68qE8O6HZQvlh2\ntmWKsaUIWHcBZjJEFv7jD9AGeLdZviLMkXgQNDP2+FmQedwocoH0gt/C5bH5K9OC\nuVaWKb9RybcYoHKeVq9ZzIagIWYg5IkVklJZJtTD3GGBx+7EolgSynEcQAsc5wg=\n=smhw\n-----END PGP SIGNATURE-----\n", "payload": "tree ba7804525626bca64d49bd9e2fb35ab89f308662\nparent f5f5c9e9939232f5a437c026a7d46fde9da0c02d\nparent 42c0236ed0071ed9f8734c346341f0bf54732b8e\nauthor Tyler Mandry <tmandry@gmail.com> 1571431700 -0700\ncommitter GitHub <noreply@github.com> 1571431700 -0700\n\nRollup merge of #65472 - Zoxc:sharded-dep-graph-2, r=nikomatsakis\n\nUse a sharded dep node to dep node index map\n\nSplit out from https://github.com/rust-lang/rust/pull/61845 and based on https://github.com/rust-lang/rust/pull/63756.\n\nr? @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05ab63efc919055c6de26d5119a264a18dd85bef", "html_url": "https://github.com/rust-lang/rust/commit/05ab63efc919055c6de26d5119a264a18dd85bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05ab63efc919055c6de26d5119a264a18dd85bef/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5f5c9e9939232f5a437c026a7d46fde9da0c02d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5f5c9e9939232f5a437c026a7d46fde9da0c02d", "html_url": "https://github.com/rust-lang/rust/commit/f5f5c9e9939232f5a437c026a7d46fde9da0c02d"}, {"sha": "42c0236ed0071ed9f8734c346341f0bf54732b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c0236ed0071ed9f8734c346341f0bf54732b8e", "html_url": "https://github.com/rust-lang/rust/commit/42c0236ed0071ed9f8734c346341f0bf54732b8e"}], "stats": {"total": 59, "additions": 44, "deletions": 15}, "files": [{"sha": "337cdddc432c4640ed1c8321f5e9d554a373bef2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/05ab63efc919055c6de26d5119a264a18dd85bef/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ab63efc919055c6de26d5119a264a18dd85bef/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=05ab63efc919055c6de26d5119a264a18dd85bef", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use rustc_data_structures::sync::{Lrc, Lock, AtomicU32, AtomicU64, Ordering};\n+use rustc_data_structures::sharded::{self, Sharded};\n use std::sync::atomic::Ordering::SeqCst;\n use std::env;\n use std::hash::Hash;\n@@ -381,7 +382,7 @@ impl DepGraph {\n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            let map = data.current.node_to_node_index.lock();\n+            let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n             if let Some(dep_node_index) = map.get(&v).copied() {\n                 std::mem::drop(map);\n                 data.read_index(dep_node_index);\n@@ -405,6 +406,7 @@ impl DepGraph {\n             .unwrap()\n             .current\n             .node_to_node_index\n+            .get_shard_by_value(dep_node)\n             .lock()\n             .get(dep_node)\n             .cloned()\n@@ -414,7 +416,11 @@ impl DepGraph {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n         if let Some(ref data) = self.data {\n-            data.current.node_to_node_index.lock().contains_key(dep_node)\n+            data.current\n+                .node_to_node_index\n+                .get_shard_by_value(&dep_node)\n+                .lock()\n+                .contains_key(dep_node)\n         } else {\n             false\n         }\n@@ -595,7 +601,11 @@ impl DepGraph {\n \n         #[cfg(not(parallel_compiler))]\n         {\n-            debug_assert!(!data.current.node_to_node_index.lock().contains_key(dep_node));\n+            debug_assert!(!data.current\n+                               .node_to_node_index\n+                               .get_shard_by_value(dep_node)\n+                               .lock()\n+                               .contains_key(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n@@ -927,7 +937,7 @@ struct DepNodeData {\n /// acquire the lock on `data.`\n pub(super) struct CurrentDepGraph {\n     data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n-    node_to_node_index: Lock<FxHashMap<DepNode, DepNodeIndex>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -985,8 +995,8 @@ impl CurrentDepGraph {\n \n         CurrentDepGraph {\n             data: Lock::new(IndexVec::with_capacity(new_node_count_estimate)),\n-            node_to_node_index: Lock::new(FxHashMap::with_capacity_and_hasher(\n-                new_node_count_estimate,\n+            node_to_node_index: Sharded::new(|| FxHashMap::with_capacity_and_hasher(\n+                new_node_count_estimate / sharded::SHARDS,\n                 Default::default(),\n             )),\n             anon_id_seed: stable_hasher.finish(),\n@@ -1035,7 +1045,10 @@ impl CurrentDepGraph {\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        debug_assert!(!self.node_to_node_index.lock().contains_key(&dep_node));\n+        debug_assert!(!self.node_to_node_index\n+                           .get_shard_by_value(&dep_node)\n+                           .lock()\n+                           .contains_key(&dep_node));\n         self.intern_node(dep_node, edges, fingerprint)\n     }\n \n@@ -1045,7 +1058,7 @@ impl CurrentDepGraph {\n         edges: SmallVec<[DepNodeIndex; 8]>,\n         fingerprint: Fingerprint\n     ) -> DepNodeIndex {\n-        match self.node_to_node_index.lock().entry(dep_node) {\n+        match self.node_to_node_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 let mut data = self.data.lock();"}, {"sha": "d0ff6108d6ea6183fc3d035198b588585ac206e2", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/05ab63efc919055c6de26d5119a264a18dd85bef/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05ab63efc919055c6de26d5119a264a18dd85bef/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=05ab63efc919055c6de26d5119a264a18dd85bef", "patch": "@@ -2,6 +2,7 @@ use std::hash::{Hasher, Hash};\n use std::mem;\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n+use smallvec::SmallVec;\n use crate::fx::{FxHasher, FxHashMap};\n use crate::sync::{Lock, LockGuard};\n \n@@ -18,7 +19,7 @@ const SHARD_BITS: usize = 5;\n #[cfg(not(parallel_compiler))]\n const SHARD_BITS: usize = 0;\n \n-const SHARDS: usize = 1 << SHARD_BITS;\n+pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n #[derive(Clone)]\n@@ -29,21 +30,36 @@ pub struct Sharded<T> {\n impl<T: Default> Default for Sharded<T> {\n     #[inline]\n     fn default() -> Self {\n+        Self::new(|| T::default())\n+    }\n+}\n+\n+impl<T> Sharded<T> {\n+    #[inline]\n+    pub fn new(mut value: impl FnMut() -> T) -> Self {\n+        // Create a vector of the values we want\n+        let mut values: SmallVec<[_; SHARDS]> = (0..SHARDS).map(|_| {\n+            CacheAligned(Lock::new(value()))\n+        }).collect();\n+\n+        // Create an unintialized array\n         let mut shards: mem::MaybeUninit<[CacheAligned<Lock<T>>; SHARDS]> =\n             mem::MaybeUninit::uninit();\n-        let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+\n         unsafe {\n-            for i in 0..SHARDS {\n-                first.add(i).write(CacheAligned(Lock::new(T::default())));\n-            }\n+            // Copy the values into our array\n+            let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+            values.as_ptr().copy_to_nonoverlapping(first, SHARDS);\n+\n+            // Ignore the content of the vector\n+            values.set_len(0);\n+\n             Sharded {\n                 shards: shards.assume_init(),\n             }\n         }\n     }\n-}\n \n-impl<T> Sharded<T> {\n     #[inline]\n     pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n         if SHARDS == 1 {"}]}