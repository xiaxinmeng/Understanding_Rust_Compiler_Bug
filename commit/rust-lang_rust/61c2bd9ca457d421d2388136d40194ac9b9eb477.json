{"sha": "61c2bd9ca457d421d2388136d40194ac9b9eb477", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYzJiZDljYTQ1N2Q0MjFkMjM4ODEzNmQ0MDE5NGFjOWI5ZWI0Nzc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-16T09:23:22Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: use Primitive instead of Integer for CEnum and General discriminants.", "tree": {"sha": "00b8be7e070ea82e5acfc5f1820c1d005cf9e220", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00b8be7e070ea82e5acfc5f1820c1d005cf9e220"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61c2bd9ca457d421d2388136d40194ac9b9eb477", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61c2bd9ca457d421d2388136d40194ac9b9eb477", "html_url": "https://github.com/rust-lang/rust/commit/61c2bd9ca457d421d2388136d40194ac9b9eb477", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61c2bd9ca457d421d2388136d40194ac9b9eb477/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "335bd8ea1b5929fc55911374b55623f066835850", "url": "https://api.github.com/repos/rust-lang/rust/commits/335bd8ea1b5929fc55911374b55623f066835850", "html_url": "https://github.com/rust-lang/rust/commit/335bd8ea1b5929fc55911374b55623f066835850"}], "stats": {"total": 120, "additions": 57, "deletions": 63}, "files": [{"sha": "65efc3b5186f06c71859eec2685d2d41cf5f6cde", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> Struct {\n             }\n             (&CEnum { discr, .. }, &ty::TyAdt(def, _)) => {\n                 if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n-                    Ok(Some((Size::from_bytes(0), Int(discr))))\n+                    Ok(Some((Size::from_bytes(0), discr)))\n                 } else {\n                     Ok(None)\n                 }\n@@ -1097,7 +1097,7 @@ pub enum Layout {\n \n     /// C-like enums; basically an integer.\n     CEnum {\n-        discr: Integer,\n+        discr: Primitive,\n         signed: bool,\n         /// Inclusive discriminant range.\n         /// If min > max, it represents min...u64::MAX followed by 0...max.\n@@ -1118,7 +1118,7 @@ pub enum Layout {\n     /// all space reserved for the discriminant, and their first field starts\n     /// at a non-0 offset, after where the discriminant would go.\n     General {\n-        discr: Integer,\n+        discr: Primitive,\n         variants: Vec<Struct>,\n         size: Size,\n         align: Align,\n@@ -1251,8 +1251,8 @@ impl<'a, 'tcx> Layout {\n                 }\n             };\n             let abi = match *layout {\n-                Scalar(value) => Abi::Scalar(value),\n-                CEnum { discr, .. } => Abi::Scalar(Int(discr)),\n+                Scalar(value) |\n+                CEnum { discr: value, .. } => Abi::Scalar(value),\n \n                 Vector { .. } => Abi::Vector,\n \n@@ -1453,7 +1453,7 @@ impl<'a, 'tcx> Layout {\n                     // grok.\n                     let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n                     return success(CEnum {\n-                        discr,\n+                        discr: Int(discr),\n                         signed,\n                         // FIXME: should be u128?\n                         min: min as u64,\n@@ -1646,7 +1646,7 @@ impl<'a, 'tcx> Layout {\n                 }\n \n                 General {\n-                    discr: ity,\n+                    discr: Int(ity),\n                     variants,\n                     size,\n                     align,\n@@ -1722,7 +1722,7 @@ impl<'a, 'tcx> Layout {\n                  metadata.size(dl)).abi_align(self.align(dl))\n             }\n \n-            CEnum { discr, .. } => Int(discr).size(dl),\n+            CEnum { discr, .. } => discr.size(dl),\n             General { size, .. } => size,\n             UntaggedUnion(ref un) => un.stride(),\n \n@@ -1756,7 +1756,7 @@ impl<'a, 'tcx> Layout {\n                 Pointer.align(dl).max(metadata.align(dl))\n             }\n \n-            CEnum { discr, .. } => Int(discr).align(dl),\n+            CEnum { discr, .. } => discr.align(dl),\n             Array { align, .. } | General { align, .. } => align,\n             UntaggedUnion(ref un) => un.align,\n \n@@ -1858,7 +1858,7 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        let build_primitive_info = |name: ast::Name, value: &Primitive| {\n+        let build_primitive_info = |name: ast::Name, value: Primitive| {\n             session::VariantInfo {\n                 name: Some(name.to_string()),\n                 kind: session::SizeKind::Exact,\n@@ -1951,7 +1951,7 @@ impl<'a, 'tcx> Layout {\n                                                            variant_layout)\n                                     })\n                                     .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+                record(adt_kind.into(), Some(discr.size(tcx)), variant_infos);\n             }\n \n             Layout::UntaggedUnion(ref un) => {\n@@ -1966,11 +1966,10 @@ impl<'a, 'tcx> Layout {\n                 let variant_infos: Vec<_> =\n                     adt_def.variants.iter()\n                                     .map(|variant_def| {\n-                                        build_primitive_info(variant_def.name,\n-                                                             &Primitive::Int(discr))\n+                                        build_primitive_info(variant_def.name, discr)\n                                     })\n                                     .collect();\n-                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+                record(adt_kind.into(), Some(discr.size(tcx)), variant_infos);\n             }\n \n             // other cases provide little interesting (i.e. adjustable\n@@ -2359,9 +2358,7 @@ impl<'a, 'tcx> FullLayout<'tcx> {\n                     match self.variant_index {\n                         None => match *self.layout {\n                             // Discriminant field for enums (where applicable).\n-                            General { discr, .. } => {\n-                                return [discr.to_ty(tcx, false)][i];\n-                            }\n+                            General { discr, .. } |\n                             NullablePointer { discr, .. } => {\n                                 return [discr.to_ty(tcx)][i];\n                             }"}, {"sha": "879d2e326d88381078a0c43c8a34cdc362ef6781", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, LayoutOf, Primitive};\n+use rustc::ty::layout::{Layout, LayoutOf};\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n-                    let discr_size = Primitive::Int(discr).size(cx.tcx).bytes();\n+                    let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n                       t, size.bytes(), layout);"}, {"sha": "45367508c94bc86639bd89b835e9e5376a81bb2d", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -474,7 +474,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n \n             // Rust enum types that map onto C enums also need to follow\n             // the target ABI zero-/sign-extension rules.\n-            Layout::CEnum { discr, signed, .. } => (discr, signed),\n+            Layout::CEnum { discr: layout::Int(i), signed, .. } => (i, signed),\n \n             _ => return\n         };"}, {"sha": "e718c7f6f485440fcc1fcb05ca2ab4be43aaa582", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -103,7 +103,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let l = cx.layout_of(t);\n     debug!(\"adt::generic_type_of t: {:?} name: {:?}\", t, name);\n     match *l {\n-        layout::CEnum { discr, .. } => Type::from_integer(cx, discr),\n+        layout::CEnum { discr, .. } => cx.llvm_type_of(discr.to_ty(cx.tcx())),\n         layout::NullablePointer { nndiscr, ref nonnull, .. } => {\n             if let layout::Abi::Scalar(_) = l.abi {\n                 return cx.llvm_type_of(l.field(cx, 0).ty);\n@@ -236,11 +236,3 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n         _ => false,\n     }\n }\n-\n-pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n-    if min <= max {\n-        assert!(min <= discr && discr <= max)\n-    } else {\n-        assert!(min <= discr || discr <= max)\n-    }\n-}"}, {"sha": "9ae1ded7805047b74c691be64d02e76c64274da4", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -1451,19 +1451,22 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |inttype: layout::Integer, signed: bool| {\n-        let disr_type_key = (enum_def_id, inttype);\n+    let discriminant_type_metadata = |discr: layout::Primitive, signed: bool| {\n+        let disr_type_key = (enum_def_id, discr);\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n                                                                  .get(&disr_type_key).cloned();\n         match cached_discriminant_type_metadata {\n             Some(discriminant_type_metadata) => discriminant_type_metadata,\n             None => {\n                 let (discriminant_size, discriminant_align) =\n-                    (inttype.size(), inttype.align(cx));\n+                    (discr.size(cx), discr.align(cx));\n                 let discriminant_base_type_metadata =\n                     type_metadata(cx,\n-                                  inttype.to_ty(cx.tcx(), signed),\n+                                  match discr {\n+                                    layout::Int(i) => i.to_ty(cx.tcx(), signed),\n+                                    _ => discr.to_ty(cx.tcx())\n+                                  },\n                                   syntax_pos::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n "}, {"sha": "8d3a0fd57251019db625c7df0df45b962ff3d9c9", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -71,7 +71,7 @@ pub struct CrateDebugContext<'tcx> {\n     llmod: ModuleRef,\n     builder: DIBuilderRef,\n     created_files: RefCell<FxHashMap<(Symbol, Symbol), DIFile>>,\n-    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Integer), DIType>>,\n+    created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), DIType>>,\n \n     type_map: RefCell<TypeMap<'tcx>>,\n     namespace_map: RefCell<DefIdMap<DIScope>>,"}, {"sha": "dd06f369470783706d89f695f98fb4246e971c93", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -1093,7 +1093,7 @@ fn trans_const_adt<'a, 'tcx>(\n         _ => 0,\n     };\n     match *l {\n-        layout::CEnum { discr: d, min, max, .. } => {\n+        layout::CEnum { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n                     adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n@@ -1102,14 +1102,14 @@ fn trans_const_adt<'a, 'tcx>(\n                 _ => 0,\n             };\n             assert_eq!(vals.len(), 0);\n-            adt::assert_discr_in_range(min, max, discr);\n-            Const::new(C_int(Type::from_integer(ccx, d), discr as i64), t)\n+            Const::new(C_int(ccx.llvm_type_of(t), discr as i64), t)\n         }\n-        layout::General { discr: d, ref variants, .. } => {\n+        layout::General { ref variants, .. } => {\n+            let discr_ty = l.field(ccx, 0).ty;\n             let variant = &variants[variant_index];\n-            let lldiscr = C_int(Type::from_integer(ccx, d), variant_index as i64);\n+            let lldiscr = C_int(ccx.llvm_type_of(discr_ty), variant_index as i64);\n             build_const_struct(ccx, l, &variant, vals,\n-                Some(Const::new(lldiscr, d.to_ty(ccx.tcx(), false))))\n+                Some(Const::new(lldiscr, discr_ty)))\n         }\n         layout::UntaggedUnion(ref un) => {\n             assert_eq!(variant_index, 0);"}, {"sha": "dd134138f78d514d5ca539144b695b8d133af21e", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61c2bd9ca457d421d2388136d40194ac9b9eb477/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=61c2bd9ca457d421d2388136d40194ac9b9eb477", "patch": "@@ -351,25 +351,28 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     /// Helper for cases where the discriminant is simply loaded.\n-    fn load_discr(self, bcx: &Builder, ity: layout::Integer, min: u64, max: u64) -> ValueRef {\n-        let bits = ity.size().bits();\n-        assert!(bits <= 64);\n-        let bits = bits as usize;\n-        let mask = !0u64 >> (64 - bits);\n-        // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n-        // However, that is fine here (it would still represent the full range),\n-        if max.wrapping_add(1) & mask == min & mask {\n-            // i.e., if the range is everything.  The lo==hi case would be\n-            // rejected by the LLVM verifier (it would mean either an\n-            // empty set, which is impossible, or the entire range of the\n-            // type, which is pointless).\n-            bcx.load(self.llval, self.alignment.non_abi())\n-        } else {\n-            // llvm::ConstantRange can deal with ranges that wrap around,\n-            // so an overflow on (max + 1) is fine.\n-            bcx.load_range_assert(self.llval, min, max.wrapping_add(1), /* signed: */ llvm::True,\n-                                  self.alignment.non_abi())\n+    fn load_discr(self, bcx: &Builder, discr: layout::Primitive, min: u64, max: u64) -> ValueRef {\n+        if let layout::Int(ity) = discr {\n+            let bits = ity.size().bits();\n+            assert!(bits <= 64);\n+            let bits = bits as usize;\n+            let mask = !0u64 >> (64 - bits);\n+            // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n+            // However, that is fine here (it would still represent the full range),\n+            if max.wrapping_add(1) & mask == min & mask {\n+                // i.e., if the range is everything.  The lo==hi case would be\n+                // rejected by the LLVM verifier (it would mean either an\n+                // empty set, which is impossible, or the entire range of the\n+                // type, which is pointless).\n+            } else {\n+                // llvm::ConstantRange can deal with ranges that wrap around,\n+                // so an overflow on (max + 1) is fine.\n+                return bcx.load_range_assert(self.llval, min, max.wrapping_add(1),\n+                                             /* signed: */ llvm::True,\n+                                             self.alignment.non_abi());\n+            }\n         }\n+        bcx.load(self.llval, self.alignment.non_abi())\n     }\n \n     /// Obtain the actual discriminant of a value.\n@@ -406,14 +409,13 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n         match *l {\n-            layout::CEnum { discr, min, max, .. } => {\n-                adt::assert_discr_in_range(min, max, to);\n-                bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n+            layout::CEnum { .. } => {\n+                bcx.store(C_int(bcx.ccx.llvm_type_of(self.ty.to_ty(bcx.tcx())), to as i64),\n                     self.llval, self.alignment.non_abi());\n             }\n-            layout::General { discr, .. } => {\n+            layout::General { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n-                bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n+                bcx.store(C_int(bcx.ccx.llvm_type_of(ptr.ty.to_ty(bcx.tcx())), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n             layout::Univariant { .. }"}]}