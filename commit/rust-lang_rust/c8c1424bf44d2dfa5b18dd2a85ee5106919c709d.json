{"sha": "c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YzE0MjRiZjQ0ZDJkZmE1YjE4ZGQyYTg1ZWU1MTA2OTE5YzcwOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T06:54:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-13T06:54:24Z"}, "message": "Auto merge of #45673 - GuillaumeGomez:rustdoc-type-search-generic, r=QuietMisdreavus\n\nSearch over generic types in docs\n\nThis is what I was talking about @QuietMisdreavus. Now we have generics.\n\nWaiting for #45617 to get merged.", "tree": {"sha": "d6c7e5815146f01380fdfc0c074886a9ece90486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c7e5815146f01380fdfc0c074886a9ece90486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "html_url": "https://github.com/rust-lang/rust/commit/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "783c6ec55d9d93abf3fd96858fc9e3bd80611845", "url": "https://api.github.com/repos/rust-lang/rust/commits/783c6ec55d9d93abf3fd96858fc9e3bd80611845", "html_url": "https://github.com/rust-lang/rust/commit/783c6ec55d9d93abf3fd96858fc9e3bd80611845"}, {"sha": "0e4c829f2b09c6e3d9a326753517ce0514e356af", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4c829f2b09c6e3d9a326753517ce0514e356af", "html_url": "https://github.com/rust-lang/rust/commit/0e4c829f2b09c6e3d9a326753517ce0514e356af"}], "stats": {"total": 438, "additions": 307, "deletions": 131}, "files": [{"sha": "69eaf24289bfcd13bd5f52997b836aadb59d9732", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "patch": "@@ -361,6 +361,7 @@ impl ToJson for IndexItem {\n /// A type used for the search index.\n struct Type {\n     name: Option<String>,\n+    generics: Option<Vec<String>>,\n }\n \n impl ToJson for Type {\n@@ -369,6 +370,9 @@ impl ToJson for Type {\n             Some(ref name) => {\n                 let mut data = BTreeMap::new();\n                 data.insert(\"name\".to_owned(), name.to_json());\n+                if let Some(ref generics) = self.generics {\n+                    data.insert(\"generics\".to_owned(), generics.to_json());\n+                }\n                 Json::Object(data)\n             },\n             None => Json::Null\n@@ -420,7 +424,7 @@ fn init_ids() -> FxHashMap<String, usize> {\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n-     ].into_iter().map(|id| (String::from(*id), 1)).collect()\n+    ].into_iter().map(|id| (String::from(*id), 1)).collect()\n }\n \n /// This method resets the local table of used ID attributes. This is typically\n@@ -667,7 +671,6 @@ fn concise_compared_strs(s1: &str, s2: &str) -> (String, String) {\n     (format!(\"...{}\", concise_str(s1)), format!(\"...{}\", concise_str(s2)))\n }\n \n-\n fn print_message(msg: &str, intro_msg: &mut bool, span: &Span, text: &str) {\n     if !*intro_msg {\n         println!(\"WARNING: documentation for this crate may be rendered \\\n@@ -3956,23 +3959,42 @@ fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n }\n \n fn get_index_type(clean_type: &clean::Type) -> Type {\n-    Type { name: get_index_type_name(clean_type).map(|s| s.to_ascii_lowercase()) }\n+    let t = Type {\n+        name: get_index_type_name(clean_type, true).map(|s| s.to_ascii_lowercase()),\n+        generics: get_generics(clean_type),\n+    };\n+    t\n }\n \n-fn get_index_type_name(clean_type: &clean::Type) -> Option<String> {\n+fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<String> {\n     match *clean_type {\n         clean::ResolvedPath { ref path, .. } => {\n             let segments = &path.segments;\n             Some(segments[segments.len() - 1].name.clone())\n-        },\n-        clean::Generic(ref s) => Some(s.clone()),\n+        }\n+        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n         clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n         // FIXME: add all from clean::Type.\n         _ => None\n     }\n }\n \n+fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n+    clean_type.generics()\n+              .and_then(|types| {\n+                  let r = types.iter()\n+                               .filter_map(|t| get_index_type_name(t, false))\n+                               .map(|s| s.to_ascii_lowercase())\n+                               .collect::<Vec<_>>();\n+                  if r.is_empty() {\n+                      None\n+                  } else {\n+                      Some(r)\n+                  }\n+              })\n+}\n+\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "8d0faf261f6c934df9314726a828edd992f69a47", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 272, "deletions": 124, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "patch": "@@ -50,7 +50,7 @@\n         if (elem && className && elem.className) {\n             var elemClass = elem.className;\n             var start = elemClass.indexOf(className);\n-            if (start == -1) {\n+            if (start === -1) {\n                 return false;\n             } else if (elemClass.length === className.length) {\n                 return true;\n@@ -64,6 +64,14 @@\n                 }\n                 return true;\n             }\n+            if (start > 0 && elemClass[start - 1] !== ' ') {\n+                return false;\n+            }\n+            var end = start + className.length;\n+            if (end < elemClass.length && elemClass[end] !== ' ') {\n+                return false;\n+            }\n+            return true;\n         }\n         return false;\n     }\n@@ -137,7 +145,7 @@\n                 if (x) {\n                     x.scrollIntoView();\n                 }\n-            };\n+            }\n             onEach(document.getElementsByClassName('line-numbers'), function(e) {\n                 onEach(e.getElementsByTagName('span'), function(i_e) {\n                     removeClass(i_e, 'line-highlighted');\n@@ -380,45 +388,150 @@\n                 return b;\n             }\n \n-            function nbElements(obj) {\n-                var size = 0, key;\n-                for (key in obj) {\n-                    if (obj.hasOwnProperty(key)) {\n-                        size += 1;\n+            function extractGenerics(val) {\n+                val = val.toLowerCase();\n+                if (val.indexOf('<') !== -1) {\n+                    var values = val.substring(val.indexOf('<') + 1, val.lastIndexOf('>'));\n+                    return {\n+                        name: val.substring(0, val.indexOf('<')),\n+                        generics: values.split(/\\s*,\\s*/),\n+                    };\n+                }\n+                return {\n+                    name: val,\n+                    generics: [],\n+                };\n+            }\n+\n+            function checkGenerics(obj, val) {\n+                // The names match, but we need to be sure that all generics kinda\n+                // match as well.\n+                var lev_distance = MAX_LEV_DISTANCE + 1;\n+                if (val.generics.length > 0) {\n+                    if (obj.generics &&\n+                        obj.generics.length >= val.generics.length) {\n+                        var elems = obj.generics.slice(0);\n+                        for (var y = 0;\n+                             y < val.generics.length;\n+                             ++y) {\n+                            // The point here is to find the type that matches the most.\n+                            var lev = { pos: -1, lev: MAX_LEV_DISTANCE + 1};\n+                            for (var x = 0; x < elems.length; ++x) {\n+                                var tmp_lev = levenshtein(elems[x], val.generics[y]);\n+                                if (tmp_lev < lev.lev) {\n+                                    lev.lev = tmp_lev;\n+                                    lev.pos = x;\n+                                }\n+                            }\n+                            if (lev.pos !== -1) {\n+                                elems.splice(lev.pos, 1);\n+                                lev_distance = min(lev.lev, lev_distance);\n+                            } else {\n+                                return MAX_LEV_DISTANCE + 1;\n+                            }\n+                        }\n+                        return lev_distance;\n+                    }\n+                } else {\n+                    return 0;\n+                }\n+                return MAX_LEV_DISTANCE + 1;\n+            }\n+\n+            // Check for type name and type generics (if any).\n+            function checkType(obj, val, literalSearch) {\n+                var lev_distance = MAX_LEV_DISTANCE + 1;\n+                if (obj.name === val.name) {\n+                    if (literalSearch === true) {\n+                        if (val.generics.length !== 0) {\n+                            if (obj.generics && obj.length >= val.generics.length) {\n+                                var elems = obj.generics.slice(0);\n+                                var allFound = true;\n+                                var x;\n+\n+                                for (var y = 0; allFound === true && y < val.generics.length; ++y) {\n+                                    allFound = false;\n+                                    for (x = 0; allFound === false && x < elems.length; ++x) {\n+                                        allFound = elems[x] === val.generics[y];\n+                                    }\n+                                    if (allFound === true) {\n+                                        elems.splice(x - 1, 1);\n+                                    }\n+                                }\n+                                if (allFound === true) {\n+                                    return true;\n+                                }\n+                            } else {\n+                                return false;\n+                            }\n+                        }\n+                        return true;\n+                    }\n+                    // If the type has generics but don't match, then it won't return at this point.\n+                    // Otherwise, `checkGenerics` will return 0 and it'll return.\n+                    var tmp_lev = checkGenerics(obj, val);\n+                    if (tmp_lev <= MAX_LEV_DISTANCE) {\n+                        return tmp_lev;\n+                    }\n+                }\n+                // Names didn't match so let's check if one of the generic types could.\n+                if (literalSearch === true) {\n+                     if (obj.generics.length > 0) {\n+                        for (var x = 0; x < obj.generics.length; ++x) {\n+                            if (obj.generics[x] === val.name) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    return false;\n+                }\n+                var new_lev = levenshtein(obj.name, val.name);\n+                if (new_lev < lev_distance) {\n+                    if ((lev = checkGenerics(obj, val)) <= MAX_LEV_DISTANCE) {\n+                        lev_distance = min(min(new_lev, lev), lev_distance);\n+                    }\n+                } else if (obj.generics && obj.generics.length > 0) {\n+                    for (var x = 0; x < obj.generics.length; ++x) {\n+                        lev_distance = min(levenshtein(obj.generics[x], val.name), lev_distance);\n                     }\n                 }\n-                return size;\n+                // Now whatever happens, the returned distance is \"less good\" so we should mark it\n+                // as such, and so we add 1 to the distance to make it \"less good\".\n+                return lev_distance + 1;\n             }\n \n-            function findArg(obj, val) {\n+            function findArg(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n                 if (obj && obj.type && obj.type.inputs.length > 0) {\n                     for (var i = 0; i < obj.type.inputs.length; i++) {\n-                        if (obj.type.inputs[i].name === val) {\n-                            // No need to check anything else: we found it. Let's just move on.\n-                            return 0;\n+                        var tmp = checkType(obj.type.inputs[i], val, literalSearch);\n+                        if (literalSearch === true && tmp === true) {\n+                            return true;\n                         }\n-                        lev_distance = min(levenshtein(obj.type.inputs[i].name, val), lev_distance);\n+                        lev_distance = min(tmp, lev_distance);\n                         if (lev_distance === 0) {\n                             return 0;\n                         }\n                     }\n                 }\n-                return lev_distance;\n+                return literalSearch === true ? false : lev_distance;\n             }\n \n-            function checkReturned(obj, val) {\n+            function checkReturned(obj, val, literalSearch) {\n                 var lev_distance = MAX_LEV_DISTANCE + 1;\n+\n                 if (obj && obj.type && obj.type.output) {\n-                    if (obj.type.output.name.toLowerCase() === val) {\n-                        return 0;\n+                    var tmp = checkType(obj.type.output, val, literalSearch);\n+                    if (literalSearch === true && tmp === true) {\n+                        return true;\n                     }\n-                    lev_distance = min(levenshtein(obj.type.output.name, val));\n+                    lev_distance = min(tmp, lev_distance);\n                     if (lev_distance === 0) {\n                         return 0;\n                     }\n                 }\n-                return lev_distance;\n+                return literalSearch === true ? false : lev_distance;\n             }\n \n             function typePassesFilter(filter, type) {\n@@ -448,27 +561,41 @@\n             if ((val.charAt(0) === \"\\\"\" || val.charAt(0) === \"'\") &&\n                 val.charAt(val.length - 1) === val.charAt(0))\n             {\n-                val = val.substr(1, val.length - 2).toLowerCase();\n+                var results_length = 0;\n+                val = extractGenerics(val.substr(1, val.length - 2));\n                 for (var i = 0; i < nSearchWords; ++i) {\n+                    var in_args = findArg(searchIndex[i], val, true);\n+                    var returned = checkReturned(searchIndex[i], val, true);\n                     var ty = searchIndex[i];\n-                    if (searchWords[i] === val) {\n+                    if (searchWords[i] === val.name) {\n                         // filter type: ... queries\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                        if (typePassesFilter(typeFilter, searchIndex[i].ty) &&\n+                            results[ty.path + ty.name] === undefined)\n+                        {\n                             results[ty.path + ty.name] = {id: i, index: -1};\n+                            results_length += 1;\n                         }\n-                    } else if (findArg(searchIndex[i], val) ||\n-                               (ty.type &&\n-                                ty.type.output &&\n-                                ty.type.output.name === val)) {\n-                        if (typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                    } else if ((in_args === true || returned === true) &&\n+                               typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                        if (results[ty.path + ty.name] === undefined) {\n                             results[ty.path + ty.name] = {\n                                 id: i,\n                                 index: -1,\n                                 dontValidate: true,\n+                                in_args: in_args,\n+                                returned: returned,\n                             };\n+                            results_length += 1;\n+                        } else {\n+                            if (in_args === true) {\n+                                results[ty.path + ty.name].in_args = true;\n+                            }\n+                            if (returned === true) {\n+                                results[ty.path + ty.name].returned = true;\n+                            }\n                         }\n                     }\n-                    if (nbElements(results) === max) {\n+                    if (results_length === max) {\n                         break;\n                     }\n                 }\n@@ -482,7 +609,10 @@\n                 var input = parts[0];\n                 // sort inputs so that order does not matter\n                 var inputs = input.split(\",\").map(trimmer).sort();\n-                var output = parts[1];\n+                for (var i = 0; i < inputs.length; ++i) {\n+                    inputs[i] = extractGenerics(inputs[i]);\n+                }\n+                var output = extractGenerics(parts[1]);\n \n                 for (var i = 0; i < nSearchWords; ++i) {\n                     var type = searchIndex[i].type;\n@@ -491,104 +621,128 @@\n                         continue;\n                     }\n \n-                    // sort index inputs so that order does not matter\n-                    var typeInputs = type.inputs.map(function (input) {\n-                        return input.name;\n-                    }).sort();\n-\n                     // allow searching for void (no output) functions as well\n                     var typeOutput = type.output ? type.output.name : \"\";\n-                    if (output === \"*\" || output == typeOutput) {\n+                    var returned = checkReturned(ty, output, true);\n+                    if (output.name === \"*\" || returned === true) {\n+                        var in_args = false;\n+                        var module = false;\n+\n                         if (input === \"*\") {\n-                            results[ty.path + ty.name] = {id: i, index: -1, dontValidate: true};\n+                            module = true;\n                         } else {\n                             var allFound = true;\n                             for (var it = 0; allFound === true && it < inputs.length; it++) {\n-                                var found = false;\n-                                for (var y = 0; found === false && y < typeInputs.length; y++) {\n-                                    found = typeInputs[y] === inputs[it];\n-                                }\n-                                allFound = found;\n+                                allFound = checkType(type, inputs[it], true);\n                             }\n-                            if (allFound === true) {\n+                            in_args = allFound;\n+                        }\n+                        if (in_args === true || returned === true || module === true) {\n+                            if (results[ty.path + ty.name] !== undefined) {\n+                                if (returned === true) {\n+                                    results[ty.path + ty.name].returned = true;\n+                                }\n+                                if (in_args === true) {\n+                                    results[ty.path + ty.name].in_args = true;\n+                                }\n+                            } else {\n                                 results[ty.path + ty.name] = {\n                                     id: i,\n                                     index: -1,\n                                     dontValidate: true,\n+                                    returned: returned,\n+                                    in_args: in_args,\n                                 };\n                             }\n                         }\n                     }\n                 }\n-                query.inputs = inputs;\n-                query.output = output;\n+                query.inputs = inputs.map(function(input) {\n+                    return input.name;\n+                });\n+                query.output = output.name;\n             } else {\n                 query.inputs = [val];\n                 query.output = val;\n                 query.search = val;\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n+                var valGenerics = extractGenerics(val);\n+                var results_length = 0;\n                 for (var i = 0; i < split.length; ++i) {\n                     for (var j = 0; j < nSearchWords; ++j) {\n                         var lev_distance;\n                         var ty = searchIndex[j];\n                         if (!ty) {\n                             continue;\n                         }\n+                        var returned = false;\n+                        var in_args = false;\n+                        var index = -1;\n+                        // we want lev results to go lower than others\n+                        var lev = MAX_LEV_DISTANCE;\n+\n                         if (searchWords[j].indexOf(split[i]) > -1 ||\n                             searchWords[j].indexOf(val) > -1 ||\n                             searchWords[j].replace(/_/g, \"\").indexOf(val) > -1)\n                         {\n                             // filter type: ... queries\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                results[ty.path + ty.name] === undefined) {\n+                                index = searchWords[j].replace(/_/g, \"\").indexOf(val);\n+                            }\n+                        }\n+                        if ((lev_distance = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                lev = min(lev, lev_distance);\n+                                index = 0;\n+                            }\n+                        }\n+                        if ((lev_distance = findArg(searchIndex[j], valGenerics))\n+                            <= MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                in_args = true;\n+                                lev = min(lev_distance, lev);\n+                                index = 0;\n+                            }\n+                        }\n+                        if ((lev_distance = checkReturned(searchIndex[j], valGenerics)) <=\n+                            MAX_LEV_DISTANCE) {\n+                            if (typePassesFilter(typeFilter, searchIndex[j].ty) &&\n+                                (results[ty.path + ty.name] === undefined ||\n+                                 results[ty.path + ty.name].lev > lev_distance)) {\n+                                returned = true;\n+                                lev = min(lev_distance, lev);\n+                                index = 0;\n+                            }\n+                        }\n+                        if (index !== -1) {\n+                            if (results[ty.path + ty.name] === undefined) {\n                                 results[ty.path + ty.name] = {\n                                     id: j,\n-                                    index: searchWords[j].replace(/_/g, \"\").indexOf(val),\n-                                    lev: 0,\n+                                    index: index,\n+                                    lev: lev,\n+                                    in_args: in_args,\n+                                    returned: returned,\n                                 };\n-                            }\n-                        } else if (\n-                            (lev_distance = levenshtein(searchWords[j], val)) <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                                results_length += 1;\n+                            } else {\n+                                if (results[ty.path + ty.name].lev > lev) {\n+                                    results[ty.path + ty.name].lev = lev;\n                                 }\n-                            }\n-                        } else if (\n-                            (lev_distance = findArg(searchIndex[j], val)) <= MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                                if (in_args === true) {\n+                                    results[ty.path + ty.name].in_args = true;\n                                 }\n-                            }\n-                        } else if (\n-                            (lev_distance = checkReturned(searchIndex[j], val)) <=\n-                            MAX_LEV_DISTANCE) {\n-                            if (typePassesFilter(typeFilter, searchIndex[j].ty)) {\n-                                if (results[ty.path + ty.name] === undefined ||\n-                                    results[ty.path + ty.name].lev > lev_distance) {\n-                                    results[ty.path + ty.name] = {\n-                                        id: j,\n-                                        index: 0,\n-                                        // we want lev results to go lower than others\n-                                        lev: lev_distance,\n-                                    };\n+                                if (returned === true) {\n+                                    results[ty.path + ty.name].returned = true;\n                                 }\n                             }\n                         }\n-                        if (nbElements(results) === max) {\n+                        if (results_length === max) {\n                             break;\n                         }\n                     }\n@@ -678,18 +832,19 @@\n             });\n \n             for (var i = 0; i < results.length; ++i) {\n-                var result = results[i],\n-                    name = result.item.name.toLowerCase(),\n-                    path = result.item.path.toLowerCase(),\n-                    parent = result.item.parent;\n+                var result = results[i];\n \n                 // this validation does not make sense when searching by types\n                 if (result.dontValidate) {\n                     continue;\n                 }\n+                var name = result.item.name.toLowerCase(),\n+                    path = result.item.path.toLowerCase(),\n+                    parent = result.item.parent;\n \n-                var valid = validateResult(name, path, split, parent);\n-                if (!valid) {\n+                if (result.returned === false && result.param === false &&\n+                    validateResult(name, path, split, parent) === false)\n+                {\n                     result.id = -1;\n                 }\n             }\n@@ -716,14 +871,14 @@\n                 // each check is for validation so we negate the conditions and invalidate\n                 if (!(\n                     // check for an exact name match\n-                    name.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    name.indexOf(keys[i]) > -1 ||\n                     // then an exact path match\n-                    path.toLowerCase().indexOf(keys[i]) > -1 ||\n+                    path.indexOf(keys[i]) > -1 ||\n                     // next if there is a parent, check for exact parent match\n                     (parent !== undefined &&\n                         parent.name.toLowerCase().indexOf(keys[i]) > -1) ||\n                     // lastly check to see if the name was a levenshtein match\n-                    levenshtein(name.toLowerCase(), keys[i]) <= MAX_LEV_DISTANCE)) {\n+                    levenshtein(name, keys[i]) <= MAX_LEV_DISTANCE)) {\n                     return false;\n                 }\n             }\n@@ -923,11 +1078,12 @@\n             return output;\n         }\n \n-        function makeTabHeader(tabNb, text) {\n+        function makeTabHeader(tabNb, text, nbElems) {\n             if (currentTab === tabNb) {\n-                return '<div class=\"selected\">' + text + '</div>';\n+                return '<div class=\"selected\">' + text +\n+                       ' <div class=\"count\">(' + nbElems + ')</div></div>';\n             }\n-            return '<div>' + text + '</div>';\n+            return '<div>' + text + ' <div class=\"count\">(' + nbElems + ')</div></div>';\n         }\n \n         function showResults(results) {\n@@ -937,9 +1093,9 @@\n             output = '<h1>Results for ' + escape(query.query) +\n                 (query.type ? ' (type: ' + escape(query.type) + ')' : '') + '</h1>' +\n                 '<div id=\"titles\">' +\n-                makeTabHeader(0, \"Types/modules\") +\n-                makeTabHeader(1, \"As parameters\") +\n-                makeTabHeader(2, \"As return value\") +\n+                makeTabHeader(0, \"Types/modules\", results['others'].length) +\n+                makeTabHeader(1, \"As parameters\", results['in_args'].length) +\n+                makeTabHeader(2, \"As return value\", results['returned'].length) +\n                 '</div><div id=\"results\">';\n \n             output += addTab(results['others'], query);\n@@ -1008,33 +1164,21 @@\n                     filterdata.push([obj.name, obj.ty, obj.path, obj.desc]);\n                     if (obj.type) {\n                         if (results['returned'].length < maxResults &&\n-                            obj.type.output &&\n-                            obj.type.output.name.toLowerCase() === query.output) {\n+                            resultIndex[i].returned === true)\n+                        {\n                             results['returned'].push(obj);\n                             added = true;\n                         }\n-                        if (results['in_args'].length < maxResults && obj.type.inputs.length > 0) {\n-                            var all_founds = true;\n-                            for (var it = 0;\n-                                 all_founds === true && it < query.inputs.length;\n-                                 it++) {\n-                                var found = false;\n-                                for (var y = 0;\n-                                     found === false && y < obj.type.inputs.length;\n-                                     y++) {\n-                                    found = query.inputs[it] === obj.type.inputs[y].name;\n-                                }\n-                                all_founds = found;\n-                            }\n-                            if (all_founds === true) {\n-                                results['in_args'].push(obj);\n-                                added = true;\n-                            }\n+                        if (results['in_args'].length < maxResults &&\n+                            resultIndex[i].in_args === true)\n+                        {\n+                            results['in_args'].push(obj);\n+                            added = true;\n                         }\n                     }\n                     if (results['others'].length < maxResults &&\n-                        ((query.search && obj.name.indexOf(query.search) !== -1) ||\n-                          added === false)) {\n+                        (added === false ||\n+                         (query.search && obj.name.indexOf(query.search) !== -1))) {\n                         results['others'].push(obj);\n                     }\n                 }\n@@ -1050,7 +1194,9 @@\n \n         function itemTypeFromName(typename) {\n             for (var i = 0; i < itemTypes.length; ++i) {\n-                if (itemTypes[i] === typename) { return i; }\n+                if (itemTypes[i] === typename) {\n+                    return i;\n+                }\n             }\n             return -1;\n         }\n@@ -1141,7 +1287,7 @@\n             var search_input = document.getElementsByClassName(\"search-input\")[0];\n             search_input.onkeyup = callback;\n             search_input.oninput = callback;\n-            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e){\n+            document.getElementsByClassName(\"search-form\")[0].onsubmit = function(e) {\n                 e.preventDefault();\n                 clearTimeout(searchTimeout);\n                 search();\n@@ -1217,7 +1363,9 @@\n \n             var crates = [];\n             for (var crate in rawSearchIndex) {\n-                if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n+                if (!rawSearchIndex.hasOwnProperty(crate)) {\n+                    continue;\n+                }\n                 crates.push(crate);\n             }\n             crates.sort();"}, {"sha": "55acc575152371a5ac05b11a30ad3f17aa5b91ab", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c8c1424bf44d2dfa5b18dd2a85ee5106919c709d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=c8c1424bf44d2dfa5b18dd2a85ee5106919c709d", "patch": "@@ -945,3 +945,9 @@ pre.rust {\n #titles > div:hover {\n \tborder-bottom: 3px solid #0089ff;\n }\n+\n+#titles > div > div.count {\n+\tdisplay: inline-block;\n+\tcolor: #888;\n+\tfont-size: 16px;\n+}"}]}