{"sha": "39967a85e1f04676062d46b04e7ac8399c57df66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5OTY3YTg1ZTFmMDQ2NzYwNjJkNDZiMDRlN2FjODM5OWM1N2RmNjY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-07T11:51:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-07T11:57:24Z"}, "message": "refactor if-let lowering\n\nmainly to get rid of unwraps", "tree": {"sha": "291d68757076b070ade3b4d6e6641dcb643a9b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/291d68757076b070ade3b4d6e6641dcb643a9b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39967a85e1f04676062d46b04e7ac8399c57df66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39967a85e1f04676062d46b04e7ac8399c57df66", "html_url": "https://github.com/rust-lang/rust/commit/39967a85e1f04676062d46b04e7ac8399c57df66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39967a85e1f04676062d46b04e7ac8399c57df66/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988", "html_url": "https://github.com/rust-lang/rust/commit/4d6475ada0c4176734f7e7f24cb1be8c5c8d1988"}], "stats": {"total": 44, "additions": 25, "deletions": 19}, "files": [{"sha": "b59787a83c8094ee1fd5d11b45edc4cf8d4cfbee", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/39967a85e1f04676062d46b04e7ac8399c57df66/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39967a85e1f04676062d46b04e7ac8399c57df66/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=39967a85e1f04676062d46b04e7ac8399c57df66", "patch": "@@ -559,6 +559,7 @@ where\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n+\n                 let else_branch = e.else_branch().map(|b| match b {\n                     ast::ElseBranch::Block(it) => self.collect_block(it),\n                     ast::ElseBranch::IfExpr(elif) => {\n@@ -567,25 +568,30 @@ where\n                     }\n                 });\n \n-                if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n-                    // if let -- desugar to match\n-                    let pat = self.collect_pat(pat);\n-                    let match_expr =\n-                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n-                    let placeholder_pat = self.pats.alloc(Pat::Missing);\n-                    let arms = vec![\n-                        MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n-                        MatchArm {\n-                            pats: vec![placeholder_pat],\n-                            expr: else_branch.unwrap_or_else(|| self.empty_block()),\n-                            guard: None,\n-                        },\n-                    ];\n-                    self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n-                } else {\n-                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n-                    self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n-                }\n+                let condition = match e.condition() {\n+                    None => self.exprs.alloc(Expr::Missing),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                                MatchArm {\n+                                    pats: vec![placeholder_pat],\n+                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                                    guard: None,\n+                                },\n+                            ];\n+                            return self\n+                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::ExprKind::TryBlockExpr(e) => {\n                 let body = self.collect_block_opt(e.try_body());"}]}