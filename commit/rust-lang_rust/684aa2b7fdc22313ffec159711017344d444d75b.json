{"sha": "684aa2b7fdc22313ffec159711017344d444d75b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NGFhMmI3ZmRjMjIzMTNmZmVjMTU5NzExMDE3MzQ0ZDQ0NGQ3NWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T20:17:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T20:18:08Z"}, "message": "librustc: De-export ty. rs=deexporting", "tree": {"sha": "7d648d930979cae165ef1a6229fef8f6bb910b29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d648d930979cae165ef1a6229fef8f6bb910b29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/684aa2b7fdc22313ffec159711017344d444d75b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/684aa2b7fdc22313ffec159711017344d444d75b", "html_url": "https://github.com/rust-lang/rust/commit/684aa2b7fdc22313ffec159711017344d444d75b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/684aa2b7fdc22313ffec159711017344d444d75b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "762ae4464e39018f608b6565c6d1b785e0ef886c", "url": "https://api.github.com/repos/rust-lang/rust/commits/762ae4464e39018f608b6565c6d1b785e0ef886c", "html_url": "https://github.com/rust-lang/rust/commit/762ae4464e39018f608b6565c6d1b785e0ef886c"}], "stats": {"total": 845, "additions": 339, "deletions": 506}, "files": [{"sha": "3371e457a616cb53e39fd9dcb3f3a308707c1259", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 339, "deletions": 505, "changes": 844, "blob_url": "https://github.com/rust-lang/rust/blob/684aa2b7fdc22313ffec159711017344d444d75b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/684aa2b7fdc22313ffec159711017344d444d75b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=684aa2b7fdc22313ffec159711017344d444d75b", "patch": "@@ -51,240 +51,48 @@ use syntax::print::pprust;\n use syntax::{ast, ast_map};\n use syntax;\n \n-export ProvidedMethodSource;\n-export ProvidedMethodInfo;\n-export ProvidedMethodsMap;\n-export InstantiatedTraitRef;\n-export TyVid, IntVid, FloatVid, RegionVid, Vid;\n-export br_hashmap;\n-export is_instantiable;\n-export node_id_to_type;\n-export node_id_to_type_params;\n-export arg;\n-export args_eq;\n-export block_ty;\n-export struct_fields, struct_mutable_fields;\n-export ctxt;\n-export deref, deref_sty;\n-export index, index_sty;\n-export def_has_ty_params;\n-export expr_has_ty_params;\n-export expr_ty;\n-export expr_ty_params_and_ty;\n-export expr_is_lval, expr_kind;\n-export ExprKind, LvalueExpr, RvalueDatumExpr, RvalueDpsExpr, RvalueStmtExpr;\n-export field_ty;\n-export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_sig;\n-export apply_op_on_t_to_ty_fn;\n-export fold_regions_and_ty, walk_regions_and_ty;\n-export field;\n-export field_idx, field_idx_strict;\n-export get_field;\n-export get_fields;\n-export get_element_type;\n-export has_dtor;\n-export is_binopable;\n-export is_pred_ty;\n-export lookup_struct_field, lookup_struct_fields;\n-export lookup_field_type;\n-export lookup_item_type;\n-export lookup_public_fields;\n-export method;\n-export method_idx;\n-export mk_struct, mk_err;\n-export mk_ctxt;\n-export mk_with_id, type_def_id;\n-export mt;\n-export node_type_table;\n-export pat_ty;\n-export sequence_element_type;\n-export stmt_node_id;\n-export sty;\n-export subst, subst_tps, substs_is_noop, substs_to_str, substs;\n-export subst_substs;\n-export t;\n-export new_ty_hash;\n-export enum_variants, substd_enum_variants, enum_is_univariant;\n-export trait_methods, store_trait_methods, impl_traits;\n-export enum_variant_with_id;\n-export ty_dtor;\n-export DtorKind, NoDtor, LegacyDtor, TraitDtor;\n-export ty_param_bounds_and_ty;\n-export ty_param_substs_and_ty;\n-export ty_bool, mk_bool, type_is_bool;\n-export ty_bot, mk_bot, type_is_bot;\n-export ty_box, mk_box, mk_imm_box, type_is_box, type_is_boxed;\n-export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n-export ty_opaque_box, mk_opaque_box;\n-export ty_float, mk_float, mk_mach_float, type_is_fp;\n-export ty_fn, FnTy, FnTyBase, FnMeta, FnSig, mk_fn;\n-export ty_fn_proto, ty_fn_purity, ty_fn_ret, tys_in_fn_sig;\n-export ty_vstore;\n-export replace_fn_return_type;\n-export ty_int, mk_int, mk_mach_int, mk_char;\n-export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n-export mk_f32, mk_f64;\n-export ty_err;\n-export ty_estr, mk_estr, type_is_str;\n-export ty_evec, mk_evec, type_is_vec;\n-export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n-export vstore, vstore_fixed, vstore_uniq, vstore_box, vstore_slice;\n-export encode_vstore, decode_vstore;\n-export ty_nil, mk_nil, type_is_nil;\n-export ty_trait, mk_trait;\n-export ty_param, mk_param, ty_params_to_tys;\n-export ty_ptr, mk_ptr, mk_mut_ptr, mk_imm_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n-export ty_rptr, mk_rptr, mk_mut_rptr, mk_imm_rptr;\n-export ty_rec, mk_rec;\n-export ty_enum, mk_enum, type_is_enum;\n-export ty_tup, mk_tup;\n-export ty_type, mk_type;\n-export ty_uint, mk_uint, mk_mach_uint;\n-export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n-export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var;\n-export mk_float_var;\n-export InferTy, TyVar, IntVar, FloatVar;\n-export ValueMode, ReadValue, CopyValue, MoveValue;\n-export ty_self, mk_self, type_has_self;\n-export ty_struct;\n-export Region, bound_region, encl_region;\n-export re_bound, re_free, re_scope, re_static, re_infer;\n-export ReVar, ReSkolemized;\n-export br_self, br_anon, br_named, br_cap_avoid, br_fresh;\n-export get, type_has_params, type_needs_infer, type_has_regions;\n-export type_contains_err, type_is_region_ptr;\n-export type_id;\n-export tbox_has_flag;\n-export ty_var_id;\n-export ty_to_def_id;\n-export ty_fn_args;\n-export ty_region;\n-export Kind, kind_implicitly_copyable, kind_send_copy, kind_copyable;\n-export kind_noncopyable, kind_const;\n-export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n-export type_implicitly_moves;\n-export kind_is_safe_for_default_mode;\n-export kind_is_durable;\n-export meta_kind, kind_lteq, type_kind, type_kind_ext;\n-export operators;\n-export type_err, terr_vstore_kind;\n-export terr_integer_as_char, terr_mismatch, terr_onceness_mismatch;\n-export type_err_to_str, note_and_explain_type_err;\n-export expected_found;\n-export type_needs_drop;\n-export type_is_char;\n-export type_is_empty;\n-export type_is_integral;\n-export type_is_numeric;\n-export type_is_pod;\n-export type_is_scalar;\n-export type_is_immediate;\n-export type_is_borrowed;\n-export type_is_sequence;\n-export type_is_signed;\n-export type_is_structural;\n-export type_is_copyable;\n-export type_is_slice;\n-export type_is_unique;\n-export type_is_c_like_enum;\n-export type_structurally_contains;\n-export type_structurally_contains_uniques;\n-export type_autoderef, deref, deref_sty;\n-export type_param;\n-export type_needs_unwind_cleanup;\n-export canon_mode;\n-export resolved_mode;\n-export arg_mode;\n-export unify_mode;\n-export set_default_mode;\n-export VariantInfo, VariantInfo_;\n-export walk_ty, maybe_walk_ty;\n-export occurs_check;\n-export param_ty;\n-export param_bound, param_bounds, bound_copy, bound_durable;\n-export param_bounds_to_str, param_bound_to_str;\n-export bound_owned, bound_trait;\n-export param_bounds_to_kind;\n-export default_arg_mode_for_ty;\n-export item_path;\n-export item_path_str;\n-export ast_ty_to_ty_cache_entry;\n-export atttce_unresolved, atttce_resolved;\n-export mach_sty;\n-export ty_sort_str;\n-export normalize_ty;\n-export to_str;\n-export bound_const;\n-export terr_int_mismatch, terr_float_mismatch, terr_sigil_mismatch;\n-export terr_ty_param_size, terr_self_substs;\n-export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n-export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n-export terr_regions_does_not_outlive, terr_mutability, terr_purity_mismatch;\n-export terr_regions_not_same, terr_regions_no_overlap;\n-export terr_regions_insufficiently_polymorphic;\n-export terr_regions_overly_polymorphic;\n-export terr_proto_mismatch;\n-export terr_fn, terr_trait;\n-export onceness_to_str;\n-export param_tys_in_type;\n-export eval_repeat_count;\n-export ast_proto_to_proto;\n-export method_call_bounds;\n-export hash_region;\n-export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n-export opt_region_variance;\n-export determine_inherited_purity;\n-export provided_trait_methods;\n-export trait_supertraits;\n-export AutoAdjustment;\n-export AutoRef;\n-export AutoRefKind, AutoPtr, AutoBorrowVec, AutoBorrowVecRef, AutoBorrowFn;\n-export iter_bound_traits_and_supertraits;\n-export count_traits_and_supertraits;\n-export IntVarValue, IntType, UintType;\n-export creader_cache_key;\n-export get_impl_id;\n-\n // Data types\n \n // Note: after typeck, you should use resolved_mode() to convert this mode\n // into an rmode, which will take into account the results of mode inference.\n #[deriving_eq]\n-struct arg {\n+pub struct arg {\n     mode: ast::mode,\n     ty: t\n }\n \n #[deriving_eq]\n-struct field {\n+pub struct field {\n     ident: ast::ident,\n     mt: mt\n }\n \n-type param_bounds = @~[param_bound];\n-\n-type method = {ident: ast::ident,\n-               tps: @~[param_bounds],\n-               fty: FnTy,\n-               self_ty: ast::self_ty_,\n-               vis: ast::visibility,\n-               def_id: ast::def_id};\n+pub type param_bounds = @~[param_bound];\n \n-struct mt {\n+pub type method = {\n+    ident: ast::ident,\n+    tps: @~[param_bounds],\n+    fty: FnTy,\n+    self_ty: ast::self_ty_,\n+    vis: ast::visibility,\n+    def_id: ast::def_id\n+};\n+\n+pub struct mt {\n     ty: t,\n     mutbl: ast::mutability,\n }\n \n #[auto_encode]\n #[auto_decode]\n-enum vstore {\n+pub enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n     vstore_box,\n     vstore_slice(Region)\n }\n \n-struct field_ty {\n+pub struct field_ty {\n   ident: ident,\n   id: def_id,\n   vis: ast::visibility,\n@@ -303,7 +111,7 @@ pub enum ValueMode {\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[deriving_eq]\n-struct creader_cache_key {\n+pub struct creader_cache_key {\n     cnum: int,\n     pos: uint,\n     len: uint\n@@ -344,16 +152,16 @@ impl intern_key : to_bytes::IterBytes {\n     }\n }\n \n-enum ast_ty_to_ty_cache_entry {\n+pub enum ast_ty_to_ty_cache_entry {\n     atttce_unresolved,  /* not resolved yet */\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-type opt_region_variance = Option<region_variance>;\n+pub type opt_region_variance = Option<region_variance>;\n \n #[auto_encode]\n #[auto_decode]\n-enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n+pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n     pure fn eq(&self, other: &region_variance) -> bool {\n@@ -386,7 +194,7 @@ pub struct AutoRef {\n \n #[auto_encode]\n #[auto_decode]\n-enum AutoRefKind {\n+pub enum AutoRefKind {\n     /// Convert from T to &T\n     AutoPtr,\n \n@@ -406,26 +214,26 @@ enum AutoRefKind {\n // This is a map from ID of each implementation to the method info and trait\n // method ID of each of the default methods belonging to the trait that that\n // implementation implements.\n-type ProvidedMethodsMap = HashMap<def_id,@DVec<@ProvidedMethodInfo>>;\n+pub type ProvidedMethodsMap = HashMap<def_id,@DVec<@ProvidedMethodInfo>>;\n \n // Stores the method info and definition ID of the associated trait method for\n // each instantiation of each provided method.\n-struct ProvidedMethodInfo {\n+pub struct ProvidedMethodInfo {\n     method_info: @MethodInfo,\n     trait_method_def_id: def_id\n }\n \n-struct ProvidedMethodSource {\n+pub struct ProvidedMethodSource {\n     method_id: ast::def_id,\n     impl_id: ast::def_id\n }\n \n-struct InstantiatedTraitRef {\n+pub struct InstantiatedTraitRef {\n     def_id: ast::def_id,\n     tpt: ty_param_substs_and_ty\n }\n \n-type ctxt =\n+pub type ctxt =\n     @{diag: syntax::diagnostic::span_handler,\n       interner: HashMap<intern_key, t_box>,\n       mut next_id: uint,\n@@ -515,9 +323,9 @@ type t_box = @{sty: sty,\n // ~15%.) This does mean that a t value relies on the ctxt to keep its box\n // alive, and using ty::get is unsafe when the ctxt is no longer alive.\n enum t_opaque {}\n-type t = *t_opaque;\n+pub type t = *t_opaque;\n \n-pure fn get(t: t) -> t_box {\n+pub pure fn get(t: t) -> t_box {\n     unsafe {\n         let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n         let t3 = t2;\n@@ -526,16 +334,22 @@ pure fn get(t: t) -> t_box {\n     }\n }\n \n-pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n+pub pure fn tbox_has_flag(tb: t_box, flag: tbox_flag) -> bool {\n     (tb.flags & (flag as uint)) != 0u\n }\n-pure fn type_has_params(t: t) -> bool { tbox_has_flag(get(t), has_params) }\n-pure fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n-pure fn type_needs_infer(t: t) -> bool { tbox_has_flag(get(t), needs_infer) }\n-pure fn type_has_regions(t: t) -> bool { tbox_has_flag(get(t), has_regions) }\n-pure fn type_contains_err(t: t) -> bool { tbox_has_flag(get(t), has_ty_err) }\n-pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n-pure fn type_id(t: t) -> uint { get(t).id }\n+pub pure fn type_has_params(t: t) -> bool { tbox_has_flag(get(t), has_params) }\n+pub pure fn type_has_self(t: t) -> bool { tbox_has_flag(get(t), has_self) }\n+pub pure fn type_needs_infer(t: t) -> bool {\n+    tbox_has_flag(get(t), needs_infer)\n+}\n+pub pure fn type_has_regions(t: t) -> bool {\n+    tbox_has_flag(get(t), has_regions)\n+}\n+pub pure fn type_contains_err(t: t) -> bool {\n+    tbox_has_flag(get(t), has_ty_err)\n+}\n+pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n+pub pure fn type_id(t: t) -> uint { get(t).id }\n \n /**\n  * Meta information about a closure.\n@@ -547,7 +361,7 @@ pure fn type_id(t: t) -> uint { get(t).id }\n  * - `region` is the region bound on the function's upvars (often &static).\n  * - `bounds` is the parameter bounds on the function's upvars. */\n #[deriving_eq]\n-struct FnMeta {\n+pub struct FnMeta {\n     purity: ast::purity,\n     proto: ast::Proto,\n     onceness: ast::Onceness,\n@@ -562,7 +376,7 @@ struct FnMeta {\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type. */\n #[deriving_eq]\n-struct FnSig {\n+pub struct FnSig {\n     inputs: ~[arg],\n     output: t\n }\n@@ -573,7 +387,7 @@ struct FnSig {\n  * by the meta information because, in some cases, the\n  * meta information is inferred. */\n #[deriving_eq]\n-struct FnTyBase<M> {\n+pub struct FnTyBase<M> {\n     meta: M,        // Either FnMeta or FnVid\n     sig: FnSig      // Types of arguments/return type\n }\n@@ -584,10 +398,10 @@ impl<M: to_bytes::IterBytes> FnTyBase<M> : to_bytes::IterBytes {\n     }\n }\n \n-type FnTy = FnTyBase<FnMeta>;\n+pub type FnTy = FnTyBase<FnMeta>;\n \n #[deriving_eq]\n-struct param_ty {\n+pub struct param_ty {\n     idx: uint,\n     def_id: def_id\n }\n@@ -602,7 +416,7 @@ impl param_ty : to_bytes::IterBytes {\n /// Representation of regions:\n #[auto_encode]\n #[auto_decode]\n-enum Region {\n+pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n     /// (analogous to type parameters, except that due to the monomorphic\n@@ -631,7 +445,7 @@ enum Region {\n \n #[auto_encode]\n #[auto_decode]\n-enum bound_region {\n+pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &self/T)\n     br_self,\n \n@@ -676,15 +490,15 @@ type opt_region = Option<Region>;\n  *   `self` type is rather funny in that it can only appear on traits and is\n  *   always substituted away to the implementing type for a trait. */\n #[deriving_eq]\n-struct substs {\n+pub struct substs {\n     self_r: opt_region,\n     self_ty: Option<ty::t>,\n     tps: ~[t]\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-enum sty {\n+pub enum sty {\n     ty_nil,\n     ty_bot,\n     ty_bool,\n@@ -720,22 +534,22 @@ enum sty {\n }\n \n #[deriving_eq]\n-enum IntVarValue {\n+pub enum IntVarValue {\n     IntType(ast::int_ty),\n     UintType(ast::uint_ty),\n }\n \n-enum terr_vstore_kind {\n+pub enum terr_vstore_kind {\n     terr_vec, terr_str, terr_fn, terr_trait\n }\n \n-struct expected_found<T> {\n+pub struct expected_found<T> {\n     expected: T,\n     found: T\n }\n \n // Data structures used in type unification\n-enum type_err {\n+pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n@@ -766,7 +580,7 @@ enum type_err {\n     terr_float_mismatch(expected_found<ast::float_ty>)\n }\n \n-enum param_bound {\n+pub enum param_bound {\n     bound_copy,\n     bound_durable,\n     bound_owned,\n@@ -775,21 +589,21 @@ enum param_bound {\n }\n \n #[deriving_eq]\n-enum TyVid = uint;\n+pub enum TyVid = uint;\n \n #[deriving_eq]\n-enum IntVid = uint;\n+pub enum IntVid = uint;\n \n #[deriving_eq]\n-enum FloatVid = uint;\n+pub enum FloatVid = uint;\n \n #[deriving_eq]\n #[auto_encode]\n #[auto_decode]\n-enum RegionVid = uint;\n+pub enum RegionVid = uint;\n \n #[deriving_eq]\n-enum InferTy {\n+pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid)\n@@ -807,7 +621,7 @@ impl InferTy : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n-enum InferRegion {\n+pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(uint, bound_region)\n }\n@@ -851,50 +665,50 @@ impl param_bound : to_bytes::IterBytes {\n     }\n }\n \n-trait Vid {\n+pub trait Vid {\n     pure fn to_uint() -> uint;\n }\n \n-impl TyVid: Vid {\n+pub impl TyVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n-impl TyVid: ToStr {\n+pub impl TyVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n-impl IntVid: Vid {\n+pub impl IntVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n-impl IntVid: ToStr {\n+pub impl IntVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n-impl FloatVid: Vid {\n+pub impl FloatVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n-impl FloatVid: ToStr {\n+pub impl FloatVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n-impl RegionVid: Vid {\n+pub impl RegionVid: Vid {\n     pure fn to_uint() -> uint { *self }\n }\n \n-impl RegionVid: ToStr {\n+pub impl RegionVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n }\n \n-impl FnSig : ToStr {\n+pub impl FnSig : ToStr {\n     pure fn to_str() -> ~str {\n         // grr, without tcx not much we can do.\n         return ~\"(...)\";\n     }\n }\n \n-impl InferTy: ToStr {\n+pub impl InferTy: ToStr {\n     pure fn to_str() -> ~str {\n         match self {\n             TyVar(ref v) => v.to_str(),\n@@ -904,7 +718,7 @@ impl InferTy: ToStr {\n     }\n }\n \n-impl IntVarValue : ToStr {\n+pub impl IntVarValue : ToStr {\n     pure fn to_str() -> ~str {\n         match self {\n             IntType(ref v) => v.to_str(),\n@@ -913,31 +727,31 @@ impl IntVarValue : ToStr {\n     }\n }\n \n-impl TyVid : to_bytes::IterBytes {\n+pub impl TyVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-impl IntVid : to_bytes::IterBytes {\n+pub impl IntVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-impl FloatVid : to_bytes::IterBytes {\n+pub impl FloatVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-impl RegionVid : to_bytes::IterBytes {\n+pub impl RegionVid : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         self.to_uint().iter_bytes(lsb0, f)\n     }\n }\n \n-fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n+pub fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n         match *bound {\n@@ -969,35 +783,36 @@ fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n ///\n /// - `ty`: the base type.  May have reference to the (unsubstituted) bound\n ///   region `&self` or to (unsubstituted) ty_param types\n-type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n-                               region_param: Option<region_variance>,\n-                               ty: t};\n+pub type ty_param_bounds_and_ty = {bounds: @~[param_bounds],\n+                                   region_param: Option<region_variance>,\n+                                   ty: t};\n \n-type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n+pub type ty_param_substs_and_ty = {substs: ty::substs, ty: ty::t};\n \n type type_cache = HashMap<ast::def_id, ty_param_bounds_and_ty>;\n \n type constness_cache = HashMap<ast::def_id, const_eval::constness>;\n \n-type node_type_table = @smallintmap::SmallIntMap<t>;\n+pub type node_type_table = @smallintmap::SmallIntMap<t>;\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n     return map::HashMap();\n }\n \n-fn new_ty_hash<V: Copy>() -> map::HashMap<t, V> {\n+pub fn new_ty_hash<V: Copy>() -> map::HashMap<t, V> {\n     map::HashMap()\n }\n \n-fn mk_ctxt(s: session::Session,\n-           dm: resolve::DefMap,\n-           amap: ast_map::map,\n-           freevars: freevars::freevar_map,\n-           region_map: middle::region::region_map,\n-           region_paramd_items: middle::region::region_paramd_items,\n-           +lang_items: middle::lang_items::LanguageItems,\n-           crate: @ast::crate) -> ctxt {\n+pub fn mk_ctxt(s: session::Session,\n+               dm: resolve::DefMap,\n+               amap: ast_map::map,\n+               freevars: freevars::freevar_map,\n+               region_map: middle::region::region_map,\n+               region_paramd_items: middle::region::region_paramd_items,\n+               +lang_items: middle::lang_items::LanguageItems,\n+               crate: @ast::crate)\n+            -> ctxt {\n     let mut legacy_modes = false;\n     let mut legacy_records = false;\n     for crate.node.attrs.each |attribute| {\n@@ -1133,149 +948,151 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     unsafe { cast::reinterpret_cast(&t) }\n }\n \n-fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n+pub fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n \n-fn mk_err(cx: ctxt) -> t { mk_t(cx, ty_err) }\n+pub fn mk_err(cx: ctxt) -> t { mk_t(cx, ty_err) }\n \n-fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n+pub fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n \n-fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n+pub fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n \n-fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n+pub fn mk_int(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i)) }\n \n-fn mk_i8(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i8)) }\n+pub fn mk_i8(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i8)) }\n \n-fn mk_i16(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i16)) }\n+pub fn mk_i16(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i16)) }\n \n-fn mk_i32(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i32)) }\n+pub fn mk_i32(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i32)) }\n \n-fn mk_i64(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i64)) }\n+pub fn mk_i64(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_i64)) }\n \n-fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n+pub fn mk_float(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f)) }\n \n-fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n+pub fn mk_uint(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u)) }\n \n-fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n+pub fn mk_u8(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u8)) }\n \n-fn mk_u16(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u16)) }\n+pub fn mk_u16(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u16)) }\n \n-fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n+pub fn mk_u32(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u32)) }\n \n-fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n+pub fn mk_u64(cx: ctxt) -> t { mk_t(cx, ty_uint(ast::ty_u64)) }\n \n-fn mk_f32(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f32)) }\n+pub fn mk_f32(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f32)) }\n \n-fn mk_f64(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f64)) }\n+pub fn mk_f64(cx: ctxt) -> t { mk_t(cx, ty_float(ast::ty_f64)) }\n \n-fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n+pub fn mk_mach_int(cx: ctxt, tm: ast::int_ty) -> t { mk_t(cx, ty_int(tm)) }\n \n-fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n+pub fn mk_mach_uint(cx: ctxt, tm: ast::uint_ty) -> t { mk_t(cx, ty_uint(tm)) }\n \n-fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t { mk_t(cx, ty_float(tm)) }\n+pub fn mk_mach_float(cx: ctxt, tm: ast::float_ty) -> t {\n+    mk_t(cx, ty_float(tm))\n+}\n \n-fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n+pub fn mk_char(cx: ctxt) -> t { mk_t(cx, ty_int(ast::ty_char)) }\n \n-fn mk_estr(cx: ctxt, t: vstore) -> t {\n+pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n     mk_t(cx, ty_estr(t))\n }\n \n-fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n+pub fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n+pub fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n-fn mk_imm_box(cx: ctxt, ty: t) -> t {\n+pub fn mk_imm_box(cx: ctxt, ty: t) -> t {\n     mk_box(cx, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n+pub fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n-fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n+pub fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n     mk_uniq(cx, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n+pub fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n-fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_mutbl})\n }\n-fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::m_mutbl})\n }\n \n-fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_nil_ptr(cx: ctxt) -> t {\n+pub fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::m_imm})\n }\n \n-fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n+pub fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_evec(tm, t))\n }\n \n-fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n+pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n-fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n-fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n+pub fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n-fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n // take a copy because we want to own the various vectors inside\n-fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n+pub fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n \n-fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n+pub fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n          -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_trait(did, substs, vstore))\n }\n \n-fn mk_struct(cx: ctxt, struct_id: ast::def_id, +substs: substs) -> t {\n+pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, +substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n+pub fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n-fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n+pub fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n-fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n+pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n+pub fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n-fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n+pub fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n     mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n }\n \n-fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n+pub fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n+pub fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n     mk_t(cx, ty_opaque_closure_ptr(proto))\n }\n \n-fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n+pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n \n-fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n+pub fn mk_with_id(cx: ctxt, base: t, def_id: ast::def_id) -> t {\n     mk_t_with_id(cx, /*bad*/copy get(base).sty, Some(def_id))\n }\n \n // Converts s to its machine type equivalent\n-pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n+pub pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n     match get(t).sty {\n       ty_int(ast::ty_i) => ty_int(cfg.int_type),\n       ty_uint(ast::ty_u) => ty_uint(cfg.uint_type),\n@@ -1284,7 +1101,7 @@ pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n     }\n }\n \n-fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n+pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         // FIXME(#2202) --- We retain by-ref for fn& things to workaround a\n         // memory leak that otherwise results when @fn is upcast to &fn.\n     if type_is_fn(ty) {\n@@ -1331,18 +1148,18 @@ fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n \n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n-fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n+pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n     match cx.region_map.find(id) {\n       Some(encl_scope) => ty::re_scope(encl_scope),\n       None => ty::re_static\n     }\n }\n \n-fn walk_ty(ty: t, f: fn(t)) {\n+pub fn walk_ty(ty: t, f: fn(t)) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n \n-fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n+pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     if !f(ty) { return; }\n     match /*bad*/copy get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n@@ -1369,11 +1186,11 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     }\n }\n \n-fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n+pub fn fold_sty_to_ty(tcx: ty::ctxt, sty: &sty, foldop: fn(t) -> t) -> t {\n     mk_t(tcx, fold_sty(sty, foldop))\n }\n \n-fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n+pub fn fold_sig(sig: &FnSig, fldop: fn(t) -> t) -> FnSig {\n     let args = do sig.inputs.map |arg| {\n         arg { mode: arg.mode, ty: fldop(arg.ty) }\n     };\n@@ -1444,12 +1261,12 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n }\n \n // Folds types from the bottom up.\n-fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n+pub fn fold_ty(cx: ctxt, t0: t, fldop: fn(t) -> t) -> t {\n     let sty = fold_sty(&get(t0).sty, |t| fold_ty(cx, fldop(t), fldop));\n     fldop(mk_t(cx, sty))\n }\n \n-fn walk_regions_and_ty(\n+pub fn walk_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n     walkr: fn(r: Region),\n@@ -1464,7 +1281,7 @@ fn walk_regions_and_ty(\n     }\n }\n \n-fn fold_regions_and_ty(\n+pub fn fold_regions_and_ty(\n     cx: ctxt,\n     ty: t,\n     fldr: fn(r: Region) -> Region,\n@@ -1526,7 +1343,7 @@ fn fold_regions_and_ty(\n  * inefficient to do the conversion), it would be better to refactor\n  * all this folding business.  However, I've been waiting on that\n  * until trait support is improved. */\n-fn apply_op_on_t_to_ty_fn(\n+pub fn apply_op_on_t_to_ty_fn(\n     cx: ctxt,\n     f: &FnTy,\n     t_op: fn(t) -> t) -> FnTy\n@@ -1545,11 +1362,10 @@ fn apply_op_on_t_to_ty_fn(\n \n // n.b. this function is intended to eventually replace fold_region() below,\n // that is why its name is so similar.\n-fn fold_regions(\n+pub fn fold_regions(\n     cx: ctxt,\n     ty: t,\n-    fldr: fn(r: Region, in_fn: bool) -> Region) -> t\n-{\n+    fldr: fn(r: Region, in_fn: bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: fn(Region, bool) -> Region) -> t {\n         debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n@@ -1563,7 +1379,7 @@ fn fold_regions(\n     do_fold(cx, ty, false, fldr)\n }\n \n-fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n+pub fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n     fn do_fold(cx: ctxt, t0: t, under_r: bool,\n                fldop: fn(Region, bool) -> Region) -> t {\n         let tb = get(t0);\n@@ -1599,7 +1415,7 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n }\n \n // Substitute *only* type parameters.  Used in trans where regions are erased.\n-fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n     let tb = ty::get(typ);\n     if self_ty_opt.is_none() && !tbox_has_flag(tb, has_params) { return typ; }\n@@ -1619,21 +1435,21 @@ fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     }\n }\n \n-fn substs_is_noop(substs: &substs) -> bool {\n+pub fn substs_is_noop(substs: &substs) -> bool {\n     substs.tps.len() == 0u &&\n         substs.self_r.is_none() &&\n         substs.self_ty.is_none()\n }\n \n-fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n+pub fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n     fmt!(\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(~\"none\", |r| region_to_str(cx, *r)),\n          substs.self_ty.map_default(~\"none\",\n                                     |t| ::util::ppaux::ty_to_str(cx, *t)),\n          tys_to_str(cx, substs.tps))\n }\n \n-fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n+pub fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n     match *pb {\n         bound_copy => ~\"copy\",\n         bound_durable => ~\"&static\",\n@@ -1643,14 +1459,14 @@ fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n     }\n }\n \n-fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n+pub fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n     fmt!(\"%?\", pbs.map(|pb| param_bound_to_str(cx, pb)))\n }\n \n-fn subst(cx: ctxt,\n-         substs: &substs,\n-         typ: t) -> t {\n-\n+pub fn subst(cx: ctxt,\n+             substs: &substs,\n+             typ: t)\n+          -> t {\n     debug!(\"subst(substs=%s, typ=%s)\",\n            substs_to_str(cx, substs),\n            ::util::ppaux::ty_to_str(cx, typ));\n@@ -1695,7 +1511,7 @@ fn subst(cx: ctxt,\n \n // Performs substitutions on a set of substitutions (result = sup(sub)) to\n // yield a new set of substitutions. This is used in trait inheritance.\n-fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n+pub fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n     substs {\n         self_r: sup.self_r,\n         self_ty: sup.self_ty.map(|typ| subst(cx, sub, *typ)),\n@@ -1705,20 +1521,20 @@ fn subst_substs(cx: ctxt, sup: &substs, sub: &substs) -> substs {\n \n // Type utilities\n \n-fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n+pub fn type_is_nil(ty: t) -> bool { get(ty).sty == ty_nil }\n \n-fn type_is_bot(ty: t) -> bool { get(ty).sty == ty_bot }\n+pub fn type_is_bot(ty: t) -> bool { get(ty).sty == ty_bot }\n \n-fn type_is_ty_var(ty: t) -> bool {\n+pub fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(TyVar(_)) => true,\n       _ => false\n     }\n }\n \n-fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n+pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n-fn type_is_structural(ty: t) -> bool {\n+pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n       ty_trait(*) |\n@@ -1729,25 +1545,25 @@ fn type_is_structural(ty: t) -> bool {\n     }\n }\n \n-fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n     return kind_can_be_copied(type_kind(cx, ty));\n }\n \n-fn type_is_sequence(ty: t) -> bool {\n+pub fn type_is_sequence(ty: t) -> bool {\n     match get(ty).sty {\n       ty_estr(_) | ty_evec(_, _) => true,\n       _ => false\n     }\n }\n \n-fn type_is_str(ty: t) -> bool {\n+pub fn type_is_str(ty: t) -> bool {\n     match get(ty).sty {\n       ty_estr(_) => true,\n       _ => false\n     }\n }\n \n-fn sequence_element_type(cx: ctxt, ty: t) -> t {\n+pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_estr(_) => return mk_mach_uint(cx, ast::ty_u8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n@@ -1756,66 +1572,66 @@ fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     }\n }\n \n-fn get_element_type(ty: t, i: uint) -> t {\n+pub fn get_element_type(ty: t, i: uint) -> t {\n     match /*bad*/copy get(ty).sty {\n       ty_rec(flds) => return flds[i].mt.ty,\n       ty_tup(ts) => return ts[i],\n       _ => fail ~\"get_element_type called on invalid type\"\n     }\n }\n \n-pure fn type_is_box(ty: t) -> bool {\n+pub pure fn type_is_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) => return true,\n       _ => return false\n     }\n }\n \n-pure fn type_is_boxed(ty: t) -> bool {\n+pub pure fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_box(_) | ty_opaque_box |\n       ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n       _ => false\n     }\n }\n \n-pure fn type_is_region_ptr(ty: t) -> bool {\n+pub pure fn type_is_region_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_rptr(_, _) => true,\n       _ => false\n     }\n }\n \n-pure fn type_is_slice(ty: t) -> bool {\n+pub pure fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n \n-pure fn type_is_unique_box(ty: t) -> bool {\n+pub pure fn type_is_unique_box(ty: t) -> bool {\n     match get(ty).sty {\n       ty_uniq(_) => return true,\n       _ => return false\n     }\n }\n \n-pure fn type_is_unsafe_ptr(ty: t) -> bool {\n+pub pure fn type_is_unsafe_ptr(ty: t) -> bool {\n     match get(ty).sty {\n       ty_ptr(_) => return true,\n       _ => return false\n     }\n }\n \n-pure fn type_is_vec(ty: t) -> bool {\n+pub pure fn type_is_vec(ty: t) -> bool {\n     return match get(ty).sty {\n           ty_evec(_, _) | ty_unboxed_vec(_) => true,\n           ty_estr(_) => true,\n           _ => false\n         };\n }\n \n-pure fn type_is_unique(ty: t) -> bool {\n+pub pure fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n       ty_uniq(_) => return true,\n       ty_evec(_, vstore_uniq) => true,\n@@ -1829,7 +1645,7 @@ pure fn type_is_unique(ty: t) -> bool {\n  (A ty_ptr is scalar because it represents a non-managed pointer, so its\n  contents are abstract to rustc.)\n */\n-pure fn type_is_scalar(ty: t) -> bool {\n+pub pure fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n@@ -1838,12 +1654,12 @@ pure fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-fn type_is_immediate(ty: t) -> bool {\n+pub fn type_is_immediate(ty: t) -> bool {\n     return type_is_scalar(ty) || type_is_boxed(ty) ||\n         type_is_unique(ty) || type_is_region_ptr(ty);\n }\n \n-fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     match cx.needs_drop_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n@@ -1922,7 +1738,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n     match cx.needs_unwind_cleanup_cache.find(ty) {\n       Some(result) => return result,\n       None => ()\n@@ -1998,7 +1814,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     return needs_unwind_cleanup;\n }\n \n-enum Kind { kind_(u32) }\n+pub enum Kind { kind_(u32) }\n \n /// can be copied (implicitly or explicitly)\n const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n@@ -2018,15 +1834,15 @@ const KIND_MASK_IMPLICIT     : u32 = 0b000000000000000000000010000_u32;\n /// safe for default mode (subset of KIND_MASK_IMPLICIT)\n const KIND_MASK_DEFAULT_MODE : u32 = 0b000000000000000000000100000_u32;\n \n-fn kind_noncopyable() -> Kind {\n+pub fn kind_noncopyable() -> Kind {\n     kind_(0u32)\n }\n \n-fn kind_copyable() -> Kind {\n+pub fn kind_copyable() -> Kind {\n     kind_(KIND_MASK_COPY)\n }\n \n-fn kind_implicitly_copyable() -> Kind {\n+pub fn kind_implicitly_copyable() -> Kind {\n     kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n }\n \n@@ -2054,7 +1870,7 @@ fn kind_owned_only() -> Kind {\n     kind_(KIND_MASK_OWNED)\n }\n \n-fn kind_const() -> Kind {\n+pub fn kind_const() -> Kind {\n     kind_(KIND_MASK_CONST)\n }\n \n@@ -2113,27 +1929,27 @@ impl Kind : ops::Sub<Kind,Kind> {\n // Using these query functions is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n-pure fn kind_can_be_implicitly_copied(k: Kind) -> bool {\n+pub pure fn kind_can_be_implicitly_copied(k: Kind) -> bool {\n     *k & KIND_MASK_IMPLICIT == KIND_MASK_IMPLICIT\n }\n \n-pure fn kind_is_safe_for_default_mode(k: Kind) -> bool {\n+pub pure fn kind_is_safe_for_default_mode(k: Kind) -> bool {\n     *k & KIND_MASK_DEFAULT_MODE == KIND_MASK_DEFAULT_MODE\n }\n \n-pure fn kind_can_be_copied(k: Kind) -> bool {\n+pub pure fn kind_can_be_copied(k: Kind) -> bool {\n     *k & KIND_MASK_COPY == KIND_MASK_COPY\n }\n \n-pure fn kind_can_be_sent(k: Kind) -> bool {\n+pub pure fn kind_can_be_sent(k: Kind) -> bool {\n     *k & KIND_MASK_OWNED == KIND_MASK_OWNED\n }\n \n-pure fn kind_is_durable(k: Kind) -> bool {\n+pub pure fn kind_is_durable(k: Kind) -> bool {\n     *k & KIND_MASK_DURABLE == KIND_MASK_DURABLE\n }\n \n-fn meta_kind(p: FnMeta) -> Kind {\n+pub fn meta_kind(p: FnMeta) -> Kind {\n     match p.proto { // XXX consider the kind bounds!\n         ast::ProtoBare => {\n             kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n@@ -2150,7 +1966,7 @@ fn meta_kind(p: FnMeta) -> Kind {\n     }\n }\n \n-fn kind_lteq(a: Kind, b: Kind) -> bool {\n+pub fn kind_lteq(a: Kind, b: Kind) -> bool {\n     *a & *b == *a\n }\n \n@@ -2195,13 +2011,13 @@ fn mutable_type_kind(cx: ctxt, ty: mt) -> Kind {\n     lower_kind(mutability_kind(ty.mutbl), type_kind(cx, ty.ty))\n }\n \n-fn type_kind(cx: ctxt, ty: t) -> Kind {\n+pub fn type_kind(cx: ctxt, ty: t) -> Kind {\n     type_kind_ext(cx, ty, false)\n }\n \n // If `allow_ty_var` is true, then this is a conservative assumption; we\n // assume that type variables *do* have all kinds.\n-fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n+pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     match cx.kind_cache.find(ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n@@ -2381,7 +2197,7 @@ fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     return result;\n }\n \n-fn type_implicitly_moves(cx: ctxt, ty: t) -> bool {\n+pub fn type_implicitly_moves(cx: ctxt, ty: t) -> bool {\n     let kind = type_kind(cx, ty);\n     !(kind_can_be_copied(kind) && kind_can_be_implicitly_copied(kind))\n }\n@@ -2448,8 +2264,7 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n }\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-\n+pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires(%s, %s)?\",\n@@ -2560,8 +2375,10 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n     !subtypes_require(cx, seen, r_ty, r_ty)\n }\n \n-fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n-   bool {\n+pub fn type_structurally_contains(cx: ctxt,\n+                                  ty: t,\n+                                  test: fn(x: &sty) -> bool)\n+                               -> bool {\n     let sty = &get(ty).sty;\n     debug!(\"type_structurally_contains: %s\",\n            ::util::ppaux::ty_to_str(cx, ty));\n@@ -2605,7 +2422,7 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n     }\n }\n \n-fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n+pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     return type_structurally_contains(cx, ty, |sty| {\n         match *sty {\n           ty_uniq(_) |\n@@ -2616,32 +2433,32 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     });\n }\n \n-fn type_is_integral(ty: t) -> bool {\n+pub fn type_is_integral(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) | ty_bool => true,\n       _ => false\n     }\n }\n \n-fn type_is_char(ty: t) -> bool {\n+pub fn type_is_char(ty: t) -> bool {\n     match get(ty).sty {\n         ty_int(ty_char) => true,\n         _ => false\n     }\n }\n \n-fn type_is_fp(ty: t) -> bool {\n+pub fn type_is_fp(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(FloatVar(_)) | ty_float(_) => true,\n       _ => false\n     }\n }\n \n-fn type_is_numeric(ty: t) -> bool {\n+pub fn type_is_numeric(ty: t) -> bool {\n     return type_is_integral(ty) || type_is_fp(ty);\n }\n \n-fn type_is_signed(ty: t) -> bool {\n+pub fn type_is_signed(ty: t) -> bool {\n     match get(ty).sty {\n       ty_int(_) => true,\n       _ => false\n@@ -2650,7 +2467,7 @@ fn type_is_signed(ty: t) -> bool {\n \n // Whether a type is Plain Old Data -- meaning it does not contain pointers\n // that the cycle collector might care about.\n-fn type_is_pod(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let mut result = true;\n     match /*bad*/copy get(ty).sty {\n       // Scalar types\n@@ -2706,7 +2523,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     return result;\n }\n \n-fn type_is_enum(ty: t) -> bool {\n+pub fn type_is_enum(ty: t) -> bool {\n     match get(ty).sty {\n       ty_enum(_, _) => return true,\n       _ => return false\n@@ -2715,7 +2532,7 @@ fn type_is_enum(ty: t) -> bool {\n \n // Whether a type is enum like, that is a enum type with only nullary\n // constructors\n-fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     match get(ty).sty {\n       ty_enum(did, _) => {\n         let variants = enum_variants(cx, did);\n@@ -2726,7 +2543,7 @@ fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_param(ty: t) -> Option<uint> {\n+pub fn type_param(ty: t) -> Option<uint> {\n     match get(ty).sty {\n       ty_param(p) => return Some(p.idx),\n       _ => {/* fall through */ }\n@@ -2738,11 +2555,11 @@ fn type_param(ty: t) -> Option<uint> {\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n+pub fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n     deref_sty(cx, &get(t).sty, explicit)\n }\n \n-fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n+pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n       ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n         Some(mt)\n@@ -2776,7 +2593,7 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n     }\n }\n \n-fn type_autoderef(cx: ctxt, t: t) -> t {\n+pub fn type_autoderef(cx: ctxt, t: t) -> t {\n     let mut t = t;\n     loop {\n         match deref(cx, t, false) {\n@@ -2787,11 +2604,11 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n }\n \n // Returns the type and mutability of t[i]\n-fn index(cx: ctxt, t: t) -> Option<mt> {\n+pub fn index(cx: ctxt, t: t) -> Option<mt> {\n     index_sty(cx, &get(t).sty)\n }\n \n-fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n+pub fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     match *sty {\n       ty_evec(mt, _) => Some(mt),\n       ty_estr(_) => Some(mt {ty: mk_u8(cx), mutbl: ast::m_imm}),\n@@ -2977,11 +2794,11 @@ impl sty : to_bytes::IterBytes {\n     }\n }\n \n-fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n+pub fn br_hashmap<V:Copy>() -> HashMap<bound_region, V> {\n     map::HashMap()\n }\n \n-fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n+pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     //io::println(fmt!(\"%?/%?\", id, cx.node_types.size()));\n     match smallintmap::find(*cx.node_types, id as uint) {\n        Some(t) => t,\n@@ -2992,7 +2809,7 @@ fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     }\n }\n \n-fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n+pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n     match cx.node_type_substs.find(id) {\n       None => return ~[],\n       Some(ts) => return ts\n@@ -3004,28 +2821,28 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n }\n \n // Type accessors for substructures of types\n-fn ty_fn_args(fty: t) -> ~[arg] {\n+pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n       ty_fn(ref f) => /*bad*/copy f.sig.inputs,\n       _ => fail ~\"ty_fn_args() called on non-fn type\"\n     }\n }\n \n-fn ty_fn_proto(fty: t) -> Proto {\n+pub fn ty_fn_proto(fty: t) -> Proto {\n     match get(fty).sty {\n       ty_fn(ref f) => f.meta.proto,\n       _ => fail ~\"ty_fn_proto() called on non-fn type\"\n     }\n }\n \n-fn ty_fn_purity(fty: t) -> ast::purity {\n+pub fn ty_fn_purity(fty: t) -> ast::purity {\n     match get(fty).sty {\n       ty_fn(ref f) => f.meta.purity,\n       _ => fail ~\"ty_fn_purity() called on non-fn type\"\n     }\n }\n \n-pure fn ty_fn_ret(fty: t) -> t {\n+pub pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n         ty_fn(ref f) => f.sig.output,\n         _ => fail ~\"ty_fn_ret() called on non-fn type\"\n@@ -3039,15 +2856,15 @@ fn is_fn_ty(fty: t) -> bool {\n     }\n }\n \n-pure fn ty_vstore(ty: t) -> vstore {\n+pub pure fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n         ty_evec(_, vstore) => vstore,\n         ty_estr(vstore) => vstore,\n         ref s => fail fmt!(\"ty_vstore() called on invalid sty: %?\", s)\n     }\n }\n \n-fn ty_region(ty: t) -> Region {\n+pub fn ty_region(ty: t) -> Region {\n     match get(ty).sty {\n       ty_rptr(r, _) => r,\n       ty_evec(_, vstore_slice(r)) => r,\n@@ -3056,7 +2873,7 @@ fn ty_region(ty: t) -> Region {\n     }\n }\n \n-fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+pub fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n      * Returns a new function type based on `fn_type` but returning a value of\n@@ -3078,25 +2895,25 @@ fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n }\n \n // Returns a vec of all the input and output types of fty.\n-fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n+pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n     vec::append_one(sig.inputs.map(|a| a.ty), sig.output)\n }\n \n // Just checks whether it's a fn that returns bool,\n // not its purity.\n-fn is_pred_ty(fty: t) -> bool {\n+pub fn is_pred_ty(fty: t) -> bool {\n     is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n // Type accessors for AST nodes\n-fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n+pub fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n     return node_id_to_type(cx, b.node.id);\n }\n \n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n+pub fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -3107,22 +2924,23 @@ fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n+pub fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(cx: ctxt,\n-                         expr: @ast::expr) -> {params: ~[t], ty: t} {\n+pub fn expr_ty_params_and_ty(cx: ctxt,\n+                             expr: @ast::expr)\n+                          -> {params: ~[t], ty: t} {\n     return {params: node_id_to_type_params(cx, expr.id),\n          ty: node_id_to_type(cx, expr.id)};\n }\n \n-fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n+pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n-                      id: ast::node_id)\n+pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n+                          id: ast::node_id)\n     -> Option<@~[param_bounds]> {\n     do method_map.find(id).map |method| {\n         match method.origin {\n@@ -3160,9 +2978,9 @@ fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n     }\n }\n \n-fn expr_is_lval(tcx: ctxt,\n-                method_map: typeck::method_map,\n-                e: @ast::expr) -> bool {\n+pub fn expr_is_lval(tcx: ctxt,\n+                    method_map: typeck::method_map,\n+                    e: @ast::expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n         LvalueExpr => true,\n         RvalueDpsExpr | RvalueDatumExpr | RvalueStmtExpr => false\n@@ -3174,16 +2992,16 @@ fn expr_is_lval(tcx: ctxt,\n /// two kinds of rvalues is an artifact of trans which reflects how we will\n /// generate code for that kind of expression.  See trans/expr.rs for more\n /// information.\n-enum ExprKind {\n+pub enum ExprKind {\n     LvalueExpr,\n     RvalueDpsExpr,\n     RvalueDatumExpr,\n     RvalueStmtExpr\n }\n \n-fn expr_kind(tcx: ctxt,\n-             method_map: typeck::method_map,\n-             expr: @ast::expr) -> ExprKind {\n+pub fn expr_kind(tcx: ctxt,\n+                 method_map: typeck::method_map,\n+                 expr: @ast::expr) -> ExprKind {\n     if method_map.contains_key(expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n@@ -3307,7 +3125,7 @@ fn expr_kind(tcx: ctxt,\n     }\n }\n \n-fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n+pub fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     match s.node {\n       ast::stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) => {\n         return id;\n@@ -3316,13 +3134,14 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     }\n }\n \n-fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n+pub fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n     for fields.each |f| { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n-fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field]) -> uint {\n+pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n+                     -> uint {\n     let mut i = 0u;\n     for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n@@ -3331,7 +3150,7 @@ fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field]) -> uint {\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n+pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n       Some(f) => f,\n       // Do we only call this when we know the field is legit?\n@@ -3340,15 +3159,15 @@ fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n     }\n }\n \n-fn get_fields(rec_ty:t) -> ~[field] {\n+pub fn get_fields(rec_ty:t) -> ~[field] {\n     match /*bad*/copy get(rec_ty).sty {\n       ty_rec(fields) => fields,\n       // Can we check at the caller?\n       _ => fail ~\"get_fields: not a record type\"\n     }\n }\n \n-fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n+pub fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n     let mut i = 0u;\n     for meths.each |m| { if m.ident == id { return Some(i); } i += 1u; }\n     return None;\n@@ -3357,7 +3176,7 @@ fn method_idx(id: ast::ident, meths: &[method]) -> Option<uint> {\n /// Returns a vector containing the indices of all type parameters that appear\n /// in `ty`.  The vector may contain duplicates.  Probably should be converted\n /// to a bitset or some other representation.\n-fn param_tys_in_type(ty: t) -> ~[param_ty] {\n+pub fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     let mut rslt = ~[];\n     do walk_ty(ty) |ty| {\n         match get(ty).sty {\n@@ -3370,8 +3189,7 @@ fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     rslt\n }\n \n-fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n-\n+pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n     fn vars_in_type(ty: t) -> ~[TyVid] {\n@@ -3422,13 +3240,13 @@ fn canon<T:Copy cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n \n // Maintains a little union-set tree for inferred modes.  `resolve_mode()`\n // returns the current head value for `m0`.\n-fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n+pub fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n     canon(cx.inferred_modes, m0)\n }\n \n // Returns the head value for mode, failing if `m` was a infer(_) that\n // was never inferred.  This should be safe for use after typeck.\n-fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n+pub fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n     match canon_mode(cx, m) {\n       ast::infer(_) => {\n         cx.sess.bug(fmt!(\"mode %? was never resolved\", m));\n@@ -3437,12 +3255,11 @@ fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n     }\n }\n \n-fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n+pub fn arg_mode(cx: ctxt, a: arg) -> ast::rmode { resolved_mode(cx, a.mode) }\n \n // Unifies `m1` and `m2`.  Returns unified value or failure code.\n-fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n-    -> Result<ast::mode, type_err> {\n-\n+pub fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n+               -> Result<ast::mode, type_err> {\n     let m1 = modes.expected;\n     let m2 = modes.found;\n     match (canon_mode(cx, m1), canon_mode(cx, m2)) {\n@@ -3465,7 +3282,7 @@ fn unify_mode(cx: ctxt, modes: expected_found<ast::mode>)\n \n // If `m` was never unified, unifies it with `m_def`.  Returns the final value\n // for `m`.\n-fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n+pub fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n     match canon_mode(cx, m) {\n       ast::infer(id) => {\n         cx.inferred_modes.insert(id, ast::expl(m_def));\n@@ -3474,7 +3291,7 @@ fn set_default_mode(cx: ctxt, m: ast::mode, m_def: ast::rmode) {\n     }\n }\n \n-fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n+pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) |\n       ty_uint(_) | ty_float(_) | ty_estr(_) |\n@@ -3503,7 +3320,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     }\n }\n \n-fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n+pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -3625,7 +3442,7 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     }\n }\n \n-fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n+pub fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n     match *err {\n         terr_regions_does_not_outlive(subregion, superregion) => {\n             note_and_explain_region(cx, ~\"\", subregion, ~\"...\");\n@@ -3656,19 +3473,19 @@ fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n     }\n }\n \n-fn def_has_ty_params(def: ast::def) -> bool {\n+pub fn def_has_ty_params(def: ast::def) -> bool {\n     match def {\n       ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_struct(_)\n         => true,\n       _ => false\n     }\n }\n \n-fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n+pub fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n     cx.trait_method_cache.insert(ast_util::local_def(id), ms);\n }\n \n-fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n+pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n         match cx.items.find(id.node) {\n             Some(ast_map::node_item(@ast::item {\n@@ -3686,7 +3503,9 @@ fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     }\n }\n \n-fn trait_supertraits(cx: ctxt, id: ast::def_id) -> @~[InstantiatedTraitRef] {\n+pub fn trait_supertraits(cx: ctxt,\n+                         id: ast::def_id)\n+                      -> @~[InstantiatedTraitRef] {\n     // Check the cache.\n     match cx.supertraits.find(id) {\n         Some(instantiated_trait_info) => { return instantiated_trait_info; }\n@@ -3716,7 +3535,7 @@ fn trait_supertraits(cx: ctxt, id: ast::def_id) -> @~[InstantiatedTraitRef] {\n     return @dvec::unwrap(move result);\n }\n \n-fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n+pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     match cx.trait_method_cache.find(id) {\n       // Local traits are supposed to have been added explicitly.\n       Some(ms) => ms,\n@@ -3738,7 +3557,7 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n /*\n   Could this return a list of (def_id, substs) pairs?\n  */\n-fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n+pub fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n     fn vstoreify(cx: ctxt, ty: t, vstore: vstore) -> t {\n         match ty::get(ty).sty {\n             ty::ty_trait(_, _, trait_vstore) if vstore == trait_vstore => ty,\n@@ -3771,7 +3590,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n     }\n }\n \n-fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n+pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     match get(ty).sty {\n       ty_trait(id, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n@@ -3802,7 +3621,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n }\n \n // Enum information\n-struct VariantInfo_ {\n+pub struct VariantInfo_ {\n     args: ~[t],\n     ctor_ty: t,\n     name: ast::ident,\n@@ -3811,11 +3630,12 @@ struct VariantInfo_ {\n     vis: visibility\n }\n \n-type VariantInfo = @VariantInfo_;\n+pub type VariantInfo = @VariantInfo_;\n \n-fn substd_enum_variants(cx: ctxt,\n-                        id: ast::def_id,\n-                        substs: &substs) -> ~[VariantInfo] {\n+pub fn substd_enum_variants(cx: ctxt,\n+                            id: ast::def_id,\n+                            substs: &substs)\n+                         -> ~[VariantInfo] {\n     do vec::map(*enum_variants(cx, id)) |variant_info| {\n         let substd_args = vec::map(variant_info.args,\n                                    |aty| subst(cx, substs, *aty));\n@@ -3827,11 +3647,11 @@ fn substd_enum_variants(cx: ctxt,\n     }\n }\n \n-fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n+pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n     ast_map::path_to_str(item_path(cx, id), cx.sess.parse_sess.interner)\n }\n \n-enum DtorKind {\n+pub enum DtorKind {\n     NoDtor,\n     LegacyDtor(def_id),\n     TraitDtor(def_id)\n@@ -3851,7 +3671,7 @@ impl DtorKind {\n \n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n-fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n+pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     match cx.destructor_for_type.find(struct_id) {\n         Some(method_def_id) => return TraitDtor(method_def_id),\n         None => {}  // Continue.\n@@ -3878,11 +3698,11 @@ fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n     }\n }\n \n-fn has_dtor(cx: ctxt, struct_id: def_id) -> bool {\n+pub fn has_dtor(cx: ctxt, struct_id: def_id) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n+pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     if id.crate != ast::local_crate {\n         csearch::get_item_path(cx, id)\n     } else {\n@@ -3938,18 +3758,18 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     }\n }\n \n-fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n+pub fn enum_is_univariant(cx: ctxt, id: ast::def_id) -> bool {\n     enum_variants(cx, id).len() == 1\n }\n \n-fn type_is_empty(cx: ctxt, t: t) -> bool {\n+pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n     match ty::get(t).sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n }\n \n-fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n+pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n     match cx.enum_var_cache.find(id) {\n       Some(variants) => return variants,\n       _ => { /* fallthrough */ }\n@@ -4017,8 +3837,10 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n \n \n // Returns information about the enum variant with the given ID:\n-fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n-                        variant_id: ast::def_id) -> VariantInfo {\n+pub fn enum_variant_with_id(cx: ctxt,\n+                            enum_id: ast::def_id,\n+                            variant_id: ast::def_id)\n+                         -> VariantInfo {\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n     while i < variants.len() {\n@@ -4032,7 +3854,9 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n+pub fn lookup_item_type(cx: ctxt,\n+                        did: ast::def_id)\n+                     -> ty_param_bounds_and_ty {\n     match cx.tcache.find(did) {\n       Some(tpt) => {\n         // The item is in this crate. The caller should have added it to the\n@@ -4050,9 +3874,11 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n-fn lookup_field_type(tcx: ctxt, struct_id: def_id, id: def_id,\n-                     substs: &substs) -> ty::t {\n-\n+pub fn lookup_field_type(tcx: ctxt,\n+                         struct_id: def_id,\n+                         id: def_id,\n+                         substs: &substs)\n+                      -> ty::t {\n     let t = if id.crate == ast::local_crate {\n         node_id_to_type(tcx, id.node)\n     }\n@@ -4071,7 +3897,7 @@ fn lookup_field_type(tcx: ctxt, struct_id: def_id, id: def_id,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n+pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n   if did.crate == ast::local_crate {\n     match cx.items.find(did.node) {\n        Some(ast_map::node_item(i,_)) => {\n@@ -4106,8 +3932,10 @@ fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n     }\n }\n \n-fn lookup_struct_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n-    -> field_ty {\n+pub fn lookup_struct_field(cx: ctxt,\n+                           parent: ast::def_id,\n+                           field_id: ast::def_id)\n+                        -> field_ty {\n     match vec::find(lookup_struct_fields(cx, parent),\n                  |f| f.id.node == field_id.node) {\n         Some(t) => t,\n@@ -4153,17 +3981,19 @@ fn struct_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n // Keep in mind that this function reports that all fields are\n // mutable, regardless of how they were declared. It's meant to\n // be used in trans.\n-fn struct_mutable_fields(cx:ctxt,\n-                                 did: ast::def_id,\n-                                 substs: &substs) -> ~[field] {\n+pub fn struct_mutable_fields(cx: ctxt,\n+                             did: ast::def_id,\n+                             substs: &substs)\n+                          -> ~[field] {\n     struct_item_fields(cx, did, substs, |_mt| m_mutbl)\n }\n \n // Same as struct_mutable_fields, but doesn't change\n // mutability.\n-fn struct_fields(cx:ctxt,\n-                         did: ast::def_id,\n-                         substs: &substs) -> ~[field] {\n+pub fn struct_fields(cx: ctxt,\n+                     did: ast::def_id,\n+                     substs: &substs)\n+                  -> ~[field] {\n     struct_item_fields(cx, did, substs, |mt| match mt {\n       struct_mutable => m_mutbl,\n         struct_immutable => m_imm })\n@@ -4188,7 +4018,7 @@ fn struct_item_fields(cx:ctxt,\n     }\n }\n \n-fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n+pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     const tycat_other: int = 0;\n     const tycat_bool: int = 1;\n     const tycat_int: int = 2;\n@@ -4256,14 +4086,14 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     return tbl[tycat(ty)][opcat(op)];\n }\n \n-fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n+pub fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n     vec::from_fn(tps.len(), |i| {\n                 ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n         })\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n-fn normalize_ty(cx: ctxt, t: t) -> t {\n+pub fn normalize_ty(cx: ctxt, t: t) -> t {\n     fn normalize_mt(cx: ctxt, mt: mt) -> mt {\n         mt { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n     }\n@@ -4338,7 +4168,10 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n }\n \n // Returns the repeat count for a repeating vector expression.\n-fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr, span: span) -> uint {\n+pub fn eval_repeat_count(tcx: ctxt,\n+                         count_expr: @ast::expr,\n+                         span: span)\n+                      -> uint {\n     match const_eval::eval_const_expr(tcx, count_expr) {\n         const_eval::const_int(count) => return count as uint,\n         const_eval::const_uint(count) => return count as uint,\n@@ -4365,9 +4198,10 @@ fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr, span: span) -> uint {\n }\n \n // Determine what purity to check a nested function under\n-pure fn determine_inherited_purity(parent_purity: ast::purity,\n-                                   child_purity: ast::purity,\n-                                   child_proto: ast::Proto) -> ast::purity {\n+pub pure fn determine_inherited_purity(parent_purity: ast::purity,\n+                                       child_purity: ast::purity,\n+                                       child_proto: ast::Proto)\n+                                    -> ast::purity {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n@@ -4382,9 +4216,9 @@ pure fn determine_inherited_purity(parent_purity: ast::purity,\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-fn iter_bound_traits_and_supertraits(tcx: ctxt,\n-                                     bounds: param_bounds,\n-                                     f: &fn(t) -> bool) {\n+pub fn iter_bound_traits_and_supertraits(tcx: ctxt,\n+                                         bounds: param_bounds,\n+                                         f: &fn(t) -> bool) {\n     let mut fin = false;\n \n     for bounds.each |bound| {\n@@ -4440,8 +4274,8 @@ fn iter_bound_traits_and_supertraits(tcx: ctxt,\n     }\n }\n \n-fn count_traits_and_supertraits(tcx: ctxt,\n-                                boundses: &[param_bounds]) -> uint {\n+pub fn count_traits_and_supertraits(tcx: ctxt,\n+                                    boundses: &[param_bounds]) -> uint {\n     let mut total = 0;\n     for boundses.each |bounds| {\n         for iter_bound_traits_and_supertraits(tcx, *bounds) |_trait_ty| {\n@@ -4452,7 +4286,7 @@ fn count_traits_and_supertraits(tcx: ctxt,\n }\n \n // Given a trait and a type, returns the impl of that type\n-fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n+pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n     match tcx.trait_impls.find(trait_id) {\n         Some(ty_to_impl) => match ty_to_impl.find(self_ty) {\n             Some(the_impl) => the_impl.did,"}, {"sha": "615153733de9197c113ca11a3d52c95d20cb88ac", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/684aa2b7fdc22313ffec159711017344d444d75b/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/684aa2b7fdc22313ffec159711017344d444d75b/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=684aa2b7fdc22313ffec159711017344d444d75b", "patch": "@@ -77,7 +77,6 @@ pub mod middle {\n         pub mod reachable;\n         pub mod machine;\n     }\n-    #[legacy_exports]\n     pub mod ty;\n     #[legacy_exports]\n     pub mod resolve;"}]}