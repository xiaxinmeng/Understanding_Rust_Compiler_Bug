{"sha": "872ab780c000026441532ced4873bab0c29971df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MmFiNzgwYzAwMDAyNjQ0MTUzMmNlZDQ4NzNiYWIwYzI5OTcxZGY=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-01-26T19:51:57Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-09-03T18:59:29Z"}, "message": "work around compiler overhead around lambdas in generics by extracting them into free functions", "tree": {"sha": "2deeb0147fab27d7bc2968e2cbacd725925d5ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2deeb0147fab27d7bc2968e2cbacd725925d5ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/872ab780c000026441532ced4873bab0c29971df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/872ab780c000026441532ced4873bab0c29971df", "html_url": "https://github.com/rust-lang/rust/commit/872ab780c000026441532ced4873bab0c29971df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/872ab780c000026441532ced4873bab0c29971df/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "771b8ecc83ed55de617cdb29e05d509cfc745a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/771b8ecc83ed55de617cdb29e05d509cfc745a8a", "html_url": "https://github.com/rust-lang/rust/commit/771b8ecc83ed55de617cdb29e05d509cfc745a8a"}], "stats": {"total": 73, "additions": 39, "deletions": 34}, "files": [{"sha": "fa68fc1e2b444ad2ef0b57634845fedfe0ffdb49", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/872ab780c000026441532ced4873bab0c29971df/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/872ab780c000026441532ced4873bab0c29971df/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=872ab780c000026441532ced4873bab0c29971df", "patch": "@@ -2212,6 +2212,34 @@ impl<T> SpecFrom<T, IntoIter<T>> for Vec<T> {\n     }\n }\n \n+fn write_in_place<T>(src_end: *const T) -> impl FnMut(*mut T, T) -> Result<*mut T, !> {\n+    move |mut dst, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(dst, item);\n+            dst = dst.add(1);\n+        }\n+        Ok(dst)\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // same caveat as above\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}\n+\n // Further specialization potential once\n // https://github.com/rust-lang/rust/issues/62645 has been solved:\n // T can be split into IN and OUT which only need to have the same size and alignment\n@@ -2230,46 +2258,23 @@ where\n             let inner = unsafe { iterator.as_inner().as_into_iter() };\n             (inner.buf.as_ptr(), inner.end, inner.cap)\n         };\n-        let dst = src_buf;\n \n+        // use try-fold\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods methods it only takes a &mut self\n+        // - lets us thread the write pointer through its innards and get it back in the end\n         let dst = if mem::needs_drop::<T>() {\n-            // special-case drop handling since it prevents vectorization\n-            let mut sink = InPlaceDrop { inner: src_buf, dst };\n-            let _ = iterator.try_for_each::<_, Result<_, !>>(|item| {\n-                unsafe {\n-                    debug_assert!(\n-                        sink.dst as *const _ <= src_end,\n-                        \"InPlaceIterable contract violation\"\n-                    );\n-                    ptr::write(sink.dst, item);\n-                    sink.dst = sink.dst.add(1);\n-                }\n-                Ok(())\n-            });\n+            // special-case drop handling since it forces us to lug that extra field around which\n+            // can inhibit optimizations\n+            let sink = InPlaceDrop { inner: src_buf, dst: src_buf };\n+            let sink = iterator\n+                .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(src_end))\n+                .unwrap();\n             // iteration succeeded, don't drop head\n             let sink = mem::ManuallyDrop::new(sink);\n             sink.dst\n         } else {\n-            // use try-fold\n-            // - it vectorizes better\n-            // - unlike most internal iteration methods methods it only takes a &mut self\n-            // - lets us thread the write pointer through its innards and get it back in the end\n-            iterator\n-                .try_fold::<_, _, Result<_, !>>(dst, move |mut dst, item| {\n-                    unsafe {\n-                        // the InPlaceIterable contract cannot be verified precisely here since\n-                        // try_fold has an exclusive reference to the source pointer\n-                        // all we can do is check if it's still in range\n-                        debug_assert!(\n-                            dst as *const _ <= src_end,\n-                            \"InPlaceIterable contract violation\"\n-                        );\n-                        ptr::write(dst, item);\n-                        dst = dst.add(1);\n-                    }\n-                    Ok(dst)\n-                })\n-                .unwrap()\n+            iterator.try_fold::<_, _, Result<_, !>>(src_buf, write_in_place(src_end)).unwrap()\n         };\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };"}]}