{"sha": "7f25580512a3466e1cb90253cb3806acb50063a5", "node_id": "C_kwDOAAsO6NoAKDdmMjU1ODA1MTJhMzQ2NmUxY2I5MDI1M2NiMzgwNmFjYjUwMDYzYTU", "commit": {"author": {"name": "Nicole Mazzuca", "email": "mazzucan@outlook.com", "date": "2023-01-20T07:21:21Z"}, "committer": {"name": "Nicole Mazzuca", "email": "mazzucan@outlook.com", "date": "2023-02-25T19:15:23Z"}, "message": "[stdio][windows] Use MBTWC and WCTMB", "tree": {"sha": "4b8ea84b70730f7a369885bf2ba9aa6aa5646db5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b8ea84b70730f7a369885bf2ba9aa6aa5646db5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f25580512a3466e1cb90253cb3806acb50063a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f25580512a3466e1cb90253cb3806acb50063a5", "html_url": "https://github.com/rust-lang/rust/commit/7f25580512a3466e1cb90253cb3806acb50063a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f25580512a3466e1cb90253cb3806acb50063a5/comments", "author": {"login": "strega-nil", "id": 3479021, "node_id": "MDQ6VXNlcjM0NzkwMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4", "gravatar_id": "", "url": "https://api.github.com/users/strega-nil", "html_url": "https://github.com/strega-nil", "followers_url": "https://api.github.com/users/strega-nil/followers", "following_url": "https://api.github.com/users/strega-nil/following{/other_user}", "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}", "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions", "organizations_url": "https://api.github.com/users/strega-nil/orgs", "repos_url": "https://api.github.com/users/strega-nil/repos", "events_url": "https://api.github.com/users/strega-nil/events{/privacy}", "received_events_url": "https://api.github.com/users/strega-nil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "strega-nil", "id": 3479021, "node_id": "MDQ6VXNlcjM0NzkwMjE=", "avatar_url": "https://avatars.githubusercontent.com/u/3479021?v=4", "gravatar_id": "", "url": "https://api.github.com/users/strega-nil", "html_url": "https://github.com/strega-nil", "followers_url": "https://api.github.com/users/strega-nil/followers", "following_url": "https://api.github.com/users/strega-nil/following{/other_user}", "gists_url": "https://api.github.com/users/strega-nil/gists{/gist_id}", "starred_url": "https://api.github.com/users/strega-nil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/strega-nil/subscriptions", "organizations_url": "https://api.github.com/users/strega-nil/orgs", "repos_url": "https://api.github.com/users/strega-nil/repos", "events_url": "https://api.github.com/users/strega-nil/events{/privacy}", "received_events_url": "https://api.github.com/users/strega-nil/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10"}], "stats": {"total": 107, "additions": 78, "deletions": 29}, "files": [{"sha": "8d77664224930da2dacbba3fe665f6e37bb20200", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=7f25580512a3466e1cb90253cb3806acb50063a5", "patch": "@@ -232,6 +232,7 @@\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n+#![cfg_attr(windows, feature(round_char_boundary))]\n //\n // Language features:\n #![feature(alloc_error_handler)]"}, {"sha": "d1e6594b3f2a83d007de7035b6618503c08039c4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=7f25580512a3466e1cb90253cb3806acb50063a5", "patch": "@@ -6,13 +6,15 @@\n \n use crate::ffi::CStr;\n use crate::mem;\n-use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n+use crate::os::raw::{c_char, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::os::windows::io::{BorrowedHandle, HandleOrInvalid, HandleOrNull};\n use crate::ptr;\n use core::ffi::NonZero_c_ulong;\n \n use libc::{c_void, size_t, wchar_t};\n \n+pub use crate::os::raw::c_int;\n+\n #[path = \"c/errors.rs\"] // c.rs is included from two places so we need to specify this\n mod errors;\n pub use errors::*;\n@@ -47,16 +49,19 @@ pub type ACCESS_MASK = DWORD;\n \n pub type LPBOOL = *mut BOOL;\n pub type LPBYTE = *mut BYTE;\n+pub type LPCCH = *const CHAR;\n pub type LPCSTR = *const CHAR;\n+pub type LPCWCH = *const WCHAR;\n pub type LPCWSTR = *const WCHAR;\n+pub type LPCVOID = *const c_void;\n pub type LPDWORD = *mut DWORD;\n pub type LPHANDLE = *mut HANDLE;\n pub type LPOVERLAPPED = *mut OVERLAPPED;\n pub type LPPROCESS_INFORMATION = *mut PROCESS_INFORMATION;\n pub type LPSECURITY_ATTRIBUTES = *mut SECURITY_ATTRIBUTES;\n pub type LPSTARTUPINFO = *mut STARTUPINFO;\n+pub type LPSTR = *mut CHAR;\n pub type LPVOID = *mut c_void;\n-pub type LPCVOID = *const c_void;\n pub type LPWCH = *mut WCHAR;\n pub type LPWIN32_FIND_DATAW = *mut WIN32_FIND_DATAW;\n pub type LPWSADATA = *mut WSADATA;\n@@ -132,6 +137,10 @@ pub const MAX_PATH: usize = 260;\n \n pub const FILE_TYPE_PIPE: u32 = 3;\n \n+pub const CP_UTF8: DWORD = 65001;\n+pub const MB_ERR_INVALID_CHARS: DWORD = 0x08;\n+pub const WC_ERR_INVALID_CHARS: DWORD = 0x80;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -1155,6 +1164,25 @@ extern \"system\" {\n         lpFilePart: *mut LPWSTR,\n     ) -> DWORD;\n     pub fn GetFileAttributesW(lpFileName: LPCWSTR) -> DWORD;\n+\n+    pub fn MultiByteToWideChar(\n+        CodePage: UINT,\n+        dwFlags: DWORD,\n+        lpMultiByteStr: LPCCH,\n+        cbMultiByte: c_int,\n+        lpWideCharStr: LPWSTR,\n+        cchWideChar: c_int,\n+    ) -> c_int;\n+    pub fn WideCharToMultiByte(\n+        CodePage: UINT,\n+        dwFlags: DWORD,\n+        lpWideCharStr: LPCWCH,\n+        cchWideChar: c_int,\n+        lpMultiByteStr: LPSTR,\n+        cbMultiByte: c_int,\n+        lpDefaultChar: LPCCH,\n+        lpUsedDefaultChar: LPBOOL,\n+    ) -> c_int;\n }\n \n #[link(name = \"ws2_32\")]"}, {"sha": "32c6ccffb7a7324f8d760a16c4284afc5032d142", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f25580512a3466e1cb90253cb3806acb50063a5/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=7f25580512a3466e1cb90253cb3806acb50063a5", "patch": "@@ -169,14 +169,27 @@ fn write(\n }\n \n fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usize> {\n+    debug_assert!(!utf8.is_empty());\n+\n     let mut utf16 = [MaybeUninit::<u16>::uninit(); MAX_BUFFER_SIZE / 2];\n-    let mut len_utf16 = 0;\n-    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n-        *dest = MaybeUninit::new(chr);\n-        len_utf16 += 1;\n-    }\n-    // Safety: We've initialized `len_utf16` values.\n-    let utf16: &[u16] = unsafe { MaybeUninit::slice_assume_init_ref(&utf16[..len_utf16]) };\n+    let utf8 = &utf8[..utf8.floor_char_boundary(utf16.len())];\n+\n+    let utf16: &[u16] = unsafe {\n+        // Note that this theoretically checks validity twice in the (most common) case\n+        // where the underlying byte sequence is valid utf-8 (given the check in `write()`).\n+        let result = c::MultiByteToWideChar(\n+            c::CP_UTF8,                      // CodePage\n+            c::MB_ERR_INVALID_CHARS,         // dwFlags\n+            utf8.as_ptr() as c::LPCCH,       // lpMultiByteStr\n+            utf8.len() as c::c_int,          // cbMultiByte\n+            utf16.as_mut_ptr() as c::LPWSTR, // lpWideCharStr\n+            utf16.len() as c::c_int,         // cchWideChar\n+        );\n+        assert!(result != 0, \"Unexpected error in MultiByteToWideChar\");\n+\n+        // Safety: MultiByteToWideChar initializes `result` values.\n+        MaybeUninit::slice_assume_init_ref(&utf16[..result as usize])\n+    };\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n@@ -189,8 +202,8 @@ fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usiz\n         // a missing surrogate can be produced (and also because of the UTF-8 validation above),\n         // write the missing surrogate out now.\n         // Buffering it would mean we have to lie about the number of bytes written.\n-        let first_char_remaining = utf16[written];\n-        if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF {\n+        let first_code_unit_remaining = utf16[written];\n+        if first_code_unit_remaining >= 0xDCEE && first_code_unit_remaining <= 0xDFFF {\n             // low surrogate\n             // We just hope this works, and give up otherwise\n             let _ = write_u16s(handle, &utf16[written..written + 1]);\n@@ -212,6 +225,7 @@ fn write_valid_utf8_to_console(handle: c::HANDLE, utf8: &str) -> io::Result<usiz\n }\n \n fn write_u16s(handle: c::HANDLE, data: &[u16]) -> io::Result<usize> {\n+    debug_assert!(data.len() < u32::MAX as usize);\n     let mut written = 0;\n     cvt(unsafe {\n         c::WriteConsoleW(\n@@ -365,26 +379,32 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [MaybeUninit<u16>]) -> io::Result<usiz\n     Ok(amount as usize)\n }\n \n-#[allow(unused)]\n fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n-    let mut written = 0;\n-    for chr in char::decode_utf16(utf16.iter().cloned()) {\n-        match chr {\n-            Ok(chr) => {\n-                chr.encode_utf8(&mut utf8[written..]);\n-                written += chr.len_utf8();\n-            }\n-            Err(_) => {\n-                // We can't really do any better than forget all data and return an error.\n-                return Err(io::const_io_error!(\n-                    io::ErrorKind::InvalidData,\n-                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n-                     encountered unpaired surrogate\",\n-                ));\n-            }\n-        }\n+    debug_assert!(utf16.len() <= c::c_int::MAX as usize);\n+    debug_assert!(utf8.len() <= c::c_int::MAX as usize);\n+\n+    let result = unsafe {\n+        c::WideCharToMultiByte(\n+            c::CP_UTF8,                    // CodePage\n+            c::WC_ERR_INVALID_CHARS,       // dwFlags\n+            utf16.as_ptr(),                // lpWideCharStr\n+            utf16.len() as c::c_int,       // cchWideChar\n+            utf8.as_mut_ptr() as c::LPSTR, // lpMultiByteStr\n+            utf8.len() as c::c_int,        // cbMultiByte\n+            ptr::null(),                   // lpDefaultChar\n+            ptr::null_mut(),               // lpUsedDefaultChar\n+        )\n+    };\n+    if result == 0 {\n+        // We can't really do any better than forget all data and return an error.\n+        Err(io::const_io_error!(\n+            io::ErrorKind::InvalidData,\n+            \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+            encountered unpaired surrogate\",\n+        ))\n+    } else {\n+        Ok(result as usize)\n     }\n-    Ok(written)\n }\n \n impl IncompleteUtf8 {"}]}