{"sha": "049f4d8cf4bf5613a658316afbec168fc03294ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OWY0ZDhjZjRiZjU2MTNhNjU4MzE2YWZiZWMxNjhmYzAzMjk0YmE=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T19:57:44Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-06-05T20:09:32Z"}, "message": "document the `Bounds` struct a bit", "tree": {"sha": "61515bda91eaf28107af350d61a84204430d120b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61515bda91eaf28107af350d61a84204430d120b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/049f4d8cf4bf5613a658316afbec168fc03294ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/049f4d8cf4bf5613a658316afbec168fc03294ba", "html_url": "https://github.com/rust-lang/rust/commit/049f4d8cf4bf5613a658316afbec168fc03294ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/049f4d8cf4bf5613a658316afbec168fc03294ba/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "963e22c38c97f342338b9d93ca5be58418fb535f", "url": "https://api.github.com/repos/rust-lang/rust/commits/963e22c38c97f342338b9d93ca5be58418fb535f", "html_url": "https://github.com/rust-lang/rust/commit/963e22c38c97f342338b9d93ca5be58418fb535f"}], "stats": {"total": 39, "additions": 37, "deletions": 2}, "files": [{"sha": "2ba6601e82631c90a20f81f85f46d3aa27d96d46", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/049f4d8cf4bf5613a658316afbec168fc03294ba/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/049f4d8cf4bf5613a658316afbec168fc03294ba/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=049f4d8cf4bf5613a658316afbec168fc03294ba", "patch": "@@ -2287,17 +2287,52 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n }\n \n-// A helper struct for conveniently grouping a set of bounds which we pass to\n-// and return from functions in multiple places.\n+/// Collects together a list of bounds that are applied to some type,\n+/// after they've been converted into `ty` form (from the HIR\n+/// representations). These lists of bounds occur in many places in\n+/// Rust's syntax:\n+///\n+/// ```\n+/// trait Foo: Bar + Baz { }\n+///            ^^^^^^^^^ supertrait list bounding the `Self` type parameter\n+///\n+/// fn foo<T: Bar + Baz>() { }\n+///           ^^^^^^^^^ bounding the type parameter `T`\n+///\n+/// impl dyn Bar + Baz\n+///          ^^^^^^^^^ bounding the forgotten dynamic type\n+/// ```\n+///\n+/// Our representation is a bit mixed here -- in some cases, we\n+/// include the self type (e.g., `trait_bounds`) but in others we do\n #[derive(Default, PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n+    /// A list of region bounds on the (implicit) self type. So if you\n+    /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n+    /// the `T` is not explicitly included).\n     pub region_bounds: Vec<(ty::Region<'tcx>, Span)>,\n+\n+    /// A list of trait bounds. So if you had `T: Debug` this would be\n+    /// `T: Debug`. Note that the self-type is explicit here.\n     pub trait_bounds: Vec<(ty::PolyTraitRef<'tcx>, Span)>,\n+\n+    /// A list of projection equality bounds. So if you had `T:\n+    /// Iterator<Item = u32>` this would include `<T as\n+    /// Iterator>::Item => u32`. Note that the self-type is explicit\n+    /// here.\n     pub projection_bounds: Vec<(ty::PolyProjectionPredicate<'tcx>, Span)>,\n+\n+    /// `Some` if there is *no* `?Sized` predicate. The `span`\n+    /// is the location in the source of the `T` declaration which can\n+    /// be cited as the source of the `T: Sized` requirement.\n     pub implicitly_sized: Option<Span>,\n }\n \n impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n+    /// Converts a bounds list into a flat set of predicates (like\n+    /// where-clauses). Because some of our bounds listings (e.g.,\n+    /// regions) don't include the self-type, you must supply the\n+    /// self-type here (the `param_ty` parameter).\n     pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<(ty::Predicate<'tcx>, Span)>\n     {"}]}