{"sha": "fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlZDg0OTE0NzY2NzRlYTdmODU3MDFmZDdmNThjMGVmODlhMGViOGM=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-04-25T10:37:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-25T10:37:24Z"}, "message": "Merge pull request #506 from yati-sagade/master\n\nLint for pointing out needless continue statements, fixes #111", "tree": {"sha": "009fe47c1405a34c60c68eaec9241137ed3b8b0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/009fe47c1405a34c60c68eaec9241137ed3b8b0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "html_url": "https://github.com/rust-lang/rust/commit/fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a485ba1f5fbea620677855f4ff9be7313a1ff64", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a485ba1f5fbea620677855f4ff9be7313a1ff64", "html_url": "https://github.com/rust-lang/rust/commit/7a485ba1f5fbea620677855f4ff9be7313a1ff64"}, {"sha": "5381c4fcf63171d1dedcf5163426b6f9410d1b03", "url": "https://api.github.com/repos/rust-lang/rust/commits/5381c4fcf63171d1dedcf5163426b6f9410d1b03", "html_url": "https://github.com/rust-lang/rust/commit/5381c4fcf63171d1dedcf5163426b6f9410d1b03"}], "stats": {"total": 668, "additions": 668, "deletions": 0}, "files": [{"sha": "8da893dededf2e2ff9997754586d94d4df13e6a5", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -417,6 +417,7 @@ All notable changes to this project will be documented in this file.\n [`mutex_integer`]: https://github.com/Manishearth/rust-clippy/wiki#mutex_integer\n [`needless_bool`]: https://github.com/Manishearth/rust-clippy/wiki#needless_bool\n [`needless_borrow`]: https://github.com/Manishearth/rust-clippy/wiki#needless_borrow\n+[`needless_continue`]: https://github.com/Manishearth/rust-clippy/wiki#needless_continue\n [`needless_lifetimes`]: https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes\n [`needless_pass_by_value`]: https://github.com/Manishearth/rust-clippy/wiki#needless_pass_by_value\n [`needless_range_loop`]: https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop"}, {"sha": "f63e7412bb4902aceffc429809e9cdd66db2bbc5", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -288,6 +288,7 @@ name\n [mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                                         | allow   | using a mutex for an integer type\n [needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                                         | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n [needless_borrow](https://github.com/Manishearth/rust-clippy/wiki#needless_borrow)                                     | warn    | taking a reference that is going to be automatically dereferenced\n+[needless_continue](https://github.com/Manishearth/rust-clippy/wiki#needless_continue)                                 | warn    | `continue` statements that can be replaced by a rearrangement of code\n [needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)                               | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n [needless_pass_by_value](https://github.com/Manishearth/rust-clippy/wiki#needless_pass_by_value)                       | warn    | functions taking arguments by value, but not consuming them in its body\n [needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)                             | warn    | for-looping over a range of indices where an iterator over items would do"}, {"sha": "0c43f63d03bf3db189080682fae6b0a627baf90d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -106,6 +106,7 @@ pub mod mutex_atomic;\n pub mod needless_bool;\n pub mod needless_borrow;\n pub mod needless_pass_by_value;\n+pub mod needless_continue;\n pub mod needless_update;\n pub mod neg_multiply;\n pub mod new_without_default;\n@@ -218,6 +219,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box approx_const::Pass);\n     reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n+    reg.register_early_lint_pass(box needless_continue::NeedlessContinue);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n     reg.register_early_lint_pass(box items_after_statements::ItemsAfterStatements);\n@@ -460,6 +462,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         needless_bool::NEEDLESS_BOOL,\n         needless_borrow::NEEDLESS_BORROW,\n         needless_pass_by_value::NEEDLESS_PASS_BY_VALUE,\n+        needless_continue::NEEDLESS_CONTINUE,\n         needless_update::NEEDLESS_UPDATE,\n         neg_multiply::NEG_MULTIPLY,\n         new_without_default::NEW_WITHOUT_DEFAULT,"}, {"sha": "1e7120951cab2c38be8183fedc38fc7fc36227ec", "filename": "clippy_lints/src/needless_continue.rs", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -0,0 +1,424 @@\n+//! Checks for continue statements in loops that are redundant.\n+//!\n+//! For example, the lint would catch\n+//!\n+//! ```\n+//! while condition() {\n+//!     update_condition();\n+//!     if x {\n+//!         // ...\n+//!     } else {\n+//!         continue;\n+//!     }\n+//!     println!(\"Hello, world\");\n+//! }\n+//! ```\n+//!\n+//! And suggest something like this:\n+//!\n+//! ```\n+//! while condition() {\n+//!     update_condition();\n+//!     if x {\n+//!         // ...\n+//!         println!(\"Hello, world\");\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This lint is **warn** by default.\n+use rustc::lint::*;\n+use syntax::ast;\n+use syntax::codemap::{original_sp,DUMMY_SP};\n+use std::borrow::Cow;\n+\n+use utils::{in_macro, span_help_and_lint, snippet_block, snippet, trim_multiline};\n+\n+/// **What it does:** The lint checks for `if`-statements appearing in loops\n+/// that contain a `continue` statement in either their main blocks or their\n+/// `else`-blocks, when omitting the `else`-block possibly with some\n+/// rearrangement of code can make the code easier to understand.\n+///\n+/// **Why is this bad?** Having explicit `else` blocks for `if` statements\n+/// containing `continue` in their THEN branch adds unnecessary branching and\n+/// nesting to the code. Having an else block containing just `continue` can\n+/// also be better written by grouping the statements following the whole `if`\n+/// statement within the THEN block and omitting the else block completely.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// while condition() {\n+///     update_condition();\n+///     if x {\n+///         // ...\n+///     } else {\n+///         continue;\n+///     }\n+///     println!(\"Hello, world\");\n+/// }\n+/// ```\n+///\n+/// Could be rewritten as\n+///\n+/// ```rust\n+/// while condition() {\n+///     update_condition();\n+///     if x {\n+///         // ...\n+///         println!(\"Hello, world\");\n+///     }\n+/// }\n+/// ```\n+///\n+/// As another example, the following code\n+///\n+/// ```rust\n+/// loop {\n+///     if waiting() {\n+///         continue;\n+///     } else {\n+///         // Do something useful\n+///     }\n+/// }\n+/// ```\n+/// Could be rewritten as\n+///\n+/// ```rust\n+/// loop {\n+///     if waiting() {\n+///         continue;\n+///     }\n+///     // Do something useful\n+/// }\n+/// ```\n+declare_lint! {\n+    pub NEEDLESS_CONTINUE,\n+    Warn,\n+    \"`continue` statements that can be replaced by a rearrangement of code\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct NeedlessContinue;\n+\n+impl LintPass for NeedlessContinue {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(NEEDLESS_CONTINUE)\n+    }\n+}\n+\n+impl EarlyLintPass for NeedlessContinue {\n+    fn check_expr(&mut self, ctx: &EarlyContext, expr: &ast::Expr) {\n+        if !in_macro(expr.span) {\n+            check_and_warn(ctx, expr);\n+        }\n+    }\n+}\n+\n+/* This lint has to mainly deal with two cases of needless continue statements.\n+ *\n+ * Case 1 [Continue inside else block]:\n+ *\n+ *     loop {\n+ *         // region A\n+ *         if cond {\n+ *             // region B\n+ *         } else {\n+ *             continue;\n+ *         }\n+ *         // region C\n+ *     }\n+ *\n+ * This code can better be written as follows:\n+ *\n+ *     loop {\n+ *         // region A\n+ *         if cond {\n+ *             // region B\n+ *             // region C\n+ *         }\n+ *     }\n+ *\n+ * Case 2 [Continue inside then block]:\n+ *\n+ *     loop {\n+ *       // region A\n+ *       if cond {\n+ *           continue;\n+ *           // potentially more code here.\n+ *       } else {\n+ *           // region B\n+ *       }\n+ *       // region C\n+ *     }\n+ *\n+ *\n+ * This snippet can be refactored to:\n+ *\n+ *     loop {\n+ *       // region A\n+ *       if !cond {\n+ *           // region B\n+ *           // region C\n+ *       }\n+ *     }\n+ */\n+\n+/// Given an expression, returns true if either of the following is true\n+///\n+/// - The expression is a `continue` node.\n+/// - The expression node is a block with the first statement being a `continue`.\n+///\n+fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n+    match else_expr.node {\n+        ast::ExprKind::Block(ref else_block) => is_first_block_stmt_continue(else_block),\n+        ast::ExprKind::Continue(_) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n+    block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n+        ast::StmtKind::Semi(ref e) |\n+        ast::StmtKind::Expr(ref e) => if let ast::ExprKind::Continue(_) = e.node {\n+            true\n+        } else {\n+            false\n+        },\n+        _ => false,\n+    })\n+}\n+\n+/// If `expr` is a loop expression (while/while let/for/loop), calls `func` with\n+/// the AST object representing the loop block of `expr`.\n+fn with_loop_block<F>(expr: &ast::Expr, mut func: F) where F: FnMut(&ast::Block) {\n+    match expr.node {\n+        ast::ExprKind::While(_, ref loop_block, _)       |\n+        ast::ExprKind::WhileLet(_, _, ref loop_block, _) |\n+        ast::ExprKind::ForLoop( _, _, ref loop_block, _) |\n+        ast::ExprKind::Loop(ref loop_block, _)           => func(loop_block),\n+        _ => {},\n+    }\n+}\n+\n+/// If `stmt` is an if expression node with an `else` branch, calls func with the\n+/// following:\n+///\n+/// - The `if` expression itself,\n+/// - The `if` condition expression,\n+/// - The `then` block, and\n+/// - The `else` expression.\n+///\n+fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n+        where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr) {\n+    match stmt.node {\n+        ast::StmtKind::Semi(ref e) |\n+        ast::StmtKind::Expr(ref e) => {\n+            if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.node {\n+                func(e, cond, if_block, else_expr);\n+            }\n+        },\n+        _ => { },\n+    }\n+}\n+\n+/// A type to distinguish between the two distinct cases this lint handles.\n+#[derive(Copy, Clone, Debug)]\n+enum LintType {\n+    ContinueInsideElseBlock,\n+    ContinueInsideThenBlock,\n+}\n+\n+/// Data we pass around for construction of help messages.\n+struct LintData<'a> {\n+    /// The `if` expression encountered in the above loop.\n+    if_expr: &'a ast::Expr,\n+    /// The condition expression for the above `if`.\n+    if_cond: &'a ast::Expr,\n+    /// The `then` block of the `if` statement.\n+    if_block: &'a ast::Block,\n+    /// The `else` block of the `if` statement.\n+    /// Note that we only work with `if` exprs that have an `else` branch.\n+    else_expr: &'a ast::Expr,\n+    /// The 0-based index of the `if` statement in the containing loop block.\n+    stmt_idx: usize,\n+    /// The statements of the loop block.\n+    block_stmts: &'a [ast::Stmt],\n+}\n+\n+const MSG_REDUNDANT_ELSE_BLOCK: &'static str = \"This else block is redundant.\\n\";\n+\n+const MSG_ELSE_BLOCK_NOT_NEEDED: &'static str = \"There is no need for an explicit `else` block for this `if` expression\\n\";\n+\n+const DROP_ELSE_BLOCK_AND_MERGE_MSG: &'static str =\n+    \"Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\\n\";\n+\n+const DROP_ELSE_BLOCK_MSG: &'static str =\n+    \"Consider dropping the else clause, and moving out the code in the else block, like so:\\n\";\n+\n+\n+fn emit_warning<'a>(ctx: &EarlyContext,\n+                    data: &'a LintData,\n+                    header: &str,\n+                    typ: LintType) {\n+\n+    // snip    is the whole *help* message that appears after the warning.\n+    // message is the warning message.\n+    // expr    is the expression which the lint warning message refers to.\n+    let (snip, message, expr) = match typ {\n+        LintType::ContinueInsideElseBlock => {\n+            (suggestion_snippet_for_continue_inside_else(ctx, data, header),\n+             MSG_REDUNDANT_ELSE_BLOCK,\n+             data.else_expr)\n+        },\n+        LintType::ContinueInsideThenBlock => {\n+            (suggestion_snippet_for_continue_inside_if(ctx, data, header),\n+             MSG_ELSE_BLOCK_NOT_NEEDED,\n+             data.if_expr)\n+        }\n+    };\n+    span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n+}\n+\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n+                                                data: &'a LintData,\n+                                                header: &str) -> String {\n+    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n+\n+    let if_code   = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n+                                   /*  ^^^^--- Four spaces of indentation. */\n+    // region B\n+    let else_code = snippet(ctx, data.else_expr.span, \"..\").into_owned();\n+    let else_code = erode_block(&else_code);\n+    let else_code = trim_multiline(Cow::from(else_code), false);\n+\n+    let mut ret = String::from(header);\n+    ret.push_str(&if_code);\n+    ret.push_str(&else_code);\n+    ret.push_str(\"\\n...\");\n+    ret\n+}\n+\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n+                                                   data: &'a LintData,\n+                                                   header: &str) -> String\n+{\n+    let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n+    let mut if_code   = format!(\"if {} {{\\n\", cond_code);\n+\n+    // Region B\n+    let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n+    let block_code = erode_block(block_code);\n+    let block_code = trim_multiline(Cow::from(block_code), false);\n+\n+    if_code.push_str(&block_code);\n+\n+    // Region C\n+    // These is the code in the loop block that follows the if/else construction\n+    // we are complaining about. We want to pull all of this code into the\n+    // `then` block of the `if` statement.\n+    let to_annex = data.block_stmts[data.stmt_idx+1..]\n+                   .iter()\n+                   .map(|stmt| {\n+                        original_sp(stmt.span, DUMMY_SP)\n+                    })\n+                   .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n+                   .collect::<Vec<_>>().join(\"\\n\");\n+\n+    let mut ret = String::from(header);\n+\n+    ret.push_str(&if_code);\n+    ret.push_str(\"\\n// Merged code follows...\");\n+    ret.push_str(&to_annex);\n+    ret.push_str(\"\\n}\\n\");\n+    ret\n+}\n+\n+fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n+    with_loop_block(expr, |loop_block| {\n+        for (i, stmt) in loop_block.stmts.iter().enumerate() {\n+            with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n+                let data = &LintData {\n+                    stmt_idx:    i,\n+                    if_expr:     if_expr,\n+                    if_cond:     cond,\n+                    if_block:    then_block,\n+                    else_expr:   else_expr,\n+                    block_stmts: &loop_block.stmts,\n+                };\n+                if needless_continue_in_else(else_expr) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n+                } else if is_first_block_stmt_continue(then_block) {\n+                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n+                }\n+            });\n+        }\n+    });\n+}\n+\n+/// Eats at `s` from the end till a closing brace `}` is encountered, and then\n+/// continues eating till a non-whitespace character is found.\n+/// e.g., the string\n+///\n+/// ```\n+///     {\n+///         let x = 5;\n+///     }\n+/// ```\n+///\n+/// is transformed to\n+///\n+/// ```\n+///     {\n+///         let x = 5;\"\n+/// ```\n+///\n+/// NOTE: when there is no closing brace in `s`, `s` is _not_ preserved, i.e.,\n+/// an empty string will be returned in that case.\n+pub fn erode_from_back(s: &str) -> String {\n+    let mut ret = String::from(s);\n+    while ret.pop().map_or(false, |c| c != '}') { }\n+    while let Some(c) = ret.pop() {\n+        if !c.is_whitespace() {\n+            ret.push(c);\n+            break;\n+        }\n+    }\n+    ret\n+}\n+\n+/// Eats at `s` from the front by first skipping all leading whitespace. Then,\n+/// any number of opening braces are eaten, followed by any number of newlines.\n+/// e.g.,  the string\n+///\n+/// ```\n+///         {\n+///             something();\n+///             inside_a_block();\n+///         }\n+/// ```\n+///\n+/// is transformed to\n+///\n+/// ```\n+///             something();\n+///             inside_a_block();\n+///         }\n+///     \n+/// ```\n+///\n+pub fn erode_from_front(s: &str) -> String {\n+    s.chars()\n+     .skip_while(|c| c.is_whitespace())\n+     .skip_while(|c| *c == '{')\n+     .skip_while(|c| *c == '\\n')\n+     .collect::<String>()\n+}\n+\n+/// If `s` contains the code for a block, delimited by braces, this function\n+/// tries to get the contents of the block. If there is no closing brace present,\n+/// an empty string is returned.\n+pub fn erode_block(s: &str) -> String {\n+    erode_from_back(&erode_from_front(s))\n+}"}, {"sha": "299404dcee415a5f95890776e5c8dee6b3a504dd", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -983,3 +983,4 @@ pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Opti\n         .infer_ctxt((), Reveal::All)\n         .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n }\n+"}, {"sha": "0fcef5180302549630dc56956b784e9b7d257f37", "filename": "tests/needless_continue_helpers.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fneedless_continue_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fneedless_continue_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fneedless_continue_helpers.rs?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -0,0 +1,89 @@\n+// Tests for the various helper functions used by the needless_continue\n+// lint that don't belong in utils.\n+extern crate clippy_lints;\n+use clippy_lints::needless_continue::{erode_from_back, erode_block, erode_from_front};\n+\n+#[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn test_erode_from_back() {\n+    let input = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\n+}\";\n+\n+    let expected = \"\\\n+{\n+    let x = 5;\n+    let y = format!(\\\"{}\\\", 42);\";\n+\n+    let got = erode_from_back(input);\n+    assert_eq!(expected, got);\n+}\n+\n+#[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn test_erode_from_back_no_brace() {\n+    let input = \"\\\n+let x = 5;\n+let y = something();\n+\";\n+    let expected = \"\";\n+    let got = erode_from_back(input);\n+    assert_eq!(expected, got);\n+}\n+\n+#[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn test_erode_from_front() {\n+    let input = \"\n+        {\n+            something();\n+            inside_a_block();\n+        }\n+    \";\n+    let expected =\n+\"            something();\n+            inside_a_block();\n+        }\n+    \";\n+    let got = erode_from_front(input);\n+    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n+    assert_eq!(expected, got);\n+}\n+\n+#[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn test_erode_from_front_no_brace() {\n+    let input = \"\n+            something();\n+            inside_a_block();\n+    \";\n+    let expected =\n+\"something();\n+            inside_a_block();\n+    \";\n+    let got = erode_from_front(input);\n+    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n+    assert_eq!(expected, got);\n+}\n+\n+\n+#[test]\n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+fn test_erode_block() {\n+\n+    let input = \"\n+        {\n+            something();\n+            inside_a_block();\n+        }\n+    \";\n+    let expected =\n+\"            something();\n+            inside_a_block();\";\n+    let got = erode_block(input);\n+    println!(\"input: {}\\nexpected:\\n{}\\ngot:\\n{}\", input, expected, got);\n+    assert_eq!(expected, got);\n+}\n+"}, {"sha": "05c5e92a7faa1c4fde8a4250a934c0ad1a5e29f7", "filename": "tests/ui/copies.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fcopies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fcopies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcopies.stderr?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -1,3 +1,39 @@\n+warning: This else block is redundant.\n+\n+   --> $DIR/copies.rs:128:20\n+    |\n+128 |               } else {\n+    |  ____________________^\n+129 | |                 continue;\n+130 | |             }\n+    | |_____________^\n+    |\n+    = note: #[warn(needless_continue)] on by default\n+    = help: Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\n+            if true {\n+            break;\n+            // Merged code follows...\n+            }\n+            \n+\n+warning: This else block is redundant.\n+\n+   --> $DIR/copies.rs:138:20\n+    |\n+138 |               } else {\n+    |  ____________________^\n+139 | |                 continue;\n+140 | |             }\n+    | |_____________^\n+    |\n+    = note: #[warn(needless_continue)] on by default\n+    = help: Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\n+            if true {\n+            break;\n+            // Merged code follows...\n+            }\n+            \n+\n error: this `if` has identical blocks\n   --> $DIR/copies.rs:40:10\n    |"}, {"sha": "b6f9513be448dfb2b59ad38f12e987cc84c7bbc4", "filename": "tests/ui/needless_continue.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_continue.rs?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -0,0 +1,50 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+macro_rules! zero {\n+    ($x:expr) => ($x == 0);\n+}\n+\n+macro_rules! nonzero {\n+    ($x:expr) => (!zero!($x));\n+}\n+\n+#[deny(needless_continue)]\n+fn main() {\n+    let mut i = 1;\n+    while i < 10 {\n+        i += 1;\n+\n+        if i % 2 == 0 && i % 3 == 0 {\n+            println!(\"{}\", i);\n+            println!(\"{}\", i+1);\n+            if i % 5 == 0 {\n+                println!(\"{}\", i+2);\n+            }\n+            let i = 0;\n+            println!(\"bar {} \", i);\n+        } else {\n+            continue;\n+        }\n+\n+        println!(\"bleh\");\n+        {\n+            println!(\"blah\");\n+        }\n+\n+        // some comments that also should ideally be included in the\n+        // output of the lint suggestion if possible.\n+        if !(!(i == 2) || !(i == 5)) {\n+            println!(\"lama\");\n+        }\n+\n+        if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+            continue;\n+        } else {\n+            println!(\"Blabber\");\n+            println!(\"Jabber\");\n+        }\n+\n+        println!(\"bleh\");\n+    }\n+}"}, {"sha": "50be062a67bf0d08c0170e12818abc193afa147d", "filename": "tests/ui/needless_continue.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fneedless_continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fed8491476674ea7f85701fd7f58c0ef89a0eb8c/tests%2Fui%2Fneedless_continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_continue.stderr?ref=fed8491476674ea7f85701fd7f58c0ef89a0eb8c", "patch": "@@ -0,0 +1,63 @@\n+error: This else block is redundant.\n+\n+  --> $DIR/needless_continue.rs:26:16\n+   |\n+26 |           } else {\n+   |  ________________^\n+27 | |             continue;\n+28 | |         }\n+   | |_________^\n+   |\n+note: lint level defined here\n+  --> $DIR/needless_continue.rs:12:8\n+   |\n+12 | #[deny(needless_continue)]\n+   |        ^^^^^^^^^^^^^^^^^\n+   = help: Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\n+           if i % 2 == 0 && i % 3 == 0 {\n+           println!(\"{}\", i);\n+           println!(\"{}\", i+1);\n+           if i % 5 == 0 {\n+               println!(\"{}\", i+2);\n+           }\n+           let i = 0;\n+           println!(\"bar {} \", i);\n+           // Merged code follows...println!(\"bleh\");\n+           {\n+               println!(\"blah\");\n+           }\n+           if !(!(i == 2) || !(i == 5)) {\n+               println!(\"lama\");\n+           }\n+           if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+               continue;\n+           } else {\n+               println!(\"Blabber\");\n+               println!(\"Jabber\");\n+           }\n+           println!(\"bleh\");\n+           }\n+           \n+\n+error: There is no need for an explicit `else` block for this `if` expression\n+\n+  --> $DIR/needless_continue.rs:41:9\n+   |\n+41 | /         if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+42 | |             continue;\n+43 | |         } else {\n+44 | |             println!(\"Blabber\");\n+45 | |             println!(\"Jabber\");\n+46 | |         }\n+   | |_________^\n+   |\n+   = help: Consider dropping the else clause, and moving out the code in the else block, like so:\n+           if (zero!(i % 2) || nonzero!(i % 5)) && i % 3 != 0 {\n+               continue;\n+           }\n+           println!(\"Blabber\");\n+           println!(\"Jabber\");\n+           ...\n+\n+error: aborting due to 2 previous errors\n+"}]}