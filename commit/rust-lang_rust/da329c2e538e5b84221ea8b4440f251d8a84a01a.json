{"sha": "da329c2e538e5b84221ea8b4440f251d8a84a01a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMzI5YzJlNTM4ZTViODQyMjFlYThiNDQ0MGYyNTFkOGE4NGEwMWE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-25T10:57:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-25T10:57:13Z"}, "message": "more incremental work", "tree": {"sha": "68205da62673b91e293f56078f0dc07c1f40c2e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68205da62673b91e293f56078f0dc07c1f40c2e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da329c2e538e5b84221ea8b4440f251d8a84a01a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da329c2e538e5b84221ea8b4440f251d8a84a01a", "html_url": "https://github.com/rust-lang/rust/commit/da329c2e538e5b84221ea8b4440f251d8a84a01a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da329c2e538e5b84221ea8b4440f251d8a84a01a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19d933ba38e843833b9fce4776ee9b6b9f779e4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/19d933ba38e843833b9fce4776ee9b6b9f779e4e", "html_url": "https://github.com/rust-lang/rust/commit/19d933ba38e843833b9fce4776ee9b6b9f779e4e"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "bb060cbae4b7e25c727f1fa7973c8e3dda5cd089", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/da329c2e538e5b84221ea8b4440f251d8a84a01a/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da329c2e538e5b84221ea8b4440f251d8a84a01a/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=da329c2e538e5b84221ea8b4440f251d8a84a01a", "patch": "@@ -62,29 +62,35 @@ pub struct File {\n }\n \n impl File {\n-    fn new(root: GreenNode, errors: Vec<SyntaxError>) -> File {\n-        let root = SyntaxRoot::new(root, errors);\n+    fn new(green: GreenNode, errors: Vec<SyntaxError>) -> File {\n+        let root = SyntaxRoot::new(green, errors);\n         let root = SyntaxNode::new_owned(root);\n         validate_block_structure(root.borrowed());\n         File { root }\n     }\n     pub fn parse(text: &str) -> File {\n         let tokens = tokenize(&text);\n-        let (root, errors) = parser_impl::parse::<yellow::GreenBuilder>(text, &tokens);\n-        File::new(root, errors)\n+        let (green, errors) = parser_impl::parse::<yellow::GreenBuilder>(text, &tokens);\n+        File::new(green, errors)\n     }\n     pub fn reparse(&self, edit: &AtomEdit) -> File {\n         self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n     }\n     fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n         let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;\n+        let text = replace_range(\n+            node.text(),\n+            edit.delete - node.range().start(),\n+            &edit.insert,\n+        );\n+        let tokens = tokenize(&text);\n+        if !is_balanced(&tokens) {\n+            return None;\n+        }\n         None\n     }\n     fn full_reparse(&self, edit: &AtomEdit) -> File {\n-        let start = u32::from(edit.delete.start()) as usize;\n-        let end = u32::from(edit.delete.end()) as usize;\n-        let mut text = self.syntax().text();\n-        text.replace_range(start..end, &edit.insert);\n+        let text = replace_range(self.syntax().text(), edit.delete, &edit.insert);\n         File::parse(&text)\n     }\n     pub fn ast(&self) -> ast::Root {\n@@ -166,3 +172,30 @@ fn find_reparsable_node(node: SyntaxNodeRef, range: TextRange) -> Option<(Syntax\n         Some(res)\n     }\n }\n+\n+fn replace_range(mut text: String, range: TextRange, replace_with: &str) -> String {\n+    let start = u32::from(range.start()) as usize;\n+    let end = u32::from(range.end()) as usize;\n+    text.replace_range(start..end, replace_with);\n+    text\n+}\n+\n+fn is_balanced(tokens: &[Token]) -> bool {\n+    if tokens.len() == 0\n+       || tokens.first().unwrap().kind != L_CURLY\n+       || tokens.last().unwrap().kind != R_CURLY {\n+        return false\n+    }\n+    let mut balance = 0usize;\n+    for t in tokens.iter() {\n+        match t.kind {\n+            L_CURLY => balance += 1,\n+            R_CURLY => balance = match balance.checked_sub(1) {\n+                Some(b) => b,\n+                None => return false,\n+            },\n+            _ => (),\n+        }\n+    }\n+    balance == 0\n+}"}]}