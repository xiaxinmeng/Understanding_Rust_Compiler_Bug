{"sha": "10ef344d8c56563570a7647aa81e1586164f812b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZWYzNDRkOGM1NjU2MzU3MGE3NjQ3YWE4MWUxNTg2MTY0ZjgxMmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-23T03:22:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-23T03:22:55Z"}, "message": "Auto merge of #46011 - euclio:reachability-redux, r=nrc\n\nAllow filtering analysis by reachability\n\nFixes #43521.\nFixes https://github.com/nrc/rls-analysis/issues/79.\n\nThis PR allows a user to filter items present in the save-analysis data by setting the `reachable_only` config option. This option is intended for use by the new rustdoc. The PR isn't quite finished, because it's dependent on a new release of rls-data, but I want to make sure that the approach is valid.\n\nhttps://github.com/nrc/rls-analysis/issues/79 mentions that `pub use` might need to be handled, but my thinking is that the consumer of the analysis data would be able to infer which imports are `pub use`, and which items are only reachable through `pub use`, so that doesn't need to be handled here.\n\nr? @nrc", "tree": {"sha": "0f52e37e20e0eca4a6a7246a05465537d96b2dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f52e37e20e0eca4a6a7246a05465537d96b2dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10ef344d8c56563570a7647aa81e1586164f812b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10ef344d8c56563570a7647aa81e1586164f812b", "html_url": "https://github.com/rust-lang/rust/commit/10ef344d8c56563570a7647aa81e1586164f812b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10ef344d8c56563570a7647aa81e1586164f812b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af4515de6c065bc4e4ac91035fbf51643172305", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af4515de6c065bc4e4ac91035fbf51643172305", "html_url": "https://github.com/rust-lang/rust/commit/6af4515de6c065bc4e4ac91035fbf51643172305"}, {"sha": "794ada06e7ad370ec48b4de69e43eb59d69543c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/794ada06e7ad370ec48b4de69e43eb59d69543c9", "html_url": "https://github.com/rust-lang/rust/commit/794ada06e7ad370ec48b4de69e43eb59d69543c9"}], "stats": {"total": 147, "additions": 100, "deletions": 47}, "files": [{"sha": "729cce118ff5d558227734f54ad1e390c90d42ce", "filename": "src/Cargo.lock", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10ef344d8c56563570a7647aa81e1586164f812b/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/10ef344d8c56563570a7647aa81e1586164f812b/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=10ef344d8c56563570a7647aa81e1586164f812b", "patch": "@@ -1504,6 +1504,15 @@ dependencies = [\n  \"serde_derive 1.0.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rls-data\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rls-rustc\"\n version = \"0.1.1\"\n@@ -1869,7 +1878,7 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2737,6 +2746,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n \"checksum rls-analysis 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b961e7270b2084839ede4d2788167086b24bc9cf09c9e955cc851afaf116054\"\n \"checksum rls-data 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48257ceade23c2e01a3ca8d2fc4226101b107f6a3c868f829cf3fd2f204a1fe6\"\n+\"checksum rls-data 0.13.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff85bb3a0daf9f64207a5530d90ae1c10f5515cef064c88b6821090678382b44\"\n \"checksum rls-rustc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b21ea952e9bf1569929abf1bb920262cde04b7b1b26d8e0260286302807299d2\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd34691a510938bb67fe0444fb363103c73ffb31c121d1e16bc92d8945ea8ff\""}, {"sha": "8325b1d2a27acfc0688df03b3fa1122f7354f0c5", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10ef344d8c56563570a7647aa81e1586164f812b/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ef344d8c56563570a7647aa81e1586164f812b/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=10ef344d8c56563570a7647aa81e1586164f812b", "patch": "@@ -183,7 +183,8 @@ fn main() {\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n             cmd.arg(\"-Zsave-analysis\");\n             cmd.env(\"RUST_SAVE_ANALYSIS_CONFIG\",\n-                    \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\"pub_only\\\": true,\\\n+                    \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\n+                     \\\"pub_only\\\": true,\\\"reachable_only\\\": false,\\\n                      \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\");\n         }\n "}, {"sha": "6c8c9b7328662571828b4260e2f2753d12399619", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=10ef344d8c56563570a7647aa81e1586164f812b", "patch": "@@ -15,7 +15,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rls-data = \"0.12\"\n+rls-data = \"0.13\"\n rls-span = \"0.4\"\n # FIXME(#40527) should move rustc serialize out of tree\n rustc-serialize = \"0.3\""}, {"sha": "d4257e35823b3b4447502709714a53b5ab0da3ef", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=10ef344d8c56563570a7647aa81e1586164f812b", "patch": "@@ -42,7 +42,7 @@ use syntax::codemap::Spanned;\n use syntax_pos::*;\n \n use {escape, generated_code, lower_attributes, PathCollector, SaveContext};\n-use json_dumper::{DumpOutput, JsonDumper};\n+use json_dumper::{Access, DumpOutput, JsonDumper};\n use span_utils::SpanUtils;\n use sig;\n \n@@ -59,6 +59,15 @@ macro_rules! down_cast_data {\n     };\n }\n \n+macro_rules! access_from {\n+    ($save_ctxt:expr, $item:expr) => {\n+        Access {\n+            public: $item.vis == ast::Visibility::Public,\n+            reachable: $save_ctxt.analysis.access_levels.is_reachable($item.id),\n+        }\n+    }\n+}\n+\n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n@@ -341,7 +350,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                     self.dumper.dump_def(\n-                        false,\n+                        &Access {\n+                            public: false,\n+                            reachable: false,\n+                        },\n                         Def {\n                             kind: DefKind::Local,\n                             id,\n@@ -387,8 +399,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n-            self.dumper\n-                .dump_def(vis == ast::Visibility::Public, method_data);\n+            self.dumper.dump_def(\n+                &Access {\n+                    public: vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n+                },\n+                method_data);\n         }\n \n         // walk arg and return types\n@@ -409,8 +425,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper\n-                .dump_def(field.vis == ast::Visibility::Public, field_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, field), field_data);\n         }\n     }\n \n@@ -432,7 +447,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 let span = self.span_from_span(param_ss);\n \n                 self.dumper.dump_def(\n-                    false,\n+                    &Access {\n+                        public: false,\n+                        reachable: false,\n+                    },\n                     Def {\n                         kind: DefKind::Type,\n                         id,\n@@ -467,8 +485,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n-            self.dumper\n-                .dump_def(item.vis == ast::Visibility::Public, fn_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item), fn_data);\n         }\n \n         for arg in &decl.inputs {\n@@ -491,8 +508,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper\n-                    .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -516,14 +532,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         if !self.span.filter_generated(sub_span, span) {\n             let sig = sig::assoc_const_signature(id, name, typ, expr, &self.save_ctxt);\n-            let id = ::id_from_node_id(id, &self.save_ctxt);\n             let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n             self.dumper.dump_def(\n-                vis == ast::Visibility::Public,\n+                &Access {\n+                    public: vis == ast::Visibility::Public,\n+                    reachable: self.save_ctxt.analysis.access_levels.is_reachable(id),\n+                },\n                 Def {\n                     kind: DefKind::Const,\n-                    id,\n+                    id: ::id_from_node_id(id, &self.save_ctxt),\n                     span,\n                     name: name.to_string(),\n                     qualname,\n@@ -596,7 +614,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if !self.span.filter_generated(sub_span, item.span) {\n             let span = self.span_from_span(sub_span.expect(\"No span found for struct\"));\n             self.dumper.dump_def(\n-                item.vis == ast::Visibility::Public,\n+                &access_from!(self.save_ctxt, item),\n                 Def {\n                     kind,\n                     id: ::id_from_node_id(item.id, &self.save_ctxt),\n@@ -635,6 +653,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n+        let access = access_from!(self.save_ctxt, item);\n+\n         for variant in &enum_definition.variants {\n             let name = variant.node.name.name.to_string();\n             let mut qualname = enum_data.qualname.clone();\n@@ -660,7 +680,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n-                            item.vis == ast::Visibility::Public,\n+                            &access,\n                             Def {\n                                 kind: DefKind::StructVariant,\n                                 id,\n@@ -700,7 +720,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         let parent = Some(::id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n-                            item.vis == ast::Visibility::Public,\n+                            &access,\n                             Def {\n                                 kind: DefKind::TupleVariant,\n                                 id,\n@@ -730,8 +750,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n-        self.dumper\n-            .dump_def(item.vis == ast::Visibility::Public, enum_data);\n+        self.dumper.dump_def(&access, enum_data);\n     }\n \n     fn process_impl(\n@@ -783,7 +802,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 .map(|i| ::id_from_node_id(i.id, &self.save_ctxt))\n                 .collect();\n             self.dumper.dump_def(\n-                item.vis == ast::Visibility::Public,\n+                &access_from!(self.save_ctxt, item),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -846,8 +865,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper\n-                .dump_def(item.vis == ast::Visibility::Public, mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item), mod_data);\n         }\n     }\n \n@@ -1038,7 +1056,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                 self.dumper.dump_def(\n-                    false,\n+                    &Access {\n+                        public: false,\n+                        reachable: false,\n+                    },\n                     Def {\n                         kind: DefKind::Local,\n                         id,\n@@ -1138,7 +1159,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                     let id = ::id_from_node_id(trait_item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        true,\n+                        &Access {\n+                            public: true,\n+                            reachable: true,\n+                        },\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1225,7 +1249,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         let span = self.span_from_span(span);\n \n         self.dumper.dump_def(\n-            true,\n+            &Access {\n+                public: true,\n+                reachable: true,\n+            },\n             Def {\n                 kind: DefKind::Mod,\n                 id: data_id,\n@@ -1249,6 +1276,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         self.process_macro_use(item.span);\n         match item.node {\n             Use(ref use_item) => {\n+                let access = access_from!(self.save_ctxt, item);\n+\n                 match use_item.node {\n                     ast::ViewPathSimple(ident, ref path) => {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n@@ -1273,7 +1302,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use\"));\n                             self.dumper.import(\n-                                item.vis == ast::Visibility::Public,\n+                                &access,\n                                 Import {\n                                     kind: ImportKind::Use,\n                                     ref_id: mod_id.map(|id| ::id_from_def_id(id)),\n@@ -1302,7 +1331,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                             let span =\n                                 self.span_from_span(sub_span.expect(\"No span found for use glob\"));\n                             self.dumper.import(\n-                                item.vis == ast::Visibility::Public,\n+                                &access,\n                                 Import {\n                                     kind: ImportKind::GlobUse,\n                                     ref_id: None,\n@@ -1334,7 +1363,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let span =\n                         self.span_from_span(alias_span.expect(\"No span found for extern crate\"));\n                     self.dumper.import(\n-                        false,\n+                        &Access {\n+                            public: false,\n+                            reachable: false,\n+                        },\n                         Import {\n                             kind: ImportKind::ExternCrate,\n                             ref_id: None,\n@@ -1373,7 +1405,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     let id = ::id_from_node_id(item.id, &self.save_ctxt);\n \n                     self.dumper.dump_def(\n-                        item.vis == ast::Visibility::Public,\n+                        &access_from!(self.save_ctxt, item),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1596,7 +1628,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         let span = self.span_from_span(sp);\n \n                         self.dumper.dump_def(\n-                            false,\n+                            &Access {\n+                                public: false,\n+                                reachable: false,\n+                            },\n                             Def {\n                                 kind: DefKind::Local,\n                                 id,\n@@ -1662,6 +1697,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n+        let access = access_from!(self.save_ctxt, item);\n+\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 if let Some(fn_data) = self.save_ctxt.get_extern_item_data(item) {\n@@ -1672,8 +1709,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n                     );\n                     self.process_generic_params(generics, item.span, &fn_data.qualname, item.id);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, fn_data);\n+                    self.dumper.dump_def(&access, fn_data);\n                 }\n \n                 for arg in &decl.inputs {\n@@ -1687,17 +1723,15 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             ast::ForeignItemKind::Static(ref ty, _) => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper.dump_def(&access, var_data);\n                 }\n \n                 self.visit_ty(ty);\n             }\n             ast::ForeignItemKind::Ty => {\n                 if let Some(var_data) = self.save_ctxt.get_extern_item_data(item) {\n                     down_cast_data!(var_data, DefData, item.span);\n-                    self.dumper\n-                        .dump_def(item.vis == ast::Visibility::Public, var_data);\n+                    self.dumper.dump_def(&access, var_data);\n                 }\n             }\n         }"}, {"sha": "2b35a4123836bbd41306567fb569f128a58450e9", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10ef344d8c56563570a7647aa81e1586164f812b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=10ef344d8c56563570a7647aa81e1586164f812b", "patch": "@@ -17,6 +17,12 @@ use rls_data::{self, Analysis, CratePreludeData, Def, DefKind, Import, MacroRef,\n use rls_data::config::Config;\n use rls_span::{Column, Row};\n \n+#[derive(Debug)]\n+pub struct Access {\n+    pub reachable: bool,\n+    pub public: bool,\n+}\n+\n pub struct JsonDumper<O: DumpOutput> {\n     result: Analysis,\n     config: Config,\n@@ -84,33 +90,35 @@ impl<'b, O: DumpOutput + 'b> JsonDumper<O> {\n     }\n \n     pub fn macro_use(&mut self, data: MacroRef) {\n-        if self.config.pub_only {\n+        if self.config.pub_only || self.config.reachable_only {\n             return;\n         }\n         self.result.macro_refs.push(data);\n     }\n \n-    pub fn import(&mut self, public: bool, import: Import) {\n-        if !public && self.config.pub_only {\n+    pub fn import(&mut self, access: &Access, import: Import) {\n+        if !access.public && self.config.pub_only\n+            || !access.reachable && self.config.reachable_only {\n             return;\n         }\n         self.result.imports.push(import);\n     }\n \n     pub fn dump_ref(&mut self, data: Ref) {\n-        if self.config.pub_only {\n+        if self.config.pub_only || self.config.reachable_only {\n             return;\n         }\n         self.result.refs.push(data);\n     }\n \n-    pub fn dump_def(&mut self, public: bool, mut data: Def) {\n-        if !public && self.config.pub_only {\n+    pub fn dump_def(&mut self, access: &Access, mut data: Def) {\n+        if !access.public && self.config.pub_only\n+            || !access.reachable && self.config.reachable_only {\n             return;\n         }\n         if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n-            // If the module is an out-of-line defintion, then we'll make the\n-            // definition the first character in the module's file and turn the\n+            // If the module is an out-of-line definition, then we'll make the\n+            // definition the first character in the module's file and turn\n             // the declaration into a reference to it.\n             let rf = Ref {\n                 kind: RefKind::Mod,"}]}