{"sha": "d70f909fa3bdc1c8231f127882cc30f274b263d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MGY5MDlmYTNiZGMxYzgyMzFmMTI3ODgyY2MzMGYyNzRiMjYzZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T02:51:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-21T02:51:57Z"}, "message": "auto merge of #12164 : alexcrichton/rust/rlibs-and-dylibs, r=cmr\n\nThe first commit improves error messages during linking, and the second commit improves error messages during crate-loading time.\r\n\r\nCloses #12297\r\nCloses #12377", "tree": {"sha": "6da3e74b3cb0bd7a0910b5b73d0e147a044a0546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6da3e74b3cb0bd7a0910b5b73d0e147a044a0546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d70f909fa3bdc1c8231f127882cc30f274b263d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d70f909fa3bdc1c8231f127882cc30f274b263d1", "html_url": "https://github.com/rust-lang/rust/commit/d70f909fa3bdc1c8231f127882cc30f274b263d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d70f909fa3bdc1c8231f127882cc30f274b263d1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e9bcc545631f2e0a5c248206ae25831242affdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9bcc545631f2e0a5c248206ae25831242affdf", "html_url": "https://github.com/rust-lang/rust/commit/7e9bcc545631f2e0a5c248206ae25831242affdf"}, {"sha": "afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/afa5f574ff30714b578ded14de2dfdf7ca1a0f39", "html_url": "https://github.com/rust-lang/rust/commit/afa5f574ff30714b578ded14de2dfdf7ca1a0f39"}], "stats": {"total": 334, "additions": 240, "deletions": 94}, "files": [{"sha": "903a93816dd22e753485606fbfe162b4e213ab62", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 167, "deletions": 94, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=d70f909fa3bdc1c8231f127882cc30f274b263d1", "patch": "@@ -26,6 +26,7 @@ use syntax::attr::AttrMetaMethods;\n \n use std::c_str::ToCStr;\n use std::cast;\n+use std::hashmap::{HashMap, HashSet};\n use std::cmp;\n use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n@@ -69,6 +70,7 @@ impl Context {\n         match self.find_library_crate() {\n             Some(t) => t,\n             None => {\n+                self.sess.abort_if_errors();\n                 let message = match root_ident {\n                     None => format!(\"can't find crate for `{}`\", self.ident),\n                     Some(c) => format!(\"can't find crate for `{}` which `{}` depends on\",\n@@ -82,78 +84,107 @@ impl Context {\n \n     fn find_library_crate(&self) -> Option<Library> {\n         let filesearch = self.sess.filesearch;\n-        let crate_name = self.name.clone();\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n-        let dylib_prefix = format!(\"{}{}-\", dyprefix, crate_name);\n-        let rlib_prefix = format!(\"lib{}-\", crate_name);\n+        let dylib_prefix = format!(\"{}{}-\", dyprefix, self.name);\n+        let rlib_prefix = format!(\"lib{}-\", self.name);\n \n-        let mut matches = ~[];\n-        filesearch.search(|path| {\n-            match path.filename_str() {\n-                None => FileDoesntMatch,\n-                Some(file) => {\n-                    let (candidate, existing) = if file.starts_with(rlib_prefix) &&\n-                                                   file.ends_with(\".rlib\") {\n-                        debug!(\"{} is an rlib candidate\", path.display());\n-                        (true, self.add_existing_rlib(matches, path, file))\n-                    } else if file.starts_with(dylib_prefix) &&\n-                              file.ends_with(dysuffix) {\n-                        debug!(\"{} is a dylib candidate\", path.display());\n-                        (true, self.add_existing_dylib(matches, path, file))\n-                    } else {\n-                        (false, false)\n-                    };\n+        let mut candidates = HashMap::new();\n \n-                    if candidate && existing {\n+        // First, find all possible candidate rlibs and dylibs purely based on\n+        // the name of the files themselves. We're trying to match against an\n+        // exact crate_id and a possibly an exact hash.\n+        //\n+        // During this step, we can filter all found libraries based on the\n+        // name and id found in the crate id (we ignore the path portion for\n+        // filename matching), as well as the exact hash (if specified). If we\n+        // end up having many candidates, we must look at the metadata to\n+        // perform exact matches against hashes/crate ids. Note that opening up\n+        // the metadata is where we do an exact match against the full contents\n+        // of the crate id (path/name/id).\n+        //\n+        // The goal of this step is to look at as little metadata as possible.\n+        filesearch.search(|path| {\n+            let file = match path.filename_str() {\n+                None => return FileDoesntMatch,\n+                Some(file) => file,\n+            };\n+            if file.starts_with(rlib_prefix) && file.ends_with(\".rlib\") {\n+                info!(\"rlib candidate: {}\", path.display());\n+                match self.try_match(file, rlib_prefix, \".rlib\") {\n+                    Some(hash) => {\n+                        info!(\"rlib accepted, hash: {}\", hash);\n+                        let slot = candidates.find_or_insert_with(hash, |_| {\n+                            (HashSet::new(), HashSet::new())\n+                        });\n+                        let (ref mut rlibs, _) = *slot;\n+                        rlibs.insert(path.clone());\n                         FileMatches\n-                    } else if candidate {\n-                        match get_metadata_section(self.os, path) {\n-                            Some(cvec) =>\n-                                if crate_matches(cvec.as_slice(),\n-                                                 self.name.clone(),\n-                                                 self.version.clone(),\n-                                                 self.hash.clone()) {\n-                                    debug!(\"found {} with matching crate_id\",\n-                                           path.display());\n-                                    let (rlib, dylib) = if file.ends_with(\".rlib\") {\n-                                        (Some(path.clone()), None)\n-                                    } else {\n-                                        (None, Some(path.clone()))\n-                                    };\n-                                    matches.push(Library {\n-                                        rlib: rlib,\n-                                        dylib: dylib,\n-                                        metadata: cvec,\n-                                    });\n-                                    FileMatches\n-                                } else {\n-                                    debug!(\"skipping {}, crate_id doesn't match\",\n-                                           path.display());\n-                                    FileDoesntMatch\n-                                },\n-                                _ => {\n-                                    debug!(\"could not load metadata for {}\",\n-                                           path.display());\n-                                    FileDoesntMatch\n-                                }\n-                        }\n-                    } else {\n+                    }\n+                    None => {\n+                        info!(\"rlib rejected\");\n                         FileDoesntMatch\n                     }\n                 }\n+            } else if file.starts_with(dylib_prefix) && file.ends_with(dysuffix){\n+                info!(\"dylib candidate: {}\", path.display());\n+                match self.try_match(file, dylib_prefix, dysuffix) {\n+                    Some(hash) => {\n+                        info!(\"dylib accepted, hash: {}\", hash);\n+                        let slot = candidates.find_or_insert_with(hash, |_| {\n+                            (HashSet::new(), HashSet::new())\n+                        });\n+                        let (_, ref mut dylibs) = *slot;\n+                        dylibs.insert(path.clone());\n+                        FileMatches\n+                    }\n+                    None => {\n+                        info!(\"dylib rejected\");\n+                        FileDoesntMatch\n+                    }\n+                }\n+            } else {\n+                FileDoesntMatch\n             }\n         });\n \n-        match matches.len() {\n+        // We have now collected all known libraries into a set of candidates\n+        // keyed of the filename hash listed. For each filename, we also have a\n+        // list of rlibs/dylibs that apply. Here, we map each of these lists\n+        // (per hash), to a Library candidate for returning.\n+        //\n+        // A Library candidate is created if the metadata for the set of\n+        // libraries corresponds to the crate id and hash criteria that this\n+        // serach is being performed for.\n+        let mut libraries = ~[];\n+        for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n+            let mut metadata = None;\n+            let rlib = self.extract_one(rlibs, \"rlib\", &mut metadata);\n+            let dylib = self.extract_one(dylibs, \"dylib\", &mut metadata);\n+            match metadata {\n+                Some(metadata) => {\n+                    libraries.push(Library {\n+                        dylib: dylib,\n+                        rlib: rlib,\n+                        metadata: metadata,\n+                    })\n+                }\n+                None => {}\n+            }\n+        }\n+\n+        // Having now translated all relevant found hashes into libraries, see\n+        // what we've got and figure out if we found multiple candidates for\n+        // libraries or not.\n+        match libraries.len() {\n             0 => None,\n-            1 => Some(matches[0]),\n+            1 => Some(libraries[0]),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\", crate_name));\n+                    format!(\"multiple matching crates for `{}`\", self.name));\n                 self.sess.note(\"candidates:\");\n-                for lib in matches.iter() {\n+                for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\", p.display()));\n@@ -175,50 +206,90 @@ impl Context {\n                         }\n                     }\n                 }\n-                self.sess.abort_if_errors();\n                 None\n             }\n         }\n     }\n \n-    fn add_existing_rlib(&self, libs: &mut [Library],\n-                         path: &Path, file: &str) -> bool {\n-        let (prefix, suffix) = self.dylibname();\n-        let file = file.slice_from(3); // chop off 'lib'\n-        let file = file.slice_to(file.len() - 5); // chop off '.rlib'\n-        let file = format!(\"{}{}{}\", prefix, file, suffix);\n-\n-        for lib in libs.mut_iter() {\n-            match lib.dylib {\n-                Some(ref p) if p.filename_str() == Some(file.as_slice()) => {\n-                    assert!(lib.rlib.is_none()); // FIXME: legit compiler error\n-                    lib.rlib = Some(path.clone());\n-                    return true;\n-                }\n-                Some(..) | None => {}\n-            }\n+    // Attempts to match the requested version of a library against the file\n+    // specified. The prefix/suffix are specified (disambiguates between\n+    // rlib/dylib).\n+    //\n+    // The return value is `None` if `file` doesn't look like a rust-generated\n+    // library, or if a specific version was requested and it doens't match the\n+    // apparent file's version.\n+    //\n+    // If everything checks out, then `Some(hash)` is returned where `hash` is\n+    // the listed hash in the filename itself.\n+    fn try_match(&self, file: &str, prefix: &str, suffix: &str) -> Option<~str>{\n+        let middle = file.slice(prefix.len(), file.len() - suffix.len());\n+        debug!(\"matching -- {}, middle: {}\", file, middle);\n+        let mut parts = middle.splitn('-', 1);\n+        let hash = match parts.next() { Some(h) => h, None => return None };\n+        debug!(\"matching -- {}, hash: {}\", file, hash);\n+        let vers = match parts.next() { Some(v) => v, None => return None };\n+        debug!(\"matching -- {}, vers: {}\", file, vers);\n+        if !self.version.is_empty() && self.version.as_slice() != vers {\n+            return None\n+        }\n+        debug!(\"matching -- {}, vers ok (requested {})\", file,\n+               self.version);\n+        // hashes in filenames are prefixes of the \"true hash\"\n+        if self.hash.is_empty() || self.hash.starts_with(hash) {\n+            debug!(\"matching -- {}, hash ok (requested {})\", file, self.hash);\n+            Some(hash.to_owned())\n+        } else {\n+            None\n         }\n-        return false;\n     }\n \n-    fn add_existing_dylib(&self, libs: &mut [Library],\n-                          path: &Path, file: &str) -> bool {\n-        let (prefix, suffix) = self.dylibname();\n-        let file = file.slice_from(prefix.len());\n-        let file = file.slice_to(file.len() - suffix.len());\n-        let file = format!(\"lib{}.rlib\", file);\n+    // Attempts to extract *one* library from the set `m`. If the set has no\n+    // elements, `None` is returned. If the set has more than one element, then\n+    // the errors and notes are emitted about the set of libraries.\n+    //\n+    // With only one library in the set, this function will extract it, and then\n+    // read the metadata from it if `*slot` is `None`. If the metadata couldn't\n+    // be read, it is assumed that the file isn't a valid rust library (no\n+    // errors are emitted).\n+    //\n+    // FIXME(#10786): for an optimization, we only read one of the library's\n+    //                metadata sections. In theory we should read both, but\n+    //                reading dylib metadata is quite slow.\n+    fn extract_one(&self, m: HashSet<Path>, flavor: &str,\n+                   slot: &mut Option<MetadataBlob>) -> Option<Path> {\n+        if m.len() == 0 { return None }\n+        if m.len() > 1 {\n+            self.sess.span_err(self.span,\n+                               format!(\"multiple {} candidates for `{}` \\\n+                                        found\", flavor, self.name));\n+            for (i, path) in m.iter().enumerate() {\n+                self.sess.span_note(self.span,\n+                                    format!(r\"candidate \\#{}: {}\", i + 1,\n+                                            path.display()));\n+            }\n+            return None\n+        }\n \n-        for lib in libs.mut_iter() {\n-            match lib.rlib {\n-                Some(ref p) if p.filename_str() == Some(file.as_slice()) => {\n-                    assert!(lib.dylib.is_none()); // FIXME: legit compiler error\n-                    lib.dylib = Some(path.clone());\n-                    return true;\n+        let lib = m.move_iter().next().unwrap();\n+        if slot.is_none() {\n+            info!(\"{} reading meatadata from: {}\", flavor, lib.display());\n+            match get_metadata_section(self.os, &lib) {\n+                Some(blob) => {\n+                    if crate_matches(blob.as_slice(), self.name,\n+                                     self.version, self.hash) {\n+                        *slot = Some(blob);\n+                    } else {\n+                        info!(\"metadata mismatch\");\n+                        return None;\n+                    }\n+                }\n+                None => {\n+                    info!(\"no metadata found\");\n+                    return None\n                 }\n-                Some(..) | None => {}\n             }\n         }\n-        return false;\n+        return Some(lib);\n     }\n \n     // Returns the corresponding (prefix, suffix) that files need to have for\n@@ -239,16 +310,16 @@ pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n }\n \n fn crate_matches(crate_data: &[u8],\n-                 name: ~str,\n-                 version: ~str,\n-                 hash: ~str) -> bool {\n+                 name: &str,\n+                 version: &str,\n+                 hash: &str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     match attr::find_crateid(attrs) {\n         None => false,\n         Some(crateid) => {\n             if !hash.is_empty() {\n                 let chash = decoder::get_crate_hash(crate_data);\n-                if chash != hash { return false; }\n+                if chash.as_slice() != hash { return false; }\n             }\n             name == crateid.name &&\n                 (version.is_empty() ||\n@@ -383,7 +454,9 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n pub fn list_file_metadata(os: Os, path: &Path,\n                           out: &mut io::Writer) -> io::IoResult<()> {\n     match get_metadata_section(os, path) {\n-      Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n-      None => write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        Some(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n+        None => {\n+            write!(out, \"could not find metadata in {}.\\n\", path.display())\n+        }\n     }\n }"}, {"sha": "f06929a5deeecb6996cf422f246af5e132138ffb", "filename": "src/test/auxiliary/issue-11908-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11908-1.rs?ref=d70f909fa3bdc1c8231f127882cc30f274b263d1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_id = \"collections#0.10-pre\"];\n+#[crate_type = \"dylib\"];"}, {"sha": "345be34f377467874aa3d4d27501d525bfce1ffd", "filename": "src/test/auxiliary/issue-11908-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11908-2.rs?ref=d70f909fa3bdc1c8231f127882cc30f274b263d1", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#[crate_id = \"collections#0.10-pre\"];\n+#[crate_type = \"rlib\"];"}, {"sha": "207e953414b46784a533555236a9616e3da3d0f7", "filename": "src/test/compile-fail/issue-11908-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11908-1.rs?ref=d70f909fa3bdc1c8231f127882cc30f274b263d1", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-11908-1.rs\n+// ignore-android this test is incompatible with the android test runner\n+// error-pattern: multiple dylib candidates for `collections` found\n+\n+// This test ensures that if you have the same rlib or dylib at two locations\n+// in the same path that you don't hit an assertion in the compiler.\n+//\n+// Note that this relies on `libcollections` to be in the path somewhere else,\n+// and then our aux-built libraries will collide with libcollections (they have\n+// the same version listed)\n+\n+extern crate collections;\n+\n+fn main() {}"}, {"sha": "b4782c35762838ef68cd3e6d20c7144bd4ad5e6f", "filename": "src/test/compile-fail/issue-11908-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d70f909fa3bdc1c8231f127882cc30f274b263d1/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11908-2.rs?ref=d70f909fa3bdc1c8231f127882cc30f274b263d1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-11908-2.rs\n+// no-prefer-dynamic\n+// ignore-android this test is incompatible with the android test runner\n+// error-pattern: multiple rlib candidates for `collections` found\n+\n+// see comments in issue-11908-1 for what's going on here\n+\n+extern crate collections;\n+\n+fn main() {}\n+"}]}