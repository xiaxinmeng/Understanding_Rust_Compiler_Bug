{"sha": "79dd92fc1638463ab8af1d275686c4751ce91465", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZGQ5MmZjMTYzODQ2M2FiOGFmMWQyNzU2ODZjNDc1MWNlOTE0NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T21:47:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T21:47:33Z"}, "message": "Auto merge of #27930 - barosl:path_max, r=alexcrichton\n\nThis PR rewrites the code that previously relied on `PATH_MAX`.\r\n\r\nOn my tests, even though the user gives the buffer length explicitly, both Linux's glibc and OS X's libc seems to obey the hard limit of `PATH_MAX` internally. So, to truly remove the limitation of `PATH_MAX`, the related system calls should be rewritten from scratch in Rust, which this PR does not try to do.\r\n\r\nHowever, eliminating the need of `PATH_MAX` is still a good idea for various reasons, such as: (1) they might change the implementation in the future, and (2) some platforms don't have a hard-coded `PATH_MAX`, such as GNU Hurd.\r\n\r\nMore details are in the commit messages.\r\n\r\nFixes #27454.\r\n\r\nr? @alexcrichton", "tree": {"sha": "8f988bfd316630886eab6f2e98fded7ad77ab422", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f988bfd316630886eab6f2e98fded7ad77ab422"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79dd92fc1638463ab8af1d275686c4751ce91465", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79dd92fc1638463ab8af1d275686c4751ce91465", "html_url": "https://github.com/rust-lang/rust/commit/79dd92fc1638463ab8af1d275686c4751ce91465", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79dd92fc1638463ab8af1d275686c4751ce91465/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abfa081c10c9401c8a2f858497fbac583bae234d", "url": "https://api.github.com/repos/rust-lang/rust/commits/abfa081c10c9401c8a2f858497fbac583bae234d", "html_url": "https://github.com/rust-lang/rust/commit/abfa081c10c9401c8a2f858497fbac583bae234d"}, {"sha": "6065678e627643cc3275c677408d11f48802595e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6065678e627643cc3275c677408d11f48802595e", "html_url": "https://github.com/rust-lang/rust/commit/6065678e627643cc3275c677408d11f48802595e"}], "stats": {"total": 82, "additions": 59, "deletions": 23}, "files": [{"sha": "c4d2dc838942a852a7f43f2bb356bc6502bd89ca", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=79dd92fc1638463ab8af1d275686c4751ce91465", "patch": "@@ -3920,6 +3920,8 @@ pub mod consts {\n             pub const _SC_XBS5_ILP32_OFFBIG : c_int = 126;\n             pub const _SC_XBS5_LPBIG_OFFBIG : c_int = 128;\n \n+            pub const _PC_NAME_MAX: c_int = 3;\n+            pub const _PC_PATH_MAX: c_int = 4;\n         }\n         #[cfg(target_os = \"nacl\")]\n         pub mod sysconf {\n@@ -3928,6 +3930,9 @@ pub mod consts {\n             pub static _SC_SENDMSG_MAX_SIZE : c_int = 0;\n             pub static _SC_NPROCESSORS_ONLN : c_int = 1;\n             pub static _SC_PAGESIZE : c_int = 2;\n+\n+            pub const _PC_NAME_MAX: c_int = 3;\n+            pub const _PC_PATH_MAX: c_int = 4;\n         }\n \n         #[cfg(target_os = \"android\")]\n@@ -3963,6 +3968,9 @@ pub mod consts {\n             pub const _SC_STREAM_MAX : c_int = 27;\n             pub const _SC_TZNAME_MAX : c_int = 28;\n             pub const _SC_PAGESIZE : c_int = 39;\n+\n+            pub const _PC_NAME_MAX: c_int = 4;\n+            pub const _PC_PATH_MAX: c_int = 5;\n         }\n     }\n \n@@ -4433,6 +4441,9 @@ pub mod consts {\n             pub const _SC_SEM_VALUE_MAX : c_int = 50;\n             pub const _SC_SIGQUEUE_MAX : c_int = 51;\n             pub const _SC_TIMER_MAX : c_int = 52;\n+\n+            pub const _PC_NAME_MAX: c_int = 4;\n+            pub const _PC_PATH_MAX: c_int = 5;\n         }\n     }\n \n@@ -4868,6 +4879,9 @@ pub mod consts {\n             pub const _SC_SYNCHRONIZED_IO : c_int = 75;\n             pub const _SC_TIMER_MAX : c_int = 93;\n             pub const _SC_TIMERS : c_int = 94;\n+\n+            pub const _PC_NAME_MAX: c_int = 4;\n+            pub const _PC_PATH_MAX: c_int = 5;\n         }\n     }\n \n@@ -5379,6 +5393,9 @@ pub mod consts {\n             pub const _SC_TRACE_SYS_MAX : c_int = 129;\n             pub const _SC_TRACE_USER_EVENT_MAX : c_int = 130;\n             pub const _SC_PASS_MAX : c_int = 131;\n+\n+            pub const _PC_NAME_MAX: c_int = 4;\n+            pub const _PC_PATH_MAX: c_int = 5;\n         }\n     }\n }\n@@ -5835,8 +5852,6 @@ pub mod funcs {\n             use types::os::arch::posix88::{gid_t, off_t, pid_t};\n             use types::os::arch::posix88::{ssize_t, uid_t};\n \n-            pub const _PC_NAME_MAX: c_int = 4;\n-\n             #[cfg(not(target_os = \"nacl\"))]\n             extern {\n                 pub fn access(path: *const c_char, amode: c_int) -> c_int;"}, {"sha": "0eebe5af9197dc07601845769e924ef1071f60e4", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=79dd92fc1638463ab8af1d275686c4751ce91465", "patch": "@@ -376,13 +376,19 @@ impl fmt::Debug for File {\n \n         #[cfg(target_os = \"macos\")]\n         fn get_path(fd: c_int) -> Option<PathBuf> {\n+            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n+            // is inevitable in this case because OS X defines `fcntl` with\n+            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n+            // alternatives. If a better method is invented, it should be used\n+            // instead.\n             let mut buf = vec![0;libc::PATH_MAX as usize];\n             let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n             if n == -1 {\n                 return None;\n             }\n             let l = buf.iter().position(|&c| c == 0).unwrap();\n             buf.truncate(l as usize);\n+            buf.shrink_to_fit();\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n@@ -466,18 +472,27 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();\n-    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n-    if len < 0 {\n-        len = 1024; // FIXME: read PATH_MAX from C ffi?\n-    }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as usize);\n-    unsafe {\n-        let n = try!(cvt({\n-            libc::readlink(p, buf.as_ptr() as *mut c_char, len as size_t)\n-        }));\n-        buf.set_len(n as usize);\n+\n+    let mut buf = Vec::with_capacity(256);\n+\n+    loop {\n+        let buf_read = try!(cvt(unsafe {\n+            libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity() as libc::size_t)\n+        })) as usize;\n+\n+        unsafe { buf.set_len(buf_read); }\n+\n+        if buf_read != buf.capacity() {\n+            buf.shrink_to_fit();\n+\n+            return Ok(PathBuf::from(OsString::from_vec(buf)));\n+        }\n+\n+        // Trigger the internal buffer resizing logic of `Vec` by requiring\n+        // more space than the current capacity. The length is guaranteed to be\n+        // the same as the capacity due to the if statement above.\n+        buf.reserve(1);\n     }\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n@@ -514,15 +529,15 @@ pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let path = try!(CString::new(p.as_os_str().as_bytes()));\n-    let mut buf = vec![0u8; 16 * 1024];\n+    let buf;\n     unsafe {\n-        let r = c::realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n+        let r = c::realpath(path.as_ptr(), ptr::null_mut());\n         if r.is_null() {\n             return Err(io::Error::last_os_error())\n         }\n+        buf = CStr::from_ptr(r).to_bytes().to_vec();\n+        libc::free(r as *mut _);\n     }\n-    let p = buf.iter().position(|i| *i == 0).unwrap();\n-    buf.truncate(p);\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n "}, {"sha": "fa31ac682d40bd04878edcd40807f4d2c881f077", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=79dd92fc1638463ab8af1d275686c4751ce91465", "patch": "@@ -30,7 +30,6 @@ use sys::c;\n use sys::fd;\n use vec;\n \n-const GETCWD_BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n /// Returns the platform-specific value of errno\n@@ -94,11 +93,9 @@ pub fn error_string(errno: i32) -> String {\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n-    let mut buf = Vec::new();\n-    let mut n = GETCWD_BUF_BYTES;\n+    let mut buf = Vec::with_capacity(512);\n     loop {\n         unsafe {\n-            buf.reserve(n);\n             let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n             if !libc::getcwd(ptr, buf.capacity() as libc::size_t).is_null() {\n                 let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n@@ -111,7 +108,12 @@ pub fn getcwd() -> io::Result<PathBuf> {\n                     return Err(error);\n                 }\n             }\n-            n *= 2;\n+\n+            // Trigger the internal buffer resizing logic of `Vec` by requiring\n+            // more space than the current capacity.\n+            let cap = buf.capacity();\n+            buf.set_len(cap);\n+            buf.reserve(1);\n         }\n     }\n }"}, {"sha": "37ce30d7066f77801da733c2cc37bae7f85489e2", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/79dd92fc1638463ab8af1d275686c4751ce91465/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=79dd92fc1638463ab8af1d275686c4751ce91465", "patch": "@@ -341,7 +341,11 @@ const char * rust_current_exe()\n   char **paths;\n   size_t sz;\n   int i;\n-  char buf[2*PATH_MAX], exe[2*PATH_MAX];\n+  /* If `PATH_MAX` is defined on the platform, `realpath` will truncate the\n+   * resolved path up to `PATH_MAX`. While this can make the resolution fail if\n+   * the executable is placed in a deep path, the usage of a buffer whose\n+   * length depends on `PATH_MAX` is still memory safe. */\n+  char buf[2*PATH_MAX], exe[PATH_MAX];\n \n   if (self != NULL)\n     return self;"}]}