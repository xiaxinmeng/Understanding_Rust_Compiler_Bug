{"sha": "2b07f0fb0018649588cda06bd33c33b71c5cac70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMDdmMGZiMDAxODY0OTU4OGNkYTA2YmQzM2MzM2I3MWM1Y2FjNzA=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-12T18:37:31Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-03-29T17:53:00Z"}, "message": "field renaming", "tree": {"sha": "efb4d53d1f2f19b9e8d13f5745b6425686d53d0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb4d53d1f2f19b9e8d13f5745b6425686d53d0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b07f0fb0018649588cda06bd33c33b71c5cac70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b07f0fb0018649588cda06bd33c33b71c5cac70", "html_url": "https://github.com/rust-lang/rust/commit/2b07f0fb0018649588cda06bd33c33b71c5cac70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b07f0fb0018649588cda06bd33c33b71c5cac70/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "706ed6dd532eaf8848e60f4368ad519647a41107", "url": "https://api.github.com/repos/rust-lang/rust/commits/706ed6dd532eaf8848e60f4368ad519647a41107", "html_url": "https://github.com/rust-lang/rust/commit/706ed6dd532eaf8848e60f4368ad519647a41107"}], "stats": {"total": 57, "additions": 29, "deletions": 28}, "files": [{"sha": "f0e1273534ab18ea82d218745c49dbb27d3cfe8d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2b07f0fb0018649588cda06bd33c33b71c5cac70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b07f0fb0018649588cda06bd33c33b71c5cac70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=2b07f0fb0018649588cda06bd33c33b71c5cac70", "patch": "@@ -26,7 +26,7 @@ use core::vec;\n    `~` */\n ///an unzipping of `token_tree`s\n struct TtFrame {\n-    readme: @mut ~[ast::token_tree],\n+    forest: @mut ~[ast::token_tree],\n     idx: uint,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -37,7 +37,7 @@ pub struct TtReader {\n     sp_diag: @span_handler,\n     interner: @ident_interner,\n     // the unzipped tree:\n-    cur: @mut TtFrame,\n+    stack: @mut TtFrame,\n     /* for MBE-style macro transcription */\n     interpolations: LinearMap<ident, @named_match>,\n     repeat_idx: ~[uint],\n@@ -58,8 +58,8 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n         interner: itr,\n-        cur: @mut TtFrame {\n-            readme: @mut src,\n+        stack: @mut TtFrame {\n+            forest: @mut src,\n             idx: 0u,\n             dotdotdoted: false,\n             sep: None,\n@@ -81,7 +81,7 @@ pub fn new_tt_reader(sp_diag: @span_handler,\n \n fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n     @mut TtFrame {\n-        readme: @mut (copy *f.readme),\n+        forest: @mut (copy *f.forest),\n         idx: f.idx,\n         dotdotdoted: f.dotdotdoted,\n         sep: copy f.sep,\n@@ -96,7 +96,7 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n         interner: r.interner,\n-        cur: dup_tt_frame(r.cur),\n+        stack: dup_tt_frame(r.stack),\n         interpolations: r.interpolations,\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n@@ -167,45 +167,46 @@ fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n     }\n }\n \n-\n+// return the next token from the TtReader.\n+// EFFECT: advances the reader's token field\n pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     let ret_val = TokenAndSpan {\n         tok: copy r.cur_tok,\n         sp: r.cur_span,\n     };\n     loop {\n         {\n-            let cur = &mut *r.cur;\n-            let readme = &mut *cur.readme;\n-            if cur.idx < readme.len() {\n+            let stack = &mut *r.stack;\n+            let forest = &mut *stack.forest;\n+            if stack.idx < forest.len() {\n                 break;\n             }\n         }\n \n         /* done with this set; pop or repeat? */\n-        if ! r.cur.dotdotdoted\n+        if ! r.stack.dotdotdoted\n             || { *r.repeat_idx.last() == *r.repeat_len.last() - 1 } {\n \n-            match r.cur.up {\n+            match r.stack.up {\n               None => {\n                 r.cur_tok = EOF;\n                 return ret_val;\n               }\n               Some(tt_f) => {\n-                if r.cur.dotdotdoted {\n+                if r.stack.dotdotdoted {\n                     r.repeat_idx.pop();\n                     r.repeat_len.pop();\n                 }\n \n-                r.cur = tt_f;\n-                r.cur.idx += 1u;\n+                r.stack = tt_f;\n+                r.stack.idx += 1u;\n               }\n             }\n \n         } else { /* repeat */\n-            r.cur.idx = 0u;\n+            r.stack.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n-            match r.cur.sep {\n+            match r.stack.sep {\n               Some(copy tk) => {\n                 r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n@@ -216,21 +217,21 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n     }\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n-        match r.cur.readme[r.cur.idx] {\n+        match r.stack.forest[r.stack.idx] {\n           tt_delim(copy tts) => {\n-            r.cur = @mut TtFrame {\n-                readme: @mut tts,\n+            r.stack = @mut TtFrame {\n+                forest: @mut tts,\n                 idx: 0u,\n                 dotdotdoted: false,\n                 sep: None,\n-                up: option::Some(r.cur)\n+                up: option::Some(r.stack)\n             };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n           tt_tok(sp, copy tok) => {\n             r.cur_span = sp;\n             r.cur_tok = tok;\n-            r.cur.idx += 1u;\n+            r.stack.idx += 1u;\n             return ret_val;\n           }\n           tt_seq(sp, copy tts, copy sep, zerok) => {\n@@ -256,17 +257,17 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                                once\");\n                           }\n \n-                    r.cur.idx += 1u;\n+                    r.stack.idx += 1u;\n                     return tt_next_token(r);\n                 } else {\n                     r.repeat_len.push(len);\n                     r.repeat_idx.push(0u);\n-                    r.cur = @mut TtFrame {\n-                        readme: @mut tts,\n+                    r.stack = @mut TtFrame {\n+                        forest: @mut tts,\n                         idx: 0u,\n                         dotdotdoted: true,\n                         sep: sep,\n-                        up: Some(r.cur)\n+                        up: Some(r.stack)\n                     };\n                 }\n               }\n@@ -280,13 +281,13 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               (b) we actually can, since it's a token. */\n               matched_nonterminal(nt_ident(sn,b)) => {\n                 r.cur_span = sp; r.cur_tok = IDENT(sn,b);\n-                r.cur.idx += 1u;\n+                r.stack.idx += 1u;\n                 return ret_val;\n               }\n               matched_nonterminal(ref other_whole_nt) => {\n                 r.cur_span = sp;\n                 r.cur_tok = INTERPOLATED(copy *other_whole_nt);\n-                r.cur.idx += 1u;\n+                r.stack.idx += 1u;\n                 return ret_val;\n               }\n               matched_seq(*) => {"}]}