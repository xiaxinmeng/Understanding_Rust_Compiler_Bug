{"sha": "4968600740b7ca71f4c5d0b0badc1082202f199c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Njg2MDA3NDBiN2NhNzFmNGM1ZDBiMGJhZGMxMDgyMjAyZjE5OWM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-19T09:13:03Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-24T00:45:04Z"}, "message": "Refactor away `metadata::creader::Macros`.", "tree": {"sha": "fd1496b48d880d389f56ea5ca501e76e2cc614df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1496b48d880d389f56ea5ca501e76e2cc614df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4968600740b7ca71f4c5d0b0badc1082202f199c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4968600740b7ca71f4c5d0b0badc1082202f199c", "html_url": "https://github.com/rust-lang/rust/commit/4968600740b7ca71f4c5d0b0badc1082202f199c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4968600740b7ca71f4c5d0b0badc1082202f199c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53de24bbd1b87cf37457568f67c2b483f196de9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/53de24bbd1b87cf37457568f67c2b483f196de9b", "html_url": "https://github.com/rust-lang/rust/commit/53de24bbd1b87cf37457568f67c2b483f196de9b"}], "stats": {"total": 88, "additions": 30, "deletions": 58}, "files": [{"sha": "440571de2409909e0bad3916f7d0dec930121f73", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 30, "deletions": 58, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4968600740b7ca71f4c5d0b0badc1082202f199c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4968600740b7ca71f4c5d0b0badc1082202f199c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=4968600740b7ca71f4c5d0b0badc1082202f199c", "patch": "@@ -148,17 +148,6 @@ enum LoadResult {\n     Loaded(Library),\n }\n \n-pub struct Macros {\n-    pub macro_rules: Vec<ast::MacroDef>,\n-\n-    /// An array of pairs where the first element is the name of the custom\n-    /// derive (e.g. the trait being derived) and the second element is the\n-    /// index of the definition.\n-    pub custom_derive_registrar: Option<DefIndex>,\n-    pub svh: Svh,\n-    pub dylib: Option<PathBuf>,\n-}\n-\n impl<'a> CrateLoader<'a> {\n     pub fn new(sess: &'a Session,\n                cstore: &'a CStore,\n@@ -554,18 +543,13 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    pub fn read_macros(&mut self, item: &ast::Item) -> Macros {\n+    pub fn read_macros(&mut self, item: &ast::Item) -> LoadedMacros {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n-\n         let root = ekrate.metadata.get_root();\n         let source_name = format!(\"<{} macros>\", item.ident);\n-        let mut ret = Macros {\n-            macro_rules: Vec::new(),\n-            custom_derive_registrar: None,\n-            svh: root.hash,\n-            dylib: None,\n-        };\n+        let mut macro_rules = Vec::new();\n+\n         for def in root.macro_defs.decode(&*ekrate.metadata) {\n             // NB: Don't use parse::parse_tts_from_source_str because it parses with\n             // quote_depth > 0.\n@@ -589,7 +573,7 @@ impl<'a> CrateLoader<'a> {\n                 attr::mark_used(attr);\n             }\n \n-            ret.macro_rules.push(ast::MacroDef {\n+            macro_rules.push(ast::MacroDef {\n                 ident: ast::Ident::with_empty_ctxt(def.name),\n                 id: ast::DUMMY_NODE_ID,\n                 span: local_span,\n@@ -602,37 +586,34 @@ impl<'a> CrateLoader<'a> {\n                 .insert(local_span, (def.name.as_str().to_string(), def.span));\n         }\n \n-        match root.macro_derive_registrar {\n-            Some(id) => ret.custom_derive_registrar = Some(id),\n+        if let Some(id) = root.macro_derive_registrar {\n+            let dylib = match ekrate.dylib.clone() {\n+                Some(dylib) => dylib,\n+                None => span_bug!(item.span, \"proc-macro crate not dylib\"),\n+            };\n+            if ekrate.target_only {\n+                let message = format!(\"proc-macro crate is not available for \\\n+                                       triple `{}` (only found {})\",\n+                                      config::host_triple(),\n+                                      self.sess.opts.target_triple);\n+                self.sess.span_fatal(item.span, &message);\n+            }\n \n+            // custom derive crates currently should not have any macro_rules!\n+            // exported macros, enforced elsewhere\n+            assert_eq!(macro_rules.len(), 0);\n+            LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n+        } else {\n             // If this crate is not a proc-macro crate then we might be able to\n             // register it with the local crate store to prevent loading the\n             // metadata twice.\n             //\n             // If it's a proc-macro crate, though, then we definitely don't\n             // want to register it with the local crate store as we're just\n             // going to use it as we would a plugin.\n-            None => {\n-                ekrate.register(self);\n-                return ret\n-            }\n-        }\n-\n-        self.cstore.add_used_for_derive_macros(item);\n-        ret.dylib = ekrate.dylib.clone();\n-        if ret.dylib.is_none() {\n-            span_bug!(item.span, \"proc-macro crate not dylib\");\n+            ekrate.register(self);\n+            LoadedMacros::MacroRules(macro_rules)\n         }\n-\n-        if ekrate.target_only {\n-            let message = format!(\"proc-macro crate is not available for \\\n-                                   triple `{}` (only found {})\",\n-                                  config::host_triple(),\n-                                  self.sess.opts.target_triple);\n-            self.sess.span_fatal(item.span, &message);\n-        }\n-\n-        return ret\n     }\n \n     /// Load custom derive macros.\n@@ -642,27 +623,28 @@ impl<'a> CrateLoader<'a> {\n     /// implemented as dynamic libraries, but we have a possible future where\n     /// custom derive (and other macro-1.1 style features) are implemented via\n     /// executables and custom IPC.\n-    fn load_derive_macros(&mut self, span: Span, macros: &Macros, index: DefIndex)\n+    fn load_derive_macros(&mut self, item: &ast::Item, index: DefIndex, svh: Svh, path: PathBuf)\n                           -> Vec<(ast::Name, SyntaxExtension)> {\n         use std::{env, mem};\n         use proc_macro::TokenStream;\n         use proc_macro::__internal::Registry;\n         use rustc_back::dynamic_lib::DynamicLibrary;\n         use syntax_ext::deriving::custom::CustomDerive;\n \n+        self.cstore.add_used_for_derive_macros(item);\n+\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = macros.dylib.as_ref().unwrap();\n         let path = env::current_dir().unwrap().join(path);\n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,\n-            Err(err) => self.sess.span_fatal(span, &err),\n+            Err(err) => self.sess.span_fatal(item.span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&macros.svh, index);\n+        let sym = self.sess.generate_derive_registrar_symbol(&svh, index);\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n                 Ok(f) => f,\n-                Err(err) => self.sess.span_fatal(span, &err),\n+                Err(err) => self.sess.span_fatal(item.span, &err),\n             };\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n@@ -1079,16 +1061,6 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n     }\n \n     fn load_macros(&mut self, extern_crate: &ast::Item) -> LoadedMacros {\n-        let macros = self.read_macros(extern_crate);\n-\n-        if let Some(index) = macros.custom_derive_registrar {\n-            // custom derive crates currently should not have any macro_rules!\n-            // exported macros, enforced elsewhere\n-            assert_eq!(macros.macro_rules.len(), 0);\n-            let custom_derives = self.load_derive_macros(extern_crate.span, &macros, index);\n-            LoadedMacros::ProcMacros(custom_derives)\n-        } else {\n-            LoadedMacros::MacroRules(macros.macro_rules)\n-        }\n+        self.read_macros(extern_crate)\n     }\n }"}]}