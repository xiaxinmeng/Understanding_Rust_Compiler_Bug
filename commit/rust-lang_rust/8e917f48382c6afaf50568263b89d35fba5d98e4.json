{"sha": "8e917f48382c6afaf50568263b89d35fba5d98e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTE3ZjQ4MzgyYzZhZmFmNTA1NjgyNjNiODlkMzVmYmE1ZDk4ZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T08:33:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-03T08:33:07Z"}, "message": "Auto merge of #62946 - RalfJung:miri_type_dispatch_first, r=oli-obk\n\nMiri: dispatch first on the type\n\nBased on the fact that Miri now always has intptrcast available, we can change binops and casts to first check the type of the source operand and then decide based on that what to do, instead of considering the value (pointer vs bits) first.", "tree": {"sha": "526f3b2e51de9bf015c9589c48fb7ec6d4d29385", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/526f3b2e51de9bf015c9589c48fb7ec6d4d29385"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e917f48382c6afaf50568263b89d35fba5d98e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e917f48382c6afaf50568263b89d35fba5d98e4", "html_url": "https://github.com/rust-lang/rust/commit/8e917f48382c6afaf50568263b89d35fba5d98e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e917f48382c6afaf50568263b89d35fba5d98e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7270712cb446aad0817040bbca73a8d024f67b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7270712cb446aad0817040bbca73a8d024f67b0", "html_url": "https://github.com/rust-lang/rust/commit/d7270712cb446aad0817040bbca73a8d024f67b0"}, {"sha": "b9db95edb1136de4230bb2e130c4e09b06f7f3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9db95edb1136de4230bb2e130c4e09b06f7f3a7", "html_url": "https://github.com/rust-lang/rust/commit/b9db95edb1136de4230bb2e130c4e09b06f7f3a7"}], "stats": {"total": 325, "additions": 160, "deletions": 165}, "files": [{"sha": "2b14558de6916a2f783e40b01070b8221ad94dd6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -1863,6 +1863,12 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Tests if this is any kind of primitive pointer type (reference, raw pointer, fn pointer).\n+    #[inline]\n+    pub fn is_any_ptr(&self) -> bool {\n+        self.is_region_ptr() || self.is_unsafe_ptr() || self.is_fn_ptr()\n+    }\n+\n     /// Returns `true` if this type is an `Arc<T>`.\n     #[inline]\n     pub fn is_arc(&self) -> bool {"}, {"sha": "54cf56258f9f27a72eaa4bdd7caaa722b545f488", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -20,10 +20,10 @@ use rustc_data_structures::fx::FxHashMap;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n+    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n-    Allocation, AllocId, MemoryKind,\n+    Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n@@ -397,7 +397,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         )\n     }\n \n-    fn ptr_op(\n+    fn ptr_to_int(\n+        _mem: &Memory<'mir, 'tcx, Self>,\n+        _ptr: Pointer,\n+    ) -> InterpResult<'tcx, u64> {\n+        Err(\n+            ConstEvalError::NeedsRfc(\"pointer-to-integer cast\".to_string()).into(),\n+        )\n+    }\n+\n+    fn binary_ptr_op(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,"}, {"sha": "1dbf1d094055780f17eec86c472cabc9dbe3854d", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 65, "deletions": 91, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -7,22 +7,13 @@ use syntax::symbol::sym;\n use rustc_apfloat::ieee::{Single, Double};\n use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n-    Scalar, InterpResult, Pointer, PointerArithmetic,\n+    Scalar, InterpResult, PointerArithmetic,\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, ImmTy, Immediate, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::RawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::Ref(_, ty, _) => !self.type_is_sized(ty),\n-            ty::Adt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n-            _ => false,\n-        }\n-    }\n-\n     pub fn cast(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n@@ -37,40 +28,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Misc | Pointer(PointerCast::MutToConstPointer) => {\n                 let src = self.read_immediate(src)?;\n-\n-                if self.type_is_fat_ptr(src.layout.ty) {\n-                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n-                        // pointers to extern types\n-                        (Immediate::Scalar(_),_) |\n-                        // slices and trait objects to other slices/trait objects\n-                        (Immediate::ScalarPair(..), true) => {\n-                            // No change to immediate\n-                            self.write_immediate(*src, dest)?;\n-                        }\n-                        // slices and trait objects to thin pointers (dropping the metadata)\n-                        (Immediate::ScalarPair(data, _), false) => {\n-                            self.write_scalar(data, dest)?;\n-                        }\n-                    }\n-                } else {\n-                    match src.layout.variants {\n-                        layout::Variants::Single { index } => {\n-                            if let Some(discr) =\n-                                src.layout.ty.discriminant_for_variant(*self.tcx, index)\n-                            {\n-                                // Cast from a univariant enum\n-                                assert!(src.layout.is_zst());\n-                                return self.write_scalar(\n-                                    Scalar::from_uint(discr.val, dest.layout.size),\n-                                    dest);\n-                            }\n-                        }\n-                        layout::Variants::Multiple { .. } => {},\n-                    }\n-\n-                    let dest_val = self.cast_scalar(src.to_scalar()?, src.layout, dest.layout)?;\n-                    self.write_scalar(dest_val, dest)?;\n-                }\n+                let res = self.cast_immediate(src, dest.layout)?;\n+                self.write_immediate(res, dest)?;\n             }\n \n             Pointer(PointerCast::ReifyFnPointer) => {\n@@ -126,36 +85,76 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn cast_scalar(\n+    fn cast_immediate(\n         &self,\n-        val: Scalar<M::PointerTag>,\n-        src_layout: TyLayout<'tcx>,\n+        src: ImmTy<'tcx, M::PointerTag>,\n         dest_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n         use rustc::ty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n+        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, dest_layout.ty);\n \n-        match src_layout.ty.sty {\n+        match src.layout.ty.sty {\n             // Floating point\n-            Float(FloatTy::F32) => self.cast_from_float(val.to_f32()?, dest_layout.ty),\n-            Float(FloatTy::F64) => self.cast_from_float(val.to_f64()?, dest_layout.ty),\n-            // Integer(-like), including fn ptr casts and casts from enums that\n-            // are represented as integers (this excludes univariant enums, which\n-            // are handled in `cast` directly).\n-            _ => {\n+            Float(FloatTy::F32) =>\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, dest_layout.ty)?.into()),\n+            Float(FloatTy::F64) =>\n+                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, dest_layout.ty)?.into()),\n+            // The rest is integer/pointer-\"like\", including fn ptr casts and casts from enums that\n+            // are represented as integers.\n+            _ =>\n                 assert!(\n-                    src_layout.ty.is_bool()       || src_layout.ty.is_char()     ||\n-                    src_layout.ty.is_enum()       || src_layout.ty.is_integral() ||\n-                    src_layout.ty.is_unsafe_ptr() || src_layout.ty.is_fn_ptr()   ||\n-                    src_layout.ty.is_region_ptr(),\n-                    \"Unexpected cast from type {:?}\", src_layout.ty\n-                );\n-                match val.to_bits_or_ptr(src_layout.size, self) {\n-                    Err(ptr) => self.cast_from_ptr(ptr, src_layout, dest_layout),\n-                    Ok(data) => self.cast_from_int(data, src_layout, dest_layout),\n+                    src.layout.ty.is_bool()       || src.layout.ty.is_char()     ||\n+                    src.layout.ty.is_enum()       || src.layout.ty.is_integral() ||\n+                    src.layout.ty.is_any_ptr(),\n+                    \"Unexpected cast from type {:?}\", src.layout.ty\n+                )\n+        }\n+\n+        // Handle cast from a univariant (ZST) enum.\n+        match src.layout.variants {\n+            layout::Variants::Single { index } => {\n+                if let Some(discr) =\n+                    src.layout.ty.discriminant_for_variant(*self.tcx, index)\n+                {\n+                    assert!(src.layout.is_zst());\n+                    return Ok(Scalar::from_uint(discr.val, dest_layout.size).into());\n                 }\n             }\n+            layout::Variants::Multiple { .. } => {},\n+        }\n+\n+        // Handle casting the metadata away from a fat pointer.\n+        if src.layout.ty.is_unsafe_ptr() && dest_layout.ty.is_unsafe_ptr() &&\n+            dest_layout.size != src.layout.size\n+        {\n+            assert_eq!(src.layout.size, 2*self.memory.pointer_size());\n+            assert_eq!(dest_layout.size, self.memory.pointer_size());\n+            assert!(dest_layout.ty.is_unsafe_ptr());\n+            match *src {\n+                Immediate::ScalarPair(data, _) =>\n+                    return Ok(data.into()),\n+                Immediate::Scalar(..) =>\n+                    bug!(\n+                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                        *src, src.layout.ty, dest_layout.ty\n+                    ),\n+            };\n+        }\n+\n+        // Handle casting any ptr to raw ptr (might be a fat ptr).\n+        if src.layout.ty.is_any_ptr() && dest_layout.ty.is_unsafe_ptr()\n+        {\n+            // The only possible size-unequal case was handled above.\n+            assert_eq!(src.layout.size, dest_layout.size);\n+            return Ok(*src);\n         }\n+\n+        // For all remaining casts, we either\n+        // (a) cast a raw ptr to usize, or\n+        // (b) cast from an integer-like (including bool, char, enums).\n+        // In both cases we want the bits.\n+        let bits = self.force_bits(src.to_scalar()?, src.layout.size)?;\n+        Ok(self.cast_from_int(bits, src.layout, dest_layout)?.into())\n     }\n \n     fn cast_from_int(\n@@ -236,31 +235,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    fn cast_from_ptr(\n-        &self,\n-        ptr: Pointer<M::PointerTag>,\n-        src_layout: TyLayout<'tcx>,\n-        dest_layout: TyLayout<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n-        use rustc::ty::TyKind::*;\n-\n-        match dest_layout.ty.sty {\n-            // Casting to a reference or fn pointer is not permitted by rustc,\n-            // no need to support it here.\n-            RawPtr(_) => Ok(ptr.into()),\n-            Int(_) | Uint(_) => {\n-                let size = self.memory.pointer_size();\n-\n-                match self.force_bits(Scalar::Ptr(ptr), size) {\n-                    Ok(bits) => self.cast_from_int(bits, src_layout, dest_layout),\n-                    Err(_) if dest_layout.size == size => Ok(ptr.into()),\n-                    Err(e) => Err(e),\n-                }\n-            }\n-            _ => bug!(\"invalid MIR: ptr to {:?} cast\", dest_layout.ty)\n-        }\n-    }\n-\n     fn unsize_into_ptr(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,"}, {"sha": "a9794982fe50b5983317e11f6ed81abfb680fdf1", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -165,11 +165,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n-    /// Called for all binary operations on integer(-like) types when one operand is a pointer\n-    /// value, and for the `Offset` operation that is inherently about pointers.\n+    /// Called for all binary operations where the LHS has pointer type.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n-    fn ptr_op(\n+    fn binary_ptr_op(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n@@ -234,7 +233,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n \n-    #[inline(always)]\n     fn int_to_ptr(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         int: u64,\n@@ -246,11 +244,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         }).into())\n     }\n \n-    #[inline(always)]\n     fn ptr_to_int(\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n-    ) -> InterpResult<'tcx, u64> {\n-        throw_unsup!(ReadPointerAsBytes)\n-    }\n+    ) -> InterpResult<'tcx, u64>;\n }"}, {"sha": "7b75627ee140060014e5ccb3e2aaabc51b682fcf", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -32,12 +32,21 @@ pub enum Immediate<Tag=(), Id=AllocId> {\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n }\n \n-impl<'tcx, Tag> Immediate<Tag> {\n-    #[inline]\n-    pub fn from_scalar(val: Scalar<Tag>) -> Self {\n-        Immediate::Scalar(ScalarMaybeUndef::Scalar(val))\n+impl<Tag> From<ScalarMaybeUndef<Tag>> for Immediate<Tag> {\n+    #[inline(always)]\n+    fn from(val: ScalarMaybeUndef<Tag>) -> Self {\n+        Immediate::Scalar(val)\n     }\n+}\n \n+impl<Tag> From<Scalar<Tag>> for Immediate<Tag> {\n+    #[inline(always)]\n+    fn from(val: Scalar<Tag>) -> Self {\n+        Immediate::Scalar(val.into())\n+    }\n+}\n+\n+impl<'tcx, Tag> Immediate<Tag> {\n     pub fn new_slice(\n         val: Scalar<Tag>,\n         len: u64,\n@@ -182,7 +191,7 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag>\n {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>, layout: TyLayout<'tcx>) -> Self {\n-        ImmTy { imm: Immediate::from_scalar(val), layout }\n+        ImmTy { imm: val.into(), layout }\n     }\n \n     #[inline]\n@@ -240,7 +249,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let ptr = match self.check_mplace_access(mplace, None)? {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n-                imm: Immediate::Scalar(Scalar::zst().into()),\n+                imm: Scalar::zst().into(),\n                 layout: mplace.layout,\n             })),\n         };\n@@ -251,7 +260,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n                 Ok(Some(ImmTy {\n-                    imm: Immediate::Scalar(scalar),\n+                    imm: scalar.into(),\n                     layout: mplace.layout,\n                 }))\n             }\n@@ -354,7 +363,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n-            let immediate = Immediate::Scalar(Scalar::zst().into());\n+            let immediate = Scalar::zst().into();\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n@@ -364,7 +373,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // extract fields from types with `ScalarPair` ABI\n             Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };\n-                Immediate::Scalar(val)\n+                Immediate::from(val)\n             },\n             Immediate::Scalar(val) =>\n                 bug!(\"field access on non aggregate {:#?}, {:#?}\", val, op.layout),\n@@ -401,7 +410,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n                 OpTy {\n-                    op: Operand::Immediate(Immediate::Scalar(Scalar::zst().into())),\n+                    op: Operand::Immediate(Scalar::zst().into()),\n                     // the actual index doesn't matter, so we just pick a convenient one like 0\n                     layout: base.layout.field(self, 0)?,\n                 }\n@@ -425,7 +434,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of_local(frame, local, layout)?;\n         let op = if layout.is_zst() {\n             // Do not read from ZST, they might not be initialized\n-            Operand::Immediate(Immediate::Scalar(Scalar::zst().into()))\n+            Operand::Immediate(Scalar::zst().into())\n         } else {\n             frame.locals[local].access()?\n         };\n@@ -556,7 +565,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Operand::Indirect(MemPlace::from_ptr(ptr, align))\n             },\n             ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),\n+                Operand::Immediate(tag_scalar(x).into()),\n             ConstValue::Slice { data, start, end } => {\n                 // We rely on mutability being set correctly in `data` to prevent writes\n                 // where none should happen."}, {"sha": "02dc3c01036d0bc3c99f74c582b3d68e9cb8fecc", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -290,30 +290,29 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n                 })\n             }\n-            _ => {\n-                // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(\n-                    left.layout.ty.is_integral()   ||\n-                    left.layout.ty.is_unsafe_ptr() || left.layout.ty.is_fn_ptr(),\n-                    \"Unexpected LHS type {:?} for BinOp {:?}\", left.layout.ty, bin_op);\n+            _ if left.layout.ty.is_integral() => {\n+                // the RHS type can be different, e.g. for shifts -- but it has to be integral, too\n                 assert!(\n-                    right.layout.ty.is_integral()   ||\n-                    right.layout.ty.is_unsafe_ptr() || right.layout.ty.is_fn_ptr(),\n-                    \"Unexpected RHS type {:?} for BinOp {:?}\", right.layout.ty, bin_op);\n-\n-                // Handle operations that support pointer values\n-                if left.to_scalar_ptr()?.is_ptr() ||\n-                    right.to_scalar_ptr()?.is_ptr() ||\n-                    bin_op == mir::BinOp::Offset\n-                {\n-                    return M::ptr_op(self, bin_op, left, right);\n-                }\n+                    right.layout.ty.is_integral(),\n+                    \"Unexpected types for BinOp: {:?} {:?} {:?}\",\n+                    left.layout.ty, bin_op, right.layout.ty\n+                );\n \n-                // Everything else only works with \"proper\" bits\n-                let l = left.to_bits().expect(\"we checked is_ptr\");\n-                let r = right.to_bits().expect(\"we checked is_ptr\");\n+                let l = self.force_bits(left.to_scalar()?, left.layout.size)?;\n+                let r = self.force_bits(right.to_scalar()?, right.layout.size)?;\n                 self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n+            _ if left.layout.ty.is_any_ptr() => {\n+                // The RHS type must be the same *or an integer type* (for `Offset`).\n+                assert!(\n+                    right.layout.ty == left.layout.ty || right.layout.ty.is_integral(),\n+                    \"Unexpected types for BinOp: {:?} {:?} {:?}\",\n+                    left.layout.ty, bin_op, right.layout.ty\n+                );\n+\n+                M::binary_ptr_op(self, bin_op, left, right)\n+            }\n+            _ => bug!(\"Invalid MIR: bad LHS type for binop: {:?}\", left.layout.ty),\n         }\n     }\n "}, {"sha": "4282687dad0f7b5f9f5f70a4f2e172818a67c831", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -8,7 +8,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     InterpResult, PointerArithmetic, Scalar,\n-    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n+    InterpCx, Machine, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -460,7 +460,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Adjust receiver argument.\n                 args[0] = OpTy::from(ImmTy {\n                     layout: this_receiver_ptr,\n-                    imm: Immediate::Scalar(receiver_place.ptr.into())\n+                    imm: receiver_place.ptr.into()\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function"}, {"sha": "7e36b2a6b1b396bc35b8e4813e1e8a4323fc37ee", "filename": "src/test/mir-opt/const_prop/reify_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -19,7 +19,7 @@ fn main() {\n //      _3 = const Scalar(AllocId(1).0x0) : fn();\n //      _2 = move _3 as usize (Misc);\n //      ...\n-//      _1 = const Scalar(AllocId(1).0x0) : *const fn();\n+//      _1 = move _2 as *const fn() (Misc);\n //      ...\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "9be1374f85d99af66d4c126e0e9034b2f3793525", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -4,8 +4,8 @@ fn main() {}\n \n // unconst and bad, will thus error in miri\n const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 }; //~ ERROR any use of this\n-// unconst and fine\n-const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n+// unconst and bad, will thus error in miri\n+const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 }; //~ ERROR any use of this\n // unconst and fine\n const Y: usize = unsafe { 42usize as *const i32 as usize + 1 };\n // unconst and bad, will thus error in miri"}, {"sha": "2cba833a74896ad1f128a5a1fa5f69b50ce47f54", "filename": "src/test/ui/consts/const-eval/const_raw_ptr_ops.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_raw_ptr_ops.stderr?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -8,13 +8,21 @@ LL | const X: bool = unsafe { &1 as *const i32 == &2 as *const i32 };\n    |\n    = note: `#[deny(const_err)]` on by default\n \n+error: any use of this value will cause an error\n+  --> $DIR/const_raw_ptr_ops.rs:8:27\n+   |\n+LL | const X2: bool = unsafe { 42 as *const i32 == 43 as *const i32 };\n+   | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                           |\n+   |                           \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n+\n error: any use of this value will cause an error\n   --> $DIR/const_raw_ptr_ops.rs:12:28\n    |\n LL | const Y2: usize = unsafe { &1 as *const i32 as usize + 1 };\n-   | ---------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   | ---------------------------^^^^^^^^^^^^^^^^^^^^^^^^^-------\n    |                            |\n-   |                            \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n+   |                            \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n error: any use of this value will cause an error\n   --> $DIR/const_raw_ptr_ops.rs:16:26\n@@ -32,5 +40,5 @@ LL | const Z3: i32 = unsafe { *(44 as *const i32) };\n    |                          |\n    |                          a memory access tried to interpret some bytes as a pointer\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "ea24578c7dd0cfd28f6937987db69918d647e143", "filename": "src/test/ui/consts/const-eval/issue-52442.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     [();  { &loop { break } as *const _ as usize } ];\n     //~^ ERROR casting pointers to integers in constants is unstable\n-    //~| ERROR it is undefined behavior to use this value\n+    //~| ERROR evaluation of constant value failed\n }"}, {"sha": "5bd4979bdb33cf4b15a581195376b8ed04cbee92", "filename": "src/test/ui/consts/const-eval/issue-52442.stderr", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -7,13 +7,11 @@ LL |     [();  { &loop { break } as *const _ as usize } ];\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51910\n    = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-52442.rs:2:11\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-52442.rs:2:13\n    |\n LL |     [();  { &loop { break } as *const _ as usize } ];\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5b89b0262aca5ce48b435d371e0f2d897baf248b", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -5,11 +5,9 @@ fn main() {\n     let _: [u8; 0] = [4; {\n         match &1 as *const i32 as usize {\n             //~^ ERROR casting pointers to integers in constants\n-            //~| NOTE for more information, see\n             //~| ERROR constant contains unimplemented expression type\n-            0 => 42, //~ ERROR constant contains unimplemented expression type\n-            //~^ NOTE \"pointer arithmetic or comparison\" needs an rfc before being allowed\n             //~| ERROR evaluation of constant value failed\n+            0 => 42, //~ ERROR constant contains unimplemented expression type\n             n => n,\n         }\n     }];"}, {"sha": "3d34ac42662703fcd4a81a41b469b46b774d6f0b", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -20,10 +20,10 @@ LL |             0 => 42,\n    |             ^\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/match-test-ptr-null.rs:10:13\n+  --> $DIR/match-test-ptr-null.rs:6:15\n    |\n-LL |             0 => 42,\n-   |             ^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n+LL |         match &1 as *const i32 as usize {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n error: aborting due to 4 previous errors\n "}, {"sha": "69f0d8df0aa4aafa1e98f88aaa434b4c5f9a2432", "filename": "src/test/ui/consts/issue-51559.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -2,6 +2,6 @@\n \n const BAR: *mut () = ((|| 3) as fn() -> i32) as *mut ();\n pub const FOO: usize = unsafe { BAR as usize };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR any use of this value will cause an error\n \n fn main() {}"}, {"sha": "4d50ec818bce7945e789b3087ce6af3c2e348abf", "filename": "src/test/ui/consts/issue-51559.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -1,11 +1,12 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/issue-51559.rs:4:1\n+error: any use of this value will cause an error\n+  --> $DIR/issue-51559.rs:4:33\n    |\n LL | pub const FOO: usize = unsafe { BAR as usize };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n+   | --------------------------------^^^^^^^^^^^^---\n+   |                                 |\n+   |                                 \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   = note: `#[deny(const_err)]` on by default\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "d12b483ba44734543f64ebc7c036e09c3cb7fcdc", "filename": "src/test/ui/issues/issue-52023-array-size-pointer-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.rs?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let _ = [0; (&0 as *const i32) as usize]; //~ ERROR casting pointers to integers in constants\n-    //~^ ERROR it is undefined behavior to use this value\n+    //~^ ERROR evaluation of constant value failed\n }"}, {"sha": "68ee53754161cf2c8bc2b211b0e4e93042d83d10", "filename": "src/test/ui/issues/issue-52023-array-size-pointer-cast.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e917f48382c6afaf50568263b89d35fba5d98e4/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52023-array-size-pointer-cast.stderr?ref=8e917f48382c6afaf50568263b89d35fba5d98e4", "patch": "@@ -7,13 +7,11 @@ LL |     let _ = [0; (&0 as *const i32) as usize];\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51910\n    = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n \n-error[E0080]: it is undefined behavior to use this value\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-52023-array-size-pointer-cast.rs:2:17\n    |\n LL |     let _ = [0; (&0 as *const i32) as usize];\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n error: aborting due to 2 previous errors\n "}]}