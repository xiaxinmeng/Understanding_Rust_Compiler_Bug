{"sha": "0b3dba42cf62419518137ec17ce7630f0174f26c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiM2RiYTQyY2Y2MjQxOTUxODEzN2VjMTdjZTc2MzBmMDE3NGYyNmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-25T22:59:24Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-25T22:59:24Z"}, "message": "Change iface and interface to trait. Close #2967.", "tree": {"sha": "9f099a66139501f497c5f4eeeac96b1d82765525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f099a66139501f497c5f4eeeac96b1d82765525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3dba42cf62419518137ec17ce7630f0174f26c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3dba42cf62419518137ec17ce7630f0174f26c", "html_url": "https://github.com/rust-lang/rust/commit/0b3dba42cf62419518137ec17ce7630f0174f26c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3dba42cf62419518137ec17ce7630f0174f26c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c1339b2f140cba7089ced984235b998e39879d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c1339b2f140cba7089ced984235b998e39879d6", "html_url": "https://github.com/rust-lang/rust/commit/7c1339b2f140cba7089ced984235b998e39879d6"}], "stats": {"total": 75, "additions": 38, "deletions": 37}, "files": [{"sha": "59e1a9d7d9d2e18c0887e03109040c6adddbcdc5", "filename": "doc/tutorial.md", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0b3dba42cf62419518137ec17ce7630f0174f26c/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b3dba42cf62419518137ec17ce7630f0174f26c/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=0b3dba42cf62419518137ec17ce7630f0174f26c", "patch": "@@ -34,8 +34,9 @@ high-level features include:\n * ***Higher-order functions.*** Rust functions may take closures as\n   arguments or return closures as return values.  Closures in Rust are\n   very powerful and used pervasively.\n-* ***Interface polymorphism.*** Rust's type system features a unique\n-  combination of Java-style interfaces and Haskell-style typeclasses.\n+* ***Trait polymorphism.*** Rust's type system features a unique\n+  combination of Java-style interfaces and Haskell-style typeclasses\n+  called _traits_.\n * ***Parametric polymorphism (generics).*** Functions and types can be\n   parameterized over type variables with optional type constraints.\n * ***Type inference.*** Type annotations on local variable\n@@ -2089,9 +2090,9 @@ resource type. Rust has several kinds that can be used as type bounds:\n   mutable fields nor shared boxes.\n \n > ***Note:*** Rust type kinds are syntactically very similar to\n-> [interfaces](#interfaces) when used as type bounds, and can be\n-> conveniently thought of as built-in interfaces. In the future type\n-> kinds will actually be interfaces that the compiler has special\n+> [traits](#traits) when used as type bounds, and can be\n+> conveniently thought of as built-in traits. In the future type\n+> kinds will actually be traits that the compiler has special\n > knowledge about.\n \n ## Generic functions and argument-passing\n@@ -2388,9 +2389,9 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n-# Interfaces\n+# Traits\n \n-Interfaces are Rust's take on value polymorphism\u2014the thing that\n+Traits are Rust's take on value polymorphism\u2014the thing that\n object-oriented languages tend to solve with methods and inheritance.\n For example, writing a function that can operate on multiple types of\n collections.\n@@ -2400,27 +2401,27 @@ collections.\n \n ## Declaration\n \n-An interface consists of a set of methods. A method is a function that\n+A trait consists of a set of methods. A method is a function that\n can be applied to a `self` value and a number of arguments, using the\n dot notation: `self.foo(arg1, arg2)`.\n \n-For example, we could declare the interface `to_str` for things that\n+For example, we could declare the trait `to_str` for things that\n can be converted to a string, with a single method of the same name:\n \n ~~~~\n-iface to_str {\n+trait to_str {\n     fn to_str() -> ~str;\n }\n ~~~~\n \n ## Implementation\n \n-To actually implement an interface for a given type, the `impl` form\n+To actually implement an trait for a given type, the `impl` form\n is used. This defines implementations of `to_str` for the `int` and\n `~str` types.\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n impl of to_str for int {\n     fn to_str() -> ~str { int::to_str(self, 10u) }\n }\n@@ -2439,13 +2440,13 @@ method that matches the name, and simply calls that.\n \n Implementations are not globally visible. Resolving a method to an\n implementation requires that implementation to be in scope. You can\n-import and export implementations using the name of the interface they\n+import and export implementations using the name of the trait they\n implement (multiple implementations with the same name can be in scope\n without problems). Or you can give them an explicit name if you\n prefer, using this syntax:\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n impl nil_to_str of to_str for () {\n     fn to_str() -> ~str { ~\"()\" }\n }\n@@ -2461,7 +2462,7 @@ known at compile time, it is possible to specify 'bounds' for type\n parameters.\n \n ~~~~\n-# iface to_str { fn to_str() -> ~str; }\n+# trait to_str { fn to_str() -> ~str; }\n fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n     let mut result = ~\"\", first = true;\n     for elts.each |elt| {\n@@ -2476,18 +2477,18 @@ fn comma_sep<T: to_str>(elts: ~[T]) -> ~str {\n The syntax for this is similar to the syntax for specifying that a\n parameter type has to be copyable (which is, in principle, another\n kind of bound). By declaring `T` as conforming to the `to_str`\n-interface, it becomes possible to call methods from that interface on\n+trait, it becomes possible to call methods from that trait on\n values of that type inside the function. It will also cause a\n compile-time error when anyone tries to call `comma_sep` on an array\n whose element type does not have a `to_str` implementation in scope.\n \n-## Polymorphic interfaces\n+## Polymorphic traits\n \n-Interfaces may contain type parameters. This defines an interface for\n+Traits may contain type parameters. This defines a trait for\n generalized sequence types:\n \n ~~~~\n-iface seq<T> {\n+trait seq<T> {\n     fn len() -> uint;\n     fn iter(fn(T));\n }\n@@ -2500,25 +2501,25 @@ impl <T> of seq<T> for ~[T] {\n ~~~~\n \n Note that the implementation has to explicitly declare the its\n-parameter `T` before using it to specify its interface type. This is\n+parameter `T` before using it to specify its trait type. This is\n needed because it could also, for example, specify an implementation\n of `seq<int>`\u2014the `of` clause *refers* to a type, rather than defining\n one.\n \n-The type parameters bound by an iface are in scope in each of the\n+The type parameters bound by a trait are in scope in each of the\n method declarations. So, re-declaring the type parameter\n-`T` as an explicit type parameter for `len` -- in either the iface or\n+`T` as an explicit type parameter for `len` -- in either the trait or\n the impl -- would be a compile-time error.\n \n-## The `self` type in interfaces\n+## The `self` type in traits\n \n-In an interface, `self` is a special type that you can think of as a\n-type parameter. An implementation of the interface for any given type\n+In a trait, `self` is a special type that you can think of as a\n+type parameter. An implementation of the trait for any given type\n `T` replaces the `self` type parameter with `T`. The following\n-interface describes types that support an equality operation:\n+trait describes types that support an equality operation:\n \n ~~~~\n-iface eq {\n+trait eq {\n   fn equals(&&other: self) -> bool;\n }\n \n@@ -2530,15 +2531,15 @@ impl of eq for int {\n Notice that `equals` takes an `int` argument, rather than a `self` argument, in\n an implementation for type `int`.\n \n-## Casting to an interface type\n+## Casting to an trait type\n \n The above allows us to define functions that polymorphically act on\n-values of *an* unknown type that conforms to a given interface.\n+values of *an* unknown type that conforms to a given trait.\n However, consider this function:\n \n ~~~~\n # type circle = int; type rectangle = int;\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n # impl of drawable for int { fn draw() {} }\n # fn new_circle() -> int { 1 }\n fn draw_all<T: drawable>(shapes: ~[T]) {\n@@ -2549,14 +2550,14 @@ fn draw_all<T: drawable>(shapes: ~[T]) {\n ~~~~\n \n You can call that on an array of circles, or an array of squares\n-(assuming those have suitable `drawable` interfaces defined), but not\n+(assuming those have suitable `drawable` traits defined), but not\n on an array containing both circles and squares.\n \n-When this is needed, an interface name can be used as a type, causing\n+When this is needed, a trait name can be used as a type, causing\n the function to be written simply like this:\n \n ~~~~\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n fn draw_all(shapes: ~[drawable]) {\n     for shapes.each |shape| { shape.draw(); }\n }\n@@ -2571,11 +2572,11 @@ is very similar to the 'vtables' used in most object-oriented\n languages.\n \n To construct such a value, you use the `as` operator to cast a value\n-to an interface type:\n+to a trait type:\n \n ~~~~\n # type circle = int; type rectangle = int;\n-# iface drawable { fn draw(); }\n+# trait drawable { fn draw(); }\n # impl of drawable for int { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n@@ -2594,10 +2595,10 @@ Note that the allocation of a box is somewhat more expensive than\n simply using a type parameter and passing in the value as-is, and much\n more expensive than statically resolved method calls.\n \n-## Interface-less implementations\n+## Trait-less implementations\n \n If you only intend to use an implementation for static overloading,\n-and there is no interface available that it conforms to, you are free\n+and there is no trait available that it conforms to, you are free\n to leave off the `of` clause.  However, this is only possible when you\n are defining an implementation in the same module as the receiver\n type, and the receiver type is a named type (i.e., an enum or a"}]}