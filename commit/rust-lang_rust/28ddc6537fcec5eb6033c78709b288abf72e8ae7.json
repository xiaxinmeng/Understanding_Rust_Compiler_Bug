{"sha": "28ddc6537fcec5eb6033c78709b288abf72e8ae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZGRjNjUzN2ZjZWM1ZWI2MDMzYzc4NzA5YjI4OGFiZjcyZThhZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-10T03:01:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-10T03:01:30Z"}, "message": "auto merge of #10926 : thestinger/rust/rc, r=cmr", "tree": {"sha": "434aeb714becdf7e9335e5d7995f8b08c19dd14c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/434aeb714becdf7e9335e5d7995f8b08c19dd14c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ddc6537fcec5eb6033c78709b288abf72e8ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ddc6537fcec5eb6033c78709b288abf72e8ae7", "html_url": "https://github.com/rust-lang/rust/commit/28ddc6537fcec5eb6033c78709b288abf72e8ae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ddc6537fcec5eb6033c78709b288abf72e8ae7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff3d5d460399070f660f5a59855fbb4698c797ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff3d5d460399070f660f5a59855fbb4698c797ee", "html_url": "https://github.com/rust-lang/rust/commit/ff3d5d460399070f660f5a59855fbb4698c797ee"}, {"sha": "fc60ace7a9ec6feed79cf52cc245f4d7c048fc8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc60ace7a9ec6feed79cf52cc245f4d7c048fc8b", "html_url": "https://github.com/rust-lang/rust/commit/fc60ace7a9ec6feed79cf52cc245f4d7c048fc8b"}], "stats": {"total": 236, "additions": 113, "deletions": 123}, "files": [{"sha": "020404057fb1ff514d9a3b23cfc27c39c1fc1835", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -406,14 +406,14 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S> + Freeze> Encodable<S> for Rc<T> {\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n     #[inline]\n     fn encode(&self, s: &mut S) {\n         self.borrow().encode(s)\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D> + Freeze> Decodable<D> for Rc<T> {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Rc<T> {\n     #[inline]\n     fn decode(d: &mut D) -> Rc<T> {\n         Rc::new(Decodable::decode(d))"}, {"sha": "3d6e81d0d6fd5f1104742caa2fffcaf8e94fa8b1", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -127,7 +127,7 @@ mod test {\n     }\n \n     fn mk(v: uint) -> (~IdleWatcher, Chan) {\n-        let rc = Rc::from_send(RefCell::new((None, 0)));\n+        let rc = Rc::new(RefCell::new((None, 0)));\n         let cb = ~MyCallback(rc.clone(), v);\n         let cb = cb as ~Callback:;\n         let cb = unsafe { cast::transmute(cb) };"}, {"sha": "7ce9873c2da418a9c10d1c1e9e2085fcd1b1dc0d", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -509,7 +509,7 @@ mod tests {\n             }\n         }\n \n-        let i = Rc::from_send(RefCell::new(0));\n+        let i = Rc::new(RefCell::new(0));\n         {\n             let x = R(i.clone());\n             let opt = Some(x);"}, {"sha": "9947d8822ae65a67427ae3301dbacdb3a9ccd071", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 107, "deletions": 96, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -14,19 +14,27 @@ The `Rc` type provides shared ownership of an immutable value. Destruction is de\n will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n overhead of atomic reference counting.\n \n+The `downgrade` method can be used to create a non-owning `Weak` pointer to the box. A `Weak`\n+pointer can be upgraded to an `Rc` pointer, but will return `None` if the value has already been\n+freed.\n+\n+For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n+pointers, and then storing the parent pointers as `Weak` pointers.\n+\n */\n \n-use ptr::RawPtr;\n-use unstable::intrinsics::transmute;\n+use cast::transmute;\n use ops::Drop;\n-use kinds::{Freeze, Send};\n+use cmp::{Eq, Ord};\n use clone::{Clone, DeepClone};\n-use cell::RefCell;\n-use cmp::{Eq, TotalEq, Ord, TotalOrd, Ordering};\n+use rt::global_heap::exchange_free;\n+use ptr::read_ptr;\n+use option::{Option, Some, None};\n \n struct RcBox<T> {\n     value: T,\n-    count: uint\n+    strong: uint,\n+    weak: uint\n }\n \n /// Immutable reference counted pointer type\n@@ -36,147 +44,141 @@ pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>\n }\n \n-impl<T: Freeze> Rc<T> {\n-    /// Construct a new reference-counted box from a `Freeze` value\n-    #[inline]\n+impl<T> Rc<T> {\n+    /// Construct a new reference-counted box\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n-            Rc::new_unchecked(value)\n+            Rc { ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }) }\n         }\n     }\n }\n \n-impl<T: Send> Rc<T> {\n-    /// Construct a new reference-counted box from a `Send` value\n-    #[inline]\n-    pub fn from_send(value: T) -> Rc<T> {\n+impl<T> Rc<T> {\n+    /// Borrow the value contained in the reference-counted box\n+    #[inline(always)]\n+    pub fn borrow<'a>(&'a self) -> &'a T {\n+        unsafe { &(*self.ptr).value }\n+    }\n+\n+    /// Downgrade the reference-counted pointer to a weak reference\n+    pub fn downgrade(&self) -> Weak<T> {\n         unsafe {\n-            Rc::new_unchecked(value)\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n         }\n     }\n }\n \n-impl<T: Freeze> Rc<RefCell<T>> {\n-    /// Construct a new reference-counted box from a `RefCell`-wrapped `Freeze` value\n-    #[inline]\n-    pub fn from_mut(value: RefCell<T>) -> Rc<RefCell<T>> {\n+#[unsafe_destructor]\n+impl<T> Drop for Rc<T> {\n+    fn drop(&mut self) {\n         unsafe {\n-            Rc::new_unchecked(value)\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).strong -= 1;\n+                if (*self.ptr).strong == 0 {\n+                    read_ptr(self.borrow()); // destroy the contained object\n+                    if (*self.ptr).weak == 0 {\n+                        exchange_free(self.ptr as *mut u8 as *i8)\n+                    }\n+                }\n+            }\n         }\n     }\n }\n \n-impl<T> Rc<T> {\n-    /// Unsafety construct a new reference-counted box from any value.\n-    ///\n-    /// It is possible to create cycles, which will leak, and may interact\n-    /// poorly with managed pointers.\n-    #[inline]\n-    pub unsafe fn new_unchecked(value: T) -> Rc<T> {\n-        Rc{ptr: transmute(~RcBox{value: value, count: 1})}\n-    }\n-\n-    /// Borrow the value contained in the reference-counted box\n+impl<T> Clone for Rc<T> {\n     #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n-        unsafe { &(*self.ptr).value }\n+    fn clone(&self) -> Rc<T> {\n+        unsafe {\n+            (*self.ptr).strong += 1;\n+            Rc { ptr: self.ptr }\n+        }\n     }\n+}\n \n-    /// Determine if two reference-counted pointers point to the same object\n+impl<T: DeepClone> DeepClone for Rc<T> {\n     #[inline]\n-    pub fn ptr_eq(&self, other: &Rc<T>) -> bool {\n-        self.ptr == other.ptr\n+    fn deep_clone(&self) -> Rc<T> {\n+        Rc::new(self.borrow().deep_clone())\n     }\n }\n \n impl<T: Eq> Eq for Rc<T> {\n-    #[inline]\n-    fn eq(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value == (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn eq(&self, other: &Rc<T>) -> bool { *self.borrow() == *other.borrow() }\n \n-    #[inline]\n-    fn ne(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value != (*other.ptr).value }\n-    }\n-}\n-\n-impl<T: TotalEq> TotalEq for Rc<T> {\n-    #[inline]\n-    fn equals(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value.equals(&(*other.ptr).value) }\n-    }\n+    #[inline(always)]\n+    fn ne(&self, other: &Rc<T>) -> bool { *self.borrow() != *other.borrow() }\n }\n \n impl<T: Ord> Ord for Rc<T> {\n-    #[inline]\n-    fn lt(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value < (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn lt(&self, other: &Rc<T>) -> bool { *self.borrow() < *other.borrow() }\n \n-    #[inline]\n-    fn le(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value <= (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn le(&self, other: &Rc<T>) -> bool { *self.borrow() <= *other.borrow() }\n \n-    #[inline]\n-    fn ge(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value >= (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn gt(&self, other: &Rc<T>) -> bool { *self.borrow() > *other.borrow() }\n \n-    #[inline]\n-    fn gt(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value > (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn ge(&self, other: &Rc<T>) -> bool { *self.borrow() >= *other.borrow() }\n }\n \n-impl<T: TotalOrd> TotalOrd for Rc<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Rc<T>) -> Ordering {\n-        unsafe { (*self.ptr).value.cmp(&(*other.ptr).value) }\n-    }\n+/// Weak reference to a reference-counted box\n+#[unsafe_no_drop_flag]\n+#[no_send]\n+pub struct Weak<T> {\n+    priv ptr: *mut RcBox<T>\n }\n \n-impl<T> Clone for Rc<T> {\n-    #[inline]\n-    fn clone(&self) -> Rc<T> {\n+impl<T> Weak<T> {\n+    /// Upgrade a weak reference to a strong reference\n+    pub fn upgrade(&self) -> Option<Rc<T>> {\n         unsafe {\n-            (*self.ptr).count += 1;\n-            Rc{ptr: self.ptr}\n+            if (*self.ptr).strong == 0 {\n+                None\n+            } else {\n+                (*self.ptr).strong += 1;\n+                Some(Rc { ptr: self.ptr })\n+            }\n         }\n     }\n }\n \n-impl<T: DeepClone> DeepClone for Rc<T> {\n-    #[inline]\n-    fn deep_clone(&self) -> Rc<T> {\n-        unsafe { Rc::new_unchecked(self.borrow().deep_clone()) }\n-    }\n-}\n-\n #[unsafe_destructor]\n-impl<T> Drop for Rc<T> {\n+impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            if self.ptr.is_not_null() {\n-                (*self.ptr).count -= 1;\n-                if (*self.ptr).count == 0 {\n-                    let _: ~RcBox<T> = transmute(self.ptr);\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).weak -= 1;\n+                if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n+                    exchange_free(self.ptr as *mut u8 as *i8)\n                 }\n             }\n         }\n     }\n }\n \n+impl<T> Clone for Weak<T> {\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        unsafe {\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n-mod test_rc {\n+mod tests {\n     use prelude::*;\n     use super::*;\n     use cell::RefCell;\n \n     #[test]\n     fn test_clone() {\n-        let x = Rc::from_send(RefCell::new(5));\n+        let x = Rc::new(RefCell::new(5));\n         let y = x.clone();\n         x.borrow().with_mut(|inner| {\n             *inner = 20;\n@@ -186,7 +188,7 @@ mod test_rc {\n \n     #[test]\n     fn test_deep_clone() {\n-        let x = Rc::from_send(RefCell::new(5));\n+        let x = Rc::new(RefCell::new(5));\n         let y = x.deep_clone();\n         x.borrow().with_mut(|inner| {\n             *inner = 20;\n@@ -210,13 +212,22 @@ mod test_rc {\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::from_send(~5);\n+        let x = Rc::new(~5);\n         assert_eq!(**x.borrow(), 5);\n     }\n \n     #[test]\n-    fn test_from_mut() {\n-        let a = 10;\n-        let _x = Rc::from_mut(RefCell::new(&a));\n+    fn test_live() {\n+        let x = Rc::new(5);\n+        let y = x.downgrade();\n+        assert!(y.upgrade().is_some());\n+    }\n+\n+    #[test]\n+    fn test_dead() {\n+        let x = Rc::new(5);\n+        let y = x.downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n     }\n }"}, {"sha": "cf7cb1a5a535f48f593063c82772bb73349012c0", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -37,7 +37,7 @@ struct A\n fn main()\n {\n     let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n-    let v = Rc::from_send(RefCell::new(a));\n+    let v = Rc::new(RefCell::new(a));\n     let w = v.clone();\n     let b = v.borrow();\n     let mut b = b.borrow_mut();"}, {"sha": "a963446b84c734d2bdfe88c7aeffc99d3d16c8f4", "filename": "src/test/compile-fail/no_freeze-rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddc6537fcec5eb6033c78709b288abf72e8ae7/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno_freeze-rc.rs?ref=28ddc6537fcec5eb6033c78709b288abf72e8ae7", "patch": "@@ -14,6 +14,6 @@ use std::cell::RefCell;\n fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n-    let x = Rc::from_send(RefCell::new(5));\n+    let x = Rc::new(RefCell::new(5));\n     bar(x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n }"}, {"sha": "7e0c8319356e47f8ca7110978bfac4ea91d1258d", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff3d5d460399070f660f5a59855fbb4698c797ee/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff3d5d460399070f660f5a59855fbb4698c797ee/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=ff3d5d460399070f660f5a59855fbb4698c797ee", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-fn o<T: Send>(_: &T) {}\n-fn c<T: Freeze>(_: &T) {}\n-\n-fn main() {\n-    let x = Rc::from_send(RefCell::new(0));\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Send`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::cell::RefCell<int>>`, which does not fulfill `Freeze`\n-}"}]}