{"sha": "be1feaa9187ca75c867b04283c2bea1128c344d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMWZlYWE5MTg3Y2E3NWM4NjdiMDQyODNjMmJlYTExMjhjMzQ0ZDU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-21T00:49:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-21T00:49:49Z"}, "message": "rt: First stab at computing internal reference counts", "tree": {"sha": "d1631fe5ae16dac6a0c1af6fd8d86e201517f192", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1631fe5ae16dac6a0c1af6fd8d86e201517f192"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be1feaa9187ca75c867b04283c2bea1128c344d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be1feaa9187ca75c867b04283c2bea1128c344d5", "html_url": "https://github.com/rust-lang/rust/commit/be1feaa9187ca75c867b04283c2bea1128c344d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be1feaa9187ca75c867b04283c2bea1128c344d5/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa7d624c1506dfb0d5f1d67257cc87a03fc37b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa7d624c1506dfb0d5f1d67257cc87a03fc37b78", "html_url": "https://github.com/rust-lang/rust/commit/aa7d624c1506dfb0d5f1d67257cc87a03fc37b78"}], "stats": {"total": 176, "additions": 161, "deletions": 15}, "files": [{"sha": "87b9f62e106cca83786f47d20e7c24ba57bc9f64", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 161, "deletions": 15, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/be1feaa9187ca75c867b04283c2bea1128c344d5/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/be1feaa9187ca75c867b04283c2bea1128c344d5/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=be1feaa9187ca75c867b04283c2bea1128c344d5", "patch": "@@ -1,45 +1,191 @@\n // Rust cycle collector. Temporary, but will probably stick around for some\n // time until LLVM's GC infrastructure is more mature.\n \n-#include <cstdio>\n-#include <cstdlib>\n-#include <map>\n-#include <vector>\n #include \"rust_gc.h\"\n #include \"rust_internal.h\"\n #include \"rust_shape.h\"\n #include \"rust_task.h\"\n+#include <cstdio>\n+#include <cstdlib>\n+#include <map>\n+#include <vector>\n+#include <stdint.h>\n \n #undef DPRINT\n #define DPRINT(fmt,...)     fprintf(stderr, fmt, ##__VA_ARGS__)\n \n namespace cc {\n \n+// Internal reference count computation\n+\n+typedef std::map<void *,uintptr_t> irc_map;\n+\n+class irc : public shape::data<irc,shape::ptr> {\n+    friend class shape::data<irc,shape::ptr>;\n+\n+    irc_map ircs;\n+\n+    irc(const irc &other, const shape::ptr &in_dp)\n+    : shape::data<irc,shape::ptr>(other.task, other.align, other.sp,\n+                                  other.params, other.tables, in_dp),\n+      ircs(other.ircs) {}\n+\n+    irc(const irc &other,\n+        const uint8_t *in_sp,\n+        const shape::type_param *in_params,\n+        const rust_shape_tables *in_tables = NULL)\n+    : shape::data<irc,shape::ptr>(other.task,\n+                                  other.align,\n+                                  in_sp,\n+                                  in_params,\n+                                  in_tables ? in_tables : other.tables,\n+                                  other.dp),\n+      ircs(other.ircs) {}\n+\n+    irc(const irc &other,\n+        const uint8_t *in_sp,\n+        const shape::type_param *in_params,\n+        const rust_shape_tables *in_tables,\n+        shape::ptr in_dp)\n+    : shape::data<irc,shape::ptr>(other.task,\n+                                  other.align,\n+                                  in_sp,\n+                                  in_params,\n+                                  in_tables,\n+                                  in_dp),\n+      ircs(other.ircs) {}\n+\n+    irc(rust_task *in_task,\n+        bool in_align,\n+        const uint8_t *in_sp,\n+        const shape::type_param *in_params,\n+        const rust_shape_tables *in_tables,\n+        uint8_t *in_data,\n+        irc_map &in_ircs)\n+    : shape::data<irc,shape::ptr>(in_task, in_align, in_sp, in_params,\n+                                  in_tables, in_data),\n+      ircs(in_ircs) {}\n+\n+    void walk_vec(bool is_pod, uint16_t sp_size) {\n+        if (is_pod || shape::get_dp<void *>(dp) == NULL)\n+            return;     // There can't be any outbound pointers from this.\n+\n+        std::pair<uint8_t *,uint8_t *> data_range(get_vec_data_range(dp));\n+        if (data_range.second - data_range.first > 10000)\n+            abort();    // FIXME: Temporary sanity check.\n+\n+        irc sub(*this, data_range.first);\n+        shape::ptr data_end = sub.end_dp = data_range.second;\n+        while (sub.dp < data_end) {\n+            sub.walk_reset();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_tag(shape::tag_info &tinfo, uint32_t tag_variant) {\n+        shape::data<irc,shape::ptr>::walk_variant(tinfo, tag_variant);\n+    }\n+\n+    void walk_box() {\n+        shape::data<irc,shape::ptr>::walk_box_contents();\n+    }\n+\n+    void walk_fn() {\n+        shape::data<irc,shape::ptr>::walk_fn_contents(dp);\n+    }\n+\n+    void walk_obj() {\n+        shape::data<irc,shape::ptr>::walk_obj_contents(dp);\n+    }\n+\n+    void walk_res(const shape::rust_fn *dtor, unsigned n_params,\n+                  const shape::type_param *params, const uint8_t *end_sp,\n+                  bool live) {\n+        while (this->sp != end_sp) {\n+            this->walk();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_subcontext(irc &sub) { sub.walk(); }\n+\n+    void walk_box_contents(irc &sub, shape::ptr &ref_count_dp) {\n+        if (!ref_count_dp)\n+            return;\n+\n+        // Bump the internal reference count of the box.\n+        if (ircs.find((void *)dp) == ircs.end())\n+            ircs[(void *)dp] = 1;\n+        else\n+            ++ircs[(void *)dp];\n+\n+        // Do not traverse the contents of this box; it's in the allocation\n+        // somewhere, so we're guaranteed to come back to it (if we haven't\n+        // traversed it already).\n+    }\n+\n+    void walk_struct(const uint8_t *end_sp) {\n+        while (this->sp != end_sp) {\n+            this->walk();\n+            align = true;\n+        }\n+    }\n+\n+    void walk_variant(shape::tag_info &tinfo, uint32_t variant_id,\n+                      const std::pair<const uint8_t *,const uint8_t *>\n+                      variant_ptr_and_end);\n+\n+    template<typename T>\n+    inline void walk_number() { /* no-op */ }\n+\n+public:\n+    static void compute_ircs(rust_task *task, irc_map &ircs);\n+};\n+\n void\n-do_cc(rust_task *task) {\n-    std::map<void *,type_desc *>::iterator begin(task->local_allocs.begin());\n-    std::map<void *,type_desc *>::iterator end(task->local_allocs.end());\n+irc::walk_variant(shape::tag_info &tinfo, uint32_t variant_id,\n+                  const std::pair<const uint8_t *,const uint8_t *>\n+                  variant_ptr_and_end) {\n+    irc sub(*this, variant_ptr_and_end.first, tinfo.params);\n+\n+    assert(variant_id < 256);   // FIXME: Temporary sanity check.\n+\n+    const uint8_t *variant_end = variant_ptr_and_end.second;\n+    while (sub.sp < variant_end) {\n+        sub.walk();\n+        align = true;\n+    }\n+}\n+\n+void\n+irc::compute_ircs(rust_task *task, irc_map &ircs) {\n+    std::map<void *,type_desc *>::iterator begin(task->local_allocs.begin()),\n+                                           end(task->local_allocs.end());\n     while (begin != end) {\n-        void *p = begin->first;\n+        uint8_t *p = reinterpret_cast<uint8_t *>(begin->first);\n         type_desc *tydesc = begin->second;\n \n-        DPRINT(\"marking allocation: %p, tydesc=%p\\n\", p, tydesc);\n+        DPRINT(\"determining internal ref counts: %p, tydesc=%p\\n\", p, tydesc);\n \n         // Prevents warnings for now\n-        (void)p;\n-        (void)tydesc;\n-#if 0\n         shape::arena arena;\n         shape::type_param *params =\n             shape::type_param::from_tydesc(tydesc, arena);\n-        mark mark(task, true, tydesc->shape, params, tydesc->shape_tables, p);\n-        mark.walk();\n-#endif\n+        irc irc(task, true, tydesc->shape, params, tydesc->shape_tables, p,\n+                ircs);\n+        irc.walk();\n \n         ++begin;\n     }\n }\n \n+\n+void\n+do_cc(rust_task *task) {\n+    irc_map ircs;\n+    irc::compute_ircs(task, ircs);\n+}\n+\n void\n maybe_cc(rust_task *task) {\n     // FIXME: We ought to lock this."}]}