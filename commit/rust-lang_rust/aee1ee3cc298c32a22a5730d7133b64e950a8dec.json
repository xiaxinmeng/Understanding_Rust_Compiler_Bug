{"sha": "aee1ee3cc298c32a22a5730d7133b64e950a8dec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZTFlZTNjYzI5OGMzMmEyMmE1NzMwZDcxMzNiNjRlOTUwYThkZWM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-03T23:19:40Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-06T14:22:11Z"}, "message": "rustc: harden against InferOk having obligations in more cases.", "tree": {"sha": "9ff1a6b7621f81147003c0d5c319c8ff91450059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ff1a6b7621f81147003c0d5c319c8ff91450059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aee1ee3cc298c32a22a5730d7133b64e950a8dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aee1ee3cc298c32a22a5730d7133b64e950a8dec", "html_url": "https://github.com/rust-lang/rust/commit/aee1ee3cc298c32a22a5730d7133b64e950a8dec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aee1ee3cc298c32a22a5730d7133b64e950a8dec/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "161f2623bd078017dfc9a06bd3417b36f6a58de9", "url": "https://api.github.com/repos/rust-lang/rust/commits/161f2623bd078017dfc9a06bd3417b36f6a58de9", "html_url": "https://github.com/rust-lang/rust/commit/161f2623bd078017dfc9a06bd3417b36f6a58de9"}], "stats": {"total": 122, "additions": 78, "deletions": 44}, "files": [{"sha": "21820ca07192103c3d55b1cc98ef3935f6a52148", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -1069,7 +1069,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.probe(|_| {\n             let origin = TypeOrigin::Misc(syntax_pos::DUMMY_SP);\n             let trace = TypeTrace::types(origin, true, a, b);\n-            self.sub(true, trace, &a, &b).map(|_| ())\n+            self.sub(true, trace, &a, &b).map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            })\n         })\n     }\n \n@@ -1592,8 +1595,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // anyhow. We should make this typetrace stuff more\n             // generic so we don't have to do anything quite this\n             // terrible.\n-            self.equate(true, TypeTrace::dummy(self.tcx), a, b)\n-        }).map(|_| ())\n+            let trace = TypeTrace::dummy(self.tcx);\n+            self.equate(true, trace, a, b).map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            })\n+        })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {"}, {"sha": "1ccd048cedcaa31458097b787b5e3445eb915481", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -14,7 +14,7 @@ use super::{SelectionContext, Obligation, ObligationCause};\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n-use infer::{InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeOrigin};\n use syntax_pos::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n@@ -55,11 +55,13 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = selcx.infcx().eq_impl_headers(true,\n-                                                  TypeOrigin::Misc(DUMMY_SP),\n-                                                  &a_impl_header,\n-                                                  &b_impl_header) {\n-        return None;\n+    match selcx.infcx().eq_impl_headers(true, TypeOrigin::Misc(DUMMY_SP), &a_impl_header,\n+                                                                          &b_impl_header) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty());\n+        }\n+        Err(_) => return None\n     }\n \n     debug!(\"overlap: unification check succeeded\");"}, {"sha": "909247d1cb245b45ebd5b20f7d1a801afa506e12", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -22,7 +22,7 @@ use super::util::impl_trait_ref_and_oblig;\n \n use rustc_data_structures::fnv::FnvHashMap;\n use hir::def_id::DefId;\n-use infer::{InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, InferOk, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n@@ -222,14 +222,18 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                                    target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    if let Err(_) = infcx.eq_trait_refs(true,\n-                                        TypeOrigin::Misc(DUMMY_SP),\n-                                        source_trait_ref,\n-                                        target_trait_ref) {\n-        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-               source_trait_ref,\n-               target_trait_ref);\n-        return Err(());\n+    match infcx.eq_trait_refs(true, TypeOrigin::Misc(DUMMY_SP), source_trait_ref,\n+                                                                target_trait_ref) {\n+        Ok(InferOk { obligations, .. }) => {\n+            // FIXME(#32730) propagate obligations\n+            assert!(obligations.is_empty())\n+        }\n+        Err(_) => {\n+            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+            return Err(());\n+        }\n     }\n \n     // attempt to prove all of the predicates for impl2 given those for impl1"}, {"sha": "2cb719675ac481263d10e193d5cb11660755b0ce", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -298,7 +298,13 @@ fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n \n-        if let Err(terr) = infcx.sub_types(false, origin, impl_fty, trait_fty) {\n+        let sub_result = infcx.sub_types(false, origin, impl_fty, trait_fty)\n+            .map(|InferOk { obligations, .. }| {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            });\n+\n+        if let Err(terr) = sub_result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\",\n                    impl_fty,\n                    trait_fty);"}, {"sha": "e72bcb3079c5c4adffd660e610c9c4bcf41f29b3", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -13,7 +13,7 @@ use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n-use rustc::infer;\n+use rustc::infer::{self, InferOk};\n use middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n@@ -93,16 +93,22 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n-        if let Err(_) = infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n-                                       named_type, fresh_impl_self_ty) {\n-            let item_span = tcx.map.span(self_type_node_id);\n-            struct_span_err!(tcx.sess, drop_impl_span, E0366,\n-                             \"Implementations of Drop cannot be specialized\")\n-                .span_note(item_span,\n-                           \"Use same sequence of generic type and region \\\n-                            parameters that is on the struct/enum definition\")\n-                .emit();\n-            return Err(());\n+        match infcx.eq_types(true, infer::TypeOrigin::Misc(drop_impl_span),\n+                             named_type, fresh_impl_self_ty) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+            }\n+            Err(_) => {\n+                let item_span = tcx.map.span(self_type_node_id);\n+                struct_span_err!(tcx.sess, drop_impl_span, E0366,\n+                                 \"Implementations of Drop cannot be specialized\")\n+                    .span_note(item_span,\n+                               \"Use same sequence of generic type and region \\\n+                                parameters that is on the struct/enum definition\")\n+                    .emit();\n+                return Err(());\n+            }\n         }\n \n         if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {"}, {"sha": "4a4dea5b514e597ef7264869984247ac72a65e62", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -415,15 +415,19 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n                                 if f.unsubst_ty().is_phantom_data() {\n                                     // Ignore PhantomData fields\n-                                    None\n-                                } else if infcx.sub_types(false, origin, b, a).is_ok() {\n-                                    // Ignore fields that aren't significantly changed\n-                                    None\n-                                } else {\n-                                    // Collect up all fields that were significantly changed\n-                                    // i.e. those that contain T in coerce_unsized T -> U\n-                                    Some((i, a, b))\n+                                    return None;\n                                 }\n+\n+                                // Ignore fields that aren't significantly changed\n+                                if let Ok(ok) = infcx.sub_types(false, origin, b, a) {\n+                                    if ok.obligations.is_empty() {\n+                                        return None;\n+                                    }\n+                                }\n+\n+                                // Collect up all fields that were significantly changed\n+                                // i.e. those that contain T in coerce_unsized T -> U\n+                                Some((i, a, b))\n                             })\n                             .collect::<Vec<_>>();\n "}, {"sha": "75f0dac59501d53cd84e4cbb8a59056aca003b7b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aee1ee3cc298c32a22a5730d7133b64e950a8dec/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=aee1ee3cc298c32a22a5730d7133b64e950a8dec", "patch": "@@ -106,7 +106,7 @@ pub use rustc::util;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use rustc::infer::TypeOrigin;\n+use rustc::infer::{InferOk, TypeOrigin};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n@@ -198,11 +198,16 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n     ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n-        if let Err(err) = infcx.eq_types(false, origin.clone(), expected, actual) {\n-            infcx.report_mismatched_types(origin, expected, actual, err);\n-            false\n-        } else {\n-            true\n+        match infcx.eq_types(false, origin.clone(), expected, actual) {\n+            Ok(InferOk { obligations, .. }) => {\n+                // FIXME(#32730) propagate obligations\n+                assert!(obligations.is_empty());\n+                true\n+            }\n+            Err(err) => {\n+                infcx.report_mismatched_types(origin, expected, actual, err);\n+                false\n+            }\n         }\n     })\n }"}]}