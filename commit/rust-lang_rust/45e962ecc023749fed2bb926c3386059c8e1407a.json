{"sha": "45e962ecc023749fed2bb926c3386059c8e1407a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZTk2MmVjYzAyMzc0OWZlZDJiYjkyNmMzMzg2MDU5YzhlMTQwN2E=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-07T01:11:23Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-01-29T11:07:27Z"}, "message": "Use correct output file paths for error checking", "tree": {"sha": "033de3b5acd449de987e1d1456b8773ba1bd5874", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/033de3b5acd449de987e1d1456b8773ba1bd5874"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45e962ecc023749fed2bb926c3386059c8e1407a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45e962ecc023749fed2bb926c3386059c8e1407a", "html_url": "https://github.com/rust-lang/rust/commit/45e962ecc023749fed2bb926c3386059c8e1407a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45e962ecc023749fed2bb926c3386059c8e1407a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d55974be4142244d98007c9557ac93e9b9b7d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d55974be4142244d98007c9557ac93e9b9b7d0d", "html_url": "https://github.com/rust-lang/rust/commit/3d55974be4142244d98007c9557ac93e9b9b7d0d"}], "stats": {"total": 135, "additions": 69, "deletions": 66}, "files": [{"sha": "af91e294db6dbbbb0c720ded836134fdc176c10c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/45e962ecc023749fed2bb926c3386059c8e1407a/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e962ecc023749fed2bb926c3386059c8e1407a/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=45e962ecc023749fed2bb926c3386059c8e1407a", "patch": "@@ -548,45 +548,6 @@ impl OutputFilenames {\n     pub fn filestem(&self) -> String {\n         format!(\"{}{}\", self.out_filestem, self.extra)\n     }\n-\n-    fn check_output<F, T>(&self, f: F) -> Option<T> where F: Fn(PathBuf) -> Option<T> {\n-        match self.single_output_file {\n-            Some(ref output_path) => {\n-                f(output_path.clone())\n-            },\n-            None => {\n-                for k in self.outputs.keys() {\n-                    let output_path = self.path(k.to_owned());\n-                    if let Some(result) = f(output_path) {\n-                        return Some(result);\n-                    }\n-                }\n-                None\n-            }\n-        }\n-    }\n-\n-    pub fn contains_path(&self, input_path: &PathBuf) -> bool {\n-        let input_path = input_path.canonicalize().ok();\n-        if input_path.is_none() {\n-            return false\n-        }\n-        let check = |output_path: PathBuf| {\n-            if output_path.canonicalize().ok() == input_path {\n-                Some(())\n-            } else { None }\n-        };\n-        self.check_output(check).is_some()\n-    }\n-\n-    pub fn conflicts_with_dir(&self) -> Option<PathBuf> {\n-        let check = |output_path: PathBuf| {\n-            if output_path.is_dir() {\n-                Some(output_path)\n-            } else { None }\n-        };\n-        self.check_output(check)\n-    }\n }\n \n pub fn host_triple() -> &'static str {"}, {"sha": "a8ba795845fc968639103c6d44bf73e3c96e6c68", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 69, "deletions": 27, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/45e962ecc023749fed2bb926c3386059c8e1407a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e962ecc023749fed2bb926c3386059c8e1407a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=45e962ecc023749fed2bb926c3386059c8e1407a", "patch": "@@ -121,19 +121,41 @@ pub fn compile_input(trans: Box<TransCrate>,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n+        let crate_name =\n+            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n+            phase_2_configure_and_expand(\n+                sess,\n+                &cstore,\n+                krate,\n+                registry,\n+                &crate_name,\n+                addl_plugins,\n+                control.make_glob_map,\n+                |expanded_crate| {\n+                    let mut state = CompileState::state_after_expand(\n+                        input, sess, outdir, output, &cstore, expanded_crate, &crate_name,\n+                    );\n+                    controller_entry_point!(after_expand, sess, state, Ok(()));\n+                    Ok(())\n+                }\n+            )?\n+        };\n+        \n+        let output_paths = generated_output_paths(sess, &outputs, &crate_name);\n \n         // Ensure the source file isn't accidentally overwritten during compilation.\n         match *input_path {\n             Some(ref input_path) => {\n                 if sess.opts.will_create_output_file() {\n-                    if outputs.contains_path(input_path) {\n+                    if output_contains_path(&output_paths, input_path) {\n                         sess.err(&format!(\n                             \"the input file \\\"{}\\\" would be overwritten by the generated \\\n                             executable\",\n                             input_path.display()));\n                         return Err(CompileIncomplete::Stopped);\n                     }\n-                    if let Some(dir_path) = outputs.conflicts_with_dir() {\n+                    if let Some(dir_path) = output_conflicts_with_dir(&output_paths) {\n                         sess.err(&format!(\n                             \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n                             existing directory \\\"{}\\\"\",\n@@ -145,29 +167,7 @@ pub fn compile_input(trans: Box<TransCrate>,\n             None => {}\n         }\n \n-        let crate_name =\n-            ::rustc_trans_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n-\n-        let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n-            phase_2_configure_and_expand(\n-                sess,\n-                &cstore,\n-                krate,\n-                registry,\n-                &crate_name,\n-                addl_plugins,\n-                control.make_glob_map,\n-                |expanded_crate| {\n-                    let mut state = CompileState::state_after_expand(\n-                        input, sess, outdir, output, &cstore, expanded_crate, &crate_name,\n-                    );\n-                    controller_entry_point!(after_expand, sess, state, Ok(()));\n-                    Ok(())\n-                }\n-            )?\n-        };\n-\n-        write_out_deps(sess, &outputs, &crate_name);\n+        write_out_deps(sess, &outputs, &output_paths);\n         if sess.opts.output_types.contains_key(&OutputType::DepInfo) &&\n             sess.opts.output_types.keys().count() == 1 {\n             return Ok(())\n@@ -1111,7 +1111,10 @@ fn escape_dep_filename(filename: &FileName) -> String {\n     filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n+// Returns all the paths that correspond to generated files.\n+fn generated_output_paths(sess: &Session,\n+                          outputs: &OutputFilenames,\n+                          crate_name: &str) -> Vec<PathBuf> {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n         let file = outputs.path(*output_type);\n@@ -1135,7 +1138,46 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n             }\n         }\n     }\n+    out_filenames\n+}\n+\n+// Runs `f` on every output file path and returns the first non-None result, or None if `f`\n+// returns None for every file path.\n+fn check_output<F, T>(output_paths: &Vec<PathBuf>, f: F) -> Option<T>\n+        where F: Fn(&PathBuf) -> Option<T> {\n+            for output_path in output_paths {\n+                if let Some(result) = f(output_path) {\n+                    return Some(result);\n+                }\n+            }\n+            None\n+}\n+\n+pub fn output_contains_path(output_paths: &Vec<PathBuf>, input_path: &PathBuf) -> bool {\n+    let input_path = input_path.canonicalize().ok();\n+    if input_path.is_none() {\n+        return false\n+    }\n+    let check = |output_path: &PathBuf| {\n+        if output_path.canonicalize().ok() == input_path {\n+            Some(())\n+        } else { None }\n+    };\n+    check_output(output_paths, check).is_some()\n+}\n+\n+pub fn output_conflicts_with_dir(output_paths: &Vec<PathBuf>) -> Option<PathBuf> {\n+    let check = |output_path: &PathBuf| {\n+        if output_path.is_dir() {\n+            Some(output_path.clone())\n+        } else { None }\n+    };\n+    check_output(output_paths, check)\n+}\n \n+fn write_out_deps(sess: &Session,\n+                  outputs: &OutputFilenames,\n+                  out_filenames: &Vec<PathBuf>) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n@@ -1154,7 +1196,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n                                          .map(|fmap| escape_dep_filename(&fmap.name))\n                                          .collect();\n             let mut file = fs::File::create(&deps_filename)?;\n-            for path in &out_filenames {\n+            for path in out_filenames {\n                 write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n             }\n "}]}