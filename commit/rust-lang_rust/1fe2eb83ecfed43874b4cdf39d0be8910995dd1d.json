{"sha": "1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZTJlYjgzZWNmZWQ0Mzg3NGI0Y2RmMzlkMGJlODkxMDk5NWRkMWQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-22T18:22:40Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-04T22:33:43Z"}, "message": "expand: Introduce enum for module loading errors and make module loading speculative", "tree": {"sha": "13a72337bdb5d7b9d2b906da25bad7db7304b56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13a72337bdb5d7b9d2b906da25bad7db7304b56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "html_url": "https://github.com/rust-lang/rust/commit/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e1d574aeac3fae44dac430ecfe8086abcdf9a5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e1d574aeac3fae44dac430ecfe8086abcdf9a5f", "html_url": "https://github.com/rust-lang/rust/commit/1e1d574aeac3fae44dac430ecfe8086abcdf9a5f"}], "stats": {"total": 181, "additions": 90, "deletions": 91}, "files": [{"sha": "1a93975533de03bbafc3c72e1c2fef3c3e55808b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -1,3 +1,4 @@\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(destructuring_assignment)]"}, {"sha": "2ec656d4895e7f0d960741bdf49cc6c934dc9a51", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 85, "deletions": 87, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ModuleData;\n use rustc_ast::ptr::P;\n use rustc_ast::{token, Attribute, Item};\n-use rustc_errors::{struct_span_err, PResult};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n@@ -19,14 +19,6 @@ pub enum DirOwnership {\n     UnownedViaBlock,\n }\n \n-/// Information about the path to a module.\n-// Public for rustfmt usage.\n-pub struct ModulePath<'a> {\n-    name: String,\n-    path_exists: bool,\n-    pub result: PResult<'a, ModulePathSuccess>,\n-}\n-\n // Public for rustfmt usage.\n pub struct ModulePathSuccess {\n     pub file_path: PathBuf,\n@@ -41,6 +33,14 @@ crate struct ParsedExternalMod {\n     pub dir_ownership: DirOwnership,\n }\n \n+pub enum ModError<'a> {\n+    CircularInclusion(Vec<PathBuf>),\n+    ModInBlock(Option<Ident>),\n+    FileNotFound(Ident, PathBuf),\n+    MultipleCandidates(Ident, String, String),\n+    ParserError(DiagnosticBuilder<'a>),\n+}\n+\n crate fn parse_external_mod(\n     sess: &Session,\n     ident: Ident,\n@@ -50,47 +50,33 @@ crate fn parse_external_mod(\n     attrs: &mut Vec<Attribute>,\n ) -> ParsedExternalMod {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n-    let result: PResult<'_, _> = try {\n+    let result: Result<_, ModError<'_>> = try {\n         // Extract the file path and the new ownership.\n-        let mp = mod_file_path(sess, ident, span, &attrs, &module.dir_path, dir_ownership)?;\n+        let mp = mod_file_path(sess, ident, &attrs, &module.dir_path, dir_ownership)?;\n         dir_ownership = mp.dir_ownership;\n \n         // Ensure file paths are acyclic.\n-        error_on_circular_module(&sess.parse_sess, span, &mp.file_path, &module.file_path_stack)?;\n+        if let Some(pos) = module.file_path_stack.iter().position(|p| p == &mp.file_path) {\n+            Err(ModError::CircularInclusion(module.file_path_stack[pos..].to_vec()))?;\n+        }\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.file_path, Some(span));\n-        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        let (mut inner_attrs, items, inner_span) =\n+            parser.parse_mod(&token::Eof).map_err(|err| ModError::ParserError(err))?;\n         attrs.append(&mut inner_attrs);\n         (items, inner_span, mp.file_path)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (items, inner_span, file_path) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    let (items, inner_span, file_path) =\n+        result.map_err(|err| err.report(sess, span)).unwrap_or_default();\n \n     // Extract the directory path for submodules of the module.\n     let dir_path = file_path.parent().unwrap_or(&file_path).to_owned();\n \n     ParsedExternalMod { items, inner_span, file_path, dir_path, dir_ownership }\n }\n \n-fn error_on_circular_module<'a>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    file_path: &Path,\n-    file_path_stack: &[PathBuf],\n-) -> PResult<'a, ()> {\n-    if let Some(i) = file_path_stack.iter().position(|p| *p == file_path) {\n-        let mut err = String::from(\"circular modules: \");\n-        for p in &file_path_stack[i..] {\n-            err.push_str(&p.to_string_lossy());\n-            err.push_str(\" -> \");\n-        }\n-        err.push_str(&file_path.to_string_lossy());\n-        return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n-    }\n-    Ok(())\n-}\n-\n crate fn mod_dir_path(\n     sess: &Session,\n     ident: Ident,\n@@ -125,11 +111,10 @@ crate fn mod_dir_path(\n fn mod_file_path<'a>(\n     sess: &'a Session,\n     ident: Ident,\n-    span: Span,\n     attrs: &[Attribute],\n     dir_path: &Path,\n     dir_ownership: DirOwnership,\n-) -> PResult<'a, ModulePathSuccess> {\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n     if let Some(file_path) = mod_file_path_from_attr(sess, attrs, dir_path) {\n         // All `#[path]` files are treated as though they are a `mod.rs` file.\n         // This means that `mod foo;` declarations inside `#[path]`-included\n@@ -146,30 +131,14 @@ fn mod_file_path<'a>(\n         DirOwnership::Owned { relative } => relative,\n         DirOwnership::UnownedViaBlock => None,\n     };\n-    let ModulePath { path_exists, name, result } =\n-        default_submod_path(&sess.parse_sess, ident, span, relative, dir_path);\n+    let result = default_submod_path(&sess.parse_sess, ident, relative, dir_path);\n     match dir_ownership {\n-        DirOwnership::Owned { .. } => Ok(result?),\n-        DirOwnership::UnownedViaBlock => {\n-            let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n-        }\n-    }\n-}\n-\n-fn error_decl_mod_in_block<'a, T>(\n-    sess: &'a ParseSess,\n-    span: Span,\n-    path_exists: bool,\n-    name: &str,\n-) -> PResult<'a, T> {\n-    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n-    let mut err = sess.span_diagnostic.struct_span_err(span, msg);\n-    if path_exists {\n-        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n-        err.span_note(span, &msg);\n+        DirOwnership::Owned { .. } => result,\n+        DirOwnership::UnownedViaBlock => Err(ModError::ModInBlock(match result {\n+            Ok(_) | Err(ModError::MultipleCandidates(..)) => Some(ident),\n+            _ => None,\n+        })),\n     }\n-    Err(err)\n }\n \n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n@@ -197,10 +166,9 @@ fn mod_file_path_from_attr(\n pub fn default_submod_path<'a>(\n     sess: &'a ParseSess,\n     ident: Ident,\n-    span: Span,\n     relative: Option<Ident>,\n     dir_path: &Path,\n-) -> ModulePath<'a> {\n+) -> Result<ModulePathSuccess, ModError<'a>> {\n     // If we're in a foo.rs file instead of a mod.rs file,\n     // we need to look for submodules in\n     // `./foo/<ident>.rs` and `./foo/<ident>/mod.rs` rather than\n@@ -222,7 +190,7 @@ pub fn default_submod_path<'a>(\n     let default_exists = sess.source_map().file_exists(&default_path);\n     let secondary_exists = sess.source_map().file_exists(&secondary_path);\n \n-    let result = match (default_exists, secondary_exists) {\n+    match (default_exists, secondary_exists) {\n         (true, false) => Ok(ModulePathSuccess {\n             file_path: default_path,\n             dir_ownership: DirOwnership::Owned { relative: Some(ident) },\n@@ -231,35 +199,65 @@ pub fn default_submod_path<'a>(\n             file_path: secondary_path,\n             dir_ownership: DirOwnership::Owned { relative: None },\n         }),\n-        (false, false) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0583,\n-                \"file not found for module `{}`\",\n-                mod_name,\n-            );\n-            err.help(&format!(\n-                \"to create the module `{}`, create file \\\"{}\\\"\",\n-                mod_name,\n-                default_path.display(),\n-            ));\n-            Err(err)\n-        }\n+        (false, false) => Err(ModError::FileNotFound(ident, default_path)),\n         (true, true) => {\n-            let mut err = struct_span_err!(\n-                sess.span_diagnostic,\n-                span,\n-                E0761,\n-                \"file for module `{}` found at both {} and {}\",\n-                mod_name,\n-                default_path_str,\n-                secondary_path_str,\n-            );\n-            err.help(\"delete or rename one of them to remove the ambiguity\");\n-            Err(err)\n+            Err(ModError::MultipleCandidates(ident, default_path_str, secondary_path_str))\n         }\n-    };\n+    }\n+}\n \n-    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+impl ModError<'_> {\n+    fn report(self, sess: &Session, span: Span) {\n+        let diag = &sess.parse_sess.span_diagnostic;\n+        match self {\n+            ModError::CircularInclusion(file_paths) => {\n+                let mut msg = String::from(\"circular modules: \");\n+                for file_path in &file_paths {\n+                    msg.push_str(&file_path.display().to_string());\n+                    msg.push_str(\" -> \");\n+                }\n+                msg.push_str(&file_paths[0].display().to_string());\n+                diag.struct_span_err(span, &msg)\n+            }\n+            ModError::ModInBlock(ident) => {\n+                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n+                let mut err = diag.struct_span_err(span, msg);\n+                if let Some(ident) = ident {\n+                    let note =\n+                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n+                    err.span_note(span, &note);\n+                }\n+                err\n+            }\n+            ModError::FileNotFound(ident, default_path) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    ident,\n+                );\n+                err.help(&format!(\n+                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    ident,\n+                    default_path.display(),\n+                ));\n+                err\n+            }\n+            ModError::MultipleCandidates(ident, default_path_short, secondary_path_short) => {\n+                let mut err = struct_span_err!(\n+                    diag,\n+                    span,\n+                    E0761,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    ident,\n+                    default_path_short,\n+                    secondary_path_short,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            ModError::ParserError(err) => err,\n+        }.emit()\n+    }\n }"}, {"sha": "fa81769e5a80021380f77c36d8fb66f45351c28b", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -2,7 +2,7 @@\n \n macro_rules! mod_decl {\n     ($i:ident) => {\n-        mod $i; //~ ERROR Cannot declare a non-inline module inside a block\n+        mod $i; //~ ERROR cannot declare a non-inline module inside a block\n     };\n }\n "}, {"sha": "4039728e18ac384c22fef6784a6559e52969349c", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/macro-expanded-mod.rs:5:9\n    |\n LL |         mod $i;"}, {"sha": "de4f816656cc477b21c913e831c54f41b943849a", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.rs?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -1,5 +1,5 @@\n // Test that non-inline modules are not allowed inside blocks.\n \n fn main() {\n-    mod foo; //~ ERROR Cannot declare a non-inline module inside a block\n+    mod foo; //~ ERROR cannot declare a non-inline module inside a block\n }"}, {"sha": "64189bee43f6ebc07f1db8e02340d7d789c86a0c", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fe2eb83ecfed43874b4cdf39d0be8910995dd1d/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr?ref=1fe2eb83ecfed43874b4cdf39d0be8910995dd1d", "patch": "@@ -1,4 +1,4 @@\n-error: Cannot declare a non-inline module inside a block unless it has a path attribute\n+error: cannot declare a non-inline module inside a block unless it has a path attribute\n   --> $DIR/non-inline-mod-restriction.rs:4:5\n    |\n LL |     mod foo;"}]}