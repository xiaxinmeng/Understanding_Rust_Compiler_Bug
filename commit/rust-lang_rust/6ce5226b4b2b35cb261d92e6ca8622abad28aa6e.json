{"sha": "6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "node_id": "C_kwDOAAsO6NoAKDZjZTUyMjZiNGIyYjM1Y2IyNjFkOTJlNmNhODYyMmFiYWQyOGFhNmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T08:58:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T08:58:53Z"}, "message": "Auto merge of #2620 - RalfJung:getname, r=RalfJung\n\nadd pthread_getname_np\n\nA new libstd test needs this, and there doesn't seem to be a good reason not to have this.", "tree": {"sha": "a4917b467f55ce3425302a8e0414b0e470476b2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4917b467f55ce3425302a8e0414b0e470476b2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "html_url": "https://github.com/rust-lang/rust/commit/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "136a1db50df706c5bd794c0f11e84fc58f3afa14", "url": "https://api.github.com/repos/rust-lang/rust/commits/136a1db50df706c5bd794c0f11e84fc58f3afa14", "html_url": "https://github.com/rust-lang/rust/commit/136a1db50df706c5bd794c0f11e84fc58f3afa14"}, {"sha": "dac24128908bd542d5ab7660d1995859e8c2d858", "url": "https://api.github.com/repos/rust-lang/rust/commits/dac24128908bd542d5ab7660d1995859e8c2d858", "html_url": "https://github.com/rust-lang/rust/commit/dac24128908bd542d5ab7660d1995859e8c2d858"}], "stats": {"total": 188, "additions": 152, "deletions": 36}, "files": [{"sha": "ac5dcbf0f4f2fc8b799d046bf69f54bada7dc0fa", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -870,6 +870,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.machine.threads.active_thread_stack_mut()\n     }\n \n+    /// Set the name of the current thread. The buffer must not include the null terminator.\n     #[inline]\n     fn set_thread_name(&mut self, thread: ThreadId, new_thread_name: Vec<u8>) {\n         let this = self.eval_context_mut();"}, {"sha": "f98727186c48d91f07159b875e414e1cc454cf99", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -1,6 +1,7 @@\n pub mod convert;\n \n use std::cmp;\n+use std::iter;\n use std::mem;\n use std::num::NonZeroUsize;\n use std::time::Duration;\n@@ -735,6 +736,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         })\n     }\n \n+    /// Read a sequence of bytes until the first null terminator.\n     fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, &'a [u8]>\n     where\n         'tcx: 'a,\n@@ -761,6 +763,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.read_bytes_ptr_strip_provenance(ptr, len)\n     }\n \n+    /// Helper function to write a sequence of bytes with an added null-terminator, which is what\n+    /// the Unix APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `c_str` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator.\n+    fn write_c_str(\n+        &mut self,\n+        c_str: &[u8],\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n+        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n+        let string_length = u64::try_from(c_str.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+        self.eval_context_mut()\n+            .write_bytes_ptr(ptr, c_str.iter().copied().chain(iter::once(0u8)))?;\n+        Ok((true, string_length))\n+    }\n+\n+    /// Read a sequence of u16 until the first null terminator.\n     fn read_wide_str(&self, mut ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, Vec<u16>> {\n         let this = self.eval_context_ref();\n         let size2 = Size::from_bytes(2);\n@@ -783,6 +809,39 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(wchars)\n     }\n \n+    /// Helper function to write a sequence of u16 with an added 0x0000-terminator, which is what\n+    /// the Windows APIs usually handle. This function returns `Ok((false, length))` without trying\n+    /// to write if `size` is not large enough to fit the contents of `os_string` plus a null\n+    /// terminator. It returns `Ok((true, length))` if the writing process was successful. The\n+    /// string length returned does include the null terminator. Length is measured in units of\n+    /// `u16.`\n+    fn write_wide_str(\n+        &mut self,\n+        wide_str: &[u16],\n+        ptr: Pointer<Option<Provenance>>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n+        // 0x0000 terminator to memory would cause an out-of-bounds access.\n+        let string_length = u64::try_from(wide_str.len()).unwrap();\n+        let string_length = string_length.checked_add(1).unwrap();\n+        if size < string_length {\n+            return Ok((false, string_length));\n+        }\n+\n+        // Store the UTF-16 string.\n+        let size2 = Size::from_bytes(2);\n+        let this = self.eval_context_mut();\n+        let mut alloc = this\n+            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n+            .unwrap(); // not a ZST, so we will get a result\n+        for (offset, wchar) in wide_str.iter().copied().chain(iter::once(0x0000)).enumerate() {\n+            let offset = u64::try_from(offset).unwrap();\n+            alloc.write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar))?;\n+        }\n+        Ok((true, string_length))\n+    }\n+\n     /// Check that the ABI is what we expect.\n     fn check_abi<'a>(&self, abi: Abi, exp_abi: Abi) -> InterpResult<'a, ()> {\n         if self.eval_context_ref().machine.enforce_abi && abi != exp_abi {"}, {"sha": "99b3605c60175458d117488ab67d7bc01f22c5ce", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -1,6 +1,5 @@\n use std::borrow::Cow;\n use std::ffi::{OsStr, OsString};\n-use std::iter;\n use std::path::{Path, PathBuf};\n \n #[cfg(unix)]\n@@ -9,7 +8,6 @@ use std::os::unix::ffi::{OsStrExt, OsStringExt};\n use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n use rustc_middle::ty::layout::LayoutOf;\n-use rustc_target::abi::{Align, Size};\n \n use crate::*;\n \n@@ -100,16 +98,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let bytes = os_str_to_bytes(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required null\n-        // terminator to memory using the `ptr` pointer would cause an out-of-bounds access.\n-        let string_length = u64::try_from(bytes.len()).unwrap();\n-        let string_length = string_length.checked_add(1).unwrap();\n-        if size < string_length {\n-            return Ok((false, string_length));\n-        }\n-        self.eval_context_mut()\n-            .write_bytes_ptr(ptr, bytes.iter().copied().chain(iter::once(0u8)))?;\n-        Ok((true, string_length))\n+        self.eval_context_mut().write_c_str(bytes, ptr, size)\n     }\n \n     /// Helper function to write an OsStr as a 0x0000-terminated u16-sequence, which is what\n@@ -140,25 +129,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         let u16_vec = os_str_to_u16vec(os_str)?;\n-        // If `size` is smaller or equal than `bytes.len()`, writing `bytes` plus the required\n-        // 0x0000 terminator to memory would cause an out-of-bounds access.\n-        let string_length = u64::try_from(u16_vec.len()).unwrap();\n-        let string_length = string_length.checked_add(1).unwrap();\n-        if size < string_length {\n-            return Ok((false, string_length));\n-        }\n-\n-        // Store the UTF-16 string.\n-        let size2 = Size::from_bytes(2);\n-        let this = self.eval_context_mut();\n-        let mut alloc = this\n-            .get_ptr_alloc_mut(ptr, size2 * string_length, Align::from_bytes(2).unwrap())?\n-            .unwrap(); // not a ZST, so we will get a result\n-        for (offset, wchar) in u16_vec.into_iter().chain(iter::once(0x0000)).enumerate() {\n-            let offset = u64::try_from(offset).unwrap();\n-            alloc.write_scalar(alloc_range(size2 * offset, size2), Scalar::from_u16(wchar))?;\n-        }\n-        Ok((true, string_length))\n+        self.eval_context_mut().write_wide_str(&u16_vec, ptr, size)\n     }\n \n     /// Allocate enough memory to store the given `OsStr` as a null-terminated sequence of bytes."}, {"sha": "d755e5f10bae897947b7bd6bc41da1def3f196c7", "filename": "src/tools/miri/src/shims/unix/freebsd/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -26,8 +26,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_set_name_np\" => {\n                 let [thread, name] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let res =\n-                    this.pthread_setname_np(this.read_scalar(thread)?, this.read_scalar(name)?)?;\n+                let max_len = usize::MAX; // freebsd does not seem to have a limit.\n+                let res = this.pthread_setname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    max_len,\n+                )?;\n                 this.write_scalar(res, dest)?;\n             }\n "}, {"sha": "2b53152688bb787abd713355236435213048034c", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -68,8 +68,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_setname_np\" => {\n                 let [thread, name] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let res =\n-                    this.pthread_setname_np(this.read_scalar(thread)?, this.read_scalar(name)?)?;\n+                let max_len = 16;\n+                let res = this.pthread_setname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    max_len,\n+                )?;\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"pthread_getname_np\" => {\n+                let [thread, name, len] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_getname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    this.read_scalar(len)?,\n+                )?;\n                 this.write_scalar(res, dest)?;\n             }\n "}, {"sha": "371f56ca3555077abba010b91266352031505a8e", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -176,7 +176,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n-                this.pthread_setname_np(thread, this.read_scalar(name)?)?;\n+                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\")?.to_machine_usize(this)?;\n+                this.pthread_setname_np(\n+                    thread,\n+                    this.read_scalar(name)?,\n+                    max_len.try_into().unwrap(),\n+                )?;\n+            }\n+            \"pthread_getname_np\" => {\n+                let [thread, name, len] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let res = this.pthread_getname_np(\n+                    this.read_scalar(thread)?,\n+                    this.read_scalar(name)?,\n+                    this.read_scalar(len)?,\n+                )?;\n+                this.write_scalar(res, dest)?;\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work."}, {"sha": "b43682710bbe5c4adfba87955bb184f259348845", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -67,22 +67,49 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(Scalar::from_machine_usize(thread_id.into(), this))\n     }\n \n+    /// Set the name of the current thread. `max_name_len` is the maximal length of the name\n+    /// including the null terminator.\n     fn pthread_setname_np(\n         &mut self,\n         thread: Scalar<Provenance>,\n         name: Scalar<Provenance>,\n+        max_name_len: usize,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n         let name = name.to_pointer(this)?;\n \n         let name = this.read_c_str(name)?.to_owned();\n+\n+        // Comparing with `>=` to account for null terminator.\n+        if name.len() >= max_name_len {\n+            return this.eval_libc(\"ERANGE\");\n+        }\n+\n         this.set_thread_name(thread, name);\n \n         Ok(Scalar::from_u32(0))\n     }\n \n+    fn pthread_getname_np(\n+        &mut self,\n+        thread: Scalar<Provenance>,\n+        name_out: Scalar<Provenance>,\n+        len: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let thread = ThreadId::try_from(thread.to_machine_usize(this)?).unwrap();\n+        let name_out = name_out.to_pointer(this)?;\n+        let len = len.to_machine_usize(this)?;\n+\n+        let name = this.get_thread_name(thread).to_owned();\n+        let (success, _written) = this.write_c_str(&name, name_out, len)?;\n+\n+        if success { Ok(Scalar::from_u32(0)) } else { this.eval_libc(\"ERANGE\") }\n+    }\n+\n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n "}, {"sha": "bbddca74754c50125e47a2b46e5893da292b74da", "filename": "src/tools/miri/tests/pass-dep/shims/pthreads.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ce5226b4b2b35cb261d92e6ca8622abad28aa6e/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Fpthreads.rs?ref=6ce5226b4b2b35cb261d92e6ca8622abad28aa6e", "patch": "@@ -1,10 +1,14 @@\n //@ignore-target-windows: No libc on Windows\n+#![feature(cstr_from_bytes_until_nul)]\n+use std::ffi::CStr;\n+use std::thread;\n \n fn main() {\n     test_mutex_libc_init_recursive();\n     test_mutex_libc_init_normal();\n     test_mutex_libc_init_errorcheck();\n     test_rwlock_libc_static_initializer();\n+    test_named_thread_truncation();\n \n     #[cfg(any(target_os = \"linux\"))]\n     test_mutex_libc_static_initializer_recursive();\n@@ -125,3 +129,24 @@ fn test_rwlock_libc_static_initializer() {\n         assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n     }\n }\n+\n+fn test_named_thread_truncation() {\n+    let long_name = std::iter::once(\"test_named_thread_truncation\")\n+        .chain(std::iter::repeat(\" yada\").take(100))\n+        .collect::<String>();\n+\n+    let result = thread::Builder::new().name(long_name.clone()).spawn(move || {\n+        // Rust remembers the full thread name itself.\n+        assert_eq!(thread::current().name(), Some(long_name.as_str()));\n+\n+        // But the system is limited -- make sure we successfully set a truncation.\n+        let mut buf = vec![0u8; long_name.len() + 1];\n+        unsafe {\n+            libc::pthread_getname_np(libc::pthread_self(), buf.as_mut_ptr().cast(), buf.len());\n+        }\n+        let cstr = CStr::from_bytes_until_nul(&buf).unwrap();\n+        assert!(cstr.to_bytes().len() >= 15); // POSIX seems to promise at least 15 chars\n+        assert!(long_name.as_bytes().starts_with(cstr.to_bytes()));\n+    });\n+    result.unwrap().join().unwrap();\n+}"}]}