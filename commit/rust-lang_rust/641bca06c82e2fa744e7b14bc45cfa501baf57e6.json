{"sha": "641bca06c82e2fa744e7b14bc45cfa501baf57e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MWJjYTA2YzgyZTJmYTc0NGU3YjE0YmM0NWNmYTUwMWJhZjU3ZTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-07T00:56:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-08T00:54:34Z"}, "message": "rustdoc: Link \"Trait Implementations\" to sources\n\nAll methods listed in \"Trait Implementations\" now hyperlink to the source trait\ninstead of themselves, allowing easy browsing of the documentation of a trait\nmethod.\n\nCloses #17476", "tree": {"sha": "a058733e05332ad362f2f993b830277600c9db3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a058733e05332ad362f2f993b830277600c9db3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/641bca06c82e2fa744e7b14bc45cfa501baf57e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/641bca06c82e2fa744e7b14bc45cfa501baf57e6", "html_url": "https://github.com/rust-lang/rust/commit/641bca06c82e2fa744e7b14bc45cfa501baf57e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/641bca06c82e2fa744e7b14bc45cfa501baf57e6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcc89ea5006441350f0275946ff6db84a1118e49", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc89ea5006441350f0275946ff6db84a1118e49", "html_url": "https://github.com/rust-lang/rust/commit/fcc89ea5006441350f0275946ff6db84a1118e49"}], "stats": {"total": 248, "additions": 143, "deletions": 105}, "files": [{"sha": "365e34476aaf8bf3b7c4bb3e6abab4e8cc6d1e07", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 41, "deletions": 67, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=641bca06c82e2fa744e7b14bc45cfa501baf57e6", "patch": "@@ -281,48 +281,46 @@ impl fmt::Display for clean::Path {\n     }\n }\n \n+pub fn href(did: ast::DefId) -> Option<(String, ItemType, Vec<String>)> {\n+    let cache = cache();\n+    let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n+    let &(ref fqp, shortty) = match cache.paths.get(&did) {\n+        Some(p) => p,\n+        None => return None,\n+    };\n+    let mut url = if ast_util::is_local(did) || cache.inlined.contains(&did) {\n+        repeat(\"../\").take(loc.len()).collect::<String>()\n+    } else {\n+        match cache.extern_locations[&did.krate] {\n+            render::Remote(ref s) => s.to_string(),\n+            render::Local => repeat(\"../\").take(loc.len()).collect::<String>(),\n+            render::Unknown => return None,\n+        }\n+    };\n+    for component in &fqp[..fqp.len() - 1] {\n+        url.push_str(component);\n+        url.push_str(\"/\");\n+    }\n+    match shortty {\n+        ItemType::Module => {\n+            url.push_str(fqp.last().unwrap());\n+            url.push_str(\"/index.html\");\n+        }\n+        _ => {\n+            url.push_str(shortty.to_static_str());\n+            url.push_str(\".\");\n+            url.push_str(fqp.last().unwrap());\n+            url.push_str(\".html\");\n+        }\n+    }\n+    Some((url, shortty, fqp.to_vec()))\n+}\n+\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n-fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n+fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, path: &clean::Path,\n                  print_all: bool) -> fmt::Result {\n-    path(w, p, print_all,\n-        |cache, loc| {\n-            if ast_util::is_local(did) || cache.inlined.contains(&did) {\n-                Some(repeat(\"../\").take(loc.len()).collect::<String>())\n-            } else {\n-                match cache.extern_locations[&did.krate] {\n-                    render::Remote(ref s) => Some(s.to_string()),\n-                    render::Local => {\n-                        Some(repeat(\"../\").take(loc.len()).collect::<String>())\n-                    }\n-                    render::Unknown => None,\n-                }\n-            }\n-        },\n-        |cache| {\n-            match cache.paths.get(&did) {\n-                None => None,\n-                Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n-            }\n-        })\n-}\n-\n-fn path<F, G>(w: &mut fmt::Formatter,\n-              path: &clean::Path,\n-              print_all: bool,\n-              root: F,\n-              info: G)\n-              -> fmt::Result where\n-    F: FnOnce(&render::Cache, &[String]) -> Option<String>,\n-    G: FnOnce(&render::Cache) -> Option<(Vec<String>, ItemType)>,\n-{\n-    // The generics will get written to both the title and link\n     let last = path.segments.last().unwrap();\n-    let generics = format!(\"{}\", last.params);\n-\n-    let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n-    let cache = cache();\n-    let abs_root = root(&*cache, &loc);\n     let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n         _ => None,\n@@ -334,8 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n             Some(root) => {\n                 let mut root = String::from_str(&root);\n                 for seg in &path.segments[..amt] {\n-                    if \"super\" == seg.name ||\n-                            \"self\" == seg.name {\n+                    if \"super\" == seg.name || \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n                     } else {\n                         root.push_str(&seg.name);\n@@ -355,37 +352,14 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         }\n     }\n \n-    match info(&*cache) {\n-        // This is a documented path, link to it!\n-        Some((ref fqp, shortty)) if abs_root.is_some() => {\n-            let mut url = String::from_str(&abs_root.unwrap());\n-            let to_link = &fqp[..fqp.len() - 1];\n-            for component in to_link {\n-                url.push_str(component);\n-                url.push_str(\"/\");\n-            }\n-            match shortty {\n-                ItemType::Module => {\n-                    url.push_str(fqp.last().unwrap());\n-                    url.push_str(\"/index.html\");\n-                }\n-                _ => {\n-                    url.push_str(shortty.to_static_str());\n-                    url.push_str(\".\");\n-                    url.push_str(fqp.last().unwrap());\n-                    url.push_str(\".html\");\n-                }\n-            }\n-\n+    match href(did) {\n+        Some((url, shortty, fqp)) => {\n             try!(write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>\",\n                           shortty, url, fqp.connect(\"::\"), last.name));\n         }\n-\n-        _ => {\n-            try!(write!(w, \"{}\", last.name));\n-        }\n+        _ => try!(write!(w, \"{}\", last.name)),\n     }\n-    try!(write!(w, \"{}\", generics));\n+    try!(write!(w, \"{}\", last.params));\n     Ok(())\n }\n "}, {"sha": "418256d4723df49bac32e088a2407d41ce6113cc", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=641bca06c82e2fa744e7b14bc45cfa501baf57e6", "patch": "@@ -62,7 +62,7 @@ use clean;\n use doctree;\n use fold::DocFolder;\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace, Stability};\n-use html::format::{ConciseStability, TyParamBounds, WhereClause};\n+use html::format::{ConciseStability, TyParamBounds, WhereClause, href};\n use html::highlight;\n use html::item_type::ItemType;\n use html::layout;\n@@ -137,6 +137,14 @@ pub struct Impl {\n     pub stability: Option<clean::Stability>,\n }\n \n+impl Impl {\n+    fn trait_did(&self) -> Option<ast::DefId> {\n+        self.impl_.trait_.as_ref().and_then(|tr| {\n+            if let clean::ResolvedPath { did, .. } = *tr {Some(did)} else {None}\n+        })\n+    }\n+}\n+\n /// This cache is used to store information about the `clean::Crate` being\n /// rendered in order to provide more useful documentation. This contains\n /// information like all implementors of a trait, all traits a type implements,\n@@ -277,7 +285,9 @@ impl fmt::Display for IndexItemFunctionType {\n             return write!(f, \"null\")\n         }\n \n-        let inputs: Vec<String> = self.inputs.iter().map(|ref t| format!(\"{}\", t)).collect();\n+        let inputs: Vec<String> = self.inputs.iter().map(|ref t| {\n+            format!(\"{}\", t)\n+        }).collect();\n         try!(write!(f, \"{{\\\"inputs\\\":[{}],\\\"output\\\":\", inputs.connect(\",\")));\n \n         match self.output {\n@@ -1780,23 +1790,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"{{\\n\"));\n         for t in &types {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, t));\n+            try!(render_method(w, t, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if types.len() > 0 && required.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m));\n+            try!(render_method(w, m, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n         if required.len() > 0 && provided.len() > 0 {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n             try!(write!(w, \"    \"));\n-            try!(render_method(w, m));\n+            try!(render_method(w, m, MethodLink::Anchor));\n             try!(write!(w, \" {{ ... }}\\n\"));\n         }\n         try!(write!(w, \"}}\"));\n@@ -1812,7 +1822,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                     shortty(m),\n                     *m.name.as_ref().unwrap(),\n                     ConciseStability(&m.stability)));\n-        try!(render_method(w, m));\n+        try!(render_method(w, m, MethodLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n         Ok(())\n@@ -1896,14 +1906,23 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n-fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n+fn render_method(w: &mut fmt::Formatter, meth: &clean::Item,\n+                 link: MethodLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter, it: &clean::Item,\n               unsafety: ast::Unsafety, abi: abi::Abi,\n               g: &clean::Generics, selfty: &clean::SelfTy,\n-              d: &clean::FnDecl) -> fmt::Result {\n+              d: &clean::FnDecl, link: MethodLink) -> fmt::Result {\n         use syntax::abi::Abi;\n \n-        write!(w, \"{}{}fn <a href='#{ty}.{name}' class='fnname'>{name}</a>\\\n+        let name = it.name.as_ref().unwrap();\n+        let anchor = format!(\"#{}.{}\", shortty(it), name);\n+        let href = match link {\n+            MethodLink::Anchor => anchor,\n+            MethodLink::GotoSource(did) => {\n+                href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            }\n+        };\n+        write!(w, \"{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                match unsafety {\n                    ast::Unsafety::Unsafe => \"unsafe \",\n@@ -1913,18 +1932,20 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                    Abi::Rust => String::new(),\n                    a => format!(\"extern {} \", a.to_string())\n                },\n-               ty = shortty(it),\n-               name = it.name.as_ref().unwrap(),\n+               href = href,\n+               name = name,\n                generics = *g,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl)\n+            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n+                   link)\n         }\n         clean::MethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl)\n+            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n+                   link)\n         }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n@@ -2151,6 +2172,12 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+#[derive(Copy, Clone)]\n+enum MethodLink {\n+    Anchor,\n+    GotoSource(ast::DefId),\n+}\n+\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache().impls.get(&it.def_id) {\n         Some(v) => {\n@@ -2159,7 +2186,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 for i in &non_trait {\n-                    try!(render_impl(w, i));\n+                    try!(render_impl(w, i, MethodLink::Anchor));\n                 }\n             }\n             if traits.len() > 0 {\n@@ -2168,13 +2195,16 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n                 let (derived, manual): (Vec<_>, _) = traits.into_iter()\n                     .partition(|i| i.impl_.derived);\n                 for i in &manual {\n-                    try!(render_impl(w, i));\n+                    let did = i.trait_did().unwrap();\n+                    try!(render_impl(w, i, MethodLink::GotoSource(did)));\n                 }\n                 if derived.len() > 0 {\n-                    try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n-                                </h3>\"));\n+                    try!(write!(w, \"<h3 id='derived_implementations'>\\\n+                        Derived Implementations \\\n+                    </h3>\"));\n                     for i in &derived {\n-                        try!(render_impl(w, i));\n+                        let did = i.trait_did().unwrap();\n+                        try!(render_impl(w, i, MethodLink::GotoSource(did)));\n                     }\n                 }\n             }\n@@ -2184,36 +2214,32 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n+               -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n                 ConciseStability(&i.stability),\n                 i.impl_.generics));\n-    match i.impl_.polarity {\n-        Some(clean::ImplPolarity::Negative) => try!(write!(w, \"!\")),\n-        _ => {}\n+    if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n+        try!(write!(w, \"!\"));\n     }\n-    match i.impl_.trait_ {\n-        Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n-        None => {}\n+    if let Some(ref ty) = i.impl_.trait_ {\n+        try!(write!(w, \"{} for \", *ty));\n     }\n-    try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_, WhereClause(&i.impl_.generics)));\n-    match i.dox {\n-        Some(ref dox) => {\n-            try!(write!(w, \"<div class='docblock'>{}</div>\",\n-                          Markdown(dox)));\n-        }\n-        None => {}\n+    try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_,\n+                WhereClause(&i.impl_.generics)));\n+    if let Some(ref dox) = i.dox {\n+        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n     }\n \n-    fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item, dox: bool)\n-                    -> fmt::Result {\n+    fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n+                    dox: bool, link: MethodLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 try!(write!(w, \"<h4 id='method.{}' class='{}'>{}<code>\",\n                             *item.name.as_ref().unwrap(),\n                             shortty(item),\n                             ConciseStability(&item.stability)));\n-                try!(render_method(w, item));\n+                try!(render_method(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n@@ -2247,10 +2273,11 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n     for trait_item in i.impl_.items.iter() {\n-        try!(doctraititem(w, trait_item, true));\n+        try!(doctraititem(w, trait_item, true, link));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n+                              did: ast::DefId,\n                               t: &clean::Trait,\n                               i: &clean::Impl) -> fmt::Result {\n         for trait_item in &t.items {\n@@ -2260,7 +2287,8 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, false));\n+            try!(doctraititem(w, trait_item, false,\n+                              MethodLink::GotoSource(did)));\n         }\n         Ok(())\n     }\n@@ -2271,7 +2299,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     // for them work.\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n-            try!(render_default_methods(w, t, &i.impl_));\n+            try!(render_default_methods(w, did, t, &i.impl_));\n         }\n     }\n     try!(write!(w, \"</div>\"));"}, {"sha": "d3a860357422c2ad3046342b2b374461ab0d2e03", "filename": "src/test/auxiliary/issue-17476.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Ftest%2Fauxiliary%2Fissue-17476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Ftest%2Fauxiliary%2Fissue-17476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17476.rs?ref=641bca06c82e2fa744e7b14bc45cfa501baf57e6", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![doc(html_root_url = \"http://example.com\")]\n+\n+pub trait Foo {\n+    fn foo(&self) {}\n+}"}, {"sha": "cb224d66b44024b901e4c96eca86d0ac96c87115", "filename": "src/test/rustdoc/issue-17476.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Ftest%2Frustdoc%2Fissue-17476.rs", "raw_url": "https://github.com/rust-lang/rust/raw/641bca06c82e2fa744e7b14bc45cfa501baf57e6/src%2Ftest%2Frustdoc%2Fissue-17476.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-17476.rs?ref=641bca06c82e2fa744e7b14bc45cfa501baf57e6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-17476.rs\n+\n+extern crate issue_17476;\n+\n+pub struct Foo;\n+\n+// @has issue_17476/struct.Foo.html \\\n+//      '//*[@href=\"http://example.com/issue_17476/trait.Foo.html#tymethod.foo\"]' \\\n+//      'foo'\n+impl issue_17476::Foo for Foo {}"}]}