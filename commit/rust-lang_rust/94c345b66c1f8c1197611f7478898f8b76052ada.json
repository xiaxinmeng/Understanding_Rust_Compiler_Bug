{"sha": "94c345b66c1f8c1197611f7478898f8b76052ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YzM0NWI2NmMxZjhjMTE5NzYxMWY3NDc4ODk4ZjhiNzYwNTJhZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-04T11:10:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-05T12:11:47Z"}, "message": "Convert astconv and friends to use object types, not generics. No need to compile\nall that stuff twice. Also, code reads so much nicer.", "tree": {"sha": "7bdd3756549839c427b6347d4e01333c03ec97d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bdd3756549839c427b6347d4e01333c03ec97d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94c345b66c1f8c1197611f7478898f8b76052ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94c345b66c1f8c1197611f7478898f8b76052ada", "html_url": "https://github.com/rust-lang/rust/commit/94c345b66c1f8c1197611f7478898f8b76052ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94c345b66c1f8c1197611f7478898f8b76052ada/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f732ef53d54ccfc3e7728390ffbcea8a696ecee", "html_url": "https://github.com/rust-lang/rust/commit/1f732ef53d54ccfc3e7728390ffbcea8a696ecee"}], "stats": {"total": 222, "additions": 103, "deletions": 119}, "files": [{"sha": "ea1577d52a335c7bb9e407343dee4e03fbd64f87", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 103, "deletions": 119, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/94c345b66c1f8c1197611f7478898f8b76052ada/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c345b66c1f8c1197611f7478898f8b76052ada/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=94c345b66c1f8c1197611f7478898f8b76052ada", "patch": "@@ -70,7 +70,9 @@ use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n+\n     fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n+\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n@@ -162,9 +164,9 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n     r\n }\n \n-pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn opt_ast_region_to_region<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     default_span: Span,\n     opt_lifetime: &Option<ast::Lifetime>) -> ty::Region\n {\n@@ -241,13 +243,12 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n-fn ast_path_substs_for_ty<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn ast_path_substs_for_ty<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     decl_generics: &ty::Generics<'tcx>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let tcx = this.tcx();\n \n@@ -285,16 +286,15 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n                                regions)\n }\n \n-fn create_substs_for_ast_path<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn create_substs_for_ast_path<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n     regions: Vec<ty::Region>)\n- -> Substs<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+    -> Substs<'tcx>\n {\n     let tcx = this.tcx();\n \n@@ -408,13 +408,12 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n-                                                    rscope: &RS,\n-                                                    data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>,\n-                                                        Vec<Ty<'tcx>>,\n-                                                        Vec<ConvertedBinding<'tcx>>)\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n+                                            rscope: &RegionScope,\n+                                            data: &ast::AngleBracketedParameterData)\n+                                            -> (Vec<ty::Region>,\n+                                                Vec<Ty<'tcx>>,\n+                                                Vec<ConvertedBinding<'tcx>>)\n {\n     let regions: Vec<_> =\n         data.lifetimes.iter()\n@@ -468,12 +467,11 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n     (implied_output_region, lifetimes_for_params)\n }\n \n-fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n-                                             implied_output_region: Option<ty::Region>,\n-                                             param_lifetimes: Vec<(String, uint)>,\n-                                             ty: &ast::Ty)\n-                                             -> Ty<'tcx>\n-    where AC: AstConv<'tcx>\n+fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n+                                          implied_output_region: Option<ty::Region>,\n+                                          param_lifetimes: Vec<(String, uint)>,\n+                                          ty: &ast::Ty)\n+                                          -> Ty<'tcx>\n {\n     match implied_output_region {\n         Some(implied_output_region) => {\n@@ -490,10 +488,9 @@ fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n     }\n }\n \n-fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n-                                             data: &ast::ParenthesizedParameterData)\n-                                             -> Vec<Ty<'tcx>>\n-    where AC: AstConv<'tcx>\n+fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n+                                          data: &ast::ParenthesizedParameterData)\n+                                          -> Vec<Ty<'tcx>>\n {\n     let binding_rscope = BindingRscope::new();\n     let inputs = data.inputs.iter()\n@@ -517,14 +514,13 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n-pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn instantiate_poly_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     ast_trait_ref: &ast::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let mut projections = Vec::new();\n \n@@ -545,14 +541,13 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_trait_ref<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn instantiate_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     ast_trait_ref: &ast::TraitRef,\n     self_ty: Option<Ty<'tcx>>,\n     projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n@@ -573,15 +568,14 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(\n     }\n }\n \n-fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn ast_path_to_trait_ref<'a,'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path,\n     mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n     -> Rc<ty::TraitRef<'tcx>>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n {\n     debug!(\"ast_path_to_trait_ref {}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n@@ -643,12 +637,11 @@ fn ast_path_to_trait_ref<'a,'tcx,AC,RS>(\n     trait_ref\n }\n \n-pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n-    this: &AC,\n+pub fn ast_type_binding_to_projection_predicate<'tcx>(\n+    this: &AstConv<'tcx>,\n     trait_ref: Rc<ty::TraitRef<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n     -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n-    where AC : AstConv<'tcx>\n {\n     // Given something like `U : SomeTrait<T=X>`, we want to produce a\n     // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n@@ -686,9 +679,9 @@ pub fn ast_type_binding_to_projection_predicate<'tcx,AC>(\n     })\n }\n \n-pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn ast_path_to_ty<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     did: ast::DefId,\n     path: &ast::Path)\n     -> TypeAndSubsts<'tcx>\n@@ -712,13 +705,12 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n /// and/or region variables are substituted.\n ///\n /// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn ast_path_to_ty_relaxed<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     did: ast::DefId,\n     path: &ast::Path)\n     -> TypeAndSubsts<'tcx>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n {\n     let tcx = this.tcx();\n     let ty::TypeScheme {\n@@ -754,9 +746,9 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n \n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n-pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n+pub fn ast_ty_to_builtin_ty<'tcx>(\n+        this: &AstConv<'tcx>,\n+        rscope: &RegionScope,\n         ast_ty: &ast::Ty)\n         -> Option<Ty<'tcx>> {\n     match ast_ty_to_prim_ty(this.tcx(), ast_ty) {\n@@ -807,12 +799,11 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n-fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                   rscope: &RS,\n-                                   ty: &ast::Ty,\n-                                   bounds: &[ast::TyParamBound])\n-                                   -> Result<TraitAndProjections<'tcx>, ErrorReported>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n+fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n+                             rscope: &RegionScope,\n+                             ty: &ast::Ty,\n+                             bounds: &[ast::TyParamBound])\n+                             -> Result<TraitAndProjections<'tcx>, ErrorReported>\n {\n     /*!\n      * In a type like `Foo + Send`, we want to wait to collect the\n@@ -878,14 +869,13 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n-                                        rscope: &RS,\n-                                        span: Span,\n-                                        trait_ref: ty::PolyTraitRef<'tcx>,\n-                                        projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                                        bounds: &[ast::TyParamBound])\n-                                        -> Ty<'tcx>\n-    where AC : AstConv<'tcx>, RS : RegionScope\n+fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n+                                  rscope: &RegionScope,\n+                                  span: Span,\n+                                  trait_ref: ty::PolyTraitRef<'tcx>,\n+                                  projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                                  bounds: &[ast::TyParamBound])\n+                                  -> Ty<'tcx>\n {\n     let existential_bounds = conv_existential_bounds(this,\n                                                      rscope,\n@@ -963,12 +953,11 @@ fn trait_defines_associated_type_named(this: &AstConv,\n     trait_def.associated_type_names.contains(&assoc_name)\n }\n \n-fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n-                           rscope: &RS,\n-                           ast_ty: &ast::Ty, // the TyQPath\n-                           qpath: &ast::QPath)\n-                           -> Ty<'tcx>\n-    where AC: AstConv<'tcx>, RS: RegionScope\n+fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n+                     rscope: &RegionScope,\n+                     ast_ty: &ast::Ty, // the TyQPath\n+                     qpath: &ast::QPath)\n+                     -> Ty<'tcx>\n {\n     debug!(\"qpath_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -992,8 +981,8 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n \n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n-pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>\n+pub fn ast_ty_to_ty<'tcx>(\n+        this: &AstConv<'tcx>, rscope: &RegionScope, ast_ty: &ast::Ty) -> Ty<'tcx>\n {\n     debug!(\"ast_ty_to_ty(ast_ty={})\",\n            ast_ty.repr(this.tcx()));\n@@ -1205,10 +1194,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     return typ;\n }\n \n-pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &RS,\n-                                                           a: &ast::Arg,\n-                                                           expected_ty: Option<Ty<'tcx>>)\n-                                                           -> Ty<'tcx> {\n+pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n+                       rscope: &RegionScope,\n+                       a: &ast::Arg,\n+                       expected_ty: Option<Ty<'tcx>>)\n+                       -> Ty<'tcx>\n+{\n     match a.ty.node {\n         ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         ast::TyInfer => this.ty_infer(a.ty.span),\n@@ -1221,14 +1212,13 @@ struct SelfInfo<'a, 'tcx> {\n     explicit_self: &'a ast::ExplicitSelf,\n }\n \n-pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n-                    this: &AC,\n-                    unsafety: ast::Unsafety,\n-                    untransformed_self_ty: Ty<'tcx>,\n-                    explicit_self: &ast::ExplicitSelf,\n-                    decl: &ast::FnDecl,\n-                    abi: abi::Abi)\n-                    -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n+                          unsafety: ast::Unsafety,\n+                          untransformed_self_ty: Ty<'tcx>,\n+                          explicit_self: &ast::ExplicitSelf,\n+                          decl: &ast::FnDecl,\n+                          abi: abi::Abi)\n+                          -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n     let self_info = Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self,\n@@ -1242,20 +1232,18 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, unsafety: ast::Unsafety, abi: abi::Abi,\n+pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx>, unsafety: ast::Unsafety, abi: abi::Abi,\n                                               decl: &ast::FnDecl) -> ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, unsafety, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n-                           this: &AC,\n-                           unsafety: ast::Unsafety,\n-                           abi: abi::Abi,\n-                           opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n-                           decl: &ast::FnDecl)\n-                           -> (ty::BareFnTy<'tcx>,\n-                               Option<ty::ExplicitSelfCategory>)\n+fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n+                                     unsafety: ast::Unsafety,\n+                                     abi: abi::Abi,\n+                                     opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n+                                     decl: &ast::FnDecl)\n+                                     -> (ty::BareFnTy<'tcx>, Option<ty::ExplicitSelfCategory>)\n {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1357,12 +1345,10 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     }, explicit_self_category_result)\n }\n \n-fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n-                                    RS:RegionScope>(\n-                                    this: &AC,\n-                                    rscope: &RS,\n-                                    self_info: &SelfInfo<'a, 'tcx>)\n-                                    -> ty::ExplicitSelfCategory\n+fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n+                                              rscope: &RegionScope,\n+                                              self_info: &SelfInfo<'a, 'tcx>)\n+                                              -> ty::ExplicitSelfCategory\n {\n     return match self_info.explicit_self.node {\n         ast::SelfStatic => ty::StaticExplicitSelfCategory,\n@@ -1439,8 +1425,8 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n     }\n }\n \n-pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n-    this: &AC,\n+pub fn ty_of_closure<'tcx>(\n+    this: &AstConv<'tcx>,\n     unsafety: ast::Unsafety,\n     onceness: ast::Onceness,\n     bounds: ty::ExistentialBounds<'tcx>,\n@@ -1501,9 +1487,9 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n /// `ExistentialBounds` struct. The `main_trait_refs` argument specifies the `Foo` -- it is absent\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n-pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn conv_existential_bounds<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -1517,13 +1503,12 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         this, rscope, span, principal_trait_ref, projection_bounds, partitioned_bounds)\n }\n \n-fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n-    this: &AC,\n-    rscope: &RS,\n+fn conv_ty_poly_trait_ref<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n-    where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n@@ -1556,15 +1541,14 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     }\n }\n \n-pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n-    this: &AC,\n-    rscope: &RS,\n+pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     mut projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>, // Empty for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds<'tcx>\n-    where AC: AstConv<'tcx>, RS:RegionScope\n {\n     let PartitionedBounds { builtin_bounds,\n                             trait_bounds,\n@@ -1657,9 +1641,9 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// A version of `compute_opt_region_bound` for use where some region bound is required\n /// (existential types, basically). Reports an error if no region bound can be derived and we are\n /// in an `rscope` that does not provide a default.\n-fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n+fn compute_region_bound<'tcx>(\n+    this: &AstConv<'tcx>,\n+    rscope: &RegionScope,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n     principal_trait_ref: Option<ty::PolyTraitRef<'tcx>>, // None for closures"}]}