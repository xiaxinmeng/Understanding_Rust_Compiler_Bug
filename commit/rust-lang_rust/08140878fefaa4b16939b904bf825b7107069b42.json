{"sha": "08140878fefaa4b16939b904bf825b7107069b42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MTQwODc4ZmVmYWE0YjE2OTM5YjkwNGJmODI1YjcxMDcwNjliNDI=", "commit": {"author": {"name": "Dan Robertson", "email": "danlrobertson89@gmail.com", "date": "2018-10-23T23:13:33Z"}, "committer": {"name": "Dan Robertson", "email": "dan@dlrobertson.com", "date": "2018-11-26T22:56:19Z"}, "message": "libcore: Add va_list lang item and intrinsics\n\n - Add the llvm intrinsics used to manipulate a va_list.\n - Add the va_list lang item in order to allow implementing\n   VaList in libcore.", "tree": {"sha": "c57592566d7448d27e46f4e261d446ca527c65dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c57592566d7448d27e46f4e261d446ca527c65dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08140878fefaa4b16939b904bf825b7107069b42", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF5dO2RaKc5C+SCJ9RcSmUsR+QqUFAlv8ehMACgkQRcSmUsR+\nQqUtBQ//b6KS6rtxW3BR+TFs4V+NeCj6n5vZAO+vu+NUB/Wx94BUdAy1L5R6Zz38\n+cp59X7wv5q38tlit1MC/U3P/8BuTLIj0UY85Nql0sJCPt6ENFg6gWPX5Hj09Y0U\nr5s6dw3yApM6iW7Zx7fYnAK62V+Vdnoi70mBeBvc4k1e+IzeZ9lt0VGegcPiDUbK\nVv/n0cXh62Nxcw606TBvFppO80WhW+nM/syTANuK9gxuTH3u7FurepTrbYd3ghWa\nh0t1Ug6s65C5wU81BxcaSE2nLA0C/HGkIR9fQnY+lZ4lrFBiVHU1x6wgjfK5UBN/\n1G0IPZnL8uom4TeH8sBwqDqDsbikndHzAlqz++b3mUVbuaBPLgdML2dkaDKhfg72\nlIkFJn8yJbOOrwJC1DI1lxnOplWy/RUvGE89ajPxVONXqrDBDU6Ci8J+1NRPdoz6\noRh+P/nvQbK+ZpODP8pUSXNUo+dacGpR9HqIBK4r3JIrBgFol5KOCyGhZMqmss+J\n14RTeq5XHQBkgLKCI2ZU19NG4KjRMt96QPxD4aSgGlk0MG67ZllQmnznIRFXAjYG\nHxIjQKo/7/kjqjqh4nkB7zy2GL4BrBbG0vOENN3JSMaWBE1x38F1VrmWU2cITPBY\nivuV7ly3jMuxmiIYrnkiUEM1DW+lFa0UAOoI6MFf/Im0NLQ/Dmw=\n=LhIY\n-----END PGP SIGNATURE-----", "payload": "tree c57592566d7448d27e46f4e261d446ca527c65dc\nparent 6bfb46e4ac9a2704f06de1a2ff7a4612cd70c8cb\nauthor Dan Robertson <danlrobertson89@gmail.com> 1540336413 +0000\ncommitter Dan Robertson <dan@dlrobertson.com> 1543272979 +0000\n\nlibcore: Add va_list lang item and intrinsics\n\n - Add the llvm intrinsics used to manipulate a va_list.\n - Add the va_list lang item in order to allow implementing\n   VaList in libcore.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08140878fefaa4b16939b904bf825b7107069b42", "html_url": "https://github.com/rust-lang/rust/commit/08140878fefaa4b16939b904bf825b7107069b42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08140878fefaa4b16939b904bf825b7107069b42/comments", "author": {"login": "dlrobertson", "id": 7504153, "node_id": "MDQ6VXNlcjc1MDQxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/7504153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlrobertson", "html_url": "https://github.com/dlrobertson", "followers_url": "https://api.github.com/users/dlrobertson/followers", "following_url": "https://api.github.com/users/dlrobertson/following{/other_user}", "gists_url": "https://api.github.com/users/dlrobertson/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlrobertson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlrobertson/subscriptions", "organizations_url": "https://api.github.com/users/dlrobertson/orgs", "repos_url": "https://api.github.com/users/dlrobertson/repos", "events_url": "https://api.github.com/users/dlrobertson/events{/privacy}", "received_events_url": "https://api.github.com/users/dlrobertson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlrobertson", "id": 7504153, "node_id": "MDQ6VXNlcjc1MDQxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/7504153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlrobertson", "html_url": "https://github.com/dlrobertson", "followers_url": "https://api.github.com/users/dlrobertson/followers", "following_url": "https://api.github.com/users/dlrobertson/following{/other_user}", "gists_url": "https://api.github.com/users/dlrobertson/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlrobertson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlrobertson/subscriptions", "organizations_url": "https://api.github.com/users/dlrobertson/orgs", "repos_url": "https://api.github.com/users/dlrobertson/repos", "events_url": "https://api.github.com/users/dlrobertson/events{/privacy}", "received_events_url": "https://api.github.com/users/dlrobertson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bfb46e4ac9a2704f06de1a2ff7a4612cd70c8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfb46e4ac9a2704f06de1a2ff7a4612cd70c8cb", "html_url": "https://github.com/rust-lang/rust/commit/6bfb46e4ac9a2704f06de1a2ff7a4612cd70c8cb"}], "stats": {"total": 481, "additions": 468, "deletions": 13}, "files": [{"sha": "edeb3b0d368b3077b4e7982c4a46a3ab5bf2a05a", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -1,6 +1,7 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n \n #![allow(non_camel_case_types)]\n+#![cfg_attr(stage0, allow(dead_code))]\n \n //! Utilities related to FFI bindings.\n \n@@ -40,3 +41,187 @@ impl fmt::Debug for c_void {\n         f.pad(\"c_void\")\n     }\n }\n+\n+/// Basic implementation of a `va_list`.\n+#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+              not(target_arch = \"x86_64\")),\n+          windows))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+extern {\n+    type VaListImpl;\n+}\n+\n+#[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+              not(target_arch = \"x86_64\")),\n+          windows))]\n+impl fmt::Debug for VaListImpl {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"va_list* {:p}\", self)\n+    }\n+}\n+\n+/// AArch64 ABI implementation of a `va_list`. See the\n+/// [Aarch64 Procedure Call Standard] for more details.\n+///\n+/// [AArch64 Procedure Call Standard]:\n+/// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055b/IHI0055B_aapcs64.pdf\n+#[cfg(all(target_arch = \"aarch64\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    stack: *mut (),\n+    gr_top: *mut (),\n+    vr_top: *mut (),\n+    gr_offs: i32,\n+    vr_offs: i32,\n+}\n+\n+/// PowerPC ABI implementation of a `va_list`.\n+#[cfg(all(target_arch = \"powerpc\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    gpr: u8,\n+    fpr: u8,\n+    reserved: u16,\n+    overflow_arg_area: *mut (),\n+    reg_save_area: *mut (),\n+}\n+\n+/// x86_64 ABI implementation of a `va_list`.\n+#[cfg(all(target_arch = \"x86_64\", not(windows)))]\n+#[repr(C)]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+struct VaListImpl {\n+    gp_offset: i32,\n+    fp_offset: i32,\n+    overflow_arg_area: *mut (),\n+    reg_save_area: *mut (),\n+}\n+\n+/// A wrapper for a `va_list`\n+#[lang = \"va_list\"]\n+#[derive(Debug)]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+#[repr(transparent)]\n+#[cfg(not(stage0))]\n+pub struct VaList<'a>(&'a mut VaListImpl);\n+\n+// The VaArgSafe trait needs to be used in public interfaces, however, the trait\n+// itself must not be allowed to be used outside this module. Allowing users to\n+// implement the trait for a new type (thereby allowing the va_arg intrinsic to\n+// be used on a new type) is likely to cause undefined behavior.\n+//\n+// FIXME(dlrobertson): In order to use the VaArgSafe trait in a public interface\n+// but also ensure it cannot be used elsewhere, the trait needs to be public\n+// within a private module. Once RFC 2145 has been implemented look into\n+// improving this.\n+mod sealed_trait {\n+    /// Trait which whitelists the allowed types to be used with [VaList::arg]\n+    ///\n+    /// [VaList::va_arg]: struct.VaList.html#method.arg\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub trait VaArgSafe {}\n+}\n+\n+macro_rules! impl_va_arg_safe {\n+    ($($t:ty),+) => {\n+        $(\n+            #[unstable(feature = \"c_variadic\",\n+                       reason = \"the `c_variadic` feature has not been properly tested on \\\n+                                 all supported platforms\",\n+                       issue = \"27745\")]\n+            impl sealed_trait::VaArgSafe for $t {}\n+        )+\n+    }\n+}\n+\n+impl_va_arg_safe!{i8, i16, i32, i64, usize}\n+impl_va_arg_safe!{u8, u16, u32, u64, isize}\n+impl_va_arg_safe!{f64}\n+\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+impl<T> sealed_trait::VaArgSafe for *mut T {}\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+impl<T> sealed_trait::VaArgSafe for *const T {}\n+\n+#[cfg(not(stage0))]\n+impl<'a> VaList<'a> {\n+    /// Advance to the next arg.\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n+        va_arg(self)\n+    }\n+\n+    /// Copy the `va_list` at the current location.\n+    #[unstable(feature = \"c_variadic\",\n+               reason = \"the `c_variadic` feature has not been properly tested on \\\n+                         all supported platforms\",\n+               issue = \"27745\")]\n+    pub unsafe fn copy<F, R>(&mut self, f: F) -> R\n+            where F: for<'copy> FnOnce(VaList<'copy>) -> R {\n+        #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+                      not(target_arch = \"x86_64\")),\n+                  windows))]\n+        let mut ap = va_copy(self);\n+        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+                  not(windows)))]\n+        let mut ap_inner = va_copy(self);\n+        #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+                  not(windows)))]\n+        let mut ap = VaList(&mut ap_inner);\n+        let ret = f(VaList(ap.0));\n+        va_end(&mut ap);\n+        ret\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+extern \"rust-intrinsic\" {\n+    /// Destroy the arglist `ap` after initialization with `va_start` or\n+    /// `va_copy`.\n+    fn va_end(ap: &mut VaList);\n+\n+    /// Copy the current location of arglist `src` to the arglist `dst`.\n+    #[cfg(any(all(not(target_arch = \"aarch64\"), not(target_arch = \"powerpc\"),\n+                  not(target_arch = \"x86_64\")),\n+              windows))]\n+    fn va_copy<'a>(src: &VaList<'a>) -> VaList<'a>;\n+    #[cfg(all(any(target_arch = \"aarch64\", target_arch = \"powerpc\", target_arch = \"x86_64\"),\n+              not(windows)))]\n+    fn va_copy(src: &VaList) -> VaListImpl;\n+\n+    /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n+    /// argument `ap` points to.\n+    fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaList) -> T;\n+}"}, {"sha": "e7a8baf7383956e9172af5ecdd6f335e2608e3f5", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -297,6 +297,7 @@ language_item_table! {\n     IndexMutTraitLangItem,       \"index_mut\",          index_mut_trait,         Target::Trait;\n \n     UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n \n     DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n     DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;"}, {"sha": "d954eb838cb8a5fed42a31a11f5c1f64f916aefd", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -723,17 +723,17 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.bitreverse.i64\", fn(t_i64) -> t_i64);\n         ifn!(\"llvm.bitreverse.i128\", fn(t_i128) -> t_i128);\n \n-    ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n-\n-    ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n-    ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n-    ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n-    ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n-    ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+        ifn!(\"llvm.fshl.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+        ifn!(\"llvm.fshl.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+        ifn!(\"llvm.fshl.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+        ifn!(\"llvm.fshl.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+        ifn!(\"llvm.fshl.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n+\n+        ifn!(\"llvm.fshr.i8\", fn(t_i8, t_i8, t_i8) -> t_i8);\n+        ifn!(\"llvm.fshr.i16\", fn(t_i16, t_i16, t_i16) -> t_i16);\n+        ifn!(\"llvm.fshr.i32\", fn(t_i32, t_i32, t_i32) -> t_i32);\n+        ifn!(\"llvm.fshr.i64\", fn(t_i64, t_i64, t_i64) -> t_i64);\n+        ifn!(\"llvm.fshr.i128\", fn(t_i128, t_i128, t_i128) -> t_i128);\n \n         ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n         ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n@@ -783,6 +783,11 @@ impl IntrinsicDeclarationMethods<'tcx> for CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.assume\", fn(i1) -> void);\n         ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n+        // variadic intrinsics\n+        ifn!(\"llvm.va_start\", fn(i8p) -> void);\n+        ifn!(\"llvm.va_end\", fn(i8p) -> void);\n+        ifn!(\"llvm.va_copy\", fn(i8p, i8p) -> void);\n+\n         if self.sess().opts.debuginfo != DebugInfo::None {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);"}, {"sha": "9c9b73f63faedd54390983da48a668382bc6d45a", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -24,13 +24,14 @@ use context::CodegenCx;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, HasTyCtxt};\n+use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, Primitive};\n use rustc_codegen_ssa::common::TypeKind;\n use rustc::hir;\n-use syntax::ast;\n+use syntax::ast::{self, FloatTy};\n use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n+use va_arg::emit_va_arg;\n \n use rustc_codegen_ssa::traits::*;\n \n@@ -146,6 +147,59 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let tp_ty = substs.type_at(0);\n                 self.cx().const_usize(self.cx().size_of(tp_ty).bytes())\n             }\n+            func @ \"va_start\" | func @ \"va_end\" => {\n+                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n+                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n+                    (Some(_), _) => self.load(args[0].immediate(),\n+                                              tcx.data_layout.pointer_align.abi),\n+                    (None, _) => bug!(\"va_list language item must be defined\")\n+                };\n+                let intrinsic = self.cx().get_intrinsic(&format!(\"llvm.{}\", func));\n+                self.call(intrinsic, &[va_list], None)\n+            }\n+            \"va_copy\" => {\n+                let va_list = match (tcx.lang_items().va_list(), &result.layout.ty.sty) {\n+                    (Some(did), ty::Adt(def, _)) if def.did == did => args[0].immediate(),\n+                    (Some(_), _)  => self.load(args[0].immediate(),\n+                                               tcx.data_layout.pointer_align.abi),\n+                    (None, _) => bug!(\"va_list language item must be defined\")\n+                };\n+                let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n+                self.call(intrinsic, &[llresult, va_list], None);\n+                return;\n+            }\n+            \"va_arg\" => {\n+                match fn_ty.ret.layout.abi {\n+                    layout::Abi::Scalar(ref scalar) => {\n+                        match scalar.value {\n+                            Primitive::Int(..) => {\n+                                if self.cx().size_of(ret_ty).bytes() < 4 {\n+                                    // va_arg should not be called on a integer type\n+                                    // less than 4 bytes in length. If it is, promote\n+                                    // the integer to a `i32` and truncate the result\n+                                    // back to the smaller type.\n+                                    let promoted_result = emit_va_arg(self, args[0],\n+                                                                      tcx.types.i32);\n+                                    self.trunc(promoted_result, llret_ty)\n+                                } else {\n+                                    emit_va_arg(self, args[0], ret_ty)\n+                                }\n+                            }\n+                            Primitive::Float(FloatTy::F64) |\n+                            Primitive::Pointer => {\n+                                emit_va_arg(self, args[0], ret_ty)\n+                            }\n+                            // `va_arg` should never be used with the return type f32.\n+                            Primitive::Float(FloatTy::F32) => {\n+                                bug!(\"the va_arg intrinsic does not work with `f32`\")\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"the va_arg intrinsic does not work with non-scalar types\")\n+                    }\n+                }\n+            }\n             \"size_of_val\" => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {"}, {"sha": "4f90cb793b6d22a107bba9963b8362ea20f14e57", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -127,6 +127,7 @@ mod mono_item;\n mod type_;\n mod type_of;\n mod value;\n+mod va_arg;\n \n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());"}, {"sha": "fbc3e6f06d147446511d49447939ea34ad816cb4", "filename": "src/librustc_codegen_llvm/va_arg.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_codegen_llvm%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fva_arg.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use builder::Builder;\n+use rustc_codegen_ssa::mir::operand::OperandRef;\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods, ConstMethods, DerivedTypeMethods};\n+use rustc::ty::layout::{Align, HasDataLayout, HasTyCtxt, LayoutOf, Size};\n+use rustc::ty::Ty;\n+use type_::Type;\n+use type_of::LayoutLlvmExt;\n+use value::Value;\n+\n+#[allow(dead_code)]\n+fn round_pointer_up_to_alignment(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    addr: &'ll Value,\n+    align: Align,\n+    ptr_ty: &'ll Type\n+) -> &'ll Value {\n+    let mut ptr_as_int = bx.ptrtoint(addr, bx.cx().type_isize());\n+    ptr_as_int = bx.add(ptr_as_int, bx.cx().const_i32(align.bytes() as i32 - 1));\n+    ptr_as_int = bx.and(ptr_as_int, bx.cx().const_i32(-(align.bytes() as i32)));\n+    bx.inttoptr(ptr_as_int, ptr_ty)\n+}\n+\n+fn emit_direct_ptr_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    list: OperandRef<'tcx, &'ll Value>,\n+    llty: &'ll Type,\n+    size: Size,\n+    align: Align,\n+    slot_size: Align,\n+    allow_higher_align: bool\n+) -> (&'ll Value, Align) {\n+    let va_list_ptr_ty = bx.cx().type_ptr_to(bx.cx.type_i8p());\n+    let va_list_addr = if list.layout.llvm_type(bx.cx) != va_list_ptr_ty {\n+        bx.bitcast(list.immediate(), va_list_ptr_ty)\n+    } else {\n+        list.immediate()\n+    };\n+\n+    let ptr = bx.load(va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+\n+    let (addr, addr_align) = if allow_higher_align && align > slot_size {\n+        (round_pointer_up_to_alignment(bx, ptr, align, bx.cx().type_i8p()), align)\n+    } else {\n+        (ptr, slot_size)\n+    };\n+\n+\n+    let aligned_size = size.align_to(slot_size).bytes() as i32;\n+    let full_direct_size = bx.cx().const_i32(aligned_size);\n+    let next = bx.inbounds_gep(addr, &[full_direct_size]);\n+    bx.store(next, va_list_addr, bx.tcx().data_layout.pointer_align.abi);\n+\n+    if size.bytes() < slot_size.bytes() &&\n+            &*bx.tcx().sess.target.target.target_endian == \"big\" {\n+        let adjusted_size = bx.cx().const_i32((slot_size.bytes() - size.bytes()) as i32);\n+        let adjusted = bx.inbounds_gep(addr, &[adjusted_size]);\n+        (bx.bitcast(adjusted, bx.cx().type_ptr_to(llty)), addr_align)\n+    } else {\n+        (bx.bitcast(addr, bx.cx().type_ptr_to(llty)), addr_align)\n+    }\n+}\n+\n+fn emit_ptr_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    list: OperandRef<'tcx, &'ll Value>,\n+    target_ty: Ty<'tcx>,\n+    indirect: bool,\n+    slot_size: Align,\n+    allow_higher_align: bool\n+) -> &'ll Value {\n+    let layout = bx.cx.layout_of(target_ty);\n+    let (llty, size, align) = if indirect {\n+        (bx.cx.layout_of(bx.cx.tcx.mk_imm_ptr(target_ty)).llvm_type(bx.cx),\n+         bx.cx.data_layout().pointer_size,\n+         bx.cx.data_layout().pointer_align)\n+    } else {\n+        (layout.llvm_type(bx.cx),\n+         layout.size,\n+         layout.align)\n+    };\n+    let (addr, addr_align) = emit_direct_ptr_va_arg(bx, list, llty, size, align.abi,\n+                                                    slot_size, allow_higher_align);\n+    if indirect {\n+        let tmp_ret = bx.load(addr, addr_align);\n+        bx.load(tmp_ret, align.abi)\n+    } else {\n+        bx.load(addr, addr_align)\n+    }\n+}\n+\n+pub(super) fn emit_va_arg(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    addr: OperandRef<'tcx, &'ll Value>,\n+    target_ty: Ty<'tcx>,\n+) -> &'ll Value {\n+    // Determine the va_arg implementation to use. The LLVM va_arg instruction\n+    // is lacking in some instances, so we should only use it as a fallback.\n+    let arch = &bx.cx.tcx.sess.target.target.arch;\n+    match (&**arch,\n+           bx.cx.tcx.sess.target.target.options.is_like_windows) {\n+        (\"x86\", true) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(4).unwrap(), false)\n+        }\n+        (\"x86_64\", true) => {\n+            let target_ty_size = bx.cx.size_of(target_ty).bytes();\n+            let indirect = if target_ty_size > 8 || !target_ty_size.is_power_of_two() {\n+                true\n+            } else {\n+                false\n+            };\n+            emit_ptr_va_arg(bx, addr, target_ty, indirect,\n+                            Align::from_bytes(8).unwrap(), false)\n+        }\n+        (\"x86\", false) => {\n+            emit_ptr_va_arg(bx, addr, target_ty, false,\n+                            Align::from_bytes(4).unwrap(), true)\n+        }\n+        _ => {\n+            let va_list = if (bx.tcx().sess.target.target.arch == \"aarch64\" ||\n+                              bx.tcx().sess.target.target.arch == \"x86_64\" ||\n+                              bx.tcx().sess.target.target.arch == \"powerpc\") &&\n+                             !bx.tcx().sess.target.target.options.is_like_windows {\n+                bx.load(addr.immediate(), bx.tcx().data_layout.pointer_align.abi)\n+            } else {\n+                addr.immediate()\n+            };\n+            bx.va_arg(va_list, bx.cx.layout_of(target_ty).llvm_type(bx.cx))\n+        }\n+    }\n+}\n+"}, {"sha": "2af21f547445eb202659f2cd31907b2308a3b1ed", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -14,6 +14,7 @@\n use intrinsics;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::subst::Subst;\n use rustc::util::nodemap::FxHashMap;\n use require_same_types;\n \n@@ -81,6 +82,16 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                       it: &hir::ForeignItem) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)).as_interned_str());\n     let name = it.name.as_str();\n+\n+    let mk_va_list_ty = || {\n+        tcx.lang_items().va_list().map(|did| {\n+            let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n+            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+            let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n+            tcx.mk_mut_ref(tcx.mk_region(env_region), va_list_ty)\n+        })\n+    };\n+\n     let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n         let split : Vec<&str> = name.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n@@ -323,6 +334,47 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n+            \"va_start\" | \"va_end\" => {\n+                match mk_va_list_ty() {\n+                    Some(va_list_ty) => (0, vec![va_list_ty], tcx.mk_unit()),\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n+            \"va_copy\" => {\n+                match tcx.lang_items().va_list() {\n+                    Some(did) => {\n+                        let region = tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BrAnon(0)));\n+                        let env_region = ty::ReLateBound(ty::INNERMOST, ty::BrEnv);\n+                        let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n+                        let ret_ty = match va_list_ty.sty {\n+                            ty::Adt(def, _) if def.is_struct() => {\n+                                let fields = &def.non_enum_variant().fields;\n+                                match tcx.type_of(fields[0].did).subst(tcx, &[region.into()]).sty {\n+                                    ty::Ref(_, element_ty, _) => match element_ty.sty {\n+                                        ty::Adt(..) => element_ty,\n+                                        _ => va_list_ty\n+                                    }\n+                                    _ => bug!(\"va_list structure is invalid\")\n+                                }\n+                            }\n+                            _ => {\n+                                bug!(\"va_list structure is invalid\")\n+                            }\n+                        };\n+                        (0, vec![tcx.mk_imm_ref(tcx.mk_region(env_region), va_list_ty)], ret_ty)\n+                    }\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n+            \"va_arg\" => {\n+                match mk_va_list_ty() {\n+                    Some(va_list_ty) => (1, vec![va_list_ty], param(0)),\n+                    None => bug!(\"va_list lang_item must be defined to use va_list intrinsics\")\n+                }\n+            }\n+\n             \"nontemporal_store\" => {\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_unit())\n             }"}, {"sha": "b438417fd4ac6e09f82858332658dac763314ff8", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -174,5 +174,12 @@ pub use self::os_str::{OsString, OsStr};\n #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n pub use core::ffi::c_void;\n \n+#[cfg(not(stage0))]\n+#[unstable(feature = \"c_variadic\",\n+           reason = \"the `c_variadic` feature has not been properly tested on \\\n+                     all supported platforms\",\n+           issue = \"27745\")]\n+pub use core::ffi::VaList;\n+\n mod c_str;\n mod os_str;"}, {"sha": "5945ba6b09066d7aa3e44c732f12a6358dce7463", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -244,6 +244,7 @@\n #![feature(array_error_internals)]\n #![feature(asm)]\n #![feature(box_syntax)]\n+#![feature(c_variadic)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(cfg_target_vendor)]"}, {"sha": "822db253191387ddd384d734c4dffecf558f9eaa", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08140878fefaa4b16939b904bf825b7107069b42/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08140878fefaa4b16939b904bf825b7107069b42/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=08140878fefaa4b16939b904bf825b7107069b42", "patch": "@@ -74,6 +74,13 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libcore/tests\",\n     \"src/liballoc/tests/lib.rs\",\n \n+    // The `VaList` implementation must have platform specific code.\n+    // The Windows implementation of a `va_list` is always a character\n+    // pointer regardless of the target architecture. As a result,\n+    // we must use `#[cfg(windows)]` to conditionally compile the\n+    // correct `VaList` structure for windows.\n+    \"src/libcore/ffi.rs\",\n+\n     // non-std crates\n     \"src/test\",\n     \"src/tools\","}]}