{"sha": "5d8fd98d347239bc7e29c19988d7c19cf860cced", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkOGZkOThkMzQ3MjM5YmM3ZTI5YzE5OTg4ZDdjMTljZjg2MGNjZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T12:30:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T12:30:14Z"}, "message": "Auto merge of #60544 - petrochenkov:parder, r=eddyb\n\nRename `PathResolution` to `PartialRes`\n\nDon't use `PartialRes` when `Res` is enough.\nRename `Res::kind_name` to `Res::descr` for consistency.\nRemove `Res::Label`, paths can never resolve to labels.\n\nSome further cleanup after https://github.com/rust-lang/rust/pull/60462\nr? @eddyb", "tree": {"sha": "8b809c029a665150eb0f054476e87375079fc274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b809c029a665150eb0f054476e87375079fc274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d8fd98d347239bc7e29c19988d7c19cf860cced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8fd98d347239bc7e29c19988d7c19cf860cced", "html_url": "https://github.com/rust-lang/rust/commit/5d8fd98d347239bc7e29c19988d7c19cf860cced", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d8fd98d347239bc7e29c19988d7c19cf860cced/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d65e721ef824becd76773368718701cd0db83e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/d65e721ef824becd76773368718701cd0db83e59", "html_url": "https://github.com/rust-lang/rust/commit/d65e721ef824becd76773368718701cd0db83e59"}, {"sha": "7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7da9250fb51e71ecd3dbb4c760c24e836ed3530f", "html_url": "https://github.com/rust-lang/rust/commit/7da9250fb51e71ecd3dbb4c760c24e836ed3530f"}], "stats": {"total": 312, "additions": 143, "deletions": 169}, "files": [{"sha": "0719eb701a984be99d7d4404ccbcf57f0a20c133", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::DefId;\n-use crate::util::nodemap::{NodeMap, DefIdMap};\n+use crate::util::nodemap::DefIdMap;\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n@@ -142,7 +142,6 @@ pub enum Res<Id = hir::HirId> {\n     Upvar(Id,           // `HirId` of closed over local\n           usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n-    Label(ast::NodeId),\n \n     // Macro namespace\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n@@ -151,7 +150,9 @@ pub enum Res<Id = hir::HirId> {\n     Err,\n }\n \n-/// The result of resolving a path before lowering to HIR.\n+/// The result of resolving a path before lowering to HIR,\n+/// with \"module\" segments resolved and associated item\n+/// segments deferred to type checking.\n /// `base_res` is the resolution of the resolved part of the\n /// path, `unresolved_segments` is the number of unresolved\n /// segments.\n@@ -166,19 +167,21 @@ pub enum Res<Id = hir::HirId> {\n ///       base_res        unresolved_segments = 2\n /// ```\n #[derive(Copy, Clone, Debug)]\n-pub struct PathResolution {\n+pub struct PartialRes {\n     base_res: Res<NodeId>,\n     unresolved_segments: usize,\n }\n \n-impl PathResolution {\n-    pub fn new(res: Res<NodeId>) -> Self {\n-        PathResolution { base_res: res, unresolved_segments: 0 }\n+impl PartialRes {\n+    #[inline]\n+    pub fn new(base_res: Res<NodeId>) -> Self {\n+        PartialRes { base_res, unresolved_segments: 0 }\n     }\n \n-    pub fn with_unresolved_segments(res: Res<NodeId>, mut unresolved_segments: usize) -> Self {\n-        if res == Res::Err { unresolved_segments = 0 }\n-        PathResolution { base_res: res, unresolved_segments: unresolved_segments }\n+    #[inline]\n+    pub fn with_unresolved_segments(base_res: Res<NodeId>, mut unresolved_segments: usize) -> Self {\n+        if base_res == Res::Err { unresolved_segments = 0 }\n+        PartialRes { base_res, unresolved_segments }\n     }\n \n     #[inline]\n@@ -269,17 +272,10 @@ impl<T> PerNS<Option<T>> {\n     }\n }\n \n-/// Definition mapping\n-pub type ResMap = NodeMap<PathResolution>;\n-\n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n pub type ExportMap<Id> = DefIdMap<Vec<Export<Id>>>;\n \n-/// Map used to track the `use` statements within a scope, matching it with all the items in every\n-/// namespace.\n-pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n-\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export<Id> {\n     /// The name of the target.\n@@ -352,7 +348,6 @@ impl<Id> Res<Id> {\n \n             Res::Local(..) |\n             Res::Upvar(..) |\n-            Res::Label(..)  |\n             Res::PrimTy(..) |\n             Res::SelfTy(..) |\n             Res::SelfCtor(..) |\n@@ -373,14 +368,13 @@ impl<Id> Res<Id> {\n     }\n \n     /// A human readable name for the res kind (\"function\", \"module\", etc.).\n-    pub fn kind_name(&self) -> &'static str {\n+    pub fn descr(&self) -> &'static str {\n         match *self {\n             Res::Def(kind, _) => kind.descr(),\n             Res::SelfCtor(..) => \"self constructor\",\n             Res::PrimTy(..) => \"builtin type\",\n             Res::Local(..) => \"local variable\",\n             Res::Upvar(..) => \"closure capture\",\n-            Res::Label(..) => \"label\",\n             Res::SelfTy(..) => \"self type\",\n             Res::ToolMod => \"tool module\",\n             Res::NonMacroAttr(attr_kind) => attr_kind.descr(),\n@@ -408,7 +402,6 @@ impl<Id> Res<Id> {\n                 index,\n                 closure\n             ),\n-            Res::Label(id) => Res::Label(id),\n             Res::SelfTy(a, b) => Res::SelfTy(a, b),\n             Res::ToolMod => Res::ToolMod,\n             Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),"}, {"sha": "36e4195c989c0d0eb3a42c62e2ea95b110f4ad06", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use crate::hir::def::{Res, DefKind, PathResolution, PerNS};\n+use crate::hir::def::{Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n@@ -145,11 +145,14 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a `NodeId`.\n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n+    /// Obtain resolution for a `NodeId` with a single resolution.\n+    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n-    /// Obtain the possible resolutions for the given `use` statement.\n-    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>>;\n+    /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n+    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n+\n+    /// Obtain resolution for a label with the given `NodeId`.\n+    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n \n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     /// This should only return `None` during testing.\n@@ -821,7 +824,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n-        self.resolver.get_resolution(id).map_or(Res::Err, |pr| {\n+        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| {\n             if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n@@ -830,12 +833,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expect_full_res_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Res<NodeId>> {\n-        self.resolver.get_import(id).present_items().map(|pr| {\n-            if pr.unresolved_segments() != 0 {\n-                bug!(\"path not fully resolved: {:?}\", pr);\n-            }\n-            pr.base_res()\n-        })\n+        self.resolver.get_import_res(id).present_items()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n@@ -1251,7 +1249,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n         let target_id = match destination {\n             Some((id, _)) => {\n-                if let Res::Label(loop_id) = self.expect_full_res(id) {\n+                if let Some(loop_id) = self.resolver.get_label_res(id) {\n                     Ok(self.lower_node_id(loop_id))\n                 } else {\n                     Err(hir::LoopIdError::UnresolvedLabel)\n@@ -1842,13 +1840,13 @@ impl<'a> LoweringContext<'a> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n-        let resolution = self.resolver\n-            .get_resolution(id)\n-            .unwrap_or_else(|| PathResolution::new(Res::Err));\n+        let partial_res = self.resolver\n+            .get_partial_res(id)\n+            .unwrap_or_else(|| PartialRes::new(Res::Err));\n \n-        let proj_start = p.segments.len() - resolution.unresolved_segments();\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n         let path = P(hir::Path {\n-            res: self.lower_res(resolution.base_res()),\n+            res: self.lower_res(partial_res.base_res()),\n             segments: p.segments[..proj_start]\n                 .iter()\n                 .enumerate()\n@@ -1869,7 +1867,7 @@ impl<'a> LoweringContext<'a> {\n                         krate: def_id.krate,\n                         index: this.def_key(def_id).parent.expect(\"missing parent\"),\n                     };\n-                    let type_def_id = match resolution.base_res() {\n+                    let type_def_id = match partial_res.base_res() {\n                         Res::Def(DefKind::AssociatedTy, def_id) if i + 2 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n@@ -1886,7 +1884,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                         _ => None,\n                     };\n-                    let parenthesized_generic_args = match resolution.base_res() {\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _)\n                             if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n@@ -1940,7 +1938,7 @@ impl<'a> LoweringContext<'a> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if resolution.unresolved_segments() == 0 {\n+        if partial_res.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n@@ -2792,7 +2790,7 @@ impl<'a> LoweringContext<'a> {\n                                     && bound_pred.bound_generic_params.is_empty() =>\n                             {\n                                 if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n-                                    .get_resolution(bound_pred.bounded_ty.id)\n+                                    .get_partial_res(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_res())\n                                 {\n                                     if let Some(node_id) =\n@@ -3946,7 +3944,7 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                match self.resolver.get_resolution(p.id).map(|d| d.base_res()) {\n+                match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n                     // `None` can occur in body-less function signatures\n                     res @ None | res @ Some(Res::Local(_)) => {\n                         let canonical_id = match res {"}, {"sha": "3a98c4ea06121e3f611829de0301c6ef681fe8eb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -2143,7 +2143,7 @@ pub enum UseKind {\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n-/// within the ResMap.\n+/// within the resolution map.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,"}, {"sha": "ed183acc93b74f75e9f5adafb28c90c8fef37406", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 PatKind::Path(hir::QPath::Resolved(None, ref path))\n                         if path.segments.len() == 1 && path.segments[0].args.is_none() => {\n                     format!(\"interpreted as {} {} pattern, not new variable\",\n-                            path.res.article(), path.res.kind_name())\n+                            path.res.article(), path.res.descr())\n                 }\n                 _ => format!(\"pattern `{}` not covered\", pattern_string),\n             };"}, {"sha": "509aa95bb61dfc38ffff8f817caf5cb2bdaba6d1", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -41,7 +41,7 @@ impl<'a> Resolver<'a> {\n         let item_str = path.last().unwrap().ident;\n         let code = source.error_code(res.is_some());\n         let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n-            (format!(\"expected {}, found {} `{}`\", expected, res.kind_name(), path_str),\n+            (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 format!(\"not a {}\", expected),\n                 span)\n         } else {"}, {"sha": "a2d30de9da117f75b5ad523daba419db0d2a8cd3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 91, "deletions": 106, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{\n-    self, DefKind, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, ResMap, ImportMap, ExportMap\n+    self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n@@ -823,7 +823,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 let self_ty = keywords::SelfUpper.ident();\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n-                self.record_res(ty.id, PathResolution::new(res));\n+                self.record_partial_res(ty.id, PartialRes::new(res));\n             }\n             _ => (),\n         }\n@@ -1073,13 +1073,13 @@ enum RibKind<'a> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-struct Rib<'a> {\n-    bindings: FxHashMap<Ident, Res>,\n+struct Rib<'a, R = Res> {\n+    bindings: FxHashMap<Ident, R>,\n     kind: RibKind<'a>,\n }\n \n-impl<'a> Rib<'a> {\n-    fn new(kind: RibKind<'a>) -> Rib<'a> {\n+impl<'a, R> Rib<'a, R> {\n+    fn new(kind: RibKind<'a>) -> Rib<'a, R> {\n         Rib {\n             bindings: Default::default(),\n             kind,\n@@ -1148,7 +1148,7 @@ impl ModuleOrUniformRoot<'_> {\n #[derive(Clone, Debug)]\n enum PathResult<'a> {\n     Module(ModuleOrUniformRoot<'a>),\n-    NonModule(PathResolution),\n+    NonModule(PartialRes),\n     Indeterminate,\n     Failed {\n         span: Span,\n@@ -1534,7 +1534,7 @@ impl<'a> NameBinding<'a> {\n     }\n \n     fn descr(&self) -> &'static str {\n-        if self.is_extern_crate() { \"extern crate\" } else { self.res().kind_name() }\n+        if self.is_extern_crate() { \"extern crate\" } else { self.res().descr() }\n     }\n \n     fn article(&self) -> &'static str {\n@@ -1640,7 +1640,7 @@ pub struct Resolver<'a> {\n     ribs: PerNS<Vec<Rib<'a>>>,\n \n     /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a>>,\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n \n     /// The trait that the current context can refer to.\n     current_trait_ref: Option<(Module<'a>, TraitRef)>,\n@@ -1661,8 +1661,13 @@ pub struct Resolver<'a> {\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    res_map: ResMap,\n-    import_map: ImportMap,\n+    /// Resolutions for nodes that have a single resolution.\n+    partial_res_map: NodeMap<PartialRes>,\n+    /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n+    import_res_map: NodeMap<PerNS<Option<Res>>>,\n+    /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n+    label_res_map: NodeMap<NodeId>,\n+\n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap<NodeId>,\n@@ -1832,12 +1837,16 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.resolve_hir_path(&path, is_value)\n     }\n \n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n-        self.res_map.get(&id).cloned()\n+    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n+        self.partial_res_map.get(&id).cloned()\n+    }\n+\n+    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res>> {\n+        self.import_res_map.get(&id).cloned().unwrap_or_default()\n     }\n \n-    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>> {\n-        self.import_map.get(&id).cloned().unwrap_or_default()\n+    fn get_label_res(&mut self, id: NodeId) -> Option<NodeId> {\n+        self.label_res_map.get(&id).cloned()\n     }\n \n     fn definitions(&mut self) -> &mut Definitions {\n@@ -1921,7 +1930,7 @@ impl<'a> Resolver<'a> {\n \n         let segments: Vec<_> = segments.iter().map(|seg| {\n             let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n-            hir_seg.res = Some(self.res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n+            hir_seg.res = Some(self.partial_res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n                 p.base_res().map_id(|_| panic!(\"unexpected node_id\"))\n             }));\n             hir_seg\n@@ -2021,8 +2030,9 @@ impl<'a> Resolver<'a> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            res_map: Default::default(),\n-            import_map: Default::default(),\n+            partial_res_map: Default::default(),\n+            import_res_map: Default::default(),\n+            label_res_map: Default::default(),\n             freevars: Default::default(),\n             freevars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n@@ -2489,7 +2499,7 @@ impl<'a> Resolver<'a> {\n     ///\n     /// Stops after meeting a closure.\n     fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n-        where P: Fn(&Rib<'_>, Ident) -> Option<R>\n+        where P: Fn(&Rib<'_, NodeId>, Ident) -> Option<R>\n     {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n@@ -2707,7 +2717,7 @@ impl<'a> Resolver<'a> {\n                                 self.definitions.local_def_id(param.id),\n                             );\n                             function_type_rib.bindings.insert(ident, res);\n-                            self.record_res(param.id, PathResolution::new(res));\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                         GenericParamKind::Const { .. } => {\n                             let ident = param.ident.modern();\n@@ -2728,7 +2738,7 @@ impl<'a> Resolver<'a> {\n                                 self.definitions.local_def_id(param.id),\n                             );\n                             function_value_rib.bindings.insert(ident, res);\n-                            self.record_res(param.id, PathResolution::new(res));\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                     }\n                 }\n@@ -2996,7 +3006,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.res_map.get(&pat.id).map(|res| res.base_res()) {\n+                if sub_pat.is_some() || match self.partial_res_map.get(&pat.id)\n+                                                                  .map(|res| res.base_res()) {\n                     Some(Res::Local(..)) => true,\n                     _ => false,\n                 } {\n@@ -3148,7 +3159,7 @@ impl<'a> Resolver<'a> {\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n                      bindings: &mut FxHashMap<Ident, NodeId>)\n-                     -> PathResolution {\n+                     -> Res {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n         // must not add it if it's in the bindings map\n@@ -3195,7 +3206,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        PathResolution::new(res)\n+        res\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -3215,7 +3226,7 @@ impl<'a> Resolver<'a> {\n                     let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n                                                                       None, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n-                    let resolution = binding.map(NameBinding::res).and_then(|res| {\n+                    let res = binding.map(NameBinding::res).and_then(|res| {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n                         match res {\n@@ -3224,7 +3235,7 @@ impl<'a> Resolver<'a> {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(PathResolution::new(res))\n+                                Some(res)\n                             }\n                             Res::Def(DefKind::Ctor(..), _)\n                             | Res::Def(DefKind::Const, _)\n@@ -3256,7 +3267,7 @@ impl<'a> Resolver<'a> {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n                     });\n \n-                    self.record_res(pat.id, resolution);\n+                    self.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n \n                 PatKind::TupleStruct(ref path, ..) => {\n@@ -3288,35 +3299,15 @@ impl<'a> Resolver<'a> {\n                           id: NodeId,\n                           qself: Option<&QSelf>,\n                           path: &Path,\n-                          source: PathSource<'_>)\n-                          -> PathResolution {\n-        self.smart_resolve_path_with_crate_lint(id, qself, path, source, CrateLint::SimplePath(id))\n-    }\n-\n-    /// A variant of `smart_resolve_path` where you also specify extra\n-    /// information about where the path came from; this extra info is\n-    /// sometimes needed for the lint that recommends rewriting\n-    /// absolute paths to `crate`, so that it knows how to frame the\n-    /// suggestion. If you are just resolving a path like `foo::bar`\n-    /// that appears in an arbitrary location, then you just want\n-    /// `CrateLint::SimplePath`, which is what `smart_resolve_path`\n-    /// already provides.\n-    fn smart_resolve_path_with_crate_lint(\n-        &mut self,\n-        id: NodeId,\n-        qself: Option<&QSelf>,\n-        path: &Path,\n-        source: PathSource<'_>,\n-        crate_lint: CrateLint\n-    ) -> PathResolution {\n+                          source: PathSource<'_>) {\n         self.smart_resolve_path_fragment(\n             id,\n             qself,\n             &Segment::from_path(path),\n             path.span,\n             source,\n-            crate_lint,\n-        )\n+            CrateLint::SimplePath(id),\n+        );\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n@@ -3326,7 +3317,7 @@ impl<'a> Resolver<'a> {\n                                    span: Span,\n                                    source: PathSource<'_>,\n                                    crate_lint: CrateLint)\n-                                   -> PathResolution {\n+                                   -> PartialRes {\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n@@ -3336,10 +3327,10 @@ impl<'a> Resolver<'a> {\n             let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n             this.use_injections.push(UseError { err, candidates, node_id, better });\n-            err_path_resolution()\n+            PartialRes::new(Res::Err)\n         };\n \n-        let resolution = match self.resolve_qpath_anywhere(\n+        let partial_res = match self.resolve_qpath_anywhere(\n             id,\n             qself,\n             path,\n@@ -3349,14 +3340,14 @@ impl<'a> Resolver<'a> {\n             source.global_by_default(),\n             crate_lint,\n         ) {\n-            Some(resolution) if resolution.unresolved_segments() == 0 => {\n-                if is_expected(resolution.base_res()) || resolution.base_res() == Res::Err {\n-                    resolution\n+            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                    partial_res\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Res::Def(DefKind::Struct, def_id) = resolution.base_res() {\n+                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n                         if let Some((ctor_res, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_res) && self.is_accessible(ctor_vis) {\n@@ -3365,15 +3356,15 @@ impl<'a> Resolver<'a> {\n                                     \"private struct constructors are not usable through \\\n                                      re-exports in outer modules\",\n                                 );\n-                                res = Some(PathResolution::new(ctor_res));\n+                                res = Some(PartialRes::new(ctor_res));\n                             }\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_res())))\n+                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n                 }\n             }\n-            Some(resolution) if source.defer_to_typeck() => {\n+            Some(partial_res) if source.defer_to_typeck() => {\n                 // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n@@ -3401,16 +3392,16 @@ impl<'a> Resolver<'a> {\n                         hm.insert(span, span);\n                     }\n                 }\n-                resolution\n+                partial_res\n             }\n             _ => report_errors(self, None)\n         };\n \n         if let PathSource::TraitItem(..) = source {} else {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.record_res(id, resolution);\n+            self.record_partial_res(id, partial_res);\n         }\n-        resolution\n+        partial_res\n     }\n \n     /// Only used in a specific case of type ascription suggestions\n@@ -3525,7 +3516,7 @@ impl<'a> Resolver<'a> {\n         defer_to_typeck: bool,\n         global_by_default: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PathResolution> {\n+    ) -> Option<PartialRes> {\n         let mut fin_res = None;\n         // FIXME: can't resolve paths in macro namespace yet, macros are\n         // processed by the little special hack below.\n@@ -3534,9 +3525,10 @@ impl<'a> Resolver<'a> {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n-                    Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n-                        return Some(res),\n-                    res => if fin_res.is_none() { fin_res = res },\n+                    Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n+                                         defer_to_typeck =>\n+                        return Some(partial_res),\n+                    partial_res => if fin_res.is_none() { fin_res = partial_res },\n                 };\n             }\n         }\n@@ -3547,7 +3539,7 @@ impl<'a> Resolver<'a> {\n             self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(PathResolution::new(Res::Def(\n+            return Some(PartialRes::new(Res::Def(\n                 DefKind::Macro(MacroKind::Bang),\n                 DefId::local(CRATE_DEF_INDEX),\n             )));\n@@ -3565,7 +3557,7 @@ impl<'a> Resolver<'a> {\n         span: Span,\n         global_by_default: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PathResolution> {\n+    ) -> Option<PartialRes> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n              ns={:?}, span={:?}, global_by_default={:?})\",\n@@ -3582,7 +3574,7 @@ impl<'a> Resolver<'a> {\n                 // This is a case like `<T>::B`, where there is no\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n-                return Some(PathResolution::with_unresolved_segments(\n+                return Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n                 ));\n             }\n@@ -3602,7 +3594,7 @@ impl<'a> Resolver<'a> {\n             // name from a fully qualified path, and this also\n             // contains the full span (the `CrateLint::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let res = self.smart_resolve_path_fragment(\n+            let partial_res = self.smart_resolve_path_fragment(\n                 id,\n                 None,\n                 &path[..=qself.position],\n@@ -3617,8 +3609,9 @@ impl<'a> Resolver<'a> {\n             // The remaining segments (the `C` in our example) will\n             // have to be resolved by type-check, since that requires doing\n             // trait resolution.\n-            return Some(PathResolution::with_unresolved_segments(\n-                res.base_res(), res.unresolved_segments() + path.len() - qself.position - 1\n+            return Some(PartialRes::with_unresolved_segments(\n+                partial_res.base_res(),\n+                partial_res.unresolved_segments() + path.len() - qself.position - 1,\n             ));\n         }\n \n@@ -3631,7 +3624,7 @@ impl<'a> Resolver<'a> {\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n-                PathResolution::new(module.res().unwrap())\n+                PartialRes::new(module.res().unwrap())\n             }\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n@@ -3651,13 +3644,13 @@ impl<'a> Resolver<'a> {\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].ident.name) => {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n-                PathResolution::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n+                PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                PathResolution::new(module.res().unwrap()),\n+                PartialRes::new(module.res().unwrap()),\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n-                err_path_resolution()\n+                PartialRes::new(Res::Err)\n             }\n             PathResult::Module(..) | PathResult::Failed { .. } => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n@@ -3733,9 +3726,9 @@ impl<'a> Resolver<'a> {\n             let record_segment_res = |this: &mut Self, res| {\n                 if record_used {\n                     if let Some(id) = id {\n-                        if !this.res_map.contains_key(&id) {\n+                        if !this.partial_res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_res(id, PathResolution::new(res));\n+                            this.record_partial_res(id, PartialRes::new(res));\n                         }\n                     }\n                 }\n@@ -3839,7 +3832,7 @@ impl<'a> Resolver<'a> {\n                     Some(LexicalScopeBinding::Res(res))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         record_segment_res(self, res);\n-                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res, path.len() - 1\n                         ));\n                     }\n@@ -3866,25 +3859,25 @@ impl<'a> Resolver<'a> {\n                             ).emit();\n                         }\n                         let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PathResolution::new(res));\n+                        return PathResult::NonModule(PartialRes::new(res));\n                     } else if res == Res::Err {\n-                        return PathResult::NonModule(err_path_resolution());\n+                        return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n                         self.lint_if_path_starts_with_module(\n                             crate_lint,\n                             path,\n                             path_span,\n                             second_binding,\n                         );\n-                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res, path.len() - i - 1\n                         ));\n                     } else {\n                         let label = format!(\n                             \"`{}` is {} {}, not a module\",\n                             ident,\n                             res.article(),\n-                            res.kind_name(),\n+                            res.descr(),\n                         );\n \n                         return PathResult::Failed {\n@@ -3899,7 +3892,7 @@ impl<'a> Resolver<'a> {\n                 Err(Determined) => {\n                     if let Some(ModuleOrUniformRoot::Module(module)) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                                 module.res().unwrap(), path.len() - i\n                             ));\n                         }\n@@ -3930,7 +3923,7 @@ impl<'a> Resolver<'a> {\n                             (format!(\"maybe a missing `extern crate {};`?\", ident), None)\n                         } else {\n                             // the parser will already have complained about the keyword being used\n-                            return PathResult::NonModule(err_path_resolution());\n+                            return PathResult::NonModule(PartialRes::new(Res::Err));\n                         }\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)\n@@ -4179,7 +4172,7 @@ impl<'a> Resolver<'a> {\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.res_map.get(&node_id) {\n+                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n                     match resolution.base_res() {\n                         Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n                                 if resolution.unresolved_segments() == 0 => {\n@@ -4236,7 +4229,7 @@ impl<'a> Resolver<'a> {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: binding.res().article(),\n-                            kind: binding.res().kind_name(),\n+                            kind: binding.res().descr(),\n                         });\n                     }\n                 }\n@@ -4254,7 +4247,7 @@ impl<'a> Resolver<'a> {\n                         names.push(TypoSuggestion {\n                             candidate: ident.name,\n                             article: res.article(),\n-                            kind: res.kind_name(),\n+                            kind: res.descr(),\n                         });\n                     }\n                 }\n@@ -4348,10 +4341,9 @@ impl<'a> Resolver<'a> {\n     {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            let res = Res::Label(id);\n             self.with_label_rib(|this| {\n                 let ident = label.ident.modern_and_legacy();\n-                this.label_ribs.last_mut().unwrap().bindings.insert(ident, res);\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n         } else {\n@@ -4382,10 +4374,10 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                let res = self.search_label(label.ident, |rib, ident| {\n+                let node_id = self.search_label(label.ident, |rib, ident| {\n                     rib.bindings.get(&ident.modern_and_legacy()).cloned()\n                 });\n-                match res {\n+                match node_id {\n                     None => {\n                         // Search again for close matches...\n                         // Picks the first label that is \"close enough\", which is not necessarily\n@@ -4400,19 +4392,16 @@ impl<'a> Resolver<'a> {\n                             });\n                             find_best_match_for_name(names, &*ident.as_str(), None)\n                         });\n-                        self.record_res(expr.id, err_path_resolution());\n+                        self.record_partial_res(expr.id, PartialRes::new(Res::Err));\n                         resolve_error(self,\n                                       label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n                                                                        close_match));\n                     }\n-                    Some(Res::Label(id)) => {\n+                    Some(node_id) => {\n                         // Since this res is a label, it is never read.\n-                        self.record_res(expr.id, PathResolution::new(Res::Label(id)));\n-                        self.unused_labels.remove(&id);\n-                    }\n-                    Some(_) => {\n-                        span_bug!(expr.span, \"label wasn't mapped to a label res!\");\n+                        self.label_res_map.insert(expr.id, node_id);\n+                        self.unused_labels.remove(&node_id);\n                     }\n                 }\n \n@@ -4857,9 +4846,9 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn record_res(&mut self, node_id: NodeId, resolution: PathResolution) {\n+    fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n-        if let Some(prev_res) = self.res_map.insert(node_id, resolution) {\n+        if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n@@ -5482,10 +5471,6 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n                         .collect::<Vec<_>>()))\n }\n \n-fn err_path_resolution() -> PathResolution {\n-    PathResolution::new(Res::Err)\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum CrateLint {\n     /// Do not issue the lint."}, {"sha": "f1706a4616b06b92103759bc7e1937df793a50b9", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -333,7 +333,7 @@ impl<'a> Resolver<'a> {\n                     // Not only attributes, but anything in macro namespace can result in\n                     // `Res::NonMacroAttr` definition (e.g., `inline!()`), so we must report\n                     // an error for those cases.\n-                    let msg = format!(\"expected a macro, found {}\", res.kind_name());\n+                    let msg = format!(\"expected a macro, found {}\", res.descr());\n                     self.session.span_err(path.span, &msg);\n                     return Err(Determinacy::Determined);\n                 }\n@@ -913,7 +913,7 @@ impl<'a> Resolver<'a> {\n                         // (which is a best effort error recovery tool, basically), so we can't\n                         // promise their resolution won't change later.\n                         let msg = format!(\"inconsistent resolution for a macro: first {}, then {}\",\n-                                          initial_res.kind_name(), res.kind_name());\n+                                          initial_res.descr(), res.descr());\n                         this.session.span_err(span, &msg);\n                     } else {\n                         span_bug!(span, \"inconsistent resolution for a macro\");"}, {"sha": "9e6b8d035458de88d7e3ac31d6c0c4a230400251", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -21,7 +21,7 @@ use rustc::lint::builtin::{\n     UNUSED_IMPORTS,\n };\n use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::def::{self, DefKind, PathResolution, Export};\n+use rustc::hir::def::{self, DefKind, PartialRes, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n@@ -1233,8 +1233,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     res = Res::Err;\n                 }\n             }\n-            let import = this.import_map.entry(directive.id).or_default();\n-            import[ns] = Some(PathResolution::new(res));\n+            this.import_res_map.entry(directive.id).or_default()[ns] = Some(res);\n         });\n \n         self.check_for_redundant_imports(\n@@ -1371,7 +1370,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.record_res(directive.id, PathResolution::new(module.res().unwrap()));\n+        self.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,"}, {"sha": "f3e0fb32ec2dc28777ad61c03e79a3938fa8e700", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -796,7 +796,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             Res::PrimTy(..) |\n             Res::SelfTy(..) |\n-            Res::Label(..) |\n             Res::Def(HirDefKind::Macro(..), _) |\n             Res::ToolMod |\n             Res::NonMacroAttr(..) |"}, {"sha": "fa12d9c49dfc37ce383ade4ff37af9f88269c2d8", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -579,7 +579,7 @@ impl Sig for ast::Path {\n         let res = scx.get_path_res(id.ok_or(\"Missing id for Path\")?);\n \n         let (name, start, end) = match res {\n-            Res::Label(..) | Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n+            Res::PrimTy(..) | Res::SelfTy(..) | Res::Err => {\n                 return Ok(Signature {\n                     text: pprust::path_to_string(self),\n                     defs: vec![],"}, {"sha": "e9e202ce37996e515e0f137f2475e5722245aac4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -884,7 +884,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         };\n         let report_unexpected_res = |res: Res| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              res.kind_name(),\n+                              res.descr(),\n                               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, \"not a tuple variant or struct\").emit();\n@@ -947,7 +947,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n             struct_span_err!(tcx.sess, pat.span, E0023,\n                              \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, res.kind_name(),\n+                             subpats.len(), subpats_ending, res.descr(),\n                              variant.fields.len(),  fields_ending)\n                 .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n                                               variant.fields.len(), fields_ending, subpats.len()))"}, {"sha": "e404a8e6972c8c70a3ac48f1294606854339c77c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -1902,7 +1902,7 @@ fn report_unexpected_variant_res<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                  qpath: &QPath) {\n     span_err!(tcx.sess, span, E0533,\n               \"expected unit struct/variant or constant, found {} `{}`\",\n-              res.kind_name(),\n+              res.descr(),\n               hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n }\n "}, {"sha": "abf19a0a5efa4cca9346102bdd1d44dd4c52f5b1", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d8fd98d347239bc7e29c19988d7c19cf860cced/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=5d8fd98d347239bc7e29c19988d7c19cf860cced", "patch": "@@ -513,18 +513,18 @@ fn ambiguity_error(\n             msg += &format!(\n                 \"both {} {} and {} {}\",\n                 first_def.article(),\n-                first_def.kind_name(),\n+                first_def.descr(),\n                 second_def.article(),\n-                second_def.kind_name(),\n+                second_def.descr(),\n             );\n         }\n         _ => {\n             let mut candidates = candidates.iter().peekable();\n             while let Some((res, _)) = candidates.next() {\n                 if candidates.peek().is_some() {\n-                    msg += &format!(\"{} {}, \", res.article(), res.kind_name());\n+                    msg += &format!(\"{} {}, \", res.article(), res.descr());\n                 } else {\n-                    msg += &format!(\"and {} {}\", res.article(), res.kind_name());\n+                    msg += &format!(\"and {} {}\", res.article(), res.descr());\n                 }\n             }\n         }\n@@ -575,7 +575,7 @@ fn ambiguity_error(\n \n                 diag.span_suggestion(\n                     sp,\n-                    &format!(\"to link to the {}, {}\", res.kind_name(), action),\n+                    &format!(\"to link to the {}, {}\", res.descr(), action),\n                     suggestion,\n                     Applicability::MaybeIncorrect,\n                 );"}]}