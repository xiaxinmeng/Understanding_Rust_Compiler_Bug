{"sha": "fb974df28157f205f81d59ab3fc9cb96d78bf590", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOTc0ZGYyODE1N2YyMDVmODFkNTlhYjNmYzljYjk2ZDc4YmY1OTA=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-18T01:24:52Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move Flatten and FlatMap to own module", "tree": {"sha": "3c53db70ad0f106eb5c5032ec406f6f1cda86dce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c53db70ad0f106eb5c5032ec406f6f1cda86dce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb974df28157f205f81d59ab3fc9cb96d78bf590", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb974df28157f205f81d59ab3fc9cb96d78bf590", "html_url": "https://github.com/rust-lang/rust/commit/fb974df28157f205f81d59ab3fc9cb96d78bf590", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb974df28157f205f81d59ab3fc9cb96d78bf590/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7", "html_url": "https://github.com/rust-lang/rust/commit/ebfd08312522b85a5b4085aa0a2bf6fb9b9873d7"}], "stats": {"total": 634, "additions": 321, "deletions": 313}, "files": [{"sha": "b88e91fad3b0a0213bb5c9f52118e34d03ea742d", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/fb974df28157f205f81d59ab3fc9cb96d78bf590/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb974df28157f205f81d59ab3fc9cb96d78bf590/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=fb974df28157f205f81d59ab3fc9cb96d78bf590", "patch": "@@ -0,0 +1,318 @@\n+use fmt;\n+use ops::Try;\n+use super::super::{Iterator, DoubleEndedIterator, FusedIterator};\n+use super::Map;\n+\n+/// An iterator that maps each element to an iterator, and yields the elements\n+/// of the produced iterators.\n+///\n+/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flat_map`]: trait.Iterator.html#method.flat_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    pub(in super::super) inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n+\n+/// An iterator that flattens one level of nesting in an iterator of things\n+/// that can be turned into iterators.\n+///\n+/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`flatten`]: trait.Iterator.html#method.flatten\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    pub(in super::super) inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+pub(in super::super) fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n+#[derive(Clone, Debug)]\n+pub(in super::super) struct FlattenCompat<I, U> {\n+    iter: I,\n+    frontiter: Option<U>,\n+    backiter: Option<U>,\n+}\n+\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.frontiter {\n+                if let elt@Some(_) = inner.next() { return elt }\n+            }\n+            match self.iter.next() {\n+                None => return self.backiter.as_mut().and_then(|it| it.next()),\n+                Some(inner) => self.frontiter = Some(inner.into_iter()),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n+        let lo = flo.saturating_add(blo);\n+        match (self.iter.size_hint(), fhi, bhi) {\n+            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n+            _ => (lo, None)\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_fold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        {\n+            let frontiter = &mut self.frontiter;\n+            init = self.iter.try_fold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_fold(acc, &mut fold);\n+                *frontiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.frontiter = None;\n+\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_fold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n+    }\n+}\n+\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> {\n+        loop {\n+            if let Some(ref mut inner) = self.backiter {\n+                if let elt@Some(_) = inner.next_back() { return elt }\n+            }\n+            match self.iter.next_back() {\n+                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n+                next => self.backiter = next.map(IntoIterator::into_iter),\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        if let Some(ref mut back) = self.backiter {\n+            init = back.try_rfold(init, &mut fold)?;\n+        }\n+        self.backiter = None;\n+\n+        {\n+            let backiter = &mut self.backiter;\n+            init = self.iter.try_rfold(init, |acc, x| {\n+                let mut mid = x.into_iter();\n+                let r = mid.try_rfold(acc, &mut fold);\n+                *backiter = Some(mid);\n+                r\n+            })?;\n+        }\n+        self.backiter = None;\n+\n+        if let Some(ref mut front) = self.frontiter {\n+            init = front.try_rfold(init, &mut fold)?;\n+        }\n+        self.frontiter = None;\n+\n+        Try::from_ok(init)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.frontiter.into_iter()\n+            .chain(self.iter.map(IntoIterator::into_iter))\n+            .chain(self.backiter)\n+            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n+    }\n+}\n+"}, {"sha": "a3e0696d21531c5df82b2586fa836ea3f957f842", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 3, "deletions": 313, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/fb974df28157f205f81d59ab3fc9cb96d78bf590/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb974df28157f205f81d59ab3fc9cb96d78bf590/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=fb974df28157f205f81d59ab3fc9cb96d78bf590", "patch": "@@ -7,11 +7,14 @@ use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, Tru\n use super::LoopState;\n \n mod chain;\n+mod flatten;\n mod zip;\n \n pub use self::chain::Chain;\n+pub use self::flatten::{FlatMap, Flatten};\n pub use self::zip::Zip;\n pub(super) use self::chain::ChainState;\n+pub(super) use self::flatten::{FlattenCompat, flatten_compat};\n pub(super) use self::zip::ZipImpl;\n pub(crate) use self::zip::TrustedRandomAccess;\n \n@@ -1620,319 +1623,6 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n     }\n }\n \n-/// An iterator that maps each element to an iterator, and yields the elements\n-/// of the produced iterators.\n-///\n-/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flat_map`]: trait.Iterator.html#method.flat_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct FlatMap<I, U: IntoIterator, F> {\n-    pub(super) inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n-    where <U as IntoIterator>::IntoIter: Clone\n-{\n-    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n-    where U::IntoIter: fmt::Debug\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n-    where F: FnMut(I::Item) -> U,\n-          U: IntoIterator,\n-          U::IntoIter: DoubleEndedIterator\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n-    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n-\n-/// An iterator that flattens one level of nesting in an iterator of things\n-/// that can be turned into iterators.\n-///\n-/// This `struct` is created by the [`flatten`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`flatten`]: trait.Iterator.html#method.flatten\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-pub struct Flatten<I: Iterator>\n-where I::Item: IntoIterator {\n-    pub(super) inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> fmt::Debug for Flatten<I>\n-    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Clone for Flatten<I>\n-    where I: Iterator + Clone, U: Iterator + Clone,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n-{\n-    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> Iterator for Flatten<I>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> DoubleEndedIterator for Flatten<I>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        self.inner.try_rfold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.inner.rfold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n-impl<I, U> FusedIterator for Flatten<I>\n-    where I: FusedIterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n-\n-/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n-pub(super) fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n-    FlattenCompat { iter, frontiter: None, backiter: None }\n-}\n-\n-/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n-/// this type.\n-#[derive(Clone, Debug)]\n-pub(super) struct FlattenCompat<I, U> {\n-    iter: I,\n-    frontiter: Option<U>,\n-    backiter: Option<U>,\n-}\n-\n-impl<I, U> Iterator for FlattenCompat<I, U>\n-    where I: Iterator, U: Iterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    type Item = U::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.frontiter {\n-                if let elt@Some(_) = inner.next() { return elt }\n-            }\n-            match self.iter.next() {\n-                None => return self.backiter.as_mut().and_then(|it| it.next()),\n-                Some(inner) => self.frontiter = Some(inner.into_iter()),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (flo, fhi) = self.frontiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let (blo, bhi) = self.backiter.as_ref().map_or((0, Some(0)), |it| it.size_hint());\n-        let lo = flo.saturating_add(blo);\n-        match (self.iter.size_hint(), fhi, bhi) {\n-            ((0, Some(0)), Some(a), Some(b)) => (lo, a.checked_add(b)),\n-            _ => (lo, None)\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_fold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        {\n-            let frontiter = &mut self.frontiter;\n-            init = self.iter.try_fold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_fold(acc, &mut fold);\n-                *frontiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.frontiter = None;\n-\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_fold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .fold(init, |acc, iter| iter.fold(acc, &mut fold))\n-    }\n-}\n-\n-impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n-    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n-          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<U::Item> {\n-        loop {\n-            if let Some(ref mut inner) = self.backiter {\n-                if let elt@Some(_) = inner.next_back() { return elt }\n-            }\n-            match self.iter.next_back() {\n-                None => return self.frontiter.as_mut().and_then(|it| it.next_back()),\n-                next => self.backiter = next.map(IntoIterator::into_iter),\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R where\n-        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-    {\n-        if let Some(ref mut back) = self.backiter {\n-            init = back.try_rfold(init, &mut fold)?;\n-        }\n-        self.backiter = None;\n-\n-        {\n-            let backiter = &mut self.backiter;\n-            init = self.iter.try_rfold(init, |acc, x| {\n-                let mut mid = x.into_iter();\n-                let r = mid.try_rfold(acc, &mut fold);\n-                *backiter = Some(mid);\n-                r\n-            })?;\n-        }\n-        self.backiter = None;\n-\n-        if let Some(ref mut front) = self.frontiter {\n-            init = front.try_rfold(init, &mut fold)?;\n-        }\n-        self.frontiter = None;\n-\n-        Try::from_ok(init)\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-        where Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.frontiter.into_iter()\n-            .chain(self.iter.map(IntoIterator::into_iter))\n-            .chain(self.backiter)\n-            .rfold(init, |acc, iter| iter.rfold(acc, &mut fold))\n-    }\n-}\n-\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n ///"}]}