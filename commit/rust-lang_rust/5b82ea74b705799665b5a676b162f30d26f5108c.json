{"sha": "5b82ea74b705799665b5a676b162f30d26f5108c", "node_id": "C_kwDOAAsO6NoAKDViODJlYTc0YjcwNTc5OTY2NWI1YTY3NmIxNjJmMzBkMjZmNTEwOGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-11T02:07:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-11T02:07:52Z"}, "message": "Auto merge of #99918 - WaffleLapkin:fnFnfun, r=estebank\n\nRecover wrong-cased keywords that start items\n\n(_this pr was inspired by [this tweet](https://twitter.com/Azumanga/status/1552982326409367561)_)\n\nr? `@estebank`\n\nWe've talked a bit about this recovery, but I just wanted to make sure that this is the right approach :)\n\nFor now I've only added the case insensitive recovery to `use`s, since most other items like `impl` blocks, modules, functions can start with multiple keywords which complicates the matter.", "tree": {"sha": "cc33383afaa05322b5afac097aa27d0ad0236001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc33383afaa05322b5afac097aa27d0ad0236001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b82ea74b705799665b5a676b162f30d26f5108c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b82ea74b705799665b5a676b162f30d26f5108c", "html_url": "https://github.com/rust-lang/rust/commit/5b82ea74b705799665b5a676b162f30d26f5108c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b82ea74b705799665b5a676b162f30d26f5108c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1a859b25a95999ba276075bbd8e284ea675b41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a859b25a95999ba276075bbd8e284ea675b41a", "html_url": "https://github.com/rust-lang/rust/commit/c1a859b25a95999ba276075bbd8e284ea675b41a"}, {"sha": "d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "url": "https://api.github.com/repos/rust-lang/rust/commits/d86f9cd4640c9ad81ad4aec45c358d1931d40f30", "html_url": "https://github.com/rust-lang/rust/commit/d86f9cd4640c9ad81ad4aec45c358d1931d40f30"}], "stats": {"total": 328, "additions": 286, "deletions": 42}, "files": [{"sha": "9c1dfeb1a61428920e20e4ac69f61e9913701094", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -29,6 +29,7 @@ extern crate rustc_macros;\n extern crate tracing;\n \n pub mod util {\n+    pub mod case;\n     pub mod classify;\n     pub mod comments;\n     pub mod literal;"}, {"sha": "f6aac0b55f1ab56c391159e517f3dc92f6aa45f0", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -5,6 +5,7 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n+use crate::util::case::Case;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -615,6 +616,15 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n+    /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {\n+        self.is_keyword(kw)\n+            || (case == Case::Insensitive\n+                && self.is_non_raw_ident_where(|id| {\n+                    id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n+                }))\n+    }\n+\n     pub fn is_path_segment_keyword(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }"}, {"sha": "1afd7dea7408ecb9c247e101ac7f4f951c636cf3", "filename": "compiler/rustc_ast/src/util/case.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -0,0 +1,6 @@\n+/// Whatever to ignore case (`fn` vs `Fn` vs `FN`) or not. Used for recovering.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Case {\n+    Sensitive,\n+    Insensitive,\n+}"}, {"sha": "7355730c9ebf13dd6c96f6093ca8cf4ab5d7821b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -33,6 +33,7 @@ use core::mem;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::Spacing;\n+use rustc_ast::util::case::Case;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n@@ -2090,7 +2091,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness = if self.token.uninterpolated_span().rust_2018() {\n-            self.parse_asyncness()\n+            self.parse_asyncness(Case::Sensitive)\n         } else {\n             Async::No\n         };"}, {"sha": "494f0cf56a80f6c82f8dc5fe408f5dde81b8c25d", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -8,6 +8,7 @@ use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{self as ast, AttrVec, Attribute, DUMMY_NODE_ID};\n use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n@@ -34,7 +35,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut AttrVec) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let mod_kind = if self.eat(&token::Semi) {\n@@ -143,8 +144,15 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n         let mut def = self.parse_defaultness();\n-        let kind =\n-            self.parse_item_kind(&mut attrs, mac_allowed, lo, &vis, &mut def, fn_parse_mode)?;\n+        let kind = self.parse_item_kind(\n+            &mut attrs,\n+            mac_allowed,\n+            lo,\n+            &vis,\n+            &mut def,\n+            fn_parse_mode,\n+            Case::Sensitive,\n+        )?;\n         if let Some((ident, kind)) = kind {\n             self.error_on_unconsumed_default(def, &kind);\n             let span = lo.to(self.prev_token.span);\n@@ -205,16 +213,17 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         def: &mut Defaultness,\n         fn_parse_mode: FnParseMode,\n+        case: Case,\n     ) -> PResult<'a, Option<ItemInfo>> {\n         let def_final = def == &Defaultness::Final;\n-        let mut def = || mem::replace(def, Defaultness::Final);\n+        let mut def_ = || mem::replace(def, Defaultness::Final);\n \n-        let info = if self.eat_keyword(kw::Use) {\n+        let info = if self.eat_keyword_case(kw::Use, case) {\n             self.parse_use_item()?\n-        } else if self.check_fn_front_matter(def_final) {\n+        } else if self.check_fn_front_matter(def_final, case) {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(attrs, fn_parse_mode, lo, vis)?;\n-            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def(), sig, generics, body })))\n+            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def_(), sig, generics, body })))\n         } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n@@ -225,7 +234,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.is_unsafe_foreign_mod() {\n             // EXTERN BLOCK\n-            let unsafety = self.parse_unsafety();\n+            let unsafety = self.parse_unsafety(Case::Sensitive);\n             self.expect_keyword(kw::Extern)?;\n             self.parse_item_foreign_mod(attrs, unsafety)?\n         } else if self.is_static_global() {\n@@ -234,15 +243,15 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let (ident, ty, expr) = self.parse_item_global(Some(m))?;\n             (ident, ItemKind::Static(ty, m, expr))\n-        } else if let Const::Yes(const_span) = self.parse_constness() {\n+        } else if let Const::Yes(const_span) = self.parse_constness(Case::Sensitive) {\n             // CONST ITEM\n             if self.token.is_keyword(kw::Impl) {\n                 // recover from `const impl`, suggest `impl const`\n-                self.recover_const_impl(const_span, attrs, def())?\n+                self.recover_const_impl(const_span, attrs, def_())?\n             } else {\n                 self.recover_const_mut(const_span);\n                 let (ident, ty, expr) = self.parse_item_global(None)?;\n-                (ident, ItemKind::Const(def(), ty, expr))\n+                (ident, ItemKind::Const(def_(), ty, expr))\n             }\n         } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n             // TRAIT ITEM\n@@ -251,15 +260,15 @@ impl<'a> Parser<'a> {\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n         {\n             // IMPL ITEM\n-            self.parse_item_impl(attrs, def())?\n+            self.parse_item_impl(attrs, def_())?\n         } else if self.check_keyword(kw::Mod)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Mod])\n         {\n             // MODULE ITEM\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n-            self.parse_type_alias(def())?\n+            self.parse_type_alias(def_())?\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n@@ -286,6 +295,19 @@ impl<'a> Parser<'a> {\n         } else if self.isnt_macro_invocation() && vis.kind.is_pub() {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n+        } else if self.isnt_macro_invocation() && case == Case::Sensitive {\n+            _ = def_;\n+\n+            // Recover wrong cased keywords\n+            return self.parse_item_kind(\n+                attrs,\n+                macros_allowed,\n+                lo,\n+                vis,\n+                def,\n+                fn_parse_mode,\n+                Case::Insensitive,\n+            );\n         } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::empty(), ItemKind::MacCall(P(self.parse_item_macro(vis)?)))\n@@ -538,7 +560,7 @@ impl<'a> Parser<'a> {\n         attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         self.expect_keyword(kw::Impl)?;\n \n         // First, parse generic parameters if necessary.\n@@ -552,7 +574,7 @@ impl<'a> Parser<'a> {\n             generics\n         };\n \n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(Case::Sensitive);\n         if let Const::Yes(span) = constness {\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n         }\n@@ -796,7 +818,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, attrs: &mut AttrVec, lo: Span) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Sensitive);\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -1762,7 +1784,7 @@ impl<'a> Parser<'a> {\n         let (ident, is_raw) = self.ident_or_err()?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n-            let err = if self.check_fn_front_matter(false) {\n+            let err = if self.check_fn_front_matter(false, Case::Sensitive) {\n                 let inherited_vis = Visibility {\n                     span: rustc_span::DUMMY_SP,\n                     kind: VisibilityKind::Inherited,\n@@ -2172,7 +2194,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// `check_pub` adds additional `pub` to the checks in case users place it\n     /// wrongly, can be used to ensure `pub` never comes after `default`.\n-    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool) -> bool {\n+    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool, case: Case) -> bool {\n         // We use an over-approximation here.\n         // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n         // `pub` is added in case users got confused with the ordering like `async pub fn`,\n@@ -2182,23 +2204,30 @@ impl<'a> Parser<'a> {\n         } else {\n             &[kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n         };\n-        self.check_keyword(kw::Fn) // Definitely an `fn`.\n+        self.check_keyword_case(kw::Fn, case) // Definitely an `fn`.\n             // `$qual fn` or `$qual $qual`:\n-            || quals.iter().any(|&kw| self.check_keyword(kw))\n+            || quals.iter().any(|&kw| self.check_keyword_case(kw, case))\n                 && self.look_ahead(1, |t| {\n                     // `$qual fn`, e.g. `const fn` or `async fn`.\n-                    t.is_keyword(kw::Fn)\n+                    t.is_keyword_case(kw::Fn, case)\n                     // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n-                    || t.is_non_raw_ident_where(|i| quals.contains(&i.name)\n-                        // Rule out 2015 `const async: T = val`.\n-                        && i.is_reserved()\n+                    || (\n+                        (\n+                            t.is_non_raw_ident_where(|i|\n+                                quals.contains(&i.name)\n+                                    // Rule out 2015 `const async: T = val`.\n+                                    && i.is_reserved()\n+                            )\n+                            || case == Case::Insensitive\n+                                && t.is_non_raw_ident_where(|i| quals.iter().any(|qual| qual.as_str() == i.name.as_str().to_lowercase()))\n+                        )\n                         // Rule out unsafe extern block.\n                         && !self.is_unsafe_foreign_mod())\n                 })\n             // `extern ABI fn`\n-            || self.check_keyword(kw::Extern)\n+            || self.check_keyword_case(kw::Extern, case)\n                 && self.look_ahead(1, |t| t.can_begin_literal_maybe_minus())\n-                && self.look_ahead(2, |t| t.is_keyword(kw::Fn))\n+                && self.look_ahead(2, |t| t.is_keyword_case(kw::Fn, case))\n     }\n \n     /// Parses all the \"front matter\" (or \"qualifiers\") for a `fn` declaration,\n@@ -2214,22 +2243,22 @@ impl<'a> Parser<'a> {\n     /// `Visibility::Inherited` when no visibility is known.\n     pub(super) fn parse_fn_front_matter(&mut self, orig_vis: &Visibility) -> PResult<'a, FnHeader> {\n         let sp_start = self.token.span;\n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(Case::Insensitive);\n \n         let async_start_sp = self.token.span;\n-        let asyncness = self.parse_asyncness();\n+        let asyncness = self.parse_asyncness(Case::Insensitive);\n \n         let unsafe_start_sp = self.token.span;\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(Case::Insensitive);\n \n         let ext_start_sp = self.token.span;\n-        let ext = self.parse_extern();\n+        let ext = self.parse_extern(Case::Insensitive);\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n \n-        if !self.eat_keyword(kw::Fn) {\n+        if !self.eat_keyword_case(kw::Fn, Case::Insensitive) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this."}, {"sha": "14dc490fb0232615d377f4ef975264648a3bca8f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -22,6 +22,7 @@ use rustc_ast::token::{self, Delimiter, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::AttributesData;\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, Extern};\n@@ -636,6 +637,20 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw)\n     }\n \n+    fn check_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n+        if self.check_keyword(kw) {\n+            return true;\n+        }\n+\n+        if case == Case::Insensitive\n+        && let Some((ident, /* is_raw */ false)) = self.token.ident()\n+        && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// If the next token is the given keyword, eats it and returns `true`.\n     /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n     // Public for rustfmt usage.\n@@ -648,6 +663,33 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Eats a keyword, optionally ignoring the case.\n+    /// If the case differs (and is ignored) an error is issued.\n+    /// This is useful for recovery.\n+    fn eat_keyword_case(&mut self, kw: Symbol, case: Case) -> bool {\n+        if self.eat_keyword(kw) {\n+            return true;\n+        }\n+\n+        if case == Case::Insensitive\n+        && let Some((ident, /* is_raw */ false)) = self.token.ident()\n+        && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n+            self\n+                .struct_span_err(ident.span, format!(\"keyword `{kw}` is written in a wrong case\"))\n+                .span_suggestion(\n+                    ident.span,\n+                    \"write it in the correct case\",\n+                    kw,\n+                    Applicability::MachineApplicable\n+                ).emit();\n+\n+            self.bump();\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n     fn eat_keyword_noexpect(&mut self, kw: Symbol) -> bool {\n         if self.token.is_keyword(kw) {\n             self.bump();\n@@ -1127,8 +1169,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses asyncness: `async` or nothing.\n-    fn parse_asyncness(&mut self) -> Async {\n-        if self.eat_keyword(kw::Async) {\n+    fn parse_asyncness(&mut self, case: Case) -> Async {\n+        if self.eat_keyword_case(kw::Async, case) {\n             let span = self.prev_token.uninterpolated_span();\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n@@ -1137,19 +1179,19 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses unsafety: `unsafe` or nothing.\n-    fn parse_unsafety(&mut self) -> Unsafe {\n-        if self.eat_keyword(kw::Unsafe) {\n+    fn parse_unsafety(&mut self, case: Case) -> Unsafe {\n+        if self.eat_keyword_case(kw::Unsafe, case) {\n             Unsafe::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Unsafe::No\n         }\n     }\n \n     /// Parses constness: `const` or nothing.\n-    fn parse_constness(&mut self) -> Const {\n+    fn parse_constness(&mut self, case: Case) -> Const {\n         // Avoid const blocks to be parsed as const items\n         if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n-            && self.eat_keyword(kw::Const)\n+            && self.eat_keyword_case(kw::Const, case)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n@@ -1404,8 +1446,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    fn parse_extern(&mut self) -> Extern {\n-        if self.eat_keyword(kw::Extern) {\n+    fn parse_extern(&mut self, case: Case) -> Extern {\n+        if self.eat_keyword_case(kw::Extern, case) {\n             let mut extern_span = self.prev_token.span;\n             let abi = self.parse_abi();\n             if let Some(abi) = abi {"}, {"sha": "4d78c5bd0e2734916f614aabb3527197e478c338", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -4,6 +4,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n+use rustc_ast::util::case::Case;\n use rustc_ast::{\n     self as ast, BareFnTy, FnRetTy, GenericBound, GenericBounds, GenericParam, Generics, Lifetime,\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n@@ -267,15 +268,15 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.check_fn_front_matter(false) {\n+        } else if self.check_fn_front_matter(false, Case::Sensitive) {\n             // Function pointer type\n             self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.check_fn_front_matter(false) {\n+            if self.check_fn_front_matter(false, Case::Sensitive) {\n                 self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;"}, {"sha": "1794268f260e12969d9eb3f7cf937b1d31529c68", "filename": "src/test/ui/parser/item-kw-case-mismatch.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+// edition:2018\n+#![allow(unused_imports)]\n+\n+fn main() {}\n+\n+use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n+use std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+\n+async fn _a() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+fn _b() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+async fn _c() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+async fn _d() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+\n+const unsafe fn _e() {}\n+//~^ ERROR keyword `const` is written in a wrong case\n+//~| ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+unsafe extern fn _f() {}\n+//~^ ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `extern` is written in a wrong case\n+\n+extern \"C\" fn _g() {}\n+//~^ ERROR keyword `extern` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case"}, {"sha": "ac8390efdb9a3f7f47ca25c855adc7d9e601c7f8", "filename": "src/test/ui/parser/item-kw-case-mismatch.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+// edition:2018\n+#![allow(unused_imports)]\n+\n+fn main() {}\n+\n+Use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n+USE std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+\n+async Fn _a() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+Fn _b() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+aSYNC fN _c() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+Async fn _d() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+\n+CONST UNSAFE FN _e() {}\n+//~^ ERROR keyword `const` is written in a wrong case\n+//~| ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+unSAFE EXTern fn _f() {}\n+//~^ ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `extern` is written in a wrong case\n+\n+EXTERN \"C\" FN _g() {}\n+//~^ ERROR keyword `extern` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case"}, {"sha": "e66dae825f9c43696e7d15a3761a4441f160e58f", "filename": "src/test/ui/parser/item-kw-case-mismatch.stderr", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5b82ea74b705799665b5a676b162f30d26f5108c/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr?ref=5b82ea74b705799665b5a676b162f30d26f5108c", "patch": "@@ -0,0 +1,86 @@\n+error: keyword `use` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:7:1\n+   |\n+LL | Use std::ptr::read;\n+   | ^^^ help: write it in the correct case (notice the capitalization): `use`\n+\n+error: keyword `use` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:8:1\n+   |\n+LL | USE std::ptr::write;\n+   | ^^^ help: write it in the correct case: `use`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:10:7\n+   |\n+LL | async Fn _a() {}\n+   |       ^^ help: write it in the correct case (notice the capitalization): `fn`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:13:1\n+   |\n+LL | Fn _b() {}\n+   | ^^ help: write it in the correct case (notice the capitalization): `fn`\n+\n+error: keyword `async` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:16:1\n+   |\n+LL | aSYNC fN _c() {}\n+   | ^^^^^ help: write it in the correct case: `async`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:16:7\n+   |\n+LL | aSYNC fN _c() {}\n+   |       ^^ help: write it in the correct case: `fn`\n+\n+error: keyword `async` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:20:1\n+   |\n+LL | Async fn _d() {}\n+   | ^^^^^ help: write it in the correct case: `async`\n+\n+error: keyword `const` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:1\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   | ^^^^^ help: write it in the correct case: `const`\n+\n+error: keyword `unsafe` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:7\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   |       ^^^^^^ help: write it in the correct case: `unsafe`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:14\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   |              ^^ help: write it in the correct case: `fn`\n+\n+error: keyword `unsafe` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:28:1\n+   |\n+LL | unSAFE EXTern fn _f() {}\n+   | ^^^^^^ help: write it in the correct case: `unsafe`\n+\n+error: keyword `extern` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:28:8\n+   |\n+LL | unSAFE EXTern fn _f() {}\n+   |        ^^^^^^ help: write it in the correct case: `extern`\n+\n+error: keyword `extern` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:32:1\n+   |\n+LL | EXTERN \"C\" FN _g() {}\n+   | ^^^^^^ help: write it in the correct case: `extern`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:32:12\n+   |\n+LL | EXTERN \"C\" FN _g() {}\n+   |            ^^ help: write it in the correct case: `fn`\n+\n+error: aborting due to 14 previous errors\n+"}]}