{"sha": "aba0251c78f88b12c499ba956beb8a9734ffdc1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYTAyNTFjNzhmODhiMTJjNDk5YmE5NTZiZWI4YTk3MzRmZmRjMWE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-31T16:40:25Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-08-01T05:20:43Z"}, "message": "Replace a recursive algorithm with an iterative one and a stack.", "tree": {"sha": "7ab2aee1581635c9ea33bb9c5a6f382879101ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ab2aee1581635c9ea33bb9c5a6f382879101ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aba0251c78f88b12c499ba956beb8a9734ffdc1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aba0251c78f88b12c499ba956beb8a9734ffdc1a", "html_url": "https://github.com/rust-lang/rust/commit/aba0251c78f88b12c499ba956beb8a9734ffdc1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aba0251c78f88b12c499ba956beb8a9734ffdc1a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b", "html_url": "https://github.com/rust-lang/rust/commit/66b97dca3c8ab51f8af7b2db7ae4c8061fbf5e9b"}], "stats": {"total": 69, "additions": 43, "deletions": 26}, "files": [{"sha": "9288d6e16f5e079e8937a78c521102d1944bb91e", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aba0251c78f88b12c499ba956beb8a9734ffdc1a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba0251c78f88b12c499ba956beb8a9734ffdc1a/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=aba0251c78f88b12c499ba956beb8a9734ffdc1a", "patch": "@@ -33,6 +33,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n \n pub struct SimplifyCfg {\n@@ -172,9 +173,12 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n         }\n     }\n \n-    // Collapse a goto chain starting from `start`\n-    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n-        let mut terminator = match self.basic_blocks[*start] {\n+    /// This function will return `None` if\n+    /// * the block has statements\n+    /// * the block has a terminator other than `goto`\n+    /// * the block has no terminator (meaning some other part of the current optimization stole it)\n+    fn take_terminator_if_simple_goto(&mut self, bb: BasicBlock) -> Option<Terminator<'tcx>> {\n+        match self.basic_blocks[bb] {\n             BasicBlockData {\n                 ref statements,\n                 terminator:\n@@ -183,32 +187,45 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n             } if statements.is_empty() => terminator.take(),\n             // if `terminator` is None, this means we are in a loop. In that\n             // case, let all the loop collapse to its entry.\n-            _ => return,\n-        };\n-\n-        let target = match terminator {\n-            Some(Terminator { kind: TerminatorKind::Goto { ref mut target }, .. }) => {\n-                self.collapse_goto_chain(target, changed);\n-                *target\n-            }\n-            _ => unreachable!(),\n-        };\n-        self.basic_blocks[*start].terminator = terminator;\n-\n-        debug!(\"collapsing goto chain from {:?} to {:?}\", *start, target);\n-\n-        *changed |= *start != target;\n+            _ => None,\n+        }\n+    }\n \n-        if self.pred_count[*start] == 1 {\n-            // This is the last reference to *start, so the pred-count to\n-            // to target is moved into the current block.\n-            self.pred_count[*start] = 0;\n-        } else {\n-            self.pred_count[target] += 1;\n-            self.pred_count[*start] -= 1;\n+    /// Collapse a goto chain starting from `start`\n+    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n+        // Using `SmallVec` here, because in some logs on libcore oli-obk saw many single-element\n+        // goto chains. We should probably benchmark different sizes.\n+        let mut terminators: SmallVec<[_; 1]> = Default::default();\n+        let mut current = *start;\n+        while let Some(terminator) = self.take_terminator_if_simple_goto(current) {\n+            let target = match terminator {\n+                Terminator { kind: TerminatorKind::Goto { target }, .. } => target,\n+                _ => unreachable!(),\n+            };\n+            terminators.push((current, terminator));\n+            current = target;\n         }\n+        let last = current;\n+        *start = last;\n+        while let Some((current, mut terminator)) = terminators.pop() {\n+            let target = match terminator {\n+                Terminator { kind: TerminatorKind::Goto { ref mut target }, .. } => target,\n+                _ => unreachable!(),\n+            };\n+            *target = last;\n+            debug!(\"collapsing goto chain from {:?} to {:?}\", current, target);\n \n-        *start = target;\n+            if self.pred_count[current] == 1 {\n+                // This is the last reference to current, so the pred-count to\n+                // to target is moved into the current block.\n+                self.pred_count[current] = 0;\n+            } else {\n+                self.pred_count[*target] += 1;\n+                self.pred_count[current] -= 1;\n+            }\n+            *changed = true;\n+            self.basic_blocks[current].terminator = Some(terminator);\n+        }\n     }\n \n     // merge a block with 1 `goto` predecessor to its parent"}]}