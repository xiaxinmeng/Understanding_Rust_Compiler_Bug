{"sha": "c26afb765cb3047f2fa83b21739d9211af39f7ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNmFmYjc2NWNiMzA0N2YyZmE4M2IyMTczOWQ5MjExYWYzOWY3Y2U=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-26T09:45:46Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-29T03:27:27Z"}, "message": "Drop branching blocks with same span as expanded macro\n\nFixes: #84561", "tree": {"sha": "e43e168dada70c9a23ce63183c6f379d307ac2cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e43e168dada70c9a23ce63183c6f379d307ac2cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c26afb765cb3047f2fa83b21739d9211af39f7ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c26afb765cb3047f2fa83b21739d9211af39f7ce", "html_url": "https://github.com/rust-lang/rust/commit/c26afb765cb3047f2fa83b21739d9211af39f7ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c26afb765cb3047f2fa83b21739d9211af39f7ce/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50ca3ac24f08cc6c8bbef9ac27245f83f30bc749", "url": "https://api.github.com/repos/rust-lang/rust/commits/50ca3ac24f08cc6c8bbef9ac27245f83f30bc749", "html_url": "https://github.com/rust-lang/rust/commit/50ca3ac24f08cc6c8bbef9ac27245f83f30bc749"}], "stats": {"total": 293, "additions": 276, "deletions": 17}, "files": [{"sha": "ddbd1680430d29f40b4e44c05cc9bf3409a3d6b7", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c26afb765cb3047f2fa83b21739d9211af39f7ce/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c26afb765cb3047f2fa83b21739d9211af39f7ce/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=c26afb765cb3047f2fa83b21739d9211af39f7ce", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::TyCtxt;\n \n use rustc_span::source_map::original_sp;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, ExpnKind, MacroKind, Span};\n \n use std::cmp::Ordering;\n \n@@ -67,19 +67,30 @@ impl CoverageStatement {\n #[derive(Debug, Clone)]\n pub(super) struct CoverageSpan {\n     pub span: Span,\n+    pub is_macro_expansion: bool,\n     pub bcb: BasicCoverageBlock,\n     pub coverage_statements: Vec<CoverageStatement>,\n     pub is_closure: bool,\n }\n \n impl CoverageSpan {\n     pub fn for_fn_sig(fn_sig_span: Span) -> Self {\n-        Self { span: fn_sig_span, bcb: START_BCB, coverage_statements: vec![], is_closure: false }\n+        // Whether the function signature is from a macro or not, it should not be treated like\n+        // macro-expanded statements and terminators.\n+        let is_macro_expansion = false;\n+        Self {\n+            span: fn_sig_span,\n+            is_macro_expansion,\n+            bcb: START_BCB,\n+            coverage_statements: vec![],\n+            is_closure: false,\n+        }\n     }\n \n     pub fn for_statement(\n         statement: &Statement<'tcx>,\n         span: Span,\n+        is_macro_expansion: bool,\n         bcb: BasicCoverageBlock,\n         bb: BasicBlock,\n         stmt_index: usize,\n@@ -94,15 +105,22 @@ impl CoverageSpan {\n \n         Self {\n             span,\n+            is_macro_expansion,\n             bcb,\n             coverage_statements: vec![CoverageStatement::Statement(bb, span, stmt_index)],\n             is_closure,\n         }\n     }\n \n-    pub fn for_terminator(span: Span, bcb: BasicCoverageBlock, bb: BasicBlock) -> Self {\n+    pub fn for_terminator(\n+        span: Span,\n+        is_macro_expansion: bool,\n+        bcb: BasicCoverageBlock,\n+        bb: BasicBlock,\n+    ) -> Self {\n         Self {\n             span,\n+            is_macro_expansion,\n             bcb,\n             coverage_statements: vec![CoverageStatement::Terminator(bb, span)],\n             is_closure: false,\n@@ -344,7 +362,27 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else if self.prev_original_span == self.curr().span {\n                 // Note that this compares the new span to `prev_original_span`, which may not\n                 // be the full `prev.span` (if merged during the previous iteration).\n-                self.hold_pending_dups_unless_dominated();\n+                if self.prev().is_macro_expansion && self.curr().is_macro_expansion {\n+                    // Macros that expand to include branching (such as\n+                    // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n+                    // `trace!()) typically generate callee spans with identical\n+                    // ranges (typically the full span of the macro) for all\n+                    // `BasicBlocks`. This makes it impossible to distinguish\n+                    // the condition (`if val1 != val2`) from the optional\n+                    // branched statements (such as the call to `panic!()` on\n+                    // assert failure). In this case it is better (or less\n+                    // worse) to drop the optional branch bcbs and keep the\n+                    // non-conditional statements, to count when reached.\n+                    debug!(\n+                        \"  curr and prev are part of a macro expansion, and curr has the same span \\\n+                        as prev, but is in a different bcb. Drop curr and keep prev for next iter. \\\n+                        prev={:?}\",\n+                        self.prev()\n+                    );\n+                    self.take_curr();\n+                } else {\n+                    self.hold_pending_dups_unless_dominated();\n+                }\n             } else {\n                 self.cutoff_prev_at_overlapping_curr();\n             }\n@@ -401,14 +439,24 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                     .iter()\n                     .enumerate()\n                     .filter_map(move |(index, statement)| {\n-                        filtered_statement_span(statement, self.body_span).map(|span| {\n-                            CoverageSpan::for_statement(statement, span, bcb, bb, index)\n-                        })\n+                        filtered_statement_span(statement, self.body_span).map(\n+                            |(span, is_macro_expansion)| {\n+                                CoverageSpan::for_statement(\n+                                    statement,\n+                                    span,\n+                                    is_macro_expansion,\n+                                    bcb,\n+                                    bb,\n+                                    index,\n+                                )\n+                            },\n+                        )\n                     })\n-                    .chain(\n-                        filtered_terminator_span(data.terminator(), self.body_span)\n-                            .map(|span| CoverageSpan::for_terminator(span, bcb, bb)),\n-                    )\n+                    .chain(filtered_terminator_span(data.terminator(), self.body_span).map(\n+                        |(span, is_macro_expansion)| {\n+                            CoverageSpan::for_terminator(span, is_macro_expansion, bcb, bb)\n+                        },\n+                    ))\n             })\n             .collect()\n     }\n@@ -656,7 +704,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n pub(super) fn filtered_statement_span(\n     statement: &'a Statement<'tcx>,\n     body_span: Span,\n-) -> Option<Span> {\n+) -> Option<(Span, bool)> {\n     match statement.kind {\n         // These statements have spans that are often outside the scope of the executed source code\n         // for their parent `BasicBlock`.\n@@ -701,7 +749,7 @@ pub(super) fn filtered_statement_span(\n pub(super) fn filtered_terminator_span(\n     terminator: &'a Terminator<'tcx>,\n     body_span: Span,\n-) -> Option<Span> {\n+) -> Option<(Span, bool)> {\n     match terminator.kind {\n         // These terminators have spans that don't positively contribute to computing a reasonable\n         // span of actually executed source code. (For example, SwitchInt terminators extracted from\n@@ -742,7 +790,13 @@ pub(super) fn filtered_terminator_span(\n }\n \n #[inline]\n-fn function_source_span(span: Span, body_span: Span) -> Span {\n+fn function_source_span(span: Span, body_span: Span) -> (Span, bool) {\n+    let is_macro_expansion = span.ctxt() != body_span.ctxt()\n+        && if let ExpnKind::Macro(MacroKind::Bang, _) = span.ctxt().outer_expn_data().kind {\n+            true\n+        } else {\n+            false\n+        };\n     let span = original_sp(span, body_span).with_ctxt(body_span.ctxt());\n-    if body_span.contains(span) { span } else { body_span }\n+    (if body_span.contains(span) { span } else { body_span }, is_macro_expansion)\n }"}, {"sha": "dbbd677fd638de39809947e3707350a6882e775a", "filename": "compiler/rustc_mir/src/transform/coverage/tests.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c26afb765cb3047f2fa83b21739d9211af39f7ce/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c26afb765cb3047f2fa83b21739d9211af39f7ce/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Ftests.rs?ref=c26afb765cb3047f2fa83b21739d9211af39f7ce", "patch": "@@ -1,6 +1,10 @@\n //! This crate hosts a selection of \"unit tests\" for components of the `InstrumentCoverage` MIR\n //! pass.\n //!\n+//! ```shell\n+//! ./x.py test --keep-stage 1 compiler/rustc_mir --test-args '--show-output coverage'\n+//! ```\n+//!\n //! The tests construct a few \"mock\" objects, as needed, to support the `InstrumentCoverage`\n //! functions and algorithms. Mocked objects include instances of `mir::Body`; including\n //! `Terminator`s of various `kind`s, and `Span` objects. Some functions used by or used on\n@@ -679,10 +683,15 @@ fn test_make_bcb_counters() {\n         let mut basic_coverage_blocks = graph::CoverageGraph::from_mir(&mir_body);\n         let mut coverage_spans = Vec::new();\n         for (bcb, data) in basic_coverage_blocks.iter_enumerated() {\n-            if let Some(span) =\n+            if let Some((span, is_macro_expansion)) =\n                 spans::filtered_terminator_span(data.terminator(&mir_body), body_span)\n             {\n-                coverage_spans.push(spans::CoverageSpan::for_terminator(span, bcb, data.last_bb()));\n+                coverage_spans.push(spans::CoverageSpan::for_terminator(\n+                    span,\n+                    is_macro_expansion,\n+                    bcb,\n+                    data.last_bb(),\n+                ));\n             }\n         }\n         let mut coverage_counters = counters::CoverageCounters::new(0);"}, {"sha": "34d584f9eae669519d125b2ecff6b52f2aa42cd3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c26afb765cb3047f2fa83b21739d9211af39f7ce/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c26afb765cb3047f2fa83b21739d9211af39f7ce/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=c26afb765cb3047f2fa83b21739d9211af39f7ce", "patch": "@@ -0,0 +1,102 @@\n+    1|       |// FIXME(#84561): function-like macros produce unintuitive coverage results.\n+    2|       |// This test demonstrates some of the problems.\n+    3|       |\n+    4|     18|#[derive(Debug, PartialEq, Eq)]\n+                       ^5                ^0\n+  ------------------\n+  | <issue_84561::Foo as core::cmp::PartialEq>::eq:\n+  |    4|     18|#[derive(Debug, PartialEq, Eq)]\n+  ------------------\n+  | Unexecuted instantiation: <issue_84561::Foo as core::cmp::PartialEq>::ne\n+  ------------------\n+    5|       |struct Foo(u32);\n+    6|       |\n+    7|      1|fn main() {\n+    8|      1|    let bar = Foo(1);\n+    9|      1|    assert_eq!(bar, Foo(1));\n+   10|      1|    let baz = Foo(0);\n+   11|      1|    assert_ne!(baz, Foo(1));\n+   12|      1|    println!(\"{:?}\", Foo(1));\n+   13|      1|    println!(\"{:?}\", bar);\n+   14|      1|    println!(\"{:?}\", baz);\n+   15|      1|\n+   16|      1|    assert_eq!(Foo(1), Foo(1));\n+   17|      1|    assert_ne!(Foo(0), Foo(1));\n+   18|      1|    assert_eq!(Foo(2), Foo(2));\n+   19|      1|    let bar = Foo(1);\n+   20|      1|    assert_ne!(Foo(0), Foo(3));\n+   21|      1|    assert_ne!(Foo(0), Foo(4));\n+   22|      1|    assert_eq!(Foo(3), Foo(3));\n+   23|      1|    assert_ne!(Foo(0), Foo(5));\n+   24|      1|    println!(\"{:?}\", bar);\n+   25|      1|    println!(\"{:?}\", Foo(1));\n+   26|      1|\n+   27|      1|    let is_true = std::env::args().len() == 1;\n+   28|      1|\n+   29|      1|    assert_eq!(\n+   30|      1|        Foo(1),\n+   31|      1|        Foo(1)\n+   32|      1|    );\n+   33|      1|    assert_ne!(\n+   34|      1|        Foo(0),\n+   35|      1|        Foo(1)\n+   36|      1|    );\n+   37|      1|    assert_eq!(\n+   38|      1|        Foo(2),\n+   39|      1|        Foo(2)\n+   40|      1|    );\n+   41|      1|    let bar = Foo(1\n+   42|      1|    );\n+   43|      1|    assert_ne!(\n+   44|      1|        Foo(0),\n+   45|      1|        Foo(3)\n+   46|      1|    );\n+   47|      1|    if is_true {\n+   48|      1|        assert_ne!(\n+   49|      1|            Foo(0),\n+   50|      1|            Foo(4)\n+   51|      1|        );\n+   52|       |    } else {\n+   53|      0|        assert_eq!(\n+   54|      0|            Foo(3),\n+   55|      0|            Foo(3)\n+   56|      0|        );\n+   57|       |    }\n+   58|       |    assert_ne!(\n+   59|      1|        if is_true {\n+   60|      1|            Foo(0)\n+   61|       |        } else {\n+   62|      0|            Foo(1)\n+   63|       |        },\n+   64|       |        Foo(5)\n+   65|       |    );\n+   66|      1|    assert_ne!(\n+   67|      1|        Foo(5),\n+   68|      1|        if is_true {\n+   69|      1|            Foo(0)\n+   70|       |        } else {\n+   71|      0|            Foo(1)\n+   72|       |        }\n+   73|       |    );\n+   74|       |    assert_ne!(\n+   75|      1|        if is_true {\n+   76|      1|            assert_eq!(\n+   77|      1|                Foo(3),\n+   78|      1|                Foo(3)\n+   79|      1|            );\n+   80|      1|            Foo(0)\n+   81|       |        } else {\n+   82|       |            assert_ne!(\n+   83|      0|                if is_true {\n+   84|      0|                    Foo(0)\n+   85|       |                } else {\n+   86|      0|                    Foo(1)\n+   87|       |                },\n+   88|       |                Foo(5)\n+   89|       |            );\n+   90|      0|            Foo(1)\n+   91|       |        },\n+   92|       |        Foo(5)\n+   93|       |    );\n+   94|      1|}\n+"}, {"sha": "a5a0e1dc7581ddd449bcdf8c818c6a41b97923ac", "filename": "src/test/run-make-fulldeps/coverage/issue-84561.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c26afb765cb3047f2fa83b21739d9211af39f7ce/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c26afb765cb3047f2fa83b21739d9211af39f7ce/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-84561.rs?ref=c26afb765cb3047f2fa83b21739d9211af39f7ce", "patch": "@@ -0,0 +1,94 @@\n+// FIXME(#84561): function-like macros produce unintuitive coverage results.\n+// This test demonstrates some of the problems.\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct Foo(u32);\n+\n+fn main() {\n+    let bar = Foo(1);\n+    assert_eq!(bar, Foo(1));\n+    let baz = Foo(0);\n+    assert_ne!(baz, Foo(1));\n+    println!(\"{:?}\", Foo(1));\n+    println!(\"{:?}\", bar);\n+    println!(\"{:?}\", baz);\n+\n+    assert_eq!(Foo(1), Foo(1));\n+    assert_ne!(Foo(0), Foo(1));\n+    assert_eq!(Foo(2), Foo(2));\n+    let bar = Foo(1);\n+    assert_ne!(Foo(0), Foo(3));\n+    assert_ne!(Foo(0), Foo(4));\n+    assert_eq!(Foo(3), Foo(3));\n+    assert_ne!(Foo(0), Foo(5));\n+    println!(\"{:?}\", bar);\n+    println!(\"{:?}\", Foo(1));\n+\n+    let is_true = std::env::args().len() == 1;\n+\n+    assert_eq!(\n+        Foo(1),\n+        Foo(1)\n+    );\n+    assert_ne!(\n+        Foo(0),\n+        Foo(1)\n+    );\n+    assert_eq!(\n+        Foo(2),\n+        Foo(2)\n+    );\n+    let bar = Foo(1\n+    );\n+    assert_ne!(\n+        Foo(0),\n+        Foo(3)\n+    );\n+    if is_true {\n+        assert_ne!(\n+            Foo(0),\n+            Foo(4)\n+        );\n+    } else {\n+        assert_eq!(\n+            Foo(3),\n+            Foo(3)\n+        );\n+    }\n+    assert_ne!(\n+        if is_true {\n+            Foo(0)\n+        } else {\n+            Foo(1)\n+        },\n+        Foo(5)\n+    );\n+    assert_ne!(\n+        Foo(5),\n+        if is_true {\n+            Foo(0)\n+        } else {\n+            Foo(1)\n+        }\n+    );\n+    assert_ne!(\n+        if is_true {\n+            assert_eq!(\n+                Foo(3),\n+                Foo(3)\n+            );\n+            Foo(0)\n+        } else {\n+            assert_ne!(\n+                if is_true {\n+                    Foo(0)\n+                } else {\n+                    Foo(1)\n+                },\n+                Foo(5)\n+            );\n+            Foo(1)\n+        },\n+        Foo(5)\n+    );\n+}"}]}