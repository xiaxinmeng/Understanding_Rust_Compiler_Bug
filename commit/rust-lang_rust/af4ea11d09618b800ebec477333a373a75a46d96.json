{"sha": "af4ea11d09618b800ebec477333a373a75a46d96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNGVhMTFkMDk2MThiODAwZWJlYzQ3NzMzM2EzNzNhNzVhNDZkOTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T04:44:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T19:00:48Z"}, "message": "test: Rewrite mandelbrot benchmark.", "tree": {"sha": "5a9064f9fed2aed12abaab61e31b1c3ec3ea65db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a9064f9fed2aed12abaab61e31b1c3ec3ea65db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af4ea11d09618b800ebec477333a373a75a46d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af4ea11d09618b800ebec477333a373a75a46d96", "html_url": "https://github.com/rust-lang/rust/commit/af4ea11d09618b800ebec477333a373a75a46d96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af4ea11d09618b800ebec477333a373a75a46d96/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9902e798d5bdc983228cdf82242ff52409dd76e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9902e798d5bdc983228cdf82242ff52409dd76e6", "html_url": "https://github.com/rust-lang/rust/commit/9902e798d5bdc983228cdf82242ff52409dd76e6"}], "stats": {"total": 228, "additions": 53, "deletions": 175}, "files": [{"sha": "e62cb8ea849d1dbbbb59dde4f9f8798c618e6132", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 53, "deletions": 175, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/af4ea11d09618b800ebec477333a373a75a46d96/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af4ea11d09618b800ebec477333a373a75a46d96/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=af4ea11d09618b800ebec477333a373a75a46d96", "patch": "@@ -1,182 +1,60 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+use core::cast::transmute;\n+use core::from_str::FromStr;\n+use core::i32::range;\n+use core::libc::{STDOUT_FILENO, c_int, fdopen, fputc};\n \n-//  based on:\n-//  http://shootout.alioth.debian.org/\n-//   u64q/program.php?test=mandelbrot&lang=python3&id=2\n-//\n-//  takes 3 optional args:\n-//   square image size, defaults to 80_u\n-//   output path, default is \"\" (no output), \"-\" means stdout\n-//   depth (max iterations per pixel), defaults to 50_u\n-//\n-//  in the shootout, they use 16000 as image size, 50 as depth,\n-//   and write to stdout:\n-//\n-//  ./shootout_mandelbrot 16000 \"-\" 50 > /tmp/mandel.pbm\n-//\n-//  writes pbm image to output path\n+static ITER: uint = 50;\n+static LIMIT: f64 = 2.0;\n \n-use core::io::WriterUtil;\n-use core::hashmap::HashMap;\n-\n-struct cmplx {\n-    re: f64,\n-    im: f64\n-}\n-\n-impl ops::Mul<cmplx,cmplx> for cmplx {\n-    fn mul(&self, x: &cmplx) -> cmplx {\n-        cmplx {\n-            re: self.re*(*x).re - self.im*(*x).im,\n-            im: self.re*(*x).im + self.im*(*x).re\n-        }\n-    }\n-}\n-\n-impl ops::Add<cmplx,cmplx> for cmplx {\n-    fn add(&self, x: &cmplx) -> cmplx {\n-        cmplx {\n-            re: self.re + (*x).re,\n-            im: self.im + (*x).im\n-        }\n-    }\n-}\n-\n-struct Line {i: uint, b: ~[u8]}\n-\n-fn cabs(x: cmplx) -> f64\n-{\n-    x.re*x.re + x.im*x.im\n-}\n-\n-fn mb(x: cmplx, depth: uint) -> bool\n-{\n-    let mut z = x;\n-    let mut i = 0;\n-    while i < depth {\n-        if cabs(z) >= 4_f64 {\n-            return false;\n-        }\n-        z = z*z + x;\n-        i += 1;\n-    }\n-    true\n-}\n-\n-fn fillbyte(x: cmplx, incr: f64, depth: uint) -> u8 {\n-    let mut rv = 0_u8;\n-    let mut i = 0_u8;\n-    while i < 8_u8 {\n-        let z = cmplx {re: x.re + (i as f64)*incr, im: x.im};\n-        if mb(z, depth) {\n-            rv += 1_u8 << (7_u8 - i);\n-        }\n-        i += 1_u8;\n-    }\n-    rv\n-}\n-\n-fn chanmb(i: uint, size: uint, depth: uint) -> Line\n-{\n-    let bsize = size/8_u;\n-    let mut crv = vec::with_capacity(bsize);\n-    let incr = 2_f64/(size as f64);\n-    let y = incr*(i as f64) - 1_f64;\n-    let xincr = 8_f64*incr;\n-    for uint::range(0_u, bsize) |j| {\n-        let x = cmplx {re: xincr*(j as f64) - 1.5_f64, im: y};\n-        crv.push(fillbyte(x, incr, depth));\n-    };\n-    Line {i:i, b:crv}\n-}\n-\n-struct Devnull();\n-\n-impl io::Writer for Devnull {\n-    fn write(&self, _b: &const [u8]) {}\n-    fn seek(&self, _i: int, _s: io::SeekStyle) {}\n-    fn tell(&self) -> uint {0_u}\n-    fn flush(&self) -> int {0}\n-    fn get_type(&self) -> io::WriterType { io::File }\n-}\n-\n-fn writer(path: ~str, pport: comm::Port<Line>, size: uint)\n-{\n-    let cout: @io::Writer = match path {\n-        ~\"\" => {\n-            @Devnull as @io::Writer\n-        }\n-        ~\"-\" => {\n-            io::stdout()\n-        }\n-        _ => {\n-            result::get(\n-                &io::file_writer(&Path(path),\n-                ~[io::Create, io::Truncate]))\n-        }\n-    };\n-    cout.write_line(\"P4\");\n-    cout.write_line(fmt!(\"%u %u\", size, size));\n-    let mut lines: HashMap<uint, Line> = HashMap::new();\n-    let mut done = 0_u;\n-    let mut i = 0_u;\n-    while i < size {\n-        let aline = pport.recv();\n-        if aline.i == done {\n-            debug!(\"W %u\", done);\n-            cout.write(aline.b);\n-            done += 1_u;\n-            let mut prev = done;\n-            while prev <= i {\n-                match lines.pop(&prev) {\n-                    Some(pl) => {\n-                        debug!(\"WS %u\", prev);\n-                        cout.write(pl.b);\n-                        done += 1_u;\n-                        prev += 1_u;\n+#[fixed_stack_segment]\n+fn main() {\n+    unsafe {\n+        let w: i32 = FromStr::from_str(os::args()[1]).get(), h = w;\n+        let mut byte_acc: i8 = 0;\n+        let mut bit_num: i32 = 0;\n+\n+        println(fmt!(\"P4\\n%d %d\", w as int, h as int));\n+\n+        let mode = \"w\";\n+        let stdout = fdopen(STDOUT_FILENO as c_int, transmute(&mode[0]));\n+\n+        for range(0, h) |y| {\n+            let y = y as f64;\n+            for range(0, w) |x| {\n+                let mut (Zr, Zi, Tr, Ti) = (0f64, 0f64, 0f64, 0f64);\n+                let Cr = 2.0 * (x as f64) / (w as f64) - 1.5;\n+                let Ci = 2.0 * (y as f64) / (h as f64) - 1.0;\n+\n+                for ITER.times {\n+                    if Tr + Ti > LIMIT * LIMIT {\n+                        break;\n                     }\n-                    None => break\n-                };\n-            };\n+\n+                    Zi = 2.0*Zr*Zi + Ci;\n+                    Zr = Tr - Ti + Cr;\n+                    Tr = Zr * Zr;\n+                    Ti = Zi * Zi;\n+                }\n+\n+                byte_acc <<= 1;\n+                if Tr + Ti <= LIMIT * LIMIT {\n+                    byte_acc |= 1;\n+                }\n+\n+                bit_num += 1;\n+\n+                if bit_num == 8 {\n+                    fputc(byte_acc as c_int, stdout);\n+                    byte_acc = 0;\n+                    bit_num = 0;\n+                } else if x == w - 1 {\n+                    byte_acc <<= 8 - w%8;\n+                    fputc(byte_acc as c_int, stdout);\n+                    byte_acc = 0;\n+                    bit_num = 0;\n+                }\n+            }\n         }\n-        else {\n-            debug!(\"S %u\", aline.i);\n-            lines.insert(aline.i, aline);\n-        };\n-        i += 1_u;\n     }\n }\n \n-fn main() {\n-    let args = os::args();\n-    let args = if os::getenv(~\"RUST_BENCH\").is_some() {\n-        ~[~\"\", ~\"4000\", ~\"50\"]\n-    } else {\n-        args\n-    };\n-\n-    let depth = if vec::len(args) < 4_u { 50_u }\n-    else { uint::from_str(args[3]).get() };\n-\n-    let path = if vec::len(args) < 3_u { ~\"\" }\n-    else { copy args[2] };  // FIXME: bad for perf\n-\n-    let size = if vec::len(args) < 2_u { 80_u }\n-    else { uint::from_str(args[1]).get() };\n-\n-    let (pport, pchan) = comm::stream();\n-    let pchan = comm::SharedChan::new(pchan);\n-    for uint::range(0_u, size) |j| {\n-        let cchan = pchan.clone();\n-        do task::spawn { cchan.send(chanmb(j, size, depth)) };\n-    };\n-    writer(path, pport, size);\n-}"}]}