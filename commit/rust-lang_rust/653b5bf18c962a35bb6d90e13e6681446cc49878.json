{"sha": "653b5bf18c962a35bb6d90e13e6681446cc49878", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2I1YmYxOGM5NjJhMzViYjZkOTBlMTNlNjY4MTQ0NmNjNDk4Nzg=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T09:37:06Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-26T05:20:53Z"}, "message": "Move functions converting bytes to str to new mod", "tree": {"sha": "b82a5cea85814ab3dd826a5ba80ee1d5d38943ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b82a5cea85814ab3dd826a5ba80ee1d5d38943ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653b5bf18c962a35bb6d90e13e6681446cc49878", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653b5bf18c962a35bb6d90e13e6681446cc49878", "html_url": "https://github.com/rust-lang/rust/commit/653b5bf18c962a35bb6d90e13e6681446cc49878", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653b5bf18c962a35bb6d90e13e6681446cc49878/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "url": "https://api.github.com/repos/rust-lang/rust/commits/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "html_url": "https://github.com/rust-lang/rust/commit/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77"}], "stats": {"total": 396, "additions": 202, "deletions": 194}, "files": [{"sha": "de2a93f735032758a93454ce3ab690aef2dd9f1e", "filename": "library/core/src/str/converts.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=653b5bf18c962a35bb6d90e13e6681446cc49878", "patch": "@@ -0,0 +1,192 @@\n+//! Ways to create a `str` from bytes slice.\n+\n+use crate::mem;\n+\n+use super::validations::run_utf8_validation;\n+use super::Utf8Error;\n+\n+/// Converts a slice of bytes to a string slice.\n+///\n+/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n+/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n+/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n+/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n+/// UTF-8, and then does the conversion.\n+///\n+/// [`&str`]: str\n+/// [byteslice]: ../../std/primitive.slice.html\n+///\n+/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n+/// incur the overhead of the validity check, there is an unsafe version of\n+/// this function, [`from_utf8_unchecked`], which has the same\n+/// behavior but skips the check.\n+///\n+/// If you need a `String` instead of a `&str`, consider\n+/// [`String::from_utf8`][string].\n+///\n+/// [string]: ../../std/string/struct.String.html#method.from_utf8\n+///\n+/// Because you can stack-allocate a `[u8; N]`, and you can take a\n+/// [`&[u8]`][byteslice] of it, this function is one way to have a\n+/// stack-allocated string. There is an example of this in the\n+/// examples section below.\n+///\n+/// [byteslice]: ../../std/primitive.slice.html\n+///\n+/// # Errors\n+///\n+/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+/// provided slice is not UTF-8.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some invalid bytes, in a vector\n+/// let sparkle_heart = vec![0, 159, 146, 150];\n+///\n+/// assert!(str::from_utf8(&sparkle_heart).is_err());\n+/// ```\n+///\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n+/// errors that can be returned.\n+///\n+/// A \"stack allocated string\":\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a stack-allocated array\n+/// let sparkle_heart = [240, 159, 146, 150];\n+///\n+/// // We know these bytes are valid, so just use `unwrap()`.\n+/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n+    run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n+    Ok(unsafe { from_utf8_unchecked(v) })\n+}\n+\n+/// Converts a mutable slice of bytes to a mutable string slice.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // \"Hello, Rust!\" as a mutable vector\n+/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n+///\n+/// // As we know these bytes are valid, we can use `unwrap()`\n+/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n+///\n+/// assert_eq!(\"Hello, Rust!\", outstr);\n+/// ```\n+///\n+/// Incorrect bytes:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // Some invalid bytes in a mutable vector\n+/// let mut invalid = vec![128, 223];\n+///\n+/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n+/// ```\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n+/// errors that can be returned.\n+#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n+    run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n+    Ok(unsafe { from_utf8_unchecked_mut(v) })\n+}\n+\n+/// Converts a slice of bytes to a string slice without checking\n+/// that the string contains valid UTF-8.\n+///\n+/// See the safe version, [`from_utf8`], for more information.\n+///\n+/// # Safety\n+///\n+/// This function is unsafe because it does not check that the bytes passed to\n+/// it are valid UTF-8. If this constraint is violated, undefined behavior\n+/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n+///\n+/// [`&str`]: str\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// // some bytes, in a vector\n+/// let sparkle_heart = vec![240, 159, 146, 150];\n+///\n+/// let sparkle_heart = unsafe {\n+///     str::from_utf8_unchecked(&sparkle_heart)\n+/// };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n+#[allow_internal_unstable(const_fn_transmute)]\n+pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n+    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n+    // Also relies on `&str` and `&[u8]` having the same layout.\n+    unsafe { mem::transmute(v) }\n+}\n+\n+/// Converts a slice of bytes to a string slice without checking\n+/// that the string contains valid UTF-8; mutable version.\n+///\n+/// See the immutable version, [`from_utf8_unchecked()`] for more information.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::str;\n+///\n+/// let mut heart = vec![240, 159, 146, 150];\n+/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n+///\n+/// assert_eq!(\"\ud83d\udc96\", heart);\n+/// ```\n+#[inline]\n+#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n+    // SAFETY: the caller must guarantee that the bytes `v`\n+    // are valid UTF-8, thus the cast to `*mut str` is safe.\n+    // Also, the pointer dereference is safe because that pointer\n+    // comes from a reference which is guaranteed to be valid for writes.\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n+}"}, {"sha": "427f720d68cdb8cc2a79debfdcefc16c2d2c35e0", "filename": "library/core/src/str/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ferror.rs?ref=653b5bf18c962a35bb6d90e13e6681446cc49878", "patch": "@@ -9,7 +9,7 @@ use crate::fmt;\n /// and [`&str`]s make use of this error, for example.\n ///\n /// [`String`]: ../../std/string/struct.String.html#method.from_utf8\n-/// [`&str`]: from_utf8\n+/// [`&str`]: super::from_utf8\n ///\n /// # Examples\n ///\n@@ -114,7 +114,7 @@ impl fmt::Display for Utf8Error {\n \n /// An error returned when parsing a `bool` using [`from_str`] fails\n ///\n-/// [`from_str`]: FromStr::from_str\n+/// [`from_str`]: super::FromStr::from_str\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError {"}, {"sha": "ada5a4fa39fb6451d633450a4c610cf6e59b9b10", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 8, "deletions": 192, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653b5bf18c962a35bb6d90e13e6681446cc49878/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=653b5bf18c962a35bb6d90e13e6681446cc49878", "patch": "@@ -8,6 +8,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod converts;\n mod error;\n mod iter;\n mod traits;\n@@ -26,6 +27,12 @@ pub mod pattern;\n #[allow(missing_docs)]\n pub mod lossy;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use converts::{from_utf8, from_utf8_unchecked};\n+\n+#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n+pub use converts::{from_utf8_mut, from_utf8_unchecked_mut};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use error::{ParseBoolError, Utf8Error};\n \n@@ -70,198 +77,7 @@ use iter::MatchIndicesInternal;\n use iter::SplitInternal;\n use iter::{MatchesInternal, SplitNInternal};\n \n-use validations::{run_utf8_validation, truncate_to_char_boundary};\n-\n-/*\n-Section: Creating a string\n-*/\n-\n-/// Converts a slice of bytes to a string slice.\n-///\n-/// A string slice ([`&str`]) is made of bytes ([`u8`]), and a byte slice\n-/// ([`&[u8]`][byteslice]) is made of bytes, so this function converts between\n-/// the two. Not all byte slices are valid string slices, however: [`&str`] requires\n-/// that it is valid UTF-8. `from_utf8()` checks to ensure that the bytes are valid\n-/// UTF-8, and then does the conversion.\n-///\n-/// [`&str`]: str\n-/// [byteslice]: ../../std/primitive.slice.html\n-///\n-/// If you are sure that the byte slice is valid UTF-8, and you don't want to\n-/// incur the overhead of the validity check, there is an unsafe version of\n-/// this function, [`from_utf8_unchecked`], which has the same\n-/// behavior but skips the check.\n-///\n-/// If you need a `String` instead of a `&str`, consider\n-/// [`String::from_utf8`][string].\n-///\n-/// [string]: ../../std/string/struct.String.html#method.from_utf8\n-///\n-/// Because you can stack-allocate a `[u8; N]`, and you can take a\n-/// [`&[u8]`][byteslice] of it, this function is one way to have a\n-/// stack-allocated string. There is an example of this in the\n-/// examples section below.\n-///\n-/// [byteslice]: ../../std/primitive.slice.html\n-///\n-/// # Errors\n-///\n-/// Returns `Err` if the slice is not UTF-8 with a description as to why the\n-/// provided slice is not UTF-8.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a vector\n-/// let sparkle_heart = vec![240, 159, 146, 150];\n-///\n-/// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-///\n-/// Incorrect bytes:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some invalid bytes, in a vector\n-/// let sparkle_heart = vec![0, 159, 146, 150];\n-///\n-/// assert!(str::from_utf8(&sparkle_heart).is_err());\n-/// ```\n-///\n-/// See the docs for [`Utf8Error`] for more details on the kinds of\n-/// errors that can be returned.\n-///\n-/// A \"stack allocated string\":\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a stack-allocated array\n-/// let sparkle_heart = [240, 159, 146, 150];\n-///\n-/// // We know these bytes are valid, so just use `unwrap()`.\n-/// let sparkle_heart = str::from_utf8(&sparkle_heart).unwrap();\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked(v) })\n-}\n-\n-/// Converts a mutable slice of bytes to a mutable string slice.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // \"Hello, Rust!\" as a mutable vector\n-/// let mut hellorust = vec![72, 101, 108, 108, 111, 44, 32, 82, 117, 115, 116, 33];\n-///\n-/// // As we know these bytes are valid, we can use `unwrap()`\n-/// let outstr = str::from_utf8_mut(&mut hellorust).unwrap();\n-///\n-/// assert_eq!(\"Hello, Rust!\", outstr);\n-/// ```\n-///\n-/// Incorrect bytes:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // Some invalid bytes in a mutable vector\n-/// let mut invalid = vec![128, 223];\n-///\n-/// assert!(str::from_utf8_mut(&mut invalid).is_err());\n-/// ```\n-/// See the docs for [`Utf8Error`] for more details on the kinds of\n-/// errors that can be returned.\n-#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n-    run_utf8_validation(v)?;\n-    // SAFETY: Just ran validation.\n-    Ok(unsafe { from_utf8_unchecked_mut(v) })\n-}\n-\n-/// Converts a slice of bytes to a string slice without checking\n-/// that the string contains valid UTF-8.\n-///\n-/// See the safe version, [`from_utf8`], for more information.\n-///\n-/// # Safety\n-///\n-/// This function is unsafe because it does not check that the bytes passed to\n-/// it are valid UTF-8. If this constraint is violated, undefined behavior\n-/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n-///\n-/// [`&str`]: str\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// // some bytes, in a vector\n-/// let sparkle_heart = vec![240, 159, 146, 150];\n-///\n-/// let sparkle_heart = unsafe {\n-///     str::from_utf8_unchecked(&sparkle_heart)\n-/// };\n-///\n-/// assert_eq!(\"\ud83d\udc96\", sparkle_heart);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n-#[allow(unused_attributes)]\n-#[allow_internal_unstable(const_fn_transmute)]\n-pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n-    // Also relies on `&str` and `&[u8]` having the same layout.\n-    unsafe { mem::transmute(v) }\n-}\n-\n-/// Converts a slice of bytes to a string slice without checking\n-/// that the string contains valid UTF-8; mutable version.\n-///\n-/// See the immutable version, [`from_utf8_unchecked()`] for more information.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::str;\n-///\n-/// let mut heart = vec![240, 159, 146, 150];\n-/// let heart = unsafe { str::from_utf8_unchecked_mut(&mut heart) };\n-///\n-/// assert_eq!(\"\ud83d\udc96\", heart);\n-/// ```\n-#[inline]\n-#[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n-pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    // SAFETY: the caller must guarantee that the bytes `v`\n-    // are valid UTF-8, thus the cast to `*mut str` is safe.\n-    // Also, the pointer dereference is safe because that pointer\n-    // comes from a reference which is guaranteed to be valid for writes.\n-    unsafe { &mut *(v as *mut [u8] as *mut str) }\n-}\n+use validations::truncate_to_char_boundary;\n \n impl_fn_for_zst! {\n     /// A nameable, cloneable fn type"}]}