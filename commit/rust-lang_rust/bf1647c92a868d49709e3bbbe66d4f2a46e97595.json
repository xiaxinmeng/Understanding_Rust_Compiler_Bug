{"sha": "bf1647c92a868d49709e3bbbe66d4f2a46e97595", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMTY0N2M5MmE4NjhkNDk3MDllM2JiYmU2NmQ0ZjJhNDZlOTc1OTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-26T09:48:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-29T00:22:15Z"}, "message": "Reconcile docs and code, adding examples and adding RESTR_CLAIM", "tree": {"sha": "e0e3096890b9159f222235a1f72c2d10530d1b13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0e3096890b9159f222235a1f72c2d10530d1b13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf1647c92a868d49709e3bbbe66d4f2a46e97595", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1647c92a868d49709e3bbbe66d4f2a46e97595", "html_url": "https://github.com/rust-lang/rust/commit/bf1647c92a868d49709e3bbbe66d4f2a46e97595", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf1647c92a868d49709e3bbbe66d4f2a46e97595/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329f7a17e2162807d62b5f1f4c3d97da1317d192", "url": "https://api.github.com/repos/rust-lang/rust/commits/329f7a17e2162807d62b5f1f4c3d97da1317d192", "html_url": "https://github.com/rust-lang/rust/commit/329f7a17e2162807d62b5f1f4c3d97da1317d192"}], "stats": {"total": 198, "additions": 165, "deletions": 33}, "files": [{"sha": "9395c3f2a40d3021d462b701084e8a77935e90f5", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -65,7 +65,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n+    MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n }\n \n pub impl<'self> CheckLoanCtxt<'self> {\n@@ -200,9 +200,9 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n \n-        // Restrictions that would cause the new loan to be immutable:\n+        // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_MUTATE,\n+            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n             m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n             m_const => RESTR_ALIAS,\n         };\n@@ -557,12 +557,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                 let cmt = self.bccx.cat_expr(ex);\n                 match self.analyze_move_out_from_cmt(cmt) {\n                     MoveOk => {}\n-                    MoveWhileBorrowed(loan_path, loan_span) => {\n+                    MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n                         self.bccx.span_err(\n                             cmt.span,\n                             fmt!(\"cannot move out of `%s` \\\n                                   because it is borrowed\",\n-                                 self.bccx.loan_path_to_str(loan_path)));\n+                                 self.bccx.loan_path_to_str(move_path)));\n                         self.bccx.span_note(\n                             loan_span,\n                             fmt!(\"borrow of `%s` occurs here\",\n@@ -582,7 +582,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         for opt_loan_path(cmt).each |&lp| {\n             for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n                 // Any restriction prevents moves.\n-                return MoveWhileBorrowed(loan.loan_path, loan.span);\n+                return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n             }\n         }\n "}, {"sha": "5e96e14dbc2cf98593a53a9c642e75329cef039a", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -580,15 +580,27 @@ borrow, `LV` remains the *sole pointer with mutable access* to `*LV`.\n Restrictions against mutations and claims are necessary because if the\n pointer in `LV` were to be somehow copied or moved to a different\n location, then the restriction issued for `*LV` would not apply to the\n-new location. Consider this example, where `*t0` is frozen, but then\n-`t0` and `t1` are swapped, so by mutating `*t1` the user can mutate\n-the frozen memory that was originally found at `*t0`:\n-\n-    fn foo(t0: &mut T,\n-           t1: &mut T) {\n-        let p: &T = &*t0;     // Freezes `*t0`\n-        t0 <-> t1;\n-        *t1 = ...;            // Invalidates `p`\n+new location. Note that because `&mut` values are non-copyable, a\n+simple attempt to move the base pointer will fail due to the\n+(implicit) restriction against moves:\n+\n+    // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n+    fn foo(t0: &mut int) {\n+        let p: &int = &*t0; // Freezes `*t0`\n+        let t1 = t0;        //~ ERROR cannot move out of `t0`\n+        *t1 = 22;\n+    }\n+\n+However, the additional restrictions against mutation mean that even a\n+clever attempt to use a swap to circumvent the type system will\n+encounter an error:\n+\n+    // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+    fn foo<'a>(mut t0: &'a mut int,\n+               mut t1: &'a mut int) {\n+        let p: &int = &*t0;     // Freezes `*t0`\n+        swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+        *t1 = 22;\n     }\n \n The restriction against *aliasing* (and, in turn, freezing) is\n@@ -598,12 +610,32 @@ pointee. Since we are only issuing restrictions against `*LV`, these\n other aliases would be unrestricted, and the result would be\n unsound. For example:\n \n-    fn foo(t0: &mut T) {\n-        let p: &T = &*t0;     // Freezes *t0\n-        let q: &&mut T = &t0;\n-        **q = ...;            // Invalidates `p`\n+    // src/test/compile-fail/borrowck-alias-mut-base-ptr.rs\n+    fn foo(t0: &mut int) {\n+        let p: &int = &*t0; // Freezes `*t0`\n+        let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n+        **q = 22; // (*)\n     }\n \n+Note that the current rules also report an error at the assignment in\n+`(*)`, because we only permit `&mut` poiners to be assigned if they\n+are located in a non-aliasable location. However, I do not believe\n+this restriction is strictly necessary. It was added, I believe, to\n+discourage `&mut` from being placed in aliasable locations in the\n+first place. One (desirable) side-effect of restricting aliasing on\n+`LV` is that borrowing an `&mut` pointee found inside an aliasable\n+pointee yields an error:\n+\n+    // src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc:\n+    fn foo(t0: & &mut int) {\n+        let t1 = t0;\n+        let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n+        **t1 = 22; // (*)\n+    }\n+\n+Here at the line `(*)` you will also see the error I referred to\n+above, which I do not believe is strictly necessary.\n+\n The second rule for `&mut` handles the case where we are not adding\n any restrictions (beyond the default of \"no move\"):\n \n@@ -622,4 +654,22 @@ that way if we *can* find a simple static error, we will:\n     RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n       TYPE(LV) = @mut Ty\n \n+# Some notes for future work\n+\n+While writing up these docs, I encountered some rules I believe to be\n+stricter than necessary:\n+\n+- I think the restriction against mutating `&mut` pointers found in an\n+  aliasable location is unnecessary. They cannot be reborrowed, to be sure,\n+  so it should be safe to mutate them. Lifting this might cause some common\n+  cases (`&mut int`) to work just fine, but might lead to further confusion\n+  in other cases, so maybe it's best to leave it as is.\n+- I think restricting the `&mut` LV against moves and `ALIAS` is sufficient,\n+  `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n+  a built-in operator, but as it is not, it is implied by `CLAIM`,\n+  and `CLAIM` is implied by `ALIAS`. The only net effect of this is an\n+  extra error message in some cases, though.\n+- I have not described how closures interact. Current code is unsound.\n+  I am working on describing and implementing the fix.\n+\n */"}, {"sha": "c2ae364e54ce89372d0f19e76ac7c223440b1d29", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -517,8 +517,8 @@ pub impl GatherLoanCtxt {\n     fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n         match req_mutbl {\n             m_const => RESTR_EMPTY,\n-            m_imm   => RESTR_EMPTY | RESTR_MUTATE,\n-            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_FREEZE\n+            m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n+            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n         }\n     }\n "}, {"sha": "4527cdec782da5927f92930330978bba4fa46261", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -86,7 +86,7 @@ impl RestrictionsContext {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                self.compute(cmt_base, restrictions | RESTR_MUTATE)\n+                self.compute(cmt_base, restrictions | RESTR_MUTATE | RESTR_CLAIM)\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n@@ -105,7 +105,9 @@ impl RestrictionsContext {\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n-                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                let result = self.compute(\n+                    cmt_base,\n+                    restrictions | RESTR_MUTATE | RESTR_CLAIM);\n                 self.extend(result, cmt.mutbl, LpDeref, restrictions)\n             }\n \n@@ -178,7 +180,9 @@ impl RestrictionsContext {\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such\n                 // cases we restrict aliasing on `cmt_base`.\n-                if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+                if restrictions.intersects(RESTR_MUTATE |\n+                                           RESTR_CLAIM |\n+                                           RESTR_FREEZE) {\n                     // R-Deref-Mut-Borrowed-1\n                     let result = self.compute(cmt_base, restrictions | RESTR_ALIAS);\n                     self.extend(result, cmt.mutbl, LpDeref, restrictions)\n@@ -244,7 +248,7 @@ impl RestrictionsContext {\n     fn check_no_mutability_control(&self,\n                                    cmt: mc::cmt,\n                                    restrictions: RestrictionSet) {\n-        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE | RESTR_CLAIM) {\n             self.bccx.report(BckError {span: self.span,\n                                        cmt: cmt,\n                                        code: err_freeze_aliasable_const});"}, {"sha": "b8c1504dbd0755a8baba3bb64b5cecba4461021c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -301,10 +301,10 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // Borrowing an lvalue often results in *restrictions* that limit what\n // can be done with this lvalue during the scope of the loan:\n //\n-// - `RESTR_MUTATE`: The lvalue may not be modified and mutable pointers to\n-//                   the value cannot be created.\n-// - `RESTR_FREEZE`: Immutable pointers to the value cannot be created.\n-// - `RESTR_ALIAS`: The lvalue may not be aliased in any way.\n+// - `RESTR_MUTATE`: The lvalue may not be modified.\n+// - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n+// - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n+// - `RESTR_ALIAS`: All borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n // restrictions are meaningful even if the RestrictionSet is empty,\n@@ -319,10 +319,11 @@ pub struct RestrictionSet {\n     bits: u32\n }\n \n-pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b000};\n-pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b001};\n-pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b010};\n-pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b100};\n+pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n+pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n+pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n+pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n pub impl RestrictionSet {\n     fn intersects(&self, restr: RestrictionSet) -> bool {"}, {"sha": "c51cf5b9538d9309a45cbcb2583e1dc2854f2071", "filename": "src/test/compile-fail/borrowck-alias-mut-base-ptr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -0,0 +1,15 @@\n+// Test that attempt to alias `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: &mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n+    **q = 22; //~ ERROR cannot assign to an `&mut` in a `&const` pointer\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "7e9c298ba4732582e7b4ed8799e59f5604290055", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -0,0 +1,31 @@\n+// Test that attempt to reborrow an `&mut` pointer in an aliasable\n+// location yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: & &mut int) {\n+    let t1 = t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n+    **t1 = 22; //~ ERROR cannot assign\n+}\n+\n+fn foo2(t0: &const &mut int) {\n+    // Note: reborrowing from an &const actually yields two errors, since it\n+    // is unsafe in two ways: we can't control the aliasing, and we can't\n+    // control the mutation.\n+    let t1 = t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&const` pointer\n+    //~^ ERROR unsafe borrow of aliasable, const value\n+    **t1 = 22; //~ ERROR cannot assign\n+}\n+\n+fn foo3(t0: &mut &mut int) {\n+    let t1 = &mut *t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow\n+    **t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "6a3832d2304cf8d7a1879200b2e85ffdfc3d5ebc", "filename": "src/test/compile-fail/borrowck-move-mut-base-ptr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -0,0 +1,15 @@\n+// Test that attempt to move `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: &mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let t1 = t0;        //~ ERROR cannot move out of `t0`\n+    *t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "bea5f1f6ea765c08c880382646bda9964a43d31c", "filename": "src/test/compile-fail/borrowck-swap-mut-base-ptr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1647c92a868d49709e3bbbe66d4f2a46e97595/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs?ref=bf1647c92a868d49709e3bbbe66d4f2a46e97595", "patch": "@@ -0,0 +1,16 @@\n+// Test that attempt to swap `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0;     // Freezes `*t0`\n+    swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+    *t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}]}