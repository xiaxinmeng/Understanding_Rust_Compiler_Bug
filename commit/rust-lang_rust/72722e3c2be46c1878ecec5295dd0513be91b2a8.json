{"sha": "72722e3c2be46c1878ecec5295dd0513be91b2a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNzIyZTNjMmJlNDZjMTg3OGVjZWM1Mjk1ZGQwNTEzYmU5MWIyYTg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T21:54:57Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T21:54:57Z"}, "message": "Merge branch 'coercions' of https://github.com/tshepang/rust into rollup_central", "tree": {"sha": "22f7d5de0c3bd4a13f6aa4f749b60468b576fe1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22f7d5de0c3bd4a13f6aa4f749b60468b576fe1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72722e3c2be46c1878ecec5295dd0513be91b2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72722e3c2be46c1878ecec5295dd0513be91b2a8", "html_url": "https://github.com/rust-lang/rust/commit/72722e3c2be46c1878ecec5295dd0513be91b2a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72722e3c2be46c1878ecec5295dd0513be91b2a8/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48ddf9068229cf29a9680913db506d358e446d8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/48ddf9068229cf29a9680913db506d358e446d8e", "html_url": "https://github.com/rust-lang/rust/commit/48ddf9068229cf29a9680913db506d358e446d8e"}, {"sha": "0d3954f4c574cda5f1bc63a915ff4d4f5e6e14ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3954f4c574cda5f1bc63a915ff4d4f5e6e14ac", "html_url": "https://github.com/rust-lang/rust/commit/0d3954f4c574cda5f1bc63a915ff4d4f5e6e14ac"}], "stats": {"total": 107, "additions": 66, "deletions": 41}, "files": [{"sha": "28e86e488d69c5da7472a0624449a1c5e8f4aa01", "filename": "src/doc/reference.md", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/72722e3c2be46c1878ecec5295dd0513be91b2a8/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/72722e3c2be46c1878ecec5295dd0513be91b2a8/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=72722e3c2be46c1878ecec5295dd0513be91b2a8", "patch": "@@ -3661,47 +3661,71 @@ sites are:\n \n * `let` statements where an explicit type is given.\n \n-    In `let _: U = e;`, `e` is coerced to have type `U`.\n+   For example, `128` is coerced to have type `i8` in the following:\n+\n+   ```rust\n+   let _: i8 = 128;\n+   ```\n \n * `static` and `const` statements (similar to `let` statements).\n \n-* arguments for function calls.\n+* Arguments for function calls\n+\n+  The value being coerced is the actual parameter, and it is coerced to\n+  the type of the formal parameter.\n+\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn bar(_: i8) { }\n \n-    The value being coerced is the\n-    actual parameter and it is coerced to the type of the formal parameter. For\n-    example, let `foo` be defined as `fn foo(x: U) { ... }` and call it as\n-    `foo(e);`. Then `e` is coerced to have type `U`;\n+  fn main() {\n+     bar(128);\n+  }\n+  ```\n \n-* instantiations of struct or variant fields.\n+* Instantiations of struct or variant fields\n \n-    Assume we have a `struct\n-    Foo { x: U }` and instantiate it as `Foo { x: e }`. Then `e` is coerced to\n-    have type `U`.\n+  For example, `128` is coerced to have type `i8` in the following:\n \n-* function results (either the final line of a block if it is not semicolon\n-terminated or any expression in a `return` statement).\n+  ```rust\n+  struct Foo { x: i8 }\n \n-    In `fn foo() -> U { e }`, `e` is coerced to to have type `U`.\n+  fn main() {\n+      Foo { x: 128 };\n+  }\n+  ```\n+\n+* Function results, either the final line of a block if it is not\n+  semicolon-terminated or any expression in a `return` statement\n+\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn foo() -> i8 {\n+      128\n+  }\n+  ```\n \n If the expression in one of these coercion sites is a coercion-propagating\n expression, then the relevant sub-expressions in that expression are also\n coercion sites. Propagation recurses from these new coercion sites.\n Propagating expressions and their relevant sub-expressions are:\n \n-* array literals, where the array has type `[U; n]`. Each sub-expression in\n+* Array literals, where the array has type `[U; n]`. Each sub-expression in\n the array literal is a coercion site for coercion to type `U`.\n \n-* array literals with repeating syntax, where the array has type `[U; n]`. The\n+* Array literals with repeating syntax, where the array has type `[U; n]`. The\n repeated sub-expression is a coercion site for coercion to type `U`.\n \n-* tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n+* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n Each sub-expression is a coercion site to the respective type, e.g. the\n zeroth sub-expression is a coercion site to type `U_0`.\n \n-* parenthesised sub-expressions (`(e)`). If the expression has type `U`, then\n+* Parenthesised sub-expressions (`(e)`): if the expression has type `U`, then\n the sub-expression is a coercion site to `U`.\n \n-* blocks. If a block has type `U`, then the last expression in the block (if\n+* Blocks: if a block has type `U`, then the last expression in the block (if\n it is not semicolon-terminated) is a coercion site to `U`. This includes\n blocks which are part of control flow statements, such as `if`/`else`, if\n the block has a known type.\n@@ -3710,45 +3734,46 @@ the block has a known type.\n \n Coercion is allowed between the following types:\n \n-* `T` to `U` if `T` is a subtype of `U` (*reflexive case*).\n+* `T` to `U` if `T` is a subtype of `U` (*reflexive case*)\n \n * `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n-(*transitive case*).\n+(*transitive case*)\n \n     Note that this is not fully supported yet\n \n-* `&mut T` to `&T`.\n+* `&mut T` to `&T`\n \n-* `*mut T` to `*const T`.\n+* `*mut T` to `*const T`\n \n-* `&T` to `*const T`.\n+* `&T` to `*const T`\n \n-* `&mut T` to `*mut T`.\n+* `&mut T` to `*mut T`\n \n * `&T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n \n-```rust\n-use std::ops::Deref;\n+  ```rust\n+  use std::ops::Deref;\n \n-struct CharContainer {\n-    value: char\n-}\n+  struct CharContainer {\n+      value: char\n+  }\n \n-impl Deref for CharContainer {\n-    type Target = char;\n+  impl Deref for CharContainer {\n+      type Target = char;\n \n-    fn deref<'a>(&'a self) -> &'a char {\n-        &self.value\n-    }\n-}\n+      fn deref<'a>(&'a self) -> &'a char {\n+          &self.value\n+      }\n+  }\n \n-fn foo(arg: &char) {}\n+  fn foo(arg: &char) {}\n+\n+  fn main() {\n+      let x = &mut CharContainer { value: 'y' };\n+      foo(x); //&mut CharContainer is coerced to &char.\n+  }\n+  ```\n \n-fn main() {\n-    let x = &mut CharContainer { value: 'y' };\n-    foo(x); //&mut CharContainer is coerced to &char.\n-}\n-```\n * `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n \n * TyCtor(`T`) to TyCtor(coerce_inner(`T`)), where TyCtor(`T`) is one of"}]}