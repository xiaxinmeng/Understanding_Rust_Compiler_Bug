{"sha": "03942056aac826c89a94d47239244277cc360714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzOTQyMDU2YWFjODI2Yzg5YTk0ZDQ3MjM5MjQ0Mjc3Y2MzNjA3MTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-24T17:37:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:51Z"}, "message": "trans: Handle type_of for Rust fn's via abi::FnType.", "tree": {"sha": "1615a8425db436400b66d55f64e3586b77309f91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1615a8425db436400b66d55f64e3586b77309f91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03942056aac826c89a94d47239244277cc360714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03942056aac826c89a94d47239244277cc360714", "html_url": "https://github.com/rust-lang/rust/commit/03942056aac826c89a94d47239244277cc360714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03942056aac826c89a94d47239244277cc360714/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6bbbe10707504065d80733a6bab81f1f4586df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6bbbe10707504065d80733a6bab81f1f4586df8", "html_url": "https://github.com/rust-lang/rust/commit/f6bbbe10707504065d80733a6bab81f1f4586df8"}], "stats": {"total": 148, "additions": 62, "deletions": 86}, "files": [{"sha": "2c3e9694844432a3291f15a6861e9d3e6370661c", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 54, "deletions": 13, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=03942056aac826c89a94d47239244277cc360714", "patch": "@@ -23,6 +23,7 @@ use trans::cabi_powerpc;\n use trans::cabi_powerpc64;\n use trans::cabi_mips;\n use trans::cabi_asmjs;\n+use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n \n@@ -146,22 +147,14 @@ impl FnType {\n         let cconv = match ccx.sess().target.target.adjust_abi(abi) {\n             RustIntrinsic => {\n                 // Intrinsics are emitted at the call site\n-                ccx.sess().bug(\"asked to register intrinsic fn\");\n+                ccx.sess().bug(\"asked to compute FnType of intrinsic\");\n             }\n             PlatformIntrinsic => {\n                 // Intrinsics are emitted at the call site\n-                ccx.sess().bug(\"asked to register platform intrinsic fn\");\n+                ccx.sess().bug(\"asked to compute FnType of platform intrinsic\");\n             }\n \n-            Rust => {\n-                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess().unimpl(\"foreign functions with Rust ABI\");\n-            }\n-\n-            RustCall => {\n-                // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess().unimpl(\"foreign functions with RustCall ABI\");\n-            }\n+            Rust | RustCall => llvm::CCallConv,\n \n             // It's the ABI's job to select this, not us.\n             System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n@@ -184,8 +177,27 @@ impl FnType {\n             _ => Type::void(ccx)\n         };\n \n-        let mut args = Vec::with_capacity(sig.inputs.len() + extra_args.len());\n-        for ty in sig.inputs.iter().chain(extra_args.iter()) {\n+        let mut inputs = &sig.inputs[..];\n+        let extra_args = if abi == RustCall {\n+            assert!(!sig.variadic && extra_args.is_empty());\n+\n+            match inputs[inputs.len() - 1].sty {\n+                ty::TyTuple(ref tupled_arguments) => {\n+                    inputs = &inputs[..inputs.len() - 1];\n+                    &tupled_arguments[..]\n+                }\n+                _ => {\n+                    unreachable!(\"argument to function with \\\"rust-call\\\" ABI \\\n+                                  is not a tuple\");\n+                }\n+            }\n+        } else {\n+            assert!(sig.variadic || extra_args.is_empty());\n+            extra_args\n+        };\n+\n+        let mut args = Vec::with_capacity(inputs.len() + extra_args.len());\n+        for ty in inputs.iter().chain(extra_args.iter()) {\n             let llty = c_type_of(ccx, ty);\n             if type_is_fat_ptr(ccx.tcx(), ty) {\n                 args.extend(llty.field_types().into_iter().map(|llty| {\n@@ -203,6 +215,35 @@ impl FnType {\n             cconv: cconv\n         };\n \n+        if abi == Rust || abi == RustCall {\n+            let fixup = |arg: &mut ArgType| {\n+                if !arg.ty.is_aggregate() {\n+                    // Scalars and vectors, always immediate.\n+                    return;\n+                }\n+                let size = llsize_of_alloc(ccx, arg.ty);\n+                if size > llsize_of_alloc(ccx, ccx.int_type()) {\n+                    arg.kind = Indirect;\n+                } else if size > 0 {\n+                    // We want to pass small aggregates as immediates, but using\n+                    // a LLVM aggregate type for this leads to bad optimizations,\n+                    // so we pick an appropriately sized integer type instead.\n+                    arg.cast = Some(Type::ix(ccx, size * 8));\n+                }\n+            };\n+            if let ty::FnConverging(ret_ty) = sig.output {\n+                // Fat pointers are returned by-value.\n+                if !type_is_fat_ptr(ccx.tcx(), ret_ty) &&\n+                   fty.ret.ty != Type::void(ccx) {\n+                    fixup(&mut fty.ret);\n+                }\n+            };\n+            for arg in &mut fty.args {\n+                fixup(arg);\n+            }\n+            return fty;\n+        }\n+\n         match &ccx.sess().target.target.arch[..] {\n             \"x86\" => cabi_x86::compute_abi_info(ccx, &mut fty),\n             \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {"}, {"sha": "9bdf371968f4300b570ceb0ccb24aa85fa480ff7", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=03942056aac826c89a94d47239244277cc360714", "patch": "@@ -31,7 +31,9 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         }\n     };\n \n-    fixup(&mut fty.ret, Some(Attribute::StructRet));\n+    if fty.ret.ty != Type::void(ccx) {\n+        fixup(&mut fty.ret, Some(Attribute::StructRet));\n+    }\n     for arg in &mut fty.args {\n         fixup(arg, None);\n     }"}, {"sha": "76195f19e9f432b74e787b2f47b644fff5cd35e1", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=03942056aac826c89a94d47239244277cc360714", "patch": "@@ -26,7 +26,6 @@ use trans::abi::{Abi, FnType};\n use trans::attributes;\n use trans::context::CrateContext;\n use trans::type_::Type;\n-use trans::type_of;\n \n use std::ffi::CString;\n use libc::c_uint;\n@@ -103,17 +102,8 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let (cconv, llfty) = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-        (llvm::CCallConv, type_of::type_of_rust_fn(ccx, &sig, f.abi))\n-    } else {\n-        let fty = FnType::new(ccx, f.abi, &sig, &[]);\n-        (fty.cconv, fty.to_llvm(ccx))\n-    };\n-\n-    // it is ok to directly access sig.0.output because we erased all\n-    // late-bound-regions above\n-        debug!(\"declare_rust_fn llfty={:?}\", llfty);\n-    let llfn = declare_raw_fn(ccx, name, cconv, llfty);\n+    let fty = FnType::new(ccx, f.abi, &sig, &[]);\n+    let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.to_llvm(ccx));\n \n     if sig.output == ty::FnDiverging {\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n@@ -122,7 +112,7 @@ pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n     if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n         attributes::from_fn_type(ccx, fn_type).apply_llfn(llfn);\n     } else {\n-        FnType::new(ccx, f.abi, &sig, &[]).add_attributes(llfn);\n+        fty.add_attributes(llfn);\n     }\n \n     llfn"}, {"sha": "662471241d586a5f08f4304d861759e48bb7f77a", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 59, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03942056aac826c89a94d47239244277cc360714/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=03942056aac826c89a94d47239244277cc360714", "patch": "@@ -13,7 +13,7 @@\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n-use trans::abi::{Abi, FnType};\n+use trans::abi::FnType;\n use trans::adt;\n use trans::common::*;\n use trans::machine;\n@@ -87,59 +87,6 @@ pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     result\n }\n \n-pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 sig: &ty::FnSig<'tcx>,\n-                                 abi: Abi)\n-                                 -> Type\n-{\n-    debug!(\"type_of_rust_fn(sig={:?}, abi={:?})\", sig, abi);\n-\n-    assert!(!sig.variadic); // rust fns are never variadic\n-\n-    let mut atys: Vec<Type> = Vec::new();\n-\n-    // First, munge the inputs, if this has the `rust-call` ABI.\n-    let inputs_temp;\n-    let inputs = if abi == Abi::RustCall {\n-        inputs_temp = untuple_arguments(cx, &sig.inputs);\n-        &inputs_temp\n-    } else {\n-        &sig.inputs\n-    };\n-\n-    // Arg 0: Output pointer.\n-    // (if the output type is non-immediate)\n-    let lloutputtype = match sig.output {\n-        ty::FnConverging(output) => {\n-            let use_out_pointer = return_uses_outptr(cx, output);\n-            let lloutputtype = arg_type_of(cx, output);\n-            // Use the output as the actual return value if it's immediate.\n-            if use_out_pointer {\n-                atys.push(lloutputtype.ptr_to());\n-                Type::void(cx)\n-            } else if return_type_is_void(cx, output) {\n-                Type::void(cx)\n-            } else {\n-                lloutputtype\n-            }\n-        }\n-        ty::FnDiverging => Type::void(cx)\n-    };\n-\n-    // ... then explicit args.\n-    for input in inputs {\n-        let arg_ty = type_of_explicit_arg(cx, input);\n-\n-        if type_is_fat_ptr(cx.tcx(), input) {\n-            atys.extend(arg_ty.field_types());\n-        } else {\n-            atys.push(arg_ty);\n-        }\n-    }\n-\n-    Type::func(&atys[..], &lloutputtype)\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -375,11 +322,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyFnPtr(f) => {\n         let sig = cx.tcx().erase_late_bound_regions(&f.sig);\n         let sig = infer::normalize_associated_type(cx.tcx(), &sig);\n-        if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            type_of_rust_fn(cx, &sig, f.abi).ptr_to()\n-        } else {\n-            FnType::new(cx, f.abi, &sig, &[]).to_llvm(cx).ptr_to()\n-        }\n+        FnType::new(cx, f.abi, &sig, &[]).to_llvm(cx).ptr_to()\n       }\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {"}]}