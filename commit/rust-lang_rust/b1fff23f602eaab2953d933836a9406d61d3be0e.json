{"sha": "b1fff23f602eaab2953d933836a9406d61d3be0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZmZmMjNmNjAyZWFhYjI5NTNkOTMzODM2YTk0MDZkNjFkM2JlMGU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-08-29T21:40:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-29T21:40:55Z"}, "message": "Rollup merge of #43918 - mystor:rustdoc-pound, r=QuietMisdreavus\n\nDon't highlight # which does not start an attribute in rustdoc\n\nCurrently when we highlight some macros for rustdoc (e.g. `quote!` from https://github.com/dtolnay/quote), we get really bad syntax highlighting, because we assume that every token between a `#` character and the next `]` in the source must be an attribute.\n\nThis patch improves that highlighting behavior to instead only highlight after finding the `[` token after the `#` token.\n\n(NOTE: I've only run this patch against https://github.com/nrc/rustdoc-highlight so if it doesn't build on travis that's why - I don't have a recent rustc build on this laptop)\n\nI'm guessing r? @steveklabnik", "tree": {"sha": "e785294a83200f0e1ff214fd838c5394c181ce85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e785294a83200f0e1ff214fd838c5394c181ce85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1fff23f602eaab2953d933836a9406d61d3be0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1fff23f602eaab2953d933836a9406d61d3be0e", "html_url": "https://github.com/rust-lang/rust/commit/b1fff23f602eaab2953d933836a9406d61d3be0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1fff23f602eaab2953d933836a9406d61d3be0e/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64a21f875f37ab0184a79e44e311f25e8e99dd86", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a21f875f37ab0184a79e44e311f25e8e99dd86", "html_url": "https://github.com/rust-lang/rust/commit/64a21f875f37ab0184a79e44e311f25e8e99dd86"}, {"sha": "2f19383742cea0c53bcd3d8775220059a1bfa883", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f19383742cea0c53bcd3d8775220059a1bfa883", "html_url": "https://github.com/rust-lang/rust/commit/2f19383742cea0c53bcd3d8775220059a1bfa883"}], "stats": {"total": 66, "additions": 49, "deletions": 17}, "files": [{"sha": "e6b236deac4eed88911e35dbd9870f11ed038fb3", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b1fff23f602eaab2953d933836a9406d61d3be0e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1fff23f602eaab2953d933836a9406d61d3be0e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b1fff23f602eaab2953d933836a9406d61d3be0e", "patch": "@@ -172,6 +172,21 @@ impl<'a> Classifier<'a> {\n         }\n     }\n \n+    /// Gets the next token out of the lexer, emitting fatal errors if lexing fails.\n+    fn try_next_token(&mut self) -> io::Result<TokenAndSpan> {\n+        match self.lexer.try_next_token() {\n+            Ok(tas) => Ok(tas),\n+            Err(_) => {\n+                self.lexer.emit_fatal_errors();\n+                self.lexer.sess.span_diagnostic\n+                    .struct_warn(\"Backing out of syntax highlighting\")\n+                    .note(\"You probably did not intend to render this as a rust code-block\")\n+                    .emit();\n+                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n+            }\n+        }\n+    }\n+\n     /// Exhausts the `lexer` writing the output into `out`.\n     ///\n     /// The general structure for this method is to iterate over each token,\n@@ -183,18 +198,7 @@ impl<'a> Classifier<'a> {\n                                    out: &mut W)\n                                    -> io::Result<()> {\n         loop {\n-            let next = match self.lexer.try_next_token() {\n-                Ok(tas) => tas,\n-                Err(_) => {\n-                    self.lexer.emit_fatal_errors();\n-                    self.lexer.sess.span_diagnostic\n-                        .struct_warn(\"Backing out of syntax highlighting\")\n-                        .note(\"You probably did not intend to render this as a rust code-block\")\n-                        .emit();\n-                    return Err(io::Error::new(io::ErrorKind::Other, \"\"));\n-                }\n-            };\n-\n+            let next = self.try_next_token()?;\n             if next.tok == token::Eof {\n                 break;\n             }\n@@ -255,13 +259,37 @@ impl<'a> Classifier<'a> {\n                 }\n             }\n \n-            // This is the start of an attribute. We're going to want to\n+            // This might be the start of an attribute. We're going to want to\n             // continue highlighting it as an attribute until the ending ']' is\n             // seen, so skip out early. Down below we terminate the attribute\n             // span when we see the ']'.\n             token::Pound => {\n-                self.in_attribute = true;\n-                out.enter_span(Class::Attribute)?;\n+                // We can't be sure that our # begins an attribute (it could\n+                // just be appearing in a macro) until we read either `#![` or\n+                // `#[` from the input stream.\n+                //\n+                // We don't want to start highlighting as an attribute until\n+                // we're confident there is going to be a ] coming up, as\n+                // otherwise # tokens in macros highlight the rest of the input\n+                // as an attribute.\n+\n+                // Case 1: #![inner_attribute]\n+                if self.lexer.peek().tok == token::Not {\n+                    self.try_next_token()?; // NOTE: consumes `!` token!\n+                    if self.lexer.peek().tok == token::OpenDelim(token::Bracket) {\n+                        self.in_attribute = true;\n+                        out.enter_span(Class::Attribute)?;\n+                    }\n+                    out.string(\"#\", Class::None, None)?;\n+                    out.string(\"!\", Class::None, None)?;\n+                    return Ok(());\n+                }\n+\n+                // Case 2: #[outer_attribute]\n+                if self.lexer.peek().tok == token::OpenDelim(token::Bracket) {\n+                    self.in_attribute = true;\n+                    out.enter_span(Class::Attribute)?;\n+                }\n                 out.string(\"#\", Class::None, None)?;\n                 return Ok(());\n             }"}, {"sha": "991cf4cf2b375aae64d296717d4bc304f7fe79f1", "filename": "src/test/rustdoc/issue-41783.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b1fff23f602eaab2953d933836a9406d61d3be0e/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1fff23f602eaab2953d933836a9406d61d3be0e/src%2Ftest%2Frustdoc%2Fissue-41783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-41783.rs?ref=b1fff23f602eaab2953d933836a9406d61d3be0e", "patch": "@@ -12,14 +12,18 @@\n // @!has - 'space'\n // @!has - 'comment'\n // @has - '# <span class=\"ident\">single'\n-// @has - '#<span class=\"attribute\"># <span class=\"ident\">double</span>'\n-// @has - '#<span class=\"attribute\">#<span class=\"attribute\"># <span class=\"ident\">triple</span>'\n+// @has - '## <span class=\"ident\">double</span>'\n+// @has - '### <span class=\"ident\">triple</span>'\n+// @has - '<span class=\"attribute\">#[<span class=\"ident\">outer</span>]</span>'\n+// @has - '<span class=\"attribute\">#![<span class=\"ident\">inner</span>]</span>'\n \n /// ```no_run\n /// # # space\n /// # comment\n /// ## single\n /// ### double\n /// #### triple\n+/// ##[outer]\n+/// ##![inner]\n /// ```\n pub struct Foo;"}]}