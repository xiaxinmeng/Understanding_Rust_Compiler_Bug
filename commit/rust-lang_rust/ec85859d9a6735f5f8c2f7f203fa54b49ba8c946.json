{"sha": "ec85859d9a6735f5f8c2f7f203fa54b49ba8c946", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjODU4NTlkOWE2NzM1ZjVmOGMyZjdmMjAzZmE1NGI0OWJhOGM5NDY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2017-05-10T15:18:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-10T15:18:32Z"}, "message": "Rollup merge of #41809 - gamazeps:thread-docs, r=steveklabnik\n\n[DOC] Improve the thread::park and thread::unpark documentation\n\nPart of #29378 .\n\nTakes care of the documentation for `park`, `park_duration` and also improves the `unpark` example.\n\n- `park should` have its module documentation inlined here, and cleaned up.\n- `park_timeout` could use links to `park`.", "tree": {"sha": "0a3b8e939dc9cb0f3b32101626654f9b6bcad66a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a3b8e939dc9cb0f3b32101626654f9b6bcad66a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946", "html_url": "https://github.com/rust-lang/rust/commit/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6e1e1fe214e729b47bf8c893e3141e7e6e50736", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e1e1fe214e729b47bf8c893e3141e7e6e50736", "html_url": "https://github.com/rust-lang/rust/commit/a6e1e1fe214e729b47bf8c893e3141e7e6e50736"}, {"sha": "afe74c3900aa00373a0d5edd2bd433870822c40a", "url": "https://api.github.com/repos/rust-lang/rust/commits/afe74c3900aa00373a0d5edd2bd433870822c40a", "html_url": "https://github.com/rust-lang/rust/commit/afe74c3900aa00373a0d5edd2bd433870822c40a"}], "stats": {"total": 152, "additions": 91, "deletions": 61}, "files": [{"sha": "6e0ad0789e420193de9890940717472644201899", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 91, "deletions": 61, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec85859d9a6735f5f8c2f7f203fa54b49ba8c946/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=ec85859d9a6735f5f8c2f7f203fa54b49ba8c946", "patch": "@@ -96,41 +96,6 @@\n //! The [`thread::current`] function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n-//! ## Blocking support: park and unpark\n-//!\n-//! Every thread is equipped with some basic low-level blocking support, via the\n-//! [`thread::park`][`park`] function and [`thread::Thread::unpark()`][`unpark`]\n-//! method. [`park`] blocks the current thread, which can then be resumed from\n-//! another thread by calling the [`unpark`] method on the blocked thread's handle.\n-//!\n-//! Conceptually, each [`Thread`] handle has an associated token, which is\n-//! initially not present:\n-//!\n-//! * The [`thread::park`][`park`] function blocks the current thread unless or until\n-//!   the token is available for its thread handle, at which point it atomically\n-//!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. [`thread::park_timeout`] does the same, but allows specifying a\n-//!   maximum time to block the thread for.\n-//!\n-//! * The [`unpark`] method on a [`Thread`] atomically makes the token available\n-//!   if it wasn't already.\n-//!\n-//! In other words, each [`Thread`] acts a bit like a semaphore with initial count\n-//! 0, except that the semaphore is *saturating* (the count cannot go above 1),\n-//! and can return spuriously.\n-//!\n-//! The API is typically used by acquiring a handle to the current thread,\n-//! placing that handle in a shared data structure so that other threads can\n-//! find it, and then `park`ing. When some desired condition is met, another\n-//! thread calls [`unpark`] on the handle.\n-//!\n-//! The motivation for this design is twofold:\n-//!\n-//! * It avoids the need to allocate mutexes and condvars when building new\n-//!   synchronization primitives; the threads already provide basic blocking/signaling.\n-//!\n-//! * It can be implemented very efficiently on many platforms.\n-//!\n //! ## Thread-local storage\n //!\n //! This module also provides an implementation of thread-local storage for Rust\n@@ -568,23 +533,72 @@ pub fn sleep(dur: Duration) {\n \n /// Blocks unless or until the current thread's token is made available.\n ///\n-/// Every thread is equipped with some basic low-level blocking support, via\n-/// the `park()` function and the [`unpark`][unpark] method. These can be\n-/// used as a more CPU-efficient implementation of a spinlock.\n+/// A call to `park` does not guarantee that the thread will remain parked\n+/// forever, and callers should be prepared for this possibility.\n+///\n+/// # park and unpark\n+///\n+/// Every thread is equipped with some basic low-level blocking support, via the\n+/// [`thread::park`][`park`] function and [`thread::Thread::unpark`][`unpark`]\n+/// method. [`park`] blocks the current thread, which can then be resumed from\n+/// another thread by calling the [`unpark`] method on the blocked thread's\n+/// handle.\n+///\n+/// Conceptually, each [`Thread`] handle has an associated token, which is\n+/// initially not present:\n ///\n-/// [unpark]: struct.Thread.html#method.unpark\n+/// * The [`thread::park`][`park`] function blocks the current thread unless or\n+///   until the token is available for its thread handle, at which point it\n+///   atomically consumes the token. It may also return *spuriously*, without\n+///   consuming the token. [`thread::park_timeout`] does the same, but allows\n+///   specifying a maximum time to block the thread for.\n+///\n+/// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n+///   if it wasn't already.\n+///\n+/// In other words, each [`Thread`] acts a bit like a spinlock that can be\n+/// locked and unlocked using `park` and `unpark`.\n ///\n /// The API is typically used by acquiring a handle to the current thread,\n /// placing that handle in a shared data structure so that other threads can\n-/// find it, and then parking (in a loop with a check for the token actually\n-/// being acquired).\n+/// find it, and then `park`ing. When some desired condition is met, another\n+/// thread calls [`unpark`] on the handle.\n ///\n-/// A call to `park` does not guarantee that the thread will remain parked\n-/// forever, and callers should be prepared for this possibility.\n+/// The motivation for this design is twofold:\n+///\n+/// * It avoids the need to allocate mutexes and condvars when building new\n+///   synchronization primitives; the threads already provide basic\n+///   blocking/signaling.\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// * It can be implemented very efficiently on many platforms.\n ///\n-/// [thread]: index.html\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+/// use std::time::Duration;\n+///\n+/// let parked_thread = thread::Builder::new()\n+///     .spawn(|| {\n+///         println!(\"Parking thread\");\n+///         thread::park();\n+///         println!(\"Thread unparked\");\n+///     })\n+///     .unwrap();\n+///\n+/// // Let some time pass for the thread to be spawned.\n+/// thread::sleep(Duration::from_millis(10));\n+///\n+/// println!(\"Unpark the thread\");\n+/// parked_thread.thread().unpark();\n+///\n+/// parked_thread.join().unwrap();\n+/// ```\n+///\n+/// [`Thread`]: ../../std/thread/struct.Thread.html\n+/// [`park`]: ../../std/thread/fn.park.html\n+/// [`unpark`]: ../../std/thread/struct.Thread.html#method.unpark\n+/// [`thread::park_timeout`]: ../../std/thread/fn.park_timeout.html\n //\n // The implementation currently uses the trivial strategy of a Mutex+Condvar\n // with wakeup flag, which does not actually allow spurious wakeups. In the\n@@ -601,21 +615,21 @@ pub fn park() {\n     *guard = false;\n }\n \n-/// Use [park_timeout].\n+/// Use [`park_timeout`].\n ///\n /// Blocks unless or until the current thread's token is made available or\n /// the specified duration has been reached (may wake spuriously).\n ///\n-/// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than `ms`. This method\n-/// should not be used for precise timing due to anomalies such as\n+/// The semantics of this function are equivalent to [`park`] except\n+/// that the thread will be blocked for roughly no longer than `dur`. This\n+/// method should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `ms` long.\n ///\n-/// See the [module documentation][thread] for more detail.\n+/// See the [park documentation][`park`] for more detail.\n ///\n-/// [thread]: index.html\n-/// [park_timeout]: fn.park_timeout.html\n+/// [`park_timeout`]: fn.park_timeout.html\n+/// [`park`]: ../../std/thread/fn.park.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::thread::park_timeout`\")]\n pub fn park_timeout_ms(ms: u32) {\n@@ -625,13 +639,13 @@ pub fn park_timeout_ms(ms: u32) {\n /// Blocks unless or until the current thread's token is made available or\n /// the specified duration has been reached (may wake spuriously).\n ///\n-/// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than `dur`. This method\n-/// should not be used for precise timing due to anomalies such as\n+/// The semantics of this function are equivalent to [`park`][park] except\n+/// that the thread will be blocked for roughly no longer than `dur`. This\n+/// method should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n /// amount of time waited to be precisely `dur` long.\n ///\n-/// See the module doc for more detail.\n+/// See the [park dococumentation][park] for more details.\n ///\n /// # Platform behavior\n ///\n@@ -656,6 +670,8 @@ pub fn park_timeout_ms(ms: u32) {\n ///     park_timeout(timeout);\n /// }\n /// ```\n+///\n+/// [park]: fn.park.html\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n     let thread = current();\n@@ -777,22 +793,36 @@ impl Thread {\n \n     /// Atomically makes the handle's token available if it is not already.\n     ///\n-    /// See the module doc for more detail.\n+    /// Every thread is equipped with some basic low-level blocking support, via\n+    /// the [`park`][park] function and the `unpark()` method. These can be\n+    /// used as a more CPU-efficient implementation of a spinlock.\n+    ///\n+    /// See the [park documentation][park] for more details.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::thread;\n+    /// use std::time::Duration;\n     ///\n-    /// let handler = thread::Builder::new()\n+    /// let parked_thread = thread::Builder::new()\n     ///     .spawn(|| {\n-    ///         let thread = thread::current();\n-    ///         thread.unpark();\n+    ///         println!(\"Parking thread\");\n+    ///         thread::park();\n+    ///         println!(\"Thread unparked\");\n     ///     })\n     ///     .unwrap();\n     ///\n-    /// handler.join().unwrap();\n+    /// // Let some time pass for the thread to be spawned.\n+    /// thread::sleep(Duration::from_millis(10));\n+    ///\n+    /// println!(\"Unpark the thread\");\n+    /// parked_thread.thread().unpark();\n+    ///\n+    /// parked_thread.join().unwrap();\n     /// ```\n+    ///\n+    /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();"}]}