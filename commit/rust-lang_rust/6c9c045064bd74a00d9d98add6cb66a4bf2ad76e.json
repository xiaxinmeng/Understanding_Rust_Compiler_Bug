{"sha": "6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjOWMwNDUwNjRiZDc0YTAwZDlkOThhZGQ2Y2I2NmE0YmYyYWQ3NmU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-22T19:23:04Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-23T17:10:36Z"}, "message": "rustdoc: Add the ability to test code in comments\n\nThis adds support for the `--test` flag to rustdoc which will parse a crate,\nextract all code examples in doc comments, and then run each test in the\nextra::test driver.", "tree": {"sha": "31dfda3b9a51c6885b424bfeabb5bd914b670d55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31dfda3b9a51c6885b424bfeabb5bd914b670d55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "html_url": "https://github.com/rust-lang/rust/commit/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f71c0dc2cd876f50252cdb907a6f05493c56d3cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f71c0dc2cd876f50252cdb907a6f05493c56d3cc", "html_url": "https://github.com/rust-lang/rust/commit/f71c0dc2cd876f50252cdb907a6f05493c56d3cc"}], "stats": {"total": 375, "additions": 335, "deletions": 40}, "files": [{"sha": "1111be5f417ec8fec7a635afb223c7d7afcdf961", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -1147,13 +1147,17 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    let tycx = match cx.tycx {\n+        Some(tycx) => tycx,\n+        // If we're extracting tests, this return value doesn't matter.\n+        None => return Bool\n+    };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let d = match cx.tycx.def_map.find(&id) {\n+    let d = match tycx.def_map.find(&id) {\n         Some(k) => k,\n         None => {\n-            let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n             debug!(\"could not find {:?} in defmap (`{}`)\", id,\n-                   syntax::ast_map::node_id_to_str(ctxt.tycx.items, id, ctxt.sess.intr()));\n+                   syntax::ast_map::node_id_to_str(tycx.items, id, cx.sess.intr()));\n             fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n         }\n     };\n@@ -1182,7 +1186,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n     if ast_util::is_local(def_id) {\n         ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n     } else {\n-        let fqn = csearch::get_item_path(cx.tycx, def_id);\n+        let fqn = csearch::get_item_path(tycx, def_id);\n         let fqn = fqn.move_iter().map(|i| {\n             match i {\n                 ast_map::path_mod(id) |\n@@ -1203,6 +1207,11 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n }\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n-    dm.find(&id).map(|&d| ast_util::def_id_of_def(d))\n+    let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    match cx.tycx {\n+        Some(tcx) => {\n+            tcx.def_map.find(&id).map(|&d| ast_util::def_id_of_def(d))\n+        }\n+        None => None\n+    }\n }"}, {"sha": "5c3d3484657349da3e03e2363f3e5e848a099596", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -27,7 +27,7 @@ use clean::Clean;\n \n pub struct DocContext {\n     crate: ast::Crate,\n-    tycx: middle::ty::ctxt,\n+    tycx: Option<middle::ty::ctxt>,\n     sess: driver::session::Session\n }\n \n@@ -78,17 +78,13 @@ fn get_ast_and_resolve(cpath: &Path,\n     } = phase_3_run_analysis_passes(sess, &crate);\n \n     debug!(\"crate: {:?}\", crate);\n-    return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n+    return (DocContext { crate: crate, tycx: Some(ty_cx), sess: sess },\n             CrateAnalysis { exported_items: exported_items });\n }\n \n pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;\n-    debug!(\"defmap:\");\n-    for (k, v) in ctxt.tycx.def_map.iter() {\n-        debug!(\"{:?}: {:?}\", k, v);\n-    }\n     local_data::set(super::ctxtkey, ctxt);\n \n     let v = @mut RustdocVisitor::new();"}, {"sha": "6fd83af3b2e760c7bac51f97b571be70a38a84aa", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -22,9 +22,12 @@\n //! // ... something using html\n //! ```\n \n+use std::cast;\n use std::fmt;\n-use std::libc;\n use std::io;\n+use std::libc;\n+use std::str;\n+use std::unstable::intrinsics;\n use std::vec;\n \n /// A unit struct which has the `fmt::Default` trait implemented. When\n@@ -41,8 +44,10 @@ static MKDEXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n \n type sd_markdown = libc::c_void;  // this is opaque to us\n \n-// this is a large struct of callbacks we don't use\n-type sd_callbacks = [libc::size_t, ..26];\n+struct sd_callbacks {\n+    blockcode: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+    other: [libc::size_t, ..25],\n+}\n \n struct html_toc_data {\n     header_count: libc::c_int,\n@@ -56,6 +61,11 @@ struct html_renderopt {\n     link_attributes: Option<extern \"C\" fn(*buf, *buf, *libc::c_void)>,\n }\n \n+struct my_opaque {\n+    opt: html_renderopt,\n+    dfltblk: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+}\n+\n struct buf {\n     data: *u8,\n     size: libc::size_t,\n@@ -84,7 +94,28 @@ extern {\n \n }\n \n-fn render(w: &mut io::Writer, s: &str) {\n+pub fn render(w: &mut io::Writer, s: &str) {\n+    extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n+        unsafe {\n+            let my_opaque: &my_opaque = cast::transmute(opaque);\n+            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                let text = str::from_utf8(text);\n+                let mut lines = text.lines().filter(|l| {\n+                    !l.trim().starts_with(\"#\")\n+                });\n+                let text = lines.to_owned_vec().connect(\"\\n\");\n+\n+                let buf = buf {\n+                    data: text.as_bytes().as_ptr(),\n+                    size: text.len() as libc::size_t,\n+                    asize: text.len() as libc::size_t,\n+                    unit: 0,\n+                };\n+                (my_opaque.dfltblk)(ob, &buf, lang, opaque);\n+            })\n+        }\n+    }\n+\n     // This code is all lifted from examples/sundown.c in the sundown repo\n     unsafe {\n         let ob = bufnew(OUTPUT_UNIT);\n@@ -100,11 +131,16 @@ fn render(w: &mut io::Writer, s: &str) {\n             flags: 0,\n             link_attributes: None,\n         };\n-        let callbacks: sd_callbacks = [0, ..26];\n+        let mut callbacks: sd_callbacks = intrinsics::init();\n \n         sdhtml_renderer(&callbacks, &options, 0);\n+        let opaque = my_opaque {\n+            opt: options,\n+            dfltblk: callbacks.blockcode,\n+        };\n+        callbacks.blockcode = block;\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n-                                       &options as *html_renderopt as *libc::c_void);\n+                                       &opaque as *my_opaque as *libc::c_void);\n \n \n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n@@ -118,6 +154,48 @@ fn render(w: &mut io::Writer, s: &str) {\n     }\n }\n \n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n+    extern fn block(_ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n+        unsafe {\n+            if text.is_null() || lang.is_null() { return }\n+            let (test, shouldfail, ignore) =\n+                vec::raw::buf_as_slice((*lang).data,\n+                                       (*lang).size as uint, |lang| {\n+                    let s = str::from_utf8(lang);\n+                    (s.contains(\"rust\"), s.contains(\"should_fail\"),\n+                     s.contains(\"ignore\"))\n+                });\n+            if !test { return }\n+            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                let tests: &mut ::test::Collector = intrinsics::transmute(opaque);\n+                let text = str::from_utf8(text);\n+                let mut lines = text.lines().map(|l| l.trim_chars(&'#'));\n+                let text = lines.to_owned_vec().connect(\"\\n\");\n+                tests.add_test(text, ignore, shouldfail);\n+            })\n+        }\n+    }\n+\n+    unsafe {\n+        let ob = bufnew(OUTPUT_UNIT);\n+        let extensions = MKDEXT_NO_INTRA_EMPHASIS | MKDEXT_TABLES |\n+                         MKDEXT_FENCED_CODE | MKDEXT_AUTOLINK |\n+                         MKDEXT_STRIKETHROUGH;\n+        let callbacks = sd_callbacks {\n+            blockcode: block,\n+            other: intrinsics::init()\n+        };\n+\n+        let tests = tests as *mut ::test::Collector as *libc::c_void;\n+        let markdown = sd_markdown_new(extensions, 16, &callbacks, tests);\n+\n+        sd_markdown_render(ob, doc.as_ptr(), doc.len() as libc::size_t,\n+                           markdown);\n+        sd_markdown_free(markdown);\n+        bufrelease(ob);\n+    }\n+}\n+\n impl<'a> fmt::Default for Markdown<'a> {\n     fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n         // This is actually common enough to special-case"}, {"sha": "3d9a0a73e57545e37e0590f2152dcf6cc0fe6667", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -47,6 +47,7 @@ pub mod html {\n pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n+pub mod test;\n \n pub static SCHEMA_VERSION: &'static str = \"0.8.1\";\n \n@@ -100,6 +101,9 @@ pub fn opts() -> ~[groups::OptGroup] {\n         optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n                  \"PLUGINS\"),\n         optflag(\"\", \"no-defaults\", \"don't run the default passes\"),\n+        optflag(\"\", \"test\", \"run code examples as tests\"),\n+        optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n+                 \"ARGS\"),\n     ]\n }\n \n@@ -114,6 +118,19 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n+    if matches.free.len() == 0 {\n+        println(\"expected an input file to act on\");\n+        return 1;\n+    } if matches.free.len() > 1 {\n+        println(\"only one input file may be specified\");\n+        return 1;\n+    }\n+    let input = matches.free[0].as_slice();\n+\n+    if matches.opt_present(\"test\") {\n+        return test::run(input, &matches);\n+    }\n+\n     if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n         println(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n@@ -126,7 +143,7 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n-    let (crate, res) = match acquire_input(&matches) {\n+    let (crate, res) = match acquire_input(input, &matches) {\n         Ok(pair) => pair,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n@@ -157,14 +174,8 @@ pub fn main_args(args: &[~str]) -> int {\n \n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input(matches: &getopts::Matches) -> Result<Output, ~str> {\n-    if matches.free.len() == 0 {\n-        return Err(~\"expected an input file to act on\");\n-    } if matches.free.len() > 1 {\n-        return Err(~\"only one input file may be specified\");\n-    }\n-\n-    let input = matches.free[0].as_slice();\n+fn acquire_input(input: &str,\n+                 matches: &getopts::Matches) -> Result<Output, ~str> {\n     match matches.opt_str(\"r\") {\n         Some(~\"rust\") => Ok(rust_input(input, matches)),\n         Some(~\"json\") => json_input(input),"}, {"sha": "9462f8118ba655c43ba7d5ba9cc20011c6e29081", "filename": "src/librustdoc/test.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hashmap::HashSet;\n+use std::local_data;\n+use std::os;\n+use std::run;\n+use std::str;\n+\n+use extra::tempfile::TempDir;\n+use extra::getopts;\n+use extra::test;\n+use rustc::driver::driver;\n+use rustc::driver::session;\n+use syntax::diagnostic;\n+use syntax::parse;\n+\n+use core;\n+use clean;\n+use clean::Clean;\n+use fold::DocFolder;\n+use html::markdown;\n+use passes;\n+use visit_ast::RustdocVisitor;\n+\n+pub fn run(input: &str, matches: &getopts::Matches) -> int {\n+    let parsesess = parse::new_parse_sess(None);\n+    let input = driver::file_input(Path::new(input));\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let libs = @mut libs.move_iter().collect();\n+\n+    let sessopts = @session::options {\n+        binary: @\"rustdoc\",\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: libs,\n+        outputs: ~[session::OutputDylib],\n+        .. (*session::basic_options()).clone()\n+    };\n+\n+\n+    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+\n+    let sess = driver::build_session_(sessopts,\n+                                      parsesess.cm,\n+                                      @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter,\n+                                      span_diagnostic_handler);\n+\n+    let cfg = driver::build_configuration(sess);\n+    let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+\n+    let ctx = @core::DocContext {\n+        crate: crate,\n+        tycx: None,\n+        sess: sess,\n+    };\n+    local_data::set(super::ctxtkey, ctx);\n+\n+    let v = @mut RustdocVisitor::new();\n+    v.visit(&ctx.crate);\n+    let crate = v.clean();\n+    let (crate, _) = passes::unindent_comments(crate);\n+    let (crate, _) = passes::collapse_docs(crate);\n+\n+    let mut collector = Collector {\n+        tests: ~[],\n+        names: ~[],\n+        cnt: 0,\n+        libs: libs,\n+        cratename: crate.name.to_owned(),\n+    };\n+    collector.fold_crate(crate);\n+\n+    let args = matches.opt_strs(\"test-args\");\n+    let mut args = args.iter().flat_map(|s| s.words()).map(|s| s.to_owned());\n+    let mut args = args.to_owned_vec();\n+    args.unshift(~\"rustdoctest\");\n+\n+    test::test_main(args, collector.tests);\n+\n+    0\n+}\n+\n+fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n+    let test = maketest(test, cratename);\n+    let parsesess = parse::new_parse_sess(None);\n+    let input = driver::str_input(test);\n+\n+    let sessopts = @session::options {\n+        binary: @\"rustdoctest\",\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: @mut libs,\n+        outputs: ~[session::OutputExecutable],\n+        debugging_opts: session::prefer_dynamic,\n+        .. (*session::basic_options()).clone()\n+    };\n+\n+    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+\n+    let sess = driver::build_session_(sessopts,\n+                                      parsesess.cm,\n+                                      @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter,\n+                                      span_diagnostic_handler);\n+\n+    let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n+    let out = Some(outdir.path().clone());\n+    let cfg = driver::build_configuration(sess);\n+    driver::compile_input(sess, cfg, &input, &out, &None);\n+\n+    let exe = outdir.path().join(\"rust_out\");\n+    let out = run::process_output(exe.as_str().unwrap(), []);\n+    match out {\n+        None => fail!(\"couldn't run the test\"),\n+        Some(out) => {\n+            if !out.status.success() {\n+                fail!(\"test executable failed:\\n{}\",\n+                      str::from_utf8(out.error));\n+            }\n+        }\n+    }\n+}\n+\n+fn maketest(s: &str, cratename: &str) -> @str {\n+    let mut prog = ~r\"\n+#[deny(warnings)];\n+#[allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n+#[feature(macro_rules, globs, struct_variant, managed_boxes)];\n+\";\n+    if s.contains(\"extra\") {\n+        prog.push_str(\"extern mod extra;\\n\");\n+    }\n+    if s.contains(cratename) {\n+        prog.push_str(format!(\"extern mod {};\\n\", cratename));\n+    }\n+    if s.contains(\"fn main\") {\n+        prog.push_str(s);\n+    } else {\n+        prog.push_str(\"fn main() {\\n\");\n+        prog.push_str(s);\n+        prog.push_str(\"\\n}\");\n+    }\n+\n+    return prog.to_managed();\n+}\n+\n+pub struct Collector {\n+    priv tests: ~[test::TestDescAndFn],\n+    priv names: ~[~str],\n+    priv libs: @mut HashSet<Path>,\n+    priv cnt: uint,\n+    priv cratename: ~str,\n+}\n+\n+impl Collector {\n+    pub fn add_test(&mut self, test: &str, ignore: bool, should_fail: bool) {\n+        let test = test.to_owned();\n+        let name = format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt);\n+        self.cnt += 1;\n+        let libs = (*self.libs).clone();\n+        let cratename = self.cratename.to_owned();\n+        self.tests.push(test::TestDescAndFn {\n+            desc: test::TestDesc {\n+                name: test::DynTestName(name),\n+                ignore: ignore,\n+                should_fail: should_fail,\n+            },\n+            testfn: test::DynTestFn(proc() {\n+                runtest(test, cratename, libs);\n+            }),\n+        });\n+    }\n+}\n+\n+impl DocFolder for Collector {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        let pushed = match item.name {\n+            Some(ref name) if name.len() == 0 => false,\n+            Some(ref name) => { self.names.push(name.to_owned()); true }\n+            None => false\n+        };\n+        match item.doc_value() {\n+            Some(doc) => {\n+                self.cnt = 0;\n+                markdown::find_testable_code(doc, self);\n+            }\n+            None => {}\n+        }\n+        let ret = self.fold_item_recur(item);\n+        if pushed {\n+            self.names.pop();\n+        }\n+        return ret;\n+    }\n+}"}, {"sha": "03ab85918c759fe3a5df2fc45cc90d2793be2e53", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c9c045064bd74a00d9d98add6cb66a4bf2ad76e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6c9c045064bd74a00d9d98add6cb66a4bf2ad76e", "patch": "@@ -12,11 +12,10 @@\n //! usable for clean\n \n use syntax::abi::AbiSet;\n-use syntax::{ast, ast_map};\n+use syntax::ast;\n use syntax::codemap::Span;\n \n use doctree::*;\n-use std::local_data;\n \n pub struct RustdocVisitor {\n     module: Module,\n@@ -91,15 +90,8 @@ impl RustdocVisitor {\n         }\n \n         fn visit_mod_contents(span: Span, attrs: ~[ast::Attribute], vis:\n-                              ast::visibility, id: ast::NodeId, m: &ast::_mod) -> Module {\n-            let am = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.items;\n-            let name = match am.find(&id) {\n-                Some(m) => match m {\n-                    &ast_map::node_item(ref it, _) => Some(it.ident),\n-                    _ => fail!(\"mod id mapped to non-item in the ast map\")\n-                },\n-                None => None\n-            };\n+                              ast::visibility, id: ast::NodeId, m: &ast::_mod,\n+                              name: Option<ast::Ident>) -> Module {\n             let mut om = Module::new(name);\n             om.view_items = m.view_items.clone();\n             om.where = span;\n@@ -117,7 +109,8 @@ impl RustdocVisitor {\n             match item.node {\n                 ast::item_mod(ref m) => {\n                     om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),\n-                                                    item.vis, item.id, m));\n+                                                    item.vis, item.id, m,\n+                                                    Some(item.ident)));\n                 },\n                 ast::item_enum(ref ed, ref gen) => om.enums.push(visit_enum_def(item, ed, gen)),\n                 ast::item_struct(sd, ref gen) => om.structs.push(visit_struct_def(item, sd, gen)),\n@@ -182,6 +175,7 @@ impl RustdocVisitor {\n         }\n \n         self.module = visit_mod_contents(crate.span, crate.attrs.clone(),\n-                                         ast::public, ast::CRATE_NODE_ID, &crate.module);\n+                                         ast::public, ast::CRATE_NODE_ID,\n+                                         &crate.module, None);\n     }\n }"}]}