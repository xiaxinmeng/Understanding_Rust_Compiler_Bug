{"sha": "bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYjVjNGQ1NGY2MDFkNjA2NmQ2ZmE0NjMzOTBkM2Q4YjMwZjUzYjc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-27T01:34:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-27T01:39:55Z"}, "message": "Run compile tests in a way that's safe in a multithreaded environment\n\nIn theory. There's still something leaking but I hope it's no longer due to\nthe test runner doing unsafe things.\n\nThis is a pretty nasty patch, working around limitations in the type and task\nsystems, and it makes the std::test API a little uglier.", "tree": {"sha": "2bfafd74e41a0ec547d6c1339282e6b696ff7680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bfafd74e41a0ec547d6c1339282e6b696ff7680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "html_url": "https://github.com/rust-lang/rust/commit/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c780b420308cc9f57a5cb5b9619d43c1a4e6f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c780b420308cc9f57a5cb5b9619d43c1a4e6f44", "html_url": "https://github.com/rust-lang/rust/commit/1c780b420308cc9f57a5cb5b9619d43c1a4e6f44"}], "stats": {"total": 231, "additions": 163, "deletions": 68}, "files": [{"sha": "bfbbdee2705f5278c391fecff0d38ee3c8780c8e", "filename": "src/lib/test.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "patch": "@@ -16,9 +16,12 @@ export tr_ok;\n export tr_failed;\n export tr_ignored;\n export run_tests_console;\n+export run_tests_console_;\n export run_test;\n export filter_tests;\n export parse_opts;\n+export test_to_task;\n+export default_test_to_task;\n \n // The name of a test. By convention this follows the rules for rust\n // paths, i.e it should be a series of identifiers seperated by double\n@@ -95,8 +98,21 @@ tag test_result {\n     tr_ignored;\n }\n \n+// To get isolation and concurrency tests have to be run in their own tasks.\n+// In cases where test functions and closures it is not ok to just dump them\n+// into a task and run them, so this transformation gives the caller a chance\n+// to create the test task.\n+type test_to_task = fn(&fn()) -> task;\n+\n // A simple console test runner\n-fn run_tests_console(&test_opts opts, &test_desc[] tests) -> bool {\n+fn run_tests_console(&test_opts opts,\n+                     &test_desc[] tests) -> bool {\n+    run_tests_console_(opts, tests, default_test_to_task)\n+}\n+\n+fn run_tests_console_(&test_opts opts,\n+                     &test_desc[] tests,\n+                     &test_to_task to_task) -> bool {\n \n     auto filtered_tests = filter_tests(opts, tests);\n \n@@ -124,7 +140,7 @@ fn run_tests_console(&test_opts opts, &test_desc[] tests) -> bool {\n     while (wait_idx < total) {\n         while (ivec::len(futures) < concurrency\n                && run_idx < total) {\n-            futures += ~[run_test(filtered_tests.(run_idx))];\n+            futures += ~[run_test(filtered_tests.(run_idx), to_task)];\n             run_idx += 1u;\n         }\n \n@@ -266,14 +282,14 @@ type test_future = rec(test_desc test,\n                        @fn() fnref,\n                        fn() -> test_result wait);\n \n-fn run_test(&test_desc test) -> test_future {\n+fn run_test(&test_desc test, &test_to_task to_task) -> test_future {\n     // FIXME: Because of the unsafe way we're passing the test function\n     // to the test task, we need to make sure we keep a reference to that\n     // function around for longer than the lifetime of the task. To that end\n     // we keep the function boxed in the test future.\n     auto fnref = @test.fn;\n     if (!test.ignore) {\n-        auto test_task = run_test_fn_in_task(*fnref);\n+        auto test_task = to_task(*fnref);\n         ret rec(test = test,\n                 fnref = fnref,\n                 wait = bind fn(&task test_task) -> test_result {\n@@ -295,8 +311,9 @@ native \"rust\" mod rustrt {\n \n // We need to run our tests in another task in order to trap test failures.\n // But, at least currently, functions can't be used as spawn arguments so\n-// we've got to treat our test functions as unsafe pointers.\n-fn run_test_fn_in_task(&fn() f) -> task {\n+// we've got to treat our test functions as unsafe pointers.  This function\n+// only works with functions that don't contain closures.\n+fn default_test_to_task(&fn() f) -> task {\n     fn run_task(*mutable fn() fptr) {\n         // If this task fails we don't want that failure to propagate to the\n         // test runner or else we couldn't keep running tests"}, {"sha": "cd349c378248b2cd3677ae3dd978c8a073fbba85", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 138, "deletions": 60, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "patch": "@@ -87,12 +87,7 @@ fn parse_config(&str[] args) -> config {\n             src_base = getopts::opt_str(match, \"src-base\"),\n             build_base = getopts::opt_str(match, \"build-base\"),\n             stage_id = getopts::opt_str(match, \"stage-id\"),\n-            mode = alt getopts::opt_str(match, \"mode\") {\n-                \"compile-fail\" { mode_compile_fail }\n-                \"run-fail\" { mode_run_fail }\n-                \"run-pass\" { mode_run_pass }\n-                _ { fail \"invalid mode\" }\n-            },\n+            mode = str_mode(getopts::opt_str(match, \"mode\")),\n             run_ignored = getopts::opt_present(match, \"ignored\"),\n             filter = if vec::len(match.free) > 0u {\n                 option::some(match.free.(0))\n@@ -115,22 +110,37 @@ fn log_config(&config config) {\n     logv(c, #fmt(\"stage_id: %s\", config.stage_id));\n     logv(c, #fmt(\"mode: %s\", mode_str(config.mode)));\n     logv(c, #fmt(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, #fmt(\"filter: %s\", alt (config.filter) {\n-      option::some(?f) { f }\n-      option::none { \"(none)\" }\n-    }));\n-    logv(c, #fmt(\"runtool: %s\", alt (config.runtool) {\n-      option::some(?s) { s }\n-      option::none { \"(none)\" }\n-    }));\n-    logv(c, #fmt(\"rustcflags: %s\", alt (config.rustcflags) {\n-      option::some(?s) { s }\n-      option::none { \"(none)\" }\n-    }));\n+    logv(c, #fmt(\"filter: %s\", opt_str(config.filter)));\n+    logv(c, #fmt(\"runtool: %s\", opt_str(config.runtool)));\n+    logv(c, #fmt(\"rustcflags: %s\", opt_str(config.rustcflags)));\n     logv(c, #fmt(\"verbose: %b\", config.verbose));\n     logv(c, #fmt(\"\\n\"));\n }\n \n+fn opt_str(option::t[str] maybestr) -> str {\n+    alt maybestr {\n+      option::some(?s) { s }\n+      option::none { \"(none)\" }\n+    }\n+}\n+\n+fn str_opt(str maybestr) -> option::t[str] {\n+    if maybestr != \"(none)\" {\n+        option::some(maybestr)\n+    } else {\n+        option::none\n+    }\n+}\n+\n+fn str_mode(str s) -> mode {\n+    alt s {\n+      \"compile-fail\" { mode_compile_fail }\n+      \"run-fail\" { mode_run_fail }\n+      \"run-pass\" { mode_run_pass }\n+      _ { fail \"invalid mode\" }\n+    }\n+}\n+\n fn mode_str(mode mode) -> str {\n     alt (mode) {\n         mode_compile_fail { \"compile-fail\" }\n@@ -147,7 +157,7 @@ fn run_tests(&config config) {\n     auto cx = rec(config = config,\n                   procsrv = procsrv::mk());\n     auto tests = make_tests(cx);\n-    test::run_tests_console(opts, tests);\n+    test::run_tests_console_(opts, tests.tests, tests.to_task);\n     procsrv::close(cx.procsrv);\n }\n \n@@ -156,16 +166,21 @@ fn test_opts(&config config) -> test::test_opts {\n         run_ignored = config.run_ignored)\n }\n \n-fn make_tests(&cx cx) -> test::test_desc[] {\n+type tests_and_conv_fn = rec(test::test_desc[] tests,\n+                             fn(&fn()) -> task to_task);\n+\n+fn make_tests(&cx cx) -> tests_and_conv_fn {\n     log #fmt(\"making tests from %s\", cx.config.src_base);\n+    auto configport = port[str]();\n     auto tests = ~[];\n     for (str file in fs::list_dir(cx.config.src_base)) {\n         log #fmt(\"inspecting file %s\", file);\n         if (is_test(file)) {\n-            tests += ~[make_test(cx, file)];\n+            tests += ~[make_test(cx, file, configport)];\n         }\n     }\n-    ret tests;\n+    ret rec(tests = tests,\n+            to_task = bind closure_to_task(cx, configport, _));\n }\n \n fn is_test(&str testfile) -> bool {\n@@ -176,9 +191,10 @@ fn is_test(&str testfile) -> bool {\n          || str::starts_with(name, \"~\"))\n }\n \n-fn make_test(&cx cx, &str testfile) -> test::test_desc {\n+fn make_test(&cx cx, &str testfile,\n+             &port[str] configport) -> test::test_desc {\n     rec(name = testfile,\n-        fn = make_test_fn(cx, testfile),\n+        fn = make_test_closure(testfile, chan(configport)),\n         ignore = is_test_ignored(cx.config, testfile))\n }\n \n@@ -206,44 +222,97 @@ iter iter_header(&str testfile) -> str {\n     }\n }\n \n-fn make_test_fn(&cx cx, &str testfile) -> test::test_fn {\n-    // We're doing some ferociously unsafe nonsense here by creating a closure\n-    // and letting the test runner spawn it into a task. To avoid having\n-    // different tasks fighting over their refcounts and then the wrong task\n-    // freeing a box we need to clone everything, and make sure our closure\n-    // outlives all the tasks.\n-    fn clonestr(&str s) -> str {\n-        str::unsafe_from_bytes(str::bytes(s))\n-    }\n+/*\n+So this is kind of crappy:\n+\n+A test is just defined as a function, as you might expect, but tests have to\n+run their own tasks. Unfortunately, if your test needs dynamic data then it\n+needs to be a closure, and transferring closures across tasks without\n+committing a host of memory management transgressions is just impossible.\n+\n+To get around this, the standard test runner allows you the opportunity do\n+your own conversion from a test function to a task. It gives you your function\n+and you give it back a task.\n+\n+So that's what we're going to do. Here's where it gets stupid. To get the\n+the data out of the test function we are going to run the test function,\n+which will do nothing but send the data for that test to a port we've set\n+up. Then we'll spawn that data into another task and return the task.\n+Really convoluted. Need to think up of a better definition for tests.\n+*/\n+\n+fn make_test_closure(&str testfile,\n+                     chan[str] configchan) -> test::test_fn {\n+    bind send_config(testfile, configchan)\n+}\n+\n+fn send_config(str testfile, chan[str] configchan) {\n+    task::send(configchan, testfile);\n+}\n+\n+/*\n+FIXME: Good god forgive me.\n+\n+So actually shuttling structural data across tasks isn't possible at this\n+time, but we can send strings! Sadly, I need the whole config record, in the\n+test task so, instead of fixing the mechanism in the compiler I'm going to\n+break up the config record and pass everything individually to the spawned\n+function.  */\n+\n+fn closure_to_task(cx cx, port[str] configport, &fn() testfn) -> task{\n+    testfn();\n+    auto testfile = task::recv(configport);\n+    ret spawn run_test_task(cx.config.compile_lib_path,\n+                            cx.config.run_lib_path,\n+                            cx.config.rustc_path,\n+                            cx.config.src_base,\n+                            cx.config.build_base,\n+                            cx.config.stage_id,\n+                            mode_str(cx.config.mode),\n+                            cx.config.run_ignored,\n+                            opt_str(cx.config.filter),\n+                            opt_str(cx.config.runtool),\n+                            opt_str(cx.config.rustcflags),\n+                            cx.config.verbose,\n+                            procsrv::clone(cx.procsrv).chan,\n+                            testfile);\n+}\n+\n+fn run_test_task(str compile_lib_path,\n+                 str run_lib_path,\n+                 str rustc_path,\n+                 str src_base,\n+                 str build_base,\n+                 str stage_id,\n+                 str mode,\n+                 bool run_ignored,\n+                 str opt_filter,\n+                 str opt_runtool,\n+                 str opt_rustcflags,\n+                 bool verbose,\n+                 procsrv::reqchan procsrv_chan,\n+                 str testfile) {\n+\n+    auto config = rec(compile_lib_path = compile_lib_path,\n+                      run_lib_path = run_lib_path,\n+                      rustc_path = rustc_path,\n+                      src_base = src_base,\n+                      build_base = build_base,\n+                      stage_id = stage_id,\n+                      mode = str_mode(mode),\n+                      run_ignored = run_ignored,\n+                      filter = str_opt(opt_filter),\n+                      runtool = str_opt(opt_runtool),\n+                      rustcflags = str_opt(opt_rustcflags),\n+                      verbose = verbose);\n+\n+    auto procsrv = procsrv::from_chan(procsrv_chan);\n \n-    fn cloneoptstr(&option::t[str] s) -> option::t[str] {\n-        alt s {\n-          option::some(?s) { option::some(clonestr(s)) }\n-          option::none { option::none }\n-        }\n-    }\n+    auto cx = rec(config = config,\n+                  procsrv = procsrv);\n \n-    auto configclone = rec(\n-        compile_lib_path = clonestr(cx.config.compile_lib_path),\n-        run_lib_path = clonestr(cx.config.run_lib_path),\n-        rustc_path = clonestr(cx.config.rustc_path),\n-        src_base = clonestr(cx.config.src_base),\n-        build_base = clonestr(cx.config.build_base),\n-        stage_id = clonestr(cx.config.stage_id),\n-        mode = cx.config.mode,\n-        run_ignored = cx.config.run_ignored,\n-        filter = cloneoptstr(cx.config.filter),\n-        runtool = cloneoptstr(cx.config.runtool),\n-        rustcflags = cloneoptstr(cx.config.rustcflags),\n-        verbose = cx.config.verbose);\n-    auto cxclone = rec(config = configclone,\n-                       procsrv = procsrv::clone(cx.procsrv));\n-    auto testfileclone = clonestr(testfile);\n-    ret bind run_test(cxclone, testfileclone);\n-}\n-\n-fn run_test(cx cx, str testfile) {\n     log #fmt(\"running %s\", testfile);\n+    task::unsupervise();\n     auto props = load_props(testfile);\n     alt (cx.config.mode) {\n         mode_compile_fail {\n@@ -561,12 +630,16 @@ mod procsrv {\n \n     export handle;\n     export mk;\n+    export from_chan;\n     export clone;\n     export run;\n     export close;\n+    export reqchan;\n+\n+    type reqchan = chan[request];\n \n     type handle = rec(option::t[task] task,\n-                      chan[request] chan);\n+                      reqchan chan);\n \n     tag request {\n         exec(str, str, vec[str], chan[response]);\n@@ -581,6 +654,11 @@ mod procsrv {\n                 chan = res.chan);\n     }\n \n+    fn from_chan(&reqchan ch) -> handle {\n+        rec(task = option::none,\n+            chan = ch)\n+    }\n+\n     fn clone(&handle handle) -> handle {\n         // Sharing tasks across tasks appears to be (yet another) recipe for\n         // disaster, so our handle clones will not get the task pointer."}, {"sha": "65c1a049f9304a20294255d656ac014c265f3702", "filename": "src/test/stdtest/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcb5c4d54f601d6066d6fa463390d3d8b30f53b7/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=bcb5c4d54f601d6066d6fa463390d3d8b30f53b7", "patch": "@@ -15,7 +15,7 @@ fn do_not_run_ignored_tests() {\n                     fn = f,\n                     ignore = true);\n \n-    test::run_test(desc);\n+    test::run_test(desc, test::default_test_to_task);\n \n     assert ran == false;\n }\n@@ -26,7 +26,7 @@ fn ignored_tests_result_in_ignored() {\n     auto desc = rec(name = \"whatever\",\n                     fn = f,\n                     ignore = true);\n-    auto res = test::run_test(desc).wait();\n+    auto res = test::run_test(desc, test::default_test_to_task).wait();\n     assert res == test::tr_ignored;\n }\n "}]}