{"sha": "14a6a62a742e6aa79519dbc4300266df46f858f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YTZhNjJhNzQyZTZhYTc5NTE5ZGJjNDMwMDI2NmRmNDZmODU4Zjk=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-22T07:28:49Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-23T00:50:45Z"}, "message": "std::rand: simplify/safe-ify the default Rng.fill_bytes.\n\nThe `&[u8]` -> `&[u64]` and `&[u32]` casts were not nice: they ignored\nalignment requirements and are generally very unsafe.", "tree": {"sha": "7e5e852aec70fa5b326f4f4958d40175c91d424c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e5e852aec70fa5b326f4f4958d40175c91d424c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14a6a62a742e6aa79519dbc4300266df46f858f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14a6a62a742e6aa79519dbc4300266df46f858f9", "html_url": "https://github.com/rust-lang/rust/commit/14a6a62a742e6aa79519dbc4300266df46f858f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14a6a62a742e6aa79519dbc4300266df46f858f9/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae0905ab67a2dd3def61e266bba9f8f223586af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae0905ab67a2dd3def61e266bba9f8f223586af6", "html_url": "https://github.com/rust-lang/rust/commit/ae0905ab67a2dd3def61e266bba9f8f223586af6"}], "stats": {"total": 89, "additions": 44, "deletions": 45}, "files": [{"sha": "9f611578c6a97c05a3235bbd296babffc31a273f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/14a6a62a742e6aa79519dbc4300266df46f858f9/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14a6a62a742e6aa79519dbc4300266df46f858f9/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=14a6a62a742e6aa79519dbc4300266df46f858f9", "patch": "@@ -52,8 +52,6 @@ fn main () {\n  ```\n */\n \n-use mem::size_of;\n-use unstable::raw::Slice;\n use cast;\n use container::Container;\n use iter::{Iterator, range};\n@@ -136,46 +134,26 @@ pub trait Rng {\n     /// }\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n-        let mut slice: Slice<u64> = unsafe { cast::transmute_copy(&dest) };\n-        slice.len /= size_of::<u64>();\n-        let as_u64: &mut [u64] = unsafe { cast::transmute(slice) };\n-        for dest in as_u64.mut_iter() {\n-            *dest = self.next_u64();\n-        }\n-\n-        // the above will have filled up the vector as much as\n-        // possible in multiples of 8 bytes.\n-        let mut remaining = dest.len() % 8;\n-\n-        // space for a u32\n-        if remaining >= 4 {\n-            let mut slice: Slice<u32> = unsafe { cast::transmute_copy(&dest) };\n-            slice.len /= size_of::<u32>();\n-            let as_u32: &mut [u32] = unsafe { cast::transmute(slice) };\n-            as_u32[as_u32.len() - 1] = self.next_u32();\n-            remaining -= 4;\n-        }\n-        // exactly filled\n-        if remaining == 0 { return }\n-\n-        // now we know we've either got 1, 2 or 3 spots to go,\n-        // i.e. exactly one u32 is enough.\n-        let rand = self.next_u32();\n-        let remaining_index = dest.len() - remaining;\n-        match dest.mut_slice_from(remaining_index) {\n-            [ref mut a] => {\n-                *a = rand as u8;\n+        // this could, in theory, be done by transmuting dest to a\n+        // [u64], but this is (1) likely to be undefined behaviour for\n+        // LLVM, (2) has to be very careful about alignment concerns,\n+        // (3) adds more `unsafe` that needs to be checked, (4)\n+        // probably doesn't give much performance gain if\n+        // optimisations are on.\n+        let mut count = 0;\n+        let mut num = 0;\n+        for byte in dest.mut_iter() {\n+            if count == 0 {\n+                // we could micro-optimise here by generating a u32 if\n+                // we only need a few more bytes to fill the vector\n+                // (i.e. at most 4).\n+                num = self.next_u64();\n+                count = 8;\n             }\n-            [ref mut a, ref mut b] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-            }\n-            [ref mut a, ref mut b, ref mut c] => {\n-                *a = rand as u8;\n-                *b = (rand >> 8) as u8;\n-                *c = (rand >> 16) as u8;\n-            }\n-            _ => fail!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+\n+            *byte = (num & 0xff) as u8;\n+            num >>= 8;\n+            count -= 1;\n         }\n     }\n \n@@ -749,14 +727,35 @@ pub fn random<T: Rand>() -> T {\n mod test {\n     use iter::{Iterator, range};\n     use option::{Option, Some};\n+    use vec;\n     use super::*;\n \n+    struct ConstRng { i: u64 }\n+    impl Rng for ConstRng {\n+        fn next_u32(&mut self) -> u32 { self.i as u32 }\n+        fn next_u64(&mut self) -> u64 { self.i }\n+\n+        // no fill_bytes on purpose\n+    }\n+\n     #[test]\n     fn test_fill_bytes_default() {\n-        let mut r = weak_rng();\n-\n-        let mut v = [0u8, .. 100];\n-        r.fill_bytes(v);\n+        let mut r = ConstRng { i: 0x11_22_33_44_55_66_77_88 };\n+\n+        // check every remainder mod 8, both in small and big vectors.\n+        let lengths = [0, 1, 2, 3, 4, 5, 6, 7,\n+                       80, 81, 82, 83, 84, 85, 86, 87];\n+        for &n in lengths.iter() {\n+            let mut v = vec::from_elem(n, 0u8);\n+            r.fill_bytes(v);\n+\n+            // use this to get nicer error messages.\n+            for (i, &byte) in v.iter().enumerate() {\n+                if byte == 0 {\n+                    fail!(\"byte {} of {} is zero\", i, n)\n+                }\n+            }\n+        }\n     }\n \n     #[test]"}]}