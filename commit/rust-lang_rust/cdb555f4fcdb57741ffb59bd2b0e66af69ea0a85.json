{"sha": "cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYjU1NWY0ZmNkYjU3NzQxZmZiNTliZDJiMGU2NmFmNjllYTBhODU=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-10-23T20:16:59Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-10-23T20:16:59Z"}, "message": "Merge commit 'bf1c6f9871f430e284b17aa44059e0d0395e28a6' into clippyup", "tree": {"sha": "5c9c37427427a7d7b95dc090c560f006a9b92efe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c9c37427427a7d7b95dc090c560f006a9b92efe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "html_url": "https://github.com/rust-lang/rust/commit/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcde7683fe7ca10c83e5bc17f0969d2284affcd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcde7683fe7ca10c83e5bc17f0969d2284affcd2", "html_url": "https://github.com/rust-lang/rust/commit/fcde7683fe7ca10c83e5bc17f0969d2284affcd2"}], "stats": {"total": 2686, "additions": 2120, "deletions": 566}, "files": [{"sha": "6c92e10522c99feb0e7f07bf7d6e66a9e0ecde96", "filename": ".github/PULL_REQUEST_TEMPLATE.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2FPULL_REQUEST_TEMPLATE.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2FPULL_REQUEST_TEMPLATE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FPULL_REQUEST_TEMPLATE.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -12,12 +12,12 @@ your PR is merged.\n If you added a new lint, here's a checklist for things that will be\n checked during review or continuous integration.\n \n-- [ ] Followed [lint naming conventions][lint_naming]\n-- [ ] Added passing UI tests (including committed `.stderr` file)\n-- [ ] `cargo test` passes locally\n-- [ ] Executed `cargo dev update_lints`\n-- [ ] Added lint documentation\n-- [ ] Run `cargo dev fmt`\n+- \\[ ] Followed [lint naming conventions][lint_naming]\n+- \\[ ] Added passing UI tests (including committed `.stderr` file)\n+- \\[ ] `cargo test` passes locally\n+- \\[ ] Executed `cargo dev update_lints`\n+- \\[ ] Added lint documentation\n+- \\[ ] Run `cargo dev fmt`\n \n [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n "}, {"sha": "cf4aa39e49b903fb071d451cc767ac5e32a09c47", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -36,14 +36,14 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.3\n+      uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Run cargo update\n       run: cargo update\n@@ -63,7 +63,7 @@ jobs:\n     - name: Set LD_LIBRARY_PATH (Linux)\n       run: |\n         SYSROOT=$(rustc --print sysroot)\n-        echo \"::set-env name=LD_LIBRARY_PATH::${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\"\n+        echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n \n     - name: Build\n       run: cargo build --features deny-warnings"}, {"sha": "7509d90c6c2fcff29fee79d75c97ff54934a3e44", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -11,6 +11,10 @@ env:\n   CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n   NO_FMT_TEST: 1\n \n+defaults:\n+  run:\n+    shell: bash\n+\n jobs:\n   changelog:\n     runs-on: ubuntu-latest\n@@ -20,7 +24,7 @@ jobs:\n       with:\n         github_token: \"${{ secrets.github_token }}\"\n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n       with:\n         ref: ${{ github.ref }}\n \n@@ -81,14 +85,14 @@ jobs:\n       if: matrix.host == 'i686-unknown-linux-gnu'\n \n     - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.3\n+      uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: ${{ matrix.host }}\n         profile: minimal\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Run cargo update\n       run: cargo update\n@@ -105,14 +109,13 @@ jobs:\n       run: bash setup-toolchain.sh\n       env:\n         HOST_TOOLCHAIN: ${{ matrix.host }}\n-      shell: bash\n \n     # Run\n     - name: Set LD_LIBRARY_PATH (Linux)\n       if: runner.os == 'Linux'\n       run: |\n         SYSROOT=$(rustc --print sysroot)\n-        echo \"::set-env name=LD_LIBRARY_PATH::${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\"\n+        echo \"LD_LIBRARY_PATH=${SYSROOT}/lib${LD_LIBRARY_PATH+:${LD_LIBRARY_PATH}}\" >> $GITHUB_ENV\n     - name: Link rustc dylib (MacOS)\n       if: runner.os == 'macOS'\n       run: |\n@@ -122,41 +125,33 @@ jobs:\n     - name: Set PATH (Windows)\n       if: runner.os == 'Windows'\n       run: |\n-        $sysroot = rustc --print sysroot\n-        $env:PATH += ';' + $sysroot + '\\bin'\n-        echo \"::set-env name=PATH::$env:PATH\"\n+        SYSROOT=$(rustc --print sysroot)\n+        echo \"$SYSROOT/bin\" >> $GITHUB_PATH\n \n     - name: Build\n       run: cargo build --features deny-warnings\n-      shell: bash\n \n     - name: Test\n       run: cargo test --features deny-warnings\n-      shell: bash\n \n     - name: Test clippy_lints\n       run: cargo test --features deny-warnings\n-      shell: bash\n       working-directory: clippy_lints\n \n     - name: Test rustc_tools_util\n       run: cargo test --features deny-warnings\n-      shell: bash\n       working-directory: rustc_tools_util\n \n     - name: Test clippy_dev\n       run: cargo test --features deny-warnings\n-      shell: bash\n       working-directory: clippy_dev\n \n     - name: Test cargo-clippy\n       run: ../target/debug/cargo-clippy\n-      shell: bash\n       working-directory: clippy_workspace_tests\n \n     - name: Test clippy-driver\n       run: bash .github/driver.sh\n-      shell: bash\n       env:\n         OS: ${{ runner.os }}\n \n@@ -165,7 +160,7 @@ jobs:\n       run: |\n         cargo +nightly install cargo-cache --no-default-features --features ci-autoclean cargo-cache\n         cargo cache\n-      shell: bash\n+\n   integration_build:\n     needs: changelog\n     runs-on: ubuntu-latest\n@@ -177,14 +172,14 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.3\n+      uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Run cargo update\n       run: cargo update\n@@ -258,14 +253,14 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.3\n+      uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Run cargo update\n       run: cargo update"}, {"sha": "5ee157cf23b864bb69e792ba0705aa0d9d9779ce", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -23,15 +23,15 @@ jobs:\n     steps:\n     # Setup\n     - name: rust-toolchain\n-      uses: actions-rs/toolchain@v1.0.3\n+      uses: actions-rs/toolchain@v1.0.6\n       with:\n         toolchain: nightly\n         target: x86_64-unknown-linux-gnu\n         profile: minimal\n         components: rustfmt\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     # Run\n     - name: Build"}, {"sha": "15aeaf907dc6b9b1faa81521d9260c2b452e52e7", "filename": ".github/workflows/deploy.yml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fdeploy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fdeploy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fdeploy.yml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -21,10 +21,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n       with:\n         ref: ${{ env.TARGET_BRANCH }}\n         path: 'out'\n@@ -34,10 +34,10 @@ jobs:\n       if: startswith(github.ref, 'refs/tags/')\n       run: |\n         TAG=$(basename ${{ github.ref }})\n-        echo \"::set-env name=TAG_NAME::$TAG\"\n+        echo \"TAG_NAME=$TAG\" >> $GITHUB_ENV\n     - name: Set beta to true\n       if: github.ref == 'refs/heads/beta'\n-      run: echo \"::set-env name=BETA::true\"\n+      run: echo \"BETA=true\" >> $GITHUB_ENV\n \n     - name: Use scripts and templates from master branch\n       run: |"}, {"sha": "4f25a86b2e4df3cac0a28a61639b0d6df04d36cd", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -16,10 +16,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.0.0\n+      uses: actions/checkout@v2.3.3\n \n     - name: Setup Node.js\n-      uses: actions/setup-node@v1.1.0\n+      uses: actions/setup-node@v1.4.4\n \n     - name: Install remark\n       run: npm install remark-cli remark-lint remark-lint-maximum-line-length remark-preset-lint-recommended"}, {"sha": "d82f970b8bf20a24eb636af059bdf1ddf33516c1", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1796,6 +1796,7 @@ Released 2018-09-13\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n+[`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n@@ -1892,6 +1893,7 @@ Released 2018-09-13\n [`print_with_newline`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_with_newline\n [`println_empty_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#println_empty_string\n [`ptr_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n+[`ptr_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n [`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n [`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n [`question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#question_mark\n@@ -1917,6 +1919,7 @@ Released 2018-09-13\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n+[`result_unit_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push"}, {"sha": "6494695606c3ac1baaef871d33d52f7e9a0bc30c", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -316,8 +316,8 @@ If you have @bors permissions, you can find an overview of the available\n commands [here][homu_instructions].\n \n [triage]: https://forge.rust-lang.org/release/triage-procedure.html\n-[l-crash]: https://github.com/rust-lang/rust-clippy/labels/L-crash%20%3Aboom%3A\n-[l-bug]: https://github.com/rust-lang/rust-clippy/labels/L-bug%20%3Abeetle%3A\n+[l-crash]: https://github.com/rust-lang/rust-clippy/labels/L-crash\n+[l-bug]: https://github.com/rust-lang/rust-clippy/labels/L-bug\n [homu]: https://github.com/rust-lang/homu\n [homu_instructions]: https://buildbot2.rust-lang.org/homu/\n [homu_queue]: https://buildbot2.rust-lang.org/homu/queue/clippy"}, {"sha": "1ddcd18598dea83b4009d927cf031f9207ad7979", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -31,16 +31,14 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.212\", path = \"clippy_lints\" }\n # end automatic update\n-semver = \"0.10\"\n+semver = \"0.11\"\n rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\"}\n tempfile = { version = \"3.1.0\", optional = true }\n-lazy_static = \"1.0\"\n \n [dev-dependencies]\n-cargo_metadata = \"0.11.1\"\n+cargo_metadata = \"0.12\"\n compiletest_rs = { version = \"0.5.0\", features = [\"tmp\"] }\n tester = \"0.7\"\n-lazy_static = \"1.0\"\n clippy-mini-macro-test = { version = \"0.2\", path = \"mini-macro\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n derive-new = \"0.5\""}, {"sha": "e1b3c84d6917d0824701efce3508d0f0210c1473", "filename": "README.md", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -169,12 +169,33 @@ You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n \n Note: `deny` produces errors instead of warnings.\n \n-If you do not want to include your lint levels in your code, you can globally enable/disable lints by passing extra\n-flags to Clippy during the run: `cargo clippy -- -A clippy::lint_name` will run Clippy with `lint_name` disabled and\n-`cargo clippy -- -W clippy::lint_name` will run it with that enabled. This also works with lint groups. For example you\n-can run Clippy with warnings for all lints enabled: `cargo clippy -- -W clippy::pedantic`\n+If you do not want to include your lint levels in your code, you can globally enable/disable lints\n+by passing extra flags to Clippy during the run:\n+\n+To disable `lint_name`, run\n+\n+```terminal\n+cargo clippy -- -A clippy::lint_name\n+```\n+\n+And to enable `lint_name`, run\n+\n+```terminal\n+cargo clippy -- -W clippy::lint_name\n+```\n+\n+This also works with lint groups. For example you\n+can run Clippy with warnings for all lints enabled: \n+```terminal\n+cargo clippy -- -W clippy::pedantic\n+```\n+\n If you care only about a single lint, you can allow all others and then explicitly reenable\n-the lint(s) you are interested in: `cargo clippy -- -Aclippy::all -Wclippy::useless_format -Wclippy::...`\n+the lint(s) you are interested in:\n+```terminal\n+cargo clippy -- -A clippy::all -W clippy::useless_format -W clippy::...\n+```\n+Note that if you've run clippy before, this may only take effect after you've modified a file or ran `cargo clean`.\n \n ## Contributing\n "}, {"sha": "556b67e0b3742ec1eee0165cf5937b38d8167d9b", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -29,7 +29,7 @@ pub fn run(update_mode: UpdateMode) {\n         false,\n         update_mode == UpdateMode::Change,\n         || {\n-            format!(\"pub static ref ALL_LINTS: Vec<Lint> = vec!{:#?};\", sorted_usable_lints)\n+            format!(\"vec!{:#?}\", sorted_usable_lints)\n                 .lines()\n                 .map(ToString::to_string)\n                 .collect::<Vec<_>>()"}, {"sha": "d9471d251974456a8364698567b32ce3ee2d30a0", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -17,7 +17,7 @@ keywords = [\"clippy\", \"lint\", \"plugin\"]\n edition = \"2018\"\n \n [dependencies]\n-cargo_metadata = \"0.11.1\"\n+cargo_metadata = \"0.12\"\n if_chain = \"1.0.0\"\n itertools = \"0.9\"\n pulldown-cmark = { version = \"0.8\", default-features = false }\n@@ -27,7 +27,7 @@ serde = { version = \"1.0\", features = [\"derive\"] }\n smallvec = { version = \"1\", features = [\"union\"] }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n-semver = \"0.10.0\"\n+semver = \"0.11\"\n # NOTE: cargo requires serde feat in its url dep\n # see <https://github.com/rust-lang/rust/pull/63587#issuecomment-522343864>\n url = { version =  \"2.1.0\", features = [\"serde\"] }"}, {"sha": "c5e33b288a9c787a8f3aab6ce1950084f912ac1d", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -40,6 +40,8 @@ pub enum Constant {\n     Tuple(Vec<Constant>),\n     /// A raw pointer.\n     RawPtr(u128),\n+    /// A reference\n+    Ref(Box<Constant>),\n     /// A literal with syntax error.\n     Err(Symbol),\n }\n@@ -66,6 +68,7 @@ impl PartialEq for Constant {\n             (&Self::Bool(l), &Self::Bool(r)) => l == r,\n             (&Self::Vec(ref l), &Self::Vec(ref r)) | (&Self::Tuple(ref l), &Self::Tuple(ref r)) => l == r,\n             (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => ls == rs && lv == rv,\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => *lb == *rb,\n             // TODO: are there inter-type equalities?\n             _ => false,\n         }\n@@ -110,6 +113,9 @@ impl Hash for Constant {\n             Self::RawPtr(u) => {\n                 u.hash(state);\n             },\n+            Self::Ref(ref r) => {\n+                r.hash(state);\n+            },\n             Self::Err(ref s) => {\n                 s.hash(state);\n             },\n@@ -144,6 +150,7 @@ impl Constant {\n                     x => x,\n                 }\n             },\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n             // TODO: are there any useful inter-type orderings?\n             _ => None,\n         }\n@@ -239,7 +246,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             ExprKind::Unary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n                 UnOp::UnNot => self.constant_not(&o, self.typeck_results.expr_ty(e)),\n                 UnOp::UnNeg => self.constant_negate(&o, self.typeck_results.expr_ty(e)),\n-                UnOp::UnDeref => Some(o),\n+                UnOp::UnDeref => Some(if let Constant::Ref(r) = o { *r } else { o }),\n             }),\n             ExprKind::Binary(op, ref left, ref right) => self.binop(op, left, right),\n             ExprKind::Call(ref callee, ref args) => {\n@@ -269,6 +276,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                 }\n             },\n             ExprKind::Index(ref arr, ref index) => self.index(arr, index),\n+            ExprKind::AddrOf(_, _, ref inner) => self.expr(inner).map(|r| Constant::Ref(Box::new(r))),\n             // TODO: add other expressions.\n             _ => None,\n         }"}, {"sha": "6c969c3ead0f0631cd8c73ad45bfcda2a4b4afce", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,4 +1,4 @@\n-use crate::utils::{eq_expr_value, SpanlessEq, SpanlessHash};\n+use crate::utils::{eq_expr_value, in_macro, SpanlessEq, SpanlessHash};\n use crate::utils::{get_parent_expr, higher, if_sequence, snippet, span_lint_and_note, span_lint_and_then};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{Arm, Block, Expr, ExprKind, MatchSource, Pat, PatKind};\n@@ -220,6 +220,10 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_>, conds: &[&Expr<'_>]) {\n     };\n \n     let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n+        // Do not lint if any expr originates from a macro\n+        if in_macro(lhs.span) || in_macro(rhs.span) {\n+            return false;\n+        }\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n         if eq_expr_value(cx, lhs, rhs) {\n             return false;"}, {"sha": "07f604cf71472eee5fd55b87acef169f17237735", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -32,13 +32,26 @@ declare_clippy_lint! {\n     /// **Known problems:** Lots of bad docs won\u2019t be fixed, what the lint checks\n     /// for is limited, and there are still false positives.\n     ///\n+    /// In addition, when writing documentation comments, including `[]` brackets\n+    /// inside a link text would trip the parser. Therfore, documenting link with\n+    /// `[`SmallVec<[T; INLINE_CAPACITY]>`]` and then [`SmallVec<[T; INLINE_CAPACITY]>`]: SmallVec\n+    /// would fail.\n+    ///\n     /// **Examples:**\n     /// ```rust\n     /// /// Do something with the foo_bar parameter. See also\n     /// /// that::other::module::foo.\n     /// // ^ `foo_bar` and `that::other::module::foo` should be ticked.\n     /// fn doit(foo_bar: usize) {}\n     /// ```\n+    ///\n+    /// ```rust\n+    /// // Link text with `[]` brackets should be written as following:\n+    /// /// Consume the array and return the inner\n+    /// /// [`SmallVec<[T; INLINE_CAPACITY]>`][SmallVec].\n+    /// /// [SmallVec]: SmallVec\n+    /// fn main() {}\n+    /// ```\n     pub DOC_MARKDOWN,\n     pedantic,\n     \"presence of `_`, `::` or camel-case outside backticks in documentation\""}, {"sha": "3201adbf9a0b60147bd8dd96cdb0025e082f9cbc", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,8 +1,10 @@\n use crate::utils::{\n-    eq_expr_value, implements_trait, in_macro, is_copy, multispan_sugg, snippet, span_lint, span_lint_and_then,\n+    eq_expr_value, higher, implements_trait, in_macro, is_copy, is_expn_of, multispan_sugg, snippet, span_lint,\n+    span_lint_and_then,\n };\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind};\n+use rustc_hir::{BinOp, BinOpKind, BorrowKind, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -23,6 +25,12 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// if x + 1 == x + 1 {}\n     /// ```\n+    /// or\n+    /// ```rust\n+    /// # let a = 3;\n+    /// # let b = 4;\n+    /// assert_eq!(a, a);\n+    /// ```\n     pub EQ_OP,\n     correctness,\n     \"equal operands on both sides of a comparison or bitwise combination (e.g., `x == x`)\"\n@@ -52,9 +60,34 @@ declare_clippy_lint! {\n \n declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n+const ASSERT_MACRO_NAMES: [&str; 4] = [\"assert_eq\", \"assert_ne\", \"debug_assert_eq\", \"debug_assert_ne\"];\n+\n impl<'tcx> LateLintPass<'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Block(ref block, _) = e.kind {\n+            for stmt in block.stmts {\n+                for amn in &ASSERT_MACRO_NAMES {\n+                    if_chain! {\n+                        if is_expn_of(stmt.span, amn).is_some();\n+                        if let StmtKind::Semi(ref matchexpr) = stmt.kind;\n+                        if let Some(macro_args) = higher::extract_assert_macro_args(matchexpr);\n+                        if macro_args.len() == 2;\n+                        let (lhs, rhs) = (macro_args[0], macro_args[1]);\n+                        if eq_expr_value(cx, lhs, rhs);\n+\n+                        then {\n+                            span_lint(\n+                                cx,\n+                                EQ_OP,\n+                                lhs.span.to(rhs.span),\n+                                &format!(\"identical args used in this `{}!` macro call\", amn),\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n         if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n             if e.span.from_expansion() {\n                 return;"}, {"sha": "26da058598e4ff996ff872cc16e22e7fbdc48b77", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_expn_of, is_type_diagnostic_item, last_path_segment, match_def_path, match_function_call, snippet,\n+    is_expn_of, is_type_diagnostic_item, last_path_segment, match_def_path, match_function_call, snippet, snippet_opt,\n     span_lint_and_then,\n };\n use if_chain::if_chain;\n@@ -132,7 +132,11 @@ fn on_new_v1<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<Strin\n         then {\n             // `format!(\"foo\")` expansion contains `match () { () => [], }`\n             if tup.is_empty() {\n-                return Some(format!(\"{:?}.to_string()\", s.as_str()));\n+                if let Some(s_src) = snippet_opt(cx, lit.span) {\n+                    // Simulate macro expansion, converting {{ and }} to { and }.\n+                    let s_expand = s_src.replace(\"{{\", \"{\").replace(\"}}\", \"}\");\n+                    return Some(format!(\"{}.to_string()\", s_expand))\n+                }\n             } else if s.as_str().is_empty() {\n                 return on_argumentv1_new(cx, &tup[0], arms);\n             }"}, {"sha": "fd45a6da61ca676739dc186d933780445d8bae62", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 93, "deletions": 13, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,8 +1,9 @@\n use crate::utils::{\n-    attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, iter_input_pats, match_def_path,\n-    must_use_attr, qpath_res, return_ty, snippet, snippet_opt, span_lint, span_lint_and_help, span_lint_and_then,\n-    trait_ref_of_method, type_is_unsafe_function,\n+    attr_by_name, attrs::is_proc_macro, is_must_use_ty, is_trait_impl_item, is_type_diagnostic_item, iter_input_pats,\n+    last_path_segment, match_def_path, must_use_attr, qpath_res, return_ty, snippet, snippet_opt, span_lint,\n+    span_lint_and_help, span_lint_and_then, trait_ref_of_method, type_is_unsafe_function,\n };\n+use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -16,6 +17,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n+use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for functions with too many parameters.\n@@ -169,6 +171,52 @@ declare_clippy_lint! {\n     \"function or method that could take a `#[must_use]` attribute\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for public functions that return a `Result`\n+    /// with an `Err` type of `()`. It suggests using a custom type that\n+    /// implements [`std::error::Error`].\n+    ///\n+    /// **Why is this bad?** Unit does not implement `Error` and carries no\n+    /// further information about what went wrong.\n+    ///\n+    /// **Known problems:** Of course, this lint assumes that `Result` is used\n+    /// for a fallible operation (which is after all the intended use). However\n+    /// code may opt to (mis)use it as a basic two-variant-enum. In that case,\n+    /// the suggestion is misguided, and the code should use a custom enum\n+    /// instead.\n+    ///\n+    /// **Examples:**\n+    /// ```rust\n+    /// pub fn read_u8() -> Result<u8, ()> { Err(()) }\n+    /// ```\n+    /// should become\n+    /// ```rust,should_panic\n+    /// use std::fmt;\n+    ///\n+    /// #[derive(Debug)]\n+    /// pub struct EndOfStream;\n+    ///\n+    /// impl fmt::Display for EndOfStream {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         write!(f, \"End of Stream\")\n+    ///     }\n+    /// }\n+    ///\n+    /// impl std::error::Error for EndOfStream { }\n+    ///\n+    /// pub fn read_u8() -> Result<u8, EndOfStream> { Err(EndOfStream) }\n+    ///# fn main() {\n+    ///#     read_u8().unwrap();\n+    ///# }\n+    /// ```\n+    ///\n+    /// Note that there are crates that simplify creating the error type, e.g.\n+    /// [`thiserror`](https://docs.rs/thiserror).\n+    pub RESULT_UNIT_ERR,\n+    style,\n+    \"public function returning `Result` with an `Err` type of `()`\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Functions {\n     threshold: u64,\n@@ -188,6 +236,7 @@ impl_lint_pass!(Functions => [\n     MUST_USE_UNIT,\n     DOUBLE_MUST_USE,\n     MUST_USE_CANDIDATE,\n+    RESULT_UNIT_ERR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Functions {\n@@ -233,15 +282,16 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         let attr = must_use_attr(&item.attrs);\n         if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+            if is_public {\n+                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            }\n             if let Some(attr) = attr {\n-                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n                 check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n                 return;\n             }\n-            if cx.access_levels.is_exported(item.hir_id)\n-                && !is_proc_macro(cx.sess(), &item.attrs)\n-                && attr_by_name(&item.attrs, \"no_mangle\").is_none()\n-            {\n+            if is_public && !is_proc_macro(cx.sess(), &item.attrs) && attr_by_name(&item.attrs, \"no_mangle\").is_none() {\n                 check_must_use_candidate(\n                     cx,\n                     &sig.decl,\n@@ -257,11 +307,15 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n         if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n+            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+            if is_public && trait_ref_of_method(cx, item.hir_id).is_none() {\n+                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            }\n             let attr = must_use_attr(&item.attrs);\n             if let Some(attr) = attr {\n-                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n                 check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n-            } else if cx.access_levels.is_exported(item.hir_id)\n+            } else if is_public\n                 && !is_proc_macro(cx.sess(), &item.attrs)\n                 && trait_ref_of_method(cx, item.hir_id).is_none()\n             {\n@@ -284,18 +338,21 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n             if sig.header.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span.with_hi(sig.decl.output.span().hi()));\n             }\n+            let is_public = cx.access_levels.is_exported(item.hir_id);\n+            let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n+            if is_public {\n+                check_result_unit_err(cx, &sig.decl, item.span, fn_header_span);\n+            }\n \n             let attr = must_use_attr(&item.attrs);\n             if let Some(attr) = attr {\n-                let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n                 check_needless_must_use(cx, &sig.decl, item.hir_id, item.span, fn_header_span, attr);\n             }\n             if let hir::TraitFn::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n                 Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n \n-                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(cx.sess(), &item.attrs)\n-                {\n+                if attr.is_none() && is_public && !is_proc_macro(cx.sess(), &item.attrs) {\n                     check_must_use_candidate(\n                         cx,\n                         &sig.decl,\n@@ -411,6 +468,29 @@ impl<'tcx> Functions {\n     }\n }\n \n+fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n+    if_chain! {\n+        if !in_external_macro(cx.sess(), item_span);\n+        if let hir::FnRetTy::Return(ref ty) = decl.output;\n+        if let hir::TyKind::Path(ref qpath) = ty.kind;\n+        if is_type_diagnostic_item(cx, hir_ty_to_ty(cx.tcx, ty), sym!(result_type));\n+        if let Some(ref args) = last_path_segment(qpath).args;\n+        if let [_, hir::GenericArg::Type(ref err_ty)] = args.args;\n+        if let hir::TyKind::Tup(t) = err_ty.kind;\n+        if t.is_empty();\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                RESULT_UNIT_ERR,\n+                fn_header_span,\n+                \"this returns a `Result<_, ()>\",\n+                None,\n+                \"use a custom Error type instead\",\n+            );\n+        }\n+    }\n+}\n+\n fn check_needless_must_use(\n     cx: &LateContext<'_>,\n     decl: &hir::FnDecl<'_>,"}, {"sha": "d4d2f92a6a695c7af893688ce2a1c1b966725570", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -234,6 +234,7 @@ mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n mod manual_strip;\n+mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n mod map_identity;\n@@ -281,6 +282,7 @@ mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n+mod ptr_eq;\n mod ptr_offset_with_cast;\n mod question_mark;\n mod ranges;\n@@ -581,6 +583,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &functions::MUST_USE_CANDIDATE,\n         &functions::MUST_USE_UNIT,\n         &functions::NOT_UNSAFE_PTR_ARG_DEREF,\n+        &functions::RESULT_UNIT_ERR,\n         &functions::TOO_MANY_ARGUMENTS,\n         &functions::TOO_MANY_LINES,\n         &future_not_send::FUTURE_NOT_SEND,\n@@ -638,6 +641,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &manual_strip::MANUAL_STRIP,\n+        &manual_unwrap_or::MANUAL_UNWRAP_OR,\n         &map_clone::MAP_CLONE,\n         &map_err_ignore::MAP_ERR_IGNORE,\n         &map_identity::MAP_IDENTITY,\n@@ -778,6 +782,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ptr::CMP_NULL,\n         &ptr::MUT_FROM_REF,\n         &ptr::PTR_ARG,\n+        &ptr_eq::PTR_EQ,\n         &ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n         &question_mark::QUESTION_MARK,\n         &ranges::RANGE_MINUS_ONE,\n@@ -916,6 +921,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let verbose_bit_mask_threshold = conf.verbose_bit_mask_threshold;\n     store.register_late_pass(move || box bit_mask::BitMask::new(verbose_bit_mask_threshold));\n     store.register_late_pass(|| box ptr::Ptr);\n+    store.register_late_pass(|| box ptr_eq::PtrEq);\n     store.register_late_pass(|| box needless_bool::NeedlessBool);\n     store.register_late_pass(|| box needless_bool::BoolComparison);\n     store.register_late_pass(|| box approx_const::ApproxConstant);\n@@ -1122,6 +1128,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n     store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n+    store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n     store.register_late_pass(|| box manual_strip::ManualStrip);\n@@ -1324,6 +1331,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n         LintId::of(&functions::NOT_UNSAFE_PTR_ARG_DEREF),\n+        LintId::of(&functions::RESULT_UNIT_ERR),\n         LintId::of(&functions::TOO_MANY_ARGUMENTS),\n         LintId::of(&get_last_with_len::GET_LAST_WITH_LEN),\n         LintId::of(&identity_op::IDENTITY_OP),\n@@ -1362,6 +1370,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n+        LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -1457,6 +1466,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::CMP_NULL),\n         LintId::of(&ptr::MUT_FROM_REF),\n         LintId::of(&ptr::PTR_ARG),\n+        LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n@@ -1554,6 +1564,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&formatting::SUSPICIOUS_UNARY_OP_FORMATTING),\n         LintId::of(&functions::DOUBLE_MUST_USE),\n         LintId::of(&functions::MUST_USE_UNIT),\n+        LintId::of(&functions::RESULT_UNIT_ERR),\n         LintId::of(&if_let_some_result::IF_LET_SOME_RESULT),\n         LintId::of(&inherent_to_string::INHERENT_TO_STRING),\n         LintId::of(&len_zero::LEN_WITHOUT_IS_EMPTY),\n@@ -1611,6 +1622,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&panic_unimplemented::PANIC_PARAMS),\n         LintId::of(&ptr::CMP_NULL),\n         LintId::of(&ptr::PTR_ARG),\n+        LintId::of(&ptr_eq::PTR_EQ),\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n@@ -1654,6 +1666,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n+        LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),"}, {"sha": "63d7e3176b10ce340ac4e6c4a8327e53d48b67bd", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 437, "deletions": 201, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -5,9 +5,8 @@ use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n-    SpanlessEq,\n+    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -770,15 +769,28 @@ fn check_for_loop<'tcx>(\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n ) {\n-    check_for_loop_range(cx, pat, arg, body, expr);\n+    let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n+    if !is_manual_memcpy_triggered {\n+        check_for_loop_range(cx, pat, arg, body, expr);\n+        check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n+    }\n     check_for_loop_arg(cx, pat, arg, expr);\n-    check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n-    detect_manual_memcpy(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n+// this function assumes the given expression is a `for` loop.\n+fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n+    // for some reason this is the only way to get the `Span`\n+    // of the entire `for` loop\n+    if let ExprKind::Match(_, arms, _) = &expr.kind {\n+        arms[0].body.span\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(qpath) = &expr.kind;\n@@ -794,36 +806,131 @@ fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     }\n }\n \n-#[derive(Clone, Copy)]\n-enum OffsetSign {\n-    Positive,\n-    Negative,\n+/// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n+/// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n+/// it exists for the convenience of the overloaded operators while normal functions can do the\n+/// same.\n+#[derive(Clone)]\n+struct MinifyingSugg<'a>(Sugg<'a>);\n+\n+impl<'a> MinifyingSugg<'a> {\n+    fn as_str(&self) -> &str {\n+        let Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) = &self.0;\n+        s.as_ref()\n+    }\n+\n+    fn into_sugg(self) -> Sugg<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n+    fn from(sugg: Sugg<'a>) -> Self {\n+        Self(sugg)\n+    }\n+}\n+\n+impl std::ops::Add for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self.clone(),\n+            (_, _) => (&self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self.clone(),\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (&self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self,\n+            (_, _) => (self.0 + &rhs.0).into(),\n+        }\n+    }\n }\n \n+impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self,\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n struct Offset {\n-    value: String,\n+    value: MinifyingSugg<'static>,\n     sign: OffsetSign,\n }\n \n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n+}\n+\n impl Offset {\n-    fn negative(value: String) -> Self {\n+    fn negative(value: Sugg<'static>) -> Self {\n         Self {\n-            value,\n+            value: value.into(),\n             sign: OffsetSign::Negative,\n         }\n     }\n \n-    fn positive(value: String) -> Self {\n+    fn positive(value: Sugg<'static>) -> Self {\n         Self {\n-            value,\n+            value: value.into(),\n             sign: OffsetSign::Positive,\n         }\n     }\n+\n+    fn empty() -> Self {\n+        Self::positive(sugg::ZERO)\n+    }\n }\n \n-struct FixedOffsetVar<'hir> {\n-    var: &'hir Expr<'hir>,\n-    offset: Offset,\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n+}\n+\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n+    idx_offset: Offset,\n+}\n+\n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n@@ -846,151 +953,216 @@ fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     }\n }\n \n-fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n-    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n+fn get_details_from_idx<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn get_start<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        starts.iter().find_map(|start| {\n+            if same_var(cx, e, start.id) {\n+                Some(start.kind)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n-                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n                 _ => None,\n             },\n-            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if get_start(cx, e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n             _ => None,\n         }\n     }\n \n     match idx.kind {\n         ExprKind::Binary(op, lhs, rhs) => match op.node {\n             BinOpKind::Add => {\n-                let offset_opt = if same_var(cx, lhs, var) {\n-                    extract_offset(cx, rhs, var)\n-                } else if same_var(cx, rhs, var) {\n-                    extract_offset(cx, lhs, var)\n-                } else {\n-                    None\n-                };\n+                let offset_opt = get_start(cx, lhs, starts)\n+                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n+                    .or_else(|| get_start(cx, rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n \n-                offset_opt.map(Offset::positive)\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n+            },\n+            BinOpKind::Sub => {\n+                get_start(cx, lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n             },\n-            BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n             _ => None,\n         },\n-        ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n+        ExprKind::Path(..) => get_start(cx, idx, starts).map(|s| (s, Offset::empty())),\n         _ => None,\n     }\n }\n \n-fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n-    fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n-            Some((lhs, rhs))\n-        } else {\n-            None\n-        }\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n     }\n+}\n \n-    // This is one of few ways to return different iterators\n-    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n-    let mut iter_a = None;\n-    let mut iter_b = None;\n+/// Get assignments from the given block.\n+/// The returned iterator yields `None` if no assignment expressions are there,\n+/// filtering out the increments of the given whitelisted loop counters;\n+/// because its job is to make sure there's nothing other than assignments and the increments.\n+fn get_assignments<'a: 'c, 'tcx: 'c, 'c>(\n+    cx: &'a LateContext<'tcx>,\n+    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n+    loop_counters: &'c [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'c {\n+    // As the `filter` and `map` below do different things, I think putting together\n+    // just increases complexity. (cc #3188 and #4193)\n+    #[allow(clippy::filter_map)]\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+        })\n+        .chain((*expr).into_iter())\n+        .filter(move |e| {\n+            if let ExprKind::AssignOp(_, place, _) = e.kind {\n+                !loop_counters\n+                    .iter()\n+                    // skip the first item which should be `StartKind::Range`\n+                    // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                    .skip(1)\n+                    .any(|counter| same_var(cx, place, counter.id))\n+            } else {\n+                true\n+            }\n+        })\n+        .map(get_assignment)\n+}\n \n-    if let ExprKind::Block(b, _) = body.kind {\n-        let Block { stmts, expr, .. } = *b;\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n \n-        iter_a = stmts\n-            .iter()\n-            .filter_map(|stmt| match stmt.kind {\n-                StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n             })\n-            .chain(expr.into_iter())\n-            .map(get_assignment)\n             .into()\n-    } else {\n-        iter_b = Some(get_assignment(body))\n-    }\n-\n-    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n+    })\n }\n \n fn build_manual_memcpy_suggestion<'tcx>(\n     cx: &LateContext<'tcx>,\n     start: &Expr<'_>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n-    dst_var: FixedOffsetVar<'_>,\n-    src_var: FixedOffsetVar<'_>,\n+    dst: &IndexExpr<'_>,\n+    src: &IndexExpr<'_>,\n ) -> String {\n-    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n-        match (arg1, &arg2.value[..], arg2.sign) {\n-            (\"0\", \"0\", _) => \"0\".into(),\n-            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n-            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n-            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n-            (x, y, OffsetSign::Negative) => {\n-                if x == y {\n-                    \"0\".into()\n-                } else {\n-                    format!(\"({} - {})\", x, y)\n-                }\n-            },\n-        }\n-    }\n-\n-    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n-        let offset = print_sum(start_str, inline_offset);\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n         if offset.as_str() == \"0\" {\n-            \"\".into()\n+            sugg::EMPTY.into()\n         } else {\n             offset\n         }\n     }\n \n-    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n             if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n-            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            if var_def_id(cx, arg) == var_def_id(cx, base);\n             then {\n-                match offset.sign {\n-                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n-                    OffsetSign::Positive => \"\".into(),\n+                if sugg.as_str() == end_str {\n+                    sugg::EMPTY.into()\n+                } else {\n+                    sugg\n                 }\n             } else {\n-                let end_str = match limits {\n+                match limits {\n                     ast::RangeLimits::Closed => {\n-                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                        format!(\"{}\", end + sugg::ONE)\n+                        sugg + &sugg::ONE.into()\n                     },\n-                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                };\n-\n-                print_sum(&end_str, &offset)\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n             }\n         }\n     };\n \n-    let start_str = snippet(cx, start.span, \"\").to_string();\n-    let dst_offset = print_offset(&start_str, &dst_var.offset);\n-    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n-    let src_offset = print_offset(&start_str, &src_var.offset);\n-    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+    let start_str = Sugg::hir(cx, start, \"\").into();\n+    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            )\n+            .into_sugg(),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                )\n+                .into_sugg(),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n \n-    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n-    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n+    let src_base_str = snippet(cx, src.base.span, \"???\");\n \n-    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-        dst_var_name\n+    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n+        dst_base_str\n     } else {\n-        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n+        .into()\n     };\n \n     format!(\n-        \"{}.clone_from_slice(&{}[{}..{}])\",\n-        dst, src_var_name, src_offset, src_limit\n+        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n     )\n }\n+\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'tcx>(\n@@ -999,7 +1171,7 @@ fn detect_manual_memcpy<'tcx>(\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n-) {\n+) -> bool {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1008,32 +1180,53 @@ fn detect_manual_memcpy<'tcx>(\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            // The only statements in the for loops can be indexed assignments from\n-            // indexed retrievals.\n-            let big_sugg = get_assignments(body)\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(cx, block, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n+                // The only statements in the for loops can be indexed assignments from\n+                // indexed retrievals (except increments of loop counters).\n                 .map(|o| {\n                     o.and_then(|(lhs, rhs)| {\n                         let rhs = fetch_cloned_expr(rhs);\n                         if_chain! {\n-                            if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n-                            if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_right));\n-                            if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n-                            if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n \n                             // Source and destination must be different\n-                            if var_def_id(cx, seqexpr_left) != var_def_id(cx, seqexpr_right);\n+                            if var_def_id(cx, base_left) != var_def_id(cx, base_right);\n                             then {\n-                                Some((FixedOffsetVar { var: seqexpr_left, offset: offset_left },\n-                                    FixedOffsetVar { var: seqexpr_right, offset: offset_right }))\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n                             } else {\n                                 None\n                             }\n                         }\n                     })\n                 })\n-                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, dst, src)))\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n                 .collect::<Option<Vec<_>>>()\n                 .filter(|v| !v.is_empty())\n                 .map(|v| v.join(\"\\n    \"));\n@@ -1042,15 +1235,17 @@ fn detect_manual_memcpy<'tcx>(\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,\n-                    expr.span,\n+                    get_span_of_entire_for_loop(expr),\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,\n                     Applicability::Unspecified,\n                 );\n+                return true;\n             }\n         }\n     }\n+    false\n }\n \n // Scans the body of the for loop and determines whether lint should be given\n@@ -1533,6 +1728,9 @@ fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     }\n }\n \n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n fn check_for_loop_explicit_counter<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n@@ -1541,40 +1739,23 @@ fn check_for_loop_explicit_counter<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     // Look for variables that are incremented once per loop iteration.\n-    let mut visitor = IncrementVisitor {\n-        cx,\n-        states: FxHashMap::default(),\n-        depth: 0,\n-        done: false,\n-    };\n-    walk_expr(&mut visitor, body);\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_expr(&mut increment_visitor, body);\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n-        for (id, _) in visitor.states.iter().filter(|&(_, v)| *v == VarState::IncrOnce) {\n-            let mut visitor2 = InitializeVisitor {\n-                cx,\n-                end_expr: expr,\n-                var_id: *id,\n-                state: VarState::IncrOnce,\n-                name: None,\n-                depth: 0,\n-                past_loop: false,\n-            };\n-            walk_block(&mut visitor2, block);\n+        for id in increment_visitor.into_results() {\n+            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n+            walk_block(&mut initialize_visitor, block);\n \n-            if visitor2.state == VarState::Warn {\n-                if let Some(name) = visitor2.name {\n+            if_chain! {\n+                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if is_integer_const(cx, initializer, 0);\n+                then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    // for some reason this is the only way to get the `Span`\n-                    // of the entire `for` loop\n-                    let for_span = if let ExprKind::Match(_, arms, _) = &expr.kind {\n-                        arms[0].body.span\n-                    } else {\n-                        unreachable!()\n-                    };\n+                    let for_span = get_span_of_entire_for_loop(expr);\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -2127,26 +2308,42 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n-// incremented exactly once in the loop body, and initialized to zero\n-// at the start of the loop.\n #[derive(Debug, PartialEq)]\n-enum VarState {\n+enum IncrementVisitorVarState {\n     Initial,  // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n-    Declared, // Declared but not (yet) initialized to zero\n-    Warn,\n     DontWarn,\n }\n \n /// Scan a for loop for variables that are incremented exactly once and not used after that.\n struct IncrementVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,          // context reference\n-    states: FxHashMap<HirId, VarState>, // incremented variables\n-    depth: u32,                         // depth of conditional expressions\n+    cx: &'a LateContext<'tcx>,                          // context reference\n+    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                         // depth of conditional expressions\n     done: bool,\n }\n \n+impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            states: FxHashMap::default(),\n+            depth: 0,\n+            done: false,\n+        }\n+    }\n+\n+    fn into_results(self) -> impl Iterator<Item = HirId> {\n+        self.states.into_iter().filter_map(|(id, state)| {\n+            if state == IncrementVisitorVarState::IncrOnce {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -2158,85 +2355,118 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n         // If node is a variable\n         if let Some(def_id) = var_def_id(self.cx, expr) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                let state = self.states.entry(def_id).or_insert(VarState::Initial);\n-                if *state == VarState::IncrOnce {\n-                    *state = VarState::DontWarn;\n+                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n+                if *state == IncrementVisitorVarState::IncrOnce {\n+                    *state = IncrementVisitorVarState::DontWarn;\n                     return;\n                 }\n \n                 match parent.kind {\n                     ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.hir_id == expr.hir_id {\n-                            if op.node == BinOpKind::Add && is_integer_const(self.cx, rhs, 1) {\n-                                *state = match *state {\n-                                    VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n-                                    _ => VarState::DontWarn,\n-                                };\n+                            *state = if op.node == BinOpKind::Add\n+                                && is_integer_const(self.cx, rhs, 1)\n+                                && *state == IncrementVisitorVarState::Initial\n+                                && self.depth == 0\n+                            {\n+                                IncrementVisitorVarState::IncrOnce\n                             } else {\n-                                // Assigned some other value\n-                                *state = VarState::DontWarn;\n-                            }\n+                                // Assigned some other value or assigned multiple times\n+                                IncrementVisitorVarState::DontWarn\n+                            };\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        *state = VarState::DontWarn\n+                        *state = IncrementVisitorVarState::DontWarn\n                     },\n                     _ => (),\n                 }\n             }\n+\n+            walk_expr(self, expr);\n         } else if is_loop(expr) || is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n-            return;\n         } else if let ExprKind::Continue(_) = expr.kind {\n             self.done = true;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n }\n \n-/// Checks whether a variable is initialized to zero at the start of a loop.\n+enum InitializeVisitorState<'hir> {\n+    Initial,          // Not examined yet\n+    Declared(Symbol), // Declared but not (yet) initialized\n+    Initialized {\n+        name: Symbol,\n+        initializer: &'hir Expr<'hir>,\n+    },\n+    DontWarn,\n+}\n+\n+/// Checks whether a variable is initialized at the start of a loop and not modified\n+/// and used after the loop.\n struct InitializeVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,  // context reference\n     end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n     var_id: HirId,\n-    state: VarState,\n-    name: Option<Symbol>,\n+    state: InitializeVisitorState<'tcx>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n \n+impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            end_expr,\n+            var_id,\n+            state: InitializeVisitorState::Initial,\n+            depth: 0,\n+            past_loop: false,\n+        }\n+    }\n+\n+    fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n+            Some((name, initializer))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         // Look for declarations of the variable\n-        if let StmtKind::Local(ref local) = stmt.kind {\n-            if local.pat.hir_id == self.var_id {\n-                if let PatKind::Binding(.., ident, _) = local.pat.kind {\n-                    self.name = Some(ident.name);\n-\n-                    self.state = local.init.as_ref().map_or(VarState::Declared, |init| {\n-                        if is_integer_const(&self.cx, init, 0) {\n-                            VarState::Warn\n-                        } else {\n-                            VarState::Declared\n-                        }\n-                    })\n-                }\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if local.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            then {\n+                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                    InitializeVisitorState::Initialized {\n+                        initializer: init,\n+                        name: ident.name,\n+                    }\n+                })\n             }\n         }\n         walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.state == VarState::DontWarn {\n+        if matches!(self.state, InitializeVisitorState::DontWarn) {\n             return;\n         }\n         if expr.hir_id == self.end_expr.hir_id {\n@@ -2245,45 +2475,51 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         }\n         // No need to visit expressions before the variable is\n         // declared\n-        if self.state == VarState::IncrOnce {\n+        if matches!(self.state, InitializeVisitorState::Initial) {\n             return;\n         }\n \n         // If node is the desired variable, see how it's used\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n+            if self.past_loop {\n+                self.state = InitializeVisitorState::DontWarn;\n+                return;\n+            }\n+\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.kind {\n                     ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = VarState::DontWarn;\n+                        self.state = InitializeVisitorState::DontWarn;\n                     },\n                     ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = if is_integer_const(&self.cx, rhs, 0) && self.depth == 0 {\n-                            VarState::Warn\n-                        } else {\n-                            VarState::DontWarn\n+                        self.state = if_chain! {\n+                            if self.depth == 0;\n+                            if let InitializeVisitorState::Declared(name)\n+                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n+                            then {\n+                                InitializeVisitorState::Initialized { initializer: rhs, name }\n+                            } else {\n+                                InitializeVisitorState::DontWarn\n+                            }\n                         }\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        self.state = VarState::DontWarn\n+                        self.state = InitializeVisitorState::DontWarn\n                     },\n                     _ => (),\n                 }\n             }\n \n-            if self.past_loop {\n-                self.state = VarState::DontWarn;\n-                return;\n-            }\n+            walk_expr(self, expr);\n         } else if !self.past_loop && is_loop(expr) {\n-            self.state = VarState::DontWarn;\n-            return;\n+            self.state = InitializeVisitorState::DontWarn;\n         } else if is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "ddb8cc25077e177bc3420f09a0e476799ab02e18", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,104 @@\n+use crate::consts::constant_simple;\n+use crate::utils;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_lint::LintContext;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// match foo {\n+    ///     Some(v) => v,\n+    ///     None => 1,\n+    /// };\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.unwrap_or(1);\n+    /// ```\n+    pub MANUAL_UNWRAP_OR,\n+    complexity,\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+}\n+\n+declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n+\n+impl LateLintPass<'_> for ManualUnwrapOr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+        lint_option_unwrap_or_case(cx, expr);\n+    }\n+}\n+\n+fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+        if_chain! {\n+            if arms.len() == 2;\n+            if arms.iter().all(|arm| arm.guard.is_none());\n+            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                if let PatKind::Path(ref qpath) = arm.pat.kind {\n+                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n+                } else {\n+                    false\n+                }\n+            );\n+            let some_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n+            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            if let def::Res::Local(body_path_hir_id) = body_path.res;\n+            if body_path_hir_id == binding_hir_id;\n+            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            then {\n+                Some(none_arm)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n+        let ty = cx.typeck_results().expr_ty(scrutinee);\n+        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n+        if let Some(none_arm) = applicable_none_arm(match_arms);\n+        if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n+        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(indent) = utils::indent_of(cx, expr.span);\n+        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        then {\n+            let reindented_none_body =\n+                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            utils::span_lint_and_sugg(\n+                cx,\n+                MANUAL_UNWRAP_OR, expr.span,\n+                \"this pattern reimplements `Option::unwrap_or`\",\n+                \"replace with\",\n+                format!(\n+                    \"{}.unwrap_or({})\",\n+                    scrutinee_snippet,\n+                    reindented_none_body,\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "4525b12689fa76cba77811b0d876180d671b4913", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::{match_def_path, paths, span_lint, trait_ref_of_method};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -120,7 +121,11 @@ fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bo\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0) && is_mutable_type(cx, inner_ty, span)\n         },\n         Tuple(..) => ty.tuple_fields().any(|ty| is_mutable_type(cx, ty, span)),\n-        Adt(..) => cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(span), cx.param_env),\n+        Adt(..) => {\n+            cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                && !ty.has_escaping_bound_vars()\n+                && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+        },\n         _ => false,\n     }\n }"}, {"sha": "76417aa7ed09d39682788314a61b2213c05ec0b9", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 11, "deletions": 55, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,7 +1,6 @@\n-use crate::utils::{is_direct_expn_of, span_lint};\n-use if_chain::if_chain;\n+use crate::utils::{higher, is_direct_expn_of, span_lint};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability, StmtKind, UnOp};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, MatchSource, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n@@ -39,66 +38,23 @@ impl<'tcx> LateLintPass<'tcx> for DebugAssertWithMutCall {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         for dmn in &DEBUG_MACRO_NAMES {\n             if is_direct_expn_of(e.span, dmn).is_some() {\n-                if let Some(span) = extract_call(cx, e) {\n-                    span_lint(\n-                        cx,\n-                        DEBUG_ASSERT_WITH_MUT_CALL,\n-                        span,\n-                        &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-//HACK(hellow554): remove this when #4694 is implemented\n-fn extract_call<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> Option<Span> {\n-    if_chain! {\n-        if let ExprKind::Block(ref block, _) = e.kind;\n-        if block.stmts.len() == 1;\n-        if let StmtKind::Semi(ref matchexpr) = block.stmts[0].kind;\n-        then {\n-            // debug_assert\n-            if_chain! {\n-                if let ExprKind::Match(ref ifclause, _, _) = matchexpr.kind;\n-                if let ExprKind::DropTemps(ref droptmp) = ifclause.kind;\n-                if let ExprKind::Unary(UnOp::UnNot, ref condition) = droptmp.kind;\n-                then {\n-                    let mut visitor = MutArgVisitor::new(cx);\n-                    visitor.visit_expr(condition);\n-                    return visitor.expr_span();\n-                }\n-            }\n-\n-            // debug_assert_{eq,ne}\n-            if_chain! {\n-                if let ExprKind::Block(ref matchblock, _) = matchexpr.kind;\n-                if let Some(ref matchheader) = matchblock.expr;\n-                if let ExprKind::Match(ref headerexpr, _, _) = matchheader.kind;\n-                if let ExprKind::Tup(ref conditions) = headerexpr.kind;\n-                if conditions.len() == 2;\n-                then {\n-                    if let ExprKind::AddrOf(BorrowKind::Ref, _, ref lhs) = conditions[0].kind {\n+                if let Some(macro_args) = higher::extract_assert_macro_args(e) {\n+                    for arg in macro_args {\n                         let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(lhs);\n+                        visitor.visit_expr(arg);\n                         if let Some(span) = visitor.expr_span() {\n-                            return Some(span);\n-                        }\n-                    }\n-                    if let ExprKind::AddrOf(BorrowKind::Ref, _, ref rhs) = conditions[1].kind {\n-                        let mut visitor = MutArgVisitor::new(cx);\n-                        visitor.visit_expr(rhs);\n-                        if let Some(span) = visitor.expr_span() {\n-                            return Some(span);\n+                            span_lint(\n+                                cx,\n+                                DEBUG_ASSERT_WITH_MUT_CALL,\n+                                span,\n+                                &format!(\"do not call a function with mutable arguments inside of `{}!`\", dmn),\n+                            );\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-\n-    None\n }\n \n struct MutArgVisitor<'a, 'tcx> {"}, {"sha": "eb7624b25a3c994a0c1ffdbbd16f29963f3c8a55", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 5, "deletions": 54, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -5,22 +5,20 @@ use crate::utils::{is_type_diagnostic_item, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n \n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n+    /// Lints usage of `if let Some(v) = ... { y } else { x }` which is more\n     /// idiomatically done with `Option::map_or` (if the else bit is a pure\n     /// expression) or `Option::map_or_else` (if the else bit is an impure\n-    /// expresion).\n+    /// expression).\n     ///\n     /// **Why is this bad?**\n     /// Using the dedicated functions of the Option type is clearer and\n-    /// more concise than an if let expression.\n+    /// more concise than an `if let` expression.\n     ///\n     /// **Known problems:**\n     /// This lint uses a deliberately conservative metric for checking\n@@ -84,53 +82,6 @@ struct OptionIfLetElseOccurence {\n     wrap_braces: bool,\n }\n \n-struct ReturnBreakContinueMacroVisitor {\n-    seen_return_break_continue: bool,\n-}\n-\n-impl ReturnBreakContinueMacroVisitor {\n-    fn new() -> ReturnBreakContinueMacroVisitor {\n-        ReturnBreakContinueMacroVisitor {\n-            seen_return_break_continue: false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n-    type Map = Map<'tcx>;\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if self.seen_return_break_continue {\n-            // No need to look farther if we've already seen one of them\n-            return;\n-        }\n-        match &ex.kind {\n-            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n-                self.seen_return_break_continue = true;\n-            },\n-            // Something special could be done here to handle while or for loop\n-            // desugaring, as this will detect a break if there's a while loop\n-            // or a for loop inside the expression.\n-            _ => {\n-                if utils::in_macro(ex.span) {\n-                    self.seen_return_break_continue = true;\n-                } else {\n-                    rustc_hir::intravisit::walk_expr(self, ex);\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n-    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n-    recursive_visitor.visit_expr(expression);\n-    recursive_visitor.seen_return_break_continue\n-}\n-\n /// Extracts the body of a given arm. If the arm contains only an expression,\n /// then it returns the expression. Otherwise, it returns the entire block\n fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n@@ -208,8 +159,8 @@ fn detect_option_if_let_else<'tcx>(\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n         if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if !utils::usage::contains_return_break_continue_macro(arms[0].body);\n+        if !utils::usage::contains_return_break_continue_macro(arms[1].body);\n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_arm(&arms[0])?;"}, {"sha": "3be792ce5e4fa5c3bed6da95be0393a11e3892fa", "filename": "clippy_lints/src/ptr_eq.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_eq.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,96 @@\n+use crate::utils;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Use `std::ptr::eq` when applicable\n+    ///\n+    /// **Why is this bad?** `ptr::eq` can be used to compare `&T` references\n+    /// (which coerce to `*const T` implicitly) by their address rather than\n+    /// comparing the values they point to.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(a as *const _ as usize == b as *const _ as usize);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let a = &[1, 2, 3];\n+    /// let b = &[1, 2, 3];\n+    ///\n+    /// assert!(std::ptr::eq(a, b));\n+    /// ```\n+    pub PTR_EQ,\n+    style,\n+    \"use `std::ptr::eq` when comparing raw pointers\"\n+}\n+\n+declare_lint_pass!(PtrEq => [PTR_EQ]);\n+\n+static LINT_MSG: &str = \"use `std::ptr::eq` when comparing raw pointers\";\n+\n+impl LateLintPass<'_> for PtrEq {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if utils::in_macro(expr.span) {\n+            return;\n+        }\n+\n+        if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind {\n+            if BinOpKind::Eq == op.node {\n+                let (left, right) = match (expr_as_cast_to_usize(cx, left), expr_as_cast_to_usize(cx, right)) {\n+                    (Some(lhs), Some(rhs)) => (lhs, rhs),\n+                    _ => (&**left, &**right),\n+                };\n+\n+                if_chain! {\n+                    if let Some(left_var) = expr_as_cast_to_raw_pointer(cx, left);\n+                    if let Some(right_var) = expr_as_cast_to_raw_pointer(cx, right);\n+                    if let Some(left_snip) = utils::snippet_opt(cx, left_var.span);\n+                    if let Some(right_snip) = utils::snippet_opt(cx, right_var.span);\n+                    then {\n+                        utils::span_lint_and_sugg(\n+                            cx,\n+                            PTR_EQ,\n+                            expr.span,\n+                            LINT_MSG,\n+                            \"try\",\n+                            format!(\"std::ptr::eq({}, {})\", left_snip, right_snip),\n+                            Applicability::MachineApplicable,\n+                            );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// If the given expression is a cast to an usize, return the lhs of the cast\n+// E.g., `foo as *const _ as usize` returns `foo as *const _`.\n+fn expr_as_cast_to_usize<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr) == cx.tcx.types.usize {\n+        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}\n+\n+// If the given expression is a cast to a `*const` pointer, return the lhs of the cast\n+// E.g., `foo as *const _` returns `foo`.\n+fn expr_as_cast_to_raw_pointer<'tcx>(cx: &LateContext<'tcx>, cast_expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if cx.typeck_results().expr_ty(cast_expr).is_unsafe_ptr() {\n+        if let ExprKind::Cast(ref expr, _) = cast_expr.kind {\n+            return Some(expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "47c650ac27d4c08cc594347789d2a8962de706bb", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -98,7 +98,11 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:**\n+    /// - `mem::transmute` in statics and constants is stable from Rust 1.46.0,\n+    /// while dereferencing raw pointer is not stable yet.\n+    /// If you need to do this in those places,\n+    /// you would have to use `transmute` instead.\n     ///\n     /// **Example:**\n     /// ```rust,ignore"}, {"sha": "c2c86aa474adc71d13047f757aac8ce795ed09e0", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -14,6 +14,7 @@ use rustc_span::Span;\n use rustc_target::abi::LayoutOf;\n use rustc_target::spec::Target;\n use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::Target;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for functions taking arguments by reference, where"}, {"sha": "9a948af8bfc4edd84ac222013149cfab77bd00e2", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -17,6 +17,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, InferTy, Ty, TyCtxt, TyS, TypeckResults};\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -541,6 +542,7 @@ impl Types {\n                                 _ => None,\n                             });\n                             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n+                            if !ty_ty.has_escaping_bound_vars();\n                             if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n                             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n                             if ty_ty_size <= self.vec_box_size_threshold;"}, {"sha": "4ceea13df377dc94db255feeb5bb543a16a112ce", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -82,7 +82,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n /// Identify some potentially computationally expensive patterns.\n /// This function is named so to stress that its implementation is non-exhaustive.\n /// It returns FNs and FPs.\n-fn identify_some_potentially_expensive_patterns<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     // Searches an expression for method calls or function calls that aren't ctors\n     struct FunCallFinder<'a, 'tcx> {\n         cx: &'a LateContext<'tcx>,"}, {"sha": "6d7c5058b4f30eee27114d4b532dec5e2a690af2", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -7,6 +7,7 @@ use crate::utils::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_hir as hir;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n use rustc_lint::LateContext;\n \n /// Converts a hir binary operator to the corresponding `ast` type.\n@@ -241,3 +242,56 @@ pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<Ve\n \n     None\n }\n+\n+/// Extract args from an assert-like macro.\n+/// Currently working with:\n+/// - `assert!`, `assert_eq!` and `assert_ne!`\n+/// - `debug_assert!`, `debug_assert_eq!` and `debug_assert_ne!`\n+/// For example:\n+/// `assert!(expr)` will return Some([expr])\n+/// `debug_assert_eq!(a, b)` will return Some([a, b])\n+pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx Expr<'tcx>>> {\n+    /// Try to match the AST for a pattern that contains a match, for example when two args are\n+    /// compared\n+    fn ast_matchblock(matchblock_expr: &'tcx Expr<'tcx>) -> Option<Vec<&Expr<'_>>> {\n+        if_chain! {\n+            if let ExprKind::Match(ref headerexpr, _, _) = &matchblock_expr.kind;\n+            if let ExprKind::Tup([lhs, rhs]) = &headerexpr.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, lhs) = lhs.kind;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, _, rhs) = rhs.kind;\n+            then {\n+                return Some(vec![lhs, rhs]);\n+            }\n+        }\n+        None\n+    }\n+\n+    if let ExprKind::Block(ref block, _) = e.kind {\n+        if block.stmts.len() == 1 {\n+            if let StmtKind::Semi(ref matchexpr) = block.stmts[0].kind {\n+                // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n+                if_chain! {\n+                    if let ExprKind::Match(ref ifclause, _, _) = matchexpr.kind;\n+                    if let ExprKind::DropTemps(ref droptmp) = ifclause.kind;\n+                    if let ExprKind::Unary(UnOp::UnNot, condition) = droptmp.kind;\n+                    then {\n+                        return Some(vec![condition]);\n+                    }\n+                }\n+\n+                // debug macros with two args: `debug_assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n+                if_chain! {\n+                    if let ExprKind::Block(ref matchblock,_) = matchexpr.kind;\n+                    if let Some(ref matchblock_expr) = matchblock.expr;\n+                    then {\n+                        return ast_matchblock(matchblock_expr);\n+                    }\n+                }\n+            }\n+        } else if let Some(matchblock_expr) = block.expr {\n+            // macros with two args: `assert_{ne, eq}` (e.g., `assert_ne!(a, b)`)\n+            return ast_matchblock(&matchblock_expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "a9d26d48b1278db3861c164dcf581f32190bad4c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -708,7 +708,7 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext<'_>, e: &Expr<'_>) -> Option<&'c Expr<'c>> {\n+pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n     let parent_id = map.get_parent_node(hir_id);"}, {"sha": "625120b880eb50f3f94fea5e21fc44894fd5bcc3", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -13,8 +13,10 @@ use rustc_span::{BytePos, Pos};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n+use std::ops::{Add, Neg, Not, Sub};\n \n /// A helper type to build suggestion correctly handling parenthesis.\n+#[derive(Clone, PartialEq)]\n pub enum Sugg<'a> {\n     /// An expression that never needs parenthesis such as `1337` or `[0; 42]`.\n     NonParen(Cow<'a, str>),\n@@ -25,8 +27,12 @@ pub enum Sugg<'a> {\n     BinOp(AssocOp, Cow<'a, str>),\n }\n \n+/// Literal constant `0`, for convenience.\n+pub const ZERO: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"0\"));\n /// Literal constant `1`, for convenience.\n pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n+/// a constant represents an empty string, for convenience.\n+pub const EMPTY: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"\"));\n \n impl Display for Sugg<'_> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n@@ -269,21 +275,60 @@ impl<'a> Sugg<'a> {\n     }\n }\n \n-impl<'a, 'b> std::ops::Add<Sugg<'b>> for Sugg<'a> {\n+// Copied from the rust standart library, and then edited\n+macro_rules! forward_binop_impls_to_ref {\n+    (impl $imp:ident, $method:ident for $t:ty, type Output = $o:ty) => {\n+        impl $imp<$t> for &$t {\n+            type Output = $o;\n+\n+            fn $method(self, other: $t) -> $o {\n+                $imp::$method(self, &other)\n+            }\n+        }\n+\n+        impl $imp<&$t> for $t {\n+            type Output = $o;\n+\n+            fn $method(self, other: &$t) -> $o {\n+                $imp::$method(&self, other)\n+            }\n+        }\n+\n+        impl $imp for $t {\n+            type Output = $o;\n+\n+            fn $method(self, other: $t) -> $o {\n+                $imp::$method(&self, &other)\n+            }\n+        }\n+    };\n+}\n+\n+impl Add for &Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn add(self, rhs: Sugg<'b>) -> Sugg<'static> {\n-        make_binop(ast::BinOpKind::Add, &self, &rhs)\n+    fn add(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Add, self, rhs)\n     }\n }\n \n-impl<'a, 'b> std::ops::Sub<Sugg<'b>> for Sugg<'a> {\n+impl Sub for &Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, self, rhs)\n+    }\n+}\n+\n+forward_binop_impls_to_ref!(impl Add, add for Sugg<'_>, type Output = Sugg<'static>);\n+forward_binop_impls_to_ref!(impl Sub, sub for Sugg<'_>, type Output = Sugg<'static>);\n+\n+impl Neg for Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn sub(self, rhs: Sugg<'b>) -> Sugg<'static> {\n-        make_binop(ast::BinOpKind::Sub, &self, &rhs)\n+    fn neg(self) -> Sugg<'static> {\n+        make_unop(\"-\", self)\n     }\n }\n \n-impl<'a> std::ops::Not for Sugg<'a> {\n+impl Not for Sugg<'_> {\n     type Output = Sugg<'static>;\n     fn not(self) -> Sugg<'static> {\n         make_unop(\"!\", self)"}, {"sha": "2fd6046ebcf5a65401dc425f2d2229eca593590b", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,10 +1,11 @@\n+use crate::utils;\n use crate::utils::match_var;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, HirId, Path};\n+use rustc_hir::{Expr, ExprKind, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -174,3 +175,50 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n         intravisit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n+\n+struct ReturnBreakContinueMacroVisitor {\n+    seen_return_break_continue: bool,\n+}\n+\n+impl ReturnBreakContinueMacroVisitor {\n+    fn new() -> ReturnBreakContinueMacroVisitor {\n+        ReturnBreakContinueMacroVisitor {\n+            seen_return_break_continue: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                if utils::in_macro(ex.span) {\n+                    self.seen_return_break_continue = true;\n+                } else {\n+                    rustc_hir::intravisit::walk_expr(self, ex);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}"}, {"sha": "2572833b8debfc0337820cc769595e1b84c98a36", "filename": "doc/adding_lints.md", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -104,7 +104,8 @@ every time before running `tests/ui/update-all-references.sh`.\n Running `TESTNAME=foo_functions cargo uitest` should pass then. When we commit\n our lint, we need to commit the generated `.stderr` files, too. In general, you\n should only commit files changed by `tests/ui/update-all-references.sh` for the\n-specific lint you are creating/editing.\n+specific lint you are creating/editing. Note that if the generated files are\n+empty, they should be removed.\n \n ### Cargo lints\n \n@@ -224,6 +225,17 @@ automate everything. We will have to register our lint pass manually in the\n store.register_early_pass(|| box foo_functions::FooFunctions);\n ```\n \n+As one may expect, there is a corresponding `register_late_pass` method\n+available as well. Without a call to one of `register_early_pass` or \n+`register_late_pass`, the lint pass in question will not be run.\n+\n+One reason that `cargo dev` does not automate this step is that multiple lints \n+can use the same lint pass, so registering the lint pass may already be done\n+when adding a new lint. Another reason that this step is not automated is that\n+the order that the passes are registered determines the order the passes \n+actually run, which in turn affects the order that any emitted lints are output\n+in.\n+\n [declare_clippy_lint]: https://github.com/rust-lang/rust-clippy/blob/557f6848bd5b7183f55c1e1522a326e9e1df6030/clippy_lints/src/lib.rs#L60\n [example_lint_page]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n [lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n@@ -453,12 +465,12 @@ Before submitting your PR make sure you followed all of the basic requirements:\n \n <!-- Sync this with `.github/PULL_REQUEST_TEMPLATE` -->\n \n-- [ ] Followed [lint naming conventions][lint_naming]\n-- [ ] Added passing UI tests (including committed `.stderr` file)\n-- [ ] `cargo test` passes locally\n-- [ ] Executed `cargo dev update_lints`\n-- [ ] Added lint documentation\n-- [ ] Run `cargo dev fmt`\n+- \\[ ] Followed [lint naming conventions][lint_naming]\n+- \\[ ] Added passing UI tests (including committed `.stderr` file)\n+- \\[ ] `cargo test` passes locally\n+- \\[ ] Executed `cargo dev update_lints`\n+- \\[ ] Added lint documentation\n+- \\[ ] Run `cargo dev fmt`\n \n ## Cheatsheet\n "}, {"sha": "15f3d1f080604d7286cf870a66569b9f123e287d", "filename": "doc/backport.md", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fbackport.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fbackport.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbackport.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -5,7 +5,7 @@ Backports in Clippy are rare and should be approved by the Clippy team. For\n example, a backport is done, if a crucial ICE was fixed or a lint is broken to a\n point, that it has to be disabled, before landing on stable.\n \n-Backports are done to the `beta` release of Clippy. Backports to stable Clippy\n+Backports are done to the `beta` branch of Clippy. Backports to stable Clippy\n releases basically don't exist, since this would require a Rust point release,\n which is almost never justifiable for a Clippy fix.\n \n@@ -18,7 +18,31 @@ Backports are done on the beta branch of the Clippy repository.\n # Assuming the current directory corresponds to the Clippy repository\n $ git checkout beta\n $ git checkout -b backport\n-$ git cherry-pick <SHA>  # `<SHA>` is the commit hash of the commit, that should be backported\n+$ git cherry-pick <SHA>  # `<SHA>` is the commit hash of the commit(s), that should be backported\n+$ git push origin backport\n+```\n+\n+Now you should test that the backport passes all the tests in the Rust\n+repository. You can do this with:\n+\n+```bash\n+# Assuming the current directory corresponds to the Rust repository\n+$ git checkout beta\n+$ git subtree pull -p src/tools/clippy https://github.com/<your-github-name>/rust-clippy backport\n+$ ./x.py test src/tools/clippy\n+```\n+\n+Should the test fail, you can fix Clippy directly in the Rust repository. This\n+has to be first applied to the Clippy beta branch and then again synced to the\n+Rust repository, though. The easiest way to do this is:\n+\n+```bash\n+# In the Rust repository\n+$ git diff --patch --relative=src/tools/clippy > clippy.patch\n+# In the Clippy repository\n+$ git apply /path/to/clippy.patch\n+$ git add -u\n+$ git commit -m \"Fix rustup fallout\"\n $ git push origin backport\n ```\n \n@@ -29,22 +53,19 @@ After this, you can open a PR to the `beta` branch of the Clippy repository.\n \n This step must be done, **after** the PR of the previous step was merged.\n \n-After the backport landed in the Clippy repository, also the Clippy version on\n-the Rust `beta` branch has to be updated.\n+After the backport landed in the Clippy repository, the branch has to be synced\n+back to the beta branch of the Rust repository.\n \n ```bash\n # Assuming the current directory corresponds to the Rust repository\n $ git checkout beta\n $ git checkout -b clippy_backport\n-$ pushd src/tools/clippy\n-$ git fetch\n-$ git checkout beta\n-$ popd\n-$ git add src/tools/clippy\n-\u00a7 git commit -m \"Update Clippy\"\n+$ git subtree pull -p src/tools/clippy https://github.com/rust-lang/rust-clippy beta\n $ git push origin clippy_backport\n ```\n \n-After this you can open a PR to the `beta` branch of the Rust repository. In\n-this PR you should tag the Clippy team member, that agreed to the backport or\n-the `@rust-lang/clippy` team. Make sure to add `[beta]` to the title of the PR.\n+Make sure to test the backport in the Rust repository before opening a PR. This\n+is done with `./x.py test src/tools/clippy`. If that passes all tests, open a PR\n+to the `beta` branch of the Rust repository. In this PR you should tag the\n+Clippy team member, that agreed to the backport or the `@rust-lang/clippy` team.\n+Make sure to add `[beta]` to the title of the PR."}, {"sha": "f25edb793e26dc89fb992f19ecfa19858f8f0f06", "filename": "doc/basics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -46,7 +46,7 @@ this toolchain, you can just use the `setup-toolchain.sh` script or use\n `rustup-toolchain-install-master`:\n \n ```bash\n-sh setup-toolchain.sh\n+bash setup-toolchain.sh\n # OR\n cargo install rustup-toolchain-install-master\n # For better IDE integration also add `-c rustfmt -c rust-src` (optional)"}, {"sha": "d56079a4ab735f4eab65e36de5ae65270f3c7864", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -45,11 +45,13 @@ Similarly in [`TypeckResults`][TypeckResults] methods, you have the [`pat_ty()`]\n to retrieve a type from a pattern.\n \n Two noticeable items here:\n-- `cx` is the lint context [`LateContext`][LateContext].\n-  The two most useful data structures in this context are `tcx` and `tables`,\n-  allowing us to jump to type definitions and other compilation stages such as HIR.\n-- `tables` is [`TypeckResults`][TypeckResults] and is created by type checking step,\n-  it includes useful information such as types of expressions, ways to resolve methods and so on.\n+- `cx` is the lint context [`LateContext`][LateContext]. The two most useful\n+  data structures in this context are `tcx` and the `TypeckResults` returned by\n+  `LateContext::typeck_results`, allowing us to jump to type definitions and\n+  other compilation stages such as HIR.\n+- `typeck_results`'s return value is [`TypeckResults`][TypeckResults] and is\n+  created by type checking step, it includes useful information such as types\n+  of expressions, ways to resolve methods and so on.\n \n # Checking if an expr is calling a specific method\n "}, {"sha": "eaa6a9af277d245788a5da2ab952929f15188ca4", "filename": "doc/release.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/doc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frelease.md?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -68,7 +68,7 @@ be updated.\n ```bash\n # Assuming the current directory corresponds to the Clippy repository\n $ git checkout beta\n-$ git rebase $BETA_SHA\n+$ git reset --hard $BETA_SHA\n $ git push upstream beta\n ```\n "}, {"sha": "cc71cc66b925b1ebb876fa1793afa57bb570401b", "filename": "src/driver.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,4 +1,5 @@\n #![feature(rustc_private)]\n+#![feature(once_cell)]\n #![cfg_attr(feature = \"deny-warnings\", deny(warnings))]\n // warn on lints, that are included in `rust-lang/rust`s bootstrap\n #![warn(rust_2018_idioms, unused_lifetimes)]\n@@ -17,9 +18,9 @@ use rustc_interface::interface;\n use rustc_middle::ty::TyCtxt;\n use rustc_tools_util::VersionInfo;\n \n-use lazy_static::lazy_static;\n use std::borrow::Cow;\n use std::env;\n+use std::lazy::SyncLazy;\n use std::ops::Deref;\n use std::panic;\n use std::path::{Path, PathBuf};\n@@ -230,13 +231,11 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-lazy_static! {\n-    static ref ICE_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n-        hook\n-    };\n-}\n+static ICE_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> = SyncLazy::new(|| {\n+    let hook = panic::take_hook();\n+    panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n+    hook\n+});\n \n fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Invoke our ICE handler, which prints the actual panic message and optionally a backtrace\n@@ -295,7 +294,7 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n \n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n-    lazy_static::initialize(&ICE_HOOK);\n+    SyncLazy::force(&ICE_HOOK);\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n "}, {"sha": "6301d623a2b12955c92a29c9afcf13bbb2deff51", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,15 +1,16 @@\n-//! This file is managed by `cargo dev update_lints`. Do not edit.\n+//! This file is managed by `cargo dev update_lints`. Do not edit or format this file.\n \n-use lazy_static::lazy_static;\n+use std::lazy::SyncLazy;\n \n pub mod lint;\n pub use lint::Level;\n pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n-lazy_static! {\n+#[rustfmt::skip]\n+pub static ALL_LINTS: SyncLazy<Vec<Lint>> = SyncLazy::new(|| {\n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub static ref ALL_LINTS: Vec<Lint> = vec![\n+vec![\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -1179,6 +1180,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"swap\",\n     },\n+    Lint {\n+        name: \"manual_unwrap_or\",\n+        group: \"complexity\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        deprecation: None,\n+        module: \"manual_unwrap_or\",\n+    },\n     Lint {\n         name: \"many_single_char_names\",\n         group: \"style\",\n@@ -1844,6 +1852,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"ptr\",\n     },\n+    Lint {\n+        name: \"ptr_eq\",\n+        group: \"style\",\n+        desc: \"use `std::ptr::eq` when comparing raw pointers\",\n+        deprecation: None,\n+        module: \"ptr_eq\",\n+    },\n     Lint {\n         name: \"ptr_offset_with_cast\",\n         group: \"complexity\",\n@@ -1998,6 +2013,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"map_unit_fn\",\n     },\n+    Lint {\n+        name: \"result_unit_err\",\n+        group: \"style\",\n+        desc: \"public function returning `Result` with an `Err` type of `()`\",\n+        deprecation: None,\n+        module: \"functions\",\n+    },\n     Lint {\n         name: \"reversed_empty_ranges\",\n         group: \"correctness\",\n@@ -2817,6 +2839,6 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n-];\n+]\n // end lint list, do not remove this comment, it\u2019s used in `update_lints`\n-}\n+});"}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "tests/ui-cargo/update-references.sh", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui-cargo%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui-cargo%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-cargo%2Fupdate-references.sh?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -29,10 +29,18 @@ while [[ \"$1\" != \"\" ]]; do\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n+            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n+        fi\n     fi\n     if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n+            rm \"$MYDIR\"/\"$STDERR_NAME\"\n+        fi\n     fi\n done"}, {"sha": "2ab51168bcaa61c4fd96d093a6e3adf50371ae9d", "filename": "tests/ui-toml/update-references.sh", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui-toml%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui-toml%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fupdate-references.sh?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -29,10 +29,18 @@ while [[ \"$1\" != \"\" ]]; do\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n+            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n+        fi\n     fi\n     if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n+            rm \"$MYDIR\"/\"$STDERR_NAME\"\n+        fi\n     fi\n done"}, {"sha": "7c4e4a145512f6b268e21bb14eab204ff315de12", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -4,6 +4,7 @@\n #![crate_type = \"proc-macro\"]\n #![feature(repr128, proc_macro_quote)]\n #![allow(incomplete_features)]\n+#![allow(clippy::eq_op)]\n \n extern crate proc_macro;\n "}, {"sha": "f3966e47f5e808eda8fd3f75e0f40ec03b7c8ebc", "filename": "tests/ui/crashes/ice-6139.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fcrashes%2Fice-6139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fcrashes%2Fice-6139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6139.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,7 @@\n+trait T<'a> {}\n+\n+fn foo(_: Vec<Box<dyn T<'_>>>) {}\n+\n+fn main() {\n+    foo(vec![]);\n+}"}, {"sha": "9f73f39f10d7969194cdbee8307437acda7e9569", "filename": "tests/ui/crashes/ice-6153.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fcrashes%2Fice-6153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fcrashes%2Fice-6153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-6153.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,9 @@\n+pub struct S<'a, 'e>(&'a str, &'e str);\n+\n+pub type T<'a, 'e> = std::collections::HashMap<S<'a, 'e>, ()>;\n+\n+impl<'e, 'a: 'e> S<'a, 'e> {\n+    pub fn foo(_a: &str, _b: &str, _map: &T) {}\n+}\n+\n+fn main() {}"}, {"sha": "f47b81a450ea937c2bd142e47bdb9b0f140620bf", "filename": "tests/ui/doc_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdoc_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdoc_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_errors.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,5 +1,6 @@\n // edition:2018\n #![warn(clippy::missing_errors_doc)]\n+#![allow(clippy::result_unit_err)]\n \n use std::io;\n "}, {"sha": "c7b616e2897087c01ee59976e37fe287afb6dbbc", "filename": "tests/ui/doc_errors.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdoc_errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdoc_errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_errors.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,5 +1,5 @@\n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:6:1\n+  --> $DIR/doc_errors.rs:7:1\n    |\n LL | / pub fn pub_fn_missing_errors_header() -> Result<(), ()> {\n LL | |     unimplemented!();\n@@ -9,47 +9,47 @@ LL | | }\n    = note: `-D clippy::missing-errors-doc` implied by `-D warnings`\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:10:1\n+  --> $DIR/doc_errors.rs:11:1\n    |\n LL | / pub async fn async_pub_fn_missing_errors_header() -> Result<(), ()> {\n LL | |     unimplemented!();\n LL | | }\n    | |_^\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:15:1\n+  --> $DIR/doc_errors.rs:16:1\n    |\n LL | / pub fn pub_fn_returning_io_result() -> io::Result<()> {\n LL | |     unimplemented!();\n LL | | }\n    | |_^\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:20:1\n+  --> $DIR/doc_errors.rs:21:1\n    |\n LL | / pub async fn async_pub_fn_returning_io_result() -> io::Result<()> {\n LL | |     unimplemented!();\n LL | | }\n    | |_^\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:50:5\n+  --> $DIR/doc_errors.rs:51:5\n    |\n LL | /     pub fn pub_method_missing_errors_header() -> Result<(), ()> {\n LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:55:5\n+  --> $DIR/doc_errors.rs:56:5\n    |\n LL | /     pub async fn async_pub_method_missing_errors_header() -> Result<(), ()> {\n LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n error: docs for function returning `Result` missing `# Errors` section\n-  --> $DIR/doc_errors.rs:84:5\n+  --> $DIR/doc_errors.rs:85:5\n    |\n LL |     fn trait_method_missing_errors_header() -> Result<(), ()>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "05e087b08bc14271fda5427614296151c5f82205", "filename": "tests/ui/double_must_use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::double_must_use)]\n+#![allow(clippy::result_unit_err)]\n \n #[must_use]\n pub fn must_use_result() -> Result<(), ()> {"}, {"sha": "8290ece1cad187dc9428f5a1f26e07247a0d36a1", "filename": "tests/ui/double_must_use.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_must_use.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,5 +1,5 @@\n error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n-  --> $DIR/double_must_use.rs:4:1\n+  --> $DIR/double_must_use.rs:5:1\n    |\n LL | pub fn must_use_result() -> Result<(), ()> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -8,15 +8,15 @@ LL | pub fn must_use_result() -> Result<(), ()> {\n    = help: either add some descriptive text or remove the attribute\n \n error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n-  --> $DIR/double_must_use.rs:9:1\n+  --> $DIR/double_must_use.rs:10:1\n    |\n LL | pub fn must_use_tuple() -> (Result<(), ()>, u8) {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: either add some descriptive text or remove the attribute\n \n error: this function has an empty `#[must_use]` attribute, but returns a type already marked as `#[must_use]`\n-  --> $DIR/double_must_use.rs:14:1\n+  --> $DIR/double_must_use.rs:15:1\n    |\n LL | pub fn must_use_array() -> [Result<(), ()>; 1] {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "ff1dc76ab63b15727e6f81655177656007ea541b", "filename": "tests/ui/double_parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_parens.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::double_parens)]\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::eq_op)]\n #![feature(custom_inner_attributes)]\n #![rustfmt::skip]\n "}, {"sha": "6b5b31a1a2ef182e97cb855c1cdf3c117d8dbaba", "filename": "tests/ui/eq_op_macros.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Feq_op_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Feq_op_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op_macros.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,56 @@\n+#![warn(clippy::eq_op)]\n+\n+// lint also in macro definition\n+macro_rules! assert_in_macro_def {\n+    () => {\n+        let a = 42;\n+        assert_eq!(a, a);\n+        assert_ne!(a, a);\n+        debug_assert_eq!(a, a);\n+        debug_assert_ne!(a, a);\n+    };\n+}\n+\n+// lint identical args in assert-like macro invocations (see #3574)\n+fn main() {\n+    assert_in_macro_def!();\n+\n+    let a = 1;\n+    let b = 2;\n+\n+    // lint identical args in `assert_eq!`\n+    assert_eq!(a, a);\n+    assert_eq!(a + 1, a + 1);\n+    // ok\n+    assert_eq!(a, b);\n+    assert_eq!(a, a + 1);\n+    assert_eq!(a + 1, b + 1);\n+\n+    // lint identical args in `assert_ne!`\n+    assert_ne!(a, a);\n+    assert_ne!(a + 1, a + 1);\n+    // ok\n+    assert_ne!(a, b);\n+    assert_ne!(a, a + 1);\n+    assert_ne!(a + 1, b + 1);\n+\n+    // lint identical args in `debug_assert_eq!`\n+    debug_assert_eq!(a, a);\n+    debug_assert_eq!(a + 1, a + 1);\n+    // ok\n+    debug_assert_eq!(a, b);\n+    debug_assert_eq!(a, a + 1);\n+    debug_assert_eq!(a + 1, b + 1);\n+\n+    // lint identical args in `debug_assert_ne!`\n+    debug_assert_ne!(a, a);\n+    debug_assert_ne!(a + 1, a + 1);\n+    // ok\n+    debug_assert_ne!(a, b);\n+    debug_assert_ne!(a, a + 1);\n+    debug_assert_ne!(a + 1, b + 1);\n+\n+    let my_vec = vec![1; 5];\n+    let mut my_iter = my_vec.iter();\n+    assert_ne!(my_iter.next(), my_iter.next());\n+}"}, {"sha": "fb9378108b98ce010b7641418b64b3c0a116087f", "filename": "tests/ui/eq_op_macros.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Feq_op_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Feq_op_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feq_op_macros.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,95 @@\n+error: identical args used in this `assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:7:20\n+   |\n+LL |         assert_eq!(a, a);\n+   |                    ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ----------------------- in this macro invocation\n+   |\n+   = note: `-D clippy::eq-op` implied by `-D warnings`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:8:20\n+   |\n+LL |         assert_ne!(a, a);\n+   |                    ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ----------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:22:16\n+   |\n+LL |     assert_eq!(a, a);\n+   |                ^^^^\n+\n+error: identical args used in this `assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:23:16\n+   |\n+LL |     assert_eq!(a + 1, a + 1);\n+   |                ^^^^^^^^^^^^\n+\n+error: identical args used in this `assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:30:16\n+   |\n+LL |     assert_ne!(a, a);\n+   |                ^^^^\n+\n+error: identical args used in this `assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:31:16\n+   |\n+LL |     assert_ne!(a + 1, a + 1);\n+   |                ^^^^^^^^^^^^\n+\n+error: identical args used in this `debug_assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:9:26\n+   |\n+LL |         debug_assert_eq!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ----------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `debug_assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:10:26\n+   |\n+LL |         debug_assert_ne!(a, a);\n+   |                          ^^^^\n+...\n+LL |     assert_in_macro_def!();\n+   |     ----------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: identical args used in this `debug_assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:38:22\n+   |\n+LL |     debug_assert_eq!(a, a);\n+   |                      ^^^^\n+\n+error: identical args used in this `debug_assert_eq!` macro call\n+  --> $DIR/eq_op_macros.rs:39:22\n+   |\n+LL |     debug_assert_eq!(a + 1, a + 1);\n+   |                      ^^^^^^^^^^^^\n+\n+error: identical args used in this `debug_assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:46:22\n+   |\n+LL |     debug_assert_ne!(a, a);\n+   |                      ^^^^\n+\n+error: identical args used in this `debug_assert_ne!` macro call\n+  --> $DIR/eq_op_macros.rs:47:22\n+   |\n+LL |     debug_assert_ne!(a + 1, a + 1);\n+   |                      ^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n+"}, {"sha": "586784b73e697dc564fdccbfc79ab43b6cc51977", "filename": "tests/ui/float_cmp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -2,6 +2,7 @@\n #![allow(\n     unused,\n     clippy::no_effect,\n+    clippy::op_ref,\n     clippy::unnecessary_operation,\n     clippy::cast_lossless,\n     clippy::many_single_char_names\n@@ -116,4 +117,8 @@ fn main() {\n     1.23f64.signum() != x64.signum();\n     1.23f64.signum() != -(x64.signum());\n     1.23f64.signum() != 3.21f64.signum();\n+\n+    // the comparison should also look through references\n+    &0.0 == &ZERO;\n+    &&&&0.0 == &&&&ZERO;\n }"}, {"sha": "bb4051c466201f9720a5ba2863cfb0be945f918b", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,5 +1,5 @@\n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:65:5\n+  --> $DIR/float_cmp.rs:66:5\n    |\n LL |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(ONE as f64 - 2.0).abs() > error_margin`\n@@ -8,39 +8,39 @@ LL |     ONE as f64 != 2.0;\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:70:5\n+  --> $DIR/float_cmp.rs:71:5\n    |\n LL |     x == 1.0;\n    |     ^^^^^^^^ help: consider comparing them within some margin of error: `(x - 1.0).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:73:5\n+  --> $DIR/float_cmp.rs:74:5\n    |\n LL |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(twice(x) - twice(ONE as f64)).abs() > error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:93:5\n+  --> $DIR/float_cmp.rs:94:5\n    |\n LL |     NON_ZERO_ARRAY[i] == NON_ZERO_ARRAY[j];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(NON_ZERO_ARRAY[i] - NON_ZERO_ARRAY[j]).abs() < error_margin`\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64` arrays\n-  --> $DIR/float_cmp.rs:98:5\n+  --> $DIR/float_cmp.rs:99:5\n    |\n LL |     a1 == a2;\n    |     ^^^^^^^^\n    |\n    = note: `f32::EPSILON` and `f64::EPSILON` are available for the `error_margin`\n \n error: strict comparison of `f32` or `f64`\n-  --> $DIR/float_cmp.rs:99:5\n+  --> $DIR/float_cmp.rs:100:5\n    |\n LL |     a1[0] == a2[0];\n    |     ^^^^^^^^^^^^^^ help: consider comparing them within some margin of error: `(a1[0] - a2[0]).abs() < error_margin`"}, {"sha": "740a22a07d747c5dc409fea811cf27afb96e5468", "filename": "tests/ui/format.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fformat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fformat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.fixed?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -13,7 +13,8 @@ fn main() {\n     \"foo\".to_string();\n     \"{}\".to_string();\n     \"{} abc {}\".to_string();\n-    \"foo {}\\n\\\" bar\".to_string();\n+    r##\"foo {}\n+\" bar\"##.to_string();\n \n     \"foo\".to_string();\n     format!(\"{:?}\", \"foo\"); // Don't warn about `Debug`."}, {"sha": "96df7f37f779232dd03fc305b86845381317ef69", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -25,7 +25,13 @@ LL | /     format!(\n LL | |         r##\"foo {{}}\n LL | | \" bar\"##\n LL | |     );\n-   | |______^ help: consider using `.to_string()`: `\"foo {}/n/\" bar\".to_string();`\n+   | |______^\n+   |\n+help: consider using `.to_string()`\n+   |\n+LL |     r##\"foo {}\n+LL | \" bar\"##.to_string();\n+   |\n \n error: useless use of `format!`\n   --> $DIR/format.rs:21:5"}, {"sha": "bad84a589008180df702444d2e57b4a9042b9d82", "filename": "tests/ui/manual_memcpy.stderr", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fcde7683fe7ca10c83e5bc17f0969d2284affcd2/tests%2Fui%2Fmanual_memcpy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcde7683fe7ca10c83e5bc17f0969d2284affcd2/tests%2Fui%2Fmanual_memcpy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy.stderr?ref=fcde7683fe7ca10c83e5bc17f0969d2284affcd2", "patch": "@@ -1,88 +0,0 @@\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:7:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n-   |\n-   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:12:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:17:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:22:14\n-   |\n-LL |     for i in 11..src.len() {\n-   |              ^^^^^^^^^^^^^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:27:14\n-   |\n-LL |     for i in 0..dst.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:40:14\n-   |\n-LL |     for i in 10..256 {\n-   |              ^^^^^^^\n-   |\n-help: try replacing the loop by\n-   |\n-LL |     for i in dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)])\n-LL |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256]) {\n-   |\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:52:14\n-   |\n-LL |     for i in 10..LOOP_OFFSET {\n-   |              ^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:65:14\n-   |\n-LL |     for i in 0..src_vec.len() {\n-   |              ^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:94:14\n-   |\n-LL |     for i in from..from + src.len() {\n-   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[..(from + src.len() - from)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:98:14\n-   |\n-LL |     for i in from..from + 3 {\n-   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[..(from + 3 - from)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:103:14\n-   |\n-LL |     for i in 0..5 {\n-   |              ^^^^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:108:14\n-   |\n-LL |     for i in 0..0 {\n-   |              ^^^^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:120:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n-\n-error: aborting due to 13 previous errors\n-"}, {"sha": "ba388a05a2859e7a05dab97158ce872be225266c", "filename": "tests/ui/manual_memcpy/with_loop_counters.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,88 @@\n+#![warn(clippy::needless_range_loop, clippy::manual_memcpy)]\n+\n+pub fn manual_copy_with_counters(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[count] = src[i];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 0..src.len() {\n+        dst[count] = src[i];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 0..src.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 0;\n+    for i in 3..(3 + src.len()) {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 5..src.len() {\n+        dst[i] = src[count - 2];\n+        count += 1;\n+    }\n+\n+    let mut count = 2;\n+    for i in 0..dst.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 5;\n+    for i in 3..10 {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    let mut count2 = 30;\n+    for i in 0..src.len() {\n+        dst[count] = src[i];\n+        dst2[count2] = src[i];\n+        count += 1;\n+        count2 += 1;\n+    }\n+\n+    // make sure parentheses are added properly to bitwise operators, which have lower precedence than\n+    // arithmetric ones\n+    let mut count = 0 << 1;\n+    for i in 0..1 << 1 {\n+        dst[count] = src[i + 2];\n+        count += 1;\n+    }\n+\n+    // make sure incrementing expressions without semicolons at the end of loops are handled correctly.\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[i] = src[count];\n+        count += 1\n+    }\n+\n+    // make sure ones where the increment is not at the end of the loop.\n+    // As a possible enhancement, one could adjust the offset in the suggestion according to\n+    // the position. For example, if the increment is at the top of the loop;\n+    // treating the loop counter as if it were initialized 1 greater than the original value.\n+    let mut count = 0;\n+    #[allow(clippy::needless_range_loop)]\n+    for i in 0..src.len() {\n+        count += 1;\n+        dst[i] = src[count];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2547b19f5d1d43978225d22eb15b03b917776f78", "filename": "tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,111 @@\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:5:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+   |\n+   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:11:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..(src.len() - 3)].clone_from_slice(&src[3..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:17:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..(src.len() + 3)].clone_from_slice(&src[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:23:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[3..(src.len() + 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:29:5\n+   |\n+LL | /     for i in 3..(3 + src.len()) {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..((3 + src.len()))].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:35:5\n+   |\n+LL | /     for i in 5..src.len() {\n+LL | |         dst[i] = src[count - 2];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[5..src.len()].clone_from_slice(&src[(3 - 2)..((src.len() - 2) + 3 - 5)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:41:5\n+   |\n+LL | /     for i in 0..dst.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[2..(dst.len() + 2)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:47:5\n+   |\n+LL | /     for i in 3..10 {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..10].clone_from_slice(&src[5..(10 + 5 - 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:54:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         dst2[count2] = src[i];\n+LL | |         count += 1;\n+LL | |         count2 += 1;\n+LL | |     }\n+   | |_____^\n+   |\n+help: try replacing the loop by\n+   |\n+LL |     dst[3..(src.len() + 3)].clone_from_slice(&src[..]);\n+LL |     dst2[30..(src.len() + 30)].clone_from_slice(&src[..]);\n+   |\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:64:5\n+   |\n+LL | /     for i in 0..1 << 1 {\n+LL | |         dst[count] = src[i + 2];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[(0 << 1)..((1 << 1) + (0 << 1))].clone_from_slice(&src[2..((1 << 1) + 2)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:71:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "0083f94798fe4b2c650998d439f05cda4e7b0d0c", "filename": "tests/ui/manual_memcpy/without_loop_counters.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "previous_filename": "tests/ui/manual_memcpy.rs"}, {"sha": "54b966f6e5419d375623fee09c6c58c66273ca7e", "filename": "tests/ui/manual_memcpy/without_loop_counters.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,115 @@\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:7:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..]);`\n+   |\n+   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:12:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i + 10] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:17:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i + 10];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..(src.len() + 10)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:22:5\n+   |\n+LL | /     for i in 11..src.len() {\n+LL | |         dst[i] = src[i - 10];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:27:5\n+   |\n+LL | /     for i in 0..dst.len() {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:40:5\n+   |\n+LL | /     for i in 10..256 {\n+LL | |         dst[i] = src[i - 5];\n+LL | |         dst2[i + 500] = src[i]\n+LL | |     }\n+   | |_____^\n+   |\n+help: try replacing the loop by\n+   |\n+LL |     dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)]);\n+LL |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256]);\n+   |\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:52:5\n+   |\n+LL | /     for i in 10..LOOP_OFFSET {\n+LL | |         dst[i + LOOP_OFFSET] = src[i - some_var];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:65:5\n+   |\n+LL | /     for i in 0..src_vec.len() {\n+LL | |         dst_vec[i] = src_vec[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:94:5\n+   |\n+LL | /     for i in from..from + src.len() {\n+LL | |         dst[i] = src[i - from];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + src.len())].clone_from_slice(&src[..(from + src.len() - from)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:98:5\n+   |\n+LL | /     for i in from..from + 3 {\n+LL | |         dst[i] = src[i - from];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + 3)].clone_from_slice(&src[..(from + 3 - from)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:103:5\n+   |\n+LL | /     for i in 0..5 {\n+LL | |         dst[i - 0] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:108:5\n+   |\n+LL | /     for i in 0..0 {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:120:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i].clone();\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..]);`\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "a8736f1e6efe159c7390fc719585a2a2745369ae", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,68 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn unwrap_or() {\n+    // int case\n+    Some(1).unwrap_or(42);\n+\n+    // int case reversed\n+    Some(1).unwrap_or(42);\n+\n+    // richer none expr\n+    Some(1).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    Some(1).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    Some(\"Bob\").unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Some(1) {\n+        Some(i) => i + 2,\n+        None => 42,\n+    };\n+    match Some(1) {\n+        Some(i) => i,\n+        None => return,\n+    };\n+    for j in 0..4 {\n+        match Some(j) {\n+            Some(i) => i,\n+            None => continue,\n+        };\n+        match Some(j) {\n+            Some(i) => i,\n+            None => break,\n+        };\n+    }\n+\n+    // cases where the none arm isn't a constant expression\n+    // are not linted due to potential ownership issues\n+\n+    // ownership issue example, don't lint\n+    struct NonCopyable;\n+    let mut option: Option<NonCopyable> = None;\n+    match option {\n+        Some(x) => x,\n+        None => {\n+            option = Some(NonCopyable);\n+            // some more code ...\n+            option.unwrap()\n+        },\n+    };\n+\n+    // ownership issue example, don't lint\n+    let option: Option<&str> = None;\n+    match option {\n+        Some(s) => s,\n+        None => &format!(\"{} {}!\", \"hello\", \"world\"),\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "bede8cffc326ecea9783815694c69bf9141c9352", "filename": "tests/ui/manual_unwrap_or.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,83 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn unwrap_or() {\n+    // int case\n+    match Some(1) {\n+        Some(i) => i,\n+        None => 42,\n+    };\n+\n+    // int case reversed\n+    match Some(1) {\n+        None => 42,\n+        Some(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Some(1) {\n+        Some(i) => i,\n+        None => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Some(1) {\n+        Some(i) => i,\n+        None => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Some(\"Bob\") {\n+        Some(i) => i,\n+        None => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Some(1) {\n+        Some(i) => i + 2,\n+        None => 42,\n+    };\n+    match Some(1) {\n+        Some(i) => i,\n+        None => return,\n+    };\n+    for j in 0..4 {\n+        match Some(j) {\n+            Some(i) => i,\n+            None => continue,\n+        };\n+        match Some(j) {\n+            Some(i) => i,\n+            None => break,\n+        };\n+    }\n+\n+    // cases where the none arm isn't a constant expression\n+    // are not linted due to potential ownership issues\n+\n+    // ownership issue example, don't lint\n+    struct NonCopyable;\n+    let mut option: Option<NonCopyable> = None;\n+    match option {\n+        Some(x) => x,\n+        None => {\n+            option = Some(NonCopyable);\n+            // some more code ...\n+            option.unwrap()\n+        },\n+    };\n+\n+    // ownership issue example, don't lint\n+    let option: Option<&str> = None;\n+    match option {\n+        Some(s) => s,\n+        None => &format!(\"{} {}!\", \"hello\", \"world\"),\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "674f2952635f6298adeb7d3cbfae994a804e7a10", "filename": "tests/ui/manual_unwrap_or.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,61 @@\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:6:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n+   |\n+   = note: `-D clippy::manual-unwrap-or` implied by `-D warnings`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:12:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         None => 42,\n+LL | |         Some(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:18:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:25:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     Some(1).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:35:5\n+   |\n+LL | /     match Some(\"Bob\") {\n+LL | |         Some(i) => i,\n+LL | |         None => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "209081e6e8011b6fb5c7bcd4b9c915d7624f8544", "filename": "tests/ui/ptr_eq.fixed", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_eq.fixed?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,38 @@\n+// run-rustfix\n+#![warn(clippy::ptr_eq)]\n+\n+macro_rules! mac {\n+    ($a:expr, $b:expr) => {\n+        $a as *const _ as usize == $b as *const _ as usize\n+    };\n+}\n+\n+macro_rules! another_mac {\n+    ($a:expr, $b:expr) => {\n+        $a as *const _ == $b as *const _\n+    };\n+}\n+\n+fn main() {\n+    let a = &[1, 2, 3];\n+    let b = &[1, 2, 3];\n+\n+    let _ = std::ptr::eq(a, b);\n+    let _ = std::ptr::eq(a, b);\n+    let _ = a.as_ptr() == b as *const _;\n+    let _ = a.as_ptr() == b.as_ptr();\n+\n+    // Do not lint\n+\n+    let _ = mac!(a, b);\n+    let _ = another_mac!(a, b);\n+\n+    let a = &mut [1, 2, 3];\n+    let b = &mut [1, 2, 3];\n+\n+    let _ = a.as_mut_ptr() == b as *mut [i32] as *mut _;\n+    let _ = a.as_mut_ptr() == b.as_mut_ptr();\n+\n+    let _ = a == b;\n+    let _ = core::ptr::eq(a, b);\n+}"}, {"sha": "69162870807a2c9665de1016e102c9eaf4263a55", "filename": "tests/ui/ptr_eq.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_eq.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,38 @@\n+// run-rustfix\n+#![warn(clippy::ptr_eq)]\n+\n+macro_rules! mac {\n+    ($a:expr, $b:expr) => {\n+        $a as *const _ as usize == $b as *const _ as usize\n+    };\n+}\n+\n+macro_rules! another_mac {\n+    ($a:expr, $b:expr) => {\n+        $a as *const _ == $b as *const _\n+    };\n+}\n+\n+fn main() {\n+    let a = &[1, 2, 3];\n+    let b = &[1, 2, 3];\n+\n+    let _ = a as *const _ as usize == b as *const _ as usize;\n+    let _ = a as *const _ == b as *const _;\n+    let _ = a.as_ptr() == b as *const _;\n+    let _ = a.as_ptr() == b.as_ptr();\n+\n+    // Do not lint\n+\n+    let _ = mac!(a, b);\n+    let _ = another_mac!(a, b);\n+\n+    let a = &mut [1, 2, 3];\n+    let b = &mut [1, 2, 3];\n+\n+    let _ = a.as_mut_ptr() == b as *mut [i32] as *mut _;\n+    let _ = a.as_mut_ptr() == b.as_mut_ptr();\n+\n+    let _ = a == b;\n+    let _ = core::ptr::eq(a, b);\n+}"}, {"sha": "45d8c60382b59829048fe8dc5fcfe811307b94b1", "filename": "tests/ui/ptr_eq.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fptr_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_eq.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,16 @@\n+error: use `std::ptr::eq` when comparing raw pointers\n+  --> $DIR/ptr_eq.rs:20:13\n+   |\n+LL |     let _ = a as *const _ as usize == b as *const _ as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::ptr::eq(a, b)`\n+   |\n+   = note: `-D clippy::ptr-eq` implied by `-D warnings`\n+\n+error: use `std::ptr::eq` when comparing raw pointers\n+  --> $DIR/ptr_eq.rs:21:13\n+   |\n+LL |     let _ = a as *const _ == b as *const _;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::ptr::eq(a, b)`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a66f581b2159f02058a9e29e1f64f416f257feb7", "filename": "tests/ui/result_unit_error.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fresult_unit_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fresult_unit_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_unit_error.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,38 @@\n+#[warn(clippy::result_unit_err)]\n+#[allow(unused)]\n+\n+pub fn returns_unit_error() -> Result<u32, ()> {\n+    Err(())\n+}\n+\n+fn private_unit_errors() -> Result<String, ()> {\n+    Err(())\n+}\n+\n+pub trait HasUnitError {\n+    fn get_that_error(&self) -> Result<bool, ()>;\n+\n+    fn get_this_one_too(&self) -> Result<bool, ()> {\n+        Err(())\n+    }\n+}\n+\n+impl HasUnitError for () {\n+    fn get_that_error(&self) -> Result<bool, ()> {\n+        Ok(true)\n+    }\n+}\n+\n+trait PrivateUnitError {\n+    fn no_problem(&self) -> Result<usize, ()>;\n+}\n+\n+pub struct UnitErrorHolder;\n+\n+impl UnitErrorHolder {\n+    pub fn unit_error(&self) -> Result<usize, ()> {\n+        Ok(0)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b8230032491b65e1c1af8c44b6286f2f29a17978", "filename": "tests/ui/result_unit_error.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fresult_unit_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fresult_unit_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_unit_error.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -0,0 +1,35 @@\n+error: this returns a `Result<_, ()>\n+  --> $DIR/result_unit_error.rs:4:1\n+   |\n+LL | pub fn returns_unit_error() -> Result<u32, ()> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::result-unit-err` implied by `-D warnings`\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/result_unit_error.rs:13:5\n+   |\n+LL |     fn get_that_error(&self) -> Result<bool, ()>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/result_unit_error.rs:15:5\n+   |\n+LL |     fn get_this_one_too(&self) -> Result<bool, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: this returns a `Result<_, ()>\n+  --> $DIR/result_unit_error.rs:33:5\n+   |\n+LL |     pub fn unit_error(&self) -> Result<usize, ()> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use a custom Error type instead\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "7f28f0257904578f9d42b7900eda8df4bc38e530", "filename": "tests/ui/same_functions_in_if_condition.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fsame_functions_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fsame_functions_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_functions_in_if_condition.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -77,4 +77,14 @@ fn ifs_same_cond_fn() {\n     }\n }\n \n-fn main() {}\n+fn main() {\n+    // macro as condition (see #6168)\n+    let os = if cfg!(target_os = \"macos\") {\n+        \"macos\"\n+    } else if cfg!(target_os = \"windows\") {\n+        \"windows\"\n+    } else {\n+        \"linux\"\n+    };\n+    println!(\"{}\", os);\n+}"}, {"sha": "e366c75335c20357659021928b32b4e834206997", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -8,6 +8,7 @@\n #![allow(\n     unused_parens,\n     unused_variables,\n+    clippy::manual_unwrap_or,\n     clippy::missing_docs_in_private_items,\n     clippy::single_match\n )]"}, {"sha": "7c1ad2949e91b914cc75034d08034088fd140c99", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -1,135 +1,135 @@\n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:26:5\n+  --> $DIR/shadow.rs:27:5\n    |\n LL |     let x = &mut x;\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:25:13\n+  --> $DIR/shadow.rs:26:13\n    |\n LL |     let mut x = 1;\n    |             ^\n \n error: `x` is shadowed by itself in `{ x }`\n-  --> $DIR/shadow.rs:27:5\n+  --> $DIR/shadow.rs:28:5\n    |\n LL |     let x = { x };\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed by itself in `(&*x)`\n-  --> $DIR/shadow.rs:28:5\n+  --> $DIR/shadow.rs:29:5\n    |\n LL |     let x = (&*x);\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:27:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = { x };\n    |         ^\n \n error: `x` is shadowed by `{ *x + 1 }` which reuses the original value\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:29:13\n+  --> $DIR/shadow.rs:30:13\n    |\n LL |     let x = { *x + 1 };\n    |             ^^^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = (&*x);\n    |         ^\n \n error: `x` is shadowed by `id(x)` which reuses the original value\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = id(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:30:13\n+  --> $DIR/shadow.rs:31:13\n    |\n LL |     let x = id(x);\n    |             ^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n \n error: `x` is shadowed by `(1, x)` which reuses the original value\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = (1, x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:31:13\n+  --> $DIR/shadow.rs:32:13\n    |\n LL |     let x = (1, x);\n    |             ^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = id(x);\n    |         ^\n \n error: `x` is shadowed by `first(x)` which reuses the original value\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = first(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:32:13\n+  --> $DIR/shadow.rs:33:13\n    |\n LL |     let x = first(x);\n    |             ^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = (1, x);\n    |         ^\n \n error: `x` is being shadowed\n-  --> $DIR/shadow.rs:34:9\n+  --> $DIR/shadow.rs:35:9\n    |\n LL |     let x = y;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:34:13\n+  --> $DIR/shadow.rs:35:13\n    |\n LL |     let x = y;\n    |             ^\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = first(x);\n    |         ^\n \n error: `x` shadows a previous declaration\n-  --> $DIR/shadow.rs:36:5\n+  --> $DIR/shadow.rs:37:5\n    |\n LL |     let x;\n    |     ^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:34:9\n+  --> $DIR/shadow.rs:35:9\n    |\n LL |     let x = y;\n    |         ^"}, {"sha": "e16ed600ef81406785b05e7dce3ff641cb5c1de1", "filename": "tests/ui/update-references.sh", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fupdate-references.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fupdate-references.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fupdate-references.sh?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -30,15 +30,27 @@ while [[ \"$1\" != \"\" ]]; do\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDOUT_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDOUT_NAME\" \"$MYDIR\"/\"$STDOUT_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDOUT_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDOUT_NAME\"\n+            rm \"$MYDIR\"/\"$STDOUT_NAME\"\n+        fi\n     fi\n     if [[ -f \"$BUILD_DIR\"/\"$STDERR_NAME\" ]] && \\\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"); then\n         echo updating \"$MYDIR\"/\"$STDERR_NAME\"\n         cp \"$BUILD_DIR\"/\"$STDERR_NAME\" \"$MYDIR\"/\"$STDERR_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$STDERR_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$STDERR_NAME\"\n+            rm \"$MYDIR\"/\"$STDERR_NAME\"\n+        fi\n     fi\n     if [[ -f \"$BUILD_DIR\"/\"$FIXED_NAME\" ]] && \\\n            ! (cmp -s -- \"$BUILD_DIR\"/\"$FIXED_NAME\" \"$MYDIR\"/\"$FIXED_NAME\"); then\n         echo updating \"$MYDIR\"/\"$FIXED_NAME\"\n         cp \"$BUILD_DIR\"/\"$FIXED_NAME\" \"$MYDIR\"/\"$FIXED_NAME\"\n+        if [[ ! -s \"$MYDIR\"/\"$FIXED_NAME\" ]]; then\n+            echo removing \"$MYDIR\"/\"$FIXED_NAME\"\n+            rm \"$MYDIR\"/\"$FIXED_NAME\"\n+        fi\n     fi\n done"}, {"sha": "d8bda7e8f48a7eb32cc22fc54c4cb5d24d1ffea8", "filename": "tests/ui/used_underscore_binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85/tests%2Fui%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fused_underscore_binding.rs?ref=cdb555f4fcdb57741ffb59bd2b0e66af69ea0a85", "patch": "@@ -3,7 +3,7 @@\n \n #![feature(rustc_private)]\n #![warn(clippy::all)]\n-#![allow(clippy::blacklisted_name)]\n+#![allow(clippy::blacklisted_name, clippy::eq_op)]\n #![warn(clippy::used_underscore_binding)]\n \n #[macro_use]"}]}