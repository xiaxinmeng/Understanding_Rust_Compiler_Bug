{"sha": "cfa09d35a355dee59008306f98330ff0472eb09d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYTA5ZDM1YTM1NWRlZTU5MDA4MzA2Zjk4MzMwZmYwNDcyZWIwOWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-03T21:42:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-03T21:42:34Z"}, "message": "Revert \"allow fn exprs to omit arg types\"\n\nThis reverts commit 1ba4ca4c4a0153578e812baf5f7f5554d079de40.", "tree": {"sha": "e9b157de0a53e056ebd63db17557e4af1ac17ef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b157de0a53e056ebd63db17557e4af1ac17ef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfa09d35a355dee59008306f98330ff0472eb09d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa09d35a355dee59008306f98330ff0472eb09d", "html_url": "https://github.com/rust-lang/rust/commit/cfa09d35a355dee59008306f98330ff0472eb09d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfa09d35a355dee59008306f98330ff0472eb09d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba4ca4c4a0153578e812baf5f7f5554d079de40", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba4ca4c4a0153578e812baf5f7f5554d079de40", "html_url": "https://github.com/rust-lang/rust/commit/1ba4ca4c4a0153578e812baf5f7f5554d079de40"}], "stats": {"total": 281, "additions": 103, "deletions": 178}, "files": [{"sha": "3215f3b9f289cb5034f174f1976fc41c21844e33", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -1096,14 +1096,6 @@ impl extensions<T> for [T] {\n     #[inline]\n     fn map<U>(f: fn(T) -> U) -> [U] { map(self, f) }\n     #[doc = \"\n-    Apply a function to the index and value of each element in the vector\n-    and return the results\n-    \"]\n-    fn mapi<U>(f: fn(uint, T) -> U) -> [U] {\n-        let mut i = 0u;\n-        self.map { |e| i += 1u; f(i - 1u, e) }\n-    }\n-    #[doc = \"\n     Apply a function to each element of a vector and return a concatenation\n     of each result vector\n     \"]"}, {"sha": "0c681900dd560a5d069d6c1e41221ecf9210bbfa", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -1206,7 +1206,7 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n     let lo = p.last_span.lo;\n     let capture_clause = parse_capture_clause(p);\n-    let decl = parse_fn_decl(p, ast::impure_fn, parse_fn_block_arg);\n+    let decl = parse_fn_decl(p, ast::impure_fn);\n     let body = parse_block(p);\n     ret mk_expr(p, lo, body.span.hi,\n                 ast::expr_fn(proto, decl, body, capture_clause));\n@@ -1699,12 +1699,11 @@ fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     } else { [] }\n }\n \n-fn parse_fn_decl(p: parser, purity: ast::purity,\n-                 parse_arg_fn: fn(parser) -> ast::arg)\n+fn parse_fn_decl(p: parser, purity: ast::purity)\n     -> ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n-                  parse_arg_fn, p);\n+                  parse_arg, p);\n     // Use the args list to translate each bound variable\n     // mentioned in a constraint to an arg index.\n     // Seems weird to do this in the parser, but I'm not sure how else to.\n@@ -1761,7 +1760,7 @@ fn parse_item_fn(p: parser, purity: ast::purity,\n                  attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, purity, parse_arg);\n+    let decl = parse_fn_decl(p, purity);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     ret mk_item(p, lo, body.span.hi, t.ident,\n@@ -1786,7 +1785,7 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n     let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n     let tps = parse_ty_params(p);\n-    let decl = parse_fn_decl(p, pur, parse_arg);\n+    let decl = parse_fn_decl(p, pur);\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n@@ -1970,7 +1969,7 @@ fn parse_class_item(p:parser, class_name_with_tps: @ast::path)\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n             // result type is always the type of the class\n-        let decl_ = parse_fn_decl(p, ast::impure_fn, parse_arg);\n+        let decl_ = parse_fn_decl(p, ast::impure_fn);\n         let decl = {output: @{id: p.get_id(),\n                       node: ast::ty_path(class_name_with_tps, p.get_id()),\n                       span: decl_.output.span}\n@@ -2049,7 +2048,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n                         purity: ast::purity) -> @ast::native_item {\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, purity, parse_arg);\n+    let decl = parse_fn_decl(p, purity);\n     let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,"}, {"sha": "b50f4f341a77488931509558b06ce4eb47bca4a1", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -1351,6 +1351,13 @@ fn print_cap_clause(s: ps, cap_clause: ast::capture_clause) {\n \n fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n     popen(s);\n+    fn print_arg(s: ps, x: ast::arg) {\n+        ibox(s, indent_unit);\n+        print_arg_mode(s, x.mode);\n+        word_space(s, x.ident + \":\");\n+        print_type(s, x.ty);\n+        end(s);\n+    }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n     word(s.s, constrs_str(decl.constraints, {|c|\n@@ -1367,6 +1374,16 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n \n fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     word(s.s, \"|\");\n+    fn print_arg(s: ps, x: ast::arg) {\n+        ibox(s, indent_unit);\n+        print_arg_mode(s, x.mode);\n+        word(s.s, x.ident);\n+        if x.ty.node != ast::ty_infer {\n+            word_space(s, \":\");\n+            print_type(s, x.ty);\n+        }\n+        end(s);\n+    }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     word(s.s, \"|\");\n     if decl.output.node != ast::ty_infer {\n@@ -1524,23 +1541,6 @@ fn print_mt(s: ps, mt: ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-fn print_arg(s: ps, input: ast::arg) {\n-    ibox(s, indent_unit);\n-    print_arg_mode(s, input.mode);\n-    alt input.ty.node {\n-      ast::ty_infer {\n-        word(s.s, input.ident);\n-      }\n-      _ {\n-        if str::len(input.ident) > 0u {\n-            word_space(s, input.ident + \":\");\n-        }\n-        print_type(s, input.ty);\n-      }\n-    }\n-    end(s);\n-}\n-\n fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                decl: ast::fn_decl, id: option<ast::ident>,\n                tps: option<[ast::ty_param]>) {\n@@ -1550,6 +1550,13 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     alt tps { some(tps) { print_type_params(s, tps); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n+    fn print_arg(s: ps, input: ast::arg) {\n+        print_arg_mode(s, input.mode);\n+        if str::len(input.ident) > 0u {\n+            word_space(s, input.ident + \":\");\n+        }\n+        print_type(s, input.ty);\n+    }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n     maybe_print_comment(s, decl.output.span.lo);"}, {"sha": "d8db45d89196133de9d9acf7654e9628dea43509", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 59, "deletions": 115, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -275,8 +275,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n     fcx.write_ty_substs(id, tpt.ty, substs);\n }\n \n-// Resolves `typ` by a single level if `typ` is a type variable.  If no\n-// resolution is possible, then an error is reported.\n+// Type tests\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt infer::resolve_shallow(fcx.infcx, tp, false) {\n       result::ok(t_s) if !ty::type_is_var(t_s) { ret t_s; }\n@@ -287,6 +286,7 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     }\n }\n \n+\n // Returns the one-level-deep structure of the given type.\n fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     ty::get(structurally_resolved_type(fcx, sp, typ)).struct\n@@ -689,7 +689,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_rec(tcx, flds)\n       }\n       ast::ty_fn(proto, decl) {\n-        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl, none))\n+        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl))\n       }\n       ast::ty_path(path, id) {\n         let a_def = alt tcx.def_map.find(id) {\n@@ -777,13 +777,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n         ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n       }\n       ast::ty_infer {\n-        // ty_infer should only appear as the type of arguments or return\n-        // values in a fn_expr, or as the type of local variables.  Both of\n-        // these cases are handled specially and should not descend into this\n-        // routine.\n-        self.tcx().sess.span_bug(\n-            ast_ty.span,\n-            \"found `ty_infer` in unexpected place\");\n+        self.ty_infer(ast_ty.span)\n       }\n       ast::ty_mac(_) {\n         tcx.sess.span_bug(ast_ty.span,\n@@ -856,8 +850,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_fn(decl, tps, _) {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare,\n-                                 decl, none);\n+        let tofd = ty_of_fn_decl(ccx, empty_rscope, ast::proto_bare, decl);\n         let tpt = {bounds: bounds,\n                    rp: ast::rp_none, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n@@ -891,8 +884,7 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_res(decl, tps, _, _, _, rp) {\n         let {bounds, substs} = mk_substs(ccx, tps, rp);\n-        let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                              decl.inputs[0], none);\n+        let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n         let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, substs);\n         let t_res = {bounds: bounds, rp: rp, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n@@ -1035,76 +1027,47 @@ fn replace_bound_regions(\n }\n \n fn ty_of_arg<AC: ast_conv, RS: region_scope copy>(\n-    self: AC, rscope: RS, a: ast::arg,\n-    expected_ty: option<ty::arg>) -> ty::arg {\n-\n-    let ty = alt a.ty.node {\n-      ast::ty_infer if expected_ty.is_some() {expected_ty.get().ty}\n-      ast::ty_infer {self.ty_infer(a.ty.span)}\n-      _ {ast_ty_to_ty(self, rscope, a.ty)}\n-    };\n+    self: AC, rscope: RS, a: ast::arg) -> ty::arg {\n \n-    let mode = {\n-        alt a.mode {\n-          ast::infer(_) if expected_ty.is_some() {\n-            result::get(ty::unify_mode(self.tcx(), a.mode,\n-                                       expected_ty.get().mode))\n-          }\n+    fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n+        alt m {\n           ast::infer(_) {\n             alt ty::get(ty).struct {\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere.\n-              ty::ty_var(_) {a.mode}\n+              ty::ty_var(_) { m }\n \n               // If the type is known, then use the default for that type.\n               // Here we unify m and the default.  This should update the\n               // tables in tcx but should never fail, because nothing else\n               // will have been unified with m yet:\n               _ {\n                 let m1 = ast::expl(ty::default_arg_mode_for_ty(ty));\n-                result::get(ty::unify_mode(self.tcx(), a.mode, m1))\n+                result::get(ty::unify_mode(tcx, m, m1))\n               }\n             }\n           }\n-          ast::expl(_) {a.mode}\n+          ast::expl(_) { m }\n         }\n-    };\n+    }\n \n+    let ty = ast_ty_to_ty(self, rscope, a.ty);\n+    let mode = arg_mode(self.tcx(), a.mode, ty);\n     {mode: mode, ty: ty}\n }\n-\n-type expected_tys = option<{inputs: [ty::arg],\n-                            output: ty::t}>;\n-\n fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n     self: AC, rscope: RS,\n     proto: ast::proto,\n-    decl: ast::fn_decl,\n-    expected_tys: expected_tys) -> ty::fn_ty {\n+    decl: ast::fn_decl) -> ty::fn_ty {\n \n     #debug[\"ty_of_fn_decl\"];\n     indent {||\n         // new region names that appear inside of the fn decl are bound to\n         // that function type\n         let rb = in_binding_rscope(rscope);\n-\n-        let input_tys = decl.inputs.mapi { |i, a|\n-            let expected_arg_ty = expected_tys.chain { |e|\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs.len() {some(e.inputs[i])} else {none}\n-            };\n-            ty_of_arg(self, rb, a, expected_arg_ty)\n-        };\n-\n-        let expected_ret_ty = expected_tys.map { |e| e.output };\n-        let output_ty = alt decl.output.node {\n-          ast::ty_infer if expected_ret_ty.is_some() {expected_ret_ty.get()}\n-          ast::ty_infer {self.ty_infer(decl.output.span)}\n-          _ {ast_ty_to_ty(self, rb, decl.output)}\n-        };\n-\n+        let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(self, rb, a) };\n+        let output_ty = ast_ty_to_ty(self, rb, decl.output);\n         let out_constrs = vec::map(decl.constraints) {|constr|\n             ty::ast_constr_to_constr(self.tcx(), constr)\n         };\n@@ -1120,7 +1083,7 @@ fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map { |a| ty_of_arg(ccx, rb, a, none) };\n+    let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(ccx, rb, a) };\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n@@ -1172,8 +1135,7 @@ fn ty_of_method(ccx: @crate_ctxt,\n                 rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(ccx, m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare,\n-                        m.decl, none),\n+     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::proto_bare, m.decl),\n      purity: m.decl.purity,\n      privacy: m.privacy}\n }\n@@ -1183,8 +1145,7 @@ fn ty_of_ty_method(self: @crate_ctxt,\n                    rp: ast::region_param) -> ty::method {\n     {ident: m.ident,\n      tps: ty_param_bounds(self, m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare,\n-                        m.decl, none),\n+     fty: ty_of_fn_decl(self, type_rscope(rp), ast::proto_bare, m.decl),\n      // assume public, because this is only invoked on iface methods\n      purity: m.decl.purity, privacy: ast::pub}\n }\n@@ -1688,8 +1649,7 @@ mod collect {\n           ast::item_res(decl, tps, _, dtor_id, ctor_id, rp) {\n             let {bounds, substs} = mk_substs(ccx, tps, rp);\n             let def_id = local_def(it.id);\n-            let t_arg = ty_of_arg(ccx, type_rscope(rp),\n-                                  decl.inputs[0], none);\n+            let t_arg = ty_of_arg(ccx, type_rscope(rp), decl.inputs[0]);\n             let t_res = ty::mk_res(tcx, def_id, t_arg.ty, substs);\n \n             let t_ctor = ty::mk_fn(tcx, {\n@@ -1731,8 +1691,7 @@ mod collect {\n                           ty_of_fn_decl(ccx,\n                                         empty_rscope,\n                                         ast::proto_any,\n-                                        ctor.node.dec,\n-                                        none));\n+                                        ctor.node.dec));\n             write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n             tcx.tcache.insert(local_def(ctor.node.id),\n                               {bounds: tpt.bounds,\n@@ -2943,6 +2902,35 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n     }\n }\n \n+fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n+                              expr: @ast::expr,\n+                              proto: ast::proto,\n+                              decl: ast::fn_decl,\n+                              body: ast::blk,\n+                              is_loop_body: bool,\n+                              unifier: fn()) {\n+    let tcx = fcx.ccx.tcx;\n+    let fty = ty::mk_fn(tcx, ty_of_fn_decl(fcx, fcx, proto, decl));\n+\n+    #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n+           expr_to_str(expr), fcx.ty_to_str(fty));\n+\n+    fcx.write_ty(expr.id, fty);\n+\n+    // Unify the type of the function with the expected type before we\n+    // typecheck the body so that we have more information about the\n+    // argument types in the body. This is needed to make binops and\n+    // record projection work on type inferred arguments.\n+    unifier();\n+\n+    let ret_ty = ty::ty_fn_ret(fty);\n+    let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n+\n+    check_fn(fcx.ccx, proto, decl, body, expr.id,\n+             ret_ty, arg_tys, is_loop_body, some(fcx),\n+             fcx.self_ty);\n+}\n+\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: option<ty::t>,\n@@ -3239,11 +3227,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n         }\n     }\n-\n-    // Resolves `expected` by a single level if it is a variable and passes it\n-    // through the `unpack` function.  It there is no expected type or\n-    // resolution is not possible (e.g., no constraints yet present), just\n-    // returns `none`.\n     fn unpack_expected<O: copy>(fcx: @fn_ctxt, expected: option<ty::t>,\n                                 unpack: fn(ty::sty) -> option<O>)\n         -> option<O> {\n@@ -3258,42 +3241,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @fn_ctxt,\n-                     expr: @ast::expr,\n-                     proto: ast::proto,\n-                     decl: ast::fn_decl,\n-                     body: ast::blk,\n-                     is_loop_body: bool,\n-                     expected: option<ty::t>) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        let expected_tys = unpack_expected(fcx, expected) { |sty|\n-            alt sty {\n-              ty::ty_fn(fn_ty) {some({inputs:fn_ty.inputs,\n-                                      output:fn_ty.output})}\n-              _ {none}\n-            }\n-        };\n-\n-        // construct the function type\n-        let fty = ty::mk_fn(tcx,\n-                            ty_of_fn_decl(fcx, fcx, proto, decl,\n-                                          expected_tys));\n-\n-        #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr), fcx.ty_to_str(fty));\n-\n-        fcx.write_ty(expr.id, fty);\n-\n-        let ret_ty = ty::ty_fn_ret(fty);\n-        let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-\n-        check_fn(fcx.ccx, proto, decl, body, expr.id,\n-                 ret_ty, arg_tys, is_loop_body, some(fcx),\n-                 fcx.self_ty);\n-    }\n-\n-\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n@@ -3564,23 +3511,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, result_ty);\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n-        check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n+        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n+                                   false, unifier);\n         capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n         let proto = unpack_expected(fcx, expected, {|sty|\n             alt sty { ty::ty_fn({proto, _}) { some(proto) } _ { none } }\n         }).get_default(ast::proto_box);\n-        check_expr_fn(fcx, expr, proto, decl, body, false, expected);\n+        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n+                                   false, unifier);\n       }\n       ast::expr_loop_body(b) {\n-        // a loop body is the special argument to a `for` loop.  We know that\n-        // there will be an expected type in this context because it can only\n-        // appear in the context of a call, so we get the expected type of the\n-        // parameter. The catch here is that we need to validate two things:\n-        // 1. a closure that returns a bool is expected\n-        // 2. the cloure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, {|x|some(x)}).get();\n         let (inner_ty, proto) = alt expected_sty {\n           ty::ty_fn(fty) {\n@@ -3602,8 +3545,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         alt check b.node {\n           ast::expr_fn_block(decl, body) {\n-            check_expr_fn(fcx, b, proto, decl, body, true, some(inner_ty));\n-            demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n+            check_expr_fn_with_unifier(fcx, b, proto, decl, body, true) {||\n+                demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n+            }\n           }\n         }\n         let block_ty = structurally_resolved_type("}, {"sha": "227dc0c8645b5cbbaf27aed9f8f6609086fe8e89", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -130,9 +130,18 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n \n     // if there is an id, print that instead of the structural type:\n-    for ty::type_def_id(typ).each { |def_id|\n-        // note that this typedef cannot have type parameters\n-        ret ast_map::path_to_str(ty::item_path(cx, def_id));\n+    alt ty::type_def_id(typ) {\n+      some(def_id) {\n+        let cs = ast_map::path_to_str(ty::item_path(cx, def_id));\n+        ret alt ty::get(typ).struct {\n+          ty_enum(_, substs) | ty_res(_, _, substs) | ty_class(_, substs) |\n+          ty_iface(_, substs) {\n+            parameterized(cx, cs, substs.self_r, substs.tps)\n+          }\n+          _ { cs }\n+        };\n+      }\n+      none { /* fallthrough */}\n     }\n \n     // pretty print the structural type representation:"}, {"sha": "8478a925eb6bdf47269df9df2cc4cf102a2c9120", "filename": "src/test/compile-fail/omitted-arg-in-item-fn.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-in-item-fn.rs?ref=1ba4ca4c4a0153578e812baf5f7f5554d079de40", "patch": "@@ -1,2 +0,0 @@\n-fn foo(x) { //! ERROR expecting ':' but found ')'\n-}\n\\ No newline at end of file"}, {"sha": "604fed1bc61c2641a4fd8261bf03f93de23f303a", "filename": "src/test/compile-fail/omitted-arg-wrong-types.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fomitted-arg-wrong-types.rs?ref=1ba4ca4c4a0153578e812baf5f7f5554d079de40", "patch": "@@ -1,9 +0,0 @@\n-fn let_in<T>(x: T, f: fn(T)) {}\n-\n-fn main() {\n-    let_in(3u, fn&(i) { assert i == 3; });\n-    //!^ ERROR expected `uint` but found `int`\n-\n-    let_in(3, fn&(i) { assert i == 3u; });\n-    //!^ ERROR expected `int` but found `uint`\n-}\n\\ No newline at end of file"}, {"sha": "941535ef0f1829a2cd9a6dd293f929a009750ae0", "filename": "src/test/compile-fail/pptypedef.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpptypedef.rs?ref=1ba4ca4c4a0153578e812baf5f7f5554d079de40", "patch": "@@ -1,8 +0,0 @@\n-type foo = option<int>;\n-\n-fn bar(_t: foo) {}\n-\n-fn main() {\n-    // we used to print foo<int>:\n-    bar(some(3u)); //! ERROR mismatched types: expected `foo`\n-}\n\\ No newline at end of file"}, {"sha": "b75623d6233a72d2f842be3a5ea1559c04988de9", "filename": "src/test/compile-fail/vec-concat-bug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa09d35a355dee59008306f98330ff0472eb09d/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-concat-bug.rs?ref=cfa09d35a355dee59008306f98330ff0472eb09d", "patch": "@@ -4,6 +4,7 @@ fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     // Earlier versions of our type checker accepted this:\n     vec::iter(v) {|&&inner: [T]|\n         //!^ ERROR values differ in mutability\n+        //!^^ ERROR values differ in mutability\n         r += inner;\n     }\n "}, {"sha": "3ae04461bcd00c7320f30f1441677d0f5ce954d2", "filename": "src/test/run-pass/omitted-arg-type.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Frun-pass%2Fomitted-arg-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ba4ca4c4a0153578e812baf5f7f5554d079de40/src%2Ftest%2Frun-pass%2Fomitted-arg-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fomitted-arg-type.rs?ref=1ba4ca4c4a0153578e812baf5f7f5554d079de40", "patch": "@@ -1,8 +0,0 @@\n-fn let_in<T>(x: T, f: fn(T)) {}\n-\n-fn main() {\n-    let_in(3u) { |i| assert i == 3u; };\n-    let_in(3) { |i| assert i == 3; };\n-    let_in(3u, fn&(i) { assert i == 3u; });\n-    let_in(3, fn&(i) { assert i == 3; });\n-}\n\\ No newline at end of file"}]}