{"sha": "d84907bbccf0430470ba7b8f121bb4f924cdffa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NDkwN2JiY2NmMDQzMDQ3MGJhN2I4ZjEyMWJiNGY5MjRjZGZmYTQ=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-07T17:56:41Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-11T23:54:32Z"}, "message": "Suggest macro import from crate root.\n\nThis commit suggests importing a macro from the root of a crate as the\nintent may have been to import a macro from the definition location that\nwas annotated with `#[macro_export]`.", "tree": {"sha": "3d0be1edbde5797a2269fa27f4e3cca5f9ed527e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d0be1edbde5797a2269fa27f4e3cca5f9ed527e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d84907bbccf0430470ba7b8f121bb4f924cdffa4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlyv07gACgkQAXYLT59T\n8VSS/Q//V1ysStfEmHbJ40ZySqpd7pt8H85OuhBb0qGqgathdZZMY8xmIv+U+PvM\nSLk9z3qWtFCUA7tfi7ZGohSZsG+GraTMYe38eTctlad+TXqSZ5Zm1qFwBrBaDRI2\nPuc3KmLEawraKIf5k7TJevEqXsACnCtcQgbGQ2wE8W5cEwY0BPxOKPho58g+QJtV\nRxRs0OxjpMuZrm3tZwnSdJxknb0H76jawhdEEDHnt2+FtdspASQ9po8/Aa16Uqh9\nCMWe3TGQffmMsaKgWzBtbecudFG48Hk78T1HC8JqIFK5+OVPMc37paldm2D6e/ql\nCxCUUGH2qoBGOknMHN/1bQoCIP/q/eM7eLBiVsB1G3N9zNmwLm4mtvXi9/5bpgje\nv0QO9iMZvC+4hKFVJca5g2ERwaZgzw//MDZgE/arGhNjigvr5d6j924vD9GpAjZP\nyNWKn1e9aVMFCkQ4Dk2RUyRrK7Q6r8AtqmViHdoeH+U11KhRmLSHsJMoWUyxqVLW\nxc6iWhH2TuOIVbleZ+yN5ppcr3Mrcj/KrTgfMwPkt9nQCi5eiXL1YqjuXatKCtQu\nFYiekshu8rCWlrGV7knR4uWy1COC5x27JMdVf/J96KQYCEpMgZEAUyfWxUO5N6vH\nwqn68FLWEuvkQssE8beDZHxTuu4luuGSH0U+ayUBofkPwjyhjzo=\n=3FLr\n-----END PGP SIGNATURE-----", "payload": "tree 3d0be1edbde5797a2269fa27f4e3cca5f9ed527e\nparent 126ac9ef6c11ced54ba9191aba916dd7d5206159\nauthor David Wood <david@davidtw.co> 1554659801 +0200\ncommitter David Wood <david@davidtw.co> 1555026872 +0200\n\nSuggest macro import from crate root.\n\nThis commit suggests importing a macro from the root of a crate as the\nintent may have been to import a macro from the definition location that\nwas annotated with `#[macro_export]`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d84907bbccf0430470ba7b8f121bb4f924cdffa4", "html_url": "https://github.com/rust-lang/rust/commit/d84907bbccf0430470ba7b8f121bb4f924cdffa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d84907bbccf0430470ba7b8f121bb4f924cdffa4/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126ac9ef6c11ced54ba9191aba916dd7d5206159", "url": "https://api.github.com/repos/rust-lang/rust/commits/126ac9ef6c11ced54ba9191aba916dd7d5206159", "html_url": "https://github.com/rust-lang/rust/commit/126ac9ef6c11ced54ba9191aba916dd7d5206159"}], "stats": {"total": 175, "additions": 134, "deletions": 41}, "files": [{"sha": "99aa6e39f7b71a1794016d2a01f329b4bfc7b93e", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -5,15 +5,16 @@ use log::debug;\n use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::config::nightly_options;\n-use syntax::ast::{Expr, ExprKind};\n+use syntax::ast::{Expr, ExprKind, Ident};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use crate::macros::ParentScope;\n-use crate::resolve_imports::ImportResolver;\n+use crate::resolve_imports::{ImportDirective, ImportResolver};\n use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment};\n+            PathSource, Resolver, Segment, Suggestion};\n \n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n@@ -428,7 +429,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n         match (path.get(0), path.get(1)) {\n@@ -463,13 +464,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -487,19 +488,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n                 path,\n-                Some(\n+                vec![\n                     \"`use` statements changed in Rust 2018; read more at \\\n                      <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n                      clarity.html>\".to_string()\n-                ),\n+                ],\n             ))\n         } else {\n             None\n@@ -518,13 +519,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -545,7 +546,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         if path[1].ident.span.rust_2015() {\n             return None;\n         }\n@@ -564,10 +565,65 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n-                return Some((path, None));\n+                return Some((path, Vec::new()));\n             }\n         }\n \n         None\n     }\n+\n+    /// Suggests importing a macro from the root of the crate rather than a module within\n+    /// the crate.\n+    ///\n+    /// ```\n+    /// help: a macro with this name exists at the root of the crate\n+    ///    |\n+    /// LL | use issue_59764::makro;\n+    ///    |     ^^^^^^^^^^^^^^^^^^\n+    ///    |\n+    ///    = note: this could be because a macro annotated with `#[macro_export]` will be exported\n+    ///            at the root of the crate instead of the module where it is defined\n+    /// ```\n+    pub(crate) fn check_for_module_export_macro(\n+        &self,\n+        directive: &'b ImportDirective<'b>,\n+        module: ModuleOrUniformRoot<'b>,\n+        ident: Ident,\n+    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+        let mut crate_module = if let ModuleOrUniformRoot::Module(module) = module {\n+            module\n+        } else {\n+            return None;\n+        };\n+\n+        while let Some(parent) = crate_module.parent {\n+            crate_module = parent;\n+        }\n+\n+        if ModuleOrUniformRoot::same_def(ModuleOrUniformRoot::Module(crate_module), module) {\n+            // Don't make a suggestion if the import was already from the root of the\n+            // crate.\n+            return None;\n+        }\n+\n+        let resolutions = crate_module.resolutions.borrow();\n+        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let binding = resolution.borrow().binding()?;\n+        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+            let name = crate_module.kind.name().unwrap();\n+            let suggestion = Some((\n+                directive.span,\n+                String::from(\"a macro with this name exists at the root of the crate\"),\n+                format!(\"{}::{}\", name, ident),\n+                Applicability::MaybeIncorrect,\n+            ));\n+            let note = vec![\n+                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+                 at the root of the crate instead of the module where it is defined\".to_string(),\n+            ];\n+            Some((suggestion, note))\n+        } else {\n+            None\n+        }\n+    }\n }"}, {"sha": "0fb1ca429835848e0fc5716f7cc0ef3cb105e086", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -1091,6 +1091,16 @@ enum ModuleKind {\n     Def(Def, Name),\n }\n \n+impl ModuleKind {\n+    /// Get name of the module.\n+    pub fn name(&self) -> Option<Name> {\n+        match self {\n+            ModuleKind::Block(..) => None,\n+            ModuleKind::Def(_, name) => Some(*name),\n+        }\n+    }\n+}\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,"}, {"sha": "6a01af5d1153a80962f837fd499949271b7085c6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -145,7 +145,7 @@ pub struct NameResolution<'a> {\n \n impl<'a> NameResolution<'a> {\n     // Returns the binding for the name if it is known or None if it not known.\n-    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+    pub(crate) fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| {\n             if !binding.is_glob_import() ||\n                self.single_imports.is_empty() { Some(binding) } else { None }\n@@ -636,7 +636,7 @@ impl<'a> Resolver<'a> {\n struct UnresolvedImportError {\n     span: Span,\n     label: Option<String>,\n-    note: Option<String>,\n+    note: Vec<String>,\n     suggestion: Option<Suggestion>,\n }\n \n@@ -756,8 +756,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         /// Upper limit on the number of `span_label` messages.\n         const MAX_LABEL_COUNT: usize = 10;\n \n-        let (span, msg, note) = if errors.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string(), None)\n+        let (span, msg) = if errors.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n         } else {\n             let span = MultiSpan::from_spans(\n                 errors\n@@ -766,11 +766,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     .collect(),\n             );\n \n-            let note = errors\n-                .iter()\n-                .filter_map(|(_, err)| err.note.as_ref())\n-                .last();\n-\n             let paths = errors\n                 .iter()\n                 .map(|(path, _)| format!(\"`{}`\", path))\n@@ -782,13 +777,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 paths.join(\", \"),\n             );\n \n-            (span, msg, note)\n+            (span, msg)\n         };\n \n         let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n \n-        if let Some(note) = &note {\n-            diag.note(note);\n+        if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n+            for message in note {\n+                diag.note(&message);\n+            }\n         }\n \n         for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n@@ -961,7 +958,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             UnresolvedImportError {\n                                 span,\n                                 label: Some(label),\n-                                note: None,\n+                                note: Vec::new(),\n                                 suggestion,\n                             }\n                         }\n@@ -1006,7 +1003,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         return Some(UnresolvedImportError {\n                             span: directive.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n+                            note: Vec::new(),\n                             suggestion: None,\n                         });\n                     }\n@@ -1114,15 +1111,22 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     }\n                 });\n \n-                let lev_suggestion =\n-                    find_best_match_for_name(names, &ident.as_str(), None).map(|suggestion| {\n-                        (\n-                            ident.span,\n-                            String::from(\"a similar name exists in the module\"),\n-                            suggestion.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                    });\n+                let (suggestion, note) = if let Some((suggestion, note)) =\n+                    self.check_for_module_export_macro(directive, module, ident)\n+                {\n+\n+                    (\n+                        suggestion.or_else(||\n+                           find_best_match_for_name(names, &ident.as_str(), None)\n+                           .map(|suggestion|\n+                                (ident.span, String::from(\"a similar name exists in the module\"),\n+                                 suggestion.to_string(), Applicability::MaybeIncorrect)\n+                            )),\n+                        note,\n+                    )\n+                } else {\n+                    (None, Vec::new())\n+                };\n \n                 let label = match module {\n                     ModuleOrUniformRoot::Module(module) => {\n@@ -1143,11 +1147,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         }\n                     }\n                 };\n+\n                 Some(UnresolvedImportError {\n                     span: directive.span,\n                     label: Some(label),\n-                    note: None,\n-                    suggestion: lev_suggestion,\n+                    note,\n+                    suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error."}, {"sha": "d7a01ce5f4d74ecd47f32f45034f8c2d0b01da04", "filename": "src/test/ui/issue-59764.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.fixed?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -0,0 +1,15 @@\n+// aux-build:issue-59764.rs\n+// compile-flags:--extern issue_59764\n+// edition:2018\n+// run-rustfix\n+\n+use issue_59764::makro;\n+//~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+\n+makro!(bar);\n+//~^ ERROR cannot determine resolution for the macro `makro`\n+\n+fn main() {\n+    bar();\n+    //~^ ERROR cannot find function `bar` in this scope [E0425]\n+}"}, {"sha": "e6f7205bfca338b6835d539e5adbe1b1493ee10f", "filename": "src/test/ui/issue-59764.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.rs?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -1,6 +1,7 @@\n // aux-build:issue-59764.rs\n // compile-flags:--extern issue_59764\n // edition:2018\n+// run-rustfix\n \n use issue_59764::foo::makro;\n //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]"}, {"sha": "6b3237e9272c5cdc5970e2a0518a9647626ce7ed", "filename": "src/test/ui/issue-59764.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d84907bbccf0430470ba7b8f121bb4f924cdffa4/src%2Ftest%2Fui%2Fissue-59764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.stderr?ref=d84907bbccf0430470ba7b8f121bb4f924cdffa4", "patch": "@@ -1,19 +1,25 @@\n error[E0432]: unresolved import `issue_59764::foo::makro`\n-  --> $DIR/issue-59764.rs:5:5\n+  --> $DIR/issue-59764.rs:6:5\n    |\n LL | use issue_59764::foo::makro;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL | use issue_59764::makro;\n+   |     ^^^^^^^^^^^^^^^^^^\n \n error: cannot determine resolution for the macro `makro`\n-  --> $DIR/issue-59764.rs:8:1\n+  --> $DIR/issue-59764.rs:9:1\n    |\n LL | makro!(bar);\n    | ^^^^^\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n error[E0425]: cannot find function `bar` in this scope\n-  --> $DIR/issue-59764.rs:12:5\n+  --> $DIR/issue-59764.rs:13:5\n    |\n LL |     bar();\n    |     ^^^ not found in this scope"}]}