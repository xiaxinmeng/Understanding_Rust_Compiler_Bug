{"sha": "f08d5ad4c59ca5fc1c961a94c53807d70959c375", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOGQ1YWQ0YzU5Y2E1ZmMxYzk2MWE5NGM1MzgwN2Q3MDk1OWMzNzU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-15T00:22:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-29T11:17:59Z"}, "message": "Refactor how spans are combined in the parser.", "tree": {"sha": "4f617f1b1ea1e1e442d54d4e8ef10e9f5fde8b15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f617f1b1ea1e1e442d54d4e8ef10e9f5fde8b15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f08d5ad4c59ca5fc1c961a94c53807d70959c375", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f08d5ad4c59ca5fc1c961a94c53807d70959c375", "html_url": "https://github.com/rust-lang/rust/commit/f08d5ad4c59ca5fc1c961a94c53807d70959c375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f08d5ad4c59ca5fc1c961a94c53807d70959c375/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec7c0aece17c9a11bc2eca15b994355a161bf878", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7c0aece17c9a11bc2eca15b994355a161bf878", "html_url": "https://github.com/rust-lang/rust/commit/ec7c0aece17c9a11bc2eca15b994355a161bf878"}], "stats": {"total": 801, "additions": 363, "deletions": 438}, "files": [{"sha": "8037570d24a808bb6ab7983d85d4ae7c4686d400", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -29,7 +29,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n-use syntax_pos::{mk_sp, Span};\n+use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n use rustc_back::slice;\n@@ -1468,8 +1468,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     self.resolve_lifetime_ref(bound);\n                 } else {\n                     self.insert_lifetime(bound, Region::Static);\n-                    let full_span = mk_sp(lifetime_i.lifetime.span.lo, bound.span.hi);\n-                    self.sess.struct_span_warn(full_span,\n+                    self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n                         &format!(\"unnecessary lifetime parameter `{}`\", lifetime_i.lifetime.name))\n                         .help(&format!(\"you can use the `'static` lifetime directly, in place \\\n                                         of `{}`\", lifetime_i.lifetime.name))"}, {"sha": "41a2e8a8d55e3e2da627f460fe7a5faef3e571b8", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -36,7 +36,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n-use syntax_pos::{mk_sp, Span};\n+use syntax_pos::{Span, NO_EXPANSION};\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n use rustc::hir;\n@@ -395,7 +395,7 @@ impl CrateStore for cstore::CStore {\n         let source_name = format!(\"<{} macros>\", name);\n \n         let filemap = sess.parse_sess.codemap().new_filemap(source_name, None, def.body);\n-        let local_span = mk_sp(filemap.start_pos, filemap.end_pos);\n+        let local_span = Span { lo: filemap.start_pos, hi: filemap.end_pos, ctxt: NO_EXPANSION };\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n \n         // Mark the attrs as used"}, {"sha": "43e076e799b3d07fedf223d537fdee94813e7666", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -39,7 +39,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::codemap;\n use syntax::ext::base::MacroKind;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n-            return Ok(syntax_pos::mk_sp(lo, hi));\n+            return Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION });\n         };\n \n         let (lo, hi) = if lo > hi {\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n         let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n \n-        Ok(syntax_pos::mk_sp(lo, hi))\n+        Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n     }\n }\n "}, {"sha": "1de9fbc8e4941f04e02d2de4c226c714050f7a31", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -742,7 +742,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let ident_start = text.find(&name).expect(\"Name not in signature?\");\n         let ident_end = ident_start + name.len();\n         Signature {\n-            span: mk_sp(item.span.lo, item.span.lo + BytePos(text.len() as u32)),\n+            span: Span { hi: item.span.lo + BytePos(text.len() as u32), ..item.span },\n             text: text,\n             ident_start: ident_start,\n             ident_end: ident_end,"}, {"sha": "af3efb48090810a602e53a51b6f634de54fa8744", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -305,10 +305,10 @@ impl<'a> SpanUtils<'a> {\n                 continue;\n             }\n             if let TokenTree::Token(_, token::Semi) = tok {\n-                return self.snippet(mk_sp(first_span.lo, prev.span().hi));\n+                return self.snippet(first_span.to(prev.span()));\n             } else if let TokenTree::Delimited(_, ref d) = tok {\n                 if d.delim == token::Brace {\n-                    return self.snippet(mk_sp(first_span.lo, prev.span().hi));\n+                    return self.snippet(first_span.to(prev.span()));\n                 }\n             }\n             prev = tok;"}, {"sha": "9eb86aa006d171f4ca0af868bdb13bd66921a237", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -17,7 +17,7 @@ pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n \n-use syntax_pos::{mk_sp, BytePos, Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::{Mark, SyntaxContext};\n@@ -1433,7 +1433,7 @@ impl Arg {\n                     TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n                         Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n-                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                    _ => Some(respan(self.pat.span.to(self.ty.span),\n                                      SelfKind::Explicit(self.ty.clone(), mutbl))),\n                 }\n             }\n@@ -1450,7 +1450,7 @@ impl Arg {\n     }\n \n     pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n-        let span = mk_sp(eself.span.lo, eself_ident.span.hi);\n+        let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n             node: TyKind::ImplicitSelf,\n@@ -1687,11 +1687,11 @@ pub struct PolyTraitRef {\n }\n \n impl PolyTraitRef {\n-    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, lo: BytePos, hi: BytePos) -> Self {\n+    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, span: Span) -> Self {\n         PolyTraitRef {\n             bound_lifetimes: lifetimes,\n             trait_ref: TraitRef { path: path, ref_id: DUMMY_NODE_ID },\n-            span: mk_sp(lo, hi),\n+            span: span,\n         }\n     }\n }"}, {"sha": "5dcce2572af878ac56375bd3df4e62c6ae50660e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -18,8 +18,8 @@ use ast;\n use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n-use codemap::{Spanned, spanned, dummy_spanned, mk_sp};\n-use syntax_pos::{Span, BytePos, DUMMY_SP};\n+use codemap::{Spanned, respan, dummy_spanned};\n+use syntax_pos::{Span, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -447,17 +447,16 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n-                           -> Attribute {\n+pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n-    let lit = spanned(lo, hi, LitKind::Str(text, ast::StrStyle::Cooked));\n+    let lit = respan(span, LitKind::Str(text, ast::StrStyle::Cooked));\n     Attribute {\n         id: id,\n         style: style,\n-        path: ast::Path::from_ident(mk_sp(lo, hi), ast::Ident::from_str(\"doc\")),\n-        tokens: MetaItemKind::NameValue(lit).tokens(mk_sp(lo, hi)),\n+        path: ast::Path::from_ident(span, ast::Ident::from_str(\"doc\")),\n+        tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n-        span: mk_sp(lo, hi),\n+        span: span,\n     }\n }\n "}, {"sha": "4d67390d442343da534036c7d30f049e8050af34", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -49,10 +49,6 @@ pub struct Spanned<T> {\n     pub span: Span,\n }\n \n-pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n-    respan(mk_sp(lo, hi), t)\n-}\n-\n pub fn respan<T>(sp: Span, t: T) -> Spanned<T> {\n     Spanned {node: t, span: sp}\n }"}, {"sha": "9ee427eed3556e949fb585bc60ea9d2cabe7edd3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -79,7 +79,7 @@ pub use self::ParseResult::*;\n use self::TokenTreeOrTokenTreeVec::*;\n \n use ast::Ident;\n-use syntax_pos::{self, BytePos, mk_sp, Span};\n+use syntax_pos::{self, BytePos, Span};\n use codemap::Spanned;\n use errors::FatalError;\n use ext::tt::quoted::{self, TokenTree};\n@@ -285,7 +285,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                     eof_eis: &mut SmallVector<Box<MatcherPos>>,\n                     bb_eis: &mut SmallVector<Box<MatcherPos>>,\n                     token: &Token,\n-                    span: &syntax_pos::Span)\n+                    span: syntax_pos::Span)\n                     -> ParseResult<()> {\n     while let Some(mut ei) = cur_eis.pop() {\n         // When unzipped trees end, remove them\n@@ -323,8 +323,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                     for idx in ei.match_lo..ei.match_hi {\n                         let sub = ei.matches[idx].clone();\n                         new_pos.matches[idx]\n-                            .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n-                                                                span.hi))));\n+                            .push(Rc::new(MatchedSeq(sub, Span { lo: ei.sp_lo, ..span })));\n                     }\n \n                     new_pos.match_cur = ei.match_hi;\n@@ -426,7 +425,7 @@ pub fn parse(sess: &ParseSess, tts: TokenStream, ms: &[TokenTree], directory: Op\n         assert!(next_eis.is_empty());\n \n         match inner_parse_loop(sess, &mut cur_eis, &mut next_eis, &mut eof_eis, &mut bb_eis,\n-                               &parser.token, &parser.span) {\n+                               &parser.token, parser.span) {\n             Success(_) => {},\n             Failure(sp, tok) => return Failure(sp, tok),\n             Error(sp, msg) => return Error(sp, msg),"}, {"sha": "92cec462ffb7cefbdd623490c125dab5a4e5f4bf", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -10,8 +10,7 @@\n \n use attr;\n use ast;\n-use syntax_pos::{mk_sp, Span};\n-use codemap::spanned;\n+use codemap::respan;\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token::{self, Nonterminal};\n@@ -49,8 +48,7 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -94,7 +92,7 @@ impl<'a> Parser<'a> {\n                self.token);\n         let (span, path, tokens, mut style) = match self.token {\n             token::Pound => {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 self.bump();\n \n                 if inner_parse_policy == InnerAttributeParsePolicy::Permitted {\n@@ -122,9 +120,9 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::OpenDelim(token::Bracket))?;\n                 let (path, tokens) = self.parse_path_and_tokens()?;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n-                (mk_sp(lo, hi), path, tokens, style)\n+                (lo.to(hi), path, tokens, style)\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n@@ -189,8 +187,7 @@ impl<'a> Parser<'a> {\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n-                    let Span { lo, hi, .. } = self.span;\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, self.span);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n@@ -238,11 +235,10 @@ impl<'a> Parser<'a> {\n             return Ok(meta);\n         }\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let ident = self.parse_ident()?;\n         let node = self.parse_meta_item_kind()?;\n-        let hi = self.prev_span.hi;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: lo.to(self.prev_span) })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n@@ -258,26 +254,25 @@ impl<'a> Parser<'a> {\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n-        let sp = self.span;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => {\n-                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::Literal(lit)))\n+                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::Literal(lit)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n-                return Ok(spanned(lo, self.prev_span.hi, ast::NestedMetaItemKind::MetaItem(mi)))\n+                return Ok(respan(lo.to(self.prev_span), ast::NestedMetaItemKind::MetaItem(mi)))\n             }\n             Err(ref mut err) => self.diagnostic().cancel(err)\n         }\n \n         let found = self.this_token_to_string();\n         let msg = format!(\"expected unsuffixed literal or identifier, found {}\", found);\n-        Err(self.diagnostic().struct_span_err(sp, &msg))\n+        Err(self.diagnostic().struct_span_err(lo, &msg))\n     }\n \n     /// matches meta_seq = ( COMMASEP(meta_item_inner) )"}, {"sha": "920b2c401e2bd2914c6806ee1887675617059d32", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{self, Ident};\n-use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n+use syntax_pos::{self, BytePos, CharPos, Pos, Span, NO_EXPANSION};\n use codemap::CodeMap;\n use errors::{FatalError, DiagnosticBuilder};\n use parse::{token, ParseSess};\n@@ -68,6 +68,10 @@ pub struct StringReader<'a> {\n     open_braces: Vec<(token::DelimToken, Span)>,\n }\n \n+fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n+    Span { lo: lo, hi: hi, ctxt: NO_EXPANSION }\n+}\n+\n impl<'a> StringReader<'a> {\n     fn next_token(&mut self) -> TokenAndSpan where Self: Sized {\n         let res = self.try_next_token();\n@@ -225,12 +229,12 @@ impl<'a> StringReader<'a> {\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n     fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n-        self.fatal_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n+        self.fatal_span(mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`).\n     fn err_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) {\n-        self.err_span(syntax_pos::mk_sp(from_pos, to_pos), m)\n+        self.err_span(mk_sp(from_pos, to_pos), m)\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -254,7 +258,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.sess.span_diagnostic.struct_span_fatal(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n+        self.sess.span_diagnostic.struct_span_fatal(mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -278,7 +282,7 @@ impl<'a> StringReader<'a> {\n         for c in c.escape_default() {\n             m.push(c)\n         }\n-        self.sess.span_diagnostic.struct_span_err(syntax_pos::mk_sp(from_pos, to_pos), &m[..])\n+        self.sess.span_diagnostic.struct_span_err(mk_sp(from_pos, to_pos), &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -302,11 +306,11 @@ impl<'a> StringReader<'a> {\n             None => {\n                 if self.is_eof() {\n                     self.peek_tok = token::Eof;\n-                    self.peek_span = syntax_pos::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n+                    self.peek_span = mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n                 } else {\n                     let start_bytepos = self.pos;\n                     self.peek_tok = self.next_token_inner()?;\n-                    self.peek_span = syntax_pos::mk_sp(start_bytepos, self.pos);\n+                    self.peek_span = mk_sp(start_bytepos, self.pos);\n                 };\n             }\n         }\n@@ -489,7 +493,7 @@ impl<'a> StringReader<'a> {\n         if let Some(c) = self.ch {\n             if c.is_whitespace() {\n                 let msg = \"called consume_any_line_comment, but there was whitespace\";\n-                self.sess.span_diagnostic.span_err(syntax_pos::mk_sp(self.pos, self.pos), msg);\n+                self.sess.span_diagnostic.span_err(mk_sp(self.pos, self.pos), msg);\n             }\n         }\n \n@@ -532,13 +536,13 @@ impl<'a> StringReader<'a> {\n \n                             Some(TokenAndSpan {\n                                 tok: tok,\n-                                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                                sp: mk_sp(start_bpos, self.pos),\n                             })\n                         })\n                     } else {\n                         Some(TokenAndSpan {\n                             tok: token::Comment,\n-                            sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                            sp: mk_sp(start_bpos, self.pos),\n                         })\n                     };\n                 }\n@@ -571,7 +575,7 @@ impl<'a> StringReader<'a> {\n                     }\n                     return Some(TokenAndSpan {\n                         tok: token::Shebang(self.name_from(start)),\n-                        sp: syntax_pos::mk_sp(start, self.pos),\n+                        sp: mk_sp(start, self.pos),\n                     });\n                 }\n             }\n@@ -599,7 +603,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 let c = Some(TokenAndSpan {\n                     tok: token::Whitespace,\n-                    sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                    sp: mk_sp(start_bpos, self.pos),\n                 });\n                 debug!(\"scanning whitespace: {:?}\", c);\n                 c\n@@ -661,7 +665,7 @@ impl<'a> StringReader<'a> {\n \n             Some(TokenAndSpan {\n                 tok: tok,\n-                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n+                sp: mk_sp(start_bpos, self.pos),\n             })\n         })\n     }\n@@ -858,7 +862,7 @@ impl<'a> StringReader<'a> {\n                                 let valid = if self.ch_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n-                                    let span = syntax_pos::mk_sp(start, self.pos);\n+                                    let span = mk_sp(start, self.pos);\n                                     self.sess.span_diagnostic\n                                         .struct_span_err(span, \"incorrect unicode escape sequence\")\n                                         .span_help(span,\n@@ -896,13 +900,13 @@ impl<'a> StringReader<'a> {\n                                                                         },\n                                                                         c);\n                                 if e == '\\r' {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n+                                    err.span_help(mk_sp(escaped_pos, pos),\n                                                   \"this is an isolated carriage return; consider \\\n                                                    checking your editor and version control \\\n                                                    settings\");\n                                 }\n                                 if (e == '{' || e == '}') && !ascii_only {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n+                                    err.span_help(mk_sp(escaped_pos, pos),\n                                                   \"if used in a formatting string, curly braces \\\n                                                    are escaped with `{{` and `}}`\");\n                                 }\n@@ -1735,7 +1739,7 @@ mod tests {\n             sp: Span {\n                 lo: BytePos(21),\n                 hi: BytePos(23),\n-                expn_id: NO_EXPANSION,\n+                ctxt: NO_EXPANSION,\n             },\n         };\n         assert_eq!(tok1, tok2);\n@@ -1749,7 +1753,7 @@ mod tests {\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n-                expn_id: NO_EXPANSION,\n+                ctxt: NO_EXPANSION,\n             },\n         };\n         assert_eq!(tok3, tok4);\n@@ -1908,7 +1912,7 @@ mod tests {\n         let mut lexer = setup(&cm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n         let comment = lexer.next_token();\n         assert_eq!(comment.tok, token::Comment);\n-        assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n+        assert_eq!((comment.sp.lo, comment.sp.hi), (BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n                    token::DocComment(Symbol::intern(\"/// test\")));"}, {"sha": "4df23da3c9ce3464bf1cb760352e5bd7df68b144", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -11,7 +11,7 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/revision-06/confusables.txt\n \n-use syntax_pos::mk_sp as make_span;\n+use syntax_pos::{Span, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n use super::StringReader;\n \n@@ -234,7 +234,7 @@ pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n     .map(|&(_, u_name, ascii_char)| {\n-        let span = make_span(reader.pos, reader.next_pos);\n+        let span = Span { lo: reader.pos, hi: reader.next_pos, ctxt: NO_EXPANSION };\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n                 let msg ="}, {"sha": "b5d0a46de492613a341d56973fde5843bdfb1701", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -12,7 +12,7 @@\n \n use ast::{self, CrateConfig};\n use codemap::CodeMap;\n-use syntax_pos::{self, Span, FileMap};\n+use syntax_pos::{self, Span, FileMap, NO_EXPANSION};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -178,7 +178,7 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Par\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap));\n \n     if parser.token == token::Eof && parser.span == syntax_pos::DUMMY_SP {\n-        parser.span = syntax_pos::mk_sp(end_pos, end_pos);\n+        parser.span = Span { lo: end_pos, hi: end_pos, ctxt: NO_EXPANSION };\n     }\n \n     parser\n@@ -665,7 +665,7 @@ mod tests {\n \n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n-        Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n+        Span {lo: BytePos(a), hi: BytePos(b), ctxt: NO_EXPANSION}\n     }\n \n     fn str2seg(s: &str, lo: u32, hi: u32) -> ast::PathSegment {"}, {"sha": "b0611d7529062fd1275fc9c520a9da059e91eb8a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 281, "deletions": 336, "changes": 617, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -40,8 +40,8 @@ use ast::{Visibility, WhereClause};\n use ast::{BinOpKind, UnOp};\n use ast::RangeEnd;\n use {ast, attr};\n-use codemap::{self, CodeMap, Spanned, spanned, respan};\n-use syntax_pos::{self, Span, BytePos, mk_sp};\n+use codemap::{self, CodeMap, Spanned, respan};\n+use syntax_pos::{self, Span, BytePos};\n use errors::{self, DiagnosticBuilder};\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n@@ -108,13 +108,13 @@ macro_rules! maybe_whole_expr {\n                     $p.bump();\n                     let span = $p.span;\n                     let kind = ExprKind::Path(None, (*path).clone());\n-                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n                 }\n                 token::NtBlock(ref block) => {\n                     $p.bump();\n                     let span = $p.span;\n                     let kind = ExprKind::Block((*block).clone());\n-                    return Ok($p.mk_expr(span.lo, span.hi, kind, ThinVec::new()));\n+                    return Ok($p.mk_expr(span, kind, ThinVec::new()));\n                 }\n                 _ => {},\n             };\n@@ -731,7 +731,7 @@ impl<'a> Parser<'a> {\n             token::AndAnd => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::BinOp(token::And), lo, span.hi))\n+                Ok(self.bump_with(token::BinOp(token::And), Span { lo: lo, ..span }))\n             }\n             _ => self.unexpected()\n         }\n@@ -765,7 +765,7 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Shl) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                self.bump_with(token::Lt, lo, span.hi);\n+                self.bump_with(token::Lt, Span { lo: lo, ..span });\n                 true\n             }\n             _ => false,\n@@ -793,17 +793,17 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Shr) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Gt, lo, span.hi))\n+                Ok(self.bump_with(token::Gt, Span { lo: lo, ..span }))\n             }\n             token::BinOpEq(token::Shr) => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Ge, lo, span.hi))\n+                Ok(self.bump_with(token::Ge, Span { lo: lo, ..span }))\n             }\n             token::Ge => {\n                 let span = self.span;\n                 let lo = span.lo + BytePos(1);\n-                Ok(self.bump_with(token::Eq, lo, span.hi))\n+                Ok(self.bump_with(token::Eq, Span { lo: lo, ..span }))\n             }\n             _ => self.unexpected()\n         }\n@@ -997,12 +997,12 @@ impl<'a> Parser<'a> {\n                            -> PResult<'a, Spanned<Vec<T>>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         self.expect(bra)?;\n         let result = self.parse_seq_to_before_end(ket, sep, f);\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.bump();\n-        Ok(spanned(lo, hi, result))\n+        Ok(respan(lo.to(hi), result))\n     }\n \n     /// Advance the parser by one token\n@@ -1033,16 +1033,13 @@ impl<'a> Parser<'a> {\n \n     /// Advance the parser using provided token as a next one. Use this when\n     /// consuming a part of a token. For example a single `<` from `<<`.\n-    pub fn bump_with(&mut self,\n-                     next: token::Token,\n-                     lo: BytePos,\n-                     hi: BytePos) {\n-        self.prev_span = mk_sp(self.span.lo, lo);\n+    pub fn bump_with(&mut self, next: token::Token, span: Span) {\n+        self.prev_span = Span { hi: span.lo, ..self.span };\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n         // prev_token_kind will be of no use anyway.\n         self.prev_token_kind = PrevTokenKind::Other;\n-        self.span = mk_sp(lo, hi);\n+        self.span = span;\n         self.token = next;\n         self.expected_tokens.clear();\n     }\n@@ -1173,7 +1170,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_trait_item(&mut self) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n         let mut attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let TyParam {ident, bounds, default, ..} = self.parse_ty_param(vec![])?;\n@@ -1197,7 +1194,7 @@ impl<'a> Parser<'a> {\n         } else if self.token.is_path_start() {\n             // trait item macro.\n             // code copied from parse_macro_use_or_failure... abstraction!\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n@@ -1207,7 +1204,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac))\n         } else {\n             let (constness, unsafety, abi) = match self.parse_fn_front_matter() {\n@@ -1277,7 +1274,7 @@ impl<'a> Parser<'a> {\n             ident: name,\n             attrs: attrs,\n             node: node,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n         })\n     }\n \n@@ -1298,8 +1295,7 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::RArrow) {\n             Ok(FunctionRetTy::Ty(self.parse_ty_no_plus()?))\n         } else {\n-            let pos = self.span.lo;\n-            Ok(FunctionRetTy::Default(mk_sp(pos, pos)))\n+            Ok(FunctionRetTy::Default(Span { hi: self.span.lo, ..self.span }))\n         }\n     }\n \n@@ -1320,7 +1316,7 @@ impl<'a> Parser<'a> {\n     fn parse_ty_common(&mut self, allow_plus: bool) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let node = if self.eat(&token::OpenDelim(token::Paren)) {\n             // `(TYPE)` is a parenthesized type.\n             // `(TYPE,)` is a tuple with a single field of type TYPE.\n@@ -1344,7 +1340,7 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, ref path)\n                             if allow_plus && self.token == token::BinOp(token::Plus) => {\n                         self.bump(); // `+`\n-                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo, self.prev_span.hi);\n+                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo.to(self.prev_span));\n                         let mut bounds = vec![TraitTyParamBound(pt, TraitBoundModifier::None)];\n                         bounds.append(&mut self.parse_ty_param_bounds()?);\n                         TyKind::TraitObject(bounds)\n@@ -1394,13 +1390,13 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n                 let (_, tts) = self.expect_delimited_token_tree()?;\n-                TyKind::Mac(spanned(lo, self.span.hi, Mac_ { path: path, tts: tts }))\n+                TyKind::Mac(respan(lo.to(self.span), Mac_ { path: path, tts: tts }))\n             } else {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n                 //   `Trait1 + Trait2 + 'a`\n                 if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo, self.prev_span.hi);\n+                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo.to(self.prev_span));\n                     let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n                     bounds.append(&mut self.parse_ty_param_bounds()?);\n                     TyKind::TraitObject(bounds)\n@@ -1415,13 +1411,13 @@ impl<'a> Parser<'a> {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n             if self.token_is_bare_fn_keyword() {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n                 let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n                 if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n                     bounds.append(&mut self.parse_ty_param_bounds()?)\n@@ -1440,7 +1436,7 @@ impl<'a> Parser<'a> {\n             return Err(self.fatal(&msg));\n         };\n \n-        let span = mk_sp(lo, self.prev_span.hi);\n+        let span = lo.to(self.prev_span);\n         let ty = Ty { node: node, span: span, id: ast::DUMMY_NODE_ID };\n \n         // Try to recover from use of `+` with incorrect priority.\n@@ -1457,7 +1453,7 @@ impl<'a> Parser<'a> {\n \n         self.bump(); // `+`\n         let bounds = self.parse_ty_param_bounds()?;\n-        let sum_span = mk_sp(ty.span.lo, self.prev_span.hi);\n+        let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, ty.span, E0178,\n             \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(&ty));\n@@ -1577,7 +1573,7 @@ impl<'a> Parser<'a> {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n                 node: TyKind::Infer,\n-                span: mk_sp(self.span.lo, self.span.hi),\n+                span: self.span,\n             })\n         };\n         Ok(Arg {\n@@ -1625,7 +1621,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches lit = true | false | token_lit\n     pub fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let lit = if self.eat_keyword(keywords::True) {\n             LitKind::Bool(true)\n         } else if self.eat_keyword(keywords::False) {\n@@ -1634,22 +1630,22 @@ impl<'a> Parser<'a> {\n             let lit = self.parse_lit_token()?;\n             lit\n         };\n-        Ok(codemap::Spanned { node: lit, span: mk_sp(lo, self.prev_span.hi) })\n+        Ok(codemap::Spanned { node: lit, span: lo.to(self.prev_span) })\n     }\n \n     /// matches '-' lit | lit\n     pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n-        let minus_lo = self.span.lo;\n+        let minus_lo = self.span;\n         let minus_present = self.eat(&token::BinOp(token::Minus));\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let literal = P(self.parse_lit()?);\n-        let hi = self.prev_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprKind::Lit(literal), ThinVec::new());\n+        let hi = self.prev_span;\n+        let expr = self.mk_expr(lo.to(hi), ExprKind::Lit(literal), ThinVec::new());\n \n         if minus_present {\n-            let minus_hi = self.prev_span.hi;\n+            let minus_hi = self.prev_span;\n             let unary = self.mk_unary(UnOp::Neg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary, ThinVec::new()))\n+            Ok(self.mk_expr(minus_lo.to(minus_hi), unary, ThinVec::new()))\n         } else {\n             Ok(expr)\n         }\n@@ -1726,7 +1722,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n         maybe_whole!(self, NtPath, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let is_global = self.eat(&token::ModSep);\n \n         // Parse any number of segments and bound sets. A segment is an\n@@ -1750,7 +1746,7 @@ impl<'a> Parser<'a> {\n \n         // Assemble the span.\n         // FIXME(#39450) This is bogus if part of the path is macro generated.\n-        let span = mk_sp(lo, self.prev_span.hi);\n+        let span = lo.to(self.prev_span);\n \n         // Assemble the result.\n         Ok(ast::Path {\n@@ -1791,7 +1787,7 @@ impl<'a> Parser<'a> {\n                     bindings: bindings,\n                 }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n-                let lo = self.prev_span.lo;\n+                let lo = self.prev_span;\n \n                 let inputs = self.parse_seq_to_end(\n                     &token::CloseDelim(token::Paren),\n@@ -1804,10 +1800,10 @@ impl<'a> Parser<'a> {\n                     None\n                 };\n \n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n                 Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n-                    span: mk_sp(lo, hi),\n+                    span: lo.to(hi),\n                     inputs: inputs,\n                     output: output_ty,\n                 })))\n@@ -1928,38 +1924,37 @@ impl<'a> Parser<'a> {\n     /// Parse ident (COLON expr)?\n     pub fn parse_field(&mut self) -> PResult<'a, Field> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let hi;\n \n         // Check if a colon exists one ahead. This means we're parsing a fieldname.\n         let (fieldname, expr, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            hi = self.prev_span.hi;\n+            hi = self.prev_span;\n             (fieldname, self.parse_expr()?, false)\n         } else {\n             let fieldname = self.parse_ident()?;\n-            hi = self.prev_span.hi;\n+            hi = self.prev_span;\n \n             // Mimic `x: x` for the `x` field shorthand.\n-            let path = ast::Path::from_ident(mk_sp(lo, hi), fieldname);\n-            (fieldname, self.mk_expr(lo, hi, ExprKind::Path(None, path), ThinVec::new()), true)\n+            let path = ast::Path::from_ident(lo.to(hi), fieldname);\n+            (fieldname, self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new()), true)\n         };\n         Ok(ast::Field {\n-            ident: spanned(lo, hi, fieldname),\n-            span: mk_sp(lo, expr.span.hi),\n+            ident: respan(lo.to(hi), fieldname),\n+            span: lo.to(expr.span),\n             expr: expr,\n             is_shorthand: is_shorthand,\n             attrs: attrs.into(),\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: ExprKind, attrs: ThinVec<Attribute>)\n-                   -> P<Expr> {\n+    pub fn mk_expr(&mut self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n-            span: mk_sp(lo, hi),\n+            span: span,\n             attrs: attrs.into(),\n         })\n     }\n@@ -2013,12 +2008,11 @@ impl<'a> Parser<'a> {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n-                       m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    pub fn mk_mac_expr(&mut self, span: Span, m: Mac_, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n-            node: ExprKind::Mac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n-            span: mk_sp(lo, hi),\n+            node: ExprKind::Mac(codemap::Spanned {node: m, span: span}),\n+            span: span,\n             attrs: attrs,\n         })\n     }\n@@ -2065,8 +2059,8 @@ impl<'a> Parser<'a> {\n         // attributes by giving them a empty \"already parsed\" list.\n         let mut attrs = ThinVec::new();\n \n-        let lo = self.span.lo;\n-        let mut hi = self.span.hi;\n+        let lo = self.span;\n+        let mut hi = self.span;\n \n         let ex: ExprKind;\n \n@@ -2095,18 +2089,19 @@ impl<'a> Parser<'a> {\n                 }\n                 self.bump();\n \n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n+                let span = lo.to(hi);\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n+                    Ok(self.mk_expr(span, ExprKind::Paren(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprKind::Tup(es), attrs))\n+                    Ok(self.mk_expr(span, ExprKind::Tup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n                 return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n             },\n             token::OpenDelim(token::Bracket) => {\n@@ -2144,34 +2139,34 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Array(vec![first_expr]);\n                     }\n                 }\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n             }\n             _ => {\n                 if self.eat_lt() {\n                     let (qself, path) =\n                         self.parse_qualified_path(PathStyle::Expr)?;\n-                    hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprKind::Path(Some(qself), path), attrs));\n+                    hi = path.span;\n+                    return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n                 if self.eat_keyword(keywords::Move) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_lambda_expr(lo, CaptureBy::Value, attrs);\n                 }\n                 if self.eat_keyword(keywords::If) {\n                     return self.parse_if_expr(attrs);\n                 }\n                 if self.eat_keyword(keywords::For) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_for_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::While) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n                     let label = Spanned { node: self.get_label(),\n                                           span: self.span };\n-                    let lo = self.span.lo;\n+                    let lo = self.span;\n                     self.bump();\n                     self.expect(&token::Colon)?;\n                     if self.eat_keyword(keywords::While) {\n@@ -2186,7 +2181,7 @@ impl<'a> Parser<'a> {\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if self.eat_keyword(keywords::Loop) {\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Continue) {\n@@ -2200,8 +2195,8 @@ impl<'a> Parser<'a> {\n                     } else {\n                         ExprKind::Continue(None)\n                     };\n-                    let hi = self.prev_span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ex, attrs));\n+                    let hi = self.prev_span;\n+                    return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n                 }\n                 if self.eat_keyword(keywords::Match) {\n                     return self.parse_match_expr(attrs);\n@@ -2215,13 +2210,13 @@ impl<'a> Parser<'a> {\n                 if self.is_catch_expr() {\n                     assert!(self.eat_keyword(keywords::Do));\n                     assert!(self.eat_keyword(keywords::Catch));\n-                    let lo = self.prev_span.lo;\n+                    let lo = self.prev_span;\n                     return self.parse_catch_expr(lo, attrs);\n                 }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n-                        hi = e.span.hi;\n+                        hi = e.span;\n                         ex = ExprKind::Ret(Some(e));\n                     } else {\n                         ex = ExprKind::Ret(None);\n@@ -2246,7 +2241,7 @@ impl<'a> Parser<'a> {\n                         None\n                     };\n                     ex = ExprKind::Break(lt, e);\n-                    hi = self.prev_span.hi;\n+                    hi = self.prev_span;\n                 } else if self.token.is_keyword(keywords::Let) {\n                     // Catch this syntax error here, instead of in `check_strict_keywords`, so\n                     // that we can explicitly mention that let is not to be used as an expression\n@@ -2260,8 +2255,8 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n                         let (_, tts) = self.expect_delimited_token_tree()?;\n-                        let hi = self.prev_span.hi;\n-                        return Ok(self.mk_mac_expr(lo, hi, Mac_ { path: pth, tts: tts }, attrs));\n+                        let hi = self.prev_span;\n+                        return Ok(self.mk_mac_expr(lo.to(hi), Mac_ { path: pth, tts: tts }, attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2274,12 +2269,12 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n \n-                    hi = pth.span.hi;\n+                    hi = pth.span;\n                     ex = ExprKind::Path(None, pth);\n                 } else {\n                     match self.parse_lit() {\n                         Ok(lit) => {\n-                            hi = lit.span.hi;\n+                            hi = lit.span;\n                             ex = ExprKind::Lit(P(lit));\n                         }\n                         Err(mut err) => {\n@@ -2293,10 +2288,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n     }\n \n-    fn parse_struct_expr(&mut self, lo: BytePos, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n+    fn parse_struct_expr(&mut self, lo: Span, pth: ast::Path, mut attrs: ThinVec<Attribute>)\n                          -> PResult<'a, P<Expr>> {\n         self.bump();\n         let mut fields = Vec::new();\n@@ -2338,9 +2333,9 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.span.hi;\n+        let span = lo.to(self.span);\n         self.expect(&token::CloseDelim(token::Brace))?;\n-        return Ok(self.mk_expr(lo, hi, ExprKind::Struct(pth, fields, base), attrs));\n+        return Ok(self.mk_expr(span, ExprKind::Struct(pth, fields, base), attrs));\n     }\n \n     fn parse_or_use_outer_attributes(&mut self,\n@@ -2354,7 +2349,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a block or unsafe block\n-    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n+    pub fn parse_block_expr(&mut self, lo: Span, blk_mode: BlockCheckMode,\n                             outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n \n@@ -2364,7 +2359,7 @@ impl<'a> Parser<'a> {\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), attrs));\n+        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n@@ -2375,12 +2370,12 @@ impl<'a> Parser<'a> {\n \n         let b = self.parse_bottom_expr();\n         let (span, b) = self.interpolated_or_expr_span(b)?;\n-        self.parse_dot_or_call_expr_with(b, span.lo, attrs)\n+        self.parse_dot_or_call_expr_with(b, span, attrs)\n     }\n \n     pub fn parse_dot_or_call_expr_with(&mut self,\n                                        e0: P<Expr>,\n-                                       lo: BytePos,\n+                                       lo: Span,\n                                        mut attrs: ThinVec<Attribute>)\n                                        -> PResult<'a, P<Expr>> {\n         // Stitch the list of outer attributes onto the return value.\n@@ -2411,11 +2406,7 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.foo` (i.e., a dot and an ident), continue\n     // parsing into an expression.\n-    fn parse_dot_suffix(&mut self,\n-                        ident: Ident,\n-                        ident_span: Span,\n-                        self_value: P<Expr>,\n-                        lo: BytePos)\n+    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>, lo: Span)\n                         -> PResult<'a, P<Expr>> {\n         let (_, tys, bindings) = if self.eat(&token::ModSep) {\n             self.expect_lt()?;\n@@ -2440,12 +2431,12 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                let hi = self.prev_span.hi;\n+                let hi = self.prev_span;\n \n                 es.insert(0, self_value);\n-                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let id = respan(ident_span.to(ident_span), ident);\n                 let nd = self.mk_method_call(id, tys, es);\n-                self.mk_expr(lo, hi, nd, ThinVec::new())\n+                self.mk_expr(lo.to(hi), nd, ThinVec::new())\n             }\n             // Field access.\n             _ => {\n@@ -2456,49 +2447,47 @@ impl<'a> Parser<'a> {\n                                    have type parameters\");\n                 }\n \n-                let id = spanned(ident_span.lo, ident_span.hi, ident);\n+                let id = respan(ident_span.to(ident_span), ident);\n                 let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo, ident_span.hi, field, ThinVec::new())\n+                self.mk_expr(lo.to(ident_span), field, ThinVec::new())\n             }\n         })\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: BytePos) -> PResult<'a, P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n         loop {\n             // expr?\n             while self.eat(&token::Question) {\n-                let hi = self.prev_span.hi;\n-                e = self.mk_expr(lo, hi, ExprKind::Try(e), ThinVec::new());\n+                let hi = self.prev_span;\n+                e = self.mk_expr(lo.to(hi), ExprKind::Try(e), ThinVec::new());\n             }\n \n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n                   token::Ident(i) => {\n-                    let dot_pos = self.prev_span.hi;\n-                    hi = self.span.hi;\n+                    let ident_span = self.span;\n                     self.bump();\n-\n-                    e = self.parse_dot_suffix(i, mk_sp(dot_pos, hi), e, lo)?;\n+                    e = self.parse_dot_suffix(i, ident_span, e, lo)?;\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n \n                     // A tuple index may not have a suffix\n                     self.expect_no_suffix(sp, \"tuple index\", suf);\n \n-                    let dot = self.prev_span.hi;\n-                    hi = self.span.hi;\n+                    let dot_span = self.prev_span;\n+                    hi = self.span;\n                     self.bump();\n \n                     let index = n.as_str().parse::<usize>().ok();\n                     match index {\n                         Some(n) => {\n-                            let id = spanned(dot, hi, n);\n+                            let id = respan(dot_span.to(hi), n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field, ThinVec::new());\n+                            e = self.mk_expr(lo.to(hi), field, ThinVec::new());\n                         }\n                         None => {\n                             let prev_span = self.prev_span;\n@@ -2541,10 +2530,8 @@ impl<'a> Parser<'a> {\n                     let actual = self.this_token_to_string();\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n \n-                    let dot_pos = self.prev_span.hi;\n-                    e = self.parse_dot_suffix(keywords::Invalid.ident(),\n-                                              mk_sp(dot_pos, dot_pos),\n-                                              e, lo)?;\n+                    let dot_span = self.prev_span;\n+                    e = self.parse_dot_suffix(keywords::Invalid.ident(), dot_span, e, lo)?;\n                   }\n                 }\n                 continue;\n@@ -2559,21 +2546,21 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd, ThinVec::new());\n+                e = self.mk_expr(lo.to(hi), nd, ThinVec::new());\n               }\n \n               // expr[...]\n               // Could be either an index expression or a slicing expression.\n               token::OpenDelim(token::Bracket) => {\n                 self.bump();\n                 let ix = self.parse_expr()?;\n-                hi = self.span.hi;\n+                hi = self.span;\n                 self.expect(&token::CloseDelim(token::Bracket))?;\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index, ThinVec::new())\n+                e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n               }\n               _ => return Ok(e)\n             }\n@@ -2635,38 +2622,33 @@ impl<'a> Parser<'a> {\n                              already_parsed_attrs: Option<ThinVec<Attribute>>)\n                              -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span.lo;\n-        let hi;\n+        let lo = self.span;\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n-        let ex = match self.token {\n+        let (hi, ex) = match self.token {\n             token::Not => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Not, e)\n+                (span, self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Neg, e)\n+                (span, self.mk_unary(UnOp::Neg, e))\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                self.mk_unary(UnOp::Deref, e)\n+                (span, self.mk_unary(UnOp::Deref, e))\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 self.expect_and()?;\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                ExprKind::AddrOf(m, e)\n+                (span, ExprKind::AddrOf(m, e))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 self.bump();\n@@ -2676,20 +2658,18 @@ impl<'a> Parser<'a> {\n                 )?;\n                 let blk = self.parse_block()?;\n                 let span = blk.span;\n-                hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, hi, ExprKind::Block(blk), ThinVec::new());\n-                ExprKind::InPlace(place, blk_expr)\n+                let blk_expr = self.mk_expr(span, ExprKind::Block(blk), ThinVec::new());\n+                (span, ExprKind::InPlace(place, blk_expr))\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n-                hi = span.hi;\n-                ExprKind::Box(e)\n+                (span, ExprKind::Box(e))\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n-        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ex, attrs));\n     }\n \n     /// Parse an associative expression\n@@ -2750,13 +2730,11 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = self.parse_ty_no_plus()?;\n-                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n-                lhs = self.mk_expr(lo, hi, ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Cast(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty_no_plus()?;\n-                let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n-                lhs = self.mk_expr(lo, hi, ExprKind::Type(lhs, rhs), ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Type(lhs, rhs), ThinVec::new());\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotDot {\n                 // If we didn\u2019t have to handle `x..`/`x...`, it would be pretty easy to\n@@ -2782,7 +2760,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let r = try!(self.mk_range(Some(lhs), rhs, limits));\n-                lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, ThinVec::new());\n+                lhs = self.mk_expr(lhs_span.to(rhs_span), r, ThinVec::new());\n                 break\n             }\n \n@@ -2809,7 +2787,7 @@ impl<'a> Parser<'a> {\n                 }),\n             }?;\n \n-            let (lo, hi) = (lhs_span.lo, rhs.span.hi);\n+            let span = lhs_span.to(rhs.span);\n             lhs = match op {\n                 AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide |\n                 AssocOp::Modulus | AssocOp::LAnd | AssocOp::LOr | AssocOp::BitXor |\n@@ -2818,12 +2796,12 @@ impl<'a> Parser<'a> {\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lo, hi, binary, ThinVec::new())\n+                    self.mk_expr(span, binary, ThinVec::new())\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lo, hi, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n+                    self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lo, hi, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n+                    self.mk_expr(span, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,\n@@ -2838,7 +2816,7 @@ impl<'a> Parser<'a> {\n                         token::Shr =>     BinOpKind::Shr,\n                     };\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lo, hi, aopexpr, ThinVec::new())\n+                    self.mk_expr(span, aopexpr, ThinVec::new())\n                 }\n                 AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotDot => {\n                     self.bug(\"As, Colon, DotDot or DotDotDot branch reached\")\n@@ -2858,7 +2836,7 @@ impl<'a> Parser<'a> {\n         match lhs.node {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n-                let op_span = mk_sp(op.span.lo, self.span.hi);\n+                let op_span = op.span.to(self.span);\n                 let mut err = self.diagnostic().struct_span_err(op_span,\n                     \"chained comparison operators require parentheses\");\n                 if op.node == BinOpKind::Lt &&\n@@ -2881,16 +2859,16 @@ impl<'a> Parser<'a> {\n         debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n-        let lo = self.span.lo;\n-        let mut hi = self.span.hi;\n+        let lo = self.span;\n+        let mut hi = self.span;\n         self.bump();\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than the dots.\n             let next_prec = AssocOp::from_token(&tok).unwrap().precedence() + 1;\n             Some(self.parse_assoc_expr_with(next_prec,\n                                             LhsExpr::NotYetParsed)\n                 .map(|x|{\n-                    hi = x.span.hi;\n+                    hi = x.span;\n                     x\n                 })?)\n          } else {\n@@ -2905,7 +2883,7 @@ impl<'a> Parser<'a> {\n         let r = try!(self.mk_range(None,\n                                    opt_end,\n                                    limits));\n-        Ok(self.mk_expr(lo, hi, r, attrs))\n+        Ok(self.mk_expr(lo.to(hi), r, attrs))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -2925,60 +2903,59 @@ impl<'a> Parser<'a> {\n         if self.check_keyword(keywords::Let) {\n             return self.parse_if_let_expr(attrs);\n         }\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n-        let mut hi = thn.span.hi;\n+        let mut hi = thn.span;\n         if self.eat_keyword(keywords::Else) {\n             let elexpr = self.parse_else_expr()?;\n-            hi = elexpr.span.hi;\n+            hi = elexpr.span;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprKind::If(cond, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::If(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n     pub fn parse_if_let_expr(&mut self, attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>> {\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let thn = self.parse_block()?;\n         let (hi, els) = if self.eat_keyword(keywords::Else) {\n             let expr = self.parse_else_expr()?;\n-            (expr.span.hi, Some(expr))\n+            (expr.span, Some(expr))\n         } else {\n-            (thn.span.hi, None)\n+            (thn.span, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprKind::IfLet(pat, expr, thn, els), attrs))\n+        Ok(self.mk_expr(lo.to(hi), ExprKind::IfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `move |args| expr`\n     pub fn parse_lambda_expr(&mut self,\n-                             lo: BytePos,\n+                             lo: Span,\n                              capture_clause: CaptureBy,\n                              attrs: ThinVec<Attribute>)\n                              -> PResult<'a, P<Expr>>\n     {\n         let decl = self.parse_fn_block_decl()?;\n-        let decl_hi = self.prev_span.hi;\n+        let decl_hi = self.prev_span;\n         let body = match decl.output {\n             FunctionRetTy::Default(_) => self.parse_expr()?,\n             _ => {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n-                let body_lo = self.span.lo;\n+                let body_lo = self.span;\n                 self.parse_block_expr(body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n \n         Ok(self.mk_expr(\n-            lo,\n-            body.span.hi,\n-            ExprKind::Closure(capture_clause, decl, body, mk_sp(lo, decl_hi)),\n+            lo.to(body.span),\n+            ExprKind::Closure(capture_clause, decl, body, lo.to(decl_hi)),\n             attrs))\n     }\n \n@@ -2988,13 +2965,13 @@ impl<'a> Parser<'a> {\n             return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprKind::Block(blk), ThinVec::new()));\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), ThinVec::new()));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                          span_lo: BytePos,\n+                          span_lo: Span,\n                           mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n@@ -3004,66 +2981,61 @@ impl<'a> Parser<'a> {\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n-        let hi = self.prev_span.hi;\n-\n-        Ok(self.mk_expr(span_lo, hi,\n-                        ExprKind::ForLoop(pat, expr, loop_block, opt_ident),\n-                        attrs))\n+        let hi = self.prev_span;\n+        Ok(self.mk_expr(span_lo.to(hi), ExprKind::ForLoop(pat, expr, loop_block, opt_ident), attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                            span_lo: BytePos,\n+                            span_lo: Span,\n                             mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n             return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n         let cond = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprKind::While(cond, body, opt_ident),\n-                               attrs));\n+        let span = span_lo.to(body.span);\n+        return Ok(self.mk_expr(span, ExprKind::While(cond, body, opt_ident), attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                                span_lo: BytePos,\n+                                span_lo: Span,\n                                 mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         self.expect_keyword(keywords::Let)?;\n         let pat = self.parse_pat()?;\n         self.expect(&token::Eq)?;\n         let expr = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None)?;\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n+        let span = span_lo.to(body.span);\n+        return Ok(self.mk_expr(span, ExprKind::WhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n     // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::SpannedIdent>,\n-                           span_lo: BytePos,\n+                           span_lo: Span,\n                            mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n+        let span = span_lo.to(body.span);\n+        Ok(self.mk_expr(span, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n     /// Parse a `do catch {...}` expression (`do catch` token already eaten)\n-    pub fn parse_catch_expr(&mut self, span_lo: BytePos, mut attrs: ThinVec<Attribute>)\n+    pub fn parse_catch_expr(&mut self, span_lo: Span, mut attrs: ThinVec<Attribute>)\n         -> PResult<'a, P<Expr>>\n     {\n         let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n-        let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprKind::Catch(body), attrs))\n+        Ok(self.mk_expr(span_lo.to(body.span), ExprKind::Catch(body), attrs))\n     }\n \n     // `match` token already eaten\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n-        let lo = self.prev_span.lo;\n+        let lo = self.prev_span;\n         let discriminant = self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n                                                None)?;\n         if let Err(mut e) = self.expect(&token::OpenDelim(token::Brace)) {\n@@ -3082,17 +3054,17 @@ impl<'a> Parser<'a> {\n                     // Recover by skipping to the end of the block.\n                     e.emit();\n                     self.recover_stmt();\n-                    let hi = self.span.hi;\n+                    let span = lo.to(self.span);\n                     if self.token == token::CloseDelim(token::Brace) {\n                         self.bump();\n                     }\n-                    return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n+                    return Ok(self.mk_expr(span, ExprKind::Match(discriminant, arms), attrs));\n                 }\n             }\n         }\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.bump();\n-        return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n+        return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<'a, Arm> {\n@@ -3266,7 +3238,7 @@ impl<'a> Parser<'a> {\n             }\n \n             let attrs = self.parse_outer_attributes()?;\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let hi;\n \n             if self.check(&token::DotDot) {\n@@ -3286,16 +3258,16 @@ impl<'a> Parser<'a> {\n                 let fieldname = self.parse_field_name()?;\n                 self.bump();\n                 let pat = self.parse_pat()?;\n-                hi = pat.span.hi;\n+                hi = pat.span;\n                 (pat, fieldname, false)\n             } else {\n                 // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n                 let is_box = self.eat_keyword(keywords::Box);\n-                let boxed_span_lo = self.span.lo;\n+                let boxed_span = self.span;\n                 let is_ref = self.eat_keyword(keywords::Ref);\n                 let is_mut = self.eat_keyword(keywords::Mut);\n                 let fieldname = self.parse_ident()?;\n-                hi = self.prev_span.hi;\n+                hi = self.prev_span;\n \n                 let bind_type = match (is_ref, is_mut) {\n                     (true, true) => BindingMode::ByRef(Mutability::Mutable),\n@@ -3307,22 +3279,22 @@ impl<'a> Parser<'a> {\n                 let fieldpat = P(ast::Pat{\n                     id: ast::DUMMY_NODE_ID,\n                     node: PatKind::Ident(bind_type, fieldpath, None),\n-                    span: mk_sp(boxed_span_lo, hi),\n+                    span: boxed_span.to(hi),\n                 });\n \n                 let subpat = if is_box {\n                     P(ast::Pat{\n                         id: ast::DUMMY_NODE_ID,\n                         node: PatKind::Box(fieldpat),\n-                        span: mk_sp(lo, hi),\n+                        span: lo.to(hi),\n                     })\n                 } else {\n                     fieldpat\n                 };\n                 (subpat, fieldname, true)\n             };\n \n-            fields.push(codemap::Spanned { span: mk_sp(lo, hi),\n+            fields.push(codemap::Spanned { span: lo.to(hi),\n                                            node: ast::FieldPat {\n                                                ident: fieldname,\n                                                pat: subpat,\n@@ -3336,7 +3308,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n         if self.token.is_path_start() {\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n                 let (qself, path) =\n@@ -3346,8 +3318,8 @@ impl<'a> Parser<'a> {\n                 // Parse an unqualified path\n                 (None, self.parse_path(PathStyle::Expr)?)\n             };\n-            let hi = self.prev_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new()))\n+            let hi = self.prev_span;\n+            Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path), ThinVec::new()))\n         } else {\n             self.parse_pat_literal_maybe_minus()\n         }\n@@ -3373,7 +3345,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_pat(&mut self) -> PResult<'a, P<Pat>> {\n         maybe_whole!(self, NtPat, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let pat;\n         match self.token {\n             token::Underscore => {\n@@ -3439,7 +3411,7 @@ impl<'a> Parser<'a> {\n                         // Parse macro invocation\n                         self.bump();\n                         let (_, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = spanned(lo, self.prev_span.hi, Mac_ { path: path, tts: tts });\n+                        let mac = respan(lo.to(self.prev_span), Mac_ { path: path, tts: tts });\n                         pat = PatKind::Mac(mac);\n                     }\n                     token::DotDotDot | token::DotDot => {\n@@ -3449,9 +3421,8 @@ impl<'a> Parser<'a> {\n                             _ => panic!(\"can only parse `..` or `...` for ranges (checked above)\"),\n                         };\n                         // Parse range\n-                        let hi = self.prev_span.hi;\n-                        let begin =\n-                              self.mk_expr(lo, hi, ExprKind::Path(qself, path), ThinVec::new());\n+                        let span = lo.to(self.prev_span);\n+                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n                         self.bump();\n                         let end = self.parse_pat_range_end()?;\n                         pat = PatKind::Range(begin, end, end_kind);\n@@ -3505,11 +3476,10 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.prev_span.hi;\n         Ok(P(ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n             node: pat,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(self.prev_span),\n         }))\n     }\n \n@@ -3545,7 +3515,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a local variable declaration\n     fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let pat = self.parse_pat()?;\n \n         let mut ty = None;\n@@ -3558,22 +3528,22 @@ impl<'a> Parser<'a> {\n             pat: pat,\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             attrs: attrs,\n         }))\n     }\n \n     /// Parse a structure field\n     fn parse_name_and_ty(&mut self,\n-                         lo: BytePos,\n+                         lo: Span,\n                          vis: Visibility,\n                          attrs: Vec<Attribute>)\n                          -> PResult<'a, StructField> {\n         let name = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         Ok(StructField {\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             ident: Some(name),\n             vis: vis,\n             id: ast::DUMMY_NODE_ID,\n@@ -3683,7 +3653,7 @@ impl<'a> Parser<'a> {\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n                      -> PResult<'a, Option<P<Item>>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         match self.token {\n             token::Ident(ident) if ident.name == \"macro_rules\" => {\n                 if self.look_ahead(1, |t| *t == token::Not) {\n@@ -3706,9 +3676,9 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        let hi = self.prev_span.hi;\n+        let span = lo.to(self.prev_span);\n         let kind = ItemKind::MacroDef(tts);\n-        Ok(Some(self.mk_item(lo, hi, id, kind, Visibility::Inherited, attrs.to_owned())))\n+        Ok(Some(self.mk_item(span, id, kind, Visibility::Inherited, attrs.to_owned())))\n     }\n \n     fn parse_stmt_without_recovery(&mut self,\n@@ -3717,19 +3687,19 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         Ok(Some(if self.eat_keyword(keywords::Let) {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: mk_sp(lo, self.prev_span.hi),\n+                span: lo.to(self.prev_span),\n             }\n         } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited)? {\n             Stmt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: StmtKind::Item(macro_def),\n-                span: mk_sp(lo, self.prev_span.hi),\n+                span: lo.to(self.prev_span),\n             }\n         // Starts like a simple path, but not a union item.\n         } else if self.token.is_path_start() &&\n@@ -3741,8 +3711,8 @@ impl<'a> Parser<'a> {\n                 let expr = if self.check(&token::OpenDelim(token::Brace)) {\n                     self.parse_struct_expr(lo, pth, ThinVec::new())?\n                 } else {\n-                    let hi = self.prev_span.hi;\n-                    self.mk_expr(lo, hi, ExprKind::Path(None, pth), ThinVec::new())\n+                    let hi = self.prev_span;\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, pth), ThinVec::new())\n                 };\n \n                 let expr = self.with_res(Restrictions::RESTRICTION_STMT_EXPR, |this| {\n@@ -3753,7 +3723,7 @@ impl<'a> Parser<'a> {\n                 return Ok(Some(Stmt {\n                     id: ast::DUMMY_NODE_ID,\n                     node: StmtKind::Expr(expr),\n-                    span: mk_sp(lo, self.prev_span.hi),\n+                    span: lo.to(self.prev_span),\n                 }));\n             }\n \n@@ -3784,7 +3754,7 @@ impl<'a> Parser<'a> {\n             };\n \n             let (_, tts) = self.expect_delimited_token_tree()?;\n-            let hi = self.prev_span.hi;\n+            let hi = self.prev_span;\n \n             let style = if delim == token::Brace {\n                 MacStmtStyle::Braces\n@@ -3793,7 +3763,7 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == keywords::Invalid.name() {\n-                let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                let mac = respan(lo.to(hi), Mac_ { path: pth, tts: tts });\n                 let node = if delim == token::Brace ||\n                               self.token == token::Semi || self.token == token::Eof {\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n@@ -3813,14 +3783,14 @@ impl<'a> Parser<'a> {\n                     self.warn_missing_semicolon();\n                     StmtKind::Mac(P((mac, style, attrs.into())))\n                 } else {\n-                    let e = self.mk_mac_expr(lo, hi, mac.node, ThinVec::new());\n+                    let e = self.mk_mac_expr(lo.to(hi), mac.node, ThinVec::new());\n                     let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                     let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n                     StmtKind::Expr(e)\n                 };\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n+                    span: lo.to(hi),\n                     node: node,\n                 }\n             } else {\n@@ -3835,13 +3805,14 @@ impl<'a> Parser<'a> {\n                                        followed by a semicolon\");\n                     }\n                 }\n+                let span = lo.to(hi);\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n+                    span: span,\n                     node: StmtKind::Item({\n                         self.mk_item(\n-                            lo, hi, id /*id is good here*/,\n-                            ItemKind::Mac(spanned(lo, hi, Mac_ { path: pth, tts: tts })),\n+                            span, id /*id is good here*/,\n+                            ItemKind::Mac(respan(span, Mac_ { path: pth, tts: tts })),\n                             Visibility::Inherited,\n                             attrs)\n                     }),\n@@ -3856,7 +3827,7 @@ impl<'a> Parser<'a> {\n             match item {\n                 Some(i) => Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, i.span.hi),\n+                    span: lo.to(i.span),\n                     node: StmtKind::Item(i),\n                 },\n                 None => {\n@@ -3887,7 +3858,7 @@ impl<'a> Parser<'a> {\n                         Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into()))?;\n                     Stmt {\n                         id: ast::DUMMY_NODE_ID,\n-                        span: mk_sp(lo, e.span.hi),\n+                        span: lo.to(e.span),\n                         node: StmtKind::Expr(e),\n                     }\n                 }\n@@ -3905,7 +3876,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         if !self.eat(&token::OpenDelim(token::Brace)) {\n             let sp = self.span;\n@@ -3950,15 +3921,15 @@ impl<'a> Parser<'a> {\n     fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n         self.expect(&token::OpenDelim(token::Brace))?;\n         Ok((self.parse_inner_attributes()?,\n             self.parse_block_tail(lo, BlockCheckMode::Default)?))\n     }\n \n     /// Parse the rest of a block expression or function body\n     /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: BytePos, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n+    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n         let mut stmts = vec![];\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n@@ -3976,7 +3947,7 @@ impl<'a> Parser<'a> {\n             stmts: stmts,\n             id: ast::DUMMY_NODE_ID,\n             rules: s,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n         }))\n     }\n \n@@ -4042,10 +4013,10 @@ impl<'a> Parser<'a> {\n                 }\n                 bounds.push(RegionTyParamBound(self.expect_lifetime()));\n             } else if self.check_keyword(keywords::For) || self.check_path() {\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n                 let modifier = if question.is_some() {\n                     TraitBoundModifier::Maybe\n                 } else {\n@@ -4166,7 +4137,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n         maybe_whole!(self, NtGenerics, |x| x);\n \n-        let span_lo = self.span.lo;\n+        let span_lo = self.span;\n         if self.eat_lt() {\n             let (lifetime_defs, ty_params) = self.parse_generic_params()?;\n             self.expect_gt()?;\n@@ -4177,7 +4148,7 @@ impl<'a> Parser<'a> {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n                 },\n-                span: mk_sp(span_lo, self.prev_span.hi),\n+                span: span_lo.to(self.prev_span),\n             })\n         } else {\n             Ok(ast::Generics::default())\n@@ -4202,15 +4173,15 @@ impl<'a> Parser<'a> {\n                 }\n             } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n                 // Parse associated type binding.\n-                let lo = self.span.lo;\n+                let lo = self.span;\n                 let ident = self.parse_ident()?;\n                 self.bump();\n                 let ty = self.parse_ty()?;\n                 bindings.push(TypeBinding {\n                     id: ast::DUMMY_NODE_ID,\n                     ident: ident,\n                     ty: ty,\n-                    span: mk_sp(lo, self.prev_span.hi),\n+                    span: lo.to(self.prev_span),\n                 });\n                 seen_binding = true;\n             } else if self.check_type() {\n@@ -4267,15 +4238,15 @@ impl<'a> Parser<'a> {\n         }\n \n         loop {\n-            let lo = self.span.lo;\n+            let lo = self.span;\n             if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n                 let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n                 where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n                     ast::WhereRegionPredicate {\n-                        span: mk_sp(lo, self.prev_span.hi),\n+                        span: lo.to(self.prev_span),\n                         lifetime: lifetime,\n                         bounds: bounds,\n                     }\n@@ -4296,7 +4267,7 @@ impl<'a> Parser<'a> {\n                     let bounds = self.parse_ty_param_bounds()?;\n                     where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n                         ast::WhereBoundPredicate {\n-                            span: mk_sp(lo, self.prev_span.hi),\n+                            span: lo.to(self.prev_span),\n                             bound_lifetimes: lifetime_defs,\n                             bounded_ty: ty,\n                             bounds: bounds,\n@@ -4307,7 +4278,7 @@ impl<'a> Parser<'a> {\n                     let rhs_ty = self.parse_ty()?;\n                     where_clause.predicates.push(ast::WherePredicate::EqPredicate(\n                         ast::WhereEqPredicate {\n-                            span: mk_sp(lo, self.prev_span.hi),\n+                            span: lo.to(self.prev_span),\n                             lhs_ty: ty,\n                             rhs_ty: rhs_ty,\n                             id: ast::DUMMY_NODE_ID,\n@@ -4404,7 +4375,7 @@ impl<'a> Parser<'a> {\n         // Parse optional self parameter of a method.\n         // Only a limited set of initial token sequences is considered self parameters, anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n-        let eself_lo = self.span.lo;\n+        let eself_lo = self.span;\n         let (eself, eself_ident) = match self.token {\n             token::BinOp(token::And) => {\n                 // &self\n@@ -4486,7 +4457,7 @@ impl<'a> Parser<'a> {\n             _ => return Ok(None),\n         };\n \n-        let eself = codemap::respan(mk_sp(eself_lo, self.prev_span.hi), eself);\n+        let eself = codemap::respan(eself_lo.to(self.prev_span), eself);\n         Ok(Some(Arg::from_self(eself, eself_ident)))\n     }\n \n@@ -4558,16 +4529,15 @@ impl<'a> Parser<'a> {\n         Ok((id, generics))\n     }\n \n-    fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n-               node: ItemKind, vis: Visibility,\n+    fn mk_item(&mut self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident: ident,\n             attrs: attrs,\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             vis: vis,\n-            span: mk_sp(lo, hi)\n+            span: span,\n         })\n     }\n \n@@ -4625,7 +4595,7 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtImplItem, |x| x);\n \n         let mut attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness()?;\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n@@ -4651,7 +4621,7 @@ impl<'a> Parser<'a> {\n \n         Ok(ImplItem {\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, self.prev_span.hi),\n+            span: lo.to(self.prev_span),\n             ident: name,\n             vis: vis,\n             defaultness: defaultness,\n@@ -4694,7 +4664,7 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&vis, prev_span);\n \n-            let lo = self.span.lo;\n+            let lo = self.span;\n             let pth = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n \n@@ -4704,7 +4674,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Semi)?\n             }\n \n-            let mac = spanned(lo, self.prev_span.hi, Mac_ { path: pth, tts: tts });\n+            let mac = respan(lo.to(self.prev_span), Mac_ { path: pth, tts: tts });\n             Ok((keywords::Invalid.ident(), vec![], ast::ImplItemKind::Macro(mac)))\n         } else {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n@@ -4938,11 +4908,11 @@ impl<'a> Parser<'a> {\n             SeqSep::trailing_allowed(token::Comma),\n             |p| {\n                 let attrs = p.parse_outer_attributes()?;\n-                let lo = p.span.lo;\n+                let lo = p.span;\n                 let vis = p.parse_visibility(true)?;\n                 let ty = p.parse_ty()?;\n                 Ok(StructField {\n-                    span: mk_sp(lo, p.span.hi),\n+                    span: lo.to(p.span),\n                     vis: vis,\n                     ident: None,\n                     id: ast::DUMMY_NODE_ID,\n@@ -4956,7 +4926,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a structure field declaration\n     pub fn parse_single_struct_field(&mut self,\n-                                     lo: BytePos,\n+                                     lo: Span,\n                                      vis: Visibility,\n                                      attrs: Vec<Attribute> )\n                                      -> PResult<'a, StructField> {\n@@ -4978,7 +4948,7 @@ impl<'a> Parser<'a> {\n     /// Parse an element of a struct definition\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         self.parse_single_struct_field(lo, vis, attrs)\n     }\n@@ -5056,7 +5026,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Given a termination token, parse all of the items in a module\n-    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<'a, Mod> {\n+    fn parse_mod_items(&mut self, term: &token::Token, inner_lo: Span) -> PResult<'a, Mod> {\n         let mut items = vec![];\n         while let Some(item) = self.parse_item()? {\n             items.push(item);\n@@ -5070,11 +5040,11 @@ impl<'a> Parser<'a> {\n         let hi = if self.span == syntax_pos::DUMMY_SP {\n             inner_lo\n         } else {\n-            self.prev_span.hi\n+            self.prev_span\n         };\n \n         Ok(ast::Mod {\n-            inner: mk_sp(inner_lo, hi),\n+            inner: inner_lo.to(hi),\n             items: items\n         })\n     }\n@@ -5137,7 +5107,7 @@ impl<'a> Parser<'a> {\n             let old_directory = self.directory.clone();\n             self.push_directory(id, &outer_attrs);\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            let mod_inner_lo = self.span.lo;\n+            let mod_inner_lo = self.span;\n             let attrs = self.parse_inner_attributes()?;\n             let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n             self.directory = old_directory;\n@@ -5280,50 +5250,50 @@ impl<'a> Parser<'a> {\n         let mut p0 =\n             new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n         p0.cfg_mods = self.cfg_mods;\n-        let mod_inner_lo = p0.span.lo;\n+        let mod_inner_lo = p0.span;\n         let mod_attrs = p0.parse_inner_attributes()?;\n         let m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n         self.sess.included_mod_stack.borrow_mut().pop();\n         Ok((ast::ItemKind::Mod(m0), mod_attrs))\n     }\n \n     /// Parse a function declaration from a foreign module\n-    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: BytePos,\n-                             attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n+    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                             -> PResult<'a, ForeignItem> {\n         self.expect_keyword(keywords::Fn)?;\n \n         let (ident, mut generics) = self.parse_fn_header()?;\n         let decl = self.parse_fn_decl(true)?;\n         generics.where_clause = self.parse_where_clause()?;\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.expect(&token::Semi)?;\n         Ok(ast::ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Fn(decl, generics),\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(hi),\n             vis: vis\n         })\n     }\n \n     /// Parse a static item from a foreign module\n-    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: BytePos,\n-                                 attrs: Vec<Attribute>) -> PResult<'a, ForeignItem> {\n+    fn parse_item_foreign_static(&mut self, vis: ast::Visibility, lo: Span, attrs: Vec<Attribute>)\n+                                 -> PResult<'a, ForeignItem> {\n         self.expect_keyword(keywords::Static)?;\n         let mutbl = self.eat_keyword(keywords::Mut);\n \n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let hi = self.span.hi;\n+        let hi = self.span;\n         self.expect(&token::Semi)?;\n         Ok(ForeignItem {\n             ident: ident,\n             attrs: attrs,\n             node: ForeignItemKind::Static(ty, mutbl),\n             id: ast::DUMMY_NODE_ID,\n-            span: mk_sp(lo, hi),\n+            span: lo.to(hi),\n             vis: vis\n         })\n     }\n@@ -5335,7 +5305,7 @@ impl<'a> Parser<'a> {\n     /// extern crate foo;\n     /// extern crate bar as foo;\n     fn parse_item_extern_crate(&mut self,\n-                               lo: BytePos,\n+                               lo: Span,\n                                visibility: Visibility,\n                                attrs: Vec<Attribute>)\n                                 -> PResult<'a, P<Item>> {\n@@ -5349,8 +5319,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Semi)?;\n \n         let prev_span = self.prev_span;\n-        Ok(self.mk_item(lo,\n-                        prev_span.hi,\n+        Ok(self.mk_item(lo.to(prev_span),\n                         ident,\n                         ItemKind::ExternCrate(maybe_path),\n                         visibility,\n@@ -5368,7 +5337,7 @@ impl<'a> Parser<'a> {\n     /// extern \"C\" {}\n     /// extern {}\n     fn parse_item_foreign_mod(&mut self,\n-                              lo: BytePos,\n+                              lo: Span,\n                               opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n                               mut attrs: Vec<Attribute>)\n@@ -5390,12 +5359,8 @@ impl<'a> Parser<'a> {\n             abi: abi,\n             items: foreign_items\n         };\n-        Ok(self.mk_item(lo,\n-                     prev_span.hi,\n-                     keywords::Invalid.ident(),\n-                     ItemKind::ForeignMod(m),\n-                     visibility,\n-                     attrs))\n+        let invalid = keywords::Invalid.ident();\n+        Ok(self.mk_item(lo.to(prev_span), invalid, ItemKind::ForeignMod(m), visibility, attrs))\n     }\n \n     /// Parse type Foo = Bar;\n@@ -5416,7 +5381,7 @@ impl<'a> Parser<'a> {\n         let mut any_disr = None;\n         while self.token != token::CloseDelim(token::Brace) {\n             let variant_attrs = self.parse_outer_attributes()?;\n-            let vlo = self.span.lo;\n+            let vlo = self.span;\n \n             let struct_def;\n             let mut disr_expr = None;\n@@ -5444,7 +5409,7 @@ impl<'a> Parser<'a> {\n                 data: struct_def,\n                 disr_expr: disr_expr,\n             };\n-            variants.push(spanned(vlo, self.prev_span.hi, vr));\n+            variants.push(respan(vlo.to(self.prev_span), vr));\n \n             if !self.eat(&token::Comma) { break; }\n         }\n@@ -5514,7 +5479,7 @@ impl<'a> Parser<'a> {\n             Some(P(item))\n         });\n \n-        let lo = self.span.lo;\n+        let lo = self.span;\n \n         let visibility = self.parse_visibility(false)?;\n \n@@ -5524,12 +5489,8 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Semi)?;\n \n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n-                                    keywords::Invalid.ident(),\n-                                    item_,\n-                                    visibility,\n-                                    attrs);\n+            let invalid = keywords::Invalid.ident();\n+            let item = self.mk_item(lo.to(prev_span), invalid, item_, visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -5549,8 +5510,7 @@ impl<'a> Parser<'a> {\n                                        respan(fn_span, Constness::NotConst),\n                                        abi)?;\n                 let prev_span = self.prev_span;\n-                let item = self.mk_item(lo,\n-                                        prev_span.hi,\n+                let item = self.mk_item(lo.to(prev_span),\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5572,8 +5532,7 @@ impl<'a> Parser<'a> {\n             };\n             let (ident, item_, extra_attrs) = self.parse_item_const(Some(m))?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5597,8 +5556,7 @@ impl<'a> Parser<'a> {\n                                        respan(const_span, Constness::Const),\n                                        Abi::Rust)?;\n                 let prev_span = self.prev_span;\n-                let item = self.mk_item(lo,\n-                                        prev_span.hi,\n+                let item = self.mk_item(lo.to(prev_span),\n                                         ident,\n                                         item_,\n                                         visibility,\n@@ -5615,8 +5573,7 @@ impl<'a> Parser<'a> {\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5632,8 +5589,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Unsafe)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5648,8 +5604,7 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(keywords::Impl)?;\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Unsafe)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5665,8 +5620,7 @@ impl<'a> Parser<'a> {\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5689,8 +5643,7 @@ impl<'a> Parser<'a> {\n                                    respan(fn_span, Constness::NotConst),\n                                    abi)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5702,8 +5655,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_mod(&attrs[..])?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5714,8 +5666,7 @@ impl<'a> Parser<'a> {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5726,8 +5677,7 @@ impl<'a> Parser<'a> {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5739,8 +5689,7 @@ impl<'a> Parser<'a> {\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_trait(ast::Unsafety::Normal)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5751,8 +5700,7 @@ impl<'a> Parser<'a> {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_impl(ast::Unsafety::Normal)?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5763,8 +5711,7 @@ impl<'a> Parser<'a> {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5776,8 +5723,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_union()?;\n             let prev_span = self.prev_span;\n-            let item = self.mk_item(lo,\n-                                    prev_span.hi,\n+            let item = self.mk_item(lo.to(prev_span),\n                                     ident,\n                                     item_,\n                                     visibility,\n@@ -5794,7 +5740,7 @@ impl<'a> Parser<'a> {\n     /// Parse a foreign item.\n     fn parse_foreign_item(&mut self) -> PResult<'a, Option<ForeignItem>> {\n         let attrs = self.parse_outer_attributes()?;\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         let visibility = self.parse_visibility(false)?;\n \n         if self.check_keyword(keywords::Static) {\n@@ -5821,7 +5767,7 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n         attributes_allowed: bool,\n-        lo: BytePos,\n+        lo: Span,\n         visibility: Visibility\n     ) -> PResult<'a, Option<P<Item>>> {\n         if macros_allowed && self.token.is_path_start() {\n@@ -5830,7 +5776,7 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&visibility, prev_span);\n \n-            let mac_lo = self.span.lo;\n+            let mac_lo = self.span;\n \n             // item macro.\n             let pth = self.parse_path(PathStyle::Mod)?;\n@@ -5856,9 +5802,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n \n-            let hi = self.prev_span.hi;\n-            let mac = spanned(mac_lo, hi, Mac_ { path: pth, tts: tts });\n-            let item = self.mk_item(lo, hi, id, ItemKind::Mac(mac), visibility, attrs);\n+            let hi = self.prev_span;\n+            let mac = respan(mac_lo.to(hi), Mac_ { path: pth, tts: tts });\n+            let item = self.mk_item(lo.to(hi), id, ItemKind::Mac(mac), visibility, attrs);\n             return Ok(Some(item));\n         }\n \n@@ -5886,7 +5832,7 @@ impl<'a> Parser<'a> {\n         self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n                                  &token::CloseDelim(token::Brace),\n                                  SeqSep::trailing_allowed(token::Comma), |this| {\n-            let lo = this.span.lo;\n+            let lo = this.span;\n             let ident = if this.eat_keyword(keywords::SelfValue) {\n                 keywords::SelfValue.ident()\n             } else {\n@@ -5898,8 +5844,7 @@ impl<'a> Parser<'a> {\n                 rename: rename,\n                 id: ast::DUMMY_NODE_ID\n             };\n-            let hi = this.prev_span.hi;\n-            Ok(spanned(lo, hi, node))\n+            Ok(respan(lo.to(this.prev_span), node))\n         })\n     }\n \n@@ -5917,38 +5862,38 @@ impl<'a> Parser<'a> {\n     /// MOD_SEP? non_global_path MOD_SEP LBRACE item_seq RBRACE\n     /// MOD_SEP? LBRACE item_seq RBRACE\n     fn parse_view_path(&mut self) -> PResult<'a, P<ViewPath>> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         if self.check(&token::OpenDelim(token::Brace)) || self.check(&token::BinOp(token::Star)) ||\n            self.is_import_coupler() {\n             // `{foo, bar}`, `::{foo, bar}`, `*`, or `::*`.\n             self.eat(&token::ModSep);\n             let prefix = ast::Path {\n                 segments: vec![PathSegment::crate_root()],\n-                span: mk_sp(lo, self.span.hi),\n+                span: lo.to(self.span),\n             };\n             let view_path_kind = if self.eat(&token::BinOp(token::Star)) {\n                 ViewPathGlob(prefix)\n             } else {\n                 ViewPathList(prefix, self.parse_path_list_items()?)\n             };\n-            Ok(P(spanned(lo, self.span.hi, view_path_kind)))\n+            Ok(P(respan(lo.to(self.span), view_path_kind)))\n         } else {\n             let prefix = self.parse_path(PathStyle::Mod)?.default_to_global();\n             if self.is_import_coupler() {\n                 // `foo::bar::{a, b}` or `foo::bar::*`\n                 self.bump();\n                 if self.check(&token::BinOp(token::Star)) {\n                     self.bump();\n-                    Ok(P(spanned(lo, self.span.hi, ViewPathGlob(prefix))))\n+                    Ok(P(respan(lo.to(self.span), ViewPathGlob(prefix))))\n                 } else {\n                     let items = self.parse_path_list_items()?;\n-                    Ok(P(spanned(lo, self.span.hi, ViewPathList(prefix, items))))\n+                    Ok(P(respan(lo.to(self.span), ViewPathList(prefix, items))))\n                 }\n             } else {\n                 // `foo::bar` or `foo::bar as baz`\n                 let rename = self.parse_rename()?.\n                                   unwrap_or(prefix.segments.last().unwrap().identifier);\n-                Ok(P(spanned(lo, self.prev_span.hi, ViewPathSimple(rename, prefix))))\n+                Ok(P(respan(lo.to(self.prev_span), ViewPathSimple(rename, prefix))))\n             }\n         }\n     }\n@@ -5964,11 +5909,11 @@ impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main\n     /// entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.span.lo;\n+        let lo = self.span;\n         Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n-            span: mk_sp(lo, self.span.lo),\n+            span: lo.to(self.span),\n         })\n     }\n "}, {"sha": "6f5ab50b2fe6fd410b2d48d12ec5e462d0f854a7", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -559,11 +559,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n-                locals.push(Context::format_arg(self.ecx,\n-                                                self.macsp,\n-                                                e.span,\n-                                                arg_ty,\n-                                                self.ecx.expr_ident(e.span, name)));\n+                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));\n             }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n@@ -576,11 +572,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 Exact(i) => spans_pos[i],\n                 _ => panic!(\"should never happen\"),\n             };\n-            counts.push(Context::format_arg(self.ecx,\n-                                            self.macsp,\n-                                            span,\n-                                            &Count,\n-                                            self.ecx.expr_ident(span, name)));\n+            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count, name));\n         }\n \n         // Now create a vector containing all the arguments\n@@ -643,9 +635,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                   macsp: Span,\n                   mut sp: Span,\n                   ty: &ArgumentType,\n-                  arg: P<ast::Expr>)\n+                  arg: ast::Ident)\n                   -> P<ast::Expr> {\n         sp.ctxt = sp.ctxt.apply_mark(ecx.current_expansion.mark);\n+        let arg = ecx.expr_ident(sp, arg);\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n                 match &tyname[..] {"}, {"sha": "947192a0a23e0760e34b3a7e39ad40a5ff871d7f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -174,6 +174,15 @@ impl Span {\n         }\n         result\n     }\n+\n+    pub fn to(self, end: Span) -> Span {\n+        // FIXME(jseyfried): self.ctxt should always equal end.ctxt here (c.f. issue #23480)\n+        if end.ctxt == SyntaxContext::empty() {\n+            Span { lo: self.lo, ..end }\n+        } else {\n+            Span { hi: end.hi, ..self }\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -208,7 +217,7 @@ impl serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(mk_sp(lo, hi))\n+            Ok(Span { lo: lo, hi: hi, ctxt: NO_EXPANSION })\n         })\n     }\n }\n@@ -696,11 +705,6 @@ pub struct FileLines {\n thread_local!(pub static SPAN_DEBUG: Cell<fn(Span, &mut fmt::Formatter) -> fmt::Result> =\n                 Cell::new(default_span_debug));\n \n-/* assuming that we're not in macro expansion */\n-pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, ctxt: NO_EXPANSION}\n-}\n-\n pub struct MacroBacktrace {\n     /// span where macro was applied to generate this code\n     pub call_site: Span,"}, {"sha": "7c19917acc476b398b6ffa4545a774dd5fa507e3", "filename": "src/test/compile-fail/imports/macro-paths.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacro-paths.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -25,7 +25,6 @@ fn f() {\n     bar::m! { //~ ERROR ambiguous\n               //~| NOTE macro-expanded items do not shadow when used in a macro invocation path\n         mod bar { pub use two_macros::m; } //~ NOTE could refer to the name defined here\n-                                           //~^^^ NOTE in this expansion\n     }\n }\n \n@@ -37,6 +36,5 @@ fn g() {\n     baz::m! { //~ ERROR ambiguous\n               //~| NOTE macro-expanded items do not shadow when used in a macro invocation path\n         mod baz { pub use two_macros::m; } //~ NOTE could refer to the name defined here\n-                                           //~^^^ NOTE in this expansion\n     }\n }"}, {"sha": "06b0964a3b14528f1eaf71845d344b6a516f7fa0", "filename": "src/test/compile-fail/imports/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fmacros.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -28,7 +28,6 @@ mod m2 {\n     m! { //~ ERROR ambiguous\n          //~| NOTE macro-expanded macro imports do not shadow\n         use foo::m; //~ NOTE could refer to the name imported here\n-                    //~^^^ NOTE in this expansion\n     }\n }\n \n@@ -43,7 +42,6 @@ mod m3 {\n         m! { //~ ERROR ambiguous\n              //~| NOTE macro-expanded macro imports do not shadow\n             use two_macros::n as m; //~ NOTE could refer to the name imported here\n-                                    //~^^^ NOTE in this expansion\n         }\n     }\n }"}, {"sha": "a7f1cf3c9d3ef92b37dedb4103f5650b5ccc09b6", "filename": "src/test/compile-fail/imports/shadow_builtin_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimports%2Fshadow_builtin_macros.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -31,7 +31,6 @@ mod m2 {\n \n mod m3 {\n     ::two_macros::m!(use foo::panic;); //~ NOTE `panic` could refer to the name imported here\n-    //~| NOTE in this expansion\n     fn f() { panic!(); } //~ ERROR ambiguous\n     //~| NOTE `panic` is also a builtin macro\n     //~| NOTE macro-expanded macro imports do not shadow"}, {"sha": "4aacb6840e9d51f22a578ba7c8cc950c08aed1e5", "filename": "src/test/compile-fail/issue-25385.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -21,5 +21,4 @@ fn main() {\n \n     foo!(1i32.foo());\n     //~^ ERROR no method named `foo` found for type `i32` in the current scope\n-    //~^^ NOTE in this expansion of foo!\n }"}, {"sha": "25c7417f7eb21a8d94dec38b35865b2207b485d2", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -22,7 +22,7 @@ macro_rules! indirect_line { () => ( line!() ) }\n \n pub fn main() {\n     assert_eq!(line!(), 24);\n-    assert_eq!(column!(), 4);\n+    assert_eq!(column!(), 15);\n     assert_eq!(indirect_line!(), 26);\n     assert!((file!().ends_with(\"syntax-extension-source-utils.rs\")));\n     assert_eq!(stringify!((2*3) + 5).to_string(), \"( 2 * 3 ) + 5\".to_string());"}, {"sha": "e4044f5aaf2be36fb528efdf369ea57eca5b3032", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f08d5ad4c59ca5fc1c961a94c53807d70959c375/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=f08d5ad4c59ca5fc1c961a94c53807d70959c375", "patch": "@@ -2,10 +2,7 @@ error[E0433]: failed to resolve. Use of undeclared type or module `m`\n   --> $DIR/macro_path_as_generic_bound.rs:17:6\n    |\n 17 | foo!(m::m2::A);\n-   | -----^^^^^^^^--\n-   | |    |\n-   | |    Use of undeclared type or module `m`\n-   | in this macro invocation\n+   |      ^^^^^^^^ Use of undeclared type or module `m`\n \n error: cannot continue compilation due to previous error\n "}]}