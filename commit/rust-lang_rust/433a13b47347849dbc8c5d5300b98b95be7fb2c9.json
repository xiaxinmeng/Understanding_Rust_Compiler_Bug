{"sha": "433a13b47347849dbc8c5d5300b98b95be7fb2c9", "node_id": "C_kwDOAAsO6NoAKDQzM2ExM2I0NzM0Nzg0OWRiYzhjNWQ1MzAwYjk4Yjk1YmU3ZmIyYzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-11T16:35:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-11T16:35:23Z"}, "message": "Rollup merge of #83174 - camelid:borrow-help, r=oli-obk\n\nSuggest using a temporary variable to fix borrowck errors\n\nFixes #77834.\n\nIn Rust, nesting method calls with both require `&mut` access to `self`\nproduces a borrow-check error:\n\n    error[E0499]: cannot borrow `*self` as mutable more than once at a time\n     --> src/lib.rs:7:14\n      |\n    7 |     self.foo(self.bar());\n      |     ---------^^^^^^^^^^-\n      |     |    |   |\n      |     |    |   second mutable borrow occurs here\n      |     |    first borrow later used by call\n      |     first mutable borrow occurs here\n\nThat's because Rust has a left-to-right evaluation order, and the method\nreceiver is passed first. Thus, the argument to the method cannot then\nmutate `self`.\n\nThere's an easy solution to this error: just extract a local variable\nfor the inner argument:\n\n    let tmp = self.bar();\n    self.foo(tmp);\n\nHowever, the error doesn't give any suggestion of how to solve the\nproblem. As a result, new users may assume that it's impossible to\nexpress their code correctly and get stuck.\n\nThis commit adds a (non-structured) suggestion to extract a local\nvariable for the inner argument to solve the error. The suggestion uses\nheuristics that eliminate most false positives, though there are a few\nfalse negatives (cases where the suggestion should be emitted but is\nnot). Those other cases can be implemented in a future change.", "tree": {"sha": "1c330cf7465ec6adcdb2b607594b65f80284eb73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c330cf7465ec6adcdb2b607594b65f80284eb73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433a13b47347849dbc8c5d5300b98b95be7fb2c9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhtNNLCRBK7hj4Ov3rIwAAk5QIAJROwT58//0Nz2FU/CpMpWfz\nctLxzpRdr17yHIY0EJ4fFBfFVpRbCTJxIpXgHm8pFVNnuEx0p3BzJzNjqTBqzyws\niRQ4TL/VvcFQyKPk1uzyyscVRNYeI29f6AKN40FrH5gc5kbFxTZk70BpvtLJto8F\nM0rBz9lxg+WNXf9je23Cwd9VEAgXL2j7b7DbH3ifXTDCEl5Q8B/UpODf1NsXhb7q\nYDV8bnuPxaH6Wb3ACeqNfUGe+DNol//TOhC26ckvW2fS89/RRGprrzr9G6m4+2n/\n2mm6wLW3rXm1RIWD5d8woZ17FdUmryOk+9q5G72/8BjvHG26HXrEbuVt/zaIASg=\n=7PMF\n-----END PGP SIGNATURE-----\n", "payload": "tree 1c330cf7465ec6adcdb2b607594b65f80284eb73\nparent b9a37ad0d995c71518629b032f8e816e1efa8bca\nparent e27315268b10c9ef2f4c3d815dfc79f513327def\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639240523 +0100\ncommitter GitHub <noreply@github.com> 1639240523 +0100\n\nRollup merge of #83174 - camelid:borrow-help, r=oli-obk\n\nSuggest using a temporary variable to fix borrowck errors\n\nFixes #77834.\n\nIn Rust, nesting method calls with both require `&mut` access to `self`\nproduces a borrow-check error:\n\n    error[E0499]: cannot borrow `*self` as mutable more than once at a time\n     --> src/lib.rs:7:14\n      |\n    7 |     self.foo(self.bar());\n      |     ---------^^^^^^^^^^-\n      |     |    |   |\n      |     |    |   second mutable borrow occurs here\n      |     |    first borrow later used by call\n      |     first mutable borrow occurs here\n\nThat's because Rust has a left-to-right evaluation order, and the method\nreceiver is passed first. Thus, the argument to the method cannot then\nmutate `self`.\n\nThere's an easy solution to this error: just extract a local variable\nfor the inner argument:\n\n    let tmp = self.bar();\n    self.foo(tmp);\n\nHowever, the error doesn't give any suggestion of how to solve the\nproblem. As a result, new users may assume that it's impossible to\nexpress their code correctly and get stuck.\n\nThis commit adds a (non-structured) suggestion to extract a local\nvariable for the inner argument to solve the error. The suggestion uses\nheuristics that eliminate most false positives, though there are a few\nfalse negatives (cases where the suggestion should be emitted but is\nnot). Those other cases can be implemented in a future change.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433a13b47347849dbc8c5d5300b98b95be7fb2c9", "html_url": "https://github.com/rust-lang/rust/commit/433a13b47347849dbc8c5d5300b98b95be7fb2c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433a13b47347849dbc8c5d5300b98b95be7fb2c9/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9a37ad0d995c71518629b032f8e816e1efa8bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a37ad0d995c71518629b032f8e816e1efa8bca", "html_url": "https://github.com/rust-lang/rust/commit/b9a37ad0d995c71518629b032f8e816e1efa8bca"}, {"sha": "e27315268b10c9ef2f4c3d815dfc79f513327def", "url": "https://api.github.com/repos/rust-lang/rust/commits/e27315268b10c9ef2f4c3d815dfc79f513327def", "html_url": "https://github.com/rust-lang/rust/commit/e27315268b10c9ef2f4c3d815dfc79f513327def"}], "stats": {"total": 311, "additions": 309, "deletions": 2}, "files": [{"sha": "98c619cdd291ccd488c81f5fe41f6bcb75a1cce6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -15,16 +15,18 @@ use rustc_span::symbol::sym;\n use rustc_span::{BytePos, MultiSpan, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n+use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n \n+use crate::diagnostics::find_all_local_uses;\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n };\n \n use super::{\n-    explain_borrow::BorrowExplanation, FnSelfUseKind, IncludingDowncast, RegionName,\n-    RegionNameSource, UseSpans,\n+    explain_borrow::{BorrowExplanation, LaterUseKind},\n+    FnSelfUseKind, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -768,9 +770,92 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some((issued_span, span)),\n         );\n \n+        self.suggest_using_local_if_applicable(\n+            &mut err,\n+            location,\n+            (place, span),\n+            gen_borrow_kind,\n+            issued_borrow,\n+            explanation,\n+        );\n+\n         err\n     }\n \n+    #[instrument(level = \"debug\", skip(self, err))]\n+    fn suggest_using_local_if_applicable(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        location: Location,\n+        (place, span): (Place<'tcx>, Span),\n+        gen_borrow_kind: BorrowKind,\n+        issued_borrow: &BorrowData<'tcx>,\n+        explanation: BorrowExplanation,\n+    ) {\n+        let used_in_call =\n+            matches!(explanation, BorrowExplanation::UsedLater(LaterUseKind::Call, _call_span, _));\n+        if !used_in_call {\n+            debug!(\"not later used in call\");\n+            return;\n+        }\n+\n+        let outer_call_loc =\n+            if let TwoPhaseActivation::ActivatedAt(loc) = issued_borrow.activation_location {\n+                loc\n+            } else {\n+                issued_borrow.reserve_location\n+            };\n+        let outer_call_stmt = self.body.stmt_at(outer_call_loc);\n+\n+        let inner_param_location = location;\n+        let Some(inner_param_stmt) = self.body.stmt_at(inner_param_location).left() else {\n+            debug!(\"`inner_param_location` {:?} is not for a statement\", inner_param_location);\n+            return;\n+        };\n+        let Some(&inner_param) = inner_param_stmt.kind.as_assign().map(|(p, _)| p) else {\n+            debug!(\n+                \"`inner_param_location` {:?} is not for an assignment: {:?}\",\n+                inner_param_location, inner_param_stmt\n+            );\n+            return;\n+        };\n+        let inner_param_uses = find_all_local_uses::find(self.body, inner_param.local);\n+        let Some((inner_call_loc,inner_call_term)) = inner_param_uses.into_iter().find_map(|loc| {\n+            let Either::Right(term) = self.body.stmt_at(loc) else {\n+                debug!(\"{:?} is a statement, so it can't be a call\", loc);\n+                return None;\n+            };\n+            let TerminatorKind::Call { args, .. } = &term.kind else {\n+                debug!(\"not a call: {:?}\", term);\n+                return None;\n+            };\n+            debug!(\"checking call args for uses of inner_param: {:?}\", args);\n+            if args.contains(&Operand::Move(inner_param)) {\n+                Some((loc,term))\n+            } else {\n+                None\n+            }\n+        }) else {\n+            debug!(\"no uses of inner_param found as a by-move call arg\");\n+            return;\n+        };\n+        debug!(\"===> outer_call_loc = {:?}, inner_call_loc = {:?}\", outer_call_loc, inner_call_loc);\n+\n+        let inner_call_span = inner_call_term.source_info.span;\n+        let outer_call_span = outer_call_stmt.either(|s| s.source_info, |t| t.source_info).span;\n+        if outer_call_span == inner_call_span || !outer_call_span.contains(inner_call_span) {\n+            // FIXME: This stops the suggestion in some cases where it should be emitted.\n+            //        Fix the spans for those cases so it's emitted correctly.\n+            debug!(\n+                \"outer span {:?} does not strictly contain inner span {:?}\",\n+                outer_call_span, inner_call_span\n+            );\n+            return;\n+        }\n+        err.span_help(inner_call_span, \"try adding a local storing this argument...\");\n+        err.span_help(outer_call_span, \"...and then using that local as the argument to this call\");\n+    }\n+\n     fn suggest_split_at_mut_if_applicable(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "49d9caae71144f8cec6353e791fa91671fd8d9a5", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,26 @@\n+use std::collections::BTreeSet;\n+\n+use rustc_middle::mir::visit::{PlaceContext, Visitor};\n+use rustc_middle::mir::{Body, Local, Location};\n+\n+/// Find all uses of (including assignments to) a [`Local`].\n+///\n+/// Uses `BTreeSet` so output is deterministic.\n+pub(super) fn find<'tcx>(body: &Body<'tcx>, local: Local) -> BTreeSet<Location> {\n+    let mut visitor = AllLocalUsesVisitor { for_local: local, uses: BTreeSet::default() };\n+    visitor.visit_body(body);\n+    visitor.uses\n+}\n+\n+struct AllLocalUsesVisitor {\n+    for_local: Local,\n+    uses: BTreeSet<Location>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for AllLocalUsesVisitor {\n+    fn visit_local(&mut self, local: &Local, _context: PlaceContext, location: Location) {\n+        if *local == self.for_local {\n+            self.uses.insert(location);\n+        }\n+    }\n+}"}, {"sha": "dec1940ace88188139a08344f335e19f928f794a", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -19,6 +19,7 @@ use rustc_target::abi::VariantIdx;\n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n \n+mod find_all_local_uses;\n mod find_use;\n mod outlives_suggestion;\n mod region_name;"}, {"sha": "afd8083dfe46a3e23e42cab2add914c8c23a12d9", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -12,6 +12,7 @@ use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::{AdtDef, InstanceDef, Region, ScalarInt, UserTypeAnnotationIndex};\n+\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{self, GeneratorKind};\n@@ -30,6 +31,9 @@ use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n+\n+use either::Either;\n+\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -503,6 +507,16 @@ impl<'tcx> Body<'tcx> {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n \n+    pub fn stmt_at(&self, location: Location) -> Either<&Statement<'tcx>, &Terminator<'tcx>> {\n+        let Location { block, statement_index } = location;\n+        let block_data = &self.basic_blocks[block];\n+        block_data\n+            .statements\n+            .get(statement_index)\n+            .map(Either::Left)\n+            .unwrap_or_else(|| Either::Right(block_data.terminator()))\n+    }\n+\n     #[inline]\n     pub fn predecessors(&self) -> &Predecessors {\n         self.predecessor_cache.compute(&self.basic_blocks)"}, {"sha": "d5996ba68be5353da48f60844b84ed0b1bbcef93", "filename": "src/test/ui/borrowck/suggest-local-var-double-mut.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,27 @@\n+// See issue #77834.\n+\n+#![crate_type = \"lib\"]\n+\n+mod method_syntax {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn foo(&mut self, _: f32) -> i32 { todo!() }\n+        fn bar(&mut self) -> f32 { todo!() }\n+        fn baz(&mut self) {\n+            self.foo(self.bar()); //~ ERROR\n+        }\n+    }\n+}\n+\n+mod fully_qualified_syntax {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn foo(&mut self, _: f32) -> i32 { todo!() }\n+        fn bar(&mut self) -> f32 { todo!() }\n+        fn baz(&mut self) {\n+            Self::foo(self, Self::bar(self)); //~ ERROR\n+        }\n+    }\n+}"}, {"sha": "3a43c18a7ed52669d748cc7c701e9993f65ad782", "filename": "src/test/ui/borrowck/suggest-local-var-double-mut.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-double-mut.stderr?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,44 @@\n+error[E0499]: cannot borrow `*self` as mutable more than once at a time\n+  --> $DIR/suggest-local-var-double-mut.rs:12:22\n+   |\n+LL |             self.foo(self.bar());\n+   |             ---------^^^^^^^^^^-\n+   |             |    |   |\n+   |             |    |   second mutable borrow occurs here\n+   |             |    first borrow later used by call\n+   |             first mutable borrow occurs here\n+   |\n+help: try adding a local storing this argument...\n+  --> $DIR/suggest-local-var-double-mut.rs:12:22\n+   |\n+LL |             self.foo(self.bar());\n+   |                      ^^^^^^^^^^\n+help: ...and then using that local as the argument to this call\n+  --> $DIR/suggest-local-var-double-mut.rs:12:13\n+   |\n+LL |             self.foo(self.bar());\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0499]: cannot borrow `*self` as mutable more than once at a time\n+  --> $DIR/suggest-local-var-double-mut.rs:24:39\n+   |\n+LL |             Self::foo(self, Self::bar(self));\n+   |             --------- ----            ^^^^ second mutable borrow occurs here\n+   |             |         |\n+   |             |         first mutable borrow occurs here\n+   |             first borrow later used by call\n+   |\n+help: try adding a local storing this argument...\n+  --> $DIR/suggest-local-var-double-mut.rs:24:29\n+   |\n+LL |             Self::foo(self, Self::bar(self));\n+   |                             ^^^^^^^^^^^^^^^\n+help: ...and then using that local as the argument to this call\n+  --> $DIR/suggest-local-var-double-mut.rs:24:13\n+   |\n+LL |             Self::foo(self, Self::bar(self));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "2ba0b6b28aaaa55eb01b1e9b9e511a1451a4c0b4", "filename": "src/test/ui/borrowck/suggest-local-var-imm-and-mut.nll.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.nll.stderr?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,33 @@\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:12:22\n+   |\n+LL |             self.foo(self.bar());\n+   |             ---------^^^^^^^^^^-\n+   |             |    |   |\n+   |             |    |   mutable borrow occurs here\n+   |             |    immutable borrow later used by call\n+   |             immutable borrow occurs here\n+   |\n+help: try adding a local storing this argument...\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:12:22\n+   |\n+LL |             self.foo(self.bar());\n+   |                      ^^^^^^^^^^\n+help: ...and then using that local as the argument to this call\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:12:13\n+   |\n+LL |             self.foo(self.bar());\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:24:39\n+   |\n+LL |             Self::foo(self, Self::bar(self));\n+   |             --------- ----            ^^^^ mutable borrow occurs here\n+   |             |         |\n+   |             |         immutable borrow occurs here\n+   |             immutable borrow later used by call\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "bf167ba79f311e3c93f030ce06be1092a7f8e880", "filename": "src/test/ui/borrowck/suggest-local-var-imm-and-mut.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.rs?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,27 @@\n+// See issue #77834.\n+\n+#![crate_type = \"lib\"]\n+\n+mod method_syntax {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn foo(&self, _: f32) -> i32 { todo!() }\n+        fn bar(&mut self) -> f32 { todo!() }\n+        fn baz(&mut self) {\n+            self.foo(self.bar()); //~ ERROR\n+        }\n+    }\n+}\n+\n+mod fully_qualified_syntax {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn foo(&self, _: f32) -> i32 { todo!() }\n+        fn bar(&mut self) -> f32 { todo!() }\n+        fn baz(&mut self) {\n+            Self::foo(self, Self::bar(self)); //~ ERROR\n+        }\n+    }\n+}"}, {"sha": "eb934e7b72b084a6266998d1617113b2a1d586a8", "filename": "src/test/ui/borrowck/suggest-local-var-imm-and-mut.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fsuggest-local-var-imm-and-mut.stderr?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -0,0 +1,22 @@\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:12:22\n+   |\n+LL |             self.foo(self.bar());\n+   |             ---------^^^^^^^^^^-\n+   |             |    |   |\n+   |             |    |   mutable borrow occurs here\n+   |             |    immutable borrow later used by call\n+   |             immutable borrow occurs here\n+\n+error[E0502]: cannot borrow `*self` as mutable because it is also borrowed as immutable\n+  --> $DIR/suggest-local-var-imm-and-mut.rs:24:29\n+   |\n+LL |             Self::foo(self, Self::bar(self));\n+   |             --------- ----  ^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |             |         |\n+   |             |         immutable borrow occurs here\n+   |             immutable borrow later used by call\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "85c7159952ffa59ea353345627765e3b0d1e497d", "filename": "src/test/ui/borrowck/two-phase-cannot-nest-mut-self-calls.stderr", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-cannot-nest-mut-self-calls.stderr?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -13,6 +13,23 @@ LL | |\n LL | |         0\n LL | |     });\n    | |______- immutable borrow occurs here\n+   |\n+help: try adding a local storing this argument...\n+  --> $DIR/two-phase-cannot-nest-mut-self-calls.rs:16:9\n+   |\n+LL |         vec.push(2);\n+   |         ^^^^^^^^^^^\n+help: ...and then using that local as the argument to this call\n+  --> $DIR/two-phase-cannot-nest-mut-self-calls.rs:14:5\n+   |\n+LL | /     vec.get({\n+LL | |\n+LL | |         vec.push(2);\n+LL | |\n+LL | |\n+LL | |         0\n+LL | |     });\n+   | |______^\n \n error: aborting due to previous error\n "}, {"sha": "6fe6e26135b9202e9d17891b90143d89eca80892", "filename": "src/test/ui/codemap_tests/one_line.stderr", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/433a13b47347849dbc8c5d5300b98b95be7fb2c9/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fone_line.stderr?ref=433a13b47347849dbc8c5d5300b98b95be7fb2c9", "patch": "@@ -7,6 +7,17 @@ LL |     v.push(v.pop().unwrap());\n    |     | |    second mutable borrow occurs here\n    |     | first borrow later used by call\n    |     first mutable borrow occurs here\n+   |\n+help: try adding a local storing this argument...\n+  --> $DIR/one_line.rs:3:12\n+   |\n+LL |     v.push(v.pop().unwrap());\n+   |            ^^^^^^^\n+help: ...and then using that local as the argument to this call\n+  --> $DIR/one_line.rs:3:5\n+   |\n+LL |     v.push(v.pop().unwrap());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}