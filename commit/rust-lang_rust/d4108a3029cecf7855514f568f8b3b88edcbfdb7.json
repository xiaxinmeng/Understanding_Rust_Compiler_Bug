{"sha": "d4108a3029cecf7855514f568f8b3b88edcbfdb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MTA4YTMwMjljZWNmNzg1NTUxNGY1NjhmOGIzYjg4ZWRjYmZkYjc=", "commit": {"author": {"name": "Pavel Sountsov", "email": "siege@google.com", "date": "2015-09-06T05:39:28Z"}, "committer": {"name": "SiegeLord", "email": "slabode@aim.com", "date": "2015-09-19T17:36:45Z"}, "message": "Initial implementation of hard tab indentation.", "tree": {"sha": "7f7fd3736a20190e8008aa63d9f557716de45621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7fd3736a20190e8008aa63d9f557716de45621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4108a3029cecf7855514f568f8b3b88edcbfdb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4108a3029cecf7855514f568f8b3b88edcbfdb7", "html_url": "https://github.com/rust-lang/rust/commit/d4108a3029cecf7855514f568f8b3b88edcbfdb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4108a3029cecf7855514f568f8b3b88edcbfdb7/comments", "author": {"login": "SiegeLordEx", "id": 43966695, "node_id": "MDQ6VXNlcjQzOTY2Njk1", "avatar_url": "https://avatars.githubusercontent.com/u/43966695?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLordEx", "html_url": "https://github.com/SiegeLordEx", "followers_url": "https://api.github.com/users/SiegeLordEx/followers", "following_url": "https://api.github.com/users/SiegeLordEx/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLordEx/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLordEx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLordEx/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLordEx/orgs", "repos_url": "https://api.github.com/users/SiegeLordEx/repos", "events_url": "https://api.github.com/users/SiegeLordEx/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLordEx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SiegeLord", "id": 480550, "node_id": "MDQ6VXNlcjQ4MDU1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/480550?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SiegeLord", "html_url": "https://github.com/SiegeLord", "followers_url": "https://api.github.com/users/SiegeLord/followers", "following_url": "https://api.github.com/users/SiegeLord/following{/other_user}", "gists_url": "https://api.github.com/users/SiegeLord/gists{/gist_id}", "starred_url": "https://api.github.com/users/SiegeLord/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SiegeLord/subscriptions", "organizations_url": "https://api.github.com/users/SiegeLord/orgs", "repos_url": "https://api.github.com/users/SiegeLord/repos", "events_url": "https://api.github.com/users/SiegeLord/events{/privacy}", "received_events_url": "https://api.github.com/users/SiegeLord/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4", "html_url": "https://github.com/rust-lang/rust/commit/4e1fff8710d9ad67cdfac08dbd6ffcb0c6fc4bc4"}], "stats": {"total": 582, "additions": 368, "deletions": 214}, "files": [{"sha": "daf800ace088dc9a01df1b0464a9e0e7d0960297", "filename": "src/chains.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -19,6 +19,7 @@\n // we put each subexpression on a separate, much like the (default) function\n // argument function argument strategy.\n \n+use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use utils::{first_line_width, make_indent};\n use expr::rewrite_call;\n@@ -30,7 +31,7 @@ use syntax::print::pprust;\n pub fn rewrite_chain(mut expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n     let mut subexpr_list = vec![expr];\n@@ -116,7 +117,7 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n     let connector = if fits_single_line {\n         String::new()\n     } else {\n-        format!(\"\\n{}\", make_indent(indent))\n+        format!(\"\\n{}\", make_indent(indent, context.config))\n     };\n \n     let first_connector = if extend {\n@@ -145,7 +146,7 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                       span: Span,\n                       context: &RewriteContext,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     match expr.node {\n         ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n@@ -179,7 +180,7 @@ fn rewrite_method_call(method_name: ast::Ident,\n                        span: Span,\n                        context: &RewriteContext,\n                        width: usize,\n-                       offset: usize)\n+                       offset: Indent)\n                        -> Option<String> {\n     let type_str = if types.is_empty() {\n         String::new()"}, {"sha": "683bf4b650c8ca0cab6507379de1526a2ce2de3b", "filename": "src/comment.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -12,10 +12,17 @@\n \n use std::iter;\n \n+use Indent;\n+use config::Config;\n use string::{StringFormat, rewrite_string};\n use utils::make_indent;\n \n-pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usize) -> String {\n+pub fn rewrite_comment(orig: &str,\n+                       block_style: bool,\n+                       width: usize,\n+                       offset: Indent,\n+                       config: &Config)\n+                       -> String {\n     let s = orig.trim();\n \n     // Edge case: block comments. Let's not trim their lines (for now).\n@@ -33,11 +40,12 @@ pub fn rewrite_comment(orig: &str, block_style: bool, width: usize, offset: usiz\n         line_start: line_start,\n         line_end: \"\",\n         width: max_chars,\n-        offset: offset + opener.len() - line_start.len(),\n+        offset: offset + (opener.len() - line_start.len()),\n         trim_end: true,\n+        config: config,\n     };\n \n-    let indent_str = make_indent(offset);\n+    let indent_str = make_indent(offset, config);\n     let line_breaks = s.chars().filter(|&c| c == '\\n').count();\n \n     let (_, mut s) = s.lines()\n@@ -288,27 +296,32 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n mod test {\n     use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented};\n \n-    // FIXME(#217): prevent string literal from going over the limit.\n+    use Indent;\n     #[test]\n     #[rustfmt_skip]\n     fn format_comments() {\n-        assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, 100));\n-        assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10, 0));\n+        let config = Default::default();\n+        assert_eq!(\"/* test */\", rewrite_comment(\" //test\", true, 100, Indent::new(0, 100),\n+                                                 &config));\n+        assert_eq!(\"// comment\\n// on a\", rewrite_comment(\"// comment on a\", false, 10,\n+                                                          Indent::new(0, 0), &config));\n \n         assert_eq!(\"//  A multi line comment\\n            // between args.\",\n                    rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n                                    false,\n                                    60,\n-                                   12));\n+                                   Indent::new(0, 12),\n+                                   &config));\n \n         let input = \"// comment\";\n         let expected =\n             \"/* com\\n                                                                      \\\n              * men\\n                                                                      \\\n              * t */\";\n-        assert_eq!(expected, rewrite_comment(input, true, 9, 69));\n+        assert_eq!(expected, rewrite_comment(input, true, 9, Indent::new(0, 69), &config));\n \n-        assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100, 100));\n+        assert_eq!(\"/* trimmed */\", rewrite_comment(\"/*   trimmed    */\", true, 100,\n+                                                    Indent::new(0, 100), &config));\n     }\n \n     // This is probably intended to be a non-test fn, but it is not used. I'm"}, {"sha": "c5b777e1d81cd12ac230bfd059ea88deafa39e73", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -246,6 +246,7 @@ create_config! {\n     format_strings: bool, \"Format string literals, or leave as is\",\n     chains_overflow_last: bool, \"Allow last call in method chain to break the line\",\n     take_source_hints: bool, \"Retain some formatting characteristics from the source code\",\n+    hard_tabs: bool, \"Use tab characters for indentation, spaces for alignment\",\n }\n \n impl Default for Config {\n@@ -279,6 +280,7 @@ impl Default for Config {\n             format_strings: true,\n             chains_overflow_last: true,\n             take_source_hints: true,\n+            hard_tabs: false,\n         }\n     }\n }"}, {"sha": "3e8401af8b9788f9173cf0e0c8fc216db74137f4", "filename": "src/expr.rs", "status": "modified", "additions": 76, "deletions": 57, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -11,6 +11,7 @@\n use std::cmp::Ordering;\n use std::borrow::Borrow;\n \n+use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n use string::{StringFormat, rewrite_string};\n@@ -29,7 +30,7 @@ use syntax::codemap::{CodeMap, Span, BytePos, mk_sp};\n use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::Expr_::ExprVec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e), self.span, context, width, offset)\n@@ -164,7 +165,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                             span: Span,\n                             context: &RewriteContext,\n                             width: usize,\n-                            offset: usize)\n+                            offset: Indent)\n                             -> Option<String>\n     where I: Iterator<Item = &'a ast::Expr>\n {\n@@ -201,6 +202,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         h_width: max_item_width,\n         v_width: max_item_width,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n@@ -215,7 +217,7 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                    span: Span,\n                    context: &RewriteContext,\n                    width: usize,\n-                   offset: usize)\n+                   offset: Indent)\n                    -> Option<String> {\n     let mover = if capture == ast::CaptureClause::CaptureByValue {\n         \"move \"\n@@ -258,14 +260,15 @@ fn rewrite_closure(capture: ast::CaptureClause,\n         h_width: horizontal_budget,\n         v_width: budget,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n     let mut prefix = format!(\"{}|{}|\", mover, list_str);\n \n     if !ret_str.is_empty() {\n         if prefix.contains('\\n') {\n             prefix.push('\\n');\n-            prefix.push_str(&make_indent(argument_offset));\n+            prefix.push_str(&make_indent(argument_offset, context.config));\n         } else {\n             prefix.push(' ');\n         }\n@@ -308,18 +311,18 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                            .as_ref()\n                            .and_then(|body_expr| {\n                                if let ast::Expr_::ExprBlock(ref inner) = body_expr.node {\n-                                   Some(inner.rewrite(&context, 2, 0))\n+                                   Some(inner.rewrite(&context, 2, Indent::new(0, 0)))\n                                } else {\n                                    None\n                                }\n                            })\n-                           .unwrap_or_else(|| body.rewrite(&context, 2, 0));\n+                           .unwrap_or_else(|| body.rewrite(&context, 2, Indent::new(0, 0)));\n \n     Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n }\n \n impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let user_str = context.snippet(self.span);\n         if user_str == \"{}\" && width >= 2 {\n             return Some(user_str);\n@@ -341,7 +344,8 @@ impl Rewrite for ast::Block {\n                 let prefix = if !trimmed.is_empty() {\n                     // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n                     let budget = try_opt!(width.checked_sub(9));\n-                    format!(\"unsafe {} \", rewrite_comment(trimmed, true, budget, offset + 7))\n+                    format!(\"unsafe {} \",\n+                            rewrite_comment(trimmed, true, budget, offset + 7, context.config))\n                 } else {\n                     \"unsafe \".to_owned()\n                 };\n@@ -381,7 +385,7 @@ impl Rewrite for ast::Block {\n \n // FIXME(#18): implement pattern formatting\n impl Rewrite for ast::Pat {\n-    fn rewrite(&self, context: &RewriteContext, _: usize, _: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, _: usize, _: Indent) -> Option<String> {\n         Some(context.snippet(self.span))\n     }\n }\n@@ -447,7 +451,7 @@ impl<'a> Loop<'a> {\n }\n \n impl<'a> Rewrite for Loop<'a> {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let label_string = rewrite_label(self.label);\n         // 2 = \" {\".len()\n         let inner_width = try_opt!(width.checked_sub(self.keyword.len() + 2 + label_string.len()));\n@@ -483,7 +487,7 @@ fn rewrite_range(context: &RewriteContext,\n                  left: Option<&ast::Expr>,\n                  right: Option<&ast::Expr>,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     let left_string = match left {\n         Some(expr) => {\n@@ -513,7 +517,7 @@ fn rewrite_if_else(context: &RewriteContext,\n                    else_block_opt: Option<&ast::Expr>,\n                    pat: Option<&ast::Pat>,\n                    width: usize,\n-                   offset: usize,\n+                   offset: Indent,\n                    allow_single_line: bool)\n                    -> Option<String> {\n     // 3 = \"if \", 2 = \" {\"\n@@ -588,11 +592,11 @@ fn single_line_if_else(context: &RewriteContext,\n \n         let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n         let if_expr = if_node.expr.as_ref().unwrap();\n-        let if_str = try_opt!(if_expr.rewrite(context, new_width, 0));\n+        let if_str = try_opt!(if_expr.rewrite(context, new_width, Indent::new(0, 0)));\n \n         let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n         let else_expr = else_node.expr.as_ref().unwrap();\n-        let else_str = try_opt!(else_expr.rewrite(context, new_width, 0));\n+        let else_str = try_opt!(else_expr.rewrite(context, new_width, Indent::new(0, 0)));\n \n         // FIXME: this check shouldn't be necessary. Rewrites should either fail\n         // or wrap to a newline when the object does not fit the width.\n@@ -621,7 +625,7 @@ fn rewrite_match(context: &RewriteContext,\n                  cond: &ast::Expr,\n                  arms: &[ast::Arm],\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     if arms.is_empty() {\n         return None;\n@@ -634,7 +638,7 @@ fn rewrite_match(context: &RewriteContext,\n \n     let nested_context = context.nested_context();\n     let arm_indent = nested_context.block_indent + context.overflow_indent;\n-    let arm_indent_str = make_indent(arm_indent);\n+    let arm_indent_str = make_indent(arm_indent, context.config);\n \n     let open_brace_pos = span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])),\n                                     \"{\",\n@@ -669,7 +673,7 @@ fn rewrite_match(context: &RewriteContext,\n         result.push_str(&arm_indent_str);\n \n         let arm_str = arm.rewrite(&nested_context,\n-                                  context.config.max_width - arm_indent,\n+                                  context.config.max_width - arm_indent.width(),\n                                   arm_indent);\n         if let Some(ref arm_str) = arm_str {\n             result.push_str(arm_str);\n@@ -684,7 +688,7 @@ fn rewrite_match(context: &RewriteContext,\n     // match expression, but meh.\n \n     result.push('\\n');\n-    result.push_str(&make_indent(context.block_indent + context.overflow_indent));\n+    result.push_str(&make_indent(context.block_indent + context.overflow_indent, context.config));\n     result.push('}');\n     Some(result)\n }\n@@ -704,9 +708,9 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n \n // Match arms.\n impl Rewrite for ast::Arm {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let &ast::Arm { ref attrs, ref pats, ref guard, ref body } = self;\n-        let indent_str = make_indent(offset);\n+        let indent_str = make_indent(offset, context.config);\n \n         // FIXME this is all a bit grotty, would be nice to abstract out the\n         // treatment of attributes.\n@@ -734,7 +738,7 @@ impl Rewrite for ast::Arm {\n                                     .map(|p| {\n                                         p.rewrite(context,\n                                                   pat_budget,\n-                                                  offset + context.config.tab_spaces)\n+                                                  offset.block_indent(context.config.tab_spaces))\n                                     })\n                                     .collect::<Option<Vec<_>>>());\n \n@@ -775,7 +779,12 @@ impl Rewrite for ast::Arm {\n         // Where the next text can start.\n         let mut line_start = last_line_width(&pats_str);\n         if pats_str.find('\\n').is_none() {\n-            line_start += offset;\n+            line_start += offset.width();\n+        }\n+\n+        let mut line_indent = offset + pats_width;\n+        if vertical {\n+            line_indent = line_indent.block_indent(context.config.tab_spaces);\n         }\n \n         let comma = if let ast::ExprBlock(_) = body.node {\n@@ -788,7 +797,7 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            if let Some(ref body_str) = body.rewrite(context, budget, line_start + 4) {\n+            if let Some(ref body_str) = body.rewrite(context, budget, line_indent + 4) {\n                 if first_line_width(body_str) <= budget {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n@@ -810,7 +819,7 @@ impl Rewrite for ast::Arm {\n         Some(format!(\"{}{} =>\\n{}{},\",\n                      attr_str.trim_left(),\n                      pats_str,\n-                     make_indent(offset + context.config.tab_spaces),\n+                     make_indent(offset.block_indent(context.config.tab_spaces), context.config),\n                      body_str))\n     }\n }\n@@ -819,7 +828,7 @@ impl Rewrite for ast::Arm {\n fn rewrite_guard(context: &RewriteContext,\n                  guard: &Option<ptr::P<ast::Expr>>,\n                  width: usize,\n-                 offset: usize,\n+                 offset: Indent,\n                  // The amount of space used up on this line for the pattern in\n                  // the arm (excludes offset).\n                  pattern_width: usize)\n@@ -840,10 +849,11 @@ fn rewrite_guard(context: &RewriteContext,\n         if overhead < width {\n             let cond_str = guard.rewrite(context,\n                                          width - overhead,\n-                                         offset + context.config.tab_spaces);\n+                                         offset.block_indent(context.config.tab_spaces));\n             if let Some(cond_str) = cond_str {\n                 return Some(format!(\"\\n{}if {}\",\n-                                    make_indent(offset + context.config.tab_spaces),\n+                                    make_indent(offset.block_indent(context.config.tab_spaces),\n+                                                context.config),\n                                     cond_str));\n             }\n         }\n@@ -862,7 +872,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     // *without* trailing space.\n                     connector: &str,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     let pat_offset = offset + matcher.len();\n     let mut result = match pat {\n@@ -898,9 +908,11 @@ fn rewrite_pat_expr(context: &RewriteContext,\n \n     // The expression won't fit on the current line, jump to next.\n     result.push('\\n');\n-    result.push_str(&make_indent(pat_offset));\n+    result.push_str(&make_indent(pat_offset, context.config));\n \n-    let expr_rewrite = expr.rewrite(context, context.config.max_width - pat_offset, pat_offset);\n+    let expr_rewrite = expr.rewrite(context,\n+                                    context.config.max_width - pat_offset.width(),\n+                                    pat_offset);\n     result.push_str(&&try_opt!(expr_rewrite));\n \n     Some(result)\n@@ -909,7 +921,7 @@ fn rewrite_pat_expr(context: &RewriteContext,\n fn rewrite_string_lit(context: &RewriteContext,\n                       span: Span,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     if !context.config.format_strings {\n         return Some(context.snippet(span));\n@@ -923,6 +935,7 @@ fn rewrite_string_lit(context: &RewriteContext,\n         width: width,\n         offset: offset,\n         trim_end: false,\n+        config: context.config,\n     };\n \n     let string_lit = context.snippet(span);\n@@ -936,7 +949,7 @@ pub fn rewrite_call<R>(context: &RewriteContext,\n                        args: &[ptr::P<ast::Expr>],\n                        span: Span,\n                        width: usize,\n-                       offset: usize)\n+                       offset: Indent)\n                        -> Option<String>\n     where R: Rewrite\n {\n@@ -955,7 +968,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                          args: &[ptr::P<ast::Expr>],\n                          span: Span,\n                          width: usize,\n-                         offset: usize)\n+                         offset: Indent)\n                          -> Result<String, Ordering>\n     where R: Rewrite\n {\n@@ -1003,7 +1016,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                              span.lo,\n                              span.hi);\n \n-    let fmt = ListFormatting::for_fn(remaining_width, offset);\n+    let fmt = ListFormatting::for_fn(remaining_width, offset, context.config);\n     let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n         Some(str) => str,\n         None => return Err(Ordering::Less),\n@@ -1015,9 +1028,9 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n fn rewrite_paren(context: &RewriteContext,\n                  subexpr: &ast::Expr,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n-    debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n+    debug!(\"rewrite_paren, width: {}, offset: {:?}\", width, offset);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n     let subexpr_str = subexpr.rewrite(context, try_opt!(width.checked_sub(2)), offset + 1);\n@@ -1031,9 +1044,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                           base: Option<&'a ast::Expr>,\n                           span: Span,\n                           width: usize,\n-                          offset: usize)\n+                          offset: Indent)\n                           -> Option<String> {\n-    debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n+    debug!(\"rewrite_struct_lit: width {}, offset {:?}\", width, offset);\n     assert!(!fields.is_empty() || base.is_some());\n \n     enum StructLitField<'a> {\n@@ -1054,8 +1067,8 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         StructLitStyle::Block => {\n             // If we are all on one line, then we'll ignore the indent, and we\n             // have a smaller budget.\n-            let indent = context.block_indent + context.config.tab_spaces;\n-            let v_budget = context.config.max_width.checked_sub(indent).unwrap_or(0);\n+            let indent = context.block_indent.block_indent(context.config.tab_spaces);\n+            let v_budget = context.config.max_width.checked_sub(indent.width()).unwrap_or(0);\n             (indent, v_budget)\n         }\n     };\n@@ -1121,12 +1134,15 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n         h_width: h_budget,\n         v_width: v_budget,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n     let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     let format_on_newline = || {\n-        let inner_indent = make_indent(context.block_indent + context.config.tab_spaces);\n-        let outer_indent = make_indent(context.block_indent);\n+        let inner_indent = make_indent(context.block_indent\n+                                              .block_indent(context.config.tab_spaces),\n+                                       context.config);\n+        let outer_indent = make_indent(context.block_indent, context.config);\n         Some(format!(\"{} {{\\n{}{}\\n{}}}\", path_str, inner_indent, fields_str, outer_indent))\n     };\n \n@@ -1143,7 +1159,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n fn rewrite_field(context: &RewriteContext,\n                  field: &ast::Field,\n                  width: usize,\n-                 offset: usize)\n+                 offset: Indent)\n                  -> Option<String> {\n     let name = &field.ident.node.to_string();\n     let overhead = name.len() + 2;\n@@ -1156,9 +1172,9 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                      items: &[ptr::P<ast::Expr>],\n                      span: Span,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n-    debug!(\"rewrite_tuple_lit: width: {}, offset: {}\", width, offset);\n+    debug!(\"rewrite_tuple_lit: width: {}, offset: {:?}\", width, offset);\n     let indent = offset + 1;\n     // In case of length 1, need a trailing comma\n     if items.len() == 1 {\n@@ -1173,15 +1189,15 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n                              |item| {\n-                                 let inner_width = context.config.max_width - indent - 1;\n+                                 let inner_width = context.config.max_width - indent.width() - 1;\n                                  item.rewrite(context, inner_width, indent)\n                                      .unwrap_or(context.snippet(item.span))\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n \n     let budget = try_opt!(width.checked_sub(2));\n-    let fmt = ListFormatting::for_fn(budget, indent);\n+    let fmt = ListFormatting::for_fn(budget, indent, context.config);\n     let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n     Some(format!(\"({})\", list_str))\n@@ -1192,7 +1208,7 @@ fn rewrite_binary_op(context: &RewriteContext,\n                      lhs: &ast::Expr,\n                      rhs: &ast::Expr,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     // FIXME: format comments between operands and operator\n \n@@ -1233,19 +1249,21 @@ fn rewrite_binary_op(context: &RewriteContext,\n     // We have to use multiple lines.\n \n     // Re-evaluate the lhs because we have more space now:\n-    let budget = try_opt!(context.config.max_width.checked_sub(offset + 1 + operator_str.len()));\n+    let budget = try_opt!(context.config\n+                                 .max_width\n+                                 .checked_sub(offset.width() + 1 + operator_str.len()));\n     Some(format!(\"{} {}\\n{}{}\",\n                  try_opt!(lhs.rewrite(context, budget, offset)),\n                  operator_str,\n-                 make_indent(offset),\n+                 make_indent(offset, context.config),\n                  rhs_result))\n }\n \n fn rewrite_unary_op(context: &RewriteContext,\n                     op: &ast::UnOp,\n                     expr: &ast::Expr,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     // For some reason, an UnOp is not spanned like BinOp!\n     let operator_str = match *op {\n@@ -1265,7 +1283,7 @@ fn rewrite_assignment(context: &RewriteContext,\n                       rhs: &ast::Expr,\n                       op: Option<&ast::BinOp>,\n                       width: usize,\n-                      offset: usize)\n+                      offset: Indent)\n                       -> Option<String> {\n     let operator_str = match op {\n         Some(op) => context.snippet(op.span),\n@@ -1285,7 +1303,7 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n                                            lhs: S,\n                                            ex: &ast::Expr,\n                                            width: usize,\n-                                           offset: usize)\n+                                           offset: Indent)\n                                            -> Option<String> {\n     let mut result = lhs.into();\n \n@@ -1301,13 +1319,14 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n         None => {\n             // Expression did not fit on the same line as the identifier. Retry\n             // on the next line.\n-            let new_offset = offset + context.config.tab_spaces;\n-            result.push_str(&format!(\"\\n{}\", make_indent(new_offset)));\n+            let new_offset = offset.block_indent(context.config.tab_spaces);\n+            result.push_str(&format!(\"\\n{}\", make_indent(new_offset, context.config)));\n \n             // FIXME: we probably should related max_width to width instead of config.max_width\n             // where is the 1 coming from anyway?\n-            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset + 1));\n-            let overflow_context = context.overflow_context(context.config.tab_spaces);\n+            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n+            let rhs_indent = Indent::new(context.config.tab_spaces, 0);\n+            let overflow_context = context.overflow_context(rhs_indent);\n             let rhs = ex.rewrite(&overflow_context, max_width, new_offset);\n \n             result.push_str(&&try_opt!(rhs));"}, {"sha": "f5f81015efbd88ccbb972665ca6416f140351a9e", "filename": "src/imports.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use Indent;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n@@ -20,7 +21,7 @@ use syntax::codemap::Span;\n \n impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n                 Some(String::new())\n@@ -68,7 +69,7 @@ fn rewrite_single_use_list(path_str: String, vpi: ast::PathListItem) -> String {\n // Pretty prints a multi-item import.\n // Assumes that path_list.len() > 0.\n pub fn rewrite_use_list(width: usize,\n-                        offset: usize,\n+                        offset: Indent,\n                         path: &ast::Path,\n                         path_list: &[ast::PathListItem],\n                         span: Span,\n@@ -105,6 +106,7 @@ pub fn rewrite_use_list(width: usize,\n         // (loose 1 column (\";\"))\n         v_width: remaining_width,\n         ends_with_newline: false,\n+        config: context.config,\n     };\n \n     let mut items = {"}, {"sha": "ae55fdf4c29bcbad7687be667662ef0e53219575", "filename": "src/items.rs", "status": "modified", "additions": 75, "deletions": 60, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -10,6 +10,7 @@\n \n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n+use Indent;\n use utils::{format_mutability, format_visibility, make_indent, contains_skip, span_after,\n             end_typaram, wrap_str};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n@@ -26,16 +27,15 @@ use syntax::parse::token;\n \n impl<'a> FmtVisitor<'a> {\n     pub fn visit_let(&mut self, local: &ast::Local, span: Span) {\n-        self.format_missing_with_indent(span.lo);\n+        self.format_missing_with_indent(span.lo, self.config);\n \n         // String that is placed within the assignment pattern and expression.\n         let infix = {\n             let mut infix = String::new();\n \n             if let Some(ref ty) = local.ty {\n                 infix.push_str(\": \");\n-                // FIXME: silly width, indent\n-                infix.push_str(&ty.rewrite(&self.get_context(), 1000, 0).unwrap());\n+                infix.push_str(&ty.rewrite(&self.get_context(), 1000, Indent::new(0, 0)).unwrap());\n             }\n \n             if local.init.is_some() {\n@@ -52,20 +52,22 @@ impl<'a> FmtVisitor<'a> {\n             let mut result = \"let \".to_owned();\n             let pattern_offset = self.block_indent + result.len() + infix.len();\n             // 1 = ;\n-            let pattern_width = match self.config.max_width.checked_sub(pattern_offset + 1) {\n+            let pattern_width = self.config.max_width.checked_sub(pattern_offset.width() + 1);\n+            let pattern_width = match pattern_width {\n                 Some(width) => width,\n                 None => return,\n             };\n \n-            match local.pat.rewrite(&context, pattern_offset, pattern_width) {\n+            match local.pat.rewrite(&context, pattern_width, pattern_offset) {\n                 Some(ref pat_string) => result.push_str(pat_string),\n                 None => return,\n             }\n \n             result.push_str(&infix);\n \n             if let Some(ref ex) = local.init {\n-                let max_width = match self.config.max_width.checked_sub(context.block_indent + 1) {\n+                let max_width = self.config.max_width.checked_sub(context.block_indent.width() + 1);\n+                let max_width = match max_width {\n                     Some(width) => width,\n                     None => return,\n                 };\n@@ -88,7 +90,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn rewrite_fn(&mut self,\n-                      indent: usize,\n+                      indent: Indent,\n                       ident: ast::Ident,\n                       fd: &ast::FnDecl,\n                       explicit_self: Option<&ast::ExplicitSelf>,\n@@ -124,7 +126,7 @@ impl<'a> FmtVisitor<'a> {\n         // this.\n         if newline_brace {\n             result.push('\\n');\n-            result.push_str(&make_indent(indent));\n+            result.push_str(&make_indent(indent, self.config));\n         } else {\n             result.push(' ');\n         }\n@@ -133,7 +135,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     pub fn rewrite_required_fn(&mut self,\n-                               indent: usize,\n+                               indent: Indent,\n                                ident: ast::Ident,\n                                sig: &ast::MethodSig,\n                                span: Span)\n@@ -160,7 +162,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn rewrite_fn_base(&mut self,\n-                       indent: usize,\n+                       indent: Indent,\n                        ident: ast::Ident,\n                        fd: &ast::FnDecl,\n                        explicit_self: Option<&ast::ExplicitSelf>,\n@@ -207,13 +209,15 @@ impl<'a> FmtVisitor<'a> {\n         result.push_str(&generics_str);\n \n         let context = self.get_context();\n-        let ret_str = fd.output.rewrite(&context, self.config.max_width - indent, indent).unwrap();\n+        let ret_str = fd.output\n+                        .rewrite(&context, self.config.max_width - indent.width(), indent)\n+                        .unwrap();\n \n         // Args.\n         let (one_line_budget, multi_line_budget, mut arg_indent) =\n             self.compute_budgets_for_args(&result, indent, ret_str.len(), newline_brace);\n \n-        debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {}\",\n+        debug!(\"rewrite_fn: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n                one_line_budget,\n                multi_line_budget,\n                arg_indent);\n@@ -222,17 +226,17 @@ impl<'a> FmtVisitor<'a> {\n         if one_line_budget <= 0 {\n             if self.config.fn_args_paren_newline {\n                 result.push('\\n');\n-                result.push_str(&make_indent(arg_indent));\n+                result.push_str(&make_indent(arg_indent, self.config));\n                 arg_indent = arg_indent + 1; // extra space for `(`\n                 result.push('(');\n             } else {\n                 result.push_str(\"(\\n\");\n-                result.push_str(&make_indent(arg_indent));\n+                result.push_str(&make_indent(arg_indent, self.config));\n             }\n         } else if self.config.fn_args_layout == StructLitStyle::Block {\n-            arg_indent = indent + self.config.tab_spaces;\n+            arg_indent = indent.block_indent(self.config.tab_spaces);\n             result.push_str(\"(\\n\");\n-            result.push_str(&make_indent(arg_indent));\n+            result.push_str(&make_indent(arg_indent, self.config));\n         } else {\n             result.push('(');\n         }\n@@ -266,7 +270,7 @@ impl<'a> FmtVisitor<'a> {\n             // Unless we are formatting args like a block, in which case there\n             // should always be room for the return type.\n             if (result.contains(\"\\n\") ||\n-                result.len() + indent + ret_str.len() > self.config.max_width) &&\n+                result.len() + indent.width() + ret_str.len() > self.config.max_width) &&\n                self.config.fn_args_layout != StructLitStyle::Block {\n                 let indent = match self.config.fn_return_indent {\n                     ReturnIndent::WithWhereClause => indent + 4,\n@@ -277,7 +281,7 @@ impl<'a> FmtVisitor<'a> {\n                 };\n \n                 result.push('\\n');\n-                result.push_str(&make_indent(indent));\n+                result.push_str(&make_indent(indent, self.config));\n             } else {\n                 result.push(' ');\n             }\n@@ -326,8 +330,8 @@ impl<'a> FmtVisitor<'a> {\n                     explicit_self: Option<&ast::ExplicitSelf>,\n                     one_line_budget: usize,\n                     multi_line_budget: usize,\n-                    indent: usize,\n-                    arg_indent: usize,\n+                    indent: Indent,\n+                    arg_indent: Indent,\n                     span: Span)\n                     -> Option<String> {\n         let context = self.get_context();\n@@ -386,7 +390,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let indent = match self.config.fn_arg_indent {\n             BlockIndentStyle::Inherit => indent,\n-            BlockIndentStyle::Tabbed => indent + self.config.tab_spaces,\n+            BlockIndentStyle::Tabbed => indent.block_indent(self.config.tab_spaces),\n             BlockIndentStyle::Visual => arg_indent,\n         };\n \n@@ -398,23 +402,24 @@ impl<'a> FmtVisitor<'a> {\n             h_width: one_line_budget,\n             v_width: multi_line_budget,\n             ends_with_newline: false,\n+            config: self.config,\n         };\n \n         write_list(&arg_items, &fmt)\n     }\n \n     fn compute_budgets_for_args(&self,\n                                 result: &str,\n-                                indent: usize,\n+                                indent: Indent,\n                                 ret_str_len: usize,\n                                 newline_brace: bool)\n-                                -> (usize, usize, usize) {\n+                                -> (usize, usize, Indent) {\n         let mut budgets = None;\n \n         // Try keeping everything on the same line\n         if !result.contains(\"\\n\") {\n             // 3 = `() `, space is before ret_string\n-            let mut used_space = indent + result.len() + ret_str_len + 3;\n+            let mut used_space = indent.width() + result.len() + ret_str_len + 3;\n             if !newline_brace {\n                 used_space += 2;\n             }\n@@ -425,7 +430,7 @@ impl<'a> FmtVisitor<'a> {\n             };\n \n             // 2 = `()`\n-            let used_space = indent + result.len() + 2;\n+            let used_space = indent.width() + result.len() + 2;\n             let max_space = self.config.ideal_width + self.config.leeway;\n             debug!(\"compute_budgets_for_args: used_space: {}, max_space: {}\",\n                    used_space,\n@@ -439,8 +444,8 @@ impl<'a> FmtVisitor<'a> {\n \n         // Didn't work. we must force vertical layout and put args on a newline.\n         if let None = budgets {\n-            let new_indent = indent + self.config.tab_spaces;\n-            let used_space = new_indent + 2; // account for `(` and `)`\n+            let new_indent = indent.block_indent(self.config.tab_spaces);\n+            let used_space = new_indent.width() + 2; // account for `(` and `)`\n             let max_space = self.config.ideal_width + self.config.leeway;\n             if used_space > max_space {\n                 // Whoops! bankrupt.\n@@ -475,13 +480,14 @@ impl<'a> FmtVisitor<'a> {\n         let generics_str = self.format_generics(generics,\n                                                 \" {\",\n                                                 self.block_indent,\n-                                                self.block_indent + self.config.tab_spaces,\n+                                                self.block_indent\n+                                                    .block_indent(self.config.tab_spaces),\n                                                 codemap::mk_sp(span.lo, body_start))\n                                .unwrap();\n         self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n-        self.block_indent += self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_indent(self.config.tab_spaces);\n         for (i, f) in enum_def.variants.iter().enumerate() {\n             let next_span_start: BytePos = if i == enum_def.variants.len() - 1 {\n                 span.hi\n@@ -491,9 +497,10 @@ impl<'a> FmtVisitor<'a> {\n \n             self.visit_variant(f, i == enum_def.variants.len() - 1, next_span_start);\n         }\n-        self.block_indent -= self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_unindent(self.config.tab_spaces);\n \n-        self.format_missing_with_indent(span.lo + BytePos(enum_snippet.rfind('}').unwrap() as u32));\n+        self.format_missing_with_indent(span.lo + BytePos(enum_snippet.rfind('}').unwrap() as u32),\n+                                        self.config);\n         self.buffer.push_str(\"}\");\n     }\n \n@@ -503,7 +510,7 @@ impl<'a> FmtVisitor<'a> {\n             return;\n         }\n \n-        self.format_missing_with_indent(field.span.lo);\n+        self.format_missing_with_indent(field.span.lo, self.config);\n \n         let result = match field.node.kind {\n             ast::VariantKind::TupleVariantKind(ref types) => {\n@@ -521,7 +528,9 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| {\n                                                  // FIXME silly width, indent\n                                                  arg.ty\n-                                                    .rewrite(&self.get_context(), 1000, 0)\n+                                                    .rewrite(&self.get_context(),\n+                                                             1000,\n+                                                             Indent::new(0, 0))\n                                                     .unwrap()\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n@@ -536,7 +545,7 @@ impl<'a> FmtVisitor<'a> {\n                     } else {\n                         0\n                     };\n-                    let budget = self.config.ideal_width - indent - comma_cost - 1; // 1 = )\n+                    let budget = self.config.ideal_width - indent.width() - comma_cost - 1; // 1 = )\n \n                     let fmt = ListFormatting {\n                         tactic: ListTactic::HorizontalVertical,\n@@ -546,6 +555,7 @@ impl<'a> FmtVisitor<'a> {\n                         h_width: budget,\n                         v_width: budget,\n                         ends_with_newline: true,\n+                        config: self.config,\n                     };\n                     let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n                         Some(list_str) => list_str,\n@@ -601,7 +611,7 @@ impl<'a> FmtVisitor<'a> {\n                      struct_def: &ast::StructDef,\n                      generics: Option<&ast::Generics>,\n                      span: Span,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n         let mut result = String::with_capacity(1024);\n \n@@ -654,15 +664,15 @@ impl<'a> FmtVisitor<'a> {\n                                  span.hi);\n \n         // 2 terminators and a semicolon\n-        let used_budget = offset + header_str.len() + generics_str.len() + 3;\n+        let used_budget = offset.width() + header_str.len() + generics_str.len() + 3;\n \n         // Conservative approximation\n         let single_line_cost = (span.hi - struct_def.fields[0].span.lo).0;\n         let break_line = !is_tuple || generics_str.contains('\\n') ||\n                          single_line_cost as usize + used_budget > self.config.max_width;\n \n         let tactic = if break_line {\n-            let indentation = make_indent(offset + self.config.tab_spaces);\n+            let indentation = make_indent(offset.block_indent(self.config.tab_spaces), self.config);\n             result.push('\\n');\n             result.push_str(&indentation);\n \n@@ -672,23 +682,24 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         // 1 = ,\n-        let budget = self.config.ideal_width - offset + self.config.tab_spaces - 1;\n+        let budget = self.config.ideal_width - offset.width() + self.config.tab_spaces - 1;\n         let fmt = ListFormatting {\n             tactic: tactic,\n             separator: \",\",\n             trailing_separator: self.config.struct_trailing_comma,\n-            indent: offset + self.config.tab_spaces,\n+            indent: offset.block_indent(self.config.tab_spaces),\n             h_width: self.config.max_width,\n             v_width: budget,\n             ends_with_newline: true,\n+            config: self.config,\n         };\n         let list_str = write_list(&items.collect::<Vec<_>>(), &fmt).unwrap();\n \n         result.push_str(&list_str);\n \n         if break_line {\n             result.push('\\n');\n-            result.push_str(&make_indent(offset));\n+            result.push_str(&make_indent(offset, self.config));\n         }\n \n         result.push_str(terminator);\n@@ -727,8 +738,8 @@ impl<'a> FmtVisitor<'a> {\n     fn format_generics(&self,\n                        generics: &ast::Generics,\n                        opener: &str,\n-                       offset: usize,\n-                       generics_offset: usize,\n+                       offset: Indent,\n+                       generics_offset: Indent,\n                        span: Span)\n                        -> Option<String> {\n         let mut result = try_opt!(self.rewrite_generics(generics, offset, generics_offset, span));\n@@ -740,7 +751,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                       Density::Tall,\n                                                                       span.hi));\n             result.push_str(&where_clause_str);\n-            result.push_str(&make_indent(self.block_indent));\n+            result.push_str(&make_indent(self.block_indent, self.config));\n             result.push('\\n');\n             result.push_str(opener.trim());\n         } else {\n@@ -765,18 +776,18 @@ impl<'a> FmtVisitor<'a> {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         // FIXME silly width, indent\n-        let typ = field.node.ty.rewrite(&self.get_context(), 1000, 0).unwrap();\n+        let typ = field.node.ty.rewrite(&self.get_context(), 1000, Indent::new(0, 0)).unwrap();\n \n         let indent = self.block_indent + self.config.tab_spaces;\n         let mut attr_str = field.node\n                                 .attrs\n                                 .rewrite(&self.get_context(),\n-                                         self.config.max_width - indent,\n+                                         self.config.max_width - indent.width(),\n                                          indent)\n                                 .unwrap();\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n-            attr_str.push_str(&make_indent(indent));\n+            attr_str.push_str(&make_indent(indent, self.config));\n         }\n \n         match name {\n@@ -787,8 +798,8 @@ impl<'a> FmtVisitor<'a> {\n \n     fn rewrite_generics(&self,\n                         generics: &ast::Generics,\n-                        offset: usize,\n-                        generics_offset: usize,\n+                        offset: Indent,\n+                        generics_offset: Indent,\n                         span: Span)\n                         -> Option<String> {\n         // FIXME: convert bounds to where clauses where they get too big or if\n@@ -801,12 +812,12 @@ impl<'a> FmtVisitor<'a> {\n \n         let offset = match self.config.generics_indent {\n             BlockIndentStyle::Inherit => offset,\n-            BlockIndentStyle::Tabbed => offset + self.config.tab_spaces,\n+            BlockIndentStyle::Tabbed => offset.block_indent(self.config.tab_spaces),\n             // 1 = <\n             BlockIndentStyle::Visual => generics_offset + 1,\n         };\n \n-        let h_budget = self.config.max_width - generics_offset - 2;\n+        let h_budget = self.config.max_width - generics_offset.width() - 2;\n         // TODO: might need to insert a newline if the generics are really long.\n \n         // Strings for the generics.\n@@ -841,7 +852,7 @@ impl<'a> FmtVisitor<'a> {\n             item.item = ty;\n         }\n \n-        let fmt = ListFormatting::for_fn(h_budget, offset);\n+        let fmt = ListFormatting::for_fn(h_budget, offset, self.config);\n         let list_str = try_opt!(write_list(&items, &fmt));\n \n         Some(format!(\"<{}>\", list_str))\n@@ -850,7 +861,7 @@ impl<'a> FmtVisitor<'a> {\n     fn rewrite_where_clause(&self,\n                             where_clause: &ast::WhereClause,\n                             config: &Config,\n-                            indent: usize,\n+                            indent: Indent,\n                             density: Density,\n                             span_end: BytePos)\n                             -> Option<String> {\n@@ -859,22 +870,23 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let extra_indent = match self.config.where_indent {\n-            BlockIndentStyle::Inherit => 0,\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => config.tab_spaces,\n+            BlockIndentStyle::Inherit => Indent::new(0, 0),\n+            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => Indent::new(config.tab_spaces,\n+                                                                               0),\n         };\n \n         let context = self.get_context();\n \n         let offset = match self.config.where_pred_indent {\n             BlockIndentStyle::Inherit => indent + extra_indent,\n-            BlockIndentStyle::Tabbed => indent + extra_indent + config.tab_spaces,\n+            BlockIndentStyle::Tabbed => indent + extra_indent.block_indent(config.tab_spaces),\n             // 6 = \"where \".len()\n             BlockIndentStyle::Visual => indent + extra_indent + 6,\n         };\n         // FIXME: if where_pred_indent != Visual, then the budgets below might\n         // be out by a char or two.\n \n-        let budget = self.config.ideal_width + self.config.leeway - offset;\n+        let budget = self.config.ideal_width + self.config.leeway - offset.width();\n         let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n         let items = itemize_list(self.codemap,\n                                  where_clause.predicates.iter(),\n@@ -896,21 +908,24 @@ impl<'a> FmtVisitor<'a> {\n             h_width: budget,\n             v_width: budget,\n             ends_with_newline: true,\n+            config: self.config,\n         };\n         let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||\n-           indent + 9 + preds_str.len() > self.config.max_width {\n-            Some(format!(\"\\n{}where {}\", make_indent(indent + extra_indent), preds_str))\n+           indent.width() + 9 + preds_str.len() > self.config.max_width {\n+            Some(format!(\"\\n{}where {}\",\n+                         make_indent(indent + extra_indent, self.config),\n+                         preds_str))\n         } else {\n             Some(format!(\" where {}\", preds_str))\n         }\n     }\n }\n \n impl Rewrite for ast::FunctionRetTy {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n             ast::FunctionRetTy::DefaultReturn(_) => Some(String::new()),\n             ast::FunctionRetTy::NoReturn(_) => {\n@@ -929,7 +944,7 @@ impl Rewrite for ast::FunctionRetTy {\n }\n \n impl Rewrite for ast::Arg {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if is_named_arg(self) {\n             if let ast::Ty_::TyInfer = self.ty.node {\n                 wrap_str(pprust::pat_to_string(&self.pat), context.config.max_width, width, offset)"}, {"sha": "2ca206665e29f7881e27f260a9abe7c11ac98190", "filename": "src/lib.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -44,6 +44,7 @@ use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::diagnostics;\n \n+use std::ops::{Add, Sub};\n use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n@@ -80,6 +81,79 @@ const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n const SKIP_ANNOTATION: &'static str = \"rustfmt_skip\";\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct Indent {\n+    block_indent: usize,\n+    alignment: usize,\n+}\n+\n+impl Indent {\n+    pub fn new(block_indent: usize, alignment: usize) -> Indent {\n+        Indent { block_indent: block_indent, alignment: alignment }\n+    }\n+\n+    pub fn block_indent(mut self, block_indent: usize) -> Indent {\n+        self.block_indent += block_indent;\n+        self\n+    }\n+\n+    pub fn block_unindent(mut self, block_indent: usize) -> Indent {\n+        self.block_indent -= block_indent;\n+        self\n+    }\n+\n+    pub fn width(&self) -> usize {\n+        self.block_indent + self.alignment\n+    }\n+\n+    pub fn to_string(&self, config: &Config) -> String {\n+        let (num_tabs, num_spaces) = if config.hard_tabs {\n+            (self.block_indent / config.tab_spaces, self.alignment)\n+        } else {\n+            (0, self.block_indent + self.alignment)\n+        };\n+        let num_chars = num_tabs + num_spaces;\n+        let mut indent = String::with_capacity(num_chars);\n+        for _ in 0..num_tabs {\n+            indent.push('\\t')\n+        }\n+        for _ in 0..num_spaces {\n+            indent.push(' ')\n+        }\n+        indent\n+    }\n+}\n+\n+impl Add for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: Indent) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent + rhs.block_indent,\n+            alignment: self.alignment + rhs.alignment,\n+        }\n+    }\n+}\n+\n+impl Sub for Indent {\n+    type Output = Indent;\n+\n+    fn sub(self, rhs: Indent) -> Indent {\n+        Indent {\n+            block_indent: self.block_indent - rhs.block_indent,\n+            alignment: self.alignment - rhs.alignment,\n+        }\n+    }\n+}\n+\n+impl Add<usize> for Indent {\n+    type Output = Indent;\n+\n+    fn add(self, rhs: usize) -> Indent {\n+        Indent { block_indent: self.block_indent, alignment: self.alignment + rhs }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub enum WriteMode {\n     // Backups the original file and overwrites the orignal."}, {"sha": "40da7af198e5b2a46e915018a12e56c3e6bca369", "filename": "src/lists.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -13,8 +13,10 @@ use std::iter::Peekable;\n \n use syntax::codemap::{self, CodeMap, BytePos};\n \n+use Indent;\n use utils::{round_up_to_power_of_two, make_indent, wrap_str};\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n+use config::Config;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {\n@@ -44,18 +46,19 @@ pub struct ListFormatting<'a> {\n     pub tactic: ListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n-    pub indent: usize,\n+    pub indent: Indent,\n     // Available width if we layout horizontally.\n     pub h_width: usize,\n     // Available width if we layout vertically\n     pub v_width: usize,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n     pub ends_with_newline: bool,\n+    pub config: &'a Config,\n }\n \n impl<'a> ListFormatting<'a> {\n-    pub fn for_fn(width: usize, offset: usize) -> ListFormatting<'a> {\n+    pub fn for_fn(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n         ListFormatting {\n             tactic: ListTactic::HorizontalVertical,\n             separator: \",\",\n@@ -64,6 +67,7 @@ impl<'a> ListFormatting<'a> {\n             h_width: width,\n             v_width: width,\n             ends_with_newline: false,\n+            config: config,\n         }\n     }\n }\n@@ -146,12 +150,12 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n     let alloc_width = if tactic == ListTactic::Horizontal {\n         total_width + total_sep_len\n     } else {\n-        total_width + items.len() * (formatting.indent + 1)\n+        total_width + items.len() * (formatting.indent.width() + 1)\n     };\n     let mut result = String::with_capacity(round_up_to_power_of_two(alloc_width));\n \n     let mut line_len = 0;\n-    let indent_str = &make_indent(formatting.indent);\n+    let indent_str = &make_indent(formatting.indent, formatting.config);\n     for (i, item) in items.iter().enumerate() {\n         let first = i == 0;\n         let last = i == items.len() - 1;\n@@ -196,7 +200,8 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             let block_mode = tactic != ListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n             let max_width = formatting.v_width;\n-            result.push_str(&rewrite_comment(comment, block_mode, max_width, formatting.indent));\n+            result.push_str(&rewrite_comment(comment, block_mode, max_width, formatting.indent,\n+                                             formatting.config));\n \n             if tactic == ListTactic::Vertical {\n                 result.push('\\n');\n@@ -206,14 +211,18 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             }\n         }\n \n-        let max_width = formatting.indent + formatting.v_width;\n+        let max_width = formatting.indent.width() + formatting.v_width;\n         let item_str = wrap_str(&item.item[..], max_width, formatting.v_width, formatting.indent);\n         result.push_str(&&try_opt!(item_str));\n \n         // Post-comments\n         if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment = rewrite_comment(comment, true, formatting.v_width, 0);\n+            let formatted_comment = rewrite_comment(comment,\n+                                                    true,\n+                                                    formatting.v_width,\n+                                                    Indent::new(0, 0),\n+                                                    formatting.config);\n \n             result.push(' ');\n             result.push_str(&formatted_comment);\n@@ -226,14 +235,19 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n         if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n             let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n-            let offset = formatting.indent + item_width + 1;\n+            let mut offset = formatting.indent;\n+            offset.alignment += item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n             // Use block-style only for the last item or multiline comments.\n             let block_style = !formatting.ends_with_newline && last ||\n                               comment.trim().contains('\\n') ||\n                               comment.trim().len() > width;\n \n-            let formatted_comment = rewrite_comment(comment, block_style, width, offset);\n+            let formatted_comment = rewrite_comment(comment,\n+                                                    block_style,\n+                                                    width,\n+                                                    offset,\n+                                                    formatting.config);\n \n             result.push(' ');\n             result.push_str(&formatted_comment);"}, {"sha": "8c38326ee8a49c0836c7b5b4de2a0fd6251cc77b", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -25,6 +25,7 @@ use syntax::ast;\n use syntax::parse::token::{Eof, Comma, Token};\n use syntax::parse::{ParseSess, tts_to_parser};\n \n+use Indent;\n use rewrite::RewriteContext;\n use expr::{rewrite_call, rewrite_array};\n use comment::FindUncommented;\n@@ -46,7 +47,7 @@ enum MacroStyle {\n pub fn rewrite_macro(mac: &ast::Mac,\n                      context: &RewriteContext,\n                      width: usize,\n-                     offset: usize)\n+                     offset: Indent)\n                      -> Option<String> {\n     let ast::Mac_::MacInvocTT(ref path, ref tt_vec, _) = mac.node;\n     let style = macro_style(mac, context);"}, {"sha": "c8da3e76b631b79fb35530c9506cf75d5a084620", "filename": "src/missed_spans.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use config::Config;\n use utils::make_indent;\n use visitor::FmtVisitor;\n \n@@ -20,15 +21,15 @@ impl<'a> FmtVisitor<'a> {\n         self.format_missing_inner(end, |this, last_snippet, _| this.buffer.push_str(last_snippet))\n     }\n \n-    pub fn format_missing_with_indent(&mut self, end: BytePos) {\n+    pub fn format_missing_with_indent(&mut self, end: BytePos, config: &Config) {\n         self.format_missing_inner(end,\n                                   |this, last_snippet, snippet| {\n                                       this.buffer.push_str(last_snippet.trim_right());\n                                       if last_snippet == snippet {\n-                // No new lines in the snippet.\n+                                          // No new lines in the snippet.\n                                           this.buffer.push_str(\"\\n\");\n                                       }\n-                                      let indent = make_indent(this.block_indent);\n+                                      let indent = make_indent(this.block_indent, config);\n                                       this.buffer.push_str(&indent);\n                                   })\n     }"}, {"sha": "2e0f5691d2e020ae633d1794ba59640f5be90953", "filename": "src/rewrite.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -12,6 +12,7 @@\n \n use syntax::codemap::{CodeMap, Span};\n \n+use Indent;\n use config::Config;\n \n pub trait Rewrite {\n@@ -22,33 +23,33 @@ pub trait Rewrite {\n     /// `width` is the maximum number of characters on the last line\n     /// (excluding offset). The width of other lines is not limited by\n     /// `width`.\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String>;\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String>;\n }\n \n pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n \n     // Indentation due to nesting of blocks.\n-    pub block_indent: usize,\n+    pub block_indent: Indent,\n     // *Extra* indentation due to overflowing to the next line, e.g.,\n     // let foo =\n     //     bar();\n     // The extra 4 spaces when formatting `bar()` is overflow_indent.\n-    pub overflow_indent: usize,\n+    pub overflow_indent: Indent,\n }\n \n impl<'a> RewriteContext<'a> {\n     pub fn nested_context(&self) -> RewriteContext<'a> {\n         RewriteContext {\n             codemap: self.codemap,\n             config: self.config,\n-            block_indent: self.block_indent + self.config.tab_spaces,\n+            block_indent: self.block_indent.block_indent(self.config.tab_spaces),\n             overflow_indent: self.overflow_indent,\n         }\n     }\n \n-    pub fn overflow_context(&self, overflow: usize) -> RewriteContext<'a> {\n+    pub fn overflow_context(&self, overflow: Indent) -> RewriteContext<'a> {\n         RewriteContext {\n             codemap: self.codemap,\n             config: self.config,"}, {"sha": "3da0a5f4a2592839e3fa13a68e649468704b1d73", "filename": "src/string.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -13,6 +13,8 @@\n use unicode_segmentation::UnicodeSegmentation;\n use regex::Regex;\n \n+use Indent;\n+use config::Config;\n use utils::{make_indent, round_up_to_power_of_two};\n \n use MIN_STRING;\n@@ -23,8 +25,9 @@ pub struct StringFormat<'a> {\n     pub line_start: &'a str,\n     pub line_end: &'a str,\n     pub width: usize,\n-    pub offset: usize,\n+    pub offset: Indent,\n     pub trim_end: bool,\n+    pub config: &'a Config,\n }\n \n // TODO: simplify this!\n@@ -36,7 +39,7 @@ pub fn rewrite_string<'a>(s: &str, fmt: &StringFormat<'a>) -> String {\n \n     let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n \n-    let indent = make_indent(fmt.offset);\n+    let indent = make_indent(fmt.offset, fmt.config);\n     let indent = &indent;\n \n     let mut cur_start = 0;"}, {"sha": "9ba50a59cd92369c94b2a74d3ad1470905a938a9", "filename": "src/types.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -12,12 +12,13 @@ use syntax::ast;\n use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n+use Indent;\n use lists::{itemize_list, write_list, ListFormatting};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after};\n \n impl Rewrite for ast::Path {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         rewrite_path(context, None, self, width, offset)\n     }\n }\n@@ -27,7 +28,7 @@ pub fn rewrite_path(context: &RewriteContext,\n                     qself: Option<&ast::QSelf>,\n                     path: &ast::Path,\n                     width: usize,\n-                    offset: usize)\n+                    offset: Indent)\n                     -> Option<String> {\n     let skip_count = qself.map(|x| x.position).unwrap_or(0);\n \n@@ -80,7 +81,7 @@ fn rewrite_path_segments<'a, I>(mut buffer: String,\n                                 span_hi: BytePos,\n                                 context: &RewriteContext,\n                                 width: usize,\n-                                offset: usize)\n+                                offset: Indent)\n                                 -> Option<String>\n     where I: Iterator<Item = &'a ast::PathSegment>\n {\n@@ -128,7 +129,7 @@ impl<'a> SegmentParam<'a> {\n \n impl<'a> Rewrite for SegmentParam<'a> {\n     // FIXME: doesn't always use width, offset.\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         Some(match *self {\n             SegmentParam::LifeTime(ref lt) => {\n                 pprust::lifetime_to_string(lt)\n@@ -186,7 +187,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                    span_hi: BytePos,\n                    context: &RewriteContext,\n                    width: usize,\n-                   offset: usize)\n+                   offset: Indent)\n                    -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n     let width = try_opt!(width.checked_sub(ident_len));\n@@ -229,7 +230,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      list_lo,\n                                      span_hi);\n \n-            let fmt = ListFormatting::for_fn(list_width, offset + extra_offset);\n+            let fmt = ListFormatting::for_fn(list_width, offset + extra_offset, context.config);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             // Update position of last bracket.\n@@ -257,7 +258,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             let budget = try_opt!(width.checked_sub(output.len() + 2));\n \n             // 1 for (\n-            let fmt = ListFormatting::for_fn(budget, offset + 1);\n+            let fmt = ListFormatting::for_fn(budget, offset + 1, context.config);\n             let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n             format!(\"({}){}\", list_str, output)\n@@ -269,7 +270,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n }\n \n impl Rewrite for ast::WherePredicate {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         // TODO: dead spans?\n         // TODO: don't assume we'll always fit on one line...\n         Some(match *self {\n@@ -340,7 +341,7 @@ impl Rewrite for ast::WherePredicate {\n }\n \n impl Rewrite for ast::LifetimeDef {\n-    fn rewrite(&self, _: &RewriteContext, _: usize, _: usize) -> Option<String> {\n+    fn rewrite(&self, _: &RewriteContext, _: usize, _: Indent) -> Option<String> {\n         if self.bounds.is_empty() {\n             Some(pprust::lifetime_to_string(&self.lifetime))\n         } else {\n@@ -356,7 +357,7 @@ impl Rewrite for ast::LifetimeDef {\n }\n \n impl Rewrite for ast::TyParamBound {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n                 tref.rewrite(context, width, offset)\n@@ -372,7 +373,7 @@ impl Rewrite for ast::TyParamBound {\n }\n \n impl Rewrite for ast::TyParamBounds {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let strs: Vec<_> = self.iter()\n                                .map(|b| b.rewrite(context, width, offset).unwrap())\n                                .collect();\n@@ -382,7 +383,7 @@ impl Rewrite for ast::TyParamBounds {\n \n // FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::TyParam {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n@@ -407,7 +408,7 @@ impl Rewrite for ast::TyParam {\n \n // FIXME: this assumes everything will fit on one line\n impl Rewrite for ast::PolyTraitRef {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n             let lifetime_str = self.bound_lifetimes\n                                    .iter()\n@@ -430,7 +431,7 @@ impl Rewrite for ast::PolyTraitRef {\n \n impl Rewrite for ast::Ty {\n     // FIXME doesn't always use width, offset\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n             ast::TyPath(None, ref p) => {\n                 p.rewrite(context, width, offset)"}, {"sha": "3843e75973e6733d1b60741a666e41ede28977d5", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -13,17 +13,19 @@ use std::cmp::Ordering;\n use syntax::ast::{self, Visibility, Attribute, MetaItem, MetaItem_};\n use syntax::codemap::{CodeMap, Span, BytePos};\n \n+use Indent;\n use comment::FindUncommented;\n+use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n \n use SKIP_ANNOTATION;\n \n // Computes the length of a string's last line, minus offset.\n #[inline]\n-pub fn extra_offset(text: &str, offset: usize) -> usize {\n+pub fn extra_offset(text: &str, offset: Indent) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => text.len() - idx - 1 - offset,\n+        Some(idx) => text.len() - idx - 1 - offset.width(),\n         None => text.len(),\n     }\n }\n@@ -36,12 +38,8 @@ pub fn span_after(original: Span, needle: &str, codemap: &CodeMap) -> BytePos {\n }\n \n #[inline]\n-pub fn make_indent(width: usize) -> String {\n-    let mut indent = String::with_capacity(width);\n-    for _ in 0..width {\n-        indent.push(' ')\n-    }\n-    indent\n+pub fn make_indent(indent: Indent, config: &Config) -> String {\n+    indent.to_string(config)\n }\n \n #[inline]\n@@ -186,7 +184,7 @@ macro_rules! try_opt {\n \n // Wraps string-like values in an Option. Returns Some when the string adheres\n // to the Rewrite constraints defined for the Rewrite trait and else otherwise.\n-pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usize) -> Option<S> {\n+pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: Indent) -> Option<S> {\n     {\n         let snippet = s.as_ref();\n \n@@ -197,7 +195,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n \n             // The caller of this function has already placed `offset`\n             // characters on the first line.\n-            let first_line_max_len = try_opt!(max_width.checked_sub(offset));\n+            let first_line_max_len = try_opt!(max_width.checked_sub(offset.width()));\n             if lines.next().unwrap().len() > first_line_max_len {\n                 return None;\n             }\n@@ -211,7 +209,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n             // indentation.\n             // A special check for the last line, since the caller may\n             // place trailing characters on this line.\n-            if snippet.lines().rev().next().unwrap().len() > offset + width {\n+            if snippet.lines().rev().next().unwrap().len() > offset.width() + width {\n                 return None;\n             }\n         }\n@@ -221,7 +219,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, width: usize, offset: usi\n }\n \n impl Rewrite for String {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         wrap_str(self, context.config.max_width, width, offset).map(ToOwned::to_owned)\n     }\n }"}, {"sha": "d0a5df12221019b5d80042ca7391179bfcae85ff", "filename": "src/visitor.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4108a3029cecf7855514f568f8b3b88edcbfdb7/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d4108a3029cecf7855514f568f8b3b88edcbfdb7", "patch": "@@ -14,6 +14,7 @@ use syntax::visit;\n \n use strings::string_buffer::StringBuffer;\n \n+use Indent;\n use utils;\n use config::Config;\n use rewrite::{Rewrite, RewriteContext};\n@@ -25,7 +26,7 @@ pub struct FmtVisitor<'a> {\n     pub buffer: StringBuffer,\n     pub last_pos: BytePos,\n     // TODO: RAII util for indenting\n-    pub block_indent: usize,\n+    pub block_indent: Indent,\n     pub config: &'a Config,\n }\n \n@@ -39,7 +40,11 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         self.format_missing(ex.span.lo);\n \n         let offset = self.buffer.cur_offset();\n-        let rewrite = ex.rewrite(&self.get_context(), self.config.max_width - offset, offset);\n+        // FIXME: We put the entire offset into the block_indent, which might not be correct in all\n+        // situations.\n+        let rewrite = ex.rewrite(&self.get_context(),\n+                                 self.config.max_width - offset,\n+                                 Indent::new(offset, 0));\n \n         if let Some(new_str) = rewrite {\n             self.buffer.push_str(&new_str);\n@@ -56,7 +61,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 }\n             }\n             ast::Stmt_::StmtExpr(ref ex, _) | ast::Stmt_::StmtSemi(ref ex, _) => {\n-                self.format_missing_with_indent(stmt.span.lo);\n+                self.format_missing_with_indent(stmt.span.lo, self.config);\n                 let suffix = if let ast::Stmt_::StmtExpr(..) = stmt.node {\n                     \"\"\n                 } else {\n@@ -65,7 +70,8 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n                 // 1 = trailing semicolon;\n                 let rewrite = ex.rewrite(&self.get_context(),\n-                                         self.config.max_width - self.block_indent - suffix.len(),\n+                                         self.config.max_width - self.block_indent.width() -\n+                                         suffix.len(),\n                                          self.block_indent);\n \n                 if let Some(new_str) = rewrite {\n@@ -75,7 +81,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 }\n             }\n             ast::Stmt_::StmtMac(ref _mac, _macro_style) => {\n-                self.format_missing_with_indent(stmt.span.lo);\n+                self.format_missing_with_indent(stmt.span.lo, self.config);\n                 visit::walk_stmt(self, stmt);\n             }\n         }\n@@ -96,7 +102,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         };\n \n         self.last_pos = self.last_pos + brace_compensation;\n-        self.block_indent += self.config.tab_spaces;\n+        self.block_indent = self.block_indent.block_indent(self.config.tab_spaces);\n         self.buffer.push_str(\"{\");\n \n         for stmt in &b.stmts {\n@@ -105,15 +111,15 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         match b.expr {\n             Some(ref e) => {\n-                self.format_missing_with_indent(e.span.lo);\n+                self.format_missing_with_indent(e.span.lo, self.config);\n                 self.visit_expr(e);\n             }\n             None => {}\n         }\n \n-        self.block_indent -= self.config.tab_spaces;\n-        // TODO: we should compress any newlines here to just one.\n-        self.format_missing_with_indent(b.span.hi - brace_compensation);\n+        self.block_indent = self.block_indent.block_unindent(self.config.tab_spaces);\n+        // TODO: we should compress any newlines here to just one\n+        self.format_missing_with_indent(b.span.hi - brace_compensation, self.config);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n     }\n@@ -126,6 +132,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 _: ast::NodeId) {\n+\n         let indent = self.block_indent;\n         let rewrite = match fk {\n             visit::FnKind::ItemFn(ident,\n@@ -161,7 +168,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         };\n \n         if let Some(fn_str) = rewrite {\n-            self.format_missing_with_indent(s.lo);\n+            self.format_missing_with_indent(s.lo, self.config);\n             self.buffer.push_str(&fn_str);\n         } else {\n             self.format_missing(b.span.lo);\n@@ -191,31 +198,31 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemImpl(..) |\n             ast::Item_::ItemTrait(..) => {\n-                self.block_indent += self.config.tab_spaces;\n+                self.block_indent = self.block_indent.block_indent(self.config.tab_spaces);\n                 visit::walk_item(self, item);\n-                self.block_indent -= self.config.tab_spaces;\n+                self.block_indent = self.block_indent.block_unindent(self.config.tab_spaces);\n             }\n             ast::Item_::ItemExternCrate(_) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo, self.config);\n                 let new_str = self.snippet(item.span);\n                 self.buffer.push_str(&new_str);\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemStruct(ref def, ref generics) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo, self.config);\n                 self.visit_struct(item.ident, item.vis, def, generics, item.span);\n             }\n             ast::Item_::ItemEnum(ref def, ref generics) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo, self.config);\n                 self.visit_enum(item.ident, item.vis, def, generics, item.span);\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemMod(ref module) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo, self.config);\n                 self.format_mod(module, item.span, item.ident);\n             }\n             ast::Item_::ItemMac(..) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(item.span.lo, self.config);\n                 // TODO: we cannot format these yet, because of a bad span.\n                 // See rust lang issue #28424.\n                 // visit::walk_item(self, item);\n@@ -232,7 +239,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         }\n \n         if let ast::TraitItem_::MethodTraitItem(ref sig, None) = ti.node {\n-            self.format_missing_with_indent(ti.span.lo);\n+            self.format_missing_with_indent(ti.span.lo, self.config);\n \n             let indent = self.block_indent;\n             let new_fn = self.rewrite_required_fn(indent, ti.ident, sig, ti.span);\n@@ -256,7 +263,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         // 1 = ;\n-        let width = self.config.max_width - self.block_indent - 1;\n+        let width = self.config.max_width - self.block_indent.width() - 1;\n         let rewrite = rewrite_macro(mac, &self.get_context(), width, self.block_indent);\n \n         if let Some(res) = rewrite {\n@@ -272,7 +279,7 @@ impl<'a> FmtVisitor<'a> {\n             codemap: codemap,\n             buffer: StringBuffer::new(),\n             last_pos: BytePos(0),\n-            block_indent: 0,\n+            block_indent: Indent { block_indent: 0, alignment: 0 },\n             config: config,\n         }\n     }\n@@ -296,13 +303,13 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let first = &attrs[0];\n-        self.format_missing_with_indent(first.span.lo);\n+        self.format_missing_with_indent(first.span.lo, self.config);\n \n         if utils::contains_skip(attrs) {\n             true\n         } else {\n             let rewrite = attrs.rewrite(&self.get_context(),\n-                                        self.config.max_width - self.block_indent,\n+                                        self.config.max_width - self.block_indent.width(),\n                                         self.block_indent)\n                                .unwrap();\n             self.buffer.push_str(&rewrite);\n@@ -323,32 +330,33 @@ impl<'a> FmtVisitor<'a> {\n \n         if is_internal {\n             debug!(\"FmtVisitor::format_mod: internal mod\");\n-            self.block_indent += self.config.tab_spaces;\n+            self.block_indent = self.block_indent.block_indent(self.config.tab_spaces);\n             visit::walk_mod(self, m);\n             debug!(\"... last_pos after: {:?}\", self.last_pos);\n-            self.block_indent -= self.config.tab_spaces;\n+            self.block_indent = self.block_indent.block_unindent(self.config.tab_spaces);\n         }\n     }\n \n     pub fn format_separate_mod(&mut self, m: &ast::Mod, filename: &str) {\n         let filemap = self.codemap.get_filemap(filename);\n         self.last_pos = filemap.start_pos;\n-        self.block_indent = 0;\n+        self.block_indent = Indent::new(0, 0);\n         visit::walk_mod(self, m);\n         self.format_missing(filemap.end_pos);\n     }\n \n     fn format_import(&mut self, vis: ast::Visibility, vp: &ast::ViewPath, span: Span) {\n         let vis = utils::format_visibility(vis);\n-        let offset = self.block_indent + vis.len() + \"use \".len();\n+        let mut offset = self.block_indent;\n+        offset.alignment += vis.len() + \"use \".len();\n         let context = RewriteContext {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: 0,\n+            overflow_indent: Indent::new(0, 0),\n         };\n         // 1 = \";\"\n-        match vp.rewrite(&context, self.config.max_width - offset - 1, offset) {\n+        match vp.rewrite(&context, self.config.max_width - offset.width() - 1, offset) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, span.lo);\n@@ -361,12 +369,12 @@ impl<'a> FmtVisitor<'a> {\n             }\n             Some(ref s) => {\n                 let s = format!(\"{}use {};\", vis, s);\n-                self.format_missing_with_indent(span.lo);\n+                self.format_missing_with_indent(span.lo, self.config);\n                 self.buffer.push_str(&s);\n                 self.last_pos = span.hi;\n             }\n             None => {\n-                self.format_missing_with_indent(span.lo);\n+                self.format_missing_with_indent(span.lo, self.config);\n                 self.format_missing(span.hi);\n             }\n         }\n@@ -377,18 +385,18 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             block_indent: self.block_indent,\n-            overflow_indent: 0,\n+            overflow_indent: Indent::new(0, 0),\n         }\n     }\n }\n \n impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, _: usize, offset: usize) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext, _: usize, offset: Indent) -> Option<String> {\n         let mut result = String::new();\n         if self.is_empty() {\n             return Some(result);\n         }\n-        let indent = utils::make_indent(offset);\n+        let indent = utils::make_indent(offset, context.config);\n \n         for (i, a) in self.iter().enumerate() {\n             let a_str = context.snippet(a.span);\n@@ -403,8 +411,9 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 if !comment.is_empty() {\n                     let comment = rewrite_comment(comment,\n                                                   false,\n-                                                  context.config.max_width - offset,\n-                                                  offset);\n+                                                  context.config.max_width - offset.width(),\n+                                                  offset,\n+                                                  context.config);\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n                     result.push('\\n');"}]}