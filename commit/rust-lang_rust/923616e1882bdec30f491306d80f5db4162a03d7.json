{"sha": "923616e1882bdec30f491306d80f5db4162a03d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMzYxNmUxODgyYmRlYzMwZjQ5MTMwNmQ4MGY1ZGI0MTYyYTAzZDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-20T06:06:10Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-24T12:16:02Z"}, "message": "Fix @nikomatsakis' nits in typeck.", "tree": {"sha": "2b923998382bdfaf5ca2e48991b622faa6d46932", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b923998382bdfaf5ca2e48991b622faa6d46932"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/923616e1882bdec30f491306d80f5db4162a03d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/923616e1882bdec30f491306d80f5db4162a03d7", "html_url": "https://github.com/rust-lang/rust/commit/923616e1882bdec30f491306d80f5db4162a03d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/923616e1882bdec30f491306d80f5db4162a03d7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ad993a259006c41bd63f14ad68b3a99e365e94", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ad993a259006c41bd63f14ad68b3a99e365e94", "html_url": "https://github.com/rust-lang/rust/commit/09ad993a259006c41bd63f14ad68b3a99e365e94"}], "stats": {"total": 63, "additions": 27, "deletions": 36}, "files": [{"sha": "9e50fdb4c48158a21907bc569c46874ae4efc5bd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=923616e1882bdec30f491306d80f5db4162a03d7", "patch": "@@ -622,7 +622,7 @@ pub fn instantiate_trait_ref<'tcx>(\n     -> Rc<ty::TraitRef<'tcx>>\n {\n     let path = &trait_ref.path;\n-    match ::lookup_def_tcx(this.tcx(), path.span, trait_ref.ref_id) {\n+    match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n@@ -899,7 +899,10 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n \n     match ty.node {\n         ast::TyPath(None, ref path) => {\n-            let def = this.tcx().def_map.borrow().get(&ty.id).map(|d| d.full_def());\n+            let def = match this.tcx().def_map.borrow().get(&ty.id) {\n+                Some(&def::PathResolution { base_def, depth: 0, .. }) => Some(base_def),\n+                _ => None\n+            };\n             match def {\n                 Some(def::DefTrait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n@@ -1202,7 +1205,10 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         segments.last().unwrap())\n         }\n         def::DefMod(id) => {\n-            // Used as sentinel by callers to indicate the `<T>::a::b::c` form.\n+            // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n+            // FIXME(#22519) This part of the resolution logic should be\n+            // avoided entirely for that form, once we stop needed a Def\n+            // for `associated_path_def_to_ty`.\n             if segments.is_empty() {\n                 opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n             } else {\n@@ -1890,7 +1896,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n-                match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n+                match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid"}, {"sha": "f56df4570b3644b255a979a51408f9c894023d29", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=923616e1882bdec30f491306d80f5db4162a03d7", "patch": "@@ -103,7 +103,7 @@ use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n-use {CrateCtxt, lookup_def_ccx, require_same_types};\n+use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n@@ -3401,7 +3401,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n               ast::ExprPath(None, ref path) => {\n                   // FIXME(pcwalton): For now we hardcode the two permissible\n                   // places: the exchange heap and the managed heap.\n-                  let definition = lookup_def(fcx, path.span, place.id);\n+                  let definition = lookup_full_def(tcx, path.span, place.id);\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n                   if tcx.lang_items.exchange_heap() == Some(def_id) {\n@@ -3884,14 +3884,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().get(&id).map(|d| d.full_def());\n+        let def = lookup_full_def(tcx, path.span, id);\n         let struct_id = match def {\n-            Some(def::DefVariant(enum_id, variant_id, true)) => {\n+            def::DefVariant(enum_id, variant_id, true) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, &fields[..]);\n                 enum_id\n             }\n-            Some(def::DefTrait(def_id)) => {\n+            def::DefTrait(def_id) => {\n                 span_err!(tcx.sess, path.span, E0159,\n                     \"use of trait `{}` as a struct constructor\",\n                     pprust::path_to_string(path));\n@@ -3901,7 +3901,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                              base_expr);\n                 def_id\n             },\n-            Some(def) => {\n+            def => {\n                 // Verify that this was actually a struct.\n                 let typ = ty::lookup_item_type(fcx.ccx.tcx, def.def_id());\n                 match typ.ty.sty {\n@@ -3926,10 +3926,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                 def.def_id()\n             }\n-            _ => {\n-                tcx.sess.span_bug(path.span,\n-                                  \"structure constructor wasn't resolved\")\n-            }\n         };\n \n         // Turn the path into a type and verify that that type unifies with\n@@ -4643,10 +4639,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n-    lookup_def_ccx(fcx.ccx, sp, id)\n-}\n-\n // Returns the type parameter count and the type for the given definition.\n fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 sp: Span,\n@@ -5171,18 +5163,15 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n             _ => false\n         }\n     })) ||\n-   // Second: is there a labeled break with label\n-   // <id> nested anywhere inside the loop?\n+    // Second: is there a labeled break with label\n+    // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n-        match e.node {\n-            ast::ExprBreak(Some(_)) => {\n-                match cx.def_map.borrow().get(&e.id).map(|d| d.full_def()) {\n-                    Some(def::DefLabel(loop_id)) if id == loop_id => true,\n-                    _ => false,\n-                }\n-            }\n-            _ => false\n-        }}))\n+        if let ast::ExprBreak(Some(_)) = e.node {\n+            lookup_full_def(cx, e.span, e.id) == def::DefLabel(id)\n+        } else {\n+            false\n+        }\n+    }))\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "78dd66c8e7dbbd02e80bc8f197f2d014a2bf990e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/923616e1882bdec30f491306d80f5db4162a03d7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=923616e1882bdec30f491306d80f5db4162a03d7", "patch": "@@ -163,20 +163,16 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n         tcx.item_substs.borrow_mut().insert(node_id, item_substs);\n     }\n }\n-fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n+\n+fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.full_def(),\n-        _ => {\n+        None => {\n             span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n         }\n     }\n }\n \n-fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n-                   -> def::Def {\n-    lookup_def_tcx(ccx.tcx, sp, id)\n-}\n-\n fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n                                    t1_is_expected: bool,"}]}