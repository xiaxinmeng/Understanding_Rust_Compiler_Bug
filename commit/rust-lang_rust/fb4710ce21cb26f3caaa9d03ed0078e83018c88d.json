{"sha": "fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNDcxMGNlMjFjYjI2ZjNjYWFhOWQwM2VkMDA3OGU4MzAxOGM4OGQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-15T05:18:55Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-04T20:48:50Z"}, "message": "Add a field in Module for the ResolverArenas", "tree": {"sha": "02f425533432f514db87340d5ee06c2a765c278a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02f425533432f514db87340d5ee06c2a765c278a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "html_url": "https://github.com/rust-lang/rust/commit/fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b94bc345ca143273cf9d0754ec5f3a8e21923e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b94bc345ca143273cf9d0754ec5f3a8e21923e5", "html_url": "https://github.com/rust-lang/rust/commit/6b94bc345ca143273cf9d0754ec5f3a8e21923e5"}], "stats": {"total": 66, "additions": 39, "deletions": 27}, "files": [{"sha": "f82cf98c2d6f83a70f8cfdeb1df9bbc8a9bf840d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "patch": "@@ -98,14 +98,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn try_define<T>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n         where T: ToNameBinding<'b>\n     {\n-        let _ = parent.try_define_child(name, ns, self.new_name_binding(def.to_name_binding()));\n+        let _ = parent.try_define_child(name, ns, def.to_name_binding());\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n     fn define<T: ToNameBinding<'b>>(&self, parent: Module<'b>, name: Name, ns: Namespace, def: T) {\n-        let binding = self.new_name_binding(def.to_name_binding());\n-        let old_binding = match parent.try_define_child(name, ns, binding) {\n+        let binding = def.to_name_binding();\n+        let old_binding = match parent.try_define_child(name, ns, binding.clone()) {\n             Ok(()) => return,\n             Err(old_binding) => old_binding,\n         };\n@@ -709,8 +709,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let directive =\n             ImportDirective::new(module_path, subclass, span, id, is_public, shadowable);\n-        let directive = self.resolver.arenas.alloc_import_directive(directive);\n-        module_.unresolved_imports.borrow_mut().push(directive);\n+        module_.add_import_directive(directive);\n         self.unresolved_imports += 1;\n     }\n }"}, {"sha": "0e21b769b74c4a6d6e1a0f8aec1b5104e4682b1b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "patch": "@@ -845,13 +845,18 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n+\n+    arenas: &'a ResolverArenas<'a>,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool, is_public: bool) -> Self {\n+    fn new(parent_link: ParentLink<'a>,\n+           def: Option<Def>,\n+           external: bool,\n+           is_public: bool,\n+           arenas: &'a ResolverArenas<'a>) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n@@ -865,6 +870,7 @@ impl<'a> ModuleS<'a> {\n             pub_count: Cell::new(0),\n             pub_glob_count: Cell::new(0),\n             populated: Cell::new(!external),\n+            arenas: arenas\n         }\n     }\n \n@@ -881,8 +887,9 @@ impl<'a> ModuleS<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    fn try_define_child(&self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>)\n+    fn try_define_child(&self, name: Name, ns: Namespace, binding: NameBinding<'a>)\n                         -> Result<(), &'a NameBinding<'a>> {\n+        let binding = self.arenas.alloc_name_binding(binding);\n         let mut children = self.resolutions.borrow_mut();\n         let resolution = children.entry((name, ns)).or_insert_with(Default::default);\n \n@@ -898,6 +905,11 @@ impl<'a> ModuleS<'a> {\n         resolution.try_define(binding)\n     }\n \n+    fn add_import_directive(&self, import_directive: ImportDirective) {\n+        let import_directive = self.arenas.alloc_import_directive(import_directive);\n+        self.unresolved_imports.borrow_mut().push(import_directive);\n+    }\n+\n     fn increment_outstanding_references_for(&self, name: Name, ns: Namespace) {\n         let mut children = self.resolutions.borrow_mut();\n         children.entry((name, ns)).or_insert_with(Default::default).outstanding_references += 1;\n@@ -995,14 +1007,14 @@ bitflags! {\n }\n \n // Records a possibly-private value, type, or module definition.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct NameBinding<'a> {\n     modifiers: DefModifiers,\n     kind: NameBindingKind<'a>,\n     span: Option<Span>,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum NameBindingKind<'a> {\n     Def(Def),\n     Module(Module<'a>),\n@@ -1171,6 +1183,12 @@ pub struct ResolverArenas<'a> {\n }\n \n impl<'a> ResolverArenas<'a> {\n+    fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n+        self.modules.alloc(module)\n+    }\n+    fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n+        self.name_bindings.alloc(name_binding)\n+    }\n     fn alloc_import_directive(&'a self, import_directive: ImportDirective) -> &'a ImportDirective {\n         self.import_directives.alloc(import_directive)\n     }\n@@ -1189,8 +1207,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let graph_root = ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true);\n-        let graph_root = arenas.modules.alloc(graph_root);\n+        let graph_root =\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true, arenas);\n+        let graph_root = arenas.alloc_module(graph_root);\n \n         Resolver {\n             session: session,\n@@ -1250,11 +1269,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   def: Option<Def>,\n                   external: bool,\n                   is_public: bool) -> Module<'a> {\n-        self.arenas.modules.alloc(ModuleS::new(parent_link, def, external, is_public))\n-    }\n-\n-    fn new_name_binding(&self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n-        self.arenas.name_bindings.alloc(name_binding)\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, is_public, self.arenas))\n     }\n \n     fn new_extern_crate_module(&self,\n@@ -1263,7 +1278,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                is_public: bool,\n                                local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, is_public);\n+        let mut module = ModuleS::new(parent_link, Some(def), false, is_public, self.arenas);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }"}, {"sha": "15c9528d7ef1e9fbf8a1b734f1bd883e8e31acd1", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4710ce21cb26f3caaa9d03ed0078e83018c88d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=fb4710ce21cb26f3caaa9d03ed0078e83018c88d", "patch": "@@ -236,15 +236,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // If it's a single failed import then create a \"fake\" import\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport { target, .. } = e.import_directive.subclass {\n-            let dummy_binding = self.resolver.new_name_binding(NameBinding {\n+            let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n                 modifiers: DefModifiers::PRELUDE,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n             });\n-            let dummy_binding =\n-                self.resolver.new_name_binding(e.import_directive.import(dummy_binding, None));\n+            let dummy_binding = e.import_directive.import(dummy_binding, None);\n \n-            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding);\n+            let _ = e.source_module.try_define_child(target, ValueNS, dummy_binding.clone());\n             let _ = e.source_module.try_define_child(target, TypeNS, dummy_binding);\n         }\n \n@@ -534,9 +533,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n               name: Name,\n               ns: Namespace,\n               binding: NameBinding<'b>) {\n-        let binding = self.resolver.new_name_binding(binding);\n-        if let Err(old_binding) = parent.try_define_child(name, ns, binding) {\n-            self.report_conflict(name, ns, binding, old_binding);\n+        if let Err(old_binding) = parent.try_define_child(name, ns, binding.clone()) {\n+            self.report_conflict(name, ns, &binding, old_binding);\n         } else if binding.is_public() { // Add to the export map\n             if let (Some(parent_def_id), Some(def)) = (parent.def_id(), binding.def()) {\n                 let parent_node_id = self.resolver.ast_map.as_local_node_id(parent_def_id).unwrap();\n@@ -549,8 +547,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     fn report_conflict(&mut self,\n                        name: Name,\n                        ns: Namespace,\n-                       binding: &'b NameBinding<'b>,\n-                       old_binding: &'b NameBinding<'b>) {\n+                       binding: &NameBinding,\n+                       old_binding: &NameBinding) {\n         // Error on the second of two conflicting imports\n         if old_binding.is_import() && binding.is_import() &&\n            old_binding.span.unwrap().lo > binding.span.unwrap().lo {"}]}