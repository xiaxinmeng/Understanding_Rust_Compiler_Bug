{"sha": "035bedc28b0069b3181710d38fa63ba6ad92de57", "node_id": "C_kwDOAAsO6NoAKDAzNWJlZGMyOGIwMDY5YjMxODE3MTBkMzhmYTYzYmE2YWQ5MmRlNTc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-20T23:02:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-20T23:02:10Z"}, "message": "internal: Remove name fields from MacroCallKind", "tree": {"sha": "9a61eeddfa5bdc420e99a65f20cc21a6fdc81d40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a61eeddfa5bdc420e99a65f20cc21a6fdc81d40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/035bedc28b0069b3181710d38fa63ba6ad92de57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/035bedc28b0069b3181710d38fa63ba6ad92de57", "html_url": "https://github.com/rust-lang/rust/commit/035bedc28b0069b3181710d38fa63ba6ad92de57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/035bedc28b0069b3181710d38fa63ba6ad92de57/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbe787ee10b3c5cf6639ca76ee4e2c40c4e322c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbe787ee10b3c5cf6639ca76ee4e2c40c4e322c7", "html_url": "https://github.com/rust-lang/rust/commit/fbe787ee10b3c5cf6639ca76ee4e2c40c4e322c7"}], "stats": {"total": 98, "additions": 38, "deletions": 60}, "files": [{"sha": "c75ceed9e3a93478ecc503ccb48557a2f7157120", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=035bedc28b0069b3181710d38fa63ba6ad92de57", "patch": "@@ -74,7 +74,7 @@ use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n use syntax::{\n     ast::{self, HasAttrs as _, HasDocComments, HasName},\n-    AstNode, AstPtr, SmolStr, SyntaxKind, SyntaxNodePtr,\n+    AstNode, AstPtr, SmolStr, SyntaxNodePtr, T,\n };\n use tt::{Ident, Leaf, Literal, TokenTree};\n \n@@ -628,43 +628,37 @@ fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag:\n \n         DefDiagnosticKind::UnresolvedProcMacro { ast } => {\n             let mut precise_location = None;\n-            let (node, name) = match ast {\n+            let (node, macro_name) = match ast {\n                 MacroCallKind::FnLike { ast_id, .. } => {\n                     let node = ast_id.to_node(db.upcast());\n                     (ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))), None)\n                 }\n-                MacroCallKind::Derive { ast_id, derive_name, .. } => {\n+                MacroCallKind::Derive { ast_id, derive_attr_index, derive_index } => {\n                     let node = ast_id.to_node(db.upcast());\n \n                     // Compute the precise location of the macro name's token in the derive\n                     // list.\n-                    // FIXME: This does not handle paths to the macro, but neither does the\n-                    // rest of r-a.\n-                    let derive_attrs =\n-                        node.attrs().filter_map(|attr| match attr.as_simple_call() {\n-                            Some((name, args)) if name == \"derive\" => Some(args),\n-                            _ => None,\n-                        });\n-                    'outer: for attr in derive_attrs {\n-                        let tokens =\n-                            attr.syntax().children_with_tokens().filter_map(|elem| match elem {\n-                                syntax::NodeOrToken::Node(_) => None,\n+                    let token = (|| {\n+                        let derive_attr = node.attrs().nth(*derive_attr_index as usize)?;\n+                        derive_attr\n+                            .syntax()\n+                            .children_with_tokens()\n+                            .filter_map(|elem| match elem {\n                                 syntax::NodeOrToken::Token(tok) => Some(tok),\n-                            });\n-                        for token in tokens {\n-                            if token.kind() == SyntaxKind::IDENT && token.text() == &**derive_name {\n-                                precise_location = Some(token.text_range());\n-                                break 'outer;\n-                            }\n-                        }\n-                    }\n-\n+                                _ => None,\n+                            })\n+                            .group_by(|t| t.kind() == T![,])\n+                            .into_iter()\n+                            .nth(*derive_index as usize)\n+                            .and_then(|(_, mut g)| g.find(|t| t.kind() == T![ident]))\n+                    })();\n+                    precise_location = token.as_ref().map(|tok| tok.text_range());\n                     (\n                         ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&node))),\n-                        Some(derive_name.clone()),\n+                        token.as_ref().map(ToString::to_string),\n                     )\n                 }\n-                MacroCallKind::Attr { ast_id, invoc_attr_index, attr_name, .. } => {\n+                MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n                     let node = ast_id.to_node(db.upcast());\n                     let attr = node\n                         .doc_comments_and_attrs()\n@@ -673,14 +667,15 @@ fn emit_def_diagnostic(db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>, diag:\n                         .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", invoc_attr_index));\n                     (\n                         ast_id.with_value(SyntaxNodePtr::from(AstPtr::new(&attr))),\n-                        Some(attr_name.clone()),\n+                        attr.path()\n+                            .and_then(|path| path.segment())\n+                            .and_then(|seg| seg.name_ref())\n+                            .as_ref()\n+                            .map(ToString::to_string),\n                     )\n                 }\n             };\n-            acc.push(\n-                UnresolvedProcMacro { node, precise_location, macro_name: name.map(Into::into) }\n-                    .into(),\n-            );\n+            acc.push(UnresolvedProcMacro { node, precise_location, macro_name }.into());\n         }\n \n         DefDiagnosticKind::UnresolvedMacroCall { ast, path } => {"}, {"sha": "452a3712bcfc89c5f8635768ce87c55ff3ddd81e", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=035bedc28b0069b3181710d38fa63ba6ad92de57", "patch": "@@ -741,23 +741,19 @@ fn macro_call_as_call_id(\n fn derive_macro_as_call_id(\n     item_attr: &AstIdWithPath<ast::Adt>,\n     derive_attr: AttrId,\n+    derive_pos: u32,\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n     let def: MacroDefId = resolver(item_attr.path.clone())\n         .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n-    let last_segment = item_attr\n-        .path\n-        .segments()\n-        .last()\n-        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n     let res = def.as_lazy_macro(\n         db.upcast(),\n         krate,\n         MacroCallKind::Derive {\n             ast_id: item_attr.ast_id,\n-            derive_name: last_segment.to_string().into_boxed_str(),\n+            derive_index: derive_pos,\n             derive_attr_index: derive_attr.ast_index,\n         },\n     );\n@@ -771,8 +767,6 @@ fn attr_macro_as_call_id(\n     krate: CrateId,\n     def: MacroDefId,\n ) -> MacroCallId {\n-    let attr_path = &item_attr.path;\n-    let last_segment = attr_path.segments().last().expect(\"empty attribute path\");\n     let mut arg = match macro_attr.input.as_deref() {\n         Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n         _ => Default::default(),\n@@ -786,7 +780,6 @@ fn attr_macro_as_call_id(\n         krate,\n         MacroCallKind::Attr {\n             ast_id: item_attr.ast_id,\n-            attr_name: last_segment.to_string().into_boxed_str(),\n             attr_args: Arc::new(arg),\n             invoc_attr_index: macro_attr.id.ast_index,\n         },"}, {"sha": "ec6af65a921c3c87f852fca59b36224219ab6526", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=035bedc28b0069b3181710d38fa63ba6ad92de57", "patch": "@@ -1036,6 +1036,9 @@ impl DefCollector<'_> {\n     fn resolve_macros(&mut self) -> ReachedFixedPoint {\n         let mut macros = std::mem::take(&mut self.unresolved_macros);\n         let mut resolved = Vec::new();\n+        let mut push_resolved = |directive: &MacroDirective, call_id| {\n+            resolved.push((directive.module_id, directive.depth, directive.container, call_id));\n+        };\n         let mut res = ReachedFixedPoint::Yes;\n         macros.retain(|directive| {\n             let resolver = |path| {\n@@ -1060,12 +1063,7 @@ impl DefCollector<'_> {\n                         &mut |_err| (),\n                     );\n                     if let Ok(Ok(call_id)) = call_id {\n-                        resolved.push((\n-                            directive.module_id,\n-                            call_id,\n-                            directive.depth,\n-                            directive.container,\n-                        ));\n+                        push_resolved(directive, call_id);\n                         res = ReachedFixedPoint::No;\n                         return false;\n                     }\n@@ -1074,6 +1072,7 @@ impl DefCollector<'_> {\n                     let call_id = derive_macro_as_call_id(\n                         ast_id,\n                         *derive_attr,\n+                        *derive_pos as u32,\n                         self.db,\n                         self.def_map.krate,\n                         &resolver,\n@@ -1086,12 +1085,7 @@ impl DefCollector<'_> {\n                             *derive_pos,\n                         );\n \n-                        resolved.push((\n-                            directive.module_id,\n-                            call_id,\n-                            directive.depth,\n-                            directive.container,\n-                        ));\n+                        push_resolved(directive, call_id);\n                         res = ReachedFixedPoint::No;\n                         return false;\n                     }\n@@ -1229,12 +1223,7 @@ impl DefCollector<'_> {\n                         .scope\n                         .add_attr_macro_invoc(ast_id, call_id);\n \n-                    resolved.push((\n-                        directive.module_id,\n-                        call_id,\n-                        directive.depth,\n-                        directive.container,\n-                    ));\n+                    push_resolved(directive, call_id);\n                     res = ReachedFixedPoint::No;\n                     return false;\n                 }\n@@ -1245,7 +1234,7 @@ impl DefCollector<'_> {\n         // Attribute resolution can add unresolved macro invocations, so concatenate the lists.\n         self.unresolved_macros.extend(macros);\n \n-        for (module_id, macro_call_id, depth, container) in resolved {\n+        for (module_id, depth, container, macro_call_id) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth, container);\n         }\n "}, {"sha": "7d82b33db81fb31284dddac1ce86e35db231dd31", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=035bedc28b0069b3181710d38fa63ba6ad92de57", "patch": "@@ -336,6 +336,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                 ast::Item::cast(node.clone())?\n                     .attrs()\n                     .take(derive_attr_index as usize + 1)\n+                    // FIXME\n                     .filter(|attr| attr.simple_name().as_deref() == Some(\"derive\"))\n                     .map(|it| it.syntax().clone())\n                     .collect()"}, {"sha": "56cf7aed8ee6bd6fb7317e5103b9251fea906be7", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035bedc28b0069b3181710d38fa63ba6ad92de57/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=035bedc28b0069b3181710d38fa63ba6ad92de57", "patch": "@@ -125,16 +125,16 @@ pub enum MacroCallKind {\n     },\n     Derive {\n         ast_id: AstId<ast::Adt>,\n-        derive_name: Box<str>,\n         /// Syntactical index of the invoking `#[derive]` attribute.\n         ///\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         derive_attr_index: u32,\n+        /// Index of the derive macro in the derive attribute\n+        derive_index: u32,\n     },\n     Attr {\n         ast_id: AstId<ast::Item>,\n-        attr_name: Box<str>,\n         attr_args: Arc<(tt::Subtree, mbe::TokenMap)>,\n         /// Syntactical index of the invoking `#[attribute]`.\n         ///"}]}