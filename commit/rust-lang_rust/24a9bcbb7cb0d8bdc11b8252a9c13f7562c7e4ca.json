{"sha": "24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTliY2JiN2NiMGQ4YmRjMTFiODI1MmE5YzEzZjc1NjJjN2U0Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-04T18:44:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-04T18:44:49Z"}, "message": "Auto merge of #61392 - Zoxc:single-interner, r=eddyb\n\nUse a single CtxtInterners\n\nBuilds on https://github.com/rust-lang/rust/pull/57214\n\nr? @eddyb", "tree": {"sha": "386c47718e54da97eb691a2bbb938c5e8d703894", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/386c47718e54da97eb691a2bbb938c5e8d703894"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca", "html_url": "https://github.com/rust-lang/rust/commit/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43eb4235ac43c822d903ad26ed806f34cc1a14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43eb4235ac43c822d903ad26ed806f34cc1a14a", "html_url": "https://github.com/rust-lang/rust/commit/b43eb4235ac43c822d903ad26ed806f34cc1a14a"}, {"sha": "ec8c2e1ab9bd47c0184a0cbd77f35e9089c9dc0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec8c2e1ab9bd47c0184a0cbd77f35e9089c9dc0f", "html_url": "https://github.com/rust-lang/rust/commit/ec8c2e1ab9bd47c0184a0cbd77f35e9089c9dc0f"}], "stats": {"total": 164, "additions": 28, "deletions": 136}, "files": [{"sha": "88236a79421f3bc2e0facbbc17c9d6b187100875", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 28, "deletions": 136, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n@@ -67,7 +65,6 @@ use std::ops::{Deref, Bound};\n use std::iter;\n use std::sync::mpsc;\n use std::sync::Arc;\n-use std::marker::PhantomData;\n use rustc_target::spec::abi;\n use rustc_macros::HashStable;\n use syntax::ast;\n@@ -81,14 +78,12 @@ use crate::hir;\n \n pub struct AllArenas {\n     pub interner: SyncDroplessArena,\n-    pub local_interner: SyncDroplessArena,\n }\n \n impl AllArenas {\n     pub fn new() -> Self {\n         AllArenas {\n             interner: SyncDroplessArena::default(),\n-            local_interner: SyncDroplessArena::default(),\n         }\n     }\n }\n@@ -136,57 +131,21 @@ impl<'tcx> CtxtInterners<'tcx> {\n \n     /// Intern a type\n     #[inline(never)]\n-    fn intern_ty(\n-        local: &CtxtInterners<'tcx>,\n-        global: &CtxtInterners<'tcx>,\n-        st: TyKind<'tcx>,\n+    fn intern_ty(&self,\n+        st: TyKind<'tcx>\n     ) -> Ty<'tcx> {\n-        let flags = super::flags::FlagComputation::for_sty(&st);\n-\n-        // HACK(eddyb) Depend on flags being accurate to\n-        // determine that all contents are in the global tcx.\n-        // See comments on Lift for why we can't use that.\n-        if flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n-            local.type_.borrow_mut().intern(st, |st| {\n-                let ty_struct = TyS {\n-                    sty: st,\n-                    flags: flags.flags,\n-                    outer_exclusive_binder: flags.outer_exclusive_binder,\n-                };\n+        self.type_.borrow_mut().intern(st, |st| {\n+            let flags = super::flags::FlagComputation::for_sty(&st);\n \n-                // Make sure we don't end up with inference\n-                // types/regions in the global interner\n-                if ptr_eq(local, global) {\n-                    bug!(\"Attempted to intern `{:?}` which contains \\\n-                        inference types/regions in the global type context\",\n-                        &ty_struct);\n-                }\n-\n-                // This is safe because all the types the ty_struct can point to\n-                // already is in the local arena or the global arena\n-                let ty_struct: TyS<'tcx> = unsafe {\n-                    mem::transmute(ty_struct)\n-                };\n-\n-                Interned(local.arena.alloc(ty_struct))\n-            }).0\n-        } else {\n-            global.type_.borrow_mut().intern(st, |st| {\n-                let ty_struct = TyS {\n-                    sty: st,\n-                    flags: flags.flags,\n-                    outer_exclusive_binder: flags.outer_exclusive_binder,\n-                };\n+            let ty_struct = TyS {\n+                sty: st,\n+                flags: flags.flags,\n+                outer_exclusive_binder: flags.outer_exclusive_binder,\n+            };\n \n-                // This is safe because all the types the ty_struct can point to\n-                // already is in the global arena\n-                let ty_struct: TyS<'tcx> = unsafe {\n-                    mem::transmute(ty_struct)\n-                };\n \n-                Interned(global.arena.alloc(ty_struct))\n-            }).0\n-        }\n+            Interned(self.arena.alloc(ty_struct))\n+        }).0\n     }\n }\n \n@@ -933,7 +892,7 @@ EnumLiftImpl! {\n \n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n-        let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n+        let mk = |sty| interners.intern_ty(sty);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1015,8 +974,6 @@ pub struct FreeRegionInfo {\n #[derive(Copy, Clone)]\n pub struct TyCtxt<'tcx> {\n     gcx: &'tcx GlobalCtxt<'tcx>,\n-    interners: &'tcx CtxtInterners<'tcx>,\n-    dummy: PhantomData<&'tcx ()>,\n }\n \n impl<'tcx> Deref for TyCtxt<'tcx> {\n@@ -1030,8 +987,7 @@ impl<'tcx> Deref for TyCtxt<'tcx> {\n pub struct GlobalCtxt<'tcx> {\n     pub arena: WorkerLocal<Arena<'tcx>>,\n \n-    global_interners: CtxtInterners<'tcx>,\n-    local_interners: CtxtInterners<'tcx>,\n+    interners: CtxtInterners<'tcx>,\n \n     cstore: &'tcx CrateStoreDyn,\n \n@@ -1122,8 +1078,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn global_tcx(self) -> TyCtxt<'tcx> {\n         TyCtxt {\n             gcx: self.gcx,\n-            interners: &self.gcx.global_interners,\n-            dummy: PhantomData,\n         }\n     }\n \n@@ -1203,11 +1157,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         value.lift_to_tcx(self.global_tcx())\n     }\n \n-    /// Returns `true` if self is the same as self.global_tcx().\n-    fn is_global(self) -> bool {\n-        ptr_eq(self.interners, &self.global_interners)\n-    }\n-\n     /// Creates a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n@@ -1229,7 +1178,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(&arenas.interner);\n-        let local_interners = CtxtInterners::new(&arenas.local_interner);\n         let common = Common {\n             empty_predicates: ty::GenericPredicates {\n                 parent: None,\n@@ -1287,8 +1235,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             sess: s,\n             cstore,\n             arena: WorkerLocal::new(|_| Arena::default()),\n-            global_interners: interners,\n-            local_interners: local_interners,\n+            interners,\n             dep_graph,\n             common,\n             types: common_types,\n@@ -1682,8 +1629,6 @@ impl<'tcx> GlobalCtxt<'tcx> {\n     {\n         let tcx = TyCtxt {\n             gcx: self,\n-            interners: &self.local_interners,\n-            dummy: PhantomData,\n         };\n         ty::tls::with_related_context(tcx.global_tcx(), |icx| {\n             let new_icx = ty::tls::ImplicitCtxt {\n@@ -1729,11 +1674,7 @@ macro_rules! nop_lift {\n                     type Lifted = $lifted;\n                     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                         if tcx.interners.arena.in_arena(*self as *const _) {\n-                            return Some(unsafe { mem::transmute(*self) });\n-                        }\n-                        // Also try in the global tcx if we're not that.\n-                        if !tcx.is_global() {\n-                            self.lift_to_tcx(tcx.global_tcx())\n+                            Some(unsafe { mem::transmute(*self) })\n                         } else {\n                             None\n                         }\n@@ -1751,11 +1692,7 @@ macro_rules! nop_list_lift {\n                             return Some(List::empty());\n                         }\n                         if tcx.interners.arena.in_arena(*self as *const _) {\n-                            return Some(unsafe { mem::transmute(*self) });\n-                        }\n-                        // Also try in the global tcx if we're not that.\n-                        if !tcx.is_global() {\n-                            self.lift_to_tcx(tcx.global_tcx())\n+                            Some(unsafe { mem::transmute(*self) })\n                         } else {\n                             None\n                         }\n@@ -1785,7 +1722,6 @@ pub mod tls {\n \n     use std::fmt;\n     use std::mem;\n-    use std::marker::PhantomData;\n     use syntax_pos;\n     use crate::ty::query;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n@@ -1949,8 +1885,6 @@ pub mod tls {\n \n         let tcx = TyCtxt {\n             gcx,\n-            interners: &gcx.global_interners,\n-            dummy: PhantomData,\n         };\n         let icx = ImplicitCtxt {\n             tcx,\n@@ -1981,8 +1915,6 @@ pub mod tls {\n         let gcx = &*(gcx as *const GlobalCtxt<'_>);\n         let tcx = TyCtxt {\n             gcx,\n-            interners: &gcx.global_interners,\n-            dummy: PhantomData,\n         };\n         let icx = ImplicitCtxt {\n             query: None,\n@@ -2041,26 +1973,6 @@ pub mod tls {\n         })\n     }\n \n-    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n-    /// interner and local interner as the tcx argument passed in. This means the closure\n-    /// is given an ImplicitCtxt with the same 'tcx and 'tcx lifetimes as the TyCtxt passed in.\n-    /// This will panic if you pass it a TyCtxt which has a different global interner or\n-    /// a different local interner from the current ImplicitCtxt's tcx field.\n-    #[inline]\n-    pub fn with_fully_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n-    where\n-        F: for<'b> FnOnce(&ImplicitCtxt<'b, 'tcx>) -> R,\n-    {\n-        with_context(|context| {\n-            unsafe {\n-                assert!(ptr_eq(context.tcx.gcx, tcx.gcx));\n-                assert!(ptr_eq(context.tcx.interners, tcx.interners));\n-                let context: &ImplicitCtxt<'_, '_> = mem::transmute(context);\n-                f(context)\n-            }\n-        })\n-    }\n-\n     /// Allows access to the TyCtxt in the current ImplicitCtxt.\n     /// Panics if there is no ImplicitCtxt available\n     #[inline]\n@@ -2288,39 +2200,22 @@ impl<'tcx> Borrow<[Goal<'tcx>]> for Interned<'tcx, List<Goal<'tcx>>> {\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:expr,\n-                                            $alloc_to_key:expr,\n-                                            $keep_in_local_tcx:expr) -> $ty:ty) => {\n+                                            $alloc_to_key:expr) -> $ty:ty) => {\n         impl<$lt_tcx> TyCtxt<$lt_tcx> {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n                 let key = ($alloc_to_key)(&v);\n \n-                // HACK(eddyb) Depend on flags being accurate to\n-                // determine that all contents are in the global tcx.\n-                // See comments on Lift for why we can't use that.\n-                if ($keep_in_local_tcx)(&v) {\n-                    self.interners.$name.borrow_mut().intern_ref(key, || {\n-                        // Make sure we don't end up with inference\n-                        // types/regions in the global tcx.\n-                        if self.is_global() {\n-                            bug!(\"Attempted to intern `{:?}` which contains \\\n-                                inference types/regions in the global type context\",\n-                                v);\n-                        }\n+                self.interners.$name.borrow_mut().intern_ref(key, || {\n+                    Interned($alloc_method(&self.interners.arena, v))\n \n-                        Interned($alloc_method(&self.interners.arena, v))\n-                    }).0\n-                } else {\n-                    self.global_interners.$name.borrow_mut().intern_ref(key, || {\n-                        Interned($alloc_method(&self.global_interners.arena, v))\n-                    }).0\n-                }\n+                }).0\n             }\n         }\n     }\n }\n \n macro_rules! direct_interners {\n-    ($lt_tcx:tt, $($name:ident: $method:ident($keep_in_local_tcx:expr) -> $ty:ty),+) => {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($ty:ty)),+) => {\n         $(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n@@ -2339,8 +2234,7 @@ macro_rules! direct_interners {\n             $lt_tcx,\n             $name: $method($ty,\n                            |a: &$lt_tcx SyncDroplessArena, v| -> &$lt_tcx $ty { a.alloc(v) },\n-                           |x| x,\n-                           $keep_in_local_tcx) -> $ty);)+\n+                           |x| x) -> $ty);)+\n     }\n }\n \n@@ -2349,18 +2243,17 @@ pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n }\n \n direct_interners!('tcx,\n-    region: mk_region(|r: &RegionKind| r.keep_in_local_tcx()) -> RegionKind,\n-    goal: mk_goal(|c: &GoalKind<'_>| keep_local(c)) -> GoalKind<'tcx>,\n-    const_: mk_const(|c: &Const<'_>| keep_local(&c)) -> Const<'tcx>\n+    region: mk_region(RegionKind),\n+    goal: mk_goal(GoalKind<'tcx>),\n+    const_: mk_const(Const<'tcx>)\n );\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+) => (\n         $(intern_method!( 'tcx, $field: $method(\n             &[$ty],\n             |a, v| List::from_arena(a, v),\n-            Deref::deref,\n-            |xs: &[$ty]| xs.iter().any(keep_local)) -> List<$ty>);)+\n+            Deref::deref) -> List<$ty>);)+\n     );\n }\n \n@@ -2384,8 +2277,7 @@ intern_method! {\n     canonical_var_infos: _intern_canonical_var_infos(\n         &[CanonicalVarInfo],\n         |a, v| List::from_arena(a, v),\n-        Deref::deref,\n-        |_xs: &[CanonicalVarInfo]| -> bool { false }\n+        Deref::deref\n     ) -> List<CanonicalVarInfo>\n }\n \n@@ -2431,7 +2323,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n-        CtxtInterners::intern_ty(&self.interners, &self.global_interners, st)\n+        self.interners.intern_ty(st)\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}]}