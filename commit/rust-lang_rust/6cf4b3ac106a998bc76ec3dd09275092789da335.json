{"sha": "6cf4b3ac106a998bc76ec3dd09275092789da335", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZjRiM2FjMTA2YTk5OGJjNzZlYzNkZDA5Mjc1MDkyNzg5ZGEzMzU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:28:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:28:38Z"}, "message": "typeck: check_expr_kind -> expr.rs", "tree": {"sha": "75378f5108ff9a9327660b981dcaea4e8c7afef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75378f5108ff9a9327660b981dcaea4e8c7afef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cf4b3ac106a998bc76ec3dd09275092789da335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf4b3ac106a998bc76ec3dd09275092789da335", "html_url": "https://github.com/rust-lang/rust/commit/6cf4b3ac106a998bc76ec3dd09275092789da335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cf4b3ac106a998bc76ec3dd09275092789da335/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9606f6fa64926a84d82e3c62dbdc57f5c10f756d", "html_url": "https://github.com/rust-lang/rust/commit/9606f6fa64926a84d82e3c62dbdc57f5c10f756d"}], "stats": {"total": 1381, "additions": 708, "deletions": 673}, "files": [{"sha": "48c1c0b36ffbfece413ef1570f3497cb4fef2f6a", "filename": "src/librustc_typeck/check/expr.rs", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/6cf4b3ac106a998bc76ec3dd09275092789da335/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf4b3ac106a998bc76ec3dd09275092789da335/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=6cf4b3ac106a998bc76ec3dd09275092789da335", "patch": "@@ -0,0 +1,706 @@\n+//! Type checking expressions.\n+//!\n+//! See `mod.rs` for more context on type checking in general.\n+\n+use crate::check::BreakableCtxt;\n+use crate::check::cast;\n+use crate::check::coercion::CoerceMany;\n+use crate::check::Diverges;\n+use crate::check::FnCtxt;\n+use crate::check::Expectation::{self, NoExpectation, ExpectHasType, ExpectCastableToType};\n+use crate::check::fatally_break_rust;\n+use crate::check::report_unexpected_variant_res;\n+use crate::check::Needs;\n+use crate::middle::lang_items;\n+use crate::util::common::ErrorReported;\n+\n+use errors::Applicability;\n+use syntax::ast;\n+use syntax::symbol::sym;\n+use rustc::hir;\n+use rustc::hir::{ExprKind, QPath};\n+use rustc::hir::def::{CtorKind, Res, DefKind};\n+use rustc::infer;\n+use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::mir::interpret::GlobalId;\n+use rustc::ty;\n+use rustc::ty::adjustment::{\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n+};\n+use rustc::ty::Ty;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::InternalSubsts;\n+use rustc::traits::{self, ObligationCauseCode};\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn check_expr_kind(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\",\n+            expr,\n+            expected,\n+            needs,\n+        );\n+\n+        let tcx = self.tcx;\n+        let id = expr.hir_id;\n+        match expr.node {\n+            ExprKind::Box(ref subexpr) => {\n+                let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::Adt(def, _) if def.is_box()\n+                            => Expectation::rvalue_hint(self, ty.boxed_ty()),\n+                        _ => NoExpectation\n+                    }\n+                });\n+                let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n+                tcx.mk_box(referent_ty)\n+            }\n+\n+            ExprKind::Lit(ref lit) => {\n+                self.check_lit(&lit, expected)\n+            }\n+            ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                self.check_binop(expr, op, lhs, rhs)\n+            }\n+            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                self.check_binop_assign(expr, op, lhs, rhs)\n+            }\n+            ExprKind::Unary(unop, ref oprnd) => {\n+                let expected_inner = match unop {\n+                    hir::UnNot | hir::UnNeg => {\n+                        expected\n+                    }\n+                    hir::UnDeref => {\n+                        NoExpectation\n+                    }\n+                };\n+                let needs = match unop {\n+                    hir::UnDeref => needs,\n+                    _ => Needs::None\n+                };\n+                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n+                                                                             expected_inner,\n+                                                                             needs);\n+\n+                if !oprnd_t.references_error() {\n+                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n+                    match unop {\n+                        hir::UnDeref => {\n+                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n+                                oprnd_t = mt.ty;\n+                            } else if let Some(ok) = self.try_overloaded_deref(\n+                                    expr.span, oprnd_t, needs) {\n+                                let method = self.register_infer_ok_obligations(ok);\n+                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                                    let mutbl = match mutbl {\n+                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                            // (It shouldn't actually matter for unary ops whether\n+                                            // we enable two-phase borrows or not, since a unary\n+                                            // op has no additional operands.)\n+                                            allow_two_phase_borrow: AllowTwoPhase::No,\n+                                        }\n+                                    };\n+                                    self.apply_adjustments(oprnd, vec![Adjustment {\n+                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                                        target: method.sig.inputs()[0]\n+                                    }]);\n+                                }\n+                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n+                                self.write_method_call(expr.hir_id, method);\n+                            } else {\n+                                let mut err = type_error_struct!(\n+                                    tcx.sess,\n+                                    expr.span,\n+                                    oprnd_t,\n+                                    E0614,\n+                                    \"type `{}` cannot be dereferenced\",\n+                                    oprnd_t,\n+                                );\n+                                let sp = tcx.sess.source_map().start_point(expr.span);\n+                                if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n+                                    .borrow().get(&sp)\n+                                {\n+                                    tcx.sess.parse_sess.expr_parentheses_needed(\n+                                        &mut err,\n+                                        *sp,\n+                                        None,\n+                                    );\n+                                }\n+                                err.emit();\n+                                oprnd_t = tcx.types.err;\n+                            }\n+                        }\n+                        hir::UnNot => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n+                                oprnd_t = result;\n+                            }\n+                        }\n+                        hir::UnNeg => {\n+                            let result = self.check_user_unop(expr, oprnd_t, unop);\n+                            // If it's builtin, we can reuse the type, this helps inference.\n+                            if !oprnd_t.is_numeric() {\n+                                oprnd_t = result;\n+                            }\n+                        }\n+                    }\n+                }\n+                oprnd_t\n+            }\n+            ExprKind::AddrOf(mutbl, ref oprnd) => {\n+                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n+                    match ty.sty {\n+                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n+                            if oprnd.is_place_expr() {\n+                                // Places may legitimately have unsized types.\n+                                // For example, dereferences of a fat pointer and\n+                                // the last field of a struct can be unsized.\n+                                ExpectHasType(ty)\n+                            } else {\n+                                Expectation::rvalue_hint(self, ty)\n+                            }\n+                        }\n+                        _ => NoExpectation\n+                    }\n+                });\n+                let needs = Needs::maybe_mut_place(mutbl);\n+                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+\n+                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+                if tm.ty.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Note: at this point, we cannot say what the best lifetime\n+                    // is to use for resulting pointer.  We want to use the\n+                    // shortest lifetime possible so as to avoid spurious borrowck\n+                    // errors.  Moreover, the longest lifetime will depend on the\n+                    // precise details of the value whose address is being taken\n+                    // (and how long it is valid), which we don't know yet until type\n+                    // inference is complete.\n+                    //\n+                    // Therefore, here we simply generate a region variable.  The\n+                    // region inferencer will then select the ultimate value.\n+                    // Finally, borrowck is charged with guaranteeing that the\n+                    // value whose address was taken can actually be made to live\n+                    // as long as it needs to live.\n+                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+                    tcx.mk_ref(region, tm)\n+                }\n+            }\n+            ExprKind::Path(ref qpath) => {\n+                let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n+                    expr.span);\n+                let ty = match res {\n+                    Res::Err => {\n+                        self.set_tainted_by_errors();\n+                        tcx.types.err\n+                    }\n+                    Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n+                        report_unexpected_variant_res(tcx, res, expr.span, qpath);\n+                        tcx.types.err\n+                    }\n+                    _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, id).0,\n+                };\n+\n+                if let ty::FnDef(..) = ty.sty {\n+                    let fn_sig = ty.fn_sig(tcx);\n+                    if !tcx.features().unsized_locals {\n+                        // We want to remove some Sized bounds from std functions,\n+                        // but don't want to expose the removal to stable Rust.\n+                        // i.e., we don't want to allow\n+                        //\n+                        // ```rust\n+                        // drop as fn(str);\n+                        // ```\n+                        //\n+                        // to work in stable even if the Sized bound on `drop` is relaxed.\n+                        for i in 0..fn_sig.inputs().skip_binder().len() {\n+                            // We just want to check sizedness, so instead of introducing\n+                            // placeholder lifetimes with probing, we just replace higher lifetimes\n+                            // with fresh vars.\n+                            let input = self.replace_bound_vars_with_fresh_vars(\n+                                expr.span,\n+                                infer::LateBoundRegionConversionTime::FnCall,\n+                                &fn_sig.input(i)).0;\n+                            self.require_type_is_sized_deferred(input, expr.span,\n+                                                                traits::SizedArgumentType);\n+                        }\n+                    }\n+                    // Here we want to prevent struct constructors from returning unsized types.\n+                    // There were two cases this happened: fn pointer coercion in stable\n+                    // and usual function call in presense of unsized_locals.\n+                    // Also, as we just want to check sizedness, instead of introducing\n+                    // placeholder lifetimes with probing, we just replace higher lifetimes\n+                    // with fresh vars.\n+                    let output = self.replace_bound_vars_with_fresh_vars(\n+                        expr.span,\n+                        infer::LateBoundRegionConversionTime::FnCall,\n+                        &fn_sig.output()).0;\n+                    self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n+                }\n+\n+                // We always require that the type provided as the value for\n+                // a type parameter outlives the moment of instantiation.\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n+                self.add_wf_bounds(substs, expr);\n+\n+                ty\n+            }\n+            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n+                for expr in outputs.iter().chain(inputs.iter()) {\n+                    self.check_expr(expr);\n+                }\n+                tcx.mk_unit()\n+            }\n+            ExprKind::Break(destination, ref expr_opt) => {\n+                if let Ok(target_id) = destination.target_id {\n+                    let (e_ty, cause);\n+                    if let Some(ref e) = *expr_opt {\n+                        // If this is a break with a value, we need to type-check\n+                        // the expression. Get an expected type from the loop context.\n+                        let opt_coerce_to = {\n+                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                            enclosing_breakables.find_breakable(target_id)\n+                                                .coerce\n+                                                .as_ref()\n+                                                .map(|coerce| coerce.expected_ty())\n+                        };\n+\n+                        // If the loop context is not a `loop { }`, then break with\n+                        // a value is illegal, and `opt_coerce_to` will be `None`.\n+                        // Just set expectation to error in that case.\n+                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                        // Recurse without `enclosing_breakables` borrowed.\n+                        e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        cause = self.misc(e.span);\n+                    } else {\n+                        // Otherwise, this is a break *without* a value. That's\n+                        // always legal, and is equivalent to `break ()`.\n+                        e_ty = tcx.mk_unit();\n+                        cause = self.misc(expr.span);\n+                    }\n+\n+                    // Now that we have type-checked `expr_opt`, borrow\n+                    // the `enclosing_loops` field and let's coerce the\n+                    // type of `expr_opt` into what is expected.\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    let ctxt = enclosing_breakables.find_breakable(target_id);\n+                    if let Some(ref mut coerce) = ctxt.coerce {\n+                        if let Some(ref e) = *expr_opt {\n+                            coerce.coerce(self, &cause, e, e_ty);\n+                        } else {\n+                            assert!(e_ty.is_unit());\n+                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                        }\n+                    } else {\n+                        // If `ctxt.coerce` is `None`, we can just ignore\n+                        // the type of the expresison.  This is because\n+                        // either this was a break *without* a value, in\n+                        // which case it is always a legal type (`()`), or\n+                        // else an error would have been flagged by the\n+                        // `loops` pass for using break with an expression\n+                        // where you are not supposed to.\n+                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+                    }\n+\n+                    ctxt.may_break = true;\n+\n+                    // the type of a `break` is always `!`, since it diverges\n+                    tcx.types.never\n+                } else {\n+                    // Otherwise, we failed to find the enclosing loop;\n+                    // this can only happen if the `break` was not\n+                    // inside a loop at all, which is caught by the\n+                    // loop-checking pass.\n+                    if self.tcx.sess.err_count() == 0 {\n+                        self.tcx.sess.delay_span_bug(expr.span,\n+                            \"break was outside loop, but no error was emitted\");\n+                    }\n+\n+                    // We still need to assign a type to the inner expression to\n+                    // prevent the ICE in #43162.\n+                    if let Some(ref e) = *expr_opt {\n+                        self.check_expr_with_hint(e, tcx.types.err);\n+\n+                        // ... except when we try to 'break rust;'.\n+                        // ICE this expression in particular (see #43162).\n+                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+                            if path.segments.len() == 1 &&\n+                               path.segments[0].ident.name == sym::rust {\n+                                fatally_break_rust(self.tcx.sess);\n+                            }\n+                        }\n+                    }\n+                    // There was an error; make type-check fail.\n+                    tcx.types.err\n+                }\n+\n+            }\n+            ExprKind::Continue(destination) => {\n+                if destination.target_id.is_ok() {\n+                    tcx.types.never\n+                } else {\n+                    // There was an error; make type-check fail.\n+                    tcx.types.err\n+                }\n+            }\n+            ExprKind::Ret(ref expr_opt) => {\n+                if self.ret_coercion.is_none() {\n+                    struct_span_err!(self.tcx.sess, expr.span, E0572,\n+                                     \"return statement outside of function body\").emit();\n+                } else if let Some(ref e) = *expr_opt {\n+                    if self.ret_coercion_span.borrow().is_none() {\n+                        *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+                    }\n+                    self.check_return_expr(e);\n+                } else {\n+                    let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+                    if self.ret_coercion_span.borrow().is_none() {\n+                        *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+                    }\n+                    let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n+                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n+                        coercion.coerce_forced_unit(\n+                            self,\n+                            &cause,\n+                            &mut |db| {\n+                                db.span_label(\n+                                    fn_decl.output.span(),\n+                                    format!(\n+                                        \"expected `{}` because of this return type\",\n+                                        fn_decl.output,\n+                                    ),\n+                                );\n+                            },\n+                            true,\n+                        );\n+                    } else {\n+                        coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                    }\n+                }\n+                tcx.types.never\n+            }\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n+                self.check_assign(expr, expected, lhs, rhs)\n+            }\n+            ExprKind::While(ref cond, ref body, _) => {\n+                let ctxt = BreakableCtxt {\n+                    // cannot use break with a value from a while loop\n+                    coerce: None,\n+                    may_break: false,  // Will get updated if/when we find a `break`.\n+                };\n+\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n+                    self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n+                    let cond_diverging = self.diverges.get();\n+                    self.check_block_no_value(&body);\n+\n+                    // We may never reach the body so it diverging means nothing.\n+                    self.diverges.set(cond_diverging);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n+                }\n+\n+                self.tcx.mk_unit()\n+            }\n+            ExprKind::Loop(ref body, _, source) => {\n+                let coerce = match source {\n+                    // you can only use break with a value from a normal `loop { }`\n+                    hir::LoopSource::Loop => {\n+                        let coerce_to = expected.coercion_target_type(self, body.span);\n+                        Some(CoerceMany::new(coerce_to))\n+                    }\n+\n+                    hir::LoopSource::WhileLet |\n+                    hir::LoopSource::ForLoop => {\n+                        None\n+                    }\n+                };\n+\n+                let ctxt = BreakableCtxt {\n+                    coerce,\n+                    may_break: false, // Will get updated if/when we find a `break`.\n+                };\n+\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n+                    self.check_block_no_value(&body);\n+                });\n+\n+                if ctxt.may_break {\n+                    // No way to know whether it's diverging because\n+                    // of a `break` or an outer `break` or `return`.\n+                    self.diverges.set(Diverges::Maybe);\n+                }\n+\n+                // If we permit break with a value, then result type is\n+                // the LUB of the breaks (possibly ! if none); else, it\n+                // is nil. This makes sense because infinite loops\n+                // (which would have type !) are only possible iff we\n+                // permit break with a value [1].\n+                if ctxt.coerce.is_none() && !ctxt.may_break {\n+                    // [1]\n+                    self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n+                }\n+                ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n+            }\n+            ExprKind::Match(ref discrim, ref arms, match_src) => {\n+                self.check_match(expr, &discrim, arms, expected, match_src)\n+            }\n+            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n+            }\n+            ExprKind::Block(ref body, _) => {\n+                self.check_block_with_expected(&body, expected)\n+            }\n+            ExprKind::Call(ref callee, ref args) => {\n+                self.check_call(expr, &callee, args, expected)\n+            }\n+            ExprKind::MethodCall(ref segment, span, ref args) => {\n+                self.check_method_call(expr, segment, span, args, expected, needs)\n+            }\n+            ExprKind::Cast(ref e, ref t) => {\n+                // Find the type of `e`. Supply hints based on the type we are casting to,\n+                // if appropriate.\n+                let t_cast = self.to_ty_saving_user_provided_ty(t);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n+                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n+\n+                // Eagerly check for some obvious errors.\n+                if t_expr.references_error() || t_cast.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    // Defer other checks until we're done type checking.\n+                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                        Ok(cast_check) => {\n+                            deferred_cast_checks.push(cast_check);\n+                            t_cast\n+                        }\n+                        Err(ErrorReported) => {\n+                            tcx.types.err\n+                        }\n+                    }\n+                }\n+            }\n+            ExprKind::Type(ref e, ref t) => {\n+                let ty = self.to_ty_saving_user_provided_ty(&t);\n+                self.check_expr_eq_type(&e, ty);\n+                ty\n+            }\n+            ExprKind::DropTemps(ref e) => {\n+                self.check_expr_with_expectation(e, expected)\n+            }\n+            ExprKind::Array(ref args) => {\n+                let uty = expected.to_option(self).and_then(|uty| {\n+                    match uty.sty {\n+                        ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n+                        _ => None\n+                    }\n+                });\n+\n+                let element_ty = if !args.is_empty() {\n+                    let coerce_to = uty.unwrap_or_else(|| {\n+                        self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: expr.span,\n+                        })\n+                    });\n+                    let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+                    assert_eq!(self.diverges.get(), Diverges::Maybe);\n+                    for e in args {\n+                        let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                        let cause = self.misc(e.span);\n+                        coerce.coerce(self, &cause, e, e_ty);\n+                    }\n+                    coerce.complete(self)\n+                } else {\n+                    self.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span: expr.span,\n+                    })\n+                };\n+                tcx.mk_array(element_ty, args.len() as u64)\n+            }\n+            ExprKind::Repeat(ref element, ref count) => {\n+                let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n+                let count = if self.const_param_def_id(count).is_some() {\n+                    Ok(self.to_const(count, self.tcx.type_of(count_def_id)))\n+                } else {\n+                    let param_env = ty::ParamEnv::empty();\n+                    let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+                    let instance = ty::Instance::resolve(\n+                        tcx.global_tcx(),\n+                        param_env,\n+                        count_def_id,\n+                        substs,\n+                    ).unwrap();\n+                    let global_id = GlobalId {\n+                        instance,\n+                        promoted: None\n+                    };\n+\n+                    tcx.const_eval(param_env.and(global_id))\n+                };\n+\n+                let uty = match expected {\n+                    ExpectHasType(uty) => {\n+                        match uty.sty {\n+                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n+                            _ => None\n+                        }\n+                    }\n+                    _ => None\n+                };\n+\n+                let (element_ty, t) = match uty {\n+                    Some(uty) => {\n+                        self.check_expr_coercable_to_type(&element, uty);\n+                        (uty, uty)\n+                    }\n+                    None => {\n+                        let ty = self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: element.span,\n+                        });\n+                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                        (element_ty, ty)\n+                    }\n+                };\n+\n+                if let Ok(count) = count {\n+                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n+                    if !zero_or_one {\n+                        // For [foo, ..n] where n > 1, `foo` must have\n+                        // Copy type:\n+                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+                    }\n+                }\n+\n+                if element_ty.references_error() {\n+                    tcx.types.err\n+                } else if let Ok(count) = count {\n+                    tcx.mk_ty(ty::Array(t, count))\n+                } else {\n+                    tcx.types.err\n+                }\n+            }\n+            ExprKind::Tup(ref elts) => {\n+                let flds = expected.only_has_type(self).and_then(|ty| {\n+                    let ty = self.resolve_type_vars_with_obligations(ty);\n+                    match ty.sty {\n+                        ty::Tuple(ref flds) => Some(&flds[..]),\n+                        _ => None\n+                    }\n+                });\n+\n+                let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n+                    let t = match flds {\n+                        Some(ref fs) if i < fs.len() => {\n+                            let ety = fs[i].expect_ty();\n+                            self.check_expr_coercable_to_type(&e, ety);\n+                            ety\n+                        }\n+                        _ => {\n+                            self.check_expr_with_expectation(&e, NoExpectation)\n+                        }\n+                    };\n+                    t\n+                });\n+                let tuple = tcx.mk_tup(elt_ts_iter);\n+                if tuple.references_error() {\n+                    tcx.types.err\n+                } else {\n+                    self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n+                    tuple\n+                }\n+            }\n+            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n+            }\n+            ExprKind::Field(ref base, field) => {\n+                self.check_field(expr, needs, &base, field)\n+            }\n+            ExprKind::Index(ref base, ref idx) => {\n+                let base_t = self.check_expr_with_needs(&base, needs);\n+                let idx_t = self.check_expr(&idx);\n+\n+                if base_t.references_error() {\n+                    base_t\n+                } else if idx_t.references_error() {\n+                    idx_t\n+                } else {\n+                    let base_t = self.structurally_resolved_type(base.span, base_t);\n+                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+                        Some((index_ty, element_ty)) => {\n+                            // two-phase not needed because index_ty is never mutable\n+                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                            element_ty\n+                        }\n+                        None => {\n+                            let mut err =\n+                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n+                                                   \"cannot index into a value of type `{}`\",\n+                                                   base_t);\n+                            // Try to give some advice about indexing tuples.\n+                            if let ty::Tuple(..) = base_t.sty {\n+                                let mut needs_note = true;\n+                                // If the index is an integer, we can show the actual\n+                                // fixed expression:\n+                                if let ExprKind::Lit(ref lit) = idx.node {\n+                                    if let ast::LitKind::Int(i,\n+                                            ast::LitIntType::Unsuffixed) = lit.node {\n+                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n+                                        if let Ok(snip) = snip {\n+                                            err.span_suggestion(\n+                                                expr.span,\n+                                                \"to access tuple elements, use\",\n+                                                format!(\"{}.{}\", snip, i),\n+                                                Applicability::MachineApplicable,\n+                                            );\n+                                            needs_note = false;\n+                                        }\n+                                    }\n+                                }\n+                                if needs_note {\n+                                    err.help(\"to access tuple elements, use tuple indexing \\\n+                                              syntax (e.g., `tuple.0`)\");\n+                                }\n+                            }\n+                            err.emit();\n+                            self.tcx.types.err\n+                        }\n+                    }\n+                }\n+            }\n+            ExprKind::Yield(ref value) => {\n+                match self.yield_ty {\n+                    Some(ty) => {\n+                        self.check_expr_coercable_to_type(&value, ty);\n+                    }\n+                    None => {\n+                        struct_span_err!(self.tcx.sess, expr.span, E0627,\n+                                         \"yield statement outside of generator literal\").emit();\n+                    }\n+                }\n+                tcx.mk_unit()\n+            }\n+            hir::ExprKind::Err => {\n+                tcx.types.err\n+            }\n+        }\n+    }\n+}"}, {"sha": "1cb064c23a9640c2d8240887a664f8c4473301fb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 673, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/6cf4b3ac106a998bc76ec3dd09275092789da335/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cf4b3ac106a998bc76ec3dd09275092789da335/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6cf4b3ac106a998bc76ec3dd09275092789da335", "patch": "@@ -74,6 +74,7 @@ pub mod writeback;\n mod regionck;\n pub mod coercion;\n pub mod demand;\n+mod expr;\n pub mod method;\n mod upvar;\n mod wfcheck;\n@@ -88,7 +89,7 @@ mod op;\n use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n-use rustc::hir::def::{CtorOf, CtorKind, Res, DefKind};\n+use rustc::hir::def::{CtorOf, Res, DefKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -3923,7 +3924,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         adt_ty\n     }\n \n-\n     /// Invariant:\n     /// If an expression has any sub-expressions that result in a type error,\n     /// inspecting that expression's type with `ty.references_error()` will return\n@@ -3983,677 +3983,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    fn check_expr_kind(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        debug!(\n-            \"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\",\n-            expr,\n-            expected,\n-            needs,\n-        );\n-\n-        let tcx = self.tcx;\n-        let id = expr.hir_id;\n-        match expr.node {\n-            ExprKind::Box(ref subexpr) => {\n-                let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n-                    match ty.sty {\n-                        ty::Adt(def, _) if def.is_box()\n-                            => Expectation::rvalue_hint(self, ty.boxed_ty()),\n-                        _ => NoExpectation\n-                    }\n-                });\n-                let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n-                tcx.mk_box(referent_ty)\n-            }\n-\n-            ExprKind::Lit(ref lit) => {\n-                self.check_lit(&lit, expected)\n-            }\n-            ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.check_binop(expr, op, lhs, rhs)\n-            }\n-            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                self.check_binop_assign(expr, op, lhs, rhs)\n-            }\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                let expected_inner = match unop {\n-                    hir::UnNot | hir::UnNeg => {\n-                        expected\n-                    }\n-                    hir::UnDeref => {\n-                        NoExpectation\n-                    }\n-                };\n-                let needs = match unop {\n-                    hir::UnDeref => needs,\n-                    _ => Needs::None\n-                };\n-                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                             expected_inner,\n-                                                                             needs);\n-\n-                if !oprnd_t.references_error() {\n-                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-                    match unop {\n-                        hir::UnDeref => {\n-                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                                oprnd_t = mt.ty;\n-                            } else if let Some(ok) = self.try_overloaded_deref(\n-                                    expr.span, oprnd_t, needs) {\n-                                let method = self.register_infer_ok_obligations(ok);\n-                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                                    let mutbl = match mutbl {\n-                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                            // (It shouldn't actually matter for unary ops whether\n-                                            // we enable two-phase borrows or not, since a unary\n-                                            // op has no additional operands.)\n-                                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                                        }\n-                                    };\n-                                    self.apply_adjustments(oprnd, vec![Adjustment {\n-                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                        target: method.sig.inputs()[0]\n-                                    }]);\n-                                }\n-                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                                self.write_method_call(expr.hir_id, method);\n-                            } else {\n-                                let mut err = type_error_struct!(\n-                                    tcx.sess,\n-                                    expr.span,\n-                                    oprnd_t,\n-                                    E0614,\n-                                    \"type `{}` cannot be dereferenced\",\n-                                    oprnd_t,\n-                                );\n-                                let sp = tcx.sess.source_map().start_point(expr.span);\n-                                if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n-                                    .borrow().get(&sp)\n-                                {\n-                                    tcx.sess.parse_sess.expr_parentheses_needed(\n-                                        &mut err,\n-                                        *sp,\n-                                        None,\n-                                    );\n-                                }\n-                                err.emit();\n-                                oprnd_t = tcx.types.err;\n-                            }\n-                        }\n-                        hir::UnNot => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                        hir::UnNeg => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !oprnd_t.is_numeric() {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                    }\n-                }\n-                oprnd_t\n-            }\n-            ExprKind::AddrOf(mutbl, ref oprnd) => {\n-                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-                    match ty.sty {\n-                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            if oprnd.is_place_expr() {\n-                                // Places may legitimately have unsized types.\n-                                // For example, dereferences of a fat pointer and\n-                                // the last field of a struct can be unsized.\n-                                ExpectHasType(ty)\n-                            } else {\n-                                Expectation::rvalue_hint(self, ty)\n-                            }\n-                        }\n-                        _ => NoExpectation\n-                    }\n-                });\n-                let needs = Needs::maybe_mut_place(mutbl);\n-                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n-\n-                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-                if tm.ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Note: at this point, we cannot say what the best lifetime\n-                    // is to use for resulting pointer.  We want to use the\n-                    // shortest lifetime possible so as to avoid spurious borrowck\n-                    // errors.  Moreover, the longest lifetime will depend on the\n-                    // precise details of the value whose address is being taken\n-                    // (and how long it is valid), which we don't know yet until type\n-                    // inference is complete.\n-                    //\n-                    // Therefore, here we simply generate a region variable.  The\n-                    // region inferencer will then select the ultimate value.\n-                    // Finally, borrowck is charged with guaranteeing that the\n-                    // value whose address was taken can actually be made to live\n-                    // as long as it needs to live.\n-                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                    tcx.mk_ref(region, tm)\n-                }\n-            }\n-            ExprKind::Path(ref qpath) => {\n-                let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n-                    expr.span);\n-                let ty = match res {\n-                    Res::Err => {\n-                        self.set_tainted_by_errors();\n-                        tcx.types.err\n-                    }\n-                    Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                        report_unexpected_variant_res(tcx, res, expr.span, qpath);\n-                        tcx.types.err\n-                    }\n-                    _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, id).0,\n-                };\n-\n-                if let ty::FnDef(..) = ty.sty {\n-                    let fn_sig = ty.fn_sig(tcx);\n-                    if !tcx.features().unsized_locals {\n-                        // We want to remove some Sized bounds from std functions,\n-                        // but don't want to expose the removal to stable Rust.\n-                        // i.e., we don't want to allow\n-                        //\n-                        // ```rust\n-                        // drop as fn(str);\n-                        // ```\n-                        //\n-                        // to work in stable even if the Sized bound on `drop` is relaxed.\n-                        for i in 0..fn_sig.inputs().skip_binder().len() {\n-                            // We just want to check sizedness, so instead of introducing\n-                            // placeholder lifetimes with probing, we just replace higher lifetimes\n-                            // with fresh vars.\n-                            let input = self.replace_bound_vars_with_fresh_vars(\n-                                expr.span,\n-                                infer::LateBoundRegionConversionTime::FnCall,\n-                                &fn_sig.input(i)).0;\n-                            self.require_type_is_sized_deferred(input, expr.span,\n-                                                                traits::SizedArgumentType);\n-                        }\n-                    }\n-                    // Here we want to prevent struct constructors from returning unsized types.\n-                    // There were two cases this happened: fn pointer coercion in stable\n-                    // and usual function call in presense of unsized_locals.\n-                    // Also, as we just want to check sizedness, instead of introducing\n-                    // placeholder lifetimes with probing, we just replace higher lifetimes\n-                    // with fresh vars.\n-                    let output = self.replace_bound_vars_with_fresh_vars(\n-                        expr.span,\n-                        infer::LateBoundRegionConversionTime::FnCall,\n-                        &fn_sig.output()).0;\n-                    self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n-                }\n-\n-                // We always require that the type provided as the value for\n-                // a type parameter outlives the moment of instantiation.\n-                let substs = self.tables.borrow().node_substs(expr.hir_id);\n-                self.add_wf_bounds(substs, expr);\n-\n-                ty\n-            }\n-            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                for expr in outputs.iter().chain(inputs.iter()) {\n-                    self.check_expr(expr);\n-                }\n-                tcx.mk_unit()\n-            }\n-            ExprKind::Break(destination, ref expr_opt) => {\n-                if let Ok(target_id) = destination.target_id {\n-                    let (e_ty, cause);\n-                    if let Some(ref e) = *expr_opt {\n-                        // If this is a break with a value, we need to type-check\n-                        // the expression. Get an expected type from the loop context.\n-                        let opt_coerce_to = {\n-                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                            enclosing_breakables.find_breakable(target_id)\n-                                                .coerce\n-                                                .as_ref()\n-                                                .map(|coerce| coerce.expected_ty())\n-                        };\n-\n-                        // If the loop context is not a `loop { }`, then break with\n-                        // a value is illegal, and `opt_coerce_to` will be `None`.\n-                        // Just set expectation to error in that case.\n-                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n-\n-                        // Recurse without `enclosing_breakables` borrowed.\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                    } else {\n-                        // Otherwise, this is a break *without* a value. That's\n-                        // always legal, and is equivalent to `break ()`.\n-                        e_ty = tcx.mk_unit();\n-                        cause = self.misc(expr.span);\n-                    }\n-\n-                    // Now that we have type-checked `expr_opt`, borrow\n-                    // the `enclosing_loops` field and let's coerce the\n-                    // type of `expr_opt` into what is expected.\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    let ctxt = enclosing_breakables.find_breakable(target_id);\n-                    if let Some(ref mut coerce) = ctxt.coerce {\n-                        if let Some(ref e) = *expr_opt {\n-                            coerce.coerce(self, &cause, e, e_ty);\n-                        } else {\n-                            assert!(e_ty.is_unit());\n-                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                        }\n-                    } else {\n-                        // If `ctxt.coerce` is `None`, we can just ignore\n-                        // the type of the expresison.  This is because\n-                        // either this was a break *without* a value, in\n-                        // which case it is always a legal type (`()`), or\n-                        // else an error would have been flagged by the\n-                        // `loops` pass for using break with an expression\n-                        // where you are not supposed to.\n-                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n-                    }\n-\n-                    ctxt.may_break = true;\n-\n-                    // the type of a `break` is always `!`, since it diverges\n-                    tcx.types.never\n-                } else {\n-                    // Otherwise, we failed to find the enclosing loop;\n-                    // this can only happen if the `break` was not\n-                    // inside a loop at all, which is caught by the\n-                    // loop-checking pass.\n-                    if self.tcx.sess.err_count() == 0 {\n-                        self.tcx.sess.delay_span_bug(expr.span,\n-                            \"break was outside loop, but no error was emitted\");\n-                    }\n-\n-                    // We still need to assign a type to the inner expression to\n-                    // prevent the ICE in #43162.\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr_with_hint(e, tcx.types.err);\n-\n-                        // ... except when we try to 'break rust;'.\n-                        // ICE this expression in particular (see #43162).\n-                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 &&\n-                               path.segments[0].ident.name == sym::rust {\n-                                fatally_break_rust(self.tcx.sess);\n-                            }\n-                        }\n-                    }\n-                    // There was an error; make type-check fail.\n-                    tcx.types.err\n-                }\n-\n-            }\n-            ExprKind::Continue(destination) => {\n-                if destination.target_id.is_ok() {\n-                    tcx.types.never\n-                } else {\n-                    // There was an error; make type-check fail.\n-                    tcx.types.err\n-                }\n-            }\n-            ExprKind::Ret(ref expr_opt) => {\n-                if self.ret_coercion.is_none() {\n-                    struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                     \"return statement outside of function body\").emit();\n-                } else if let Some(ref e) = *expr_opt {\n-                    if self.ret_coercion_span.borrow().is_none() {\n-                        *self.ret_coercion_span.borrow_mut() = Some(e.span);\n-                    }\n-                    self.check_return_expr(e);\n-                } else {\n-                    let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-                    if self.ret_coercion_span.borrow().is_none() {\n-                        *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n-                    }\n-                    let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n-                        coercion.coerce_forced_unit(\n-                            self,\n-                            &cause,\n-                            &mut |db| {\n-                                db.span_label(\n-                                    fn_decl.output.span(),\n-                                    format!(\n-                                        \"expected `{}` because of this return type\",\n-                                        fn_decl.output,\n-                                    ),\n-                                );\n-                            },\n-                            true,\n-                        );\n-                    } else {\n-                        coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                    }\n-                }\n-                tcx.types.never\n-            }\n-            ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.check_assign(expr, expected, lhs, rhs)\n-            }\n-            ExprKind::While(ref cond, ref body, _) => {\n-                let ctxt = BreakableCtxt {\n-                    // cannot use break with a value from a while loop\n-                    coerce: None,\n-                    may_break: false,  // Will get updated if/when we find a `break`.\n-                };\n-\n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-                    self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n-                    let cond_diverging = self.diverges.get();\n-                    self.check_block_no_value(&body);\n-\n-                    // We may never reach the body so it diverging means nothing.\n-                    self.diverges.set(cond_diverging);\n-                });\n-\n-                if ctxt.may_break {\n-                    // No way to know whether it's diverging because\n-                    // of a `break` or an outer `break` or `return`.\n-                    self.diverges.set(Diverges::Maybe);\n-                }\n-\n-                self.tcx.mk_unit()\n-            }\n-            ExprKind::Loop(ref body, _, source) => {\n-                let coerce = match source {\n-                    // you can only use break with a value from a normal `loop { }`\n-                    hir::LoopSource::Loop => {\n-                        let coerce_to = expected.coercion_target_type(self, body.span);\n-                        Some(CoerceMany::new(coerce_to))\n-                    }\n-\n-                    hir::LoopSource::WhileLet |\n-                    hir::LoopSource::ForLoop => {\n-                        None\n-                    }\n-                };\n-\n-                let ctxt = BreakableCtxt {\n-                    coerce,\n-                    may_break: false, // Will get updated if/when we find a `break`.\n-                };\n-\n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-                    self.check_block_no_value(&body);\n-                });\n-\n-                if ctxt.may_break {\n-                    // No way to know whether it's diverging because\n-                    // of a `break` or an outer `break` or `return`.\n-                    self.diverges.set(Diverges::Maybe);\n-                }\n-\n-                // If we permit break with a value, then result type is\n-                // the LUB of the breaks (possibly ! if none); else, it\n-                // is nil. This makes sense because infinite loops\n-                // (which would have type !) are only possible iff we\n-                // permit break with a value [1].\n-                if ctxt.coerce.is_none() && !ctxt.may_break {\n-                    // [1]\n-                    self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n-                }\n-                ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n-            }\n-            ExprKind::Match(ref discrim, ref arms, match_src) => {\n-                self.check_match(expr, &discrim, arms, expected, match_src)\n-            }\n-            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n-                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n-            }\n-            ExprKind::Block(ref body, _) => {\n-                self.check_block_with_expected(&body, expected)\n-            }\n-            ExprKind::Call(ref callee, ref args) => {\n-                self.check_call(expr, &callee, args, expected)\n-            }\n-            ExprKind::MethodCall(ref segment, span, ref args) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n-            }\n-            ExprKind::Cast(ref e, ref t) => {\n-                // Find the type of `e`. Supply hints based on the type we are casting to,\n-                // if appropriate.\n-                let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-\n-                // Eagerly check for some obvious errors.\n-                if t_expr.references_error() || t_cast.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Defer other checks until we're done type checking.\n-                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n-                        Ok(cast_check) => {\n-                            deferred_cast_checks.push(cast_check);\n-                            t_cast\n-                        }\n-                        Err(ErrorReported) => {\n-                            tcx.types.err\n-                        }\n-                    }\n-                }\n-            }\n-            ExprKind::Type(ref e, ref t) => {\n-                let ty = self.to_ty_saving_user_provided_ty(&t);\n-                self.check_expr_eq_type(&e, ty);\n-                ty\n-            }\n-            ExprKind::DropTemps(ref e) => {\n-                self.check_expr_with_expectation(e, expected)\n-            }\n-            ExprKind::Array(ref args) => {\n-                let uty = expected.to_option(self).and_then(|uty| {\n-                    match uty.sty {\n-                        ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n-                        _ => None\n-                    }\n-                });\n-\n-                let element_ty = if !args.is_empty() {\n-                    let coerce_to = uty.unwrap_or_else(|| {\n-                        self.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: expr.span,\n-                        })\n-                    });\n-                    let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n-                    assert_eq!(self.diverges.get(), Diverges::Maybe);\n-                    for e in args {\n-                        let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        let cause = self.misc(e.span);\n-                        coerce.coerce(self, &cause, e, e_ty);\n-                    }\n-                    coerce.complete(self)\n-                } else {\n-                    self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span: expr.span,\n-                    })\n-                };\n-                tcx.mk_array(element_ty, args.len() as u64)\n-            }\n-            ExprKind::Repeat(ref element, ref count) => {\n-                let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n-                let count = if self.const_param_def_id(count).is_some() {\n-                    Ok(self.to_const(count, self.tcx.type_of(count_def_id)))\n-                } else {\n-                    let param_env = ty::ParamEnv::empty();\n-                    let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n-                    let instance = ty::Instance::resolve(\n-                        tcx.global_tcx(),\n-                        param_env,\n-                        count_def_id,\n-                        substs,\n-                    ).unwrap();\n-                    let global_id = GlobalId {\n-                        instance,\n-                        promoted: None\n-                    };\n-\n-                    tcx.const_eval(param_env.and(global_id))\n-                };\n-\n-                let uty = match expected {\n-                    ExpectHasType(uty) => {\n-                        match uty.sty {\n-                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n-                            _ => None\n-                        }\n-                    }\n-                    _ => None\n-                };\n-\n-                let (element_ty, t) = match uty {\n-                    Some(uty) => {\n-                        self.check_expr_coercable_to_type(&element, uty);\n-                        (uty, uty)\n-                    }\n-                    None => {\n-                        let ty = self.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: element.span,\n-                        });\n-                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n-                        (element_ty, ty)\n-                    }\n-                };\n-\n-                if let Ok(count) = count {\n-                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-                    if !zero_or_one {\n-                        // For [foo, ..n] where n > 1, `foo` must have\n-                        // Copy type:\n-                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n-                    }\n-                }\n-\n-                if element_ty.references_error() {\n-                    tcx.types.err\n-                } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, count))\n-                } else {\n-                    tcx.types.err\n-                }\n-            }\n-            ExprKind::Tup(ref elts) => {\n-                let flds = expected.only_has_type(self).and_then(|ty| {\n-                    let ty = self.resolve_type_vars_with_obligations(ty);\n-                    match ty.sty {\n-                        ty::Tuple(ref flds) => Some(&flds[..]),\n-                        _ => None\n-                    }\n-                });\n-\n-                let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n-                    let t = match flds {\n-                        Some(ref fs) if i < fs.len() => {\n-                            let ety = fs[i].expect_ty();\n-                            self.check_expr_coercable_to_type(&e, ety);\n-                            ety\n-                        }\n-                        _ => {\n-                            self.check_expr_with_expectation(&e, NoExpectation)\n-                        }\n-                    };\n-                    t\n-                });\n-                let tuple = tcx.mk_tup(elt_ts_iter);\n-                if tuple.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n-                    tuple\n-                }\n-            }\n-            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n-                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n-            }\n-            ExprKind::Field(ref base, field) => {\n-                self.check_field(expr, needs, &base, field)\n-            }\n-            ExprKind::Index(ref base, ref idx) => {\n-                let base_t = self.check_expr_with_needs(&base, needs);\n-                let idx_t = self.check_expr(&idx);\n-\n-                if base_t.references_error() {\n-                    base_t\n-                } else if idx_t.references_error() {\n-                    idx_t\n-                } else {\n-                    let base_t = self.structurally_resolved_type(base.span, base_t);\n-                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n-                        Some((index_ty, element_ty)) => {\n-                            // two-phase not needed because index_ty is never mutable\n-                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n-                            element_ty\n-                        }\n-                        None => {\n-                            let mut err =\n-                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n-                                                   \"cannot index into a value of type `{}`\",\n-                                                   base_t);\n-                            // Try to give some advice about indexing tuples.\n-                            if let ty::Tuple(..) = base_t.sty {\n-                                let mut needs_note = true;\n-                                // If the index is an integer, we can show the actual\n-                                // fixed expression:\n-                                if let ExprKind::Lit(ref lit) = idx.node {\n-                                    if let ast::LitKind::Int(i,\n-                                            ast::LitIntType::Unsuffixed) = lit.node {\n-                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n-                                        if let Ok(snip) = snip {\n-                                            err.span_suggestion(\n-                                                expr.span,\n-                                                \"to access tuple elements, use\",\n-                                                format!(\"{}.{}\", snip, i),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                            needs_note = false;\n-                                        }\n-                                    }\n-                                }\n-                                if needs_note {\n-                                    err.help(\"to access tuple elements, use tuple indexing \\\n-                                              syntax (e.g., `tuple.0`)\");\n-                                }\n-                            }\n-                            err.emit();\n-                            self.tcx.types.err\n-                        }\n-                    }\n-                }\n-            }\n-            ExprKind::Yield(ref value) => {\n-                match self.yield_ty {\n-                    Some(ty) => {\n-                        self.check_expr_coercable_to_type(&value, ty);\n-                    }\n-                    None => {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                         \"yield statement outside of generator literal\").emit();\n-                    }\n-                }\n-                tcx.mk_unit()\n-            }\n-            hir::ExprKind::Err => {\n-                tcx.types.err\n-            }\n-        }\n-    }\n-\n     /// Type check assignment expression `expr` of form `lhs = rhs`.\n     /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n     fn check_assign("}]}