{"sha": "d04ab9e5ba46b21a49027ce38dc913b4617125ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwNGFiOWU1YmE0NmIyMWE0OTAyN2NlMzhkYzkxM2I0NjE3MTI1YmE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-04T23:41:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-04T23:41:52Z"}, "message": "Merge pull request #1630 from topecongiro/issue-1115\n\nAllow comments after attributes on enum fields", "tree": {"sha": "4ee15ca6f5efd760e89eea1dbfa721b87255bb75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ee15ca6f5efd760e89eea1dbfa721b87255bb75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d04ab9e5ba46b21a49027ce38dc913b4617125ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d04ab9e5ba46b21a49027ce38dc913b4617125ba", "html_url": "https://github.com/rust-lang/rust/commit/d04ab9e5ba46b21a49027ce38dc913b4617125ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d04ab9e5ba46b21a49027ce38dc913b4617125ba/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a1ea819325a2f62cc35252cab2712975f6cd86", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a1ea819325a2f62cc35252cab2712975f6cd86", "html_url": "https://github.com/rust-lang/rust/commit/14a1ea819325a2f62cc35252cab2712975f6cd86"}, {"sha": "d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7de5b7656dcdca403b3560c7c9c2ebb335f8567", "html_url": "https://github.com/rust-lang/rust/commit/d7de5b7656dcdca403b3560c7c9c2ebb335f8567"}], "stats": {"total": 98, "additions": 74, "deletions": 24}, "files": [{"sha": "fdcf96454c758142b870cbdc50c70f5ede386098", "filename": "src/items.rs", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d04ab9e5ba46b21a49027ce38dc913b4617125ba/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04ab9e5ba46b21a49027ce38dc913b4617125ba/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d04ab9e5ba46b21a49027ce38dc913b4617125ba", "patch": "@@ -456,15 +456,30 @@ impl<'a> FmtVisitor<'a> {\n             return Some(self.snippet(span));\n         }\n \n+        let context = self.get_context();\n         let indent = self.block_indent;\n-        let mut result = try_opt!(field.node.attrs.rewrite(&self.get_context(),\n-                                                           Shape::indented(indent, self.config)));\n+        let mut result = try_opt!(field\n+                                      .node\n+                                      .attrs\n+                                      .rewrite(&context, Shape::indented(indent, self.config)));\n         if !result.is_empty() {\n-            result.push('\\n');\n-            result.push_str(&indent.to_string(self.config));\n+            let shape = Shape {\n+                width: context.config.max_width(),\n+                indent: self.block_indent,\n+                offset: self.block_indent.alignment,\n+            };\n+            let missing_comment =\n+                rewrite_missing_comment_on_field(&context,\n+                                                 shape,\n+                                                 field.node.attrs[field.node.attrs.len() - 1]\n+                                                     .span\n+                                                     .hi,\n+                                                 field.span.lo,\n+                                                 &mut result)\n+                    .unwrap_or(String::new());\n+            result.push_str(&missing_comment);\n         }\n \n-        let context = self.get_context();\n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) |\n             ast::VariantData::Struct(..) => {\n@@ -1194,6 +1209,31 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n      })\n }\n \n+fn rewrite_missing_comment_on_field(context: &RewriteContext,\n+                                    shape: Shape,\n+                                    lo: BytePos,\n+                                    hi: BytePos,\n+                                    result: &mut String)\n+                                    -> Option<String> {\n+    let possibly_comment_snippet = context.snippet(mk_sp(lo, hi));\n+    let newline_index = possibly_comment_snippet.find('\\n');\n+    let comment_index = possibly_comment_snippet.find('/');\n+    match (newline_index, comment_index) {\n+        (Some(i), Some(j)) if i > j => result.push(' '),\n+        _ => {\n+            result.push('\\n');\n+            result.push_str(&shape.indent.to_string(context.config));\n+        }\n+    }\n+    let trimmed = possibly_comment_snippet.trim();\n+    if trimmed.is_empty() {\n+        None\n+    } else {\n+        rewrite_comment(trimmed, false, shape, context.config)\n+            .map(|s| format!(\"{}\\n{}\", s, shape.indent.to_string(context.config)))\n+    }\n+}\n+\n impl Rewrite for ast::StructField {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if contains_skip(&self.attrs) {\n@@ -1208,25 +1248,12 @@ impl Rewrite for ast::StructField {\n                                                                        context.config)));\n         // Try format missing comments after attributes\n         let missing_comment = if !self.attrs.is_empty() {\n-            let possibly_comment_snippet =\n-                context.snippet(mk_sp(self.attrs[self.attrs.len() - 1].span.hi, self.span.lo));\n-            let newline_index = possibly_comment_snippet.find('\\n');\n-            let comment_index = possibly_comment_snippet.find('/');\n-            match (newline_index, comment_index) {\n-                (Some(i), Some(j)) if i > j => attr_str.push(' '),\n-                _ => {\n-                    attr_str.push('\\n');\n-                    attr_str.push_str(&shape.indent.to_string(context.config));\n-                }\n-            }\n-            let trimmed = possibly_comment_snippet.trim();\n-            if trimmed.is_empty() {\n-                String::new()\n-            } else {\n-                rewrite_comment(trimmed, false, shape, context.config).map_or(String::new(), |s| {\n-                    format!(\"{}\\n{}\", s, shape.indent.to_string(context.config))\n-                })\n-            }\n+            rewrite_missing_comment_on_field(context,\n+                                             shape,\n+                                             self.attrs[self.attrs.len() - 1].span.hi,\n+                                             self.span.lo,\n+                                             &mut attr_str)\n+                .unwrap_or(String::new())\n         } else {\n             String::new()\n         };"}, {"sha": "0e2e2c066c3b05a76b85087bebe2cb43c1e5e5a7", "filename": "tests/source/enum.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d04ab9e5ba46b21a49027ce38dc913b4617125ba/tests%2Fsource%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04ab9e5ba46b21a49027ce38dc913b4617125ba/tests%2Fsource%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fenum.rs?ref=d04ab9e5ba46b21a49027ce38dc913b4617125ba", "patch": "@@ -98,3 +98,14 @@ fn nested_enum_test() {\n    pub  struct  EmtpyWithComment {\n     // FIXME: Implement this struct\n }\n+\n+// #1115\n+pub enum Bencoding<'i> {\n+    Str(&'i [u8]),\n+    Int(i64),\n+    List(Vec<Bencoding<'i>>),\n+    /// A bencoded dict value. The first element the slice of bytes in the source that the dict is\n+    /// composed of. The second is the dict, decoded into an ordered map.\n+    // TODO make Dict \"structlike\" AKA name the two values.\n+    Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),\n+}"}, {"sha": "3e0e46d3fae97950b9014ebfaae60d493b617040", "filename": "tests/target/enum.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d04ab9e5ba46b21a49027ce38dc913b4617125ba/tests%2Ftarget%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d04ab9e5ba46b21a49027ce38dc913b4617125ba/tests%2Ftarget%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fenum.rs?ref=d04ab9e5ba46b21a49027ce38dc913b4617125ba", "patch": "@@ -127,3 +127,15 @@ fn nested_enum_test() {\n pub struct EmtpyWithComment {\n     // FIXME: Implement this struct\n }\n+\n+// #1115\n+pub enum Bencoding<'i> {\n+    Str(&'i [u8]),\n+    Int(i64),\n+    List(Vec<Bencoding<'i>>),\n+    /// A bencoded dict value. The first element the slice of bytes in the\n+    /// source that the dict is\n+    /// composed of. The second is the dict, decoded into an ordered map.\n+    // TODO make Dict \"structlike\" AKA name the two values.\n+    Dict(&'i [u8], BTreeMap<&'i [u8], Bencoding<'i>>),\n+}"}]}