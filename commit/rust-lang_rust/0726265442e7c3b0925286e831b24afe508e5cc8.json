{"sha": "0726265442e7c3b0925286e831b24afe508e5cc8", "node_id": "C_kwDOAAsO6NoAKDA3MjYyNjU0NDJlN2MzYjA5MjUyODZlODMxYjI0YWZlNTA4ZTVjYzg", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-06-30T14:54:10Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-09-13T15:44:49Z"}, "message": "cranelift changes", "tree": {"sha": "1482f5c110cb504e5b4a4ae4705d9c483f1d825a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1482f5c110cb504e5b4a4ae4705d9c483f1d825a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0726265442e7c3b0925286e831b24afe508e5cc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0726265442e7c3b0925286e831b24afe508e5cc8", "html_url": "https://github.com/rust-lang/rust/commit/0726265442e7c3b0925286e831b24afe508e5cc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0726265442e7c3b0925286e831b24afe508e5cc8/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7735cd329da6f9a75c15bb86e5789925c860f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7735cd329da6f9a75c15bb86e5789925c860f31", "html_url": "https://github.com/rust-lang/rust/commit/a7735cd329da6f9a75c15bb86e5789925c860f31"}], "stats": {"total": 108, "additions": 59, "deletions": 49}, "files": [{"sha": "a04b38ae33f375c14adfc310154e14aae54e1757", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0726265442e7c3b0925286e831b24afe508e5cc8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0726265442e7c3b0925286e831b24afe508e5cc8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=0726265442e7c3b0925286e831b24afe508e5cc8", "patch": "@@ -41,36 +41,30 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let const_ = match fx.monomorphize(constant.literal) {\n-            ConstantKind::Ty(ct) => ct,\n+        let unevaluated = match fx.monomorphize(constant.literal) {\n+            ConstantKind::Ty(ct) => match ct.kind() {\n+                ConstKind::Unevaluated(uv) => uv.expand(),\n+                ConstKind::Value(_) => continue,\n+                ConstKind::Param(_)\n+                | ConstKind::Infer(_)\n+                | ConstKind::Bound(_, _)\n+                | ConstKind::Placeholder(_)\n+                | ConstKind::Error(_) => unreachable!(\"{:?}\", ct),\n+            },\n+            ConstantKind::Unevaluated(uv, _) => uv,\n             ConstantKind::Val(..) => continue,\n         };\n-        match const_.kind() {\n-            ConstKind::Value(_) => {}\n-            ConstKind::Unevaluated(unevaluated) => {\n-                if let Err(err) =\n-                    fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None)\n-                {\n-                    all_constants_ok = false;\n-                    match err {\n-                        ErrorHandled::Reported(_) | ErrorHandled::Linted => {\n-                            fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n-                        }\n-                        ErrorHandled::TooGeneric => {\n-                            span_bug!(\n-                                constant.span,\n-                                \"codegen encountered polymorphic constant: {:?}\",\n-                                err\n-                            );\n-                        }\n-                    }\n+\n+        if let Err(err) = fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n+            all_constants_ok = false;\n+            match err {\n+                ErrorHandled::Reported(_) | ErrorHandled::Linted => {\n+                    fx.tcx.sess.span_err(constant.span, \"erroneous constant encountered\");\n+                }\n+                ErrorHandled::TooGeneric => {\n+                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n                 }\n             }\n-            ConstKind::Param(_)\n-            | ConstKind::Infer(_)\n-            | ConstKind::Bound(_, _)\n-            | ConstKind::Placeholder(_)\n-            | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n         }\n     }\n     all_constants_ok\n@@ -122,43 +116,56 @@ pub(crate) fn codegen_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = match fx.monomorphize(constant.literal) {\n-        ConstantKind::Ty(ct) => ct,\n-        ConstantKind::Unevaluated(mir::Unevaluated { def, substs, promoted })\n+    let (const_val, ty) = match fx.monomorphize(constant.literal) {\n+        ConstantKind::Ty(const_) => match const_.kind() {\n+            ConstKind::Value(valtree) => {\n+                (fx.tcx.valtree_to_const_val((const_.ty(), valtree)), const_.ty())\n+            }\n+            ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n+                if fx.tcx.is_static(def.did) =>\n+            {\n+                assert!(substs.is_empty());\n+                assert_eq!(promoted, ());\n+                return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty())).to_cvalue(fx);\n+            }\n+            ConstKind::Unevaluated(unevaluated) => {\n+                match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated.expand(), None)\n+                {\n+                    Ok(const_val) => (const_val, const_.ty()),\n+                    Err(_) => {\n+                        span_bug!(\n+                            constant.span,\n+                            \"erroneous constant not captured by required_consts\"\n+                        );\n+                    }\n+                }\n+            }\n+            ConstKind::Param(_)\n+            | ConstKind::Infer(_)\n+            | ConstKind::Bound(_, _)\n+            | ConstKind::Placeholder(_)\n+            | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+        },\n+        ConstantKind::Unevaluated(ty::Unevaluated { def, substs, promoted }, ty)\n             if fx.tcx.is_static(def.did) =>\n         {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty())).to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(ty)).to_cvalue(fx);\n         }\n-        ConstantKind::Unevaluated(unevaluated) => {\n+        ConstantKind::Unevaluated(unevaluated, ty) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n-                Ok(const_val) => const_val,\n+                Ok(const_val) => (const_val, ty),\n                 Err(_) => {\n                     span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n                 }\n             }\n         }\n-        ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n-    };\n-    let const_val = match const_.kind() {\n-        ConstKind::Value(valtree) => fx.tcx.valtree_to_const_val((const_.ty(), valtree)),\n-        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-            if fx.tcx.is_static(def.did) =>\n-        {\n-            assert!(substs.is_empty());\n-            assert!(promoted.is_none());\n-            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty())).to_cvalue(fx);\n-        }\n-        ConstKind::Param(_)\n-        | ConstKind::Infer(_)\n-        | ConstKind::Bound(_, _)\n-        | ConstKind::Placeholder(_)\n-        | ConstKind::Error(_) => unreachable!(\"{:?}\", const_),\n+        ConstantKind::Val(val, ty) => (val, ty),\n     };\n \n-    codegen_const_value(fx, const_val, const_.ty())\n+    codegen_const_value(fx, const_val, ty)\n }\n \n pub(crate) fn codegen_const_value<'tcx>(\n@@ -503,6 +510,9 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                 .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n                 .try_to_value(fx.tcx),\n             ConstantKind::Val(val, _) => Some(val),\n+            ConstantKind::Unevaluated(uv, _) => {\n+                fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).ok()\n+            }\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored\n         // inside a temporary before being passed to the intrinsic requiring the const argument."}]}