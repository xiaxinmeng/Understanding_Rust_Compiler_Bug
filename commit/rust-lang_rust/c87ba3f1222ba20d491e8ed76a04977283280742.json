{"sha": "c87ba3f1222ba20d491e8ed76a04977283280742", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4N2JhM2YxMjIyYmEyMGQ0OTFlOGVkNzZhMDQ5NzcyODMyODA3NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-13T11:57:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-13T11:57:23Z"}, "message": "Auto merge of #36264 - matklad:zeroing-cstring, r=alexcrichton\n\nZero first byte of CString on drop\n\nHi! This is one more attempt to ameliorate `CString::new(\"...\").unwrap().as_ptr()` problem (related RFC: https://github.com/rust-lang/rfcs/pull/1642).\n\nOne of the biggest problems with this code is that it may actually work in practice, so the idea of this PR is to proactively break such invalid code.\n\nLooks like writing a `null` byte at the start of the CString should do the trick, and I think is an affordable cost: zeroing a single byte in `Drop` should be cheap enough compared to actual memory deallocation which would follow.\n\nI would actually prefer to do something like\n\n```Rust\nimpl Drop for CString {\n    fn drop(&mut self) {\n        let pattern = b\"CTHULHU FHTAGN \";\n        let bytes = self.inner[..self.inner.len() - 1];\n        for (d, s) in bytes.iter_mut().zip(pattern.iter().cycle()) {\n            *d = *s;\n        }\n    }\n}\n```\n\nbecause Cthulhu error should be much easier to google, but unfortunately this would be too expensive in release builds, and we can't implement things `cfg(debug_assertions)` conditionally in stdlib.\n\nNot sure if the whole idea or my implementation (I've used ~~`transmute`~~ `mem::unitialized` to workaround move out of Drop thing) makes sense :)", "tree": {"sha": "3cca884f97cefdb31fd3d31fd9e014a01b709079", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cca884f97cefdb31fd3d31fd9e014a01b709079"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c87ba3f1222ba20d491e8ed76a04977283280742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c87ba3f1222ba20d491e8ed76a04977283280742", "html_url": "https://github.com/rust-lang/rust/commit/c87ba3f1222ba20d491e8ed76a04977283280742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c87ba3f1222ba20d491e8ed76a04977283280742/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58450c047ec3f09700e58b985c4776e34abf3f1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/58450c047ec3f09700e58b985c4776e34abf3f1e", "html_url": "https://github.com/rust-lang/rust/commit/58450c047ec3f09700e58b985c4776e34abf3f1e"}, {"sha": "f9a340804c998f25691be182fc8bc40b8fc9a496", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9a340804c998f25691be182fc8bc40b8fc9a496", "html_url": "https://github.com/rust-lang/rust/commit/f9a340804c998f25691be182fc8bc40b8fc9a496"}], "stats": {"total": 77, "additions": 74, "deletions": 3}, "files": [{"sha": "2d5e8c041940293a670caa2d1e55ae5d4d304704", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c87ba3f1222ba20d491e8ed76a04977283280742/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87ba3f1222ba20d491e8ed76a04977283280742/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=c87ba3f1222ba20d491e8ed76a04977283280742", "patch": "@@ -19,6 +19,7 @@ use mem;\n use memchr;\n use ops;\n use os::raw::c_char;\n+use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n@@ -68,6 +69,9 @@ use str::{self, Utf8Error};\n #[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CString {\n+    // Invariant 1: the slice ends with a zero byte and has a length of at least one.\n+    // Invariant 2: the slice contains only one zero byte.\n+    // Improper usage of unsafe function can break Invariant 2, but not Invariant 1.\n     inner: Box<[u8]>,\n }\n \n@@ -244,7 +248,7 @@ impl CString {\n     /// Failure to call `from_raw` will lead to a memory leak.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub fn into_raw(self) -> *mut c_char {\n-        Box::into_raw(self.inner) as *mut c_char\n+        Box::into_raw(self.into_inner()) as *mut c_char\n     }\n \n     /// Converts the `CString` into a `String` if it contains valid Unicode data.\n@@ -265,7 +269,7 @@ impl CString {\n     /// it is guaranteed to not have any interior nul bytes.\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n-        let mut vec = self.inner.into_vec();\n+        let mut vec = self.into_inner().into_vec();\n         let _nul = vec.pop();\n         debug_assert_eq!(_nul, Some(0u8));\n         vec\n@@ -275,7 +279,7 @@ impl CString {\n     /// includes the trailing nul byte.\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes_with_nul(self) -> Vec<u8> {\n-        self.inner.into_vec()\n+        self.into_inner().into_vec()\n     }\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n@@ -293,6 +297,24 @@ impl CString {\n     pub fn as_bytes_with_nul(&self) -> &[u8] {\n         &self.inner\n     }\n+\n+    // Bypass \"move out of struct which implements `Drop` trait\" restriction.\n+    fn into_inner(self) -> Box<[u8]> {\n+        unsafe {\n+            let result = ptr::read(&self.inner);\n+            mem::forget(self);\n+            result\n+        }\n+    }\n+}\n+\n+// Turns this `CString` into an empty string to prevent\n+// memory unsafe code from working by accident.\n+#[stable(feature = \"cstring_drop\", since = \"1.13.0\")]\n+impl Drop for CString {\n+    fn drop(&mut self) {\n+        unsafe { *self.inner.get_unchecked_mut(0) = 0; }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "960391bb8deac7a788692d89de0325b9f6538b64", "filename": "src/test/run-pass/cstring-drop.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c87ba3f1222ba20d491e8ed76a04977283280742/src%2Ftest%2Frun-pass%2Fcstring-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87ba3f1222ba20d491e8ed76a04977283280742/src%2Ftest%2Frun-pass%2Fcstring-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcstring-drop.rs?ref=c87ba3f1222ba20d491e8ed76a04977283280742", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// Test that `CString::new(\"hello\").unwrap().as_ptr()` pattern\n+// leads to failure.\n+\n+use std::env;\n+use std::ffi::{CString, CStr};\n+use std::os::raw::c_char;\n+use std::process::{Command, Stdio};\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() > 1 && args[1] == \"child\" {\n+        // Repeat several times to be more confident that\n+        // it is `Drop` for `CString` that does the cleanup,\n+        // and not just some lucky UB.\n+        let xs = vec![CString::new(\"Hello\").unwrap(); 10];\n+        let ys = xs.iter().map(|s| s.as_ptr()).collect::<Vec<_>>();\n+        drop(xs);\n+        assert!(ys.into_iter().any(is_hello));\n+        return;\n+    }\n+\n+    let output = Command::new(&args[0]).arg(\"child\").output().unwrap();\n+    assert!(!output.status.success());\n+}\n+\n+fn is_hello(s: *const c_char) -> bool {\n+    // `s` is a dangling pointer and reading it is technically\n+    // undefined behavior. But we want to prevent the most diabolical\n+    // kind of UB (apart from nasal demons): reading a value that was\n+    // previously written.\n+    //\n+    // Segfaulting or reading an empty string is Ok,\n+    // reading \"Hello\" is bad.\n+    let s = unsafe { CStr::from_ptr(s) };\n+    let hello = CString::new(\"Hello\").unwrap();\n+    s == hello.as_ref()\n+}"}]}