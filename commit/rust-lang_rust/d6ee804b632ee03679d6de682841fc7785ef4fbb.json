{"sha": "d6ee804b632ee03679d6de682841fc7785ef4fbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZWU4MDRiNjMyZWUwMzY3OWQ2ZGU2ODI4NDFmYzc3ODVlZjRmYmI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-03T18:26:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-11-21T21:18:08Z"}, "message": "unicode: Convert UnicodeChar methods to by-value\n\nExtension traits for primitive types should be by-value.\n\n[breaking-change]", "tree": {"sha": "c90b5756184c6bf3dcf66c10ae56dd1ea0e95b3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c90b5756184c6bf3dcf66c10ae56dd1ea0e95b3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ee804b632ee03679d6de682841fc7785ef4fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ee804b632ee03679d6de682841fc7785ef4fbb", "html_url": "https://github.com/rust-lang/rust/commit/d6ee804b632ee03679d6de682841fc7785ef4fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ee804b632ee03679d6de682841fc7785ef4fbb/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aad246160451aacc2f7a707c028bdf44e77ad38d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aad246160451aacc2f7a707c028bdf44e77ad38d", "html_url": "https://github.com/rust-lang/rust/commit/aad246160451aacc2f7a707c028bdf44e77ad38d"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "1e81916a2c6e0bb221faee3cb2298e7b40c969ae", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6ee804b632ee03679d6de682841fc7785ef4fbb/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ee804b632ee03679d6de682841fc7785ef4fbb/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=d6ee804b632ee03679d6de682841fc7785ef4fbb", "patch": "@@ -166,7 +166,7 @@ pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n pub trait UnicodeChar {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n-    fn is_alphabetic(&self) -> bool;\n+    fn is_alphabetic(self) -> bool;\n \n     /// Returns whether the specified character satisfies the 'XID_Start'\n     /// Unicode property.\n@@ -175,7 +175,7 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_start(&self) -> bool;\n+    fn is_XID_start(self) -> bool;\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n     /// Unicode property.\n@@ -184,40 +184,40 @@ pub trait UnicodeChar {\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n     #[allow(non_snake_case)]\n-    fn is_XID_continue(&self) -> bool;\n+    fn is_XID_continue(self) -> bool;\n \n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n-    fn is_lowercase(&self) -> bool;\n+    fn is_lowercase(self) -> bool;\n \n     /// Indicates whether a character is in uppercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n-    fn is_uppercase(&self) -> bool;\n+    fn is_uppercase(self) -> bool;\n \n     /// Indicates whether a character is whitespace.\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n-    fn is_whitespace(&self) -> bool;\n+    fn is_whitespace(self) -> bool;\n \n     /// Indicates whether a character is alphanumeric.\n     ///\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-    fn is_alphanumeric(&self) -> bool;\n+    fn is_alphanumeric(self) -> bool;\n \n     /// Indicates whether a character is a control code point.\n     ///\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n-    fn is_control(&self) -> bool;\n+    fn is_control(self) -> bool;\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n-    fn is_numeric(&self) -> bool;\n+    fn is_numeric(self) -> bool;\n \n     /// Converts a character to its lowercase equivalent.\n     ///\n@@ -228,7 +228,7 @@ pub trait UnicodeChar {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    fn to_lowercase(&self) -> char;\n+    fn to_lowercase(self) -> char;\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n@@ -250,7 +250,7 @@ pub trait UnicodeChar {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    fn to_uppercase(&self) -> char;\n+    fn to_uppercase(self) -> char;\n \n     /// Returns this character's displayed width in columns, or `None` if it is a\n     /// control character other than `'\\x00'`.\n@@ -261,31 +261,33 @@ pub trait UnicodeChar {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    fn width(&self, is_cjk: bool) -> Option<uint>;\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n impl UnicodeChar for char {\n-    fn is_alphabetic(&self) -> bool { is_alphabetic(*self) }\n+    fn is_alphabetic(self) -> bool { is_alphabetic(self) }\n \n-    fn is_XID_start(&self) -> bool { is_XID_start(*self) }\n+    fn is_XID_start(self) -> bool { is_XID_start(self) }\n \n-    fn is_XID_continue(&self) -> bool { is_XID_continue(*self) }\n+    fn is_XID_continue(self) -> bool { is_XID_continue(self) }\n \n-    fn is_lowercase(&self) -> bool { is_lowercase(*self) }\n+    fn is_lowercase(self) -> bool { is_lowercase(self) }\n \n-    fn is_uppercase(&self) -> bool { is_uppercase(*self) }\n+    fn is_uppercase(self) -> bool { is_uppercase(self) }\n \n-    fn is_whitespace(&self) -> bool { is_whitespace(*self) }\n+    fn is_whitespace(self) -> bool { is_whitespace(self) }\n \n-    fn is_alphanumeric(&self) -> bool { is_alphanumeric(*self) }\n+    fn is_alphanumeric(self) -> bool { is_alphanumeric(self) }\n \n-    fn is_control(&self) -> bool { is_control(*self) }\n+    fn is_control(self) -> bool { is_control(self) }\n \n-    fn is_numeric(&self) -> bool { is_digit(*self) }\n+    fn is_numeric(self) -> bool { is_digit(self) }\n \n-    fn to_lowercase(&self) -> char { to_lowercase(*self) }\n+    fn to_lowercase(self) -> char { to_lowercase(self) }\n \n-    fn to_uppercase(&self) -> char { to_uppercase(*self) }\n+    fn to_uppercase(self) -> char { to_uppercase(self) }\n \n-    fn width(&self, is_cjk: bool) -> Option<uint> { width(*self, is_cjk) }\n+    #[experimental = \"needs expert opinion. is_cjk flag stands out as ugly\"]\n+    fn width(self, is_cjk: bool) -> Option<uint> { width(self, is_cjk) }\n }"}]}