{"sha": "0aa1aaa2c1d095365e341017e443d61a960e0af6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYTFhYWEyYzFkMDk1MzY1ZTM0MTAxN2U0NDNkNjFhOTYwZTBhZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T04:26:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-21T04:26:32Z"}, "message": "auto merge of #5058 : Thiez/rust/incoming, r=catamorphism\n\nI've moved all intrinsics in a single file (libcore/private/intrinsics.rs) and changed a few files to make use of this file (e.g. vec.rs: move_val_init).\r\n\r\nTwo intrinsics have been commented out:\r\nvisit_tydesc: it uses TyDesc and TyVisitor, this would create a dependency on librustc which seems undesirable.\r\nframe_address: I really had no idea what it should look like without the legacy modes (would it even work? In several places in libcore the (legacy-modes) intrinsics were wrapped\r\nwith a normal fn) and what it was supposed to do.\r\n\r\nSome documentation is still required, but many names are fairly self-explanatory.", "tree": {"sha": "efe137545e83fe0b69d4c4c9ccc0b6e1ccfe5dea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efe137545e83fe0b69d4c4c9ccc0b6e1ccfe5dea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aa1aaa2c1d095365e341017e443d61a960e0af6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aa1aaa2c1d095365e341017e443d61a960e0af6", "html_url": "https://github.com/rust-lang/rust/commit/0aa1aaa2c1d095365e341017e443d61a960e0af6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aa1aaa2c1d095365e341017e443d61a960e0af6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc", "html_url": "https://github.com/rust-lang/rust/commit/a307608781027d8c1b4c99bf1a8ac2c0d960a1bc"}, {"sha": "9776c387319f4078fb748c5f365b713d603bfc4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9776c387319f4078fb748c5f365b713d603bfc4f", "html_url": "https://github.com/rust-lang/rust/commit/9776c387319f4078fb748c5f365b713d603bfc4f"}], "stats": {"total": 261, "additions": 171, "deletions": 90}, "files": [{"sha": "beda48d2dfb20d293ddd4bbfe259102a96e0413e", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -30,11 +30,6 @@ pub extern mod rustrt {\n                                             ++n: libc::size_t);\n }\n \n-#[abi = \"rust-intrinsic\"]\n-pub extern mod rusti {\n-    pub fn move_val_init<T>(dst: &mut T, -src: T);\n-}\n-\n /// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n pub pure fn capacity<T>(v: @[const T]) -> uint {\n@@ -185,9 +180,10 @@ pub mod traits {\n pub mod traits {}\n \n pub mod raw {\n-    use at_vec::{capacity, rusti, rustrt};\n+    use at_vec::{capacity, rustrt};\n     use cast::transmute;\n     use libc;\n+    use private::intrinsics::{move_val_init};\n     use ptr::addr_of;\n     use ptr;\n     use sys;\n@@ -229,7 +225,7 @@ pub mod raw {\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));\n         let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(&mut(*p), initval);\n+        move_val_init(&mut(*p), initval);\n     }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {"}, {"sha": "d5407daca80d039c9b0d3f252799392497bce651", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -18,6 +18,7 @@ use num::strconv;\n use num;\n use ops;\n use option::Option;\n+use private::intrinsics::floorf32;\n use from_str;\n use to_str;\n \n@@ -332,11 +333,6 @@ impl ops::Neg<f32> for f32 {\n     pure fn neg(&self) -> f32 { -*self }\n }\n \n-#[abi=\"rust-intrinsic\"]\n-pub extern {\n-    fn floorf32(val: f32) -> f32;\n-}\n-\n impl num::Round for f32 {\n     #[inline(always)]\n     pure fn round(&self, mode: num::RoundMode) -> f32 {"}, {"sha": "4e4e7c68646f2bebe4d9951c78b2cf0f5538559f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -19,6 +19,7 @@ use num::strconv;\n use num;\n use ops;\n use option::Option;\n+use private::intrinsics::floorf64;\n use to_str;\n use from_str;\n \n@@ -357,11 +358,6 @@ impl ops::Neg<f64> for f64 {\n     pure fn neg(&self) -> f64 { -*self }\n }\n \n-#[abi=\"rust-intrinsic\"]\n-pub extern {\n-    fn floorf64(val: f64) -> f64;\n-}\n-\n impl num::Round for f64 {\n     #[inline(always)]\n     pure fn round(&self, mode: num::RoundMode) -> f64 {"}, {"sha": "f1f4319bfceca96eb576ef7b41835b6132611a35", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -92,6 +92,7 @@ use libc;\n use option;\n use option::{None, Option, Some, unwrap};\n use pipes;\n+use private::intrinsics;\n use ptr;\n use private;\n use task;\n@@ -256,37 +257,26 @@ pub fn entangle_buffer<T: Owned, Tstart: Owned>(\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n-#[abi = \"rust-intrinsic\"]\n-#[doc(hidden)]\n-extern mod rusti {\n-    fn atomic_xchg(dst: &mut int, src: int) -> int;\n-    fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n-    fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n-\n-    fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n-    fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n-}\n-\n // If I call the rusti versions directly from a polymorphic function,\n // I get link errors. This is a bug that needs investigated more.\n #[doc(hidden)]\n pub fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n     unsafe {\n-        rusti::atomic_xchg_rel(dst, src)\n+        intrinsics::atomic_xchg_rel(dst, src)\n     }\n }\n \n #[doc(hidden)]\n pub fn atomic_add_acq(dst: &mut int, src: int) -> int {\n     unsafe {\n-        rusti::atomic_xadd_acq(dst, src)\n+        intrinsics::atomic_xadd_acq(dst, src)\n     }\n }\n \n #[doc(hidden)]\n pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n     unsafe {\n-        rusti::atomic_xsub_rel(dst, src)\n+        intrinsics::atomic_xsub_rel(dst, src)\n     }\n }\n \n@@ -295,7 +285,7 @@ pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n-        transmute(rusti::atomic_xchg(transmute(dst), src as int))\n+        transmute(intrinsics::atomic_xchg(transmute(dst), src as int))\n     }\n }\n \n@@ -335,14 +325,14 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n #[doc(hidden)]\n fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n+        transmute(intrinsics::atomic_xchg_acq(transmute(dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n+        transmute(intrinsics::atomic_xchg_rel(transmute(dst), src as int))\n     }\n }\n "}, {"sha": "6d6fd07dc5a8214298d11d11926e9aff8f6b561a", "filename": "src/libcore/private.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -32,6 +32,8 @@ pub mod finally;\n pub mod weak_task;\n #[path = \"private/exchange_alloc.rs\"]\n pub mod exchange_alloc;\n+#[path = \"private/intrinsics.rs\"]\n+pub mod intrinsics;\n \n extern mod rustrt {\n     pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n@@ -43,13 +45,6 @@ extern mod rustrt {\n     pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n-    fn atomic_xadd(dst: &mut int, src: int) -> int;\n-    fn atomic_xsub(dst: &mut int, src: int) -> int;\n-}\n-\n #[allow(non_camel_case_types)] // runtime type\n type raw_thread = libc::c_void;\n \n@@ -101,7 +96,7 @@ fn test_run_in_bare_thread_exchange() {\n \n fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n     unsafe {\n-        let old = rusti::atomic_cxchg(address, oldval, newval);\n+        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n         old == oldval\n     }\n }\n@@ -132,7 +127,8 @@ struct ArcDestruct<T> {\n             }\n             do task::unkillable {\n                 let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n-                let new_count = rusti::atomic_xsub(&mut data.count, 1) - 1;\n+                let new_count =\n+                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n                 assert new_count >= 0;\n                 if new_count == 0 {\n                     // Were we really last, or should we hand off to an\n@@ -205,7 +201,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n             rc.data = ptr::null();\n             // Step 1 - drop our own reference.\n-            let new_count = rusti::atomic_xsub(&mut ptr.count, 1) - 1;\n+            let new_count = intrinsics::atomic_xsub(&mut ptr.count, 1) - 1;\n             //assert new_count >= 0;\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n@@ -284,7 +280,7 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        let new_count = rusti::atomic_xadd(&mut ptr.count, 1) + 1;\n+        let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n         assert new_count >= 2;\n         cast::forget(ptr);\n     }"}, {"sha": "4785cb622cbc511da3335182658566418f97ffa2", "filename": "src/libcore/private/at_exit.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fat_exit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fat_exit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fat_exit.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -70,12 +70,6 @@ fn exit_runner(exit_fns: *ExitFunctions) {\n     }\n }\n \n-#[abi = \"rust-intrinsic\"]\n-pub extern mod rusti {\n-    fn move_val_init<T>(dst: &mut T, -src: T);\n-    fn init<T>() -> T;\n-}\n-\n #[test]\n fn test_at_exit() {\n     let i = 10;"}, {"sha": "b6af9891e118be85cc964eec12aeb68e5b2fcf69", "filename": "src/libcore/private/exchange_alloc.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fexchange_alloc.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -14,6 +14,7 @@ use c_malloc = libc::malloc;\n use c_free = libc::free;\n use managed::raw::{BoxHeaderRepr, BoxRepr};\n use cast::transmute;\n+use private::intrinsics::{atomic_xadd,atomic_xsub};\n use ptr::null;\n use intrinsic::TyDesc;\n \n@@ -35,15 +36,15 @@ pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n         box.header.next = null();\n \n         let exchange_count = &mut *rust_get_exchange_count_ptr();\n-        rusti::atomic_xadd(exchange_count, 1);\n+        atomic_xadd(exchange_count, 1);\n \n         return transmute(box);\n     }\n }\n \n pub unsafe fn free(ptr: *c_void) {\n     let exchange_count = &mut *rust_get_exchange_count_ptr();\n-    rusti::atomic_xsub(exchange_count, 1);\n+    atomic_xsub(exchange_count, 1);\n \n     assert ptr.is_not_null();\n     c_free(ptr);\n@@ -68,8 +69,3 @@ extern {\n     fn rust_get_exchange_count_ptr() -> *mut int;\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern mod rusti {\n-    fn atomic_xadd(dst: &mut int, src: int) -> int;\n-    fn atomic_xsub(dst: &mut int, src: int) -> int;\n-}"}, {"sha": "086fa49c7b507ea60528181679e891962b2d5527", "filename": "src/libcore/private/global.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fglobal.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -36,6 +36,7 @@ use private::{Exclusive, exclusive};\n use private::{SharedMutableState, shared_mutable_state};\n use private::{get_shared_immutable_state};\n use private::at_exit::at_exit;\n+use private::intrinsics::atomic_cxchg;\n use hashmap::linear::LinearMap;\n use sys::Closure;\n use task::spawn;\n@@ -231,11 +232,6 @@ extern {\n     fn rust_get_global_data_ptr() -> *mut int;\n }\n \n-#[abi = \"rust-intrinsic\"]\n-extern {\n-    fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n-}\n-\n #[test]\n fn test_clone_rc() {\n     type MyType = SharedMutableState<int>;"}, {"sha": "8f0067b739335d15baf1582b362751cf021dbc89", "filename": "src/libcore/private/intrinsics.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fprivate%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fintrinsics.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+An attempt to move all intrinsic declarations to a single place,\n+as mentioned in #3369\n+The intrinsics are defined in librustc/middle/trans/foreign.rs.\n+*/\n+\n+#[abi = \"rust-intrinsic\"]\n+pub extern {\n+    pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n+    pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n+    pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n+\n+    pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n+\n+    pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n+\n+    pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n+    pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n+\n+    pub fn size_of<T>() -> uint;\n+\n+    pub fn move_val<T>(dst: &mut T, -src: T);\n+    pub fn move_val_init<T>(dst: &mut T, -src: T);\n+\n+    pub fn min_align_of<T>() -> uint;\n+    pub fn pref_align_of<T>() -> uint;\n+\n+    pub fn get_tydesc<T>() -> *();\n+\n+    pub fn init<T>() -> T;\n+\n+    pub fn forget<T>(_: T) -> ();\n+\n+    // XXX: intrinsic uses legacy modes\n+    fn reinterpret_cast<T,U>(&&src: T) -> U;\n+    // XXX: intrinsic uses legacy modes\n+    fn addr_of<T>(&&scr: T) -> *T;\n+\n+    pub fn needs_drop<T>() -> bool;\n+\n+    // XXX: intrinsic uses legacy modes and has reference to TyDesc\n+    // and TyVisitor which are in librustc\n+    //fn visit_tydesc(++td: *TyDesc, &&tv: TyVisitor) -> ();\n+    // XXX: intrinsic uses legacy modes\n+    //fn frame_address(f: &once fn(*u8));\n+\n+    pub fn morestack_addr() -> *();\n+\n+    pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n+    pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n+\n+    pub fn sqrtf32(x: f32) -> f32;\n+    pub fn sqrtf64(x: f64) -> f64;\n+\n+    pub fn powif32(a: f32, x: i32) -> f32;\n+    pub fn powif64(a: f64, x: i32) -> f64;\n+\n+    pub fn sinf32(x: f32) -> f32;\n+    pub fn sinf64(x: f64) -> f64;\n+\n+    pub fn cosf32(x: f32) -> f32;\n+    pub fn cosf64(x: f64) -> f64;\n+\n+    pub fn powf32(a: f32, x: f32) -> f32;\n+    pub fn powf64(a: f64, x: f64) -> f64;\n+\n+    pub fn expf32(x: f32) -> f32;\n+    pub fn expf64(x: f64) -> f64;\n+\n+    pub fn exp2f32(x: f32) -> f32;\n+    pub fn exp2f64(x: f64) -> f64;\n+\n+    pub fn logf32(x: f32) -> f32;\n+    pub fn logf64(x: f64) -> f64;\n+\n+    pub fn log10f32(x: f32) -> f32;\n+    pub fn log10f64(x: f64) -> f64;\n+\n+    pub fn log2f32(x: f32) -> f32;\n+    pub fn log2f64(x: f64) -> f64;\n+\n+    pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n+    pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n+\n+    pub fn fabsf32(x: f32) -> f32;\n+    pub fn fabsf64(x: f64) -> f64;\n+\n+    pub fn floorf32(x: f32) -> f32;\n+    pub fn floorf64(x: f64) -> f64;\n+\n+    pub fn ceilf32(x: f32) -> f32;\n+    pub fn ceilf64(x: f64) -> f64;\n+\n+    pub fn truncf32(x: f32) -> f32;\n+    pub fn truncf64(x: f64) -> f64;\n+\n+    pub fn ctpop8(x: i8) -> i8;\n+    pub fn ctpop16(x: i16) -> i16;\n+    pub fn ctpop32(x: i32) -> i32;\n+    pub fn ctpop64(x: i64) -> i64;\n+\n+    pub fn ctlz8(x: i8) -> i8;\n+    pub fn ctlz16(x: i16) -> i16;\n+    pub fn ctlz32(x: i32) -> i32;\n+    pub fn ctlz64(x: i64) -> i64;\n+\n+    pub fn cttz8(x: i8) -> i8;\n+    pub fn cttz16(x: i16) -> i16;\n+    pub fn cttz32(x: i32) -> i32;\n+    pub fn cttz64(x: i64) -> i64;\n+\n+    pub fn bswap16(x: i16) -> i16;\n+    pub fn bswap32(x: i32) -> i32;\n+    pub fn bswap64(x: i64) -> i64;\n+}\n+"}, {"sha": "2266c2511f8f3dca564a61bc8eb29797cc54474b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -14,6 +14,7 @@ use cast;\n use cmp::{Eq, Ord};\n use libc;\n use libc::{c_void, size_t};\n+use private::intrinsics::{memmove32,memmove64};\n use ptr;\n use str;\n use sys;\n@@ -179,12 +180,6 @@ pub trait Ptr<T> {\n     pure fn offset(count: uint) -> Self;\n }\n \n-#[abi=\"rust-intrinsic\"]\n-pub extern {\n-    fn memmove32(dst: *mut u8, src: *u8, size: u32);\n-    fn memmove64(dst: *mut u8, src: *u8, size: u64);\n-}\n-\n /// Extension methods for immutable pointers\n impl<T> Ptr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer."}, {"sha": "6c374d6101aef449433a2568ae8b481bf5eec5ea", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -22,6 +22,7 @@ use kinds::Copy;\n use libc;\n use libc::size_t;\n use option::{None, Option, Some};\n+use private::intrinsics;\n use ptr;\n use ptr::addr_of;\n use sys;\n@@ -35,13 +36,6 @@ pub extern mod rustrt {\n                                  ++n: libc::size_t);\n }\n \n-#[abi = \"rust-intrinsic\"]\n-pub extern mod rusti {\n-    fn move_val_init<T>(dst: &mut T, -src: T);\n-    fn init<T>() -> T;\n-}\n-\n-\n /// Returns true if a vector contains no elements\n pub pure fn is_empty<T>(v: &[const T]) -> bool {\n     as_const_buf(v, |_p, len| len == 0u)\n@@ -120,7 +114,8 @@ pub pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n         do as_mut_buf(v) |p, _len| {\n             let mut i: uint = 0u;\n             while i < n_elts {\n-                rusti::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n+                intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n+                                          op(i));\n                 i += 1u;\n             }\n         }\n@@ -538,7 +533,7 @@ pub fn consume<T>(mut v: ~[T], f: fn(uint, v: T)) {\n                 // holes we create in the vector. That ensures that, if the\n                 // iterator fails then we won't try to clean up the consumed\n                 // elements during unwinding\n-                let mut x = rusti::init();\n+                let mut x = intrinsics::init();\n                 let p = ptr::mut_offset(p, i);\n                 x <-> *p;\n                 f(i, x);\n@@ -557,8 +552,8 @@ pub fn pop<T>(v: &mut ~[T]) -> T {\n     }\n     let valptr = ptr::to_mut_unsafe_ptr(&mut v[ln - 1u]);\n     unsafe {\n-        // FIXME #4204: Should be rusti::uninit() - we don't need this zeroed\n-        let mut val = rusti::init();\n+        // FIXME #4204: Should be uninit() - we don't need this zeroed\n+        let mut val = intrinsics::init();\n         val <-> *valptr;\n         raw::set_len(v, ln - 1u);\n         val\n@@ -605,7 +600,7 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(&mut(*p), initval);\n+    intrinsics::move_val_init(&mut(*p), initval);\n }\n \n #[inline(never)]\n@@ -632,8 +627,8 @@ pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n     unsafe {\n         do as_mut_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n-                // FIXME #4204 Should be rusti::uninit() - don't need to zero\n-                let mut x = rusti::init();\n+                // FIXME #4204 Should be uninit() - don't need to zero\n+                let mut x = intrinsics::init();\n                 x <-> *ptr::mut_offset(p, i);\n                 push(&mut *v, x);\n             }\n@@ -649,8 +644,8 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n         unsafe {\n             // This loop is optimized out for non-drop types.\n             for uint::range(newlen, oldlen) |i| {\n-                // FIXME #4204 Should be rusti::uninit() - don't need to zero\n-                let mut dropped = rusti::init();\n+                // FIXME #4204 Should be uninit() - don't need to zero\n+                let mut dropped = intrinsics::init();\n                 dropped <-> *ptr::mut_offset(p, i);\n             }\n         }\n@@ -675,9 +670,9 @@ pub fn dedup<T: Eq>(v: &mut ~[T]) {\n                 // last_written < next_to_read < ln\n                 if *ptr::mut_offset(p, next_to_read) ==\n                     *ptr::mut_offset(p, last_written) {\n-                    // FIXME #4204 Should be rusti::uninit() - don't need to\n+                    // FIXME #4204 Should be uninit() - don't need to\n                     // zero\n-                    let mut dropped = rusti::init();\n+                    let mut dropped = intrinsics::init();\n                     dropped <-> *ptr::mut_offset(p, next_to_read);\n                 } else {\n                     last_written += 1;\n@@ -2009,11 +2004,11 @@ pub mod raw {\n     use managed;\n     use option::{None, Some};\n     use option;\n+    use private::intrinsics;\n     use ptr::addr_of;\n     use ptr;\n     use sys;\n     use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, len, with_capacity};\n-    use vec::rusti;\n \n     /// The internal representation of a (boxed) vector\n     pub struct VecRepr {\n@@ -2101,7 +2096,7 @@ pub mod raw {\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n             box2 <-> box;\n-            rusti::move_val_init(&mut(*ptr::mut_offset(p, i)),\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n                                  option::unwrap(box2));\n         }\n     }"}, {"sha": "d16b2e3e996ce3e913d0b0371f4eed8eb59a645c", "filename": "src/test/run-pass/type-use-i1-versus-i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aa1aaa2c1d095365e341017e443d61a960e0af6/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-use-i1-versus-i8.rs?ref=0aa1aaa2c1d095365e341017e443d61a960e0af6", "patch": "@@ -11,5 +11,5 @@\n pub fn main() {\n     let mut x: bool = false;\n     // this line breaks it\n-    vec::rusti::move_val_init(&mut x, false);\n+    private::intrinsics::move_val_init(&mut x, false);\n }"}]}