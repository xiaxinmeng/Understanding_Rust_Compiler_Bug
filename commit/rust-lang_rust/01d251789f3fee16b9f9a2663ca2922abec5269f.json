{"sha": "01d251789f3fee16b9f9a2663ca2922abec5269f", "node_id": "C_kwDOAAsO6NoAKDAxZDI1MTc4OWYzZmVlMTZiOWY5YTI2NjNjYTI5MjJhYmVjNTI2OWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T16:36:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T16:36:57Z"}, "message": "Auto merge of #12539 - soruh:instanciate_empty_structs, r=Veykril\n\nAutomatically instaciate trivially instaciable structs in \"Generate new\" and \"Fill struct fields\"\n\nAs proposed in #12535 this PR changes the \"Generate new\" and \"Fill struct fields\" assist/diagnostic to instanciate structs with no fields and enums with a single empty variant.\n\nFor example:\n```rust\npub enum Bar {\n    Bar {},\n}\nstruct Foo<T> {\n    a: usize,\n    bar: Bar,\n    _phantom: std::marker::PhantomData<T>,\n}\nimpl<T> Foo<T> {\n    /* generate new */\n\n    fn random() -> Self {\n        Self { /* Fill struct fields */ }\n    }\n}\n```\n\nwas previously:\n```rust\nimpl<T> Foo<T> {\n    fn new(a: usize, bar: Bar, _phantom: std::marker::PhantomData<T>) -> Self {\n        Self { a, bar, _phantom }\n    }\n\n    fn random() -> Self {\n        Self {\n            a: todo!(),\n            bar: todo!(),\n            _phantom: todo!(),\n        }\n    }\n}\n```\n\nand is now:\n```rust\nimpl<T> Foo<T> {\n  fn new(a: usize) -> Self {\n      Self {\n          a,\n          bar: Bar::Bar {},\n          _phantom: std::marker::PhantomData\n      }\n  }\n\n  fn random() -> Self {\n      Self {\n          a: todo!(),\n          bar: Bar::Bar {},\n          _phantom: std::marker::PhantomData,\n      }\n  }\n}\n```\n\nI'd be happy about any suggestions.\n\n## TODO\n   - [x]  deduplicate `use_trivial_constructor` (unclear how to do as it's used in two separate crates)\n   - [x]  write tests\n\nCloses #12535", "tree": {"sha": "8ad753e287d2667033ae719e68f3c459f0d212d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ad753e287d2667033ae719e68f3c459f0d212d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01d251789f3fee16b9f9a2663ca2922abec5269f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01d251789f3fee16b9f9a2663ca2922abec5269f", "html_url": "https://github.com/rust-lang/rust/commit/01d251789f3fee16b9f9a2663ca2922abec5269f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01d251789f3fee16b9f9a2663ca2922abec5269f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac526e029a22b64e59f9ab65500898d5399869c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac526e029a22b64e59f9ab65500898d5399869c4", "html_url": "https://github.com/rust-lang/rust/commit/ac526e029a22b64e59f9ab65500898d5399869c4"}, {"sha": "a5ad4de11186961f8f9b13cfee383af59e75c5d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ad4de11186961f8f9b13cfee383af59e75c5d1", "html_url": "https://github.com/rust-lang/rust/commit/a5ad4de11186961f8f9b13cfee383af59e75c5d1"}], "stats": {"total": 291, "additions": 287, "deletions": 4}, "files": [{"sha": "5f4715bb53d241b4f49fbdc445b5fd9efb030986", "filename": "crates/ide-assists/src/handlers/generate_new.rs", "status": "modified", "additions": 137, "deletions": 2, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=01d251789f3fee16b9f9a2663ca2922abec5269f", "patch": "@@ -1,3 +1,6 @@\n+use ide_db::{\n+    imports::import_assets::item_for_path_search, use_trivial_contructor::use_trivial_constructor,\n+};\n use itertools::Itertools;\n use stdx::format_to;\n use syntax::ast::{self, AstNode, HasName, HasVisibility, StructKind};\n@@ -38,6 +41,8 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     // Return early if we've found an existing new fn\n     let impl_def = find_struct_impl(ctx, &ast::Adt::Struct(strukt.clone()), \"new\")?;\n \n+    let current_module = ctx.sema.scope(strukt.syntax())?.module();\n+\n     let target = strukt.syntax().text_range();\n     acc.add(AssistId(\"generate_new\", AssistKind::Generate), \"Generate `new`\", target, |builder| {\n         let mut buf = String::with_capacity(512);\n@@ -48,11 +53,50 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n \n         let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n \n+        let trivial_constructors = field_list\n+            .fields()\n+            .map(|f| {\n+                let ty = ctx.sema.resolve_type(&f.ty()?)?;\n+\n+                let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n+\n+                let type_path = current_module\n+                    .find_use_path(ctx.sema.db, item_for_path_search(ctx.sema.db, item_in_ns)?)?;\n+\n+                let expr = use_trivial_constructor(\n+                    &ctx.sema.db,\n+                    ide_db::helpers::mod_path_to_ast(&type_path),\n+                    &ty,\n+                )?;\n+\n+                Some(format!(\"{}: {}\", f.name()?.syntax(), expr))\n+            })\n+            .collect::<Vec<_>>();\n+\n         let params = field_list\n             .fields()\n-            .filter_map(|f| Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax())))\n+            .enumerate()\n+            .filter_map(|(i, f)| {\n+                if trivial_constructors[i].is_none() {\n+                    Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax()))\n+                } else {\n+                    None\n+                }\n+            })\n+            .format(\", \");\n+\n+        let fields = field_list\n+            .fields()\n+            .enumerate()\n+            .filter_map(|(i, f)| {\n+                let contructor = trivial_constructors[i].clone();\n+                if contructor.is_some() {\n+                    contructor\n+                } else {\n+                    Some(f.name()?.to_string())\n+                }\n+            })\n             .format(\", \");\n-        let fields = field_list.fields().filter_map(|f| f.name()).format(\", \");\n \n         format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n \n@@ -79,6 +123,97 @@ mod tests {\n \n     use super::*;\n \n+    #[test]\n+    fn test_generate_new_with_zst_fields() {\n+        check_assist(\n+            generate_new,\n+            r#\"\n+struct Empty;\n+\n+struct Foo { empty: Empty $0}\n+\"#,\n+            r#\"\n+struct Empty;\n+\n+struct Foo { empty: Empty }\n+\n+impl Foo {\n+    fn $0new() -> Self { Self { empty: Empty } }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_new,\n+            r#\"\n+struct Empty;\n+\n+struct Foo { baz: String, empty: Empty $0}\n+\"#,\n+            r#\"\n+struct Empty;\n+\n+struct Foo { baz: String, empty: Empty }\n+\n+impl Foo {\n+    fn $0new(baz: String) -> Self { Self { baz, empty: Empty } }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_new,\n+            r#\"\n+enum Empty { Bar }\n+\n+struct Foo { empty: Empty $0}\n+\"#,\n+            r#\"\n+enum Empty { Bar }\n+\n+struct Foo { empty: Empty }\n+\n+impl Foo {\n+    fn $0new() -> Self { Self { empty: Empty::Bar } }\n+}\n+\"#,\n+        );\n+\n+        // make sure the assist only works on unit variants\n+        check_assist(\n+            generate_new,\n+            r#\"\n+struct Empty {}\n+\n+struct Foo { empty: Empty $0}\n+\"#,\n+            r#\"\n+struct Empty {}\n+\n+struct Foo { empty: Empty }\n+\n+impl Foo {\n+    fn $0new(empty: Empty) -> Self { Self { empty } }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_new,\n+            r#\"\n+enum Empty { Bar {} }\n+\n+struct Foo { empty: Empty $0}\n+\"#,\n+            r#\"\n+enum Empty { Bar {} }\n+\n+struct Foo { empty: Empty }\n+\n+impl Foo {\n+    fn $0new(empty: Empty) -> Self { Self { empty } }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_generate_new() {\n         check_assist("}, {"sha": "165b98d72ed672f2f75ef40e6b670b47e7151df2", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=01d251789f3fee16b9f9a2663ca2922abec5269f", "patch": "@@ -20,6 +20,7 @@ pub mod source_change;\n pub mod symbol_index;\n pub mod traits;\n pub mod ty_filter;\n+pub mod use_trivial_contructor;\n \n pub mod imports {\n     pub mod import_assets;"}, {"sha": "39431bed3821c8e5560a1dc13c0078f2f30dba56", "filename": "crates/ide-db/src/use_trivial_contructor.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-db%2Fsrc%2Fuse_trivial_contructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-db%2Fsrc%2Fuse_trivial_contructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fuse_trivial_contructor.rs?ref=01d251789f3fee16b9f9a2663ca2922abec5269f", "patch": "@@ -0,0 +1,34 @@\n+//! Functionality for generating trivial contructors\n+\n+use hir::StructKind;\n+use syntax::ast;\n+\n+/// given a type return the trivial contructor (if one exists)\n+pub fn use_trivial_constructor(\n+    db: &crate::RootDatabase,\n+    path: ast::Path,\n+    ty: &hir::Type,\n+) -> Option<ast::Expr> {\n+    match ty.as_adt() {\n+        Some(hir::Adt::Enum(x)) => {\n+            if let &[variant] = &*x.variants(db) {\n+                if variant.kind(db) == hir::StructKind::Unit {\n+                    let path = ast::make::path_qualified(\n+                        path,\n+                        syntax::ast::make::path_segment(ast::make::name_ref(\n+                            &variant.name(db).to_smol_str(),\n+                        )),\n+                    );\n+\n+                    return Some(syntax::ast::make::expr_path(path));\n+                }\n+            }\n+        }\n+        Some(hir::Adt::Struct(x)) if x.kind(db) == StructKind::Unit => {\n+            return Some(syntax::ast::make::expr_path(path));\n+        }\n+        _ => {}\n+    }\n+\n+    None\n+}"}, {"sha": "30f903af50d5bd0e8eba742a19af4f42e809fa46", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 115, "deletions": 2, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01d251789f3fee16b9f9a2663ca2922abec5269f/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=01d251789f3fee16b9f9a2663ca2922abec5269f", "patch": "@@ -3,7 +3,10 @@ use hir::{\n     db::{AstDatabase, HirDatabase},\n     known, AssocItem, HirDisplay, InFile, Type,\n };\n-use ide_db::{assists::Assist, famous_defs::FamousDefs, source_change::SourceChange, FxHashMap};\n+use ide_db::{\n+    assists::Assist, famous_defs::FamousDefs, imports::import_assets::item_for_path_search,\n+    source_change::SourceChange, use_trivial_contructor::use_trivial_constructor, FxHashMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n@@ -55,6 +58,11 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n \n     let root = ctx.sema.db.parse_or_expand(d.file)?;\n \n+    let current_module = match &d.field_list_parent {\n+        Either::Left(ptr) => ctx.sema.scope(ptr.to_node(&root).syntax()).map(|it| it.module()),\n+        Either::Right(ptr) => ctx.sema.scope(ptr.to_node(&root).syntax()).map(|it| it.module()),\n+    };\n+\n     let build_text_edit = |parent_syntax, new_syntax: &SyntaxNode, old_syntax| {\n         let edit = {\n             let mut builder = TextEdit::builder();\n@@ -110,7 +118,26 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n                         Some(generate_fill_expr(ty))\n                     }\n                 } else {\n-                    Some(generate_fill_expr(ty))\n+                    let expr = (|| -> Option<ast::Expr> {\n+                        let item_in_ns = hir::ItemInNs::from(hir::ModuleDef::from(ty.as_adt()?));\n+\n+                        let type_path = current_module?.find_use_path(\n+                            ctx.sema.db,\n+                            item_for_path_search(ctx.sema.db, item_in_ns)?,\n+                        )?;\n+\n+                        use_trivial_constructor(\n+                            &ctx.sema.db,\n+                            ide_db::helpers::mod_path_to_ast(&type_path),\n+                            &ty,\n+                        )\n+                    })();\n+\n+                    if expr.is_some() {\n+                        expr\n+                    } else {\n+                        Some(generate_fill_expr(ty))\n+                    }\n                 };\n                 let field = make::record_expr_field(\n                     make::name_ref(&f.name(ctx.sema.db).to_smol_str()),\n@@ -318,6 +345,92 @@ fn test_fn() {\n         );\n     }\n \n+    #[test]\n+    fn test_fill_struct_zst_fields() {\n+        check_fix(\n+            r#\"\n+struct Empty;\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+struct Empty;\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: 0, two: Empty };\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+enum Empty { Foo };\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+enum Empty { Foo };\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: 0, two: Empty::Foo };\n+}\n+\"#,\n+        );\n+\n+        // make sure the assist doesn't fill non Unit variants\n+        check_fix(\n+            r#\"\n+struct Empty {};\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+struct Empty {};\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: 0, two: todo!() };\n+}\n+\"#,\n+        );\n+        check_fix(\n+            r#\"\n+enum Empty { Foo {} };\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+enum Empty { Foo {} };\n+\n+struct TestStruct { one: i32, two: Empty }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: 0, two: todo!() };\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_fill_struct_fields_self() {\n         check_fix("}]}