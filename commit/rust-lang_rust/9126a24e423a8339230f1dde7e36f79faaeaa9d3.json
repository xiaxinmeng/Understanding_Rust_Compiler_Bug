{"sha": "9126a24e423a8339230f1dde7e36f79faaeaa9d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMjZhMjRlNDIzYTgzMzkyMzBmMWRkZTdlMzZmNzlmYWFlYWE5ZDM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-01T19:32:36Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-14T01:15:39Z"}, "message": "libstd: convert `Duration` binops to by value", "tree": {"sha": "aa4e83413b0fa1daf8106a5328077de86597623d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa4e83413b0fa1daf8106a5328077de86597623d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9126a24e423a8339230f1dde7e36f79faaeaa9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9126a24e423a8339230f1dde7e36f79faaeaa9d3", "html_url": "https://github.com/rust-lang/rust/commit/9126a24e423a8339230f1dde7e36f79faaeaa9d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9126a24e423a8339230f1dde7e36f79faaeaa9d3/comments", "author": null, "committer": null, "parents": [{"sha": "32168faf9f7a9e634647b86c1a671ae68dbe9c9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32168faf9f7a9e634647b86c1a671ae68dbe9c9d", "html_url": "https://github.com/rust-lang/rust/commit/32168faf9f7a9e634647b86c1a671ae68dbe9c9d"}], "stats": {"total": 64, "additions": 64, "deletions": 0}, "files": [{"sha": "f98cebd9675962ea5efdb8ef8b43ea9675e82d1f", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9126a24e423a8339230f1dde7e36f79faaeaa9d3/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9126a24e423a8339230f1dde7e36f79faaeaa9d3/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=9126a24e423a8339230f1dde7e36f79faaeaa9d3", "patch": "@@ -276,6 +276,8 @@ impl Neg<Duration> for Duration {\n     }\n }\n \n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Add<Duration,Duration> for Duration {\n     fn add(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs + rhs.secs;\n@@ -288,6 +290,21 @@ impl Add<Duration,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Add<Duration, Duration> for Duration {\n+    fn add(self, rhs: Duration) -> Duration {\n+        let mut secs = self.secs + rhs.secs;\n+        let mut nanos = self.nanos + rhs.nanos;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs += 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Sub<Duration,Duration> for Duration {\n     fn sub(&self, rhs: &Duration) -> Duration {\n         let mut secs = self.secs - rhs.secs;\n@@ -300,6 +317,21 @@ impl Sub<Duration,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Sub<Duration, Duration> for Duration {\n+    fn sub(self, rhs: Duration) -> Duration {\n+        let mut secs = self.secs - rhs.secs;\n+        let mut nanos = self.nanos - rhs.nanos;\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Mul<i32,Duration> for Duration {\n     fn mul(&self, rhs: &i32) -> Duration {\n         // Multiply nanoseconds as i64, because it cannot overflow that way.\n@@ -310,6 +342,19 @@ impl Mul<i32,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Mul<i32, Duration> for Duration {\n+    fn mul(self, rhs: i32) -> Duration {\n+        // Multiply nanoseconds as i64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as i64 * rhs as i64;\n+        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n+        let secs = self.secs * rhs as i64 + extra_secs;\n+        Duration { secs: secs, nanos: nanos as i32 }\n+    }\n+}\n+\n+// NOTE(stage0): Remove impl after a snapshot\n+#[cfg(stage0)]\n impl Div<i32,Duration> for Duration {\n     fn div(&self, rhs: &i32) -> Duration {\n         let mut secs = self.secs / *rhs as i64;\n@@ -328,6 +373,25 @@ impl Div<i32,Duration> for Duration {\n     }\n }\n \n+#[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n+impl Div<i32, Duration> for Duration {\n+    fn div(self, rhs: i32) -> Duration {\n+        let mut secs = self.secs / rhs as i64;\n+        let carry = self.secs - secs * rhs as i64;\n+        let extra_nanos = carry * NANOS_PER_SEC as i64 / rhs as i64;\n+        let mut nanos = self.nanos / rhs + extra_nanos as i32;\n+        if nanos >= NANOS_PER_SEC {\n+            nanos -= NANOS_PER_SEC;\n+            secs += 1;\n+        }\n+        if nanos < 0 {\n+            nanos += NANOS_PER_SEC;\n+            secs -= 1;\n+        }\n+        Duration { secs: secs, nanos: nanos }\n+    }\n+}\n+\n impl fmt::Show for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,"}]}