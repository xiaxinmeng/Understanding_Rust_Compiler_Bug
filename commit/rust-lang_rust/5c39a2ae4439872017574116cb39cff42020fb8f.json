{"sha": "5c39a2ae4439872017574116cb39cff42020fb8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMzlhMmFlNDQzOTg3MjAxNzU3NDExNmNiMzljZmY0MjAyMGZiOGY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-07T21:52:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-14T04:23:02Z"}, "message": "add cycle-reporting logic\n\nFixes #33344", "tree": {"sha": "9b76bc9456130269cce458443dd3194f9b61f9b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b76bc9456130269cce458443dd3194f9b61f9b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c39a2ae4439872017574116cb39cff42020fb8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c39a2ae4439872017574116cb39cff42020fb8f", "html_url": "https://github.com/rust-lang/rust/commit/5c39a2ae4439872017574116cb39cff42020fb8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c39a2ae4439872017574116cb39cff42020fb8f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "957500b79348a89b2148a6d20f7de6c10af4eea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/957500b79348a89b2148a6d20f7de6c10af4eea2", "html_url": "https://github.com/rust-lang/rust/commit/957500b79348a89b2148a6d20f7de6c10af4eea2"}], "stats": {"total": 240, "additions": 151, "deletions": 89}, "files": [{"sha": "a04c1d989f424a2a121d60e34002b97ba91235ee", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5c39a2ae4439872017574116cb39cff42020fb8f", "patch": "@@ -513,6 +513,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// going to help).\n     pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n         let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n "}, {"sha": "4e0eb9f88c1b39f5a6d70e551029f989ec521d79", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=5c39a2ae4439872017574116cb39cff42020fb8f", "patch": "@@ -314,12 +314,13 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }).collect()))\n     }\n \n-    fn process_backedge(&mut self, cycle: &[Self::Obligation])\n+    fn process_backedge<'c, I>(&mut self, cycle: I)\n+        where I: Clone + Iterator<Item=*const Self::Obligation>,\n     {\n-        if coinductive_match(self.selcx, &cycle) {\n+        if coinductive_match(self.selcx, cycle.clone()) {\n             debug!(\"process_child_obligations: coinductive match\");\n         } else {\n-            let cycle : Vec<_> = cycle.iter().map(|c| c.obligation.clone()).collect();\n+            let cycle : Vec<_> = cycle.map(|c| unsafe { &*c }.obligation.clone()).collect();\n             self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n     }\n@@ -535,21 +536,21 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                              cycle: &[PendingPredicateObligation<'tcx>])\n-                                     -> bool\n+fn coinductive_match<'a,'gcx,'tcx,I>(selcx: &mut SelectionContext<'a,'gcx,'tcx>, cycle: I) -> bool\n+    where I: Iterator<Item=*const PendingPredicateObligation<'tcx>>\n {\n+    let mut cycle = cycle;\n     cycle\n-        .iter()\n         .all(|bt_obligation| {\n+            let bt_obligation = unsafe { &*bt_obligation };\n             let result = coinductive_obligation(selcx, &bt_obligation.obligation);\n             debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n                    bt_obligation, result);\n             result\n         })\n }\n \n-fn coinductive_obligation<'a, 'gcx, 'tcx>(selcx: &SelectionContext<'a, 'gcx, 'tcx>,\n+fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n                                           -> bool {\n     match obligation.predicate {"}, {"sha": "926ee85230a311e0498b8eaa806d05420ae76bbb", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=5c39a2ae4439872017574116cb39cff42020fb8f", "patch": "@@ -28,6 +28,8 @@\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(unboxed_closures)]\n+#![feature(fn_traits)]\n \n #![cfg_attr(test, feature(test))]\n "}, {"sha": "cb7d9e588f6a976685a2ae4cf8a832b7c5a5189c", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 109, "deletions": 54, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=5c39a2ae4439872017574116cb39cff42020fb8f", "patch": "@@ -17,6 +17,7 @@\n \n use fnv::{FnvHashMap, FnvHashSet};\n \n+use std::cell::Cell;\n use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n use std::hash;\n@@ -41,7 +42,9 @@ pub trait ObligationProcessor {\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n \n-    fn process_backedge(&mut self, cycle: &[Self::Obligation]);\n+    // FIXME: crazy lifetime troubles\n+    fn process_backedge<I>(&mut self, cycle: I)\n+        where I: Clone + Iterator<Item=*const Self::Obligation>;\n }\n \n struct SnapshotData {\n@@ -77,7 +80,7 @@ pub struct Snapshot {\n #[derive(Debug)]\n struct Node<O> {\n     obligation: O,\n-    state: NodeState,\n+    state: Cell<NodeState>,\n \n     // these both go *in the same direction*.\n     parent: Option<NodeIndex>,\n@@ -87,14 +90,17 @@ struct Node<O> {\n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum NodeState {\n     /// Obligation not yet resolved to success or error.\n     Pending,\n \n     /// Used before garbage collection\n     Success,\n \n+    /// Used in DFS loops\n+    InLoop,\n+\n     /// Obligation resolved to success; `num_incomplete_children`\n     /// indicates the number of children still in an \"incomplete\"\n     /// state. Incomplete means that either the child is still\n@@ -225,7 +231,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             debug_assert!(!self.nodes[index].is_popped());\n-            if let NodeState::Pending = self.nodes[index].state {\n+            if let NodeState::Pending = self.nodes[index].state.get() {\n                 let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n@@ -244,7 +250,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n     {\n         self.nodes\n             .iter()\n-            .filter(|n| n.state == NodeState::Pending)\n+            .filter(|n| n.state.get() == NodeState::Pending)\n             .map(|n| n.obligation.clone())\n             .collect()\n     }\n@@ -270,7 +276,9 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n                    self.nodes[index]);\n \n             let result = match self.nodes[index] {\n-                Node { state: NodeState::Pending, ref mut obligation, .. } => {\n+                Node { state: ref _state, ref mut obligation, .. }\n+                    if _state.get() == NodeState::Pending =>\n+                {\n                     processor.process_obligation(obligation)\n                 }\n                 _ => continue\n@@ -292,7 +300,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n                                                     Some(NodeIndex::new(index)));\n                     }\n \n-                    self.nodes[index].state = NodeState::Success;\n+                    self.nodes[index].state.set(NodeState::Success);\n                 }\n                 Err(err) => {\n                     let backtrace = self.error_at(index);\n@@ -319,29 +327,69 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         }\n     }\n \n-    pub fn process_cycles<P>(&mut self, _processor: &mut P)\n+    pub fn process_cycles<P>(&mut self, processor: &mut P)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        // TODO: implement\n-        for node in &mut self.nodes {\n-            if node.state == NodeState::Success {\n-                node.state = NodeState::Done;\n-            }\n+        let mut stack = self.scratch.take().unwrap();\n+\n+        for node in 0..self.nodes.len() {\n+            self.visit_node(&mut stack, processor, node);\n         }\n+\n+        self.scratch = Some(stack);\n+    }\n+\n+    fn visit_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        let node = &self.nodes[index];\n+        let state = node.state.get();\n+        match state {\n+            NodeState::InLoop => {\n+                let index =\n+                    stack.iter().rposition(|n| *n == index).unwrap();\n+                // I need a Clone closure\n+                #[derive(Clone)]\n+                struct GetObligation<'a, O: 'a>(&'a [Node<O>]);\n+                impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n+                    type Output = *const O;\n+                    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> *const O {\n+                        &self.0[*args.0].obligation\n+                    }\n+                }\n+                impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n+                    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> *const O {\n+                        &self.0[*args.0].obligation\n+                    }\n+                }\n+\n+                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)));\n+            }\n+            NodeState::Success => {\n+                node.state.set(NodeState::InLoop);\n+                stack.push(index);\n+                if let Some(parent) = node.parent {\n+                    self.visit_node(stack, processor, parent.get());\n+                }\n+                for dependant in &node.dependants {\n+                        self.visit_node(stack, processor, dependant.get());\n+                }\n+                stack.pop();\n+                node.state.set(NodeState::Done);\n+            },\n+            _ => return\n+        };\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    /// The fact that the root is now marked as an error is used by\n-    /// `inherit_error` above to propagate the error state to the\n-    /// remainder of the tree.\n     fn error_at(&mut self, p: usize) -> Vec<O> {\n         let mut error_stack = self.scratch.take().unwrap();\n         let mut trace = vec![];\n \n         let mut n = p;\n         loop {\n-            self.nodes[n].state = NodeState::Error;\n+            self.nodes[n].state.set(NodeState::Error);\n             trace.push(self.nodes[n].obligation.clone());\n             error_stack.extend(self.nodes[n].dependants.iter().map(|x| x.get()));\n \n@@ -359,12 +407,13 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n                 None => break\n             };\n \n-            match self.nodes[i].state {\n+            let node = &self.nodes[i];\n+\n+            match node.state.get() {\n                 NodeState::Error => continue,\n-                ref mut s => *s = NodeState::Error\n+                _ => node.state.set(NodeState::Error)\n             }\n \n-            let node = &self.nodes[i];\n             error_stack.extend(\n                 node.dependants.iter().cloned().chain(node.parent).map(|x| x.get())\n             );\n@@ -374,41 +423,37 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         trace\n     }\n \n-    fn mark_as_waiting(&mut self) {\n-        for node in &mut self.nodes {\n-            if node.state == NodeState::Waiting {\n-                node.state = NodeState::Success;\n+    /// Marks all nodes that depend on a pending node as \"waiting\".\n+    fn mark_as_waiting(&self) {\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Waiting {\n+                node.state.set(NodeState::Success);\n             }\n         }\n \n-        let mut undone_stack = self.scratch.take().unwrap();\n-        undone_stack.extend(\n-            self.nodes.iter().enumerate()\n-                .filter(|&(_i, n)| n.state == NodeState::Pending)\n-                .map(|(i, _n)| i));\n-\n-        loop {\n-            // non-standard `while let` to bypass #6393\n-            let i = match undone_stack.pop() {\n-                Some(i) => i,\n-                None => break\n-            };\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Pending {\n+                self.mark_as_waiting_from(node)\n+            }\n+        }\n+    }\n \n-            match self.nodes[i].state {\n-                NodeState::Pending | NodeState::Done => {},\n-                NodeState::Waiting | NodeState::Error => continue,\n-                ref mut s @ NodeState::Success => {\n-                    *s = NodeState::Waiting;\n-                }\n+    fn mark_as_waiting_from(&self, node: &Node<O>) {\n+        match node.state.get() {\n+            NodeState::Pending | NodeState::Done => {},\n+            NodeState::Waiting | NodeState::Error | NodeState::InLoop => return,\n+            NodeState::Success => {\n+                node.state.set(NodeState::Waiting);\n             }\n+        }\n \n-            let node = &self.nodes[i];\n-            undone_stack.extend(\n-                node.dependants.iter().cloned().chain(node.parent).map(|x| x.get())\n-            );\n+        if let Some(parent) = node.parent {\n+            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n         }\n \n-        self.scratch = Some(undone_stack);\n+        for dependant in &node.dependants {\n+            self.mark_as_waiting_from(&self.nodes[dependant.get()]);\n+        }\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts\n@@ -433,12 +478,22 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         //     self.nodes[i - dead_nodes..i] are all dead\n         //     self.nodes[i..] are unchanged\n         for i in 0..self.nodes.len() {\n-            if let NodeState::Done = self.nodes[i].state {\n-                self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+            match self.nodes[i].state.get() {\n+                NodeState::Done => {\n+                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    // FIXME(HashMap): why can't I get my key back?\n+                    self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                }\n+                NodeState::Error => {\n+                    // We *intentionally* remove the node from the cache at this point. Otherwise\n+                    // tests must come up with a different type on every type error they\n+                    // check against.\n+                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                }\n+                _ => {}\n             }\n \n             if self.nodes[i].is_popped() {\n-                self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n                 node_rewrites[i] = nodes_len;\n                 dead_nodes += 1;\n             } else {\n@@ -461,7 +516,7 @@ impl<O: Debug + ForestObligation> ObligationForest<O> {\n         let successful = (0..dead_nodes)\n                              .map(|_| self.nodes.pop().unwrap())\n                              .flat_map(|node| {\n-                                 match node.state {\n+                                 match node.state.get() {\n                                      NodeState::Error => None,\n                                      NodeState::Done => Some(node.obligation),\n                                      _ => unreachable!()\n@@ -521,15 +576,15 @@ impl<O> Node<O> {\n         Node {\n             obligation: obligation,\n             parent: parent,\n-            state: NodeState::Pending,\n+            state: Cell::new(NodeState::Pending),\n             dependants: vec![],\n         }\n     }\n \n     fn is_popped(&self) -> bool {\n-        match self.state {\n+        match self.state.get() {\n             NodeState::Pending | NodeState::Success | NodeState::Waiting => false,\n-            NodeState::Error | NodeState::Done => true,\n+            NodeState::Error | NodeState::Done | NodeState::InLoop => true,\n         }\n     }\n }"}, {"sha": "499448634acbdbeeea90e6ee39bfdec6371dd5ff", "filename": "src/librustc_data_structures/obligation_forest/tree_index.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct TreeIndex {\n-    index: u32,\n-}\n-\n-impl TreeIndex {\n-    pub fn new(value: usize) -> TreeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        TreeIndex { index: value as u32 }\n-    }\n-\n-    pub fn get(self) -> usize {\n-        self.index as usize\n-    }\n-}"}, {"sha": "2968e8a7ca9968edaeb83f689ab50274800dded0", "filename": "src/test/compile-fail/traits-inductive-overflow-simultaneous.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c39a2ae4439872017574116cb39cff42020fb8f/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs?ref=5c39a2ae4439872017574116cb39cff42020fb8f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #33344, initial version. This example allowed\n+// arbitrary trait bounds to be synthesized.\n+\n+trait Tweedledum: IntoIterator {}\n+trait Tweedledee: IntoIterator {}\n+\n+impl<T: Tweedledum> Tweedledee for T {}\n+impl<T: Tweedledee> Tweedledum for T {}\n+\n+trait Combo: IntoIterator {}\n+impl<T: Tweedledee + Tweedledum> Combo for T {}\n+\n+fn is_ee<T: Combo>(t: T) {\n+    t.into_iter();\n+}\n+\n+fn main() {\n+    is_ee(4);\n+    //~^ ERROR overflow evaluating the requirement `_: Tweedle\n+}"}]}