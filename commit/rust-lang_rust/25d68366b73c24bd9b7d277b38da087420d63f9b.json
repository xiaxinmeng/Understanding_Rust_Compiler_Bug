{"sha": "25d68366b73c24bd9b7d277b38da087420d63f9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDY4MzY2YjczYzI0YmQ5YjdkMjc3YjM4ZGEwODc0MjBkNjNmOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-25T14:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-25T14:41:36Z"}, "message": "auto merge of #12522 : erickt/rust/hash, r=alexcrichton\n\nThis patch series does a couple things:\r\n\r\n* replaces manual `Hash` implementations with `#[deriving(Hash)]`\r\n* adds `Hash` back to `std::prelude`\r\n* minor cleanup of whitespace and variable names.", "tree": {"sha": "20978b14ec9da96f64fbd7659d090c04e99d300d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20978b14ec9da96f64fbd7659d090c04e99d300d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d68366b73c24bd9b7d277b38da087420d63f9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d68366b73c24bd9b7d277b38da087420d63f9b", "html_url": "https://github.com/rust-lang/rust/commit/25d68366b73c24bd9b7d277b38da087420d63f9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d68366b73c24bd9b7d277b38da087420d63f9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d222f03f42fe855d2fadc87010453bcfc2a669e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d222f03f42fe855d2fadc87010453bcfc2a669e1", "html_url": "https://github.com/rust-lang/rust/commit/d222f03f42fe855d2fadc87010453bcfc2a669e1"}, {"sha": "6335a76b6eb473ea399b16fe9309db142d6b68ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/6335a76b6eb473ea399b16fe9309db142d6b68ce", "html_url": "https://github.com/rust-lang/rust/commit/6335a76b6eb473ea399b16fe9309db142d6b68ce"}], "stats": {"total": 151, "additions": 68, "deletions": 83}, "files": [{"sha": "6abe49bc908577747f7d8076cdc51e84d5a979e3", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -98,7 +98,7 @@ fn resize_at(capacity: uint) -> uint {\n     (capacity * 3) / 4\n }\n \n-impl<K:Hash + Eq,V> HashMap<K, V> {\n+impl<K:Hash + Eq, V> HashMap<K, V> {\n     #[inline]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the"}, {"sha": "74d21f114ef64bb842ec7fc7a072cdb559fd5b98", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -722,7 +722,7 @@ pub fn is_null(val: ValueRef) -> bool {\n }\n \n // Used to identify cached monomorphized functions and vtables\n-#[deriving(Eq,Hash)]\n+#[deriving(Eq, Hash)]\n pub enum mono_param_id {\n     mono_precise(ty::t, Option<@~[mono_id]>),\n     mono_any,\n@@ -732,7 +732,7 @@ pub enum mono_param_id {\n               datum::RvalueMode),\n }\n \n-#[deriving(Eq,Hash)]\n+#[deriving(Eq, Hash)]\n pub enum MonoDataClass {\n     MonoBits,    // Anything not treated differently from arbitrary integer data\n     MonoNonNull, // Non-null pointers (used for optional-pointer optimization)\n@@ -754,8 +754,7 @@ pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     }\n }\n \n-\n-#[deriving(Eq,Hash)]\n+#[deriving(Eq, Hash)]\n pub struct mono_id_ {\n     def: ast::DefId,\n     params: ~[mono_param_id]"}, {"sha": "c3b9b898de2a109cc2f02dcfeb4e1cb908cae0d1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -150,7 +150,7 @@ pub struct field_ty {\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-#[deriving(Eq,Hash)]\n+#[deriving(Eq, Hash)]\n pub struct creader_cache_key {\n     cnum: CrateNum,\n     pos: uint,\n@@ -4926,13 +4926,11 @@ pub fn trait_method_of_method(tcx: ctxt,\n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n-    use std::hash::{sip, Hash};\n-\n-    let mut hash = sip::SipState::new(0, 0);\n-    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut hash) } );\n-    macro_rules! hash( ($e:expr) => { $e.hash(&mut hash) } );\n+    let mut state = sip::SipState::new(0, 0);\n+    macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n+    macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n \n-    let region = |_hash: &mut sip::SipState, r: Region| {\n+    let region = |_state: &mut sip::SipState, r: Region| {\n         match r {\n             ReStatic => {}\n \n@@ -4946,27 +4944,27 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             }\n         }\n     };\n-    let vstore = |hash: &mut sip::SipState, v: vstore| {\n+    let vstore = |state: &mut sip::SipState, v: vstore| {\n         match v {\n-            vstore_fixed(_) => 0u8.hash(hash),\n-            vstore_uniq => 1u8.hash(hash),\n+            vstore_fixed(_) => 0u8.hash(state),\n+            vstore_uniq => 1u8.hash(state),\n             vstore_slice(r) => {\n-                2u8.hash(hash);\n-                region(hash, r);\n+                2u8.hash(state);\n+                region(state, r);\n             }\n         }\n     };\n-    let did = |hash: &mut sip::SipState, did: DefId| {\n+    let did = |state: &mut sip::SipState, did: DefId| {\n         let h = if ast_util::is_local(did) {\n             local_hash.clone()\n         } else {\n             tcx.sess.cstore.get_crate_hash(did.krate)\n         };\n-        h.as_bytes().hash(hash);\n-        did.node.hash(hash);\n+        h.as_bytes().hash(state);\n+        did.node.hash(state);\n     };\n-    let mt = |hash: &mut sip::SipState, mt: mt| {\n-        mt.mutbl.hash(hash);\n+    let mt = |state: &mut sip::SipState, mt: mt| {\n+        mt.mutbl.hash(state);\n     };\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n@@ -5002,17 +5000,17 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             }\n             ty_vec(m, v) => {\n                 byte!(11);\n-                mt(&mut hash, m);\n-                vstore(&mut hash, v);\n+                mt(&mut state, m);\n+                vstore(&mut state, v);\n             }\n             ty_ptr(m) => {\n                 byte!(12);\n-                mt(&mut hash, m);\n+                mt(&mut state, m);\n             }\n             ty_rptr(r, m) => {\n                 byte!(13);\n-                region(&mut hash, r);\n-                mt(&mut hash, m);\n+                region(&mut state, r);\n+                mt(&mut state, m);\n             }\n             ty_bare_fn(ref b) => {\n                 byte!(14);\n@@ -5025,24 +5023,24 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n                 hash!(c.sigil);\n                 hash!(c.onceness);\n                 hash!(c.bounds);\n-                region(&mut hash, c.region);\n+                region(&mut state, c.region);\n             }\n             ty_trait(d, _, store, m, bounds) => {\n                 byte!(17);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n                 match store {\n                     UniqTraitStore => byte!(0),\n                     RegionTraitStore(r) => {\n                         byte!(1)\n-                        region(&mut hash, r);\n+                        region(&mut state, r);\n                     }\n                 }\n                 hash!(m);\n                 hash!(bounds);\n             }\n             ty_struct(d, _) => {\n                 byte!(18);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n             }\n             ty_tup(ref inner) => {\n                 byte!(19);\n@@ -5051,22 +5049,22 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n             ty_param(p) => {\n                 byte!(20);\n                 hash!(p.idx);\n-                did(&mut hash, p.def_id);\n+                did(&mut state, p.def_id);\n             }\n             ty_self(d) => {\n                 byte!(21);\n-                did(&mut hash, d);\n+                did(&mut state, d);\n             }\n             ty_infer(_) => unreachable!(),\n             ty_err => byte!(23),\n             ty_unboxed_vec(m) => {\n                 byte!(24);\n-                mt(&mut hash, m);\n+                mt(&mut state, m);\n             }\n         }\n     });\n \n-    hash.result()\n+    state.result()\n }\n \n impl Variance {"}, {"sha": "d7b6ab250781e865587998ffffae574ef5bda263", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -18,13 +18,12 @@ use str::OwnedStr;\n use container::Container;\n use cast;\n use fmt;\n-use hash::{Hash, sip};\n use iter::Iterator;\n use vec::{ImmutableVector, MutableVector, Vector};\n use option::{Option, Some, None};\n \n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq)]\n+#[deriving(Clone, Eq, Ord, TotalOrd, TotalEq, Hash)]\n pub struct Ascii { priv chr: u8 }\n \n impl Ascii {\n@@ -306,13 +305,6 @@ impl IntoStr for ~[Ascii] {\n     }\n }\n \n-impl Hash for Ascii {\n-    #[inline]\n-    fn hash(&self, s: &mut sip::SipState) {\n-        self.to_byte().hash(s)\n-    }\n-}\n-\n /// Trait to convert to an owned byte array by consuming self\n pub trait IntoBytes {\n     /// Converts to an owned byte array by consuming self"}, {"sha": "d112b504c98f1a005e6a8ca2e062ea73d18c2c7d", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -55,7 +55,6 @@ pub struct SocketAddr {\n     port: Port,\n }\n \n-\n impl fmt::Show for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {"}, {"sha": "d38daf68cbc59039c8bf101ed0d4b32acefed6e2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -151,7 +151,6 @@ pub mod container;\n pub mod default;\n pub mod any;\n \n-\n /* Common data structures */\n \n pub mod option;"}, {"sha": "c01f3721fad9aadf4ed7509f6554d90122c5ec49", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::{Hash, sip};\n use std::fmt;\n use std::fmt::Show;\n \n #[deriving(Eq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, Hash)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -267,12 +266,6 @@ impl AbiSet {\n     }\n }\n \n-impl Hash for Abi {\n-    fn hash(&self, s: &mut sip::SipState) {\n-        self.index().hash(s)\n-    }\n-}\n-\n impl fmt::Show for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.data().name.fmt(f)"}, {"sha": "c095cec1e7df30e629f92071b115260e1ac2ca6f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -107,7 +107,7 @@ pub struct SCTable {\n pub static EMPTY_CTXT : SyntaxContext = 0;\n pub static ILLEGAL_CTXT : SyntaxContext = 1;\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -332,7 +332,7 @@ impl Eq for MetaItem_ {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Block {\n     view_items: ~[ViewItem],\n     stmts: ~[@Stmt],\n@@ -467,7 +467,7 @@ pub enum Stmt_ {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct Local {\n     ty: P<Ty>,\n     pat: @Pat,\n@@ -478,7 +478,7 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n@@ -514,7 +514,7 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Expr {\n     id: NodeId,\n     node: Expr_,\n@@ -732,7 +732,7 @@ pub struct MutTy {\n     mutbl: Mutability,\n }\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct TypeField {\n     ident: Ident,\n     mt: MutTy,\n@@ -836,7 +836,7 @@ impl fmt::Show for Onceness {\n     }\n }\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n     sigil: Sigil,\n     region: Option<Lifetime>,\n@@ -967,7 +967,7 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct Method {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -987,7 +987,7 @@ pub struct Mod {\n     items: ~[@Item],\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n     abis: AbiSet,\n     view_items: ~[ViewItem],\n@@ -1074,14 +1074,14 @@ pub type Attribute = Spanned<Attribute_>;\n // Distinguishes between Attributes that decorate items and Attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct Attribute_ {\n     style: AttrStyle,\n     value: @MetaItem,\n@@ -1095,13 +1095,13 @@ pub struct Attribute_ {\n   If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct TraitRef {\n     path: Path,\n     ref_id: NodeId,\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum Visibility {\n     Public,\n     Private,\n@@ -1117,7 +1117,7 @@ impl Visibility {\n     }\n }\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub struct StructField_ {\n     kind: StructFieldKind,\n     id: NodeId,\n@@ -1127,13 +1127,13 @@ pub struct StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[deriving(Clone, Eq, Encodable, Decodable,Hash)]\n+#[deriving(Clone, Eq, Encodable, Decodable, Hash)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     UnnamedField // element of a tuple-like struct\n }\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct StructDef {\n     fields: ~[StructField], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n@@ -1173,7 +1173,7 @@ pub enum Item_ {\n     ItemMac(Mac),\n }\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub struct ForeignItem {\n     ident: Ident,\n     attrs: ~[Attribute],\n@@ -1183,7 +1183,7 @@ pub struct ForeignItem {\n     vis: Visibility,\n }\n \n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1192,7 +1192,7 @@ pub enum ForeignItem_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[deriving(Eq, Encodable, Decodable,Hash)]\n+#[deriving(Eq, Encodable, Decodable, Hash)]\n pub enum InlinedItem {\n     IIItem(@Item),\n     IIMethod(DefId /* impl id */, bool /* is provided */, @Method),"}, {"sha": "79ccc8df0f3feb1df8dd33e68f11c9770ebe97b7", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -38,7 +38,7 @@ pub struct BytePos(u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[deriving(Eq,Hash, Ord)]\n+#[deriving(Eq, Hash, Ord)]\n pub struct CharPos(uint);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix"}, {"sha": "4b5a05f4cb875c3400cd3ef3aea0ec6259621e6e", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -75,8 +75,7 @@ impl<T:Eq + Hash + Freeze + Clone + 'static> Interner<T> {\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + Equiv<T>>(&self, val: &Q)\n-                                              -> Option<Name> {\n+    pub fn find_equiv<Q:Hash + Equiv<T>>(&self, val: &Q) -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {\n             Some(v) => Some(*v),\n@@ -207,8 +206,7 @@ impl StrInterner {\n         vect.get().len()\n     }\n \n-    pub fn find_equiv<Q:Hash + Equiv<RcStr>>(&self, val: &Q)\n-                                                         -> Option<Name> {\n+    pub fn find_equiv<Q:Hash + Equiv<RcStr>>(&self, val: &Q) -> Option<Name> {\n         let map = self.map.borrow();\n         match map.get().find_equiv(val) {\n             Some(v) => Some(*v),"}, {"sha": "af60a35cbf80cb4fa895ddb4e0d9daf648f78a09", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -27,18 +27,21 @@ mod submod {\n     // function calls, then being in a submodule will (correctly)\n     // cause errors about unrecognised module `std` (or `extra`)\n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+               Hash,\n                Clone, DeepClone,\n                Show, Rand,\n                Encodable, Decodable)]\n     enum A { A1(uint), A2(int) }\n \n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+               Hash,\n                Clone, DeepClone,\n                Show, Rand,\n                Encodable, Decodable)]\n     struct B { x: uint, y: int }\n \n     #[deriving(Eq, Ord, TotalEq, TotalOrd,\n+               Hash,\n                Clone, DeepClone,\n                Show, Rand,\n                Encodable, Decodable)]"}, {"sha": "069f50f89f4ae85837a860812ddff1645a93ba92", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -10,8 +10,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n-#[deriving(Clone)]\n+use std::hash::hash;\n+\n+#[deriving(Eq, Clone, Hash)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -22,4 +23,5 @@ pub fn main() {\n \n     a == a;    // check for Eq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n+    hash(&a);  // check for Hash impl w/o testing its correctness\n }"}, {"sha": "069f50f89f4ae85837a860812ddff1645a93ba92", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -10,7 +10,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq, Clone)]\n+use std::hash::hash;\n+\n+#[deriving(Eq, Clone, Hash)]\n struct Foo {\n     bar: uint,\n     baz: int\n@@ -21,4 +23,5 @@ pub fn main() {\n \n     a == a;    // check for Eq impl w/o testing its correctness\n     a.clone(); // check for Clone impl w/o testing its correctness\n+    hash(&a);  // check for Hash impl w/o testing its correctness\n }"}, {"sha": "2ea558b566ec8e154c4c3a19d13b7d25b05c2b09", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d68366b73c24bd9b7d277b38da087420d63f9b/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=25d68366b73c24bd9b7d277b38da087420d63f9b", "patch": "@@ -10,8 +10,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[deriving(Eq)]\n-#[deriving(Hash)]\n+#[deriving(Eq, Hash)]\n struct Foo<T> {\n     x: int,\n     y: T,"}]}