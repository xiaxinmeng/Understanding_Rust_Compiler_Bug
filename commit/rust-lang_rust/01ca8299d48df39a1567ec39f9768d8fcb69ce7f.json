{"sha": "01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxY2E4Mjk5ZDQ4ZGYzOWExNTY3ZWMzOWY5NzY4ZDhmY2I2OWNlN2Y=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-02T22:31:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-02T22:31:14Z"}, "message": "Rollup merge of #77264 - fusion-engineering-forks:skip-local-stdio, r=dtolnay\n\nOnly use LOCAL_{STDOUT,STDERR} when set_{print/panic} is used.\n\nThe thread local `LOCAL_STDOUT` and `LOCAL_STDERR` are only used by the `test` crate to capture output from tests when running them in the same process in differen threads. However, every program will check these variables on every print, even outside of testing.\n\nThis involves allocating a thread local key, and registering a thread local destructor. This can be somewhat expensive.\n\nThis change keeps a global flag (`LOCAL_STREAMS`) which will be set to `true` when either of these local streams is used. (So, effectively only in test and benchmark runs.) When this flag is off, these thread locals are not even looked at and therefore will not be initialized on the first output on every thread, which also means no thread local destructors will be registered.\n\n---\n\nTogether with https://github.com/rust-lang/rust/pull/77154, this should make output a little bit more efficient.", "tree": {"sha": "2674347aaac089a335c3d6aa7c4b98109c1adf0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2674347aaac089a335c3d6aa7c4b98109c1adf0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfd6oyCRBK7hj4Ov3rIwAAdHIIAHdJAKVcmFadYRUHu4rZd6ZF\n5c24756C39odwMQWAJe4m8wfwBrgmcWgyKxKmyntpBXjeEfjsMSw9TxjWSyqs/zQ\n5xvmZf9TUN/+dc5mVetdPJOL3IUlmo58LwM1bPX6WDEbQXRSe9WTf3aBpTsYLQg1\nBLotG5zEJ1xGBZvpYGAyFBGTyEGUfzk6QhkPlMDRODtWbs9YRwb/HFDAaPXaWTXE\nm3ISeLMNcJ4roPp9owALjzNIUwP9Z1b72b8Qxu3nfGmKsPs8+HlxlBiiB4M1iLMW\nSq/5Q2qXbtP7+nAmLdAlX4Xwd86aD50F13YgyZ0/1Qc0iMxE04bfHuJvww2Q8mE=\n=u3EK\n-----END PGP SIGNATURE-----\n", "payload": "tree 2674347aaac089a335c3d6aa7c4b98109c1adf0c\nparent 65228686649c68f491d3b763e9dde52c23fea9d7\nparent de597fca40d129435c53a69c6662d7bfac29771d\nauthor Jonas Schievink <jonasschievink@gmail.com> 1601677874 +0200\ncommitter GitHub <noreply@github.com> 1601677874 +0200\n\nRollup merge of #77264 - fusion-engineering-forks:skip-local-stdio, r=dtolnay\n\nOnly use LOCAL_{STDOUT,STDERR} when set_{print/panic} is used.\n\nThe thread local `LOCAL_STDOUT` and `LOCAL_STDERR` are only used by the `test` crate to capture output from tests when running them in the same process in differen threads. However, every program will check these variables on every print, even outside of testing.\n\nThis involves allocating a thread local key, and registering a thread local destructor. This can be somewhat expensive.\n\nThis change keeps a global flag (`LOCAL_STREAMS`) which will be set to `true` when either of these local streams is used. (So, effectively only in test and benchmark runs.) When this flag is off, these thread locals are not even looked at and therefore will not be initialized on the first output on every thread, which also means no thread local destructors will be registered.\n\n---\n\nTogether with https://github.com/rust-lang/rust/pull/77154, this should make output a little bit more efficient.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "html_url": "https://github.com/rust-lang/rust/commit/01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ca8299d48df39a1567ec39f9768d8fcb69ce7f/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65228686649c68f491d3b763e9dde52c23fea9d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/65228686649c68f491d3b763e9dde52c23fea9d7", "html_url": "https://github.com/rust-lang/rust/commit/65228686649c68f491d3b763e9dde52c23fea9d7"}, {"sha": "de597fca40d129435c53a69c6662d7bfac29771d", "url": "https://api.github.com/repos/rust-lang/rust/commits/de597fca40d129435c53a69c6662d7bfac29771d", "html_url": "https://github.com/rust-lang/rust/commit/de597fca40d129435c53a69c6662d7bfac29771d"}], "stats": {"total": 84, "additions": 61, "deletions": 23}, "files": [{"sha": "36b49401591f5243b4849425e22ed2c717a2be70", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/01ca8299d48df39a1567ec39f9768d8fcb69ce7f/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca8299d48df39a1567ec39f9768d8fcb69ce7f/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "patch": "@@ -9,26 +9,41 @@ use crate::cell::RefCell;\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n+use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Mutex, MutexGuard};\n use crate::sys::stdio;\n use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n thread_local! {\n-    /// Stdout used by print! and println! macros\n+    /// Used by the test crate to capture the output of the print! and println! macros.\n     static LOCAL_STDOUT: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n thread_local! {\n-    /// Stderr used by eprint! and eprintln! macros, and panics\n+    /// Used by the test crate to capture the output of the eprint! and eprintln! macros, and panics.\n     static LOCAL_STDERR: RefCell<Option<Box<dyn Write + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n+/// Flag to indicate LOCAL_STDOUT and/or LOCAL_STDERR is used.\n+///\n+/// If both are None and were never set on any thread, this flag is set to\n+/// false, and both LOCAL_STDOUT and LOCAL_STDOUT can be safely ignored on all\n+/// threads, saving some time and memory registering an unused thread local.\n+///\n+/// Note about memory ordering: This contains information about whether two\n+/// thread local variables might be in use. Although this is a global flag, the\n+/// memory ordering between threads does not matter: we only want this flag to\n+/// have a consistent order between set_print/set_panic and print_to *within\n+/// the same thread*. Within the same thread, things always have a perfectly\n+/// consistent order. So Ordering::Relaxed is fine.\n+static LOCAL_STREAMS: AtomicBool = AtomicBool::new(false);\n+\n /// A handle to a raw instance of the standard input stream of this process.\n ///\n /// This handle is not synchronized or buffered in any fashion. Constructed via\n@@ -890,10 +905,18 @@ impl fmt::Debug for StderrLock<'_> {\n #[doc(hidden)]\n pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n+        // LOCAL_STDERR is definitely None since LOCAL_STREAMS is false.\n+        return None;\n+    }\n+    let s = LOCAL_STDERR.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n+    s\n }\n \n /// Resets the thread-local stdout handle to the specified writer\n@@ -913,10 +936,18 @@ pub fn set_panic(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write +\n #[doc(hidden)]\n pub fn set_print(sink: Option<Box<dyn Write + Send>>) -> Option<Box<dyn Write + Send>> {\n     use crate::mem;\n-    LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n+    if sink.is_none() && !LOCAL_STREAMS.load(Ordering::Relaxed) {\n+        // LOCAL_STDOUT is definitely None since LOCAL_STREAMS is false.\n+        return None;\n+    }\n+    let s = LOCAL_STDOUT.with(move |slot| mem::replace(&mut *slot.borrow_mut(), sink)).and_then(\n+        |mut s| {\n+            let _ = s.flush();\n+            Some(s)\n+        },\n+    );\n+    LOCAL_STREAMS.store(true, Ordering::Relaxed);\n+    s\n }\n \n /// Write `args` to output stream `local_s` if possible, `global_s`\n@@ -937,20 +968,26 @@ fn print_to<T>(\n ) where\n     T: Write,\n {\n-    let result = local_s\n-        .try_with(|s| {\n-            // Note that we completely remove a local sink to write to in case\n-            // our printing recursively panics/prints, so the recursive\n-            // panic/print goes to the global sink instead of our local sink.\n-            let prev = s.borrow_mut().take();\n-            if let Some(mut w) = prev {\n-                let result = w.write_fmt(args);\n-                *s.borrow_mut() = Some(w);\n-                return result;\n-            }\n-            global_s().write_fmt(args)\n+    let result = LOCAL_STREAMS\n+        .load(Ordering::Relaxed)\n+        .then(|| {\n+            local_s\n+                .try_with(|s| {\n+                    // Note that we completely remove a local sink to write to in case\n+                    // our printing recursively panics/prints, so the recursive\n+                    // panic/print goes to the global sink instead of our local sink.\n+                    let prev = s.borrow_mut().take();\n+                    if let Some(mut w) = prev {\n+                        let result = w.write_fmt(args);\n+                        *s.borrow_mut() = Some(w);\n+                        return result;\n+                    }\n+                    global_s().write_fmt(args)\n+                })\n+                .ok()\n         })\n-        .unwrap_or_else(|_| global_s().write_fmt(args));\n+        .flatten()\n+        .unwrap_or_else(|| global_s().write_fmt(args));\n \n     if let Err(e) = result {\n         panic!(\"failed printing to {}: {}\", label, e);"}, {"sha": "b2bd5f4da5012aea5cbc0a3d85ed66e639aef0de", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01ca8299d48df39a1567ec39f9768d8fcb69ce7f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ca8299d48df39a1567ec39f9768d8fcb69ce7f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=01ca8299d48df39a1567ec39f9768d8fcb69ce7f", "patch": "@@ -226,6 +226,7 @@\n #![feature(asm)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n+#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n #![feature(cfg_accessible)]"}]}