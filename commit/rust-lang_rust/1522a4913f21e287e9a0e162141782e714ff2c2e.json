{"sha": "1522a4913f21e287e9a0e162141782e714ff2c2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MjJhNDkxM2YyMWUyODdlOWEwZTE2MjE0MTc4MmU3MTRmZjJjMmU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-05-03T12:13:50Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-05-03T12:13:50Z"}, "message": "Run rustfmt", "tree": {"sha": "282400c5ea3d3f569371ce18091eff5ab5e8d7c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/282400c5ea3d3f569371ce18091eff5ab5e8d7c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1522a4913f21e287e9a0e162141782e714ff2c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1522a4913f21e287e9a0e162141782e714ff2c2e", "html_url": "https://github.com/rust-lang/rust/commit/1522a4913f21e287e9a0e162141782e714ff2c2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1522a4913f21e287e9a0e162141782e714ff2c2e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5295fe47927481245d59a2a3fb6316ccb596530a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5295fe47927481245d59a2a3fb6316ccb596530a", "html_url": "https://github.com/rust-lang/rust/commit/5295fe47927481245d59a2a3fb6316ccb596530a"}], "stats": {"total": 188, "additions": 85, "deletions": 103}, "files": [{"sha": "e094e8da3fcacb90898e158da79fd7604e308c49", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -299,7 +299,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                         tcx: self.tcx,\n                         tables: self.tcx.typeck_tables_of(def_id),\n                         needed_resolution: false,\n-                        substs,\n+                        substs: substs,\n                     };\n                     let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                         self.tcx.mir_const_qualif(def_id);"}, {"sha": "b2183ff1c73d0510255a1a14c40189c72400cbe1", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -54,9 +54,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,\n-                            EQ_OP,\n-                            e.span,\n-                            &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                          EQ_OP,\n+                          e.span,\n+                          &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n                 return;\n             }\n             let (trait_id, requires_ref) = match op.node {\n@@ -91,32 +91,30 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                         // either operator autorefs or both args are copyable\n                         if (requires_ref || (lcpy && rcpy)) && implements_trait(cx, lty, trait_id, &[rty], None) {\n                             span_lint_and_then(cx,\n-                                                OP_REF,\n-                                                e.span,\n-                                                \"needlessly taken reference of both operands\",\n-                                                |db| {\n+                                               OP_REF,\n+                                               e.span,\n+                                               \"needlessly taken reference of both operands\",\n+                                               |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 multispan_sugg(db,\n-                                                \"use the values directly\".to_string(),\n-                                                vec![(left.span, lsnip),\n+                                               \"use the values directly\".to_string(),\n+                                               vec![(left.span, lsnip),\n                                                     (right.span, rsnip)]);\n                             })\n-                        } else if lcpy && !rcpy && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n-                            span_lint_and_then(cx,\n-                                                OP_REF,\n-                                                e.span,\n-                                                \"needlessly taken reference of left operand\",\n-                                                |db| {\n+                        } else if lcpy && !rcpy &&\n+                                  implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                            span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n                             })\n-                        } else if !lcpy && rcpy && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                        } else if !lcpy && rcpy &&\n+                                  implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n                             span_lint_and_then(cx,\n-                                                OP_REF,\n-                                                e.span,\n-                                                \"needlessly taken reference of right operand\",\n-                                                |db| {\n+                                               OP_REF,\n+                                               e.span,\n+                                               \"needlessly taken reference of right operand\",\n+                                               |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);\n                             })\n@@ -126,7 +124,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (&ExprAddrOf(_, ref l), _) => {\n                         let lty = cx.tables.expr_ty(l);\n                         let lcpy = is_copy(cx, lty, parent);\n-                        if (requires_ref || lcpy) && implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n+                        if (requires_ref || lcpy) &&\n+                           implements_trait(cx, lty, trait_id, &[cx.tables.expr_ty(right)], None) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"needlessly taken reference of left operand\", |db| {\n                                 let lsnip = snippet(cx, l.span, \"...\").to_string();\n                                 db.span_suggestion(left.span, \"use the left value directly\", lsnip);\n@@ -137,7 +136,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n                     (_, &ExprAddrOf(_, ref r)) => {\n                         let rty = cx.tables.expr_ty(r);\n                         let rcpy = is_copy(cx, rty, parent);\n-                        if (requires_ref || rcpy) && implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n+                        if (requires_ref || rcpy) &&\n+                           implements_trait(cx, cx.tables.expr_ty(left), trait_id, &[rty], None) {\n                             span_lint_and_then(cx, OP_REF, e.span, \"taken reference of right operand\", |db| {\n                                 let rsnip = snippet(cx, r.span, \"...\").to_string();\n                                 db.span_suggestion(right.span, \"use the right value directly\", rsnip);"}, {"sha": "148eb616be0caf9b748a899f757fca9e43c33ffa", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -199,7 +199,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     /// Check the inherent impl's items for an `is_empty(self)` method.\n     fn has_is_empty_impl(cx: &LateContext, id: DefId) -> bool {\n-        cx.tcx.inherent_impls(id)\n+        cx.tcx\n+            .inherent_impls(id)\n             .iter()\n             .any(|imp| cx.tcx.associated_items(*imp).any(|item| is_is_empty(cx, &item)))\n     }"}, {"sha": "076bf82b687af1e4516c63b2d80b0e701b5a36f0", "filename": "clippy_lints/src/needless_continue.rs", "status": "modified", "additions": 59, "deletions": 68, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fneedless_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fneedless_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_continue.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -29,7 +29,7 @@\n //! This lint is **warn** by default.\n use rustc::lint::*;\n use syntax::ast;\n-use syntax::codemap::{original_sp,DUMMY_SP};\n+use syntax::codemap::{original_sp, DUMMY_SP};\n use std::borrow::Cow;\n \n use utils::{in_macro, span_help_and_lint, snippet_block, snippet, trim_multiline};\n@@ -163,7 +163,7 @@ impl EarlyLintPass for NeedlessContinue {\n  *           // region C\n  *       }\n  *     }\n- */\n+ * */\n \n /// Given an expression, returns true if either of the following is true\n ///\n@@ -181,23 +181,27 @@ fn needless_continue_in_else(else_expr: &ast::Expr) -> bool {\n fn is_first_block_stmt_continue(block: &ast::Block) -> bool {\n     block.stmts.get(0).map_or(false, |stmt| match stmt.node {\n         ast::StmtKind::Semi(ref e) |\n-        ast::StmtKind::Expr(ref e) => if let ast::ExprKind::Continue(_) = e.node {\n-            true\n-        } else {\n-            false\n+        ast::StmtKind::Expr(ref e) => {\n+            if let ast::ExprKind::Continue(_) = e.node {\n+                true\n+            } else {\n+                false\n+            }\n         },\n         _ => false,\n     })\n }\n \n /// If `expr` is a loop expression (while/while let/for/loop), calls `func` with\n /// the AST object representing the loop block of `expr`.\n-fn with_loop_block<F>(expr: &ast::Expr, mut func: F) where F: FnMut(&ast::Block) {\n+fn with_loop_block<F>(expr: &ast::Expr, mut func: F)\n+    where F: FnMut(&ast::Block)\n+{\n     match expr.node {\n-        ast::ExprKind::While(_, ref loop_block, _)       |\n+        ast::ExprKind::While(_, ref loop_block, _) |\n         ast::ExprKind::WhileLet(_, _, ref loop_block, _) |\n-        ast::ExprKind::ForLoop( _, _, ref loop_block, _) |\n-        ast::ExprKind::Loop(ref loop_block, _)           => func(loop_block),\n+        ast::ExprKind::ForLoop(_, _, ref loop_block, _) |\n+        ast::ExprKind::Loop(ref loop_block, _) => func(loop_block),\n         _ => {},\n     }\n }\n@@ -211,15 +215,16 @@ fn with_loop_block<F>(expr: &ast::Expr, mut func: F) where F: FnMut(&ast::Block)\n /// - The `else` expression.\n ///\n fn with_if_expr<F>(stmt: &ast::Stmt, mut func: F)\n-        where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr) {\n+    where F: FnMut(&ast::Expr, &ast::Expr, &ast::Block, &ast::Expr)\n+{\n     match stmt.node {\n         ast::StmtKind::Semi(ref e) |\n         ast::StmtKind::Expr(ref e) => {\n             if let ast::ExprKind::If(ref cond, ref if_block, Some(ref else_expr)) = e.node {\n                 func(e, cond, if_block, else_expr);\n             }\n         },\n-        _ => { },\n+        _ => {},\n     }\n }\n \n@@ -249,45 +254,37 @@ struct LintData<'a> {\n \n const MSG_REDUNDANT_ELSE_BLOCK: &'static str = \"This else block is redundant.\\n\";\n \n-const MSG_ELSE_BLOCK_NOT_NEEDED: &'static str = \"There is no need for an explicit `else` block for this `if` expression\\n\";\n+const MSG_ELSE_BLOCK_NOT_NEEDED: &'static str = \"There is no need for an explicit `else` block for this `if` \\\n+                                                 expression\\n\";\n \n-const DROP_ELSE_BLOCK_AND_MERGE_MSG: &'static str =\n-    \"Consider dropping the else clause and merging the code that follows (in the loop) with the if block, like so:\\n\";\n+const DROP_ELSE_BLOCK_AND_MERGE_MSG: &'static str = \"Consider dropping the else clause and merging the code that \\\n+                                                     follows (in the loop) with the if block, like so:\\n\";\n \n-const DROP_ELSE_BLOCK_MSG: &'static str =\n-    \"Consider dropping the else clause, and moving out the code in the else block, like so:\\n\";\n+const DROP_ELSE_BLOCK_MSG: &'static str = \"Consider dropping the else clause, and moving out the code in the else \\\n+                                           block, like so:\\n\";\n \n \n-fn emit_warning<'a>(ctx: &EarlyContext,\n-                    data: &'a LintData,\n-                    header: &str,\n-                    typ: LintType) {\n+fn emit_warning<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str, typ: LintType) {\n \n     // snip    is the whole *help* message that appears after the warning.\n     // message is the warning message.\n     // expr    is the expression which the lint warning message refers to.\n     let (snip, message, expr) = match typ {\n         LintType::ContinueInsideElseBlock => {\n-            (suggestion_snippet_for_continue_inside_else(ctx, data, header),\n-             MSG_REDUNDANT_ELSE_BLOCK,\n-             data.else_expr)\n+            (suggestion_snippet_for_continue_inside_else(ctx, data, header), MSG_REDUNDANT_ELSE_BLOCK, data.else_expr)\n         },\n         LintType::ContinueInsideThenBlock => {\n-            (suggestion_snippet_for_continue_inside_if(ctx, data, header),\n-             MSG_ELSE_BLOCK_NOT_NEEDED,\n-             data.if_expr)\n-        }\n+            (suggestion_snippet_for_continue_inside_if(ctx, data, header), MSG_ELSE_BLOCK_NOT_NEEDED, data.if_expr)\n+        },\n     };\n     span_help_and_lint(ctx, NEEDLESS_CONTINUE, expr.span, message, &snip);\n }\n \n-fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n-                                                data: &'a LintData,\n-                                                header: &str) -> String {\n+fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n \n-    let if_code   = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n-                                   /*  ^^^^--- Four spaces of indentation. */\n+    let if_code = format!(\"if {} {{\\n    continue;\\n}}\\n\", cond_code);\n+    /* ^^^^--- Four spaces of indentation. */\n     // region B\n     let else_code = snippet(ctx, data.else_expr.span, \"..\").into_owned();\n     let else_code = erode_block(&else_code);\n@@ -300,12 +297,9 @@ fn suggestion_snippet_for_continue_inside_if<'a>(ctx: &EarlyContext,\n     ret\n }\n \n-fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n-                                                   data: &'a LintData,\n-                                                   header: &str) -> String\n-{\n+fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext, data: &'a LintData, header: &str) -> String {\n     let cond_code = snippet(ctx, data.if_cond.span, \"..\");\n-    let mut if_code   = format!(\"if {} {{\\n\", cond_code);\n+    let mut if_code = format!(\"if {} {{\\n\", cond_code);\n \n     // Region B\n     let block_code = &snippet(ctx, data.if_block.span, \"..\").into_owned();\n@@ -318,13 +312,12 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n     // These is the code in the loop block that follows the if/else construction\n     // we are complaining about. We want to pull all of this code into the\n     // `then` block of the `if` statement.\n-    let to_annex = data.block_stmts[data.stmt_idx+1..]\n-                   .iter()\n-                   .map(|stmt| {\n-                        original_sp(stmt.span, DUMMY_SP)\n-                    })\n-                   .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n-                   .collect::<Vec<_>>().join(\"\\n\");\n+    let to_annex = data.block_stmts[data.stmt_idx + 1..]\n+        .iter()\n+        .map(|stmt| original_sp(stmt.span, DUMMY_SP))\n+        .map(|span| snippet_block(ctx, span, \"..\").into_owned())\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n \n     let mut ret = String::from(header);\n \n@@ -336,24 +329,22 @@ fn suggestion_snippet_for_continue_inside_else<'a>(ctx: &EarlyContext,\n }\n \n fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n-    with_loop_block(expr, |loop_block| {\n-        for (i, stmt) in loop_block.stmts.iter().enumerate() {\n-            with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n-                let data = &LintData {\n-                    stmt_idx:    i,\n-                    if_expr:     if_expr,\n-                    if_cond:     cond,\n-                    if_block:    then_block,\n-                    else_expr:   else_expr,\n-                    block_stmts: &loop_block.stmts,\n-                };\n-                if needless_continue_in_else(else_expr) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n-                } else if is_first_block_stmt_continue(then_block) {\n-                    emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n-                }\n-            });\n-        }\n+    with_loop_block(expr, |loop_block| for (i, stmt) in loop_block.stmts.iter().enumerate() {\n+        with_if_expr(stmt, |if_expr, cond, then_block, else_expr| {\n+            let data = &LintData {\n+                stmt_idx: i,\n+                if_expr: if_expr,\n+                if_cond: cond,\n+                if_block: then_block,\n+                else_expr: else_expr,\n+                block_stmts: &loop_block.stmts,\n+            };\n+            if needless_continue_in_else(else_expr) {\n+                emit_warning(ctx, data, DROP_ELSE_BLOCK_AND_MERGE_MSG, LintType::ContinueInsideElseBlock);\n+            } else if is_first_block_stmt_continue(then_block) {\n+                emit_warning(ctx, data, DROP_ELSE_BLOCK_MSG, LintType::ContinueInsideThenBlock);\n+            }\n+        });\n     });\n }\n \n@@ -378,7 +369,7 @@ fn check_and_warn<'a>(ctx: &EarlyContext, expr: &'a ast::Expr) {\n /// an empty string will be returned in that case.\n pub fn erode_from_back(s: &str) -> String {\n     let mut ret = String::from(s);\n-    while ret.pop().map_or(false, |c| c != '}') { }\n+    while ret.pop().map_or(false, |c| c != '}') {}\n     while let Some(c) = ret.pop() {\n         if !c.is_whitespace() {\n             ret.push(c);\n@@ -409,10 +400,10 @@ pub fn erode_from_back(s: &str) -> String {\n ///\n pub fn erode_from_front(s: &str) -> String {\n     s.chars()\n-     .skip_while(|c| c.is_whitespace())\n-     .skip_while(|c| *c == '{')\n-     .skip_while(|c| *c == '\\n')\n-     .collect::<String>()\n+        .skip_while(|c| c.is_whitespace())\n+        .skip_while(|c| *c == '{')\n+        .skip_while(|c| *c == '\\n')\n+        .collect::<String>()\n }\n \n /// If `s` contains the code for a block, delimited by braces, this function"}, {"sha": "f443ea1f9dc5c1a3fe037c1c09e61b539891cd94", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -284,16 +284,7 @@ impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(\n-        &mut self,\n-        _: NodeId,\n-        _: Span,\n-        _: mc::cmt<'tcx>,\n-        _: ty::Region,\n-        _: ty::BorrowKind,\n-        _: euv::LoanCause\n-    ) {\n-    }\n+    fn borrow(&mut self, _: NodeId, _: Span, _: mc::cmt<'tcx>, _: ty::Region, _: ty::BorrowKind, _: euv::LoanCause) {}\n \n     fn mutate(&mut self, _: NodeId, _: Span, _: mc::cmt<'tcx>, _: euv::MutateMode) {}\n "}, {"sha": "2c1043cffa0c7a7beda0fcec4cb51c9324a2772e", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1522a4913f21e287e9a0e162141782e714ff2c2e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=1522a4913f21e287e9a0e162141782e714ff2c2e", "patch": "@@ -978,4 +978,3 @@ pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Opti\n         .infer_ctxt((), Reveal::All)\n         .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n }\n-"}]}