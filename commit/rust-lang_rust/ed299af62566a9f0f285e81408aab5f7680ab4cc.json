{"sha": "ed299af62566a9f0f285e81408aab5f7680ab4cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMjk5YWY2MjU2NmE5ZjBmMjg1ZTgxNDA4YWFiNWY3NjgwYWI0Y2M=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T05:12:39Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-08T16:22:23Z"}, "message": "std: remove fold[lr] in favour of iterators", "tree": {"sha": "39d540d5fa2b0aee7b88859e1644668a96b67be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39d540d5fa2b0aee7b88859e1644668a96b67be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed299af62566a9f0f285e81408aab5f7680ab4cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed299af62566a9f0f285e81408aab5f7680ab4cc", "html_url": "https://github.com/rust-lang/rust/commit/ed299af62566a9f0f285e81408aab5f7680ab4cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed299af62566a9f0f285e81408aab5f7680ab4cc/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "url": "https://api.github.com/repos/rust-lang/rust/commits/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691", "html_url": "https://github.com/rust-lang/rust/commit/65c7c58c8f15189d2e4ca6b166e933c5fe2d0691"}], "stats": {"total": 265, "additions": 72, "deletions": 193}, "files": [{"sha": "7ea6de90fb24f55dc7ec93964dbaebcefd2364f5", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -354,7 +354,7 @@ a single large vector of floats. Each task needs the full vector to perform its\n use extra::arc::ARC;\n \n fn pnorm(nums: &~[float], p: uint) -> float {\n-    (vec::foldl(0.0, *nums, |a,b| a+(*b).pow(p as float) )).pow(1f / (p as float))\n+    nums.iter().fold(0.0, |a,b| a+(*b).pow(p as float) ).pow(1f / (p as float))\n }\n \n fn main() {"}, {"sha": "7fac125243eb0ffded8b56b3ee759f037e309344", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -20,6 +20,7 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::managed;\n use core::old_iter;\n use core::vec;\n@@ -110,7 +111,7 @@ pub fn from_elem<T>(data: T) -> @mut DList<T> {\n \n /// Creates a new dlist from a vector of elements, maintaining the same order\n pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n-    do vec::foldl(DList(), vec) |list,data| {\n+    do vec.iter().fold(DList()) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }"}, {"sha": "0d0b5ea00f0d2b8a69e18697be2183b7e92fc96d", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n \n-use core::vec;\n+use core::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n pub enum List<T> {\n@@ -28,7 +28,7 @@ pub enum MutList<T> {\n \n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(*h, t))\n }\n \n /**"}, {"sha": "0cc1ee9a1d716eff180460ad8007301ddc12c384", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::*;\n use core::vec;\n use core::f64;\n use core::cmp;\n@@ -36,17 +37,17 @@ pub trait Stats {\n \n impl<'self> Stats for &'self [f64] {\n     fn sum(self) -> f64 {\n-        vec::foldl(0.0, self, |p,q| p + *q)\n+        self.iter().fold(0.0, |p,q| p + *q)\n     }\n \n     fn min(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::min(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::min(p, *q))\n     }\n \n     fn max(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::max(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::max(p, *q))\n     }\n \n     fn mean(self) -> f64 {"}, {"sha": "45447d3993c5bf9f9e360618d19ada72d36a6344", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -18,6 +18,7 @@ use middle;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n+use core::iterator::IteratorUtil;\n use core::float;\n use core::hashmap::{HashMap, HashSet};\n use core::vec;\n@@ -72,7 +73,7 @@ pub fn join(a: constness, b: constness) -> constness {\n }\n \n pub fn join_all(cs: &[constness]) -> constness {\n-    vec::foldl(integral_const, cs, |a, b| join(a, *b))\n+    cs.iter().fold(integral_const, |a, b| join(a, *b))\n }\n \n pub fn classify(e: @expr,"}, {"sha": "1fecdf5a338d92fbd228597a001fef36fc331b3e", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -17,6 +17,7 @@ use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n use middle::trans::common::{T_array, T_ptr, T_void};\n \n+use core::iterator::IteratorUtil;\n use core::option::{Option, None, Some};\n use core::uint;\n use core::vec;\n@@ -43,9 +44,8 @@ fn ty_align(ty: TypeRef) -> uint {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n                     1\n                 } else {\n-                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                        uint::max(a, ty_align(*t))\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                 }\n             }\n             Array => {\n@@ -68,13 +68,11 @@ fn ty_size(ty: TypeRef) -> uint {\n             Double => 8,\n             Struct => {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        s + ty_size(*t)\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        align(s, *t) + ty_size(*t)\n-                    };\n+                    let str_tys = struct_tys(ty);\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }"}, {"sha": "5ef5c4c35b1036fe523534b8615d70bb6573f2c7", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc::c_uint;\n use core::ptr;\n use core::uint;\n@@ -56,9 +57,8 @@ fn ty_align(ty: TypeRef) -> uint {\n               if llvm::LLVMIsPackedStruct(ty) == True {\n                 1\n               } else {\n-                do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                    uint::max(a, ty_align(*t))\n-                }\n+                let str_tys = struct_tys(ty);\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n               }\n             }\n             Array => {\n@@ -81,13 +81,11 @@ fn ty_size(ty: TypeRef) -> uint {\n             Double => 8,\n             Struct => {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        s + ty_size(*t)\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        align(s, *t) + ty_size(*t)\n-                    };\n+                    let str_tys = struct_tys(ty);\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }"}, {"sha": "eb2d7e619eb75cab50849883fe787d448eaffb06", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -19,6 +19,7 @@ use lib::llvm::True;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc::c_uint;\n use core::option;\n use core::option::Option;\n@@ -80,9 +81,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                   if llvm::LLVMIsPackedStruct(ty) == True {\n                     1\n                   } else {\n-                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                      uint::max(a, ty_align(*t))\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                   }\n                 }\n                 Array => {\n@@ -104,16 +104,14 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                  if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                      s + ty_size(*t)\n+                    if llvm::LLVMIsPackedStruct(ty) == True {\n+                        let str_tys = struct_tys(ty);\n+                        str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+                    } else {\n+                        let str_tys = struct_tys(ty);\n+                        let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                        align(size, ty)\n                     }\n-                  } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                      align(s, *t) + ty_size(*t)\n-                    };\n-                    align(size, ty)\n-                  }\n                 }\n                 Array => {\n                   let len = llvm::LLVMGetArrayLength(ty) as uint;"}, {"sha": "3066e817044c0d711cbb7e94e16fb533ca33a485", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -24,6 +24,7 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n+use core::iterator::IteratorUtil;\n use core::str;\n use core::util;\n use core::vec;\n@@ -150,7 +151,7 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do vec::foldl(~[], lines) |paras, line| {\n+    let paras = do lines.iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if str::is_whitespace(*line) {"}, {"sha": "2f00cd0bbcefb3ce93e2cc2a34a462f2dd245900", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -14,6 +14,7 @@ use core::prelude::*;\n \n use doc;\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n \n pub type AstId = int;\n@@ -174,7 +175,7 @@ pub struct IndexEntry {\n \n impl Doc {\n     pub fn CrateDoc(&self) -> CrateDoc {\n-        vec::foldl(None, self.pages, |_m, page| {\n+        self.pages.iter().fold(None, |_m, page| {\n             match copy *page {\n               doc::CratePage(doc) => Some(doc),\n               _ => None"}, {"sha": "e83b7adad0eb88298d0f044ce3c5407c7c5922b0", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use core::vec;\n+use core::iterator::IteratorUtil;\n \n use astsrv;\n use doc;\n@@ -30,7 +31,7 @@ pub fn run_passes(\n     passes: ~[Pass]\n ) -> doc::Doc {\n     let mut passno = 0;\n-    do vec::foldl(doc, passes) |doc, pass| {\n+    do passes.iter().fold(doc) |doc, pass| {\n         debug!(\"pass #%d\", passno);\n         passno += 1;\n         do time(copy pass.name) {"}, {"sha": "41a844c0b4607eebbf4f99fe279e4eaf2c2f37ed", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -21,6 +21,7 @@ middle of a line, and each of the following lines is indented.\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::str;\n use core::uint;\n use core::vec;\n@@ -36,7 +37,7 @@ fn unindent(s: &str) -> ~str {\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = do vec::foldl(uint::max_value, lines)\n+    let min_indent = do lines.iter().fold(uint::max_value)\n         |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at"}, {"sha": "7540f54f30864aa0a0924aa5310088111599dfa8", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 124, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -1066,64 +1066,6 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-/**\n- * Reduces a vector from left to right.\n- *\n- * # Arguments\n- * * `z` - initial accumulator value\n- * * `v` - vector to iterate over\n- * * `p` - a closure to operate on vector elements\n- *\n- * # Examples\n- *\n- * Sum all values in the vector [1, 2, 3]:\n- *\n- * ~~~ {.rust}\n- * vec::foldl(0, [1, 2, 3], |a, b| a + *b);\n- * ~~~\n- *\n- */\n-pub fn foldl<'a, T, U>(z: T, v: &'a [U], p: &fn(t: T, u: &'a U) -> T) -> T {\n-    let mut accum = z;\n-    let mut i = 0;\n-    let l = v.len();\n-    while i < l {\n-        // Use a while loop so that liveness analysis can handle moving\n-        // the accumulator.\n-        accum = p(accum, &v[i]);\n-        i += 1;\n-    }\n-    accum\n-}\n-\n-/**\n- * Reduces a vector from right to left. Note that the argument order is\n- * reversed compared to `foldl` to reflect the order they are provided to\n- * the closure.\n- *\n- * # Arguments\n- * * `v` - vector to iterate over\n- * * `z` - initial accumulator value\n- * * `p` - a closure to do operate on vector elements\n- *\n- * # Examples\n- *\n- * Sum all values in the vector [1, 2, 3]:\n- *\n- * ~~~ {.rust}\n- * vec::foldr([1, 2, 3], 0, |a, b| a + *b);\n- * ~~~\n- *\n- */\n-pub fn foldr<'a, T, U>(v: &'a [T], mut z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n-    let mut i = v.len();\n-    while i > 0 {\n-        i -= 1;\n-        z = p(&v[i], z);\n-    }\n-    return z;\n-}\n-\n /// Return true if a vector contains an element with the given value\n pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n@@ -1974,7 +1916,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// Reduce a vector from right to left\n     #[inline]\n     fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n-        foldr(*self, z, p)\n+        self.rev_iter().fold(z, |u, t| p(t, u))\n     }\n \n     /// Apply a function to each element of a vector and return the results\n@@ -3394,39 +3336,6 @@ mod tests {\n         assert_eq!(v, ~[1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_foldl() {\n-        // Test on-stack fold.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut sum = foldl(0u, v, add);\n-        assert_eq!(sum, 6u);\n-\n-        // Test on-heap fold.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        sum = foldl(0u, v, add);\n-        assert_eq!(sum, 15u);\n-    }\n-\n-    #[test]\n-    fn test_foldl2() {\n-        fn sub(a: int, b: &int) -> int {\n-            a - *b\n-        }\n-        let v = ~[1, 2, 3, 4];\n-        let sum = foldl(0, v, sub);\n-        assert_eq!(sum, -10);\n-    }\n-\n-    #[test]\n-    fn test_foldr() {\n-        fn sub(a: &int, b: int) -> int {\n-            *a - b\n-        }\n-        let v = ~[1, 2, 3, 4];\n-        let sum = foldr(v, 0, sub);\n-        assert_eq!(sum, -2);\n-    }\n-\n     #[test]\n     fn test_each_empty() {\n         for each::<int>([]) |_v| {\n@@ -4234,38 +4143,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_foldl_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do foldl((~0, @0), v) |_a, _b| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            (~0, @0)\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_foldr_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do foldr(v, (~0, @0)) |_a, _b| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            (~0, @0)\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]"}, {"sha": "51334772c84b3f5662b02b512d01fc6109c804a3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -19,6 +19,7 @@ use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashSet;\n use core::vec;\n use extra;\n@@ -313,7 +314,7 @@ pub enum inline_attr {\n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n-    do vec::foldl(ia_none, attrs) |ia,attr| {\n+    do attrs.iter().fold(ia_none) |ia,attr| {\n         match attr.node.value.node {\n           ast::meta_word(@~\"inline\") => ia_hint,\n           ast::meta_list(@~\"inline\", ref items) => {"}, {"sha": "453d867fce9d654c8e500cd470bf374f136e2fb9", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -16,7 +16,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-use core::vec;\n+use core::iterator::IteratorUtil;\n \n pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   span: span,\n@@ -85,7 +85,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n     }\n \n-    do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n+    do exprs.slice(1, exprs.len()).iter().fold(exprs[0]) |prev, me| {\n         cx.expr_binary(span, and, prev, *me)\n     }\n }"}, {"sha": "1630fb116266467b95a32f3790524d089c0f748f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -27,6 +27,7 @@ use parse::token::{ident_to_str, intern, fresh_name};\n use visit;\n use visit::{Visitor,mk_vt};\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n@@ -128,7 +129,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n-        do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n+        do item.attrs.rev_iter().fold(~[*item]) |items, attr| {\n             let mname = attr::get_attr_name(attr);\n \n             match (*extsbox).find(&intern(*mname)) {"}, {"sha": "a6ec91f899ca89c62f65f71da961a379b791d5d5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -129,12 +129,12 @@ pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n }\n \n pub fn count_names(ms: &[matcher]) -> uint {\n-    vec::foldl(0u, ms, |ct, m| {\n+    do ms.iter().fold(0) |ct, m| {\n         ct + match m.node {\n           match_tok(_) => 0u,\n           match_seq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n           match_nonterminal(_,_,_) => 1u\n-        }})\n+        }}\n }\n \n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)"}, {"sha": "f3bd2d4b8d1cf260533d50d2624c7c608fb434b2", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -19,9 +19,9 @@ use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::option;\n-use core::vec;\n \n ///an unzipping of `token_tree`s\n struct TtFrame {\n@@ -113,9 +113,7 @@ fn lookup_cur_matched_by_matched(r: &mut TtReader,\n           matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n-    let r = &mut *r;\n-    let repeat_idx = &r.repeat_idx;\n-    vec::foldl(start, *repeat_idx, red)\n+    r.repeat_idx.iter().fold(start, red)\n }\n \n fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n@@ -152,10 +150,10 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     }\n     match *t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        vec::foldl(lis_unconstrained, *tts, |lis, tt| {\n+        do tts.iter().fold(lis_unconstrained) |lis, tt| {\n             let lis2 = lockstep_iter_size(tt, r);\n             lis_merge(lis, lis2)\n-        })\n+        }\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {"}, {"sha": "ce8f5e502e8318b23c87c6ceb7ca47307a2c4295", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n fn compute1() -> float {\n     let v = ~[0f, 1f, 2f, 3f];\n \n-    do vec::foldl(0f, v) |x, y| { x + *y } - 10f\n+    do v.iter().fold(0f) |x, y| { x + *y } - 10f\n     //~^ ERROR mismatched types: expected `()`\n }\n "}, {"sha": "47cf9177ac236798f9324c09aef08d4f16a4dd7a", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n-    do vec::foldr(needlesArr) |x, y| {\n+    do needlesArr.iter().fold() |x, y| {\n     }\n-    //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n+    //~^ ERROR 1 parameter were supplied (including the closure passed by the `do` keyword)\n     //\n     // the first error is, um, non-ideal.\n }"}, {"sha": "6a90dafa2f1ddb85e4ca713830e88f8230c4d329", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Trailing expressions don't require parentheses:\n-    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n+    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n \n     assert_eq!(y, 15f);\n }"}, {"sha": "3dc282fdffa7136e85faf07851d8d2b21c744e7d", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -13,6 +13,6 @@ use std::vec;\n pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n+    let z = do do v.iter().fold(f) |x, _y| { x } { 22u };\n     assert_eq!(z, 22u);\n }"}, {"sha": "0c78735a07093d17bd8c9a2c45856f80c44e4f3a", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -13,6 +13,6 @@ use std::vec;\n pub fn main() {\n     fn f(i: uint) -> uint { i }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = do vec::foldl(f, v) |x, _y| { x } (22u);\n+    let z = do v.iter().fold(f) |x, _y| { x } (22u);\n     assert_eq!(z, 22u);\n }"}, {"sha": "854b45f4672d147d7986d50952741174cf7f38ce", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -8,25 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::IteratorUtil;\n use std::vec;\n \n fn w_semi(v: ~[int]) -> int {\n     // the semicolon causes compiler not to\n     // complain about the ignored return value:\n-    do vec::foldl(0, v) |x,y| { x+*y };\n+    do v.iter().fold(0) |x,y| { x+*y };\n     -10\n }\n \n fn w_paren1(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+*y }) - 10\n+    (do v.iter().fold(0) |x,y| { x+*y }) - 10\n }\n \n fn w_paren2(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+*y} - 10)\n+    (do v.iter().fold(0) |x,y| { x+*y} - 10)\n }\n \n fn w_ret(v: ~[int]) -> int {\n-    return do vec::foldl(0, v) |x,y| { x+*y } - 10;\n+    return do v.iter().fold(0) |x,y| { x+*y } - 10;\n }\n \n pub fn main() {"}, {"sha": "c34948a897937633b606eb25030d78c338d15d14", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed299af62566a9f0f285e81408aab5f7680ab4cc/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=ed299af62566a9f0f285e81408aab5f7680ab4cc", "patch": "@@ -51,9 +51,9 @@ pub fn main() {\n \n \n     // Lower precedence than binary operations:\n-    let w = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n-    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n-    let z = 10f + do vec::foldl(0f, v) |x, y| { x + *y };\n+    let w = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n+    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n+    let z = 10f + do v.iter().fold(0f) |x, y| { x + *y };\n     assert_eq!(w, y);\n     assert_eq!(y, z);\n "}]}