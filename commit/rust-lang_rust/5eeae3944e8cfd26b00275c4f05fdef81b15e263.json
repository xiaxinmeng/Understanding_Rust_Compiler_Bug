{"sha": "5eeae3944e8cfd26b00275c4f05fdef81b15e263", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZWFlMzk0NGU4Y2ZkMjZiMDAyNzVjNGYwNWZkZWY4MWIxNWUyNjM=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-10-06T20:29:52Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-10-06T20:29:52Z"}, "message": "Merge pull request #404 from marcusklaas/rewrite-list-fmt\n\nList formatting refactoring", "tree": {"sha": "3a5c8b333d7d84a1425c2e7c76cca1f66051ae9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a5c8b333d7d84a1425c2e7c76cca1f66051ae9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eeae3944e8cfd26b00275c4f05fdef81b15e263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eeae3944e8cfd26b00275c4f05fdef81b15e263", "html_url": "https://github.com/rust-lang/rust/commit/5eeae3944e8cfd26b00275c4f05fdef81b15e263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eeae3944e8cfd26b00275c4f05fdef81b15e263/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ea589d7b413c068443cda8ad3f24fe9a50cb07a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ea589d7b413c068443cda8ad3f24fe9a50cb07a", "html_url": "https://github.com/rust-lang/rust/commit/7ea589d7b413c068443cda8ad3f24fe9a50cb07a"}, {"sha": "199d40fa5589bb0e74c4086e30825015277439c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/199d40fa5589bb0e74c4086e30825015277439c1", "html_url": "https://github.com/rust-lang/rust/commit/199d40fa5589bb0e74c4086e30825015277439c1"}], "stats": {"total": 686, "additions": 337, "deletions": 349}, "files": [{"sha": "3648e5e5f67f6e33c04b5c4c560a8c263a23e7b3", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -2,11 +2,11 @@\n name = \"rustfmt\"\n version = \"0.0.1\"\n dependencies = [\n- \"diff 0.1.5 (git+https://github.com/utkarshkukreti/diff.rs.git)\",\n+ \"diff 0.1.7 (git+https://github.com/utkarshkukreti/diff.rs.git)\",\n  \"regex 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (git+https://github.com/nrc/strings.rs.git)\",\n- \"term 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.2.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -21,15 +21,15 @@ dependencies = [\n \n [[package]]\n name = \"diff\"\n-version = \"0.1.5\"\n-source = \"git+https://github.com/utkarshkukreti/diff.rs.git#1921576a73e1b50a0ecb26c8ce62eefb26d273b4\"\n+version = \"0.1.7\"\n+source = \"git+https://github.com/utkarshkukreti/diff.rs.git#6edb9454bf4127087aced0fe07ab3ea6894083cb\"\n \n [[package]]\n name = \"kernel32-sys\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"winapi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -84,11 +84,11 @@ dependencies = [\n \n [[package]]\n name = \"term\"\n-version = \"0.2.11\"\n+version = \"0.2.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -106,7 +106,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"winapi\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]"}, {"sha": "86d1a9aeb1496002af7ad4fe8a38c138c67f7e46", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -348,8 +348,7 @@ mod test {\n         assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n         assert_eq!(&uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"),\n                    \"..ac\\n\");\n-        assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"),\n-                   \"abc \\\" /* */\\\" qsdf\");\n+        assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n     }\n \n     #[test]"}, {"sha": "b237ce4ddfc4597cfde383ede73a3c4707332752", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -260,9 +260,9 @@ create_config! {\n     max_width: usize, 100, \"Maximum width of each line\";\n     ideal_width: usize, 80, \"Ideal width of each line\";\n     tab_spaces: usize, 4, \"Number of spaces per tab\";\n-    fn_call_width: usize, 50,\n+    fn_call_width: usize, 60,\n         \"Maximum width of the args of a function call before faling back to vertical formatting\";\n-    struct_lit_width: usize, 12,\n+    struct_lit_width: usize, 16,\n         \"Maximum width in the body of a struct lit before faling back to vertical formatting\";\n     newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n     fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";"}, {"sha": "1d0621539e012656be180b66404b2ed902f139ae", "filename": "src/expr.rs", "status": "modified", "additions": 53, "deletions": 72, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -13,7 +13,8 @@ use std::borrow::Borrow;\n \n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n-use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListFormatting, SeparatorTactic, ListTactic,\n+            DefinitiveListTactic, definitive_tactic, ListItem, format_fn_args};\n use string::{StringFormat, rewrite_string};\n use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search};\n use visitor::FmtVisitor;\n@@ -156,10 +157,7 @@ impl Rewrite for ast::Expr {\n                 })\n             }\n             ast::Expr_::ExprRet(None) => {\n-                wrap_str(\"return\".to_owned(),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n+                wrap_str(\"return\".to_owned(), context.config.max_width, width, offset)\n             }\n             ast::Expr_::ExprRet(Some(ref expr)) => {\n                 rewrite_unary_prefix(context, \"return \", expr, width, offset)\n@@ -266,30 +264,28 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n                              // 1 = [\n-                             // FIXME(#133): itemize_list doesn't support\n-                             // rewrite failure. This may not be its\n-                             // responsibility, but that of write_list.\n-                             |item| {\n-                                 item.rewrite(context, max_item_width, offset + 1)\n-                                     .unwrap_or_else(|| context.snippet(item.span))\n-                             },\n+                             |item| item.rewrite(context, max_item_width, offset + 1),\n                              span_after(span, \"[\", context.codemap),\n                              span.hi)\n                     .collect::<Vec<_>>();\n \n-    let tactic = if items.iter().any(|li| li.item.len() > 10 || li.is_multiline()) {\n-        ListTactic::HorizontalVertical\n+    let has_long_item = try_opt!(items.iter()\n+                                      .map(|li| li.item.as_ref().map(|s| s.len() > 10))\n+                                      .fold(Some(false),\n+                                            |acc, x| acc.and_then(|y| x.map(|x| (x || y)))));\n+\n+    let tactic = if has_long_item || items.iter().any(ListItem::is_multiline) {\n+        definitive_tactic(&items, ListTactic::HorizontalVertical, max_item_width)\n     } else {\n-        ListTactic::Mixed\n+        DefinitiveListTactic::Mixed\n     };\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n         indent: offset + 1,\n-        h_width: max_item_width,\n-        v_width: max_item_width,\n+        width: max_item_width,\n         ends_with_newline: false,\n         config: context.config,\n     };\n@@ -329,29 +325,26 @@ fn rewrite_closure(capture: ast::CaptureClause,\n                                  \"|\",\n                                  |arg| span_lo_for_arg(arg),\n                                  |arg| span_hi_for_arg(arg),\n-                                 |arg| {\n-                                     // FIXME: we should just escalate failure\n-                                     // here, but itemize_list doesn't allow it.\n-                                     arg.rewrite(context, budget, argument_offset)\n-                                        .unwrap_or_else(|| {\n-                                            context.snippet(mk_sp(span_lo_for_arg(arg),\n-                                                                  span_hi_for_arg(arg)))\n-                                        })\n-                                 },\n+                                 |arg| arg.rewrite(context, budget, argument_offset),\n                                  span_after(span, \"|\", context.codemap),\n                                  body.span.lo);\n+    let item_vec = arg_items.collect::<Vec<_>>();\n+    let tactic = definitive_tactic(&item_vec, ListTactic::HorizontalVertical, horizontal_budget);\n+    let budget = match tactic {\n+        DefinitiveListTactic::Horizontal => horizontal_budget,\n+        _ => budget,\n+    };\n \n     let fmt = ListFormatting {\n-        tactic: ListTactic::HorizontalVertical,\n+        tactic: tactic,\n         separator: \",\",\n         trailing_separator: SeparatorTactic::Never,\n         indent: argument_offset,\n-        h_width: horizontal_budget,\n-        v_width: budget,\n+        width: budget,\n         ends_with_newline: false,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n+    let list_str = try_opt!(write_list(&item_vec, &fmt));\n     let mut prefix = format!(\"{}|{}|\", mover, list_str);\n \n     if !ret_str.is_empty() {\n@@ -801,8 +794,7 @@ fn rewrite_match(context: &RewriteContext,\n         }\n     }\n     // BytePos(1) = closing match brace.\n-    let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]),\n-                          span.hi - BytePos(1));\n+    let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]), span.hi - BytePos(1));\n     let last_comment = context.snippet(last_span);\n     let comment = try_opt!(rewrite_match_arm_comment(context,\n                                                      &last_comment,\n@@ -915,8 +907,7 @@ impl Rewrite for ast::Arm {\n         // 4 = ` => `.len()\n         let same_line_body = if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n-            let offset = Indent::new(offset.block_indent,\n-                                     line_start + 4 - offset.block_indent);\n+            let offset = Indent::new(offset.block_indent, line_start + 4 - offset.block_indent);\n             let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n \n             match rewrite {\n@@ -1156,16 +1147,11 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n-                             // Take old span when rewrite fails.\n-                             |item| {\n-                                 item.rewrite(&inner_context, remaining_width, offset)\n-                                     .unwrap_or(context.snippet(item.span))\n-                             },\n+                             |item| item.rewrite(&inner_context, remaining_width, offset),\n                              span.lo,\n                              span.hi);\n \n-    let fmt = ListFormatting::for_fn(remaining_width, offset, context.config);\n-    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+    let list_str = match format_fn_args(items, remaining_width, offset, context.config) {\n         Some(str) => str,\n         None => return Err(Ordering::Less),\n     };\n@@ -1178,9 +1164,7 @@ fn rewrite_paren(context: &RewriteContext,\n                  width: usize,\n                  offset: Indent)\n                  -> Option<String> {\n-    debug!(\"rewrite_paren, width: {}, offset: {:?}\",\n-           width,\n-           offset);\n+    debug!(\"rewrite_paren, width: {}, offset: {:?}\", width, offset);\n     // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n     // paren on the same line as the subexpr.\n     let subexpr_str = subexpr.rewrite(context, try_opt!(width.checked_sub(2)), offset + 1);\n@@ -1196,9 +1180,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                           width: usize,\n                           offset: Indent)\n                           -> Option<String> {\n-    debug!(\"rewrite_struct_lit: width {}, offset {:?}\",\n-           width,\n-           offset);\n+    debug!(\"rewrite_struct_lit: width {}, offset {:?}\", width, offset);\n     assert!(!fields.is_empty() || base.is_some());\n \n     enum StructLitField<'a> {\n@@ -1259,32 +1241,37 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => {\n                                          rewrite_field(inner_context, &field, v_budget, indent)\n-                                             .unwrap_or(context.snippet(field.span))\n                                      }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n-                                         format!(\"..{}\",\n-                                                 v_budget.checked_sub(2)\n-                                                         .and_then(|v_budget| {\n-                                                             expr.rewrite(inner_context,\n-                                                                          v_budget,\n-                                                                          indent + 2)\n-                                                         })\n-                                                         .unwrap_or(context.snippet(expr.span)))\n+                                         expr.rewrite(inner_context,\n+                                                      try_opt!(v_budget.checked_sub(2)),\n+                                                      indent + 2)\n+                                             .map(|s| format!(\"..{}\", s))\n                                      }\n                                  }\n                              },\n                              span_after(span, \"{\", context.codemap),\n                              span.hi);\n+    let item_vec = items.collect::<Vec<_>>();\n+\n+    let tactic = {\n+        let mut prelim_tactic = match (context.config.struct_lit_style, fields.len()) {\n+            (StructLitStyle::Visual, 1) => ListTactic::HorizontalVertical,\n+            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+        };\n+\n+        if prelim_tactic == ListTactic::HorizontalVertical && fields.len() > 1 {\n+            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n+        };\n \n-    let mut tactic = match (context.config.struct_lit_style, fields.len()) {\n-        (StructLitStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-        _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+        definitive_tactic(&item_vec, prelim_tactic, h_budget)\n     };\n \n-    if tactic == ListTactic::HorizontalVertical && fields.len() > 1 {\n-        tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n-    }\n+    let budget = match tactic {\n+        DefinitiveListTactic::Horizontal => h_budget,\n+        _ => v_budget,\n+    };\n \n     let fmt = ListFormatting {\n         tactic: tactic,\n@@ -1295,12 +1282,11 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n             context.config.struct_lit_trailing_comma\n         },\n         indent: indent,\n-        h_width: h_budget,\n-        v_width: v_budget,\n+        width: budget,\n         ends_with_newline: false,\n         config: context.config,\n     };\n-    let fields_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+    let fields_str = try_opt!(write_list(&item_vec, &fmt));\n \n     let format_on_newline = || {\n         let inner_indent = context.block_indent\n@@ -1345,9 +1331,7 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n-    debug!(\"rewrite_tuple_lit: width: {}, offset: {:?}\",\n-           width,\n-           offset);\n+    debug!(\"rewrite_tuple_lit: width: {}, offset: {:?}\", width, offset);\n     let indent = offset + 1;\n     // In case of length 1, need a trailing comma\n     if items.len() == 1 {\n@@ -1364,14 +1348,11 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              |item| {\n                                  let inner_width = context.config.max_width - indent.width() - 1;\n                                  item.rewrite(context, inner_width, indent)\n-                                     .unwrap_or(context.snippet(item.span))\n                              },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n-\n     let budget = try_opt!(width.checked_sub(2));\n-    let fmt = ListFormatting::for_fn(budget, indent, context.config);\n-    let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+    let list_str = try_opt!(format_fn_args(items, budget, indent, context.config));\n \n     Some(format!(\"({})\", list_str))\n }"}, {"sha": "d94c1501734517d5eca0f7f59d71ff27496b5471", "filename": "src/filemap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -115,8 +115,7 @@ fn write_file(text: &StringBuffer,\n             try!(write_system_newlines(&mut v, text, config));\n             let fmt_text = String::from_utf8(v).unwrap();\n             let diff = make_diff(&ori_text, &fmt_text, 3);\n-            print_diff(diff,\n-                       |line_num| format!(\"\\nDiff at line {}:\", line_num));\n+            print_diff(diff, |line_num| format!(\"\\nDiff at line {}:\", line_num));\n         }\n         WriteMode::Return => {\n             // io::Write is not implemented for String, working around with"}, {"sha": "aab5dd76799ba764e2323887f72402cc59e77092", "filename": "src/imports.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use Indent;\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, definitive_tactic};\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n \n@@ -71,7 +71,7 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n     append_alias(path_item_str, vpi)\n }\n \n-fn rewrite_path_item(vpi: &&ast::PathListItem) -> String {\n+fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n         ast::PathListItem_::PathListIdent{ name, .. } => {\n             name.to_string()\n@@ -81,7 +81,7 @@ fn rewrite_path_item(vpi: &&ast::PathListItem) -> String {\n         }\n     };\n \n-    append_alias(path_item_str, vpi)\n+    Some(append_alias(path_item_str, vpi))\n }\n \n fn append_alias(path_item_str: String, vpi: &ast::PathListItem) -> String {\n@@ -124,20 +124,6 @@ pub fn rewrite_use_list(width: usize,\n     // 1 = }\n     let remaining_width = width.checked_sub(supp_indent + 1).unwrap_or(0);\n \n-    let fmt = ListFormatting {\n-        tactic: ListTactic::Mixed,\n-        separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n-        indent: offset + supp_indent,\n-        h_width: remaining_width,\n-        // FIXME This is too conservative, and will not use all width\n-        // available\n-        // (loose 1 column (\";\"))\n-        v_width: remaining_width,\n-        ends_with_newline: false,\n-        config: context.config,\n-    };\n-\n     let mut items = {\n         // Dummy value, see explanation below.\n         let mut items = vec![ListItem::from_str(\"\")];\n@@ -156,8 +142,6 @@ pub fn rewrite_use_list(width: usize,\n     // We prefixed the item list with a dummy value so that we can\n     // potentially move \"self\" to the front of the vector without touching\n     // the rest of the items.\n-    // FIXME: Make more efficient by using a linked list? That would require\n-    // changes to the signatures of write_list.\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self {\n         0\n@@ -169,6 +153,21 @@ pub fn rewrite_use_list(width: usize,\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n \n+    let tactic = definitive_tactic(&items[first_index..],\n+                                   ::lists::ListTactic::Mixed,\n+                                   remaining_width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset + supp_indent,\n+        // FIXME This is too conservative, and will not use all width\n+        // available\n+        // (loose 1 column (\";\"))\n+        width: remaining_width,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n     let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n \n     Some(if path_str.is_empty() {\n@@ -180,7 +179,7 @@ pub fn rewrite_use_list(width: usize,\n \n // Returns true when self item was found.\n fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n-    match items.iter().position(|item| item.item == \"self\") {\n+    match items.iter().position(|item| item.item.as_ref().map(|x| &x[..]) == Some(\"self\")) {\n         Some(pos) => {\n             items[0] = items.remove(pos);\n             true"}, {"sha": "04a61fff358bc6879bfd21ceb08f7787eb0fec93", "filename": "src/issues.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -236,8 +236,7 @@ fn find_unnumbered_issue() {\n \n     fn check_pass(text: &str) {\n         let mut seeker = BadIssueSeeker::new(ReportTactic::Unnumbered, ReportTactic::Unnumbered);\n-        assert_eq!(None,\n-                   text.chars().position(|c| seeker.inspect(c).is_some()));\n+        assert_eq!(None, text.chars().position(|c| seeker.inspect(c).is_some()));\n     }\n \n     check_fail(\"TODO\\n\", 4);\n@@ -272,9 +271,7 @@ fn find_issue() {\n                          ReportTactic::Never,\n                          ReportTactic::Always));\n \n-    assert!(!is_bad_issue(\"bad FIXME\\n\",\n-                          ReportTactic::Always,\n-                          ReportTactic::Never));\n+    assert!(!is_bad_issue(\"bad FIXME\\n\", ReportTactic::Always, ReportTactic::Never));\n }\n \n #[test]"}, {"sha": "3d9a0e56aa46439cacce974da6e578d7d612ff8c", "filename": "src/items.rs", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -12,7 +12,8 @@\n \n use Indent;\n use utils::{format_mutability, format_visibility, contains_skip, span_after, end_typaram, wrap_str};\n-use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic};\n+use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, ListTactic,\n+            DefinitiveListTactic, definitive_tactic};\n use expr::rewrite_assign_rhs;\n use comment::FindUncommented;\n use visitor::FmtVisitor;\n@@ -311,9 +312,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let context = self.get_context();\n         let ret_str = fd.output\n-                        .rewrite(&context,\n-                                 self.config.max_width - indent.width(),\n-                                 indent)\n+                        .rewrite(&context, self.config.max_width - indent.width(), indent)\n                         .unwrap();\n \n         // Args.\n@@ -480,7 +479,7 @@ impl<'a> FmtVisitor<'a> {\n                                           \")\",\n                                           |arg| span_lo_for_arg(arg),\n                                           |arg| arg.ty.span.hi,\n-                                          |_| String::new(),\n+                                          |_| None,\n                                           comment_span_start,\n                                           span.hi);\n \n@@ -490,7 +489,7 @@ impl<'a> FmtVisitor<'a> {\n         assert_eq!(arg_item_strs.len(), arg_items.len());\n \n         for (item, arg) in arg_items.iter_mut().zip(arg_item_strs) {\n-            item.item = arg;\n+            item.item = Some(arg);\n         }\n \n         let indent = match self.config.fn_arg_indent {\n@@ -499,13 +498,20 @@ impl<'a> FmtVisitor<'a> {\n             BlockIndentStyle::Visual => arg_indent,\n         };\n \n+        let tactic = definitive_tactic(&arg_items,\n+                                       self.config.fn_args_density.to_list_tactic(),\n+                                       one_line_budget);\n+        let budget = match tactic {\n+            DefinitiveListTactic::Horizontal => one_line_budget,\n+            _ => multi_line_budget,\n+        };\n+\n         let fmt = ListFormatting {\n-            tactic: self.config.fn_args_density.to_list_tactic(),\n+            tactic: tactic,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: indent,\n-            h_width: one_line_budget,\n-            v_width: multi_line_budget,\n+            width: budget,\n             ends_with_newline: false,\n             config: self.config,\n         };\n@@ -622,14 +628,13 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| arg.ty.span.hi,\n                                              |arg| {\n                                                  // FIXME silly width, indent\n-                                                 arg.ty\n-                                                    .rewrite(&self.get_context(),\n-                                                             1000,\n-                                                             Indent::empty())\n-                                                    .unwrap()\n+                                                 arg.ty.rewrite(&self.get_context(),\n+                                                                1000,\n+                                                                Indent::empty())\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n+                    let item_vec = items.collect::<Vec<_>>();\n \n                     result.push('(');\n \n@@ -641,18 +646,20 @@ impl<'a> FmtVisitor<'a> {\n                         0\n                     };\n                     let budget = self.config.max_width - indent.width() - comma_cost - 1; // 1 = )\n+                    let tactic = definitive_tactic(&item_vec,\n+                                                   ListTactic::HorizontalVertical,\n+                                                   budget);\n \n                     let fmt = ListFormatting {\n-                        tactic: ListTactic::HorizontalVertical,\n+                        tactic: tactic,\n                         separator: \",\",\n                         trailing_separator: SeparatorTactic::Never,\n                         indent: indent,\n-                        h_width: budget,\n-                        v_width: budget,\n+                        width: budget,\n                         ends_with_newline: true,\n                         config: self.config,\n                     };\n-                    let list_str = match write_list(&items.collect::<Vec<_>>(), &fmt) {\n+                    let list_str = match write_list(&item_vec, &fmt) {\n                         Some(list_str) => list_str,\n                         None => return,\n                     };\n@@ -766,9 +773,9 @@ impl<'a> FmtVisitor<'a> {\n             result.push('\\n');\n             result.push_str(&indentation);\n \n-            ListTactic::Vertical\n+            DefinitiveListTactic::Vertical\n         } else {\n-            ListTactic::Horizontal\n+            DefinitiveListTactic::Horizontal\n         };\n \n         // 1 = ,\n@@ -778,13 +785,12 @@ impl<'a> FmtVisitor<'a> {\n             separator: \",\",\n             trailing_separator: self.config.struct_trailing_comma,\n             indent: offset.block_indent(self.config),\n-            h_width: self.config.max_width,\n-            v_width: budget,\n+            width: budget,\n             ends_with_newline: true,\n             config: self.config,\n         };\n \n-        let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+        let list_str = try_opt!(write_list(items, &fmt));\n         result.push_str(&list_str);\n \n         if break_line {\n@@ -853,9 +859,14 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     // Field of a struct\n-    fn format_field(&self, field: &ast::StructField) -> String {\n+    fn format_field(&self, field: &ast::StructField) -> Option<String> {\n         if contains_skip(&field.node.attrs) {\n-            return self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo, field.span.hi));\n+            // FIXME: silly width, indent\n+            return wrap_str(self.snippet(codemap::mk_sp(field.node.attrs[0].span.lo,\n+                                                        field.span.hi)),\n+                            self.config.max_width,\n+                            1000,\n+                            Indent::empty());\n         }\n \n         let name = match field.node.kind {\n@@ -867,24 +878,23 @@ impl<'a> FmtVisitor<'a> {\n             ast::StructFieldKind::UnnamedField(vis) => format_visibility(vis),\n         };\n         // FIXME silly width, indent\n-        let typ = field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()).unwrap();\n+        let typ = try_opt!(field.node.ty.rewrite(&self.get_context(), 1000, Indent::empty()));\n \n         let indent = self.block_indent.block_indent(self.config);\n-        let mut attr_str = field.node\n-                                .attrs\n-                                .rewrite(&self.get_context(),\n-                                         self.config.max_width - indent.width(),\n-                                         indent)\n-                                .unwrap();\n+        let mut attr_str = try_opt!(field.node\n+                                         .attrs\n+                                         .rewrite(&self.get_context(),\n+                                                  self.config.max_width - indent.width(),\n+                                                  indent));\n         if !attr_str.is_empty() {\n             attr_str.push('\\n');\n             attr_str.push_str(&indent.to_string(self.config));\n         }\n \n-        match name {\n+        Some(match name {\n             Some(name) => format!(\"{}{}{}: {}\", attr_str, vis, name, typ),\n             None => format!(\"{}{}{}\", attr_str, vis, typ),\n-        }\n+        })\n     }\n \n     fn rewrite_generics(&self,\n@@ -913,10 +923,8 @@ impl<'a> FmtVisitor<'a> {\n \n         // Strings for the generics.\n         let context = self.get_context();\n-        // FIXME: don't unwrap\n-        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset).unwrap());\n-        let ty_strs = tys.iter()\n-                         .map(|ty_param| ty_param.rewrite(&context, h_budget, offset).unwrap());\n+        let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(&context, h_budget, offset));\n+        let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(&context, h_budget, offset));\n \n         // Extract comments between generics.\n         let lt_spans = lifetimes.iter().map(|l| {\n@@ -930,21 +938,15 @@ impl<'a> FmtVisitor<'a> {\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n         let items = itemize_list(self.codemap,\n-                                 lt_spans.chain(ty_spans),\n+                                 lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n                                  \">\",\n-                                 |sp| sp.lo,\n-                                 |sp| sp.hi,\n-                                 |_| String::new(),\n+                                 |&(sp, _)| sp.lo,\n+                                 |&(sp, _)| sp.hi,\n+                                 // FIXME: don't clone\n+                                 |&(_, ref str)| str.clone(),\n                                  span_after(span, \"<\", self.codemap),\n                                  span.hi);\n-        let mut items = items.collect::<Vec<_>>();\n-\n-        for (item, ty) in items.iter_mut().zip(lt_strs.chain(ty_strs)) {\n-            item.item = ty;\n-        }\n-\n-        let fmt = ListFormatting::for_item(h_budget, offset, self.config);\n-        let list_str = try_opt!(write_list(&items, &fmt));\n+        let list_str = try_opt!(::lists::format_item_list(items, h_budget, offset, self.config));\n \n         Some(format!(\"<{}>\", list_str))\n     }\n@@ -984,24 +986,23 @@ impl<'a> FmtVisitor<'a> {\n                                  \"{\",\n                                  |pred| span_for_where_pred(pred).lo,\n                                  |pred| span_for_where_pred(pred).hi,\n-                                 // FIXME: we should handle failure better\n-                                 // this will be taken care of when write_list\n-                                 // takes Rewrite object: see issue #133\n-                                 |pred| pred.rewrite(&context, budget, offset).unwrap(),\n+                                 |pred| pred.rewrite(&context, budget, offset),\n                                  span_start,\n                                  span_end);\n+        let item_vec = items.collect::<Vec<_>>();\n+        // FIXME: we don't need to collect here if the where_layout isnt horizontalVertical\n+        let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n \n         let fmt = ListFormatting {\n-            tactic: self.config.where_layout,\n+            tactic: tactic,\n             separator: \",\",\n             trailing_separator: SeparatorTactic::Never,\n             indent: offset,\n-            h_width: budget,\n-            v_width: budget,\n+            width: budget,\n             ends_with_newline: true,\n             config: self.config,\n         };\n-        let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+        let preds_str = try_opt!(write_list(&item_vec, &fmt));\n \n         // 9 = \" where \".len() + \" {\".len()\n         if density == Density::Tall || preds_str.contains('\\n') ||"}, {"sha": "1dfb05c88b6df3c81aadff3d5bc5fce5b1005235", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -19,7 +19,6 @@\n // keeping some scratch mem for this and running our own StrPool?\n // TODO for lint violations of names, emit a refactor script\n \n-\n #[macro_use]\n extern crate log;\n \n@@ -119,8 +118,7 @@ impl Indent {\n \n     pub fn to_string(&self, config: &Config) -> String {\n         let (num_tabs, num_spaces) = if config.hard_tabs {\n-            (self.block_indent / config.tab_spaces,\n-             self.alignment)\n+            (self.block_indent / config.tab_spaces, self.alignment)\n         } else {\n             (0, self.block_indent + self.alignment)\n         };"}, {"sha": "6f464805e4b7b71feb2479260d607ad94c9d7d59", "filename": "src/lists.rs", "status": "modified", "additions": 145, "deletions": 118, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -14,17 +14,20 @@ use std::iter::Peekable;\n use syntax::codemap::{self, CodeMap, BytePos};\n \n use Indent;\n-use utils::{round_up_to_power_of_two, wrap_str};\n+use utils::wrap_str;\n use comment::{FindUncommented, rewrite_comment, find_comment_end};\n use config::Config;\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+/// Formatting tactic for lists. This will be cast down to a\n+/// DefinitiveListTactic depending on the number and length of the items and\n+/// their comments.\n pub enum ListTactic {\n     // One item per row.\n     Vertical,\n     // All items on one row.\n     Horizontal,\n-    // Try Horizontal layout, if that fails then vertical\n+    // Try Horizontal layout, if that fails then vertical.\n     HorizontalVertical,\n     // HorizontalVertical with a soft limit of n characters.\n     LimitedHorizontalVertical(usize),\n@@ -43,62 +46,82 @@ pub enum SeparatorTactic {\n \n impl_enum_decodable!(SeparatorTactic, Always, Never, Vertical);\n \n-// TODO having some helpful ctors for ListFormatting would be nice.\n pub struct ListFormatting<'a> {\n-    pub tactic: ListTactic,\n+    pub tactic: DefinitiveListTactic,\n     pub separator: &'a str,\n     pub trailing_separator: SeparatorTactic,\n     pub indent: Indent,\n-    // Available width if we layout horizontally.\n-    pub h_width: usize,\n-    // Available width if we layout vertically\n-    pub v_width: usize,\n+    pub width: usize,\n     // Non-expressions, e.g. items, will have a new line at the end of the list.\n     // Important for comment styles.\n     pub ends_with_newline: bool,\n     pub config: &'a Config,\n }\n \n-impl<'a> ListFormatting<'a> {\n-    pub fn for_fn(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n-        ListFormatting {\n-            tactic: ListTactic::LimitedHorizontalVertical(config.fn_call_width),\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            h_width: width,\n-            v_width: width,\n-            ends_with_newline: false,\n-            config: config,\n-        }\n-    }\n+pub fn format_fn_args<I>(items: I, width: usize, offset: Indent, config: &Config) -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    list_helper(items,\n+                width,\n+                offset,\n+                config,\n+                ListTactic::LimitedHorizontalVertical(config.fn_call_width))\n+}\n \n-    pub fn for_item(width: usize, offset: Indent, config: &'a Config) -> ListFormatting<'a> {\n-        ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset,\n-            h_width: width,\n-            v_width: width,\n-            ends_with_newline: false,\n-            config: config,\n-        }\n+pub fn format_item_list<I>(items: I,\n+                           width: usize,\n+                           offset: Indent,\n+                           config: &Config)\n+                           -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    list_helper(items, width, offset, config, ListTactic::HorizontalVertical)\n+}\n+\n+fn list_helper<I>(items: I,\n+                  width: usize,\n+                  offset: Indent,\n+                  config: &Config,\n+                  tactic: ListTactic)\n+                  -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    let item_vec: Vec<_> = items.collect();\n+    let tactic = definitive_tactic(&item_vec, tactic, width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \",\",\n+        trailing_separator: SeparatorTactic::Never,\n+        indent: offset,\n+        width: width,\n+        ends_with_newline: false,\n+        config: config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}\n+\n+impl AsRef<ListItem> for ListItem {\n+    fn as_ref(&self) -> &ListItem {\n+        self\n     }\n }\n \n pub struct ListItem {\n+    // None for comments mean that they are not present.\n     pub pre_comment: Option<String>,\n-    // Item should include attributes and doc comments.\n-    pub item: String,\n+    // Item should include attributes and doc comments. None indicates a failed\n+    // rewrite.\n+    pub item: Option<String>,\n     pub post_comment: Option<String>,\n     // Whether there is extra whitespace before this item.\n     pub new_lines: bool,\n }\n \n impl ListItem {\n     pub fn is_multiline(&self) -> bool {\n-        self.item.contains('\\n') || self.pre_comment.is_some() ||\n+        self.item.as_ref().map(|s| s.contains('\\n')).unwrap_or(false) ||\n+        self.pre_comment.is_some() ||\n         self.post_comment.as_ref().map(|s| s.contains('\\n')).unwrap_or(false)\n     }\n \n@@ -109,103 +132,96 @@ impl ListItem {\n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n         ListItem {\n             pre_comment: None,\n-            item: s.into(),\n+            item: Some(s.into()),\n             post_comment: None,\n             new_lines: false,\n         }\n     }\n }\n \n-// Format a list of commented items into a string.\n-// FIXME: this has grown into a monstrosity\n-// TODO: add unit tests\n-pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Option<String> {\n-    if items.is_empty() {\n-        return Some(String::new());\n-    }\n-\n-    let mut tactic = formatting.tactic;\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+/// The definitive formatting tactic for lists.\n+pub enum DefinitiveListTactic {\n+    Vertical,\n+    Horizontal,\n+    Mixed,\n+}\n \n-    // Conservatively overestimates because of the changing separator tactic.\n-    let sep_count = if formatting.trailing_separator == SeparatorTactic::Always {\n-        items.len()\n-    } else {\n-        items.len() - 1\n+pub fn definitive_tactic<'t, I, T>(items: I,\n+                                   tactic: ListTactic,\n+                                   width: usize)\n+                                   -> DefinitiveListTactic\n+    where I: IntoIterator<Item = T> + Clone,\n+          T: AsRef<ListItem>\n+{\n+    let pre_line_comments = items.clone()\n+                                 .into_iter()\n+                                 .any(|item| item.as_ref().has_line_pre_comment());\n+\n+    let limit = match tactic {\n+        _ if pre_line_comments => return DefinitiveListTactic::Vertical,\n+        ListTactic::Mixed => return DefinitiveListTactic::Mixed,\n+        ListTactic::Horizontal => return DefinitiveListTactic::Horizontal,\n+        ListTactic::Vertical => return DefinitiveListTactic::Vertical,\n+        ListTactic::LimitedHorizontalVertical(limit) => ::std::cmp::min(width, limit),\n+        ListTactic::HorizontalVertical => width,\n     };\n-    let sep_len = formatting.separator.len();\n-    let total_sep_len = (sep_len + 1) * sep_count;\n-    let total_width = calculate_width(items);\n-    let fits_single = total_width + total_sep_len <= formatting.h_width;\n-\n-    // Check if we need to fallback from horizontal listing, if possible.\n-    if let ListTactic::LimitedHorizontalVertical(limit) = tactic {\n-        if total_width > limit {\n-            tactic = ListTactic::Vertical;\n-        } else {\n-            tactic = ListTactic::HorizontalVertical;\n-        }\n-    }\n-    if tactic == ListTactic::HorizontalVertical {\n-        debug!(\"write_list: total_width: {}, total_sep_len: {}, h_width: {}\",\n-               total_width,\n-               total_sep_len,\n-               formatting.h_width);\n-        tactic = if fits_single && !items.iter().any(ListItem::is_multiline) {\n-            ListTactic::Horizontal\n-        } else {\n-            ListTactic::Vertical\n-        };\n-    }\n \n-    // Check if we can fit everything on a single line in mixed mode.\n-    // The horizontal tactic does not break after v_width columns.\n-    if tactic == ListTactic::Mixed && fits_single {\n-        tactic = ListTactic::Horizontal;\n-    }\n+    let (sep_count, total_width) = calculate_width(items.clone());\n+    let sep_len = \", \".len(); // FIXME: make more generic?\n+    let total_sep_len = sep_len * sep_count.checked_sub(1).unwrap_or(0);\n+    let real_total = total_width + total_sep_len;\n \n-    // Switch to vertical mode if we find non-block comments.\n-    if items.iter().any(ListItem::has_line_pre_comment) {\n-        tactic = ListTactic::Vertical;\n+    if real_total <= limit && !pre_line_comments &&\n+       !items.into_iter().any(|item| item.as_ref().is_multiline()) {\n+        DefinitiveListTactic::Horizontal\n+    } else {\n+        DefinitiveListTactic::Vertical\n     }\n+}\n+\n+// Format a list of commented items into a string.\n+// TODO: add unit tests\n+pub fn write_list<'b, I, T>(items: I, formatting: &ListFormatting<'b>) -> Option<String>\n+    where I: IntoIterator<Item = T>,\n+          T: AsRef<ListItem>\n+{\n+    let tactic = formatting.tactic;\n+    let sep_len = formatting.separator.len();\n \n     // Now that we know how we will layout, we can decide for sure if there\n     // will be a trailing separator.\n     let trailing_separator = needs_trailing_separator(formatting.trailing_separator, tactic);\n-\n-    // Create a buffer for the result.\n-    // TODO could use a StringBuffer or rope for this\n-    let alloc_width = if tactic == ListTactic::Horizontal {\n-        total_width + total_sep_len\n-    } else {\n-        total_width + items.len() * (formatting.indent.width() + 1)\n-    };\n-    let mut result = String::with_capacity(round_up_to_power_of_two(alloc_width));\n+    let mut result = String::new();\n+    let mut iter = items.into_iter().enumerate().peekable();\n \n     let mut line_len = 0;\n     let indent_str = &formatting.indent.to_string(formatting.config);\n-    for (i, item) in items.iter().enumerate() {\n+    while let Some((i, item)) = iter.next() {\n+        let item = item.as_ref();\n+        let inner_item = try_opt!(item.item.as_ref());\n         let first = i == 0;\n-        let last = i == items.len() - 1;\n+        let last = iter.peek().is_none();\n         let separate = !last || trailing_separator;\n         let item_sep_len = if separate {\n             sep_len\n         } else {\n             0\n         };\n-        let item_width = item.item.len() + item_sep_len;\n+        let item_width = inner_item.len() + item_sep_len;\n \n         match tactic {\n-            ListTactic::Horizontal if !first => {\n+            DefinitiveListTactic::Horizontal if !first => {\n                 result.push(' ');\n             }\n-            ListTactic::Vertical if !first => {\n+            DefinitiveListTactic::Vertical if !first => {\n                 result.push('\\n');\n                 result.push_str(indent_str);\n             }\n-            ListTactic::Mixed => {\n+            DefinitiveListTactic::Mixed => {\n                 let total_width = total_item_width(item) + item_sep_len;\n \n-                if line_len > 0 && line_len + total_width > formatting.v_width {\n+                if line_len > 0 && line_len + total_width > formatting.width {\n                     result.push('\\n');\n                     result.push_str(indent_str);\n                     line_len = 0;\n@@ -224,36 +240,37 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n         // Pre-comments\n         if let Some(ref comment) = item.pre_comment {\n             // Block style in non-vertical mode.\n-            let block_mode = tactic != ListTactic::Vertical;\n+            let block_mode = tactic != DefinitiveListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n-            let max_width = formatting.v_width;\n+            let max_width = formatting.width;\n             let comment = try_opt!(rewrite_comment(comment,\n                                                    block_mode,\n                                                    max_width,\n                                                    formatting.indent,\n                                                    formatting.config));\n             result.push_str(&comment);\n \n-            if tactic == ListTactic::Vertical {\n+            if tactic == DefinitiveListTactic::Vertical {\n                 result.push('\\n');\n                 result.push_str(indent_str);\n             } else {\n                 result.push(' ');\n             }\n         }\n \n-        let item_str = try_opt!(wrap_str(&item.item[..],\n+        // Make sure that string actually fits.\n+        let item_str = try_opt!(wrap_str(&inner_item[..],\n                                          formatting.config.max_width,\n-                                         formatting.v_width,\n+                                         formatting.width,\n                                          formatting.indent));\n         result.push_str(&item_str);\n \n         // Post-comments\n-        if tactic != ListTactic::Vertical && item.post_comment.is_some() {\n+        if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n             let formatted_comment = try_opt!(rewrite_comment(comment,\n                                                              true,\n-                                                             formatting.v_width,\n+                                                             formatting.width,\n                                                              Indent::empty(),\n                                                              formatting.config));\n \n@@ -265,9 +282,9 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             result.push_str(formatting.separator);\n         }\n \n-        if tactic == ListTactic::Vertical && item.post_comment.is_some() {\n+        if tactic == DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             // 1 = space between item and comment.\n-            let width = formatting.v_width.checked_sub(item_width + 1).unwrap_or(1);\n+            let width = formatting.width.checked_sub(item_width + 1).unwrap_or(1);\n             let mut offset = formatting.indent;\n             offset.alignment += item_width + 1;\n             let comment = item.post_comment.as_ref().unwrap();\n@@ -286,7 +303,7 @@ pub fn write_list<'b>(items: &[ListItem], formatting: &ListFormatting<'b>) -> Op\n             result.push_str(&formatted_comment);\n         }\n \n-        if !last && tactic == ListTactic::Vertical && item.new_lines {\n+        if !last && tactic == DefinitiveListTactic::Vertical && item.new_lines {\n             result.push('\\n');\n         }\n     }\n@@ -311,7 +328,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     where I: Iterator<Item = T>,\n           F1: Fn(&T) -> BytePos,\n           F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> String\n+          F3: Fn(&T) -> Option<String>\n {\n     type Item = ListItem;\n \n@@ -435,7 +452,7 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n     where I: Iterator<Item = T>,\n           F1: Fn(&T) -> BytePos,\n           F2: Fn(&T) -> BytePos,\n-          F3: Fn(&T) -> String\n+          F3: Fn(&T) -> Option<String>\n {\n     ListItems {\n         codemap: codemap,\n@@ -449,25 +466,35 @@ pub fn itemize_list<'a, T, I, F1, F2, F3>(codemap: &'a CodeMap,\n     }\n }\n \n-fn needs_trailing_separator(separator_tactic: SeparatorTactic, list_tactic: ListTactic) -> bool {\n+fn needs_trailing_separator(separator_tactic: SeparatorTactic,\n+                            list_tactic: DefinitiveListTactic)\n+                            -> bool {\n     match separator_tactic {\n         SeparatorTactic::Always => true,\n-        SeparatorTactic::Vertical => list_tactic == ListTactic::Vertical,\n+        SeparatorTactic::Vertical => list_tactic == DefinitiveListTactic::Vertical,\n         SeparatorTactic::Never => false,\n     }\n }\n \n-fn calculate_width(items: &[ListItem]) -> usize {\n-    items.iter().map(total_item_width).fold(0, |a, l| a + l)\n+/// Returns the count and total width of the list items.\n+fn calculate_width<'li, I, T>(items: I) -> (usize, usize)\n+    where I: IntoIterator<Item = T>,\n+          T: AsRef<ListItem>\n+{\n+    items.into_iter()\n+         .map(|item| total_item_width(item.as_ref()))\n+         .fold((0, 0), |acc, l| (acc.0 + 1, acc.1 + l))\n }\n \n fn total_item_width(item: &ListItem) -> usize {\n-    comment_len(&item.pre_comment) + comment_len(&item.post_comment) + item.item.len()\n+    comment_len(item.pre_comment.as_ref().map(|x| &(*x)[..])) +\n+    comment_len(item.post_comment.as_ref().map(|x| &(*x)[..])) +\n+    item.item.as_ref().map(|str| str.len()).unwrap_or(0)\n }\n \n-fn comment_len(comment: &Option<String>) -> usize {\n-    match *comment {\n-        Some(ref s) => {\n+fn comment_len(comment: Option<&str>) -> usize {\n+    match comment {\n+        Some(s) => {\n             let text_len = s.trim().len();\n             if text_len > 0 {\n                 // We'll put \" /*\" before and \" */\" after inline comments."}, {"sha": "2cbbed92fa511cc68b6efcf1bb68e24adadf5ead", "filename": "src/types.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -13,7 +13,7 @@ use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n use Indent;\n-use lists::{itemize_list, write_list, ListFormatting};\n+use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n \n@@ -206,9 +206,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                  .collect::<Vec<_>>();\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n-            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi),\n-                                     \"<\",\n-                                     context.codemap);\n+            let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n             let separator = get_path_separator(context.codemap, *span_lo, list_lo);\n \n             // 1 for <\n@@ -221,20 +219,17 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \">\",\n                                      |param| param.get_span().lo,\n                                      |param| param.get_span().hi,\n-                                     // FIXME(#133): write_list should call\n-                                     // rewrite itself, because it has a better\n-                                     // context.\n                                      |seg| {\n                                          seg.rewrite(context,\n                                                      context.config.max_width,\n                                                      offset + extra_offset)\n-                                            .unwrap()\n                                      },\n                                      list_lo,\n                                      span_hi);\n-\n-            let fmt = ListFormatting::for_item(list_width, offset + extra_offset, context.config);\n-            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+            let list_str = try_opt!(format_item_list(items,\n+                                                     list_width,\n+                                                     offset + extra_offset,\n+                                                     context.config));\n \n             // Update position of last bracket.\n             *span_lo = next_span_lo;\n@@ -260,12 +255,10 @@ fn rewrite_segment(segment: &ast::PathSegment,\n                                      \")\",\n                                      |ty| ty.span.lo,\n                                      |ty| ty.span.hi,\n-                                     |ty| ty.rewrite(context, budget, offset).unwrap(),\n+                                     |ty| ty.rewrite(context, budget, offset),\n                                      list_lo,\n                                      span_hi);\n-\n-            let fmt = ListFormatting::for_fn(budget, offset, context.config);\n-            let list_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+            let list_str = try_opt!(format_fn_args(items, budget, offset, context.config));\n \n             format!(\"({}){}\", list_str, output)\n         }\n@@ -287,40 +280,39 @@ impl Rewrite for ast::WherePredicate {\n                 let type_str = try_opt!(bounded_ty.rewrite(context, width, offset));\n \n                 if !bound_lifetimes.is_empty() {\n-                    let lifetime_str = bound_lifetimes.iter()\n-                                                      .map(|lt| {\n-                                                          lt.rewrite(context, width, offset)\n-                                                            .unwrap()\n-                                                      })\n-                                                      .collect::<Vec<_>>()\n-                                                      .join(\", \");\n+                    let lifetime_str = try_opt!(bound_lifetimes.iter()\n+                                                               .map(|lt| {\n+                                                                   lt.rewrite(context,\n+                                                                              width,\n+                                                                              offset)\n+                                                               })\n+                                                               .collect::<Option<Vec<_>>>())\n+                                           .join(\", \");\n                     // 8 = \"for<> : \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + 8;\n                     let budget = try_opt!(width.checked_sub(used_width));\n-                    let bounds_str = bounds.iter()\n-                                           .map(|ty_bound| {\n-                                               ty_bound.rewrite(context,\n-                                                                budget,\n-                                                                offset + used_width)\n-                                                       .unwrap()\n-                                           })\n-                                           .collect::<Vec<_>>()\n-                                           .join(\" + \");\n+                    let bounds_str = try_opt!(bounds.iter()\n+                                                    .map(|ty_bound| {\n+                                                        ty_bound.rewrite(context,\n+                                                                         budget,\n+                                                                         offset + used_width)\n+                                                    })\n+                                                    .collect::<Option<Vec<_>>>())\n+                                         .join(\" + \");\n \n                     format!(\"for<{}> {}: {}\", lifetime_str, type_str, bounds_str)\n                 } else {\n                     // 2 = \": \".len()\n                     let used_width = type_str.len() + 2;\n                     let budget = try_opt!(width.checked_sub(used_width));\n-                    let bounds_str = bounds.iter()\n-                                           .map(|ty_bound| {\n-                                               ty_bound.rewrite(context,\n-                                                                budget,\n-                                                                offset + used_width)\n-                                                       .unwrap()\n-                                           })\n-                                           .collect::<Vec<_>>()\n-                                           .join(\" + \");\n+                    let bounds_str = try_opt!(bounds.iter()\n+                                                    .map(|ty_bound| {\n+                                                        ty_bound.rewrite(context,\n+                                                                         budget,\n+                                                                         offset + used_width)\n+                                                    })\n+                                                    .collect::<Option<Vec<_>>>())\n+                                         .join(\" + \");\n \n                     format!(\"{}: {}\", type_str, bounds_str)\n                 }\n@@ -371,8 +363,7 @@ impl Rewrite for ast::TyParamBound {\n             }\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n                 let budget = try_opt!(width.checked_sub(1));\n-                Some(format!(\"?{}\",\n-                             try_opt!(tref.rewrite(context, budget, offset + 1))))\n+                Some(format!(\"?{}\", try_opt!(tref.rewrite(context, budget, offset + 1))))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => {\n                 Some(pprust::lifetime_to_string(l))\n@@ -383,9 +374,9 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        let strs: Vec<_> = self.iter()\n-                               .map(|b| b.rewrite(context, width, offset).unwrap())\n-                               .collect();\n+        let strs: Vec<_> = try_opt!(self.iter()\n+                                        .map(|b| b.rewrite(context, width, offset))\n+                                        .collect());\n         Some(strs.join(\" + \"))\n     }\n }\n@@ -398,10 +389,10 @@ impl Rewrite for ast::TyParam {\n         if !self.bounds.is_empty() {\n             result.push_str(\": \");\n \n-            let bounds = self.bounds\n-                             .iter()\n-                             .map(|ty_bound| ty_bound.rewrite(context, width, offset).unwrap())\n-                             .collect::<Vec<_>>()\n+            let bounds = try_opt!(self.bounds\n+                                      .iter()\n+                                      .map(|ty_bound| ty_bound.rewrite(context, width, offset))\n+                                      .collect::<Option<Vec<_>>>())\n                              .join(\" + \");\n \n             result.push_str(&bounds);\n@@ -421,10 +412,10 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str = self.bound_lifetimes\n-                                   .iter()\n-                                   .map(|lt| lt.rewrite(context, width, offset).unwrap())\n-                                   .collect::<Vec<_>>()\n+            let lifetime_str = try_opt!(self.bound_lifetimes\n+                                            .iter()\n+                                            .map(|lt| lt.rewrite(context, width, offset))\n+                                            .collect::<Option<Vec<_>>>())\n                                    .join(\", \");\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;"}, {"sha": "69217034d000bcfc106b31d2f89d831bc6cc4b9a", "filename": "src/visitor.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eeae3944e8cfd26b00275c4f05fdef81b15e263/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=5eeae3944e8cfd26b00275c4f05fdef81b15e263", "patch": "@@ -319,9 +319,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     fn format_mod(&mut self, m: &ast::Mod, s: Span, ident: ast::Ident) {\n-        debug!(\"FmtVisitor::format_mod: ident: {:?}, span: {:?}\",\n-               ident,\n-               s);\n+        debug!(\"FmtVisitor::format_mod: ident: {:?}, span: {:?}\", ident, s);\n \n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n@@ -359,9 +357,7 @@ impl<'a> FmtVisitor<'a> {\n             overflow_indent: Indent::empty(),\n         };\n         // 1 = \";\"\n-        match vp.rewrite(&context,\n-                         self.config.max_width - offset.width() - 1,\n-                         offset) {\n+        match vp.rewrite(&context, self.config.max_width - offset.width() - 1, offset) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, span.lo);"}]}