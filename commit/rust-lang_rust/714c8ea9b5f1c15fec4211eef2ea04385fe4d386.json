{"sha": "714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNGM4ZWE5YjVmMWMxNWZlYzQyMTFlZWYyZWEwNDM4NWZlNGQzODY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-09T12:07:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-09T12:07:29Z"}, "message": "Rollup merge of #63114 - matthewjasper:hygienic-format-args, r=petrochenkov\n\nRemove gensym in format_args\n\nThis also fixes some things to allow us to export opaque macros from libcore:\n\n* Don't consider items that are only reachable through opaque macros as public/exported (so they aren't linted as needing docs)\n* Mark private items reachable from the root of libcore as unstable - they are now reachable (in principle) in other crates via macros in libcore\n\nr? @petrochenkov", "tree": {"sha": "2a6ba0b6e5280ac86fa97e80c5e4eab237a99d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a6ba0b6e5280ac86fa97e80c5e4eab237a99d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdTWIBCRBK7hj4Ov3rIwAAdHIIAKR7Yo96tQKsOGDumSAQXaET\nLOwtA+X2ryYeAJvrBwXBdGpupP9MZhsH0dLk6D9/l1gRplak9BIe3ZPF6l/925Uq\n/B/vayiQ4fkX672JlVmGveR15mVyTXErI4cfJbByu+B+9h4/2TUCyC6WQ5V8KX9u\nQLj51396k5rnYF8M0Km2m1+Uf/mxHtZzFpfk1sFvuyuEwWIUZ2xRPMS1Bs4Nu5vP\nLXdyRxBgXd0h2yAPpDW19Uf3dlqJKJ3QuKYyJQsxorrV59j1fJ96/afGXnMBQJrn\npgi6WhCP+bY1W4+WK4BynYEw/uIBidQyR38+TqtNFYQk3kOG+3Xq2XnBMzsoDo0=\n=e3ym\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a6ba0b6e5280ac86fa97e80c5e4eab237a99d71\nparent a03872645fc655125e43e56bd12c335b2fb19c2e\nparent d9d9246418ae884cb67feb3574832696660b8e2e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565352449 +0200\ncommitter GitHub <noreply@github.com> 1565352449 +0200\n\nRollup merge of #63114 - matthewjasper:hygienic-format-args, r=petrochenkov\n\nRemove gensym in format_args\n\nThis also fixes some things to allow us to export opaque macros from libcore:\n\n* Don't consider items that are only reachable through opaque macros as public/exported (so they aren't linted as needing docs)\n* Mark private items reachable from the root of libcore as unstable - they are now reachable (in principle) in other crates via macros in libcore\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "html_url": "https://github.com/rust-lang/rust/commit/714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a03872645fc655125e43e56bd12c335b2fb19c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03872645fc655125e43e56bd12c335b2fb19c2e", "html_url": "https://github.com/rust-lang/rust/commit/a03872645fc655125e43e56bd12c335b2fb19c2e"}, {"sha": "d9d9246418ae884cb67feb3574832696660b8e2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9d9246418ae884cb67feb3574832696660b8e2e", "html_url": "https://github.com/rust-lang/rust/commit/d9d9246418ae884cb67feb3574832696660b8e2e"}], "stats": {"total": 373, "additions": 310, "deletions": 63}, "files": [{"sha": "667b35d0f775ac039de111572592d0aa1a4fb469", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -768,7 +768,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ }),\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -780,7 +779,6 @@ pub(crate) mod builtin {\n                          language use and is subject to change\")]\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ }),\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })"}, {"sha": "3fae3a46ada6b7c20be05f336bdb4d2b82745cb8", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -14,8 +14,8 @@ pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n     micro: 0,\n     _priv: (),\n };\n-pub mod general_category {\n-    pub const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+pub(crate) mod general_category {\n+    const Cc_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 0\n         ],\n@@ -28,7 +28,7 @@ pub mod general_category {\n         Cc_table.lookup(c)\n     }\n \n-    pub const N_table: &super::BoolTrie = &super::BoolTrie {\n+    const N_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x0000000000000000, 0x720c000000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -141,8 +141,8 @@ pub mod general_category {\n \n }\n \n-pub mod derived_property {\n-    pub const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n+pub(crate) mod derived_property {\n+    const Alphabetic_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -327,7 +327,7 @@ pub mod derived_property {\n         Alphabetic_table.lookup(c)\n     }\n \n-    pub const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n+    const Case_Ignorable_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0400408000000000, 0x0000000140000000, 0x0190a10000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -464,7 +464,7 @@ pub mod derived_property {\n         Case_Ignorable_table.lookup(c)\n     }\n \n-    pub const Cased_table: &super::BoolTrie = &super::BoolTrie {\n+    const Cased_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xf7ffffffffffffff, 0xfffffffffffffff0,\n@@ -565,7 +565,7 @@ pub mod derived_property {\n         Cased_table.lookup(c)\n     }\n \n-    pub const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n+    const Grapheme_Extend_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n             0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000,\n@@ -689,7 +689,7 @@ pub mod derived_property {\n         Grapheme_Extend_table.lookup(c)\n     }\n \n-    pub const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n+    const Lowercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe00000000, 0x0420040000000000, 0xff7fffff80000000,\n             0x55aaaaaaaaaaaaaa, 0xd4aaaaaaaaaaab55, 0xe6512d2a4e243129, 0xaa29aaaab5555240,\n@@ -789,7 +789,7 @@ pub mod derived_property {\n         Lowercase_table.lookup(c)\n     }\n \n-    pub const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n+    const Uppercase_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x0000000007fffffe, 0x0000000000000000, 0x000000007f7fffff,\n             0xaa55555555555555, 0x2b555555555554aa, 0x11aed2d5b1dbced6, 0x55d255554aaaa490,\n@@ -890,7 +890,7 @@ pub mod derived_property {\n         Uppercase_table.lookup(c)\n     }\n \n-    pub const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n+    const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -1068,7 +1068,7 @@ pub mod derived_property {\n         XID_Continue_table.lookup(c)\n     }\n \n-    pub const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n+    const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n         r1: [\n             0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n             0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n@@ -1250,8 +1250,8 @@ pub mod derived_property {\n \n }\n \n-pub mod property {\n-    pub const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+pub(crate) mod property {\n+    const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1268,7 +1268,7 @@ pub mod property {\n         Pattern_White_Space_table.lookup(c)\n     }\n \n-    pub const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n+    const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n             1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n@@ -1290,7 +1290,7 @@ pub mod property {\n \n }\n \n-pub mod conversions {\n+pub(crate) mod conversions {\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {\n             None        => [c, '\\0', '\\0'],"}, {"sha": "6de5d9e033b9309bd47e336cc6c4a162839ed55f", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -606,7 +606,7 @@ def compute_trie(raw_data, chunk_size):\n     return root, child_data\n \n \n-def generate_bool_trie(name, codepoint_ranges, is_pub=True):\n+def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n     # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n     \"\"\"\n     Generate Rust code for BoolTrie struct.\n@@ -681,7 +681,7 @@ def generate_bool_trie(name, codepoint_ranges, is_pub=True):\n     yield \"    };\\n\\n\"\n \n \n-def generate_small_bool_trie(name, codepoint_ranges, is_pub=True):\n+def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n     # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n     \"\"\"\n     Generate Rust code for `SmallBoolTrie` struct.\n@@ -726,7 +726,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n     Generate Rust code for module defining properties.\n     \"\"\"\n \n-    yield \"pub mod %s {\\n\" % mod\n+    yield \"pub(crate) mod %s {\\n\" % mod\n     for cat in sorted(category_subset):\n         if cat in (\"Cc\", \"White_Space\", \"Pattern_White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -749,7 +749,7 @@ def generate_conversions_module(unicode_data):\n     Generate Rust code for module defining conversions.\n     \"\"\"\n \n-    yield \"pub mod conversions {\"\n+    yield \"pub(crate) mod conversions {\"\n     yield \"\"\"\n     pub fn to_lower(c: char) -> [char; 3] {\n         match bsearch_case_table(c, to_lowercase_table) {"}, {"sha": "9dce61492dab55066e1056897c2596ece03df41f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 159, "deletions": 31, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -229,6 +229,13 @@ fn def_id_visibility<'tcx>(\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                Node::MacroDef(macro_def) => {\n+                    if attr::contains_name(&macro_def.attrs, sym::macro_export) {\n+                        return (ty::Visibility::Public, macro_def.span, \"public\");\n+                    } else {\n+                        &macro_def.vis\n+                    }\n+                },\n                 Node::TraitItem(..) | Node::Variant(..) => {\n                     return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n@@ -433,11 +440,24 @@ impl VisibilityLike for Option<AccessLevel> {\n struct EmbargoVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // Accessibility levels for reachable nodes.\n+    /// Accessibility levels for reachable nodes.\n     access_levels: AccessLevels,\n-    // Previous accessibility level; `None` means unreachable.\n+    /// A set of pairs corresponding to modules, where the first module is\n+    /// reachable via a macro that's defined in the second module. This cannot\n+    /// be represented as reachable because it can't handle the following case:\n+    ///\n+    /// pub mod n {                         // Should be `Public`\n+    ///     pub(crate) mod p {              // Should *not* be accessible\n+    ///         pub fn f() -> i32 { 12 }    // Must be `Reachable`\n+    ///     }\n+    /// }\n+    /// pub macro m() {\n+    ///     n::p::f()\n+    /// }\n+    macro_reachable: FxHashSet<(hir::HirId, DefId)>,\n+    /// Previous accessibility level; `None` means unreachable.\n     prev_level: Option<AccessLevel>,\n-    // Has something changed in the level map?\n+    /// Has something changed in the level map?\n     changed: bool,\n }\n \n@@ -452,7 +472,7 @@ impl EmbargoVisitor<'tcx> {\n         self.access_levels.map.get(&id).cloned()\n     }\n \n-    // Updates node level and returns the updated level.\n+    /// Updates node level and returns the updated level.\n     fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n@@ -477,6 +497,127 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n+    /// Updates the item as being reachable through a macro defined in the given\n+    /// module. Returns `true` if the level has changed.\n+    fn update_macro_reachable(&mut self, reachable_mod: hir::HirId, defining_mod: DefId) -> bool {\n+        if self.macro_reachable.insert((reachable_mod, defining_mod)) {\n+            self.update_macro_reachable_mod(reachable_mod, defining_mod);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn update_macro_reachable_mod(\n+        &mut self,\n+        reachable_mod: hir::HirId,\n+        defining_mod: DefId,\n+    ) {\n+        let module_def_id = self.tcx.hir().local_def_id(reachable_mod);\n+        let module = self.tcx.hir().get_module(module_def_id).0;\n+        for item_id in &module.item_ids {\n+            let hir_id = item_id.id;\n+            let item_def_id = self.tcx.hir().local_def_id(hir_id);\n+            if let Some(def_kind) = self.tcx.def_kind(item_def_id) {\n+                let item = self.tcx.hir().expect_item(hir_id);\n+                let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+                self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n+            }\n+        }\n+\n+        if let Some(exports) = self.tcx.module_exports(module_def_id) {\n+            for export in exports {\n+                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n+                    if let Res::Def(def_kind, def_id) = export.res {\n+                        let vis = def_id_visibility(self.tcx, def_id).0;\n+                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                            self.update_macro_reachable_def(\n+                                hir_id,\n+                                def_kind,\n+                                vis,\n+                                defining_mod,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_macro_reachable_def(\n+        &mut self,\n+        hir_id: hir::HirId,\n+        def_kind: DefKind,\n+        vis: ty::Visibility,\n+        module: DefId,\n+    ) {\n+        let level = Some(AccessLevel::Reachable);\n+        if let ty::Visibility::Public = vis {\n+            self.update(hir_id, level);\n+        }\n+        match def_kind {\n+            // No type privacy, so can be directly marked as reachable.\n+            DefKind::Const\n+            | DefKind::Macro(_)\n+            | DefKind::Static\n+            | DefKind::TraitAlias\n+            | DefKind::TyAlias => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update(hir_id, level);\n+                }\n+            },\n+\n+            // We can't use a module name as the final segment of a path, except\n+            // in use statements. Since re-export checking doesn't consider\n+            // hygiene these don't need to be marked reachable. The contents of\n+            // the module, however may be reachable.\n+            DefKind::Mod => {\n+                if vis.is_accessible_from(module, self.tcx) {\n+                    self.update_macro_reachable(hir_id, module);\n+                }\n+            }\n+\n+            DefKind::Struct | DefKind::Union => {\n+                // While structs and unions have type privacy, their fields do\n+                // not.\n+                if let ty::Visibility::Public = vis {\n+                    let item = self.tcx.hir().expect_item(hir_id);\n+                    if let hir::ItemKind::Struct(ref struct_def, _)\n+                        | hir::ItemKind::Union(ref struct_def, _) = item.node\n+                    {\n+                        for field in struct_def.fields() {\n+                            let field_vis = ty::Visibility::from_hir(\n+                                &field.vis,\n+                                field.hir_id,\n+                                self.tcx,\n+                            );\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n+                                self.reach(field.hir_id, level).ty();\n+                            }\n+                        }\n+                    } else {\n+                        bug!(\"item {:?} with DefKind {:?}\", item, def_kind);\n+                    }\n+                }\n+            }\n+\n+            // These have type privacy, so are not reachable unless they're\n+            // public\n+            DefKind::AssocConst\n+            | DefKind::AssocTy\n+            | DefKind::AssocOpaqueTy\n+            | DefKind::ConstParam\n+            | DefKind::Ctor(_, _)\n+            | DefKind::Enum\n+            | DefKind::ForeignTy\n+            | DefKind::Fn\n+            | DefKind::OpaqueTy\n+            | DefKind::Method\n+            | DefKind::Trait\n+            | DefKind::TyParam\n+            | DefKind::Variant => (),\n+        }\n+    }\n \n     /// Given the path segments of a `ItemKind::Use`, then we need\n     /// to update the visibility of the intermediate use so that it isn't linted\n@@ -746,40 +887,21 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             return\n         }\n \n-        let module_did = ty::DefIdTree::parent(\n+        let macro_module_def_id = ty::DefIdTree::parent(\n             self.tcx,\n             self.tcx.hir().local_def_id(md.hir_id)\n         ).unwrap();\n-        let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_hir_id(macro_module_def_id).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(md.hir_id, level);\n-        if level.is_none() {\n+        let new_level = self.update(md.hir_id, level);\n+        if new_level.is_none() {\n             return\n         }\n \n         loop {\n-            let module = if module_id == hir::CRATE_HIR_ID {\n-                &self.tcx.hir().krate().module\n-            } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item(module_id).node {\n-                module\n-            } else {\n-                unreachable!()\n-            };\n-            for id in &module.item_ids {\n-                self.update(id.id, level);\n-            }\n-            let def_id = self.tcx.hir().local_def_id(module_id);\n-            if let Some(exports) = self.tcx.module_exports(def_id) {\n-                for export in exports.iter() {\n-                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.res.def_id()) {\n-                        self.update(hir_id, level);\n-                    }\n-                }\n-            }\n-\n-            if module_id == hir::CRATE_HIR_ID {\n-                break\n+            let changed_reachability = self.update_macro_reachable(module_id, macro_module_def_id);\n+            if changed_reachability || module_id == hir::CRATE_HIR_ID {\n+                break;\n             }\n             module_id = self.tcx.hir().get_parent_node(module_id);\n         }\n@@ -826,7 +948,12 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n-            self.ev.update(hir_id, self.access_level);\n+            if let ((ty::Visibility::Public, ..), _)\n+                | (_, Some(AccessLevel::ReachableFromImplTrait))\n+                = (def_id_visibility(self.tcx(), def_id), self.access_level)\n+            {\n+                self.ev.update(hir_id, self.access_level);\n+            }\n         }\n         false\n     }\n@@ -1865,6 +1992,7 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, krate: CrateNum) -> &AccessLevels {\n     let mut visitor = EmbargoVisitor {\n         tcx,\n         access_levels: Default::default(),\n+        macro_reachable: Default::default(),\n         prev_level: Some(AccessLevel::Public),\n         changed: false,\n     };"}, {"sha": "2ae13b66e28536d3741ff09db6fb3946f7433e61", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -645,7 +645,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut heads = Vec::with_capacity(self.args.len());\n \n         let names_pos: Vec<_> = (0..self.args.len())\n-            .map(|i| self.ecx.ident_of(&format!(\"arg{}\", i)).gensym())\n+            .map(|i| ast::Ident::from_str_and_span(&format!(\"arg{}\", i), self.macsp))\n             .collect();\n \n         // First, build up the static array which will become our precompiled\n@@ -842,7 +842,7 @@ pub fn expand_preparsed_format_args(\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n \n     let mut macsp = ecx.call_site();\n-    macsp = macsp.apply_mark(ecx.current_expansion.id);\n+    macsp = macsp.with_ctxt(ecx.backtrace());\n \n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;"}, {"sha": "30ba70bdfeb66bc3699c0d74edbe73003adb1f05", "filename": "src/test/ui/definition-reachable/auxiliary/field-method-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Ffield-method-macro.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,23 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub struct B(pub(crate) p::C);\n+    impl B {\n+        pub fn new() -> Self {\n+            B(p::C)\n+        }\n+    }\n+    mod p {\n+        pub struct C;\n+\n+        impl C {\n+            pub fn foo(&self) -> i32 {\n+                33\n+            }\n+        }\n+    }\n+}\n+\n+pub macro m() {\n+    n::B::new().0.foo()\n+}"}, {"sha": "a39e8c986c3911df50ec764a1c49a886f7d38b61", "filename": "src/test/ui/definition-reachable/auxiliary/nested-fn-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fnested-fn-macro.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub(crate) mod p {\n+        pub fn f() -> i32 { 12 }\n+    }\n+}\n+\n+pub macro m() {\n+    n::p::f()\n+}"}, {"sha": "4f283d9c19c04f55b7533321c0aff385afa04fb4", "filename": "src/test/ui/definition-reachable/auxiliary/private-use-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fauxiliary%2Fprivate-use-macro.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,11 @@\n+#![feature(decl_macro)]\n+\n+mod n {\n+    pub static S: i32 = 57;\n+}\n+\n+use n::S;\n+\n+pub macro m() {\n+    S\n+}"}, {"sha": "60e895a2f9a0742db232c47f95de091562c1a320", "filename": "src/test/ui/definition-reachable/field-method.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Ffield-method.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions accessible through a field visible to a macro are\n+// considered reachable\n+\n+// aux-build:nested-fn-macro.rs\n+// run-pass\n+\n+extern crate nested_fn_macro;\n+\n+fn main() {\n+    assert_eq!(nested_fn_macro::m!(), 12);\n+}"}, {"sha": "b596ba8936a4391142680f3aceccd3970f9819ee", "filename": "src/test/ui/definition-reachable/nested-fn.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fnested-fn.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,11 @@\n+// Check that functions visible to macros through paths with >2 segements are\n+// considered reachable\n+\n+// aux-build:field-method-macro.rs\n+// run-pass\n+\n+extern crate field_method_macro;\n+\n+fn main() {\n+    assert_eq!(field_method_macro::m!(), 33);\n+}"}, {"sha": "a601dabcb0b3fdfe9643ea4b358ff68aa791340e", "filename": "src/test/ui/definition-reachable/private-non-types.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-non-types.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,21 @@\n+// Check that we don't require stability annotations for private modules,\n+// imports and fields that are accessible to opaque macros.\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+extern crate std as local_std;\n+use local_std::marker::Copy as LocalCopy;\n+mod private_mod {\n+    #[stable(feature = \"test\", since = \"1.0.0\")]\n+    pub struct A {\n+        pub(crate) f: i32,\n+    }\n+}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02c1224f4e142e63ce23836a49e6c3eb382eb8de", "filename": "src/test/ui/definition-reachable/private-types.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-types.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,19 @@\n+// Check that type privacy is taken into account when considering reachability\n+\n+// check-pass\n+\n+#![feature(decl_macro, staged_api)]\n+#![stable(feature = \"test\", since = \"1.0.0\")]\n+\n+// Type privacy should prevent use of these in other crates, so we shouldn't\n+// need a stability annotation.\n+fn private_function() {}\n+struct PrivateStruct { f: () }\n+enum PrivateEnum { V }\n+union PrivateUnion { g: () }\n+trait PrivateTrait {}\n+\n+#[stable(feature = \"test\", since = \"1.0.0\")]\n+pub macro m() {}\n+\n+fn main() {}"}, {"sha": "02cff0475e586447cd657de642cc20db47a1abbd", "filename": "src/test/ui/definition-reachable/private-use.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdefinition-reachable%2Fprivate-use.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,10 @@\n+// Check that private use statements can be used by\n+\n+// run-pass\n+// aux-build:private-use-macro.rs\n+\n+extern crate private_use_macro;\n+\n+fn main() {\n+    assert_eq!(private_use_macro::m!(), 57);\n+}"}, {"sha": "6bf5ae8beaddb91a9984df5187eab1198443f79e", "filename": "src/test/ui/format-hygiene.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a03872645fc655125e43e56bd12c335b2fb19c2e/src%2Ftest%2Fui%2Fformat-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a03872645fc655125e43e56bd12c335b2fb19c2e/src%2Ftest%2Fui%2Fformat-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fformat-hygiene.rs?ref=a03872645fc655125e43e56bd12c335b2fb19c2e", "patch": "@@ -1,8 +0,0 @@\n-// run-pass\n-\n-#![allow(non_upper_case_globals)]\n-pub const arg0: u8 = 1;\n-\n-pub fn main() {\n-    format!(\"{}\", 1);\n-}"}, {"sha": "d74889b95cc12de3a8ce704f6381ada6e564953f", "filename": "src/test/ui/hygiene/format-args.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/714c8ea9b5f1c15fec4211eef2ea04385fe4d386/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fformat-args.rs?ref=714c8ea9b5f1c15fec4211eef2ea04385fe4d386", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![allow(non_upper_case_globals)]\n+#![feature(format_args_nl)]\n+\n+static arg0: () = ();\n+\n+fn main() {\n+    static arg1: () = ();\n+    format_args!(\"{} {:?}\", 0, 1);\n+    format_args_nl!(\"{} {:?}\", 0, 1);\n+}"}]}