{"sha": "7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOWRhYThmZjcxY2I1ODk2YWY5YmI5YTZlYzhlMTUzOTFlNzZiNGU=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-15T03:57:11Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-23T05:19:53Z"}, "message": "Remove RcMut\n\nRc<Mut<T>> should be used instead", "tree": {"sha": "88befa3aa9a8b826fe2f813f9bb27be690323de4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88befa3aa9a8b826fe2f813f9bb27be690323de4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "html_url": "https://github.com/rust-lang/rust/commit/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1", "html_url": "https://github.com/rust-lang/rust/commit/0fade3a714f7a7f9bff5c11f9f37528d0ab168a1"}], "stats": {"total": 261, "additions": 14, "deletions": 247}, "files": [{"sha": "c4ee2190ad83ba75abadaf22f10196c85622c864", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 0, "deletions": 237, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "patch": "@@ -14,10 +14,6 @@ The `Rc` type provides shared ownership of an immutable value. Destruction is de\n will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n overhead of atomic reference counting.\n \n-The `RcMut` type provides shared ownership of a mutable value. Since multiple owners prevent\n-inherited mutability, a dynamic freezing check is used to maintain the invariant that an `&mut`\n-reference is a unique handle and the type is marked as non-`Freeze`.\n-\n */\n \n use ptr::RawPtr;\n@@ -151,236 +147,3 @@ mod test_rc {\n         assert_eq!(**x.borrow(), 5);\n     }\n }\n-\n-#[deriving(Eq)]\n-enum Borrow {\n-    Mutable,\n-    Immutable,\n-    Nothing\n-}\n-\n-struct RcMutBox<T> {\n-    value: T,\n-    count: uint,\n-    borrow: Borrow\n-}\n-\n-/// Mutable reference counted pointer type\n-#[no_send]\n-#[no_freeze]\n-#[unsafe_no_drop_flag]\n-pub struct RcMut<T> {\n-    priv ptr: *mut RcMutBox<T>,\n-}\n-\n-impl<T: Freeze> RcMut<T> {\n-    /// Construct a new mutable reference-counted box from a `Freeze` value\n-    #[inline]\n-    pub fn new(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new_unchecked(value) }\n-    }\n-}\n-\n-impl<T: Send> RcMut<T> {\n-    /// Construct a new mutable reference-counted box from a `Send` value\n-    #[inline]\n-    pub fn from_send(value: T) -> RcMut<T> {\n-        unsafe { RcMut::new_unchecked(value) }\n-    }\n-}\n-\n-impl<T> RcMut<T> {\n-    /// Unsafety construct a new mutable reference-counted box from any value.\n-    ///\n-    /// It is possible to create cycles, which will leak, and may interact\n-    /// poorly with managed pointers.\n-    #[inline]\n-    pub unsafe fn new_unchecked(value: T) -> RcMut<T> {\n-        RcMut{ptr: transmute(~RcMutBox{value: value, count: 1, borrow: Nothing})}\n-    }\n-}\n-\n-impl<T> RcMut<T> {\n-    /// Fails if there is already a mutable borrow of the box\n-    #[inline]\n-    pub fn with_borrow<U>(&self, f: |&T| -> U) -> U {\n-        unsafe {\n-            assert!((*self.ptr).borrow != Mutable);\n-            let previous = (*self.ptr).borrow;\n-            (*self.ptr).borrow = Immutable;\n-            let res = f(&(*self.ptr).value);\n-            (*self.ptr).borrow = previous;\n-            res\n-        }\n-    }\n-\n-    /// Fails if there is already a mutable or immutable borrow of the box\n-    #[inline]\n-    pub fn with_mut_borrow<U>(&self, f: |&mut T| -> U) -> U {\n-        unsafe {\n-            assert_eq!((*self.ptr).borrow, Nothing);\n-            (*self.ptr).borrow = Mutable;\n-            let res = f(&mut (*self.ptr).value);\n-            (*self.ptr).borrow = Nothing;\n-            res\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for RcMut<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.ptr.is_not_null() {\n-                (*self.ptr).count -= 1;\n-                if (*self.ptr).count == 0 {\n-                    let _: ~RcMutBox<T> = transmute(self.ptr);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for RcMut<T> {\n-    /// Return a shallow copy of the reference counted pointer.\n-    #[inline]\n-    fn clone(&self) -> RcMut<T> {\n-        unsafe {\n-            (*self.ptr).count += 1;\n-            RcMut{ptr: self.ptr}\n-        }\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for RcMut<T> {\n-    /// Return a deep copy of the reference counted pointer.\n-    #[inline]\n-    fn deep_clone(&self) -> RcMut<T> {\n-        do self.with_borrow |x| {\n-            // FIXME: #6497: should avoid freeze (slow)\n-            unsafe { RcMut::new_unchecked(x.deep_clone()) }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test_rc_mut {\n-    use super::*;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-        do x.with_mut_borrow |value| {\n-            *value = 20;\n-        }\n-        do y.with_borrow |value| {\n-            assert_eq!(*value, 20);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_deep_clone() {\n-        let x = RcMut::new(5);\n-        let y = x.deep_clone();\n-        do x.with_mut_borrow |value| {\n-            *value = 20;\n-        }\n-        do y.with_borrow |value| {\n-            assert_eq!(*value, 5);\n-        }\n-    }\n-\n-    #[test]\n-    fn borrow_many() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |a| {\n-            assert_eq!(*a, 5);\n-            do y.with_borrow |b| {\n-                assert_eq!(*b, 5);\n-                do x.with_borrow |c| {\n-                    assert_eq!(*c, 5);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn modify() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do y.with_mut_borrow |a| {\n-            assert_eq!(*a, 5);\n-            *a = 6;\n-        }\n-\n-        do x.with_borrow |a| {\n-            assert_eq!(*a, 6);\n-        }\n-    }\n-\n-    #[test]\n-    fn release_immutable() {\n-        let x = RcMut::from_send(5);\n-        do x.with_borrow |_| {}\n-        do x.with_mut_borrow |_| {}\n-    }\n-\n-    #[test]\n-    fn release_mutable() {\n-        let x = RcMut::new(5);\n-        do x.with_mut_borrow |_| {}\n-        do x.with_borrow |_| {}\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn frozen() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |_| {\n-            do y.with_mut_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mutable_dupe() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do x.with_mut_borrow |_| {\n-            do y.with_mut_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn mutable_freeze() {\n-        let x = RcMut::from_send(5);\n-        let y = x.clone();\n-\n-        do x.with_mut_borrow |_| {\n-            do y.with_borrow |_| {\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn restore_freeze() {\n-        let x = RcMut::new(5);\n-        let y = x.clone();\n-\n-        do x.with_borrow |_| {\n-            do x.with_borrow |_| {}\n-            do y.with_mut_borrow |_| {}\n-        }\n-    }\n-}"}, {"sha": "feea0765ec22b143603b817dbd1f2b0a256f8348", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "patch": "@@ -8,21 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::RcMut;\n+use std::rc::Rc;\n+use std::mutable::Mut;\n \n trait Foo\n {\n-    fn set(&mut self, v: RcMut<A>);\n+    fn set(&mut self, v: Rc<Mut<A>>);\n }\n \n struct B\n {\n-    v: Option<RcMut<A>>\n+    v: Option<Rc<Mut<A>>>\n }\n \n impl Foo for B\n {\n-    fn set(&mut self, v: RcMut<A>)\n+    fn set(&mut self, v: Rc<Mut<A>>)\n     {\n         self.v = Some(v);\n     }\n@@ -36,7 +37,9 @@ struct A\n fn main()\n {\n     let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n-    let v = RcMut::new(a); //~ ERROR instantiating a type parameter with an incompatible type\n+    let v = Rc::from_send(Mut::new(a));\n     let w = v.clone();\n-    v.with_mut_borrow(|p| {p.v.set(w.clone());})\n+    let b = v.borrow();\n+    let mut b = b.borrow_mut();\n+    b.get().v.set(w.clone());\n }"}, {"sha": "981cec6f0ba19a22d90d1080917c4b1a087fe3dc", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=7c9daa8ff71cb5896af9bb9a6ec8e15391e76b4e", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::RcMut;\n+use std::mutable::Mut;\n+use std::rc::Rc;\n \n fn o<T: Send>(_: &T) {}\n fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n-    let x = RcMut::from_send(0);\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Send`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::RcMut<int>`, which does not fulfill `Freeze`\n+    let x = Rc::from_send(Mut::new(0));\n+    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::mutable::Mut<int>>`, which does not fulfill `Send`\n+    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `std::rc::Rc<std::mutable::Mut<int>>`, which does not fulfill `Freeze`\n }"}]}