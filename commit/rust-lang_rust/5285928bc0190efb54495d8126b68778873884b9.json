{"sha": "5285928bc0190efb54495d8126b68778873884b9", "node_id": "C_kwDOAAsO6NoAKDUyODU5MjhiYzAxOTBlZmI1NDQ5NWQ4MTI2YjY4Nzc4ODczODg0Yjk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-08T14:09:05Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-08T14:09:05Z"}, "message": "Fix ICE when checking the HIR ty of closure args.", "tree": {"sha": "aec825e53fc74bebcc5dc2abe2bd90cf3c526680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aec825e53fc74bebcc5dc2abe2bd90cf3c526680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5285928bc0190efb54495d8126b68778873884b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5285928bc0190efb54495d8126b68778873884b9", "html_url": "https://github.com/rust-lang/rust/commit/5285928bc0190efb54495d8126b68778873884b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5285928bc0190efb54495d8126b68778873884b9/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d602ab1445a7c1982583df9297e21e137b450eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d602ab1445a7c1982583df9297e21e137b450eb2", "html_url": "https://github.com/rust-lang/rust/commit/d602ab1445a7c1982583df9297e21e137b450eb2"}], "stats": {"total": 175, "additions": 112, "deletions": 63}, "files": [{"sha": "821528d7ab9485f950eb93e46bba02698c359564", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 41, "deletions": 26, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5285928bc0190efb54495d8126b68778873884b9/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5285928bc0190efb54495d8126b68778873884b9/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=5285928bc0190efb54495d8126b68778873884b9", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable, TypeckResults};\n+use rustc_middle::ty::{self, Binder, BoundVariableKind, List, Ty, TyCtxt, TypeVisitable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -651,7 +651,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n         }\n         match parent {\n             Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n-                Some(binding_ty_auto_deref_stability(cx, ty, precedence))\n+                Some(binding_ty_auto_deref_stability(cx, ty, precedence, List::empty()))\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n@@ -703,13 +703,23 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 ExprKind::Ret(_) => {\n                     let owner_id = cx.tcx.hir().body_owner(cx.enclosing_body.unwrap());\n                     Some(\n-                        if let Node::Expr(Expr {\n-                            kind: ExprKind::Closure(&Closure { fn_decl, .. }),\n-                            ..\n-                        }) = cx.tcx.hir().get(owner_id)\n+                        if let Node::Expr(\n+                            closure @ Expr {\n+                                kind: ExprKind::Closure(&Closure { fn_decl, .. }),\n+                                ..\n+                            },\n+                        ) = cx.tcx.hir().get(owner_id)\n                         {\n                             match fn_decl.output {\n-                                FnRetTy::Return(ty) => binding_ty_auto_deref_stability(cx, ty, precedence),\n+                                FnRetTy::Return(ty) => {\n+                                    if let Some(sig) = expr_sig(cx, closure)\n+                                        && let Some(output) = sig.output()\n+                                    {\n+                                        binding_ty_auto_deref_stability(cx, ty, precedence, output.bound_vars())\n+                                    } else {\n+                                        Position::Other(precedence)\n+                                    }\n+                                },\n                                 FnRetTy::DefaultReturn(_) => Position::Other(precedence),\n                             }\n                         } else {\n@@ -731,7 +741,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .map(|(hir_ty, ty)| match hir_ty {\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n-                        Some(ty) => binding_ty_auto_deref_stability(cx, ty, precedence),\n+                        Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n                         None => ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n                             .position_for_arg(),\n                     }),\n@@ -824,7 +834,12 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn binding_ty_auto_deref_stability(cx: &LateContext<'_>, ty: &hir::Ty<'_>, precedence: i8) -> Position {\n+fn binding_ty_auto_deref_stability<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: &'tcx hir::Ty<'_>,\n+    precedence: i8,\n+    binder_args: &'tcx List<BoundVariableKind>,\n+) -> Position {\n     let TyKind::Rptr(_, ty) = &ty.kind else {\n         return Position::Other(precedence);\n     };\n@@ -856,31 +871,31 @@ fn binding_ty_auto_deref_stability(cx: &LateContext<'_>, ty: &hir::Ty<'_>, prece\n                 } else {\n                     Position::DerefStable(\n                         precedence,\n-                        cx\n-                            .typeck_results()\n-                            .node_type(ty.ty.hir_id)\n+                        cx.tcx\n+                            .erase_late_bound_regions(Binder::bind_with_vars(\n+                                cx.typeck_results().node_type(ty.ty.hir_id),\n+                                binder_args,\n+                            ))\n                             .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n                     )\n                 }\n             },\n-            TyKind::Slice(_)\n-            | TyKind::Array(..)\n-            | TyKind::BareFn(_)\n-            | TyKind::Never\n+            TyKind::Slice(_) => Position::DerefStable(precedence, false),\n+            TyKind::Array(..) | TyKind::Ptr(_) | TyKind::BareFn(_) => Position::DerefStable(precedence, true),\n+            TyKind::Never\n             | TyKind::Tup(_)\n-            | TyKind::Ptr(_)\n             | TyKind::Path(_) => Position::DerefStable(\n                 precedence,\n-                cx\n-                .typeck_results()\n-                .node_type(ty.ty.hir_id)\n-                .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                cx.tcx\n+                    .erase_late_bound_regions(Binder::bind_with_vars(\n+                        cx.typeck_results().node_type(ty.ty.hir_id),\n+                        binder_args,\n+                    ))\n+                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n             ),\n-            TyKind::OpaqueDef(..)\n-            | TyKind::Infer\n-            | TyKind::Typeof(..)\n-            | TyKind::TraitObject(..)\n-            | TyKind::Err => Position::ReborrowStable(precedence),\n+            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n+                Position::ReborrowStable(precedence)\n+            },\n         };\n     }\n }"}, {"sha": "27bc7fbfae3c73d23cc7cf4a60c28fbc272af1c2", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=5285928bc0190efb54495d8126b68778873884b9", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(closure_lifetime_binder)]\n #![warn(clippy::explicit_auto_deref)]\n #![allow(\n     dead_code,\n@@ -255,4 +256,14 @@ fn main() {\n     }\n     let x = S7([0]);\n     let _: &[u32] = &*x;\n+\n+    let c1 = |x: &Vec<&u32>| {};\n+    let x = &&vec![&1u32];\n+    c1(x);\n+    let _ = for<'a, 'b> |x: &'a &'a Vec<&'b u32>, b: bool| -> &'a Vec<&'b u32> {\n+        if b {\n+            return x;\n+        }\n+        *x\n+    };\n }"}, {"sha": "64aea9f464e484d0ea1212398d2d7cc0a3cd97c4", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=5285928bc0190efb54495d8126b68778873884b9", "patch": "@@ -1,5 +1,6 @@\n // run-rustfix\n \n+#![feature(closure_lifetime_binder)]\n #![warn(clippy::explicit_auto_deref)]\n #![allow(\n     dead_code,\n@@ -255,4 +256,14 @@ fn main() {\n     }\n     let x = S7([0]);\n     let _: &[u32] = &*x;\n+\n+    let c1 = |x: &Vec<&u32>| {};\n+    let x = &&vec![&1u32];\n+    c1(*x);\n+    let _ = for<'a, 'b> |x: &'a &'a Vec<&'b u32>, b: bool| -> &'a Vec<&'b u32> {\n+        if b {\n+            return *x;\n+        }\n+        *x\n+    };\n }"}, {"sha": "12db0c6f87fc33edc545ae89ce6ce5c1ee168f6c", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5285928bc0190efb54495d8126b68778873884b9/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=5285928bc0190efb54495d8126b68778873884b9", "patch": "@@ -1,220 +1,232 @@\n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:69:19\n+  --> $DIR/explicit_auto_deref.rs:70:19\n    |\n LL |     let _: &str = &*s;\n    |                   ^^^ help: try this: `&s`\n    |\n    = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:70:19\n+  --> $DIR/explicit_auto_deref.rs:71:19\n    |\n LL |     let _: &str = &*{ String::new() };\n    |                   ^^^^^^^^^^^^^^^^^^^ help: try this: `&{ String::new() }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:71:19\n+  --> $DIR/explicit_auto_deref.rs:72:19\n    |\n LL |     let _: &str = &mut *{ String::new() };\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&mut { String::new() }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:75:11\n+  --> $DIR/explicit_auto_deref.rs:76:11\n    |\n LL |     f_str(&*s);\n    |           ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:79:13\n+  --> $DIR/explicit_auto_deref.rs:80:13\n    |\n LL |     f_str_t(&*s, &*s); // Don't lint second param.\n    |             ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:82:24\n+  --> $DIR/explicit_auto_deref.rs:83:24\n    |\n LL |     let _: &Box<i32> = &**b;\n    |                        ^^^^ help: try this: `&b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:88:7\n+  --> $DIR/explicit_auto_deref.rs:89:7\n    |\n LL |     c(&*s);\n    |       ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:94:9\n+  --> $DIR/explicit_auto_deref.rs:95:9\n    |\n LL |         &**x\n    |         ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:98:11\n+  --> $DIR/explicit_auto_deref.rs:99:11\n    |\n LL |         { &**x }\n    |           ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:102:9\n+  --> $DIR/explicit_auto_deref.rs:103:9\n    |\n LL |         &**{ x }\n    |         ^^^^^^^^ help: try this: `{ x }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:106:9\n+  --> $DIR/explicit_auto_deref.rs:107:9\n    |\n LL |         &***x\n    |         ^^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:123:12\n+  --> $DIR/explicit_auto_deref.rs:124:12\n    |\n LL |         f1(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:124:12\n+  --> $DIR/explicit_auto_deref.rs:125:12\n    |\n LL |         f2(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:125:12\n+  --> $DIR/explicit_auto_deref.rs:126:12\n    |\n LL |         f3(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:126:27\n+  --> $DIR/explicit_auto_deref.rs:127:27\n    |\n LL |         f4.callable_str()(&*x);\n    |                           ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:127:12\n+  --> $DIR/explicit_auto_deref.rs:128:12\n    |\n LL |         f5(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:128:12\n+  --> $DIR/explicit_auto_deref.rs:129:12\n    |\n LL |         f6(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:129:27\n+  --> $DIR/explicit_auto_deref.rs:130:27\n    |\n LL |         f7.callable_str()(&*x);\n    |                           ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:130:25\n+  --> $DIR/explicit_auto_deref.rs:131:25\n    |\n LL |         f8.callable_t()(&*x);\n    |                         ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:131:12\n+  --> $DIR/explicit_auto_deref.rs:132:12\n    |\n LL |         f9(&*x);\n    |            ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:132:13\n+  --> $DIR/explicit_auto_deref.rs:133:13\n    |\n LL |         f10(&*x);\n    |             ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:133:26\n+  --> $DIR/explicit_auto_deref.rs:134:26\n    |\n LL |         f11.callable_t()(&*x);\n    |                          ^^^ help: try this: `&x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:137:16\n+  --> $DIR/explicit_auto_deref.rs:138:16\n    |\n LL |     let _ = S1(&*s);\n    |                ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:142:21\n+  --> $DIR/explicit_auto_deref.rs:143:21\n    |\n LL |     let _ = S2 { s: &*s };\n    |                     ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:158:30\n+  --> $DIR/explicit_auto_deref.rs:159:30\n    |\n LL |             let _ = Self::S1(&**s);\n    |                              ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:159:35\n+  --> $DIR/explicit_auto_deref.rs:160:35\n    |\n LL |             let _ = Self::S2 { s: &**s };\n    |                                   ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:162:20\n+  --> $DIR/explicit_auto_deref.rs:163:20\n    |\n LL |     let _ = E1::S1(&*s);\n    |                    ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:163:25\n+  --> $DIR/explicit_auto_deref.rs:164:25\n    |\n LL |     let _ = E1::S2 { s: &*s };\n    |                         ^^^ help: try this: `&s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:181:13\n+  --> $DIR/explicit_auto_deref.rs:182:13\n    |\n LL |     let _ = (*b).foo;\n    |             ^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:182:13\n+  --> $DIR/explicit_auto_deref.rs:183:13\n    |\n LL |     let _ = (**b).foo;\n    |             ^^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:197:19\n+  --> $DIR/explicit_auto_deref.rs:198:19\n    |\n LL |     let _ = f_str(*ref_str);\n    |                   ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:199:19\n+  --> $DIR/explicit_auto_deref.rs:200:19\n    |\n LL |     let _ = f_str(**ref_ref_str);\n    |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:209:13\n+  --> $DIR/explicit_auto_deref.rs:210:13\n    |\n LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n    |             ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:210:12\n+  --> $DIR/explicit_auto_deref.rs:211:12\n    |\n LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n    |            ^^^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:219:41\n+  --> $DIR/explicit_auto_deref.rs:220:41\n    |\n LL |     let _ = || -> &'static str { return *s };\n    |                                         ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:238:9\n+  --> $DIR/explicit_auto_deref.rs:239:9\n    |\n LL |         &**x\n    |         ^^^^ help: try this: `x`\n \n-error: aborting due to 36 previous errors\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:262:8\n+   |\n+LL |     c1(*x);\n+   |        ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:265:20\n+   |\n+LL |             return *x;\n+   |                    ^^ help: try this: `x`\n+\n+error: aborting due to 38 previous errors\n "}]}