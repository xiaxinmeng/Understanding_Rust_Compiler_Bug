{"sha": "da59b8ff655522642b44e2236b75d3f8c59f0edc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTliOGZmNjU1NTIyNjQyYjQ0ZTIyMzZiNzVkM2Y4YzU5ZjBlZGM=", "commit": {"author": {"name": "Duddino", "email": "rezziandrea106@gmail.com", "date": "2020-04-16T09:28:49Z"}, "committer": {"name": "Duddino", "email": "rezziandrea106@gmail.com", "date": "2020-04-16T11:23:01Z"}, "message": "fixed missing trait method suggests incorrect code (self parameter not named self)", "tree": {"sha": "2df922d3cd2b0d8d3ad476e08c76d797db4bfcea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df922d3cd2b0d8d3ad476e08c76d797db4bfcea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da59b8ff655522642b44e2236b75d3f8c59f0edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da59b8ff655522642b44e2236b75d3f8c59f0edc", "html_url": "https://github.com/rust-lang/rust/commit/da59b8ff655522642b44e2236b75d3f8c59f0edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da59b8ff655522642b44e2236b75d3f8c59f0edc/comments", "author": null, "committer": null, "parents": [{"sha": "534a41a32952d36ec73656357777ebbea707aeb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/534a41a32952d36ec73656357777ebbea707aeb4", "html_url": "https://github.com/rust-lang/rust/commit/534a41a32952d36ec73656357777ebbea707aeb4"}], "stats": {"total": 36, "additions": 25, "deletions": 11}, "files": [{"sha": "77540ecde6cfe647f7d3e2846ef79f1a2aba0278", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=da59b8ff655522642b44e2236b75d3f8c59f0edc", "patch": "@@ -2251,26 +2251,33 @@ fn fn_sig_suggestion(\n     sig: &ty::FnSig<'_>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'_>,\n+    assoc: &ty::AssocItem,\n ) -> String {\n     let args = sig\n         .inputs()\n         .iter()\n-        .map(|ty| {\n+        .enumerate()\n+        .map(|(i, ty)| {\n             Some(match ty.kind {\n-                ty::Param(param) if param.name == kw::SelfUpper => \"self\".to_string(),\n-                ty::Ref(reg, ref_ty, mutability) => {\n+                ty::Param(_) if assoc.fn_has_self_parameter && i == 0 => \"self\".to_string(),\n+                ty::Ref(reg, _ref_ty, mutability) => {\n                     let reg = match &format!(\"{}\", reg)[..] {\n                         \"'_\" | \"\" => String::new(),\n                         reg => format!(\"{} \", reg),\n                     };\n-                    match ref_ty.kind {\n-                        ty::Param(param) if param.name == kw::SelfUpper => {\n-                            format!(\"&{}{}self\", reg, mutability.prefix_str())\n-                        }\n-                        _ => format!(\"_: {:?}\", ty),\n+                    if assoc.fn_has_self_parameter && i == 0 {\n+                        format!(\"&{}{}self\", reg, mutability.prefix_str())\n+                    }else {\n+                        format!(\"_: {:?}\", ty)\n+                    }\n+                }\n+                _ => {\n+                    if assoc.fn_has_self_parameter && i == 0 {\n+                        format!(\"self: {:?}\", ty)\n+                    } else {\n+                        format!(\"_: {:?}\", ty)\n                     }\n                 }\n-                _ => format!(\"_: {:?}\", ty),\n             })\n         })\n         .chain(std::iter::once(if sig.c_variadic { Some(\"...\".to_string()) } else { None }))\n@@ -2309,6 +2316,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n                 tcx.fn_sig(assoc.def_id).skip_binder(),\n                 assoc.ident,\n                 tcx.predicates_of(assoc.def_id),\n+                assoc,\n             )\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),"}, {"sha": "177506d917637678cf2de02e0b0494dff27fc0a1", "filename": "src/test/ui/missing/missing-items/auxiliary/m1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs?ref=da59b8ff655522642b44e2236b75d3f8c59f0edc", "patch": "@@ -2,4 +2,7 @@ pub trait X {\n     const CONSTANT: u32;\n     type Type;\n     fn method(&self, s: String) -> Self::Type;\n+    fn method2(self: Box<Self>, s: String) -> Self::Type;\n+    fn method3(other: &Self, s: String) -> Self::Type;\n+    fn method4(&self, other: &Self) -> Self::Type;\n }"}, {"sha": "3231836bc88d516d336cac968ef0900ab3a0cca7", "filename": "src/test/ui/missing/missing-items/m2.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da59b8ff655522642b44e2236b75d3f8c59f0edc/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr?ref=da59b8ff655522642b44e2236b75d3f8c59f0edc", "patch": "@@ -1,12 +1,15 @@\n-error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`\n+error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`, `method2`, `method3`, `method4`\n   --> $DIR/m2.rs:9:1\n    |\n LL | impl m1::X for X {\n-   | ^^^^^^^^^^^^^^^^ missing `CONSTANT`, `Type`, `method` in implementation\n+   | ^^^^^^^^^^^^^^^^ missing `CONSTANT`, `Type`, `method`, `method2`, `method3`, `method4` in implementation\n    |\n    = help: implement the missing item: `const CONSTANT: u32 = 42;`\n    = help: implement the missing item: `type Type = Type;`\n    = help: implement the missing item: `fn method(&self, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method2(self: std::boxed::Box<Self>, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method3(_: &Self, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method4(&self, _: &Self) -> <Self as m1::X>::Type { todo!() }`\n \n error: aborting due to previous error\n "}]}