{"sha": "71d4c368509536f7277e9a1cb6e6286ba6de7911", "node_id": "C_kwDOAAsO6NoAKDcxZDRjMzY4NTA5NTM2ZjcyNzdlOWExY2I2ZTYyODZiYTZkZTc5MTE", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2023-03-18T00:56:45Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2023-04-23T00:58:51Z"}, "message": "lane -> element for core::simd::Simd\n\nA while ago we began saying T, N instead of T, LANES in reference to Simd.\nAt some point that leaked in to us checking in code with const N: usize.\nAfter a while, we had a discussion and agreed that \"lanes\", while common,\nis unnecessary jargon for Rust learners who aren't familiar with SIMD, and\nis fully interchangeable with terms for arrays like element and index.\n\nBut we never acted on that. Let's update the main type's docs, at least.\nThe example tweaks also enable removing a slated-for-removal nightly fn.", "tree": {"sha": "545103dce52a7521f3c1a432cade4c2ba08353e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/545103dce52a7521f3c1a432cade4c2ba08353e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71d4c368509536f7277e9a1cb6e6286ba6de7911", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71d4c368509536f7277e9a1cb6e6286ba6de7911", "html_url": "https://github.com/rust-lang/rust/commit/71d4c368509536f7277e9a1cb6e6286ba6de7911", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71d4c368509536f7277e9a1cb6e6286ba6de7911/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f916add75d58dd3310e4cc217a1982d385d975a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f916add75d58dd3310e4cc217a1982d385d975a5", "html_url": "https://github.com/rust-lang/rust/commit/f916add75d58dd3310e4cc217a1982d385d975a5"}], "stats": {"total": 390, "additions": 199, "deletions": 191}, "files": [{"sha": "154b467752b6d099fc06d4ebb2334cf59db1d0f1", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 199, "deletions": 191, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/71d4c368509536f7277e9a1cb6e6286ba6de7911/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d4c368509536f7277e9a1cb6e6286ba6de7911/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=71d4c368509536f7277e9a1cb6e6286ba6de7911", "patch": "@@ -3,48 +3,55 @@ use crate::simd::{\n     SimdPartialOrd, SupportedLaneCount, Swizzle,\n };\n \n-/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+/// A SIMD vector with the shape of `[T; N]` but the operations of `T`.\n ///\n-/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n-/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n-/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n-/// the two arrays together and mapping the operator over each lane.\n+/// `Simd<T, N>` supports the operators (+, *, etc.) that `T` does in \"elementwise\" fashion.\n+/// These take the element at each index from the left-hand side and right-hand side,\n+/// perform the operation, then return the result in the same index in a vector of equal size.\n+/// In other words, an elementwise operation is equivalent to a zip, then map.\n ///\n /// ```rust\n-/// # #![feature(array_zip, portable_simd)]\n+/// # #![feature(portable_simd)]\n /// # use core::simd::{Simd};\n-/// let a0: [i32; 4] = [-2, 0, 2, 4];\n-/// let a1 = [10, 9, 8, 7];\n-/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n-/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+/// # use core::array;\n+/// let a: [i32; 4] = [-2, 0, 2, 4];\n+/// let b = [10, 9, 8, 7];\n+/// let sum = array::from_fn(|i| a[i] + b[i]);\n+/// let prod = array::from_fn(|i| a[i] * b[i]);\n ///\n /// // `Simd<T, N>` implements `From<[T; N]>\n-/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// let (v, w) = (Simd::from(a), Simd::from(b));\n /// // Which means arrays implement `Into<Simd<T, N>>`.\n-/// assert_eq!(v0 + v1, zm_add.into());\n-/// assert_eq!(v0 * v1, zm_mul.into());\n+/// assert_eq!(v + w, sum.into());\n+/// assert_eq!(v * w, prod.into());\n /// ```\n ///\n-/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+///\n+/// `Simd` with integer elements treats operators as wrapping, as if `T` was [`Wrapping<T>`].\n /// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n /// This means there is no warning on overflows, even in \"debug\" builds.\n /// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n /// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n /// You may want to consider using explicitly checked arithmetic if such is required.\n-/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+/// Division by zero on integers still causes a panic, so\n+/// you may want to consider using `f32` or `f64` if that is unacceptable.\n ///\n /// [`Wrapping<T>`]: core::num::Wrapping\n ///\n /// # Layout\n-/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), with a greater alignment.\n /// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n-/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n-/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+/// Thus it is sound to [`transmute`] `Simd<T, N>` to `[T; N]` and should optimize to \"zero cost\",\n+/// but the reverse transmutation may require a copy the compiler cannot simply elide.\n ///\n /// # ABI \"Features\"\n-/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n-/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n-/// The need for this may be corrected in the future.\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed and returned via memory,\n+/// not SIMD registers, except as an optimization. Using `#[inline]` on functions that accept\n+/// `Simd<T, N>` or return it is recommended, at the cost of code generation time, as\n+/// inlining SIMD-using functions can omit a large function prolog or epilog and thus\n+/// improve both speed and code size. The need for this may be corrected in the future.\n+///\n+/// Using `#[inline(always)]` still requires additional care.\n ///\n /// # Safe SIMD with Unsafe Rust\n ///\n@@ -55,18 +62,22 @@ use crate::simd::{\n /// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n /// [`read_unaligned`] and [`write_unaligned`]. This is because:\n /// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n-/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n-/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n-/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n-/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+/// - `Simd<T, N>` is often read from or written to [`[T]`](slice) and other types aligned to `T`\n+/// - combining these actions violates the `unsafe` contract and explodes the program into\n+///   a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned\n+///   if it sees the optimization\n+/// - most contemporary processors with \"aligned\" and \"unaligned\" read and write instructions\n+///   exhibit no performance difference if the \"unaligned\" variant is aligned at runtime\n ///\n-/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// Less obligations mean unaligned reads and writes are less likely to make the program unsound,\n /// and may be just as fast as stricter alternatives.\n-/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n-/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n-/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n-/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n-/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for\n+/// converting `[T]` to `[Simd<T, N>]`, and allows soundly operating on an aligned SIMD body,\n+/// but it may cost more time when handling the scalar head and tail.\n+/// If these are not enough, it is most ideal to design data structures to be already aligned\n+/// to `mem::align_of::<Simd<T, N>>()` before using `unsafe` Rust to read or write.\n+/// Other ways to compensate for these facts, like materializing `Simd` to or from an array first,\n /// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n ///\n /// [`transmute`]: core::mem::transmute\n@@ -82,20 +93,20 @@ use crate::simd::{\n // avoided, as it will likely become illegal on `#[repr(simd)]` structs in the future. It also\n // causes rustc to emit illegal LLVM IR in some cases.\n #[repr(simd)]\n-pub struct Simd<T, const LANES: usize>([T; LANES])\n+pub struct Simd<T, const N: usize>([T; N])\n where\n-    T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount;\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement;\n \n-impl<T, const LANES: usize> Simd<T, LANES>\n+impl<T, const N: usize> Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    /// Number of lanes in this vector.\n-    pub const LANES: usize = LANES;\n+    /// Number of elements in this vector.\n+    pub const N: usize = N;\n \n-    /// Returns the number of lanes in this SIMD vector.\n+    /// Returns the number of elements in this SIMD vector.\n     ///\n     /// # Examples\n     ///\n@@ -106,10 +117,10 @@ where\n     /// assert_eq!(v.lanes(), 4);\n     /// ```\n     pub const fn lanes(&self) -> usize {\n-        LANES\n+        Self::N\n     }\n \n-    /// Constructs a new SIMD vector with all lanes set to the given value.\n+    /// Constructs a new SIMD vector with all elements set to the given value.\n     ///\n     /// # Examples\n     ///\n@@ -120,11 +131,11 @@ where\n     /// assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n     /// ```\n     pub fn splat(value: T) -> Self {\n-        // This is preferred over `[value; LANES]`, since it's explicitly a splat:\n+        // This is preferred over `[value; N]`, since it's explicitly a splat:\n         // https://github.com/rust-lang/rust/issues/97804\n         struct Splat;\n-        impl<const LANES: usize> Swizzle<1, LANES> for Splat {\n-            const INDEX: [usize; LANES] = [0; LANES];\n+        impl<const N: usize> Swizzle<1, N> for Splat {\n+            const INDEX: [usize; N] = [0; N];\n         }\n         Splat::swizzle(Simd::<T, 1>::from([value]))\n     }\n@@ -139,30 +150,30 @@ where\n     /// let v: u64x4 = Simd::from_array([0, 1, 2, 3]);\n     /// assert_eq!(v.as_array(), &[0, 1, 2, 3]);\n     /// ```\n-    pub const fn as_array(&self) -> &[T; LANES] {\n-        // SAFETY: Transmuting between `Simd<T, LANES>` and `[T; LANES]`\n-        // is always valid and `Simd<T, LANES>` never has a lower alignment\n-        // than `[T; LANES]`.\n+    pub const fn as_array(&self) -> &[T; N] {\n+        // SAFETY: Transmuting between `Simd<T, N>` and `[T; N]`\n+        // is always valid and `Simd<T, N>` never has a lower alignment\n+        // than `[T; N]`.\n         //\n         // NOTE: This deliberately doesn't just use `&self.0`, see the comment\n         // on the struct definition for details.\n-        unsafe { &*(self as *const Self as *const [T; LANES]) }\n+        unsafe { &*(self as *const Self as *const [T; N]) }\n     }\n \n     /// Returns a mutable array reference containing the entire SIMD vector.\n-    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n-        // SAFETY: Transmuting between `Simd<T, LANES>` and `[T; LANES]`\n-        // is always valid and `Simd<T, LANES>` never has a lower alignment\n-        // than `[T; LANES]`.\n+    pub fn as_mut_array(&mut self) -> &mut [T; N] {\n+        // SAFETY: Transmuting between `Simd<T, N>` and `[T; N]`\n+        // is always valid and `Simd<T, N>` never has a lower alignment\n+        // than `[T; N]`.\n         //\n         // NOTE: This deliberately doesn't just use `&mut self.0`, see the comment\n         // on the struct definition for details.\n-        unsafe { &mut *(self as *mut Self as *mut [T; LANES]) }\n+        unsafe { &mut *(self as *mut Self as *mut [T; N]) }\n     }\n \n     /// Converts an array to a SIMD vector.\n-    pub const fn from_array(array: [T; LANES]) -> Self {\n-        // SAFETY: Transmuting between `Simd<T, LANES>` and `[T; LANES]`\n+    pub const fn from_array(array: [T; N]) -> Self {\n+        // SAFETY: Transmuting between `Simd<T, N>` and `[T; N]`\n         // is always valid. We need to use `read_unaligned` here, since\n         // the array may have a lower alignment than the vector.\n         //\n@@ -172,12 +183,12 @@ where\n         //\n         // NOTE: This deliberately doesn't just use `Self(array)`, see the comment\n         // on the struct definition for details.\n-        unsafe { (&array as *const [T; LANES] as *const Self).read_unaligned() }\n+        unsafe { (&array as *const [T; N] as *const Self).read_unaligned() }\n     }\n \n     /// Converts a SIMD vector to an array.\n-    pub const fn to_array(self) -> [T; LANES] {\n-        // SAFETY: Transmuting between `Simd<T, LANES>` and `[T; LANES]`\n+    pub const fn to_array(self) -> [T; N] {\n+        // SAFETY: Transmuting between `Simd<T, N>` and `[T; N]`\n         // is always valid. No need to use `read_unaligned` here, since\n         // the vector never has a lower alignment than the array.\n         //\n@@ -187,14 +198,14 @@ where\n         //\n         // NOTE: This deliberately doesn't just use `self.0`, see the comment\n         // on the struct definition for details.\n-        unsafe { (&self as *const Self as *const [T; LANES]).read() }\n+        unsafe { (&self as *const Self as *const [T; N]).read() }\n     }\n \n-    /// Converts a slice to a SIMD vector containing `slice[..LANES]`.\n+    /// Converts a slice to a SIMD vector containing `slice[..N]`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n     ///\n     /// # Example\n     ///\n@@ -208,21 +219,21 @@ where\n     #[must_use]\n     pub const fn from_slice(slice: &[T]) -> Self {\n         assert!(\n-            slice.len() >= LANES,\n-            \"slice length must be at least the number of lanes\"\n+            slice.len() >= Self::N,\n+            \"slice length must be at least the number of elements\"\n         );\n-        assert!(core::mem::size_of::<Self>() == LANES * core::mem::size_of::<T>());\n+        assert!(core::mem::size_of::<Self>() == Self::N * core::mem::size_of::<T>());\n         // Safety:\n         // - We've checked the length is sufficient.\n         // - `T` and `Simd<T, N>` are Copy types.\n         unsafe { slice.as_ptr().cast::<Self>().read_unaligned() }\n     }\n \n-    /// Writes a SIMD vector to the first `LANES` elements of a slice.\n+    /// Writes a SIMD vector to the first `N` elements of a slice.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n     ///\n     /// # Example\n     ///\n@@ -238,22 +249,22 @@ where\n     /// ```\n     pub fn copy_to_slice(self, slice: &mut [T]) {\n         assert!(\n-            slice.len() >= LANES,\n-            \"slice length must be at least the number of lanes\"\n+            slice.len() >= Self::N,\n+            \"slice length must be at least the number of elements\"\n         );\n-        assert!(core::mem::size_of::<Self>() == LANES * core::mem::size_of::<T>());\n+        assert!(core::mem::size_of::<Self>() == Self::N * core::mem::size_of::<T>());\n         // Safety:\n         // - We've checked the length is sufficient\n         // - `T` and `Simd<T, N>` are Copy types.\n         unsafe { slice.as_mut_ptr().cast::<Self>().write_unaligned(self) }\n     }\n \n-    /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    /// Performs elementwise conversion of a SIMD vector's elements to another SIMD-valid type.\n     ///\n-    /// This follows the semantics of Rust's `as` conversion for casting\n-    /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n-    /// and from floats to integers (truncating, or saturating at the limits) for each lane,\n-    /// or vice versa.\n+    /// This follows the semantics of Rust's `as` conversion for casting integers between\n+    /// signed and unsigned (interpreting integers as 2s complement, so `-1` to `U::MAX` and\n+    /// `1 << (U::BITS -1)` becoming `I::MIN` ), and from floats to integers (truncating,\n+    /// or saturating at the limits) for each element.\n     ///\n     /// # Examples\n     /// ```\n@@ -274,18 +285,18 @@ where\n     #[must_use]\n     #[inline]\n     #[cfg(not(bootstrap))]\n-    pub fn cast<U: SimdCast>(self) -> Simd<U, LANES>\n+    pub fn cast<U: SimdCast>(self) -> Simd<U, N>\n     where\n         T: SimdCast,\n     {\n         // Safety: supported types are guaranteed by SimdCast\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n-    /// Lanewise casts pointers to another pointer type.\n+    /// Casts a vector of pointers to another pointer type.\n     #[must_use]\n     #[inline]\n-    pub fn cast_ptr<U>(self) -> Simd<U, LANES>\n+    pub fn cast_ptr<U>(self) -> Simd<U, N>\n     where\n         T: SimdCastPtr<U>,\n         U: SimdElement,\n@@ -310,7 +321,7 @@ where\n     /// [cast]: Simd::cast\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, N>\n     where\n         T: core::convert::FloatToInt<I> + SimdCast,\n         I: SimdCast,\n@@ -320,79 +331,79 @@ where\n     }\n \n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n+    /// If an index is out-of-bounds, the element is instead selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     ///\n-    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or(&vec, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, N>, or: Self) -> Self {\n         Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is set to the default value for the type.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// If an index is out-of-bounds, the element is set to the default given by `T: Default`.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     ///\n-    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or_default(&vec, idxs);\n     /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, N>) -> Self\n     where\n         T: Default,\n     {\n         Self::gather_or(slice, idxs, Self::splat(T::default()))\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled or is out-of-bounds, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled or is out-of-bounds, the element is selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// let result = Simd::gather_select(&vec, enable, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_select(&vec, enable, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled, the element is selected from the `or` vector.\n     ///\n     /// # Safety\n     ///\n@@ -406,13 +417,13 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, SimdPartialOrd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// // The out-of-bounds index has been masked, so it's safe to gather now.\n     /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n@@ -422,18 +433,18 @@ where\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn gather_select_unchecked(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let base_ptr = Simd::<*const T, LANES>::splat(slice.as_ptr());\n+        let base_ptr = Simd::<*const T, N>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n         // Safety: The caller is responsible for determining the indices are okay to read\n         unsafe { Self::gather_select_ptr(ptrs, enable, or) }\n     }\n \n-    /// Read pointers elementwise into a SIMD vector.\n+    /// Read elementwise from pointers into a SIMD vector.\n     ///\n     /// # Safety\n     ///\n@@ -454,7 +465,7 @@ where\n     #[must_use]\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-    pub unsafe fn gather_ptr(source: Simd<*const T, LANES>) -> Self\n+    pub unsafe fn gather_ptr(source: Simd<*const T, N>) -> Self\n     where\n         T: Default,\n     {\n@@ -463,13 +474,14 @@ where\n         unsafe { Self::gather_select_ptr(source, Mask::splat(true), Self::default()) }\n     }\n \n-    /// Conditionally read pointers elementwise into a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If a lane is disabled, the lane is selected from the `or` vector and no read is performed.\n+    /// Conditionally read elementwise from pointers into a SIMD vector.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the element is selected from the `or` vector,\n+    /// and no read is performed.\n     ///\n     /// # Safety\n     ///\n-    /// Enabled lanes must satisfy the same conditions as [`core::ptr::read`].\n+    /// Enabled elements must satisfy the same conditions as [`core::ptr::read`].\n     ///\n     /// # Example\n     /// ```\n@@ -488,39 +500,40 @@ where\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn gather_select_ptr(\n-        source: Simd<*const T, LANES>,\n-        enable: Mask<isize, LANES>,\n+        source: Simd<*const T, N>,\n+        enable: Mask<isize, N>,\n         or: Self,\n     ) -> Self {\n         // Safety: The caller is responsible for upholding all invariants\n         unsafe { intrinsics::simd_gather(or, source, enable.to_int()) }\n     }\n \n     /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n-    /// If two lanes in the scattered vector would write to the same index\n-    /// only the last lane is guaranteed to actually be written.\n+    /// If an index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two elements in the scattered vector would write to the same index\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Note the duplicate index.\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     ///\n-    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// vals.scatter(&mut vec, idxs); // two logical writes means the last wins.\n     /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, N>) {\n         self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an enabled index is out-of-bounds, the lane is not written.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an enabled index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n@@ -529,29 +542,24 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Includes an out-of-bounds index\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// vals.scatter_select(&mut vec, enable, idxs); // index 0's second write is masked, thus omitted.\n+    /// vals.scatter_select(&mut vec, enable, idxs); // The last write is masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter_select(\n-        self,\n-        slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n-    ) {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+    pub fn scatter_select(self, slice: &mut [T], enable: Mask<isize, N>, idxs: Simd<usize, N>) {\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Safety\n     ///\n@@ -567,13 +575,13 @@ where\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Masks the final index\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to scatter now.\n+    /// // We have masked the OOB index, so it's safe to scatter now.\n     /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n-    /// // index 0's second write is masked, thus was omitted.\n+    /// // The second write to index 0 was masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n@@ -582,8 +590,8 @@ where\n     pub unsafe fn scatter_select_unchecked(\n         self,\n         slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n     ) {\n         // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n@@ -597,7 +605,7 @@ where\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n             // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = Simd::<*mut T, LANES>::splat(slice.as_mut_ptr());\n+            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n@@ -626,18 +634,18 @@ where\n     /// ```\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-    pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, LANES>) {\n+    pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, N>) {\n         // Safety: The caller is responsible for upholding all invariants\n         unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) }\n     }\n \n     /// Conditionally write pointers elementwise into a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If a lane is disabled, the write to that lane is skipped.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the write to its pointee is skipped.\n     ///\n     /// # Safety\n     ///\n-    /// Enabled lanes must satisfy the same conditions as [`core::ptr::write`].\n+    /// Enabled pointers must satisfy the same conditions as [`core::ptr::write`].\n     ///\n     /// # Example\n     /// ```\n@@ -654,32 +662,32 @@ where\n     /// ```\n     #[inline]\n     #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n-    pub unsafe fn scatter_select_ptr(self, dest: Simd<*mut T, LANES>, enable: Mask<isize, LANES>) {\n+    pub unsafe fn scatter_select_ptr(self, dest: Simd<*mut T, N>, enable: Mask<isize, N>) {\n         // Safety: The caller is responsible for upholding all invariants\n         unsafe { intrinsics::simd_scatter(self, dest, enable.to_int()) }\n     }\n }\n \n-impl<T, const LANES: usize> Copy for Simd<T, LANES>\n+impl<T, const N: usize> Copy for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<T, const LANES: usize> Clone for Simd<T, LANES>\n+impl<T, const N: usize> Clone for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T, const LANES: usize> Default for Simd<T, LANES>\n+impl<T, const N: usize> Default for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Default,\n {\n     #[inline]\n@@ -688,20 +696,20 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n+impl<T, const N: usize> PartialEq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialEq,\n {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_eq(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_eq(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are equal if all lanes tested true for vertical equality.\n+        // Two vectors are equal if they are elementwise equal\n         mask.all()\n     }\n \n@@ -710,18 +718,18 @@ where\n     fn ne(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_ne(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_ne(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are non-equal if any lane tested true for vertical non-equality.\n+        // Two vectors are non-equal if they are elementwise non-equal\n         mask.any()\n     }\n }\n \n-impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n+impl<T, const N: usize> PartialOrd for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialOrd,\n {\n     #[inline]\n@@ -731,16 +739,16 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> Eq for Simd<T, LANES>\n+impl<T, const N: usize> Eq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Eq,\n {\n }\n \n-impl<T, const LANES: usize> Ord for Simd<T, LANES>\n+impl<T, const N: usize> Ord for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Ord,\n {\n     #[inline]\n@@ -750,9 +758,9 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n+impl<T, const N: usize> core::hash::Hash for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + core::hash::Hash,\n {\n     #[inline]\n@@ -765,32 +773,32 @@ where\n }\n \n // array references\n-impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_ref(&self) -> &[T; LANES] {\n+    fn as_ref(&self) -> &[T; N] {\n         self.as_array()\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_mut(&mut self) -> &mut [T; LANES] {\n+    fn as_mut(&mut self) -> &mut [T; N] {\n         self.as_mut_array()\n     }\n }\n \n // slice references\n-impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n@@ -799,9 +807,9 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n@@ -811,29 +819,29 @@ where\n }\n \n // vector/array conversion\n-impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> From<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(array: [T; LANES]) -> Self {\n+    fn from(array: [T; N]) -> Self {\n         Self(array)\n     }\n }\n \n-impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n+impl<T, const N: usize> From<Simd<T, N>> for [T; N]\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(vector: Simd<T, LANES>) -> Self {\n+    fn from(vector: Simd<T, N>) -> Self {\n         vector.to_array()\n     }\n }\n \n-impl<T, const LANES: usize> TryFrom<&[T]> for Simd<T, LANES>\n+impl<T, const N: usize> TryFrom<&[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     type Error = core::array::TryFromSliceError;\n@@ -843,9 +851,9 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> TryFrom<&mut [T]> for Simd<T, LANES>\n+impl<T, const N: usize> TryFrom<&mut [T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     type Error = core::array::TryFromSliceError;"}]}