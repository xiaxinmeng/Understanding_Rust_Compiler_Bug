{"sha": "4c9896f279357896d31d811fddc2025d72259498", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOTg5NmYyNzkzNTc4OTZkMzFkODExZmRkYzIwMjVkNzIyNTk0OTg=", "commit": {"author": {"name": "12101111", "email": "w12101111@gmail.com", "date": "2021-07-26T14:47:07Z"}, "committer": {"name": "12101111", "email": "w12101111@gmail.com", "date": "2021-08-28T06:14:22Z"}, "message": "build llvm libunwind.a in rustbuild", "tree": {"sha": "2d4d9f1757a234e6a6836d04723e5154a2d83fa4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d4d9f1757a234e6a6836d04723e5154a2d83fa4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c9896f279357896d31d811fddc2025d72259498", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEERq7VLWSlisBf3CZ8l3hfrfOKl9wFAmEp1D4ACgkQl3hfrfOK\nl9xe0A//eqTp7OMWFXDjDPRCbWgumldqORW65LdbL51NQItay30cDBCE+olGCNA6\njk1wltx/dN2v105bFTJkSQXxeh2uyu5TcbzhXpyQM4BlTwh+qQNIkRUNNaJ5oqWr\nQFu4at/k9BPnG9FwZeO6xjT40rPha1dvjejvSk1mN7pjkOpcTKUGXVqWuVXaFJNm\nxVOgWONQ8jtZfTJzOD6xDi0QOQGsW6zZpdZsrkSqCR7IaluyxSNUQ60L3F8prOWW\n78QuZqOYANl9ZP14ooebKQDVGQV8ERcCUYM/oaDZQOu9ohZBcc2bqwtWNJVG9zSm\nVjfz0BqpxemvScMmpruuN74kqxZqk1sCm+PE7UMnpr2UMspg0dr2g4KOxy+vZb4J\nC/pzc+p0cJU3ecmJJK25kNSDkcYExJ8QfDMtY8b/yDT4XbnPk07S/CYn6toohFjL\nakJie+ihMk92B42QqAh24+JhEo32EWdcG17SCMA51unparSTIO6u+FBRnPyOyuBJ\n7pm9ZT7Oih4T6ckxibrhGN4HEnTfNe80uW0/HGxkfMrwu4Mqwt0Mvg5X1WOczso/\nU456kDMzuETTrtU4x+R/F29jnsuYIqE5pXMgFH2uGUeQaupeXYbsjT53VdM+zYy9\niNM7TaSGY7g9Eu/Eg0V62SQsiaTSQLtcyepLFqaiEcapk4XqDcs=\n=TZL0\n-----END PGP SIGNATURE-----", "payload": "tree 2d4d9f1757a234e6a6836d04723e5154a2d83fa4\nparent ac50a53359328a5d7f2f558833e63d59d372e4f7\nauthor 12101111 <w12101111@gmail.com> 1627310827 +0800\ncommitter 12101111 <w12101111@gmail.com> 1630131262 +0800\n\nbuild llvm libunwind.a in rustbuild\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c9896f279357896d31d811fddc2025d72259498", "html_url": "https://github.com/rust-lang/rust/commit/4c9896f279357896d31d811fddc2025d72259498", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c9896f279357896d31d811fddc2025d72259498/comments", "author": {"login": "12101111", "id": 8438475, "node_id": "MDQ6VXNlcjg0Mzg0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/8438475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/12101111", "html_url": "https://github.com/12101111", "followers_url": "https://api.github.com/users/12101111/followers", "following_url": "https://api.github.com/users/12101111/following{/other_user}", "gists_url": "https://api.github.com/users/12101111/gists{/gist_id}", "starred_url": "https://api.github.com/users/12101111/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/12101111/subscriptions", "organizations_url": "https://api.github.com/users/12101111/orgs", "repos_url": "https://api.github.com/users/12101111/repos", "events_url": "https://api.github.com/users/12101111/events{/privacy}", "received_events_url": "https://api.github.com/users/12101111/received_events", "type": "User", "site_admin": false}, "committer": {"login": "12101111", "id": 8438475, "node_id": "MDQ6VXNlcjg0Mzg0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/8438475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/12101111", "html_url": "https://github.com/12101111", "followers_url": "https://api.github.com/users/12101111/followers", "following_url": "https://api.github.com/users/12101111/following{/other_user}", "gists_url": "https://api.github.com/users/12101111/gists{/gist_id}", "starred_url": "https://api.github.com/users/12101111/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/12101111/subscriptions", "organizations_url": "https://api.github.com/users/12101111/orgs", "repos_url": "https://api.github.com/users/12101111/repos", "events_url": "https://api.github.com/users/12101111/events{/privacy}", "received_events_url": "https://api.github.com/users/12101111/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac50a53359328a5d7f2f558833e63d59d372e4f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac50a53359328a5d7f2f558833e63d59d372e4f7", "html_url": "https://github.com/rust-lang/rust/commit/ac50a53359328a5d7f2f558833e63d59d372e4f7"}], "stats": {"total": 360, "additions": 204, "deletions": 156}, "files": [{"sha": "1d0b4a59a287b05969080147a5aab691d0e36603", "filename": "library/unwind/build.rs", "status": "modified", "additions": 10, "deletions": 136, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fbuild.rs?ref=4c9896f279357896d31d811fddc2025d72259498", "patch": "@@ -4,36 +4,18 @@ fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n \n-    if cfg!(target_os = \"linux\") && cfg!(feature = \"system-llvm-libunwind\") {\n-        // linking for Linux is handled in lib.rs\n-        return;\n-    }\n-\n-    if cfg!(feature = \"llvm-libunwind\")\n-        && ((target.contains(\"linux\") && !target.contains(\"musl\")) || target.contains(\"fuchsia\"))\n-    {\n-        // Build the unwinding from libunwind C/C++ source code.\n-        llvm_libunwind::compile();\n-    } else if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n-        llvm_libunwind::compile();\n-    } else if target.contains(\"linux\") {\n-        // linking for Linux is handled in lib.rs\n-        if target.contains(\"musl\") {\n-            llvm_libunwind::compile();\n-        } else if target.contains(\"android\") {\n-            let build = cc::Build::new();\n+    if target.contains(\"android\") {\n+        let build = cc::Build::new();\n \n-            // Since ndk r23 beta 3 `libgcc` was replaced with `libunwind` thus\n-            // check if we have `libunwind` available and if so use it. Otherwise\n-            // fall back to `libgcc` to support older ndk versions.\n-            let has_unwind =\n-                build.is_flag_supported(\"-lunwind\").expect(\"Unable to invoke compiler\");\n+        // Since ndk r23 beta 3 `libgcc` was replaced with `libunwind` thus\n+        // check if we have `libunwind` available and if so use it. Otherwise\n+        // fall back to `libgcc` to support older ndk versions.\n+        let has_unwind = build.is_flag_supported(\"-lunwind\").expect(\"Unable to invoke compiler\");\n \n-            if has_unwind {\n-                println!(\"cargo:rustc-link-lib=unwind\");\n-            } else {\n-                println!(\"cargo:rustc-link-lib=gcc\");\n-            }\n+        if has_unwind {\n+            println!(\"cargo:rustc-link-lib=unwind\");\n+        } else {\n+            println!(\"cargo:rustc-link-lib=gcc\");\n         }\n     } else if target.contains(\"freebsd\") {\n         println!(\"cargo:rustc-link-lib=gcc_s\");\n@@ -63,111 +45,3 @@ fn main() {\n         // redox is handled in lib.rs\n     }\n }\n-\n-mod llvm_libunwind {\n-    use std::env;\n-    use std::path::Path;\n-\n-    /// Compile the libunwind C/C++ source code.\n-    pub fn compile() {\n-        let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-        let target_env = env::var(\"CARGO_CFG_TARGET_ENV\").unwrap();\n-        let mut cc_cfg = cc::Build::new();\n-        let mut cpp_cfg = cc::Build::new();\n-        let root = Path::new(\"../../src/llvm-project/libunwind\");\n-\n-        cpp_cfg.cpp(true);\n-        cpp_cfg.cpp_set_stdlib(None);\n-        cpp_cfg.flag(\"-nostdinc++\");\n-        cpp_cfg.flag(\"-fno-exceptions\");\n-        cpp_cfg.flag(\"-fno-rtti\");\n-        cpp_cfg.flag_if_supported(\"-fvisibility-global-new-delete-hidden\");\n-\n-        // Don't set this for clang\n-        // By default, Clang builds C code in GNU C17 mode.\n-        // By default, Clang builds C++ code according to the C++98 standard,\n-        // with many C++11 features accepted as extensions.\n-        if cpp_cfg.get_compiler().is_like_gnu() {\n-            cpp_cfg.flag(\"-std=c++11\");\n-            cc_cfg.flag(\"-std=c99\");\n-        }\n-\n-        if target.contains(\"x86_64-fortanix-unknown-sgx\") || target_env == \"musl\" {\n-            // use the same GCC C compiler command to compile C++ code so we do not need to setup the\n-            // C++ compiler env variables on the builders.\n-            // Don't set this for clang++, as clang++ is able to compile this without libc++.\n-            if cpp_cfg.get_compiler().is_like_gnu() {\n-                cpp_cfg.cpp(false);\n-            }\n-        }\n-\n-        for cfg in [&mut cc_cfg, &mut cpp_cfg].iter_mut() {\n-            cfg.warnings(false);\n-            cfg.flag(\"-fstrict-aliasing\");\n-            cfg.flag(\"-funwind-tables\");\n-            cfg.flag(\"-fvisibility=hidden\");\n-            cfg.define(\"_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS\", None);\n-            cfg.include(root.join(\"include\"));\n-            cfg.cargo_metadata(false);\n-\n-            if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n-                cfg.static_flag(true);\n-                cfg.opt_level(3);\n-                cfg.flag(\"-fno-stack-protector\");\n-                cfg.flag(\"-ffreestanding\");\n-                cfg.flag(\"-fexceptions\");\n-\n-                // easiest way to undefine since no API available in cc::Build to undefine\n-                cfg.flag(\"-U_FORTIFY_SOURCE\");\n-                cfg.define(\"_FORTIFY_SOURCE\", \"0\");\n-                cfg.define(\"RUST_SGX\", \"1\");\n-                cfg.define(\"__NO_STRING_INLINES\", None);\n-                cfg.define(\"__NO_MATH_INLINES\", None);\n-                cfg.define(\"_LIBUNWIND_IS_BAREMETAL\", None);\n-                cfg.define(\"__LIBUNWIND_IS_NATIVE_ONLY\", None);\n-                cfg.define(\"NDEBUG\", None);\n-            }\n-        }\n-\n-        let mut c_sources = vec![\n-            \"Unwind-sjlj.c\",\n-            \"UnwindLevel1-gcc-ext.c\",\n-            \"UnwindLevel1.c\",\n-            \"UnwindRegistersRestore.S\",\n-            \"UnwindRegistersSave.S\",\n-        ];\n-\n-        let cpp_sources = vec![\"Unwind-EHABI.cpp\", \"Unwind-seh.cpp\", \"libunwind.cpp\"];\n-        let cpp_len = cpp_sources.len();\n-\n-        if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n-            c_sources.push(\"UnwindRustSgx.c\");\n-        }\n-\n-        for src in c_sources {\n-            cc_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n-        }\n-\n-        for src in cpp_sources {\n-            cpp_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n-        }\n-\n-        let out_dir = env::var(\"OUT_DIR\").unwrap();\n-        println!(\"cargo:rustc-link-search=native={}\", &out_dir);\n-\n-        cpp_cfg.compile(\"unwind-cpp\");\n-\n-        let mut count = 0;\n-        for entry in std::fs::read_dir(&out_dir).unwrap() {\n-            let obj = entry.unwrap().path().canonicalize().unwrap();\n-            if let Some(ext) = obj.extension() {\n-                if ext == \"o\" {\n-                    cc_cfg.object(&obj);\n-                    count += 1;\n-                }\n-            }\n-        }\n-        assert_eq!(cpp_len, count, \"Can't get object files from {:?}\", &out_dir);\n-        cc_cfg.compile(\"unwind\");\n-    }\n-}"}, {"sha": "06384b159264789108eb7329e14b5eb85437e6d4", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=4c9896f279357896d31d811fddc2025d72259498", "patch": "@@ -1,6 +1,8 @@\n #![no_std]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n #![feature(link_cfg)]\n+#![feature(native_link_modifiers)]\n+#![feature(native_link_modifiers_bundle)]\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(static_nobundle)]\n@@ -42,14 +44,14 @@ cfg_if::cfg_if! {\n     if #[cfg(all(feature = \"llvm-libunwind\", feature = \"system-llvm-libunwind\"))] {\n         compile_error!(\"`llvm-libunwind` and `system-llvm-libunwind` cannot be enabled at the same time\");\n     } else if #[cfg(feature = \"llvm-libunwind\")] {\n-        #[link(name = \"unwind\", kind = \"static\")]\n+        #[link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")]\n         extern \"C\" {}\n     } else if #[cfg(feature = \"system-llvm-libunwind\")] {\n-        #[link(name = \"unwind\", kind = \"static-nobundle\", cfg(target_feature = \"crt-static\"))]\n+        #[link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\", cfg(target_feature = \"crt-static\"))]\n         #[link(name = \"unwind\", cfg(not(target_feature = \"crt-static\")))]\n         extern \"C\" {}\n     } else {\n-        #[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]\n+        #[link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\", cfg(target_feature = \"crt-static\"))]\n         #[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n         extern \"C\" {}\n     }\n@@ -77,10 +79,10 @@ extern \"C\" {}\n extern \"C\" {}\n \n #[cfg(target_os = \"redox\")]\n-#[link(name = \"gcc_eh\", kind = \"static-nobundle\", cfg(target_feature = \"crt-static\"))]\n+#[link(name = \"gcc_eh\", kind = \"static\", modifiers = \"-bundle\", cfg(target_feature = \"crt-static\"))]\n #[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n extern \"C\" {}\n \n #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))]\n-#[link(name = \"unwind\", kind = \"static\")]\n+#[link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")]\n extern \"C\" {}"}, {"sha": "5e15fe75a2463632f14850d7433168c16936eed8", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9896f279357896d31d811fddc2025d72259498/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=4c9896f279357896d31d811fddc2025d72259498", "patch": "@@ -77,9 +77,18 @@ pub enum _Unwind_Context {}\n \n pub type _Unwind_Exception_Cleanup_Fn =\n     extern \"C\" fn(unwind_code: _Unwind_Reason_Code, exception: *mut _Unwind_Exception);\n+\n+// FIXME: The `#[link]` attributes on `extern \"C\"` block marks those symbols declared in\n+// the block are reexported in dylib build of libstd. This is needed when build rustc with\n+// feature `llvm-libunwind', as no other cdylib will provided those _Unwind_* symbols.\n+// However the `link` attribute is duplicated multiple times and does not just export symbol,\n+// a better way to manually export symbol would be another attribute like `#[export]`.\n+// See the logic in function rustc_codegen_ssa::src::back::exported_symbols, module\n+// rustc_codegen_ssa::src::back::symbol_export, rustc_middle::middle::exported_symbols\n+// and RFC 2841\n #[cfg_attr(\n     all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n-    link(name = \"unwind\", kind = \"static\")\n+    link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")\n )]\n extern \"C-unwind\" {\n     pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n@@ -106,9 +115,10 @@ if #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))\n     }\n     pub use _Unwind_Action::*;\n \n-    #[cfg_attr(all(feature = \"llvm-libunwind\",\n-                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n-               link(name = \"unwind\", kind = \"static\"))]\n+    #[cfg_attr(\n+        all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n+        link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")\n+    )]\n     extern \"C\" {\n         pub fn _Unwind_GetGR(ctx: *mut _Unwind_Context, reg_index: c_int) -> _Unwind_Word;\n         pub fn _Unwind_SetGR(ctx: *mut _Unwind_Context, reg_index: c_int, value: _Unwind_Word);\n@@ -163,9 +173,10 @@ if #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))\n     pub const UNWIND_SP_REG: c_int = 13;\n     pub const UNWIND_IP_REG: c_int = 15;\n \n-    #[cfg_attr(all(feature = \"llvm-libunwind\",\n-                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n-               link(name = \"unwind\", kind = \"static\"))]\n+    #[cfg_attr(\n+        all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n+        link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")\n+    )]\n     extern \"C\" {\n         fn _Unwind_VRS_Get(ctx: *mut _Unwind_Context,\n                            regclass: _Unwind_VRS_RegClass,\n@@ -228,9 +239,10 @@ if #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))\n cfg_if::cfg_if! {\n if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     // Not 32-bit iOS\n-    #[cfg_attr(all(feature = \"llvm-libunwind\",\n-                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n-               link(name = \"unwind\", kind = \"static\"))]\n+    #[cfg_attr(\n+        all(feature = \"llvm-libunwind\", any(target_os = \"fuchsia\", target_os = \"linux\")),\n+        link(name = \"unwind\", kind = \"static\", modifiers = \"-bundle\")\n+    )]\n     extern \"C-unwind\" {\n         pub fn _Unwind_RaiseException(exception: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n     }\n@@ -241,9 +253,6 @@ if #[cfg(not(all(target_os = \"ios\", target_arch = \"arm\")))] {\n     }\n } else {\n     // 32-bit iOS uses SjLj and does not provide _Unwind_Backtrace()\n-    #[cfg_attr(all(feature = \"llvm-libunwind\",\n-                   any(target_os = \"fuchsia\", target_os = \"linux\")),\n-               link(name = \"unwind\", kind = \"static\"))]\n     extern \"C-unwind\" {\n         pub fn _Unwind_SjLj_RaiseException(e: *mut _Unwind_Exception) -> _Unwind_Reason_Code;\n     }"}, {"sha": "afddbc1da9e702176ab947c57697c6b544cd3865", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c9896f279357896d31d811fddc2025d72259498/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9896f279357896d31d811fddc2025d72259498/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=4c9896f279357896d31d811fddc2025d72259498", "patch": "@@ -23,7 +23,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n-use crate::config::TargetSelection;\n+use crate::config::{LlvmLibunwind, TargetSelection};\n use crate::dist;\n use crate::native;\n use crate::tool::SourceType;\n@@ -234,6 +234,18 @@ fn copy_self_contained_objects(\n         }\n     }\n \n+    if target.contains(\"musl\")\n+        || target.contains(\"x86_64-fortanix-unknown-sgx\")\n+        || builder.config.llvm_libunwind == LlvmLibunwind::InTree\n+            && (target.contains(\"linux\") || target.contains(\"fuchsia\"))\n+    {\n+        let libunwind_path = builder.ensure(native::Libunwind { target });\n+        let libunwind_source = libunwind_path.join(\"libunwind.a\");\n+        let libunwind_target = libdir_self_contained.join(\"libunwind.a\");\n+        builder.copy(&libunwind_source, &libunwind_target);\n+        target_deps.push((libunwind_target, DependencyType::TargetSelfContained));\n+    }\n+\n     target_deps\n }\n "}, {"sha": "0a23d4fff6bda0127bab325e210217b0be8cec10", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 152, "deletions": 1, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/4c9896f279357896d31d811fddc2025d72259498/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c9896f279357896d31d811fddc2025d72259498/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=4c9896f279357896d31d811fddc2025d72259498", "patch": "@@ -10,7 +10,7 @@\n \n use std::env;\n use std::env::consts::EXE_EXTENSION;\n-use std::ffi::OsString;\n+use std::ffi::{OsStr, OsString};\n use std::fs::{self, File};\n use std::io;\n use std::path::{Path, PathBuf};\n@@ -952,3 +952,154 @@ impl Step for CrtBeginEnd {\n         out_dir\n     }\n }\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Libunwind {\n+    pub target: TargetSelection,\n+}\n+\n+impl Step for Libunwind {\n+    type Output = PathBuf;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/llvm-project/libunwind\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(Libunwind { target: run.target });\n+    }\n+\n+    /// Build linunwind.a\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        if builder.config.dry_run {\n+            return PathBuf::new();\n+        }\n+\n+        let out_dir = builder.native_dir(self.target).join(\"libunwind\");\n+        let root = builder.src.join(\"src/llvm-project/libunwind\");\n+\n+        if up_to_date(&root, &out_dir.join(\"libunwind.a\")) {\n+            return out_dir;\n+        }\n+\n+        builder.info(&format!(\"Building libunwind.a for {}\", self.target.triple));\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let mut cc_cfg = cc::Build::new();\n+        let mut cpp_cfg = cc::Build::new();\n+\n+        cpp_cfg.cpp(true);\n+        cpp_cfg.cpp_set_stdlib(None);\n+        cpp_cfg.flag(\"-nostdinc++\");\n+        cpp_cfg.flag(\"-fno-exceptions\");\n+        cpp_cfg.flag(\"-fno-rtti\");\n+        cpp_cfg.flag_if_supported(\"-fvisibility-global-new-delete-hidden\");\n+\n+        for cfg in [&mut cc_cfg, &mut cpp_cfg].iter_mut() {\n+            if let Some(ar) = builder.ar(self.target) {\n+                cfg.archiver(ar);\n+            }\n+            cfg.target(&self.target.triple);\n+            cfg.host(&builder.config.build.triple);\n+            cfg.warnings(false);\n+            cfg.debug(false);\n+            // get_compiler() need set opt_level first.\n+            cfg.opt_level(3);\n+            cfg.flag(\"-fstrict-aliasing\");\n+            cfg.flag(\"-funwind-tables\");\n+            cfg.flag(\"-fvisibility=hidden\");\n+            cfg.define(\"_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS\", None);\n+            cfg.include(root.join(\"include\"));\n+            cfg.cargo_metadata(false);\n+            cfg.out_dir(&out_dir);\n+\n+            if self.target.contains(\"x86_64-fortanix-unknown-sgx\") {\n+                cfg.static_flag(true);\n+                cfg.flag(\"-fno-stack-protector\");\n+                cfg.flag(\"-ffreestanding\");\n+                cfg.flag(\"-fexceptions\");\n+\n+                // easiest way to undefine since no API available in cc::Build to undefine\n+                cfg.flag(\"-U_FORTIFY_SOURCE\");\n+                cfg.define(\"_FORTIFY_SOURCE\", \"0\");\n+                cfg.define(\"RUST_SGX\", \"1\");\n+                cfg.define(\"__NO_STRING_INLINES\", None);\n+                cfg.define(\"__NO_MATH_INLINES\", None);\n+                cfg.define(\"_LIBUNWIND_IS_BAREMETAL\", None);\n+                cfg.define(\"__LIBUNWIND_IS_NATIVE_ONLY\", None);\n+                cfg.define(\"NDEBUG\", None);\n+            }\n+        }\n+\n+        cc_cfg.compiler(builder.cc(self.target));\n+        if let Ok(cxx) = builder.cxx(self.target) {\n+            cpp_cfg.compiler(cxx);\n+        } else {\n+            cc_cfg.compiler(builder.cc(self.target));\n+        }\n+\n+        // Don't set this for clang\n+        // By default, Clang builds C code in GNU C17 mode.\n+        // By default, Clang builds C++ code according to the C++98 standard,\n+        // with many C++11 features accepted as extensions.\n+        if cc_cfg.get_compiler().is_like_gnu() {\n+            cc_cfg.flag(\"-std=c99\");\n+        }\n+        if cpp_cfg.get_compiler().is_like_gnu() {\n+            cpp_cfg.flag(\"-std=c++11\");\n+        }\n+\n+        if self.target.contains(\"x86_64-fortanix-unknown-sgx\") || self.target.contains(\"musl\") {\n+            // use the same GCC C compiler command to compile C++ code so we do not need to setup the\n+            // C++ compiler env variables on the builders.\n+            // Don't set this for clang++, as clang++ is able to compile this without libc++.\n+            if cpp_cfg.get_compiler().is_like_gnu() {\n+                cpp_cfg.cpp(false);\n+                cpp_cfg.compiler(builder.cc(self.target));\n+            }\n+        }\n+\n+        let mut c_sources = vec![\n+            \"Unwind-sjlj.c\",\n+            \"UnwindLevel1-gcc-ext.c\",\n+            \"UnwindLevel1.c\",\n+            \"UnwindRegistersRestore.S\",\n+            \"UnwindRegistersSave.S\",\n+        ];\n+\n+        let cpp_sources = vec![\"Unwind-EHABI.cpp\", \"Unwind-seh.cpp\", \"libunwind.cpp\"];\n+        let cpp_len = cpp_sources.len();\n+\n+        if self.target.contains(\"x86_64-fortanix-unknown-sgx\") {\n+            c_sources.push(\"UnwindRustSgx.c\");\n+        }\n+\n+        for src in c_sources {\n+            cc_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n+        }\n+\n+        for src in &cpp_sources {\n+            cpp_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n+        }\n+\n+        cpp_cfg.compile(\"unwind-cpp\");\n+\n+        // FIXME: https://github.com/alexcrichton/cc-rs/issues/545#issuecomment-679242845\n+        let mut count = 0;\n+        for entry in fs::read_dir(&out_dir).unwrap() {\n+            let file = entry.unwrap().path().canonicalize().unwrap();\n+            if file.is_file() && file.extension() == Some(OsStr::new(\"o\")) {\n+                // file name starts with \"Unwind-EHABI\", \"Unwind-seh\" or \"libunwind\"\n+                let file_name = file.file_name().unwrap().to_str().expect(\"UTF-8 file name\");\n+                if cpp_sources.iter().any(|f| file_name.starts_with(&f[..f.len() - 4])) {\n+                    cc_cfg.object(&file);\n+                    count += 1;\n+                }\n+            }\n+        }\n+        assert_eq!(cpp_len, count, \"Can't get object files from {:?}\", &out_dir);\n+\n+        cc_cfg.compile(\"unwind\");\n+        out_dir\n+    }\n+}"}]}