{"sha": "54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzlhNDY1NWI4YzY2MmI1Y2UzYTdhZDhhNDdhNGQ0ZDEyZTc4Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T17:43:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T17:43:47Z"}, "message": "Auto merge of #20082 - pczarn:btree-bounded-iter, r=Gankro\n\nPart of collections reform v1, #18424\r\nAlso, iteration is simplified:\r\n```\r\nbefore\r\ntest btree::map::bench::iter_1000                          ... bench:     17177 ns/iter (+/- 6302)\r\ntest btree::map::bench::iter_100000                        ... bench:   1735731 ns/iter (+/- 23908)\r\ntest btree::map::bench::iter_20                            ... bench:       386 ns/iter (+/- 148)\r\nafter\r\ntest btree::map::bench::iter_1000                          ... bench:     15777 ns/iter (+/- 346)\r\ntest btree::map::bench::iter_100000                        ... bench:   1602604 ns/iter (+/- 73629)\r\ntest btree::map::bench::iter_20                            ... bench:       339 ns/iter (+/- 91)\r\n```\r\ncc @gereeter @cgaebel\r\nr? @Gankro", "tree": {"sha": "9c589458b9f7d90afa6c2aa5db900eb7ee03855b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c589458b9f7d90afa6c2aa5db900eb7ee03855b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "html_url": "https://github.com/rust-lang/rust/commit/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda3490f8fb099a1ddd1f253a75c29110042dc01", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda3490f8fb099a1ddd1f253a75c29110042dc01", "html_url": "https://github.com/rust-lang/rust/commit/cda3490f8fb099a1ddd1f253a75c29110042dc01"}, {"sha": "429c23d5f4de5274cbcc22e72f6a2e3a00069817", "url": "https://api.github.com/repos/rust-lang/rust/commits/429c23d5f4de5274cbcc22e72f6a2e3a00069817", "html_url": "https://github.com/rust-lang/rust/commit/429c23d5f4de5274cbcc22e72f6a2e3a00069817"}], "stats": {"total": 799, "additions": 605, "deletions": 194}, "files": [{"sha": "c56592177b49aa1af7018f31e1730ef289d0c5eb", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 333, "deletions": 118, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "patch": "@@ -27,6 +27,7 @@ use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n+use Bound::{self, Included, Excluded, Unbounded};\n \n use ring_buf::RingBuf;\n \n@@ -37,8 +38,6 @@ use super::node::TraversalItem::{self, Elem, Edge};\n use super::node::{Traversal, MutTraversal, MoveTraversal};\n use super::node::{self, Node, Found, GoDown};\n \n-// FIXME(conventions): implement bounded iterators\n-\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -92,9 +91,7 @@ pub struct BTreeMap<K, V> {\n \n /// An abstract base over-which all other BTree iterators are built.\n struct AbsIter<T> {\n-    lca: T,\n-    left: RingBuf<T>,\n-    right: RingBuf<T>,\n+    traversals: RingBuf<T>,\n     size: uint,\n }\n \n@@ -128,6 +125,16 @@ pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n }\n \n+/// An iterator over a sub-range of BTreeMap's entries.\n+pub struct Range<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<Traversal<'a, K, V>>\n+}\n+\n+/// A mutable iterator over a sub-range of BTreeMap's entries.\n+pub struct RangeMut<'a, K: 'a, V: 'a> {\n+    inner: AbsIter<MutTraversal<'a, K, V>>\n+}\n+\n /// A view into a single entry in a map, which may either be vacant or occupied.\n #[unstable = \"precise API still under development\"]\n pub enum Entry<'a, K:'a, V:'a> {\n@@ -924,74 +931,45 @@ impl<K, V> Traverse<Node<K, V>> for MoveTraversal<K, V> {\n }\n \n /// Represents an operation to perform inside the following iterator methods.\n-/// This is necessary to use in `next` because we want to modify self.left inside\n-/// a match that borrows it. Similarly, in `next_back` for self.right. Instead, we use this\n-/// enum to note what we want to do, and do it after the match.\n+/// This is necessary to use in `next` because we want to modify `self.traversals` inside\n+/// a match that borrows it. Similarly in `next_back`. Instead, we use this enum to note\n+/// what we want to do, and do it after the match.\n enum StackOp<T> {\n     Push(T),\n     Pop,\n }\n-\n impl<K, V, E, T> Iterator for AbsIter<T> where\n     T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n {\n     type Item = (K, V);\n \n-    // This function is pretty long, but only because there's a lot of cases to consider.\n-    // Our iterator represents two search paths, left and right, to the smallest and largest\n-    // elements we have yet to yield. lca represents the least common ancestor of these two paths,\n-    // above-which we never walk, since everything outside it has already been consumed (or was\n-    // never in the range to iterate).\n-    //\n-    // Note that the design of these iterators permits an *arbitrary* initial pair of min and max,\n-    // making these arbitrary sub-range iterators. However the logic to construct these paths\n-    // efficiently is fairly involved, so this is a FIXME. The sub-range iterators also wouldn't be\n-    // able to accurately predict size, so those iterators can't implement ExactSizeIterator.\n+    // Our iterator represents a queue of all ancestors of elements we have\n+    // yet to yield, from smallest to largest.  Note that the design of these\n+    // iterators permits an *arbitrary* initial pair of min and max, making\n+    // these arbitrary sub-range iterators.\n     fn next(&mut self) -> Option<(K, V)> {\n         loop {\n-            // We want the smallest element, so try to get the top of the left stack\n-            let op = match self.left.back_mut() {\n-                // The left stack is empty, so try to get the next element of the two paths\n-                // LCAs (the left search path is currently a subpath of the right one)\n-                None => match self.lca.next() {\n-                    // The lca has been exhausted, walk further down the right path\n-                    None => match self.right.pop_front() {\n-                        // The right path is exhausted, so we're done\n-                        None => return None,\n-                        // The right path had something, make that the new LCA\n-                        // and restart the whole process\n-                        Some(right) => {\n-                            self.lca = right;\n-                            continue;\n-                        }\n-                    },\n-                    // The lca yielded an edge, make that the new head of the left path\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    // The lca yielded an entry, so yield that\n-                    Some(Elem(k, v)) => {\n-                        self.size -= 1;\n-                        return Some((k, v))\n-                    }\n-                },\n-                // The left stack wasn't empty, so continue along the node in its head\n+            // We want the smallest element, so try to get the back of the queue\n+            let op = match self.traversals.back_mut() {\n+                None => return None,\n+                // The queue wasn't empty, so continue along the node in its head\n                 Some(iter) => match iter.next() {\n-                    // The head of the left path is empty, so Pop it off and restart the process\n+                    // The head is empty, so Pop it off and continue the process\n                     None => Pop,\n-                    // The head of the left path yielded an edge, so make that the new head\n-                    // of the left path\n+                    // The head yielded an edge, so make that the new head\n                     Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    // The head of the left path yielded entry, so yield that\n-                    Some(Elem(k, v)) => {\n+                    // The head yielded an entry, so yield that\n+                    Some(Elem(kv)) => {\n                         self.size -= 1;\n-                        return Some((k, v))\n+                        return Some(kv)\n                     }\n                 }\n             };\n \n-            // Handle any operation on the left stack as necessary\n+            // Handle any operation as necessary, without a conflicting borrow of the queue\n             match op {\n-                Push(item) => { self.left.push_back(item); },\n-                Pop => { self.left.pop_back(); },\n+                Push(item) => { self.traversals.push_back(item); },\n+                Pop => { self.traversals.pop_back(); },\n             }\n         }\n     }\n@@ -1005,36 +983,24 @@ impl<K, V, E, T> DoubleEndedIterator for AbsIter<T> where\n     T: DoubleEndedIterator<Item=TraversalItem<K, V, E>> + Traverse<E>,\n {\n     // next_back is totally symmetric to next\n+    #[inline]\n     fn next_back(&mut self) -> Option<(K, V)> {\n         loop {\n-            let op = match self.right.back_mut() {\n-                None => match self.lca.next_back() {\n-                    None => match self.left.pop_front() {\n-                        None => return None,\n-                        Some(left) => {\n-                            self.lca = left;\n-                            continue;\n-                        }\n-                    },\n-                    Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    Some(Elem(k, v)) => {\n-                        self.size -= 1;\n-                        return Some((k, v))\n-                    }\n-                },\n+            let op = match self.traversals.front_mut() {\n+                None => return None,\n                 Some(iter) => match iter.next_back() {\n                     None => Pop,\n                     Some(Edge(next)) => Push(Traverse::traverse(next)),\n-                    Some(Elem(k, v)) => {\n+                    Some(Elem(kv)) => {\n                         self.size -= 1;\n-                        return Some((k, v))\n+                        return Some(kv)\n                     }\n                 }\n             };\n \n             match op {\n-                Push(item) => { self.right.push_back(item); },\n-                Pop => { self.right.pop_back(); }\n+                Push(item) => { self.traversals.push_front(item); },\n+                Pop => { self.traversals.pop_front(); }\n             }\n         }\n     }\n@@ -1111,6 +1077,24 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n #[stable]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {}\n \n+impl<'a, K, V> Iterator for Range<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+}\n+impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next_back() }\n+}\n+\n+impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n+\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+}\n+impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n+    fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next_back() }\n+}\n+\n impl<'a, K: Ord, V> Entry<'a, K, V> {\n     #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n@@ -1188,11 +1172,12 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable]\n     pub fn iter(&self) -> Iter<K, V> {\n         let len = self.len();\n+        // NB. The initial capacity for ringbuf is large enough to avoid reallocs in many cases.\n+        let mut lca = RingBuf::new();\n+        lca.push_back(Traverse::traverse(&self.root));\n         Iter {\n             inner: AbsIter {\n-                lca: Traverse::traverse(&self.root),\n-                left: RingBuf::new(),\n-                right: RingBuf::new(),\n+                traversals: lca,\n                 size: len,\n             }\n         }\n@@ -1220,11 +1205,11 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable]\n     pub fn iter_mut(&mut self) -> IterMut<K, V> {\n         let len = self.len();\n+        let mut lca = RingBuf::new();\n+        lca.push_back(Traverse::traverse(&mut self.root));\n         IterMut {\n             inner: AbsIter {\n-                lca: Traverse::traverse(&mut self.root),\n-                left: RingBuf::new(),\n-                right: RingBuf::new(),\n+                traversals: lca,\n                 size: len,\n             }\n         }\n@@ -1249,11 +1234,11 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n         let len = self.len();\n+        let mut lca = RingBuf::new();\n+        lca.push_back(Traverse::traverse(self.root));\n         IntoIter {\n             inner: AbsIter {\n-                lca: Traverse::traverse(self.root),\n-                left: RingBuf::new(),\n-                right: RingBuf::new(),\n+                traversals: lca,\n                 size: len,\n             }\n         }\n@@ -1334,7 +1319,189 @@ impl<K, V> BTreeMap<K, V> {\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n+macro_rules! range_impl {\n+    ($root:expr, $min:expr, $max:expr, $as_slices_internal:ident, $iter:ident, $Range:ident,\n+                                       $edges:ident, [$($mutability:ident)*]) => (\n+        {\n+            // A deque that encodes two search paths containing (left-to-right):\n+            // a series of truncated-from-the-left iterators, the LCA's doubly-truncated iterator,\n+            // and a series of truncated-from-the-right iterators.\n+            let mut traversals = RingBuf::new();\n+            let (root, min, max) = ($root, $min, $max);\n+\n+            let mut leftmost = None;\n+            let mut rightmost = None;\n+\n+            match (&min, &max) {\n+                (&Unbounded, &Unbounded) => {\n+                    traversals.push_back(Traverse::traverse(root))\n+                }\n+                (&Unbounded, &Included(_)) | (&Unbounded, &Excluded(_)) => {\n+                    rightmost = Some(root);\n+                }\n+                (&Included(_), &Unbounded) | (&Excluded(_), &Unbounded) => {\n+                    leftmost = Some(root);\n+                }\n+                  (&Included(min_key), &Included(max_key))\n+                | (&Included(min_key), &Excluded(max_key))\n+                | (&Excluded(min_key), &Included(max_key))\n+                | (&Excluded(min_key), &Excluded(max_key)) => {\n+                    // lca represents the Lowest Common Ancestor, above which we never\n+                    // walk, since everything else is outside the range to iterate.\n+                    //       ___________________\n+                    //      |__0_|_80_|_85_|_90_|  (root)\n+                    //      |    |    |    |    |\n+                    //           |\n+                    //           v\n+                    //  ___________________\n+                    // |__5_|_15_|_30_|_73_|\n+                    // |    |    |    |    |\n+                    //                |\n+                    //                v\n+                    //       ___________________\n+                    //      |_33_|_58_|_63_|_68_|  lca for the range [41, 65]\n+                    //      |    |\\___|___/|    |  iterator at traversals[2]\n+                    //           |         |\n+                    //           |         v\n+                    //           v         rightmost\n+                    //           leftmost\n+                    let mut is_leaf = root.is_leaf();\n+                    let mut lca = root.$as_slices_internal();\n+                    loop {\n+                        let slice = lca.slice_from(min_key).slice_to(max_key);\n+                        if let [ref $($mutability)* edge] = slice.edges {\n+                            // Follow the only edge that leads the node that covers the range.\n+                            is_leaf = edge.is_leaf();\n+                            lca = edge.$as_slices_internal();\n+                        } else {\n+                            let mut iter = slice.$iter();\n+                            if is_leaf {\n+                                leftmost = None;\n+                                rightmost = None;\n+                            } else {\n+                                // Only change the state of nodes with edges.\n+                                leftmost = iter.next_edge_item();\n+                                rightmost = iter.next_edge_item_back();\n+                            }\n+                            traversals.push_back(iter);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            // Keep narrowing the range by going down.\n+            //               ___________________\n+            //              |_38_|_43_|_48_|_53_|\n+            //              |    |____|____|____/ iterator at traversals[1]\n+            //                   |\n+            //                   v\n+            //  ___________________\n+            // |_39_|_40_|_41_|_42_|  (leaf, the last leftmost)\n+            //           \\_________|  iterator at traversals[0]\n+            match min {\n+                Included(key) | Excluded(key) =>\n+                    while let Some(left) = leftmost {\n+                        let is_leaf = left.is_leaf();\n+                        let mut iter = left.$as_slices_internal().slice_from(key).$iter();\n+                        leftmost = if is_leaf {\n+                            None\n+                        } else {\n+                            // Only change the state of nodes with edges.\n+                            iter.next_edge_item()\n+                        };\n+                        traversals.push_back(iter);\n+                    },\n+                _ => {}\n+            }\n+            // If the leftmost iterator starts with an element, then it was an exact match.\n+            if let (Excluded(_), Some(leftmost_iter)) = (min, traversals.back_mut()) {\n+                // Drop this excluded element. `next_kv_item` has no effect when\n+                // the next item is an edge.\n+                leftmost_iter.next_kv_item();\n+            }\n+\n+            // The code for the right side is similar.\n+            match max {\n+                Included(key) | Excluded(key) =>\n+                    while let Some(right) = rightmost {\n+                        let is_leaf = right.is_leaf();\n+                        let mut iter = right.$as_slices_internal().slice_to(key).$iter();\n+                        rightmost = if is_leaf {\n+                            None\n+                        } else {\n+                            iter.next_edge_item_back()\n+                        };\n+                        traversals.push_front(iter);\n+                    },\n+                _ => {}\n+            }\n+            if let (Excluded(_), Some(rightmost_iter)) = (max, traversals.front_mut()) {\n+                rightmost_iter.next_kv_item_back();\n+            }\n+\n+            $Range {\n+                inner: AbsIter {\n+                    traversals: traversals,\n+                    size: 0, // unused\n+                }\n+            }\n+        }\n+    )\n+}\n+\n impl<K: Ord, V> BTreeMap<K, V> {\n+    /// Constructs a double-ended iterator over a sub-range of elements in the map, starting\n+    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n+    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n+    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::Bound::{Included, Unbounded};\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(3u, \"a\");\n+    /// map.insert(5u, \"b\");\n+    /// map.insert(8u, \"c\");\n+    /// for (&key, &value) in map.range(Included(&4), Included(&8)) {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n+        range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n+    }\n+\n+    /// Constructs a mutable double-ended iterator over a sub-range of elements in the map, starting\n+    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n+    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n+    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::Bound::{Included, Excluded};\n+    ///\n+    /// let mut map: BTreeMap<&str, i32> = [\"Alice\", \"Bob\", \"Carol\", \"Cheryl\"].iter()\n+    ///                                                                       .map(|&s| (s, 0))\n+    ///                                                                       .collect();\n+    /// for (_, balance) in map.range_mut(Included(&\"B\"), Excluded(&\"Cheryl\")) {\n+    ///     *balance += 100;\n+    /// }\n+    /// for (name, balance) in map.iter() {\n+    ///     println!(\"{} => {}\", name, balance);\n+    /// }\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n+        range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n+                                                                      edges_mut, [mut])\n+    }\n+\n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n     ///\n     /// # Examples\n@@ -1410,8 +1577,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n+    use std::iter::range_inclusive;\n \n     use super::{BTreeMap, Occupied, Vacant};\n+    use Bound::{self, Included, Excluded, Unbounded};\n \n     #[test]\n     fn test_basic_large() {\n@@ -1481,75 +1650,121 @@ mod test {\n         // Forwards\n         let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n \n-        {\n-            let mut iter = map.iter();\n+        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n             for i in range(0, size) {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (&i, &i));\n+                assert_eq!(iter.next().unwrap(), (i, i));\n             }\n             assert_eq!(iter.size_hint(), (0, Some(0)));\n             assert_eq!(iter.next(), None);\n         }\n+        test(size, map.iter().map(|(&k, &v)| (k, v)));\n+        test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n+        test(size, map.into_iter());\n+    }\n \n-        {\n-            let mut iter = map.iter_mut();\n-            for i in range(0, size) {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (&i, &mut (i + 0)));\n-            }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n-        }\n+    #[test]\n+    fn test_iter_rev() {\n+        let size = 10000u;\n \n-        {\n-            let mut iter = map.into_iter();\n+        // Forwards\n+        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+\n+        fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n             for i in range(0, size) {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (i, i));\n+                assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n             }\n             assert_eq!(iter.size_hint(), (0, Some(0)));\n             assert_eq!(iter.next(), None);\n         }\n-\n+        test(size, map.iter().rev().map(|(&k, &v)| (k, v)));\n+        test(size, map.iter_mut().rev().map(|(&k, &mut v)| (k, v)));\n+        test(size, map.into_iter().rev());\n     }\n \n     #[test]\n-    fn test_iter_rev() {\n+    fn test_iter_mixed() {\n         let size = 10000u;\n \n         // Forwards\n         let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n \n-        {\n-            let mut iter = map.iter().rev();\n-            for i in range(0, size) {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (&(size - i - 1), &(size - i - 1)));\n+        fn test<T>(size: uint, mut iter: T)\n+                where T: Iterator<Item=(uint, uint)> + DoubleEndedIterator {\n+            for i in range(0, size / 4) {\n+                assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n+                assert_eq!(iter.next().unwrap(), (i, i));\n+                assert_eq!(iter.next_back().unwrap(), (size - i - 1, size - i - 1));\n+            }\n+            for i in range(size / 4, size * 3 / 4) {\n+                assert_eq!(iter.size_hint(), (size * 3 / 4 - i, Some(size * 3 / 4 - i)));\n+                assert_eq!(iter.next().unwrap(), (i, i));\n             }\n             assert_eq!(iter.size_hint(), (0, Some(0)));\n             assert_eq!(iter.next(), None);\n         }\n+        test(size, map.iter().map(|(&k, &v)| (k, v)));\n+        test(size, map.iter_mut().map(|(&k, &mut v)| (k, v)));\n+        test(size, map.into_iter());\n+    }\n \n-        {\n-            let mut iter = map.iter_mut().rev();\n-            for i in range(0, size) {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (&(size - i - 1), &mut(size - i - 1)));\n-            }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n+    #[test]\n+    fn test_range_small() {\n+        let size = 5u;\n+\n+        // Forwards\n+        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+\n+        let mut j = 0u;\n+        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(range(2u, size)) {\n+            assert_eq!(k, i);\n+            assert_eq!(v, i);\n+            j += 1;\n         }\n+        assert_eq!(j, size - 2);\n+    }\n \n-        {\n-            let mut iter = map.into_iter().rev();\n-            for i in range(0, size) {\n-                assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n-                assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n+    #[test]\n+    fn test_range_1000() {\n+        let size = 1000u;\n+        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+\n+        fn test(map: &BTreeMap<uint, uint>, size: uint, min: Bound<&uint>, max: Bound<&uint>) {\n+            let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n+            let mut pairs = range(0, size).map(|i| (i, i));\n+\n+            for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n+                assert_eq!(kv, pair);\n             }\n-            assert_eq!(iter.size_hint(), (0, Some(0)));\n-            assert_eq!(iter.next(), None);\n+            assert_eq!(kvs.next(), None);\n+            assert_eq!(pairs.next(), None);\n         }\n+        test(&map, size, Included(&0), Excluded(&size));\n+        test(&map, size, Unbounded, Excluded(&size));\n+        test(&map, size, Included(&0), Included(&(size - 1)));\n+        test(&map, size, Unbounded, Included(&(size - 1)));\n+        test(&map, size, Included(&0), Unbounded);\n+        test(&map, size, Unbounded, Unbounded);\n+    }\n+\n+    #[test]\n+    fn test_range() {\n+        let size = 200u;\n+        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+\n+        for i in range(0, size) {\n+            for j in range(i, size) {\n+                let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n+                let mut pairs = range_inclusive(i, j).map(|i| (i, i));\n \n+                for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n+                    assert_eq!(kv, pair);\n+                }\n+                assert_eq!(kvs.next(), None);\n+                assert_eq!(pairs.next(), None);\n+            }\n+        }\n     }\n \n     #[test]"}, {"sha": "afce5f7dbda35492a98aa1fd3454ac7ce399d869", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 215, "deletions": 75, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "patch": "@@ -77,6 +77,24 @@ pub struct Node<K, V> {\n     _capacity: uint,\n }\n \n+struct NodeSlice<'a, K: 'a, V: 'a> {\n+    keys: &'a [K],\n+    vals: &'a [V],\n+    pub edges: &'a [Node<K, V>],\n+    head_is_edge: bool,\n+    tail_is_edge: bool,\n+    has_edges: bool,\n+}\n+\n+struct MutNodeSlice<'a, K: 'a, V: 'a> {\n+    keys: &'a [K],\n+    vals: &'a mut [V],\n+    pub edges: &'a mut [Node<K, V>],\n+    head_is_edge: bool,\n+    tail_is_edge: bool,\n+    has_edges: bool,\n+}\n+\n /// Rounds up to a multiple of a power of two. Returns the closest multiple\n /// of `target_alignment` that is higher or equal to `unrounded`.\n ///\n@@ -342,7 +360,8 @@ impl<K, V> Node<K, V> {\n     }\n \n     #[inline]\n-    pub fn as_slices_internal<'a>(&'a self) -> (&'a [K], &'a [V], &'a [Node<K, V>]) {\n+    pub fn as_slices_internal<'b>(&'b self) -> NodeSlice<'b, K, V> {\n+        let is_leaf = self.is_leaf();\n         let (keys, vals) = self.as_slices();\n         let edges: &[_] = if self.is_leaf() {\n             &[]\n@@ -354,12 +373,18 @@ impl<K, V> Node<K, V> {\n                 })\n             }\n         };\n-        (keys, vals, edges)\n+        NodeSlice {\n+            keys: keys,\n+            vals: vals,\n+            edges: edges,\n+            head_is_edge: true,\n+            tail_is_edge: true,\n+            has_edges: !is_leaf,\n+        }\n     }\n \n     #[inline]\n-    pub fn as_slices_internal_mut<'a>(&'a mut self) -> (&'a mut [K], &'a mut [V],\n-                                                        &'a mut [Node<K, V>]) {\n+    pub fn as_slices_internal_mut<'b>(&'b mut self) -> MutNodeSlice<'b, K, V> {\n         unsafe { mem::transmute(self.as_slices_internal()) }\n     }\n \n@@ -385,12 +410,12 @@ impl<K, V> Node<K, V> {\n \n     #[inline]\n     pub fn edges<'a>(&'a self) -> &'a [Node<K, V>] {\n-        self.as_slices_internal().2\n+        self.as_slices_internal().edges\n     }\n \n     #[inline]\n     pub fn edges_mut<'a>(&'a mut self) -> &'a mut [Node<K, V>] {\n-        self.as_slices_internal_mut().2\n+        self.as_slices_internal_mut().edges\n     }\n }\n \n@@ -522,30 +547,11 @@ impl<K: Ord, V> Node<K, V> {\n         // FIXME(Gankro): Tune when to search linear or binary based on B (and maybe K/V).\n         // For the B configured as of this writing (B = 6), binary search was *significantly*\n         // worse for uints.\n-        let (found, index) = node.search_linear(key);\n-        if found {\n-            Found(Handle {\n-                node: node,\n-                index: index\n-            })\n-        } else {\n-            GoDown(Handle {\n-                node: node,\n-                index: index\n-            })\n+        match node.as_slices_internal().search_linear(key) {\n+            (index, true) => Found(Handle { node: node, index: index }),\n+            (index, false) => GoDown(Handle { node: node, index: index }),\n         }\n     }\n-\n-    fn search_linear<Q: ?Sized>(&self, key: &Q) -> (bool, uint) where Q: BorrowFrom<K> + Ord {\n-        for (i, k) in self.keys().iter().enumerate() {\n-            match key.cmp(BorrowFrom::borrow_from(k)) {\n-                Greater => {},\n-                Equal => return (true, i),\n-                Less => return (false, i),\n-            }\n-        }\n-        (false, self.len())\n-    }\n }\n \n // Public interface\n@@ -1043,31 +1049,11 @@ impl<K, V> Node<K, V> {\n     }\n \n     pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        let (keys, vals, edges) = self.as_slices_internal();\n-        Traversal {\n-            inner: ElemsAndEdges(\n-                keys.iter().zip(vals.iter()),\n-                edges.iter()\n-            ),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n-        }\n+        self.as_slices_internal().iter()\n     }\n \n     pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n-        let is_leaf = self.is_leaf();\n-        let (keys, vals, edges) = self.as_slices_internal_mut();\n-        MutTraversal {\n-            inner: ElemsAndEdges(\n-                keys.iter().zip(vals.iter_mut()),\n-                edges.iter_mut()\n-            ),\n-            head_is_edge: true,\n-            tail_is_edge: true,\n-            has_edges: !is_leaf,\n-        }\n+        self.as_slices_internal_mut().iter_mut()\n     }\n \n     pub fn into_iter(self) -> MoveTraversal<K, V> {\n@@ -1311,22 +1297,27 @@ fn min_load_from_capacity(cap: uint) -> uint {\n /// A trait for pairs of `Iterator`s, one over edges and the other over key/value pairs. This is\n /// necessary, as the `MoveTraversalImpl` needs to have a destructor that deallocates the `Node`,\n /// and a pair of `Iterator`s would require two independent destructors.\n-trait TraversalImpl<K, V, E> {\n-    fn next_kv(&mut self) -> Option<(K, V)>;\n-    fn next_kv_back(&mut self) -> Option<(K, V)>;\n+trait TraversalImpl {\n+    type Item;\n+    type Edge;\n+\n+    fn next_kv(&mut self) -> Option<Self::Item>;\n+    fn next_kv_back(&mut self) -> Option<Self::Item>;\n \n-    fn next_edge(&mut self) -> Option<E>;\n-    fn next_edge_back(&mut self) -> Option<E>;\n+    fn next_edge(&mut self) -> Option<Self::Edge>;\n+    fn next_edge_back(&mut self) -> Option<Self::Edge>;\n }\n \n /// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n /// as no deallocation needs to be done.\n struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n \n impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n-        TraversalImpl<K, V, E> for ElemsAndEdges<Elems, Edges>\n+        TraversalImpl for ElemsAndEdges<Elems, Edges>\n     where Elems : Iterator<Item=(K, V)>, Edges : Iterator<Item=E>\n {\n+    type Item = (K, V);\n+    type Edge = E;\n \n     fn next_kv(&mut self) -> Option<(K, V)> { self.0.next() }\n     fn next_kv_back(&mut self) -> Option<(K, V)> { self.0.next_back() }\n@@ -1347,7 +1338,10 @@ struct MoveTraversalImpl<K, V> {\n     is_leaf: bool\n }\n \n-impl<K, V> TraversalImpl<K, V, Node<K, V>> for MoveTraversalImpl<K, V> {\n+impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n+    type Item = (K, V);\n+    type Edge = Node<K, V>;\n+\n     fn next_kv(&mut self) -> Option<(K, V)> {\n         match (self.keys.next(), self.vals.next()) {\n             (Some(k), Some(v)) => Some((k, v)),\n@@ -1398,9 +1392,12 @@ struct AbsTraversal<Impl> {\n     has_edges: bool,\n }\n \n-/// A single atomic step in a traversal. Either an element is visited, or an edge is followed\n+/// A single atomic step in a traversal.\n pub enum TraversalItem<K, V, E> {\n-    Elem(K, V),\n+    /// An element is visited. This isn't written as `Elem(K, V)` just because `opt.map(Elem)`\n+    /// requires the function to take a single argument. (Enum constructors are functions.)\n+    Elem((K, V)),\n+    /// An edge is followed.\n     Edge(E),\n }\n \n@@ -1417,32 +1414,175 @@ pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a,\n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;\n \n-#[old_impl_check]\n-impl<K, V, E, Impl: TraversalImpl<K, V, E>> Iterator for AbsTraversal<Impl> {\n+\n+impl<K, V, E, Impl> Iterator for AbsTraversal<Impl>\n+        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n     type Item = TraversalItem<K, V, E>;\n \n     fn next(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        let head_is_edge = self.head_is_edge;\n-        self.head_is_edge = !head_is_edge;\n+        self.next_edge_item().map(Edge).or_else(||\n+            self.next_kv_item().map(Elem)\n+        )\n+    }\n+}\n \n-        if head_is_edge && self.has_edges {\n-            self.inner.next_edge().map(|node| Edge(node))\n+impl<K, V, E, Impl> DoubleEndedIterator for AbsTraversal<Impl>\n+        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n+        self.next_edge_item_back().map(Edge).or_else(||\n+            self.next_kv_item_back().map(Elem)\n+        )\n+    }\n+}\n+\n+impl<K, V, E, Impl> AbsTraversal<Impl>\n+        where Impl: TraversalImpl<Item=(K, V), Edge=E> {\n+    /// Advances the iterator and returns the item if it's an edge. Returns None\n+    /// and does nothing if the first item is not an edge.\n+    pub fn next_edge_item(&mut self) -> Option<E> {\n+        // NB. `&& self.has_edges` might be redundant in this condition.\n+        let edge = if self.head_is_edge && self.has_edges {\n+            self.inner.next_edge()\n+        } else {\n+            None\n+        };\n+        self.head_is_edge = false;\n+        edge\n+    }\n+\n+    /// Advances the iterator and returns the item if it's an edge. Returns None\n+    /// and does nothing if the last item is not an edge.\n+    pub fn next_edge_item_back(&mut self) -> Option<E> {\n+        let edge = if self.tail_is_edge && self.has_edges {\n+            self.inner.next_edge_back()\n+        } else {\n+            None\n+        };\n+        self.tail_is_edge = false;\n+        edge\n+    }\n+\n+    /// Advances the iterator and returns the item if it's a key-value pair. Returns None\n+    /// and does nothing if the first item is not a key-value pair.\n+    pub fn next_kv_item(&mut self) -> Option<(K, V)> {\n+        if !self.head_is_edge {\n+            self.head_is_edge = true;\n+            self.inner.next_kv()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Advances the iterator and returns the item if it's a key-value pair. Returns None\n+    /// and does nothing if the last item is not a key-value pair.\n+    pub fn next_kv_item_back(&mut self) -> Option<(K, V)> {\n+        if !self.tail_is_edge {\n+            self.tail_is_edge = true;\n+            self.inner.next_kv_back()\n         } else {\n-            self.inner.next_kv().map(|(k, v)| Elem(k, v))\n+            None\n         }\n     }\n }\n \n-#[old_impl_check]\n-impl<K, V, E, Impl: TraversalImpl<K, V, E>> DoubleEndedIterator for AbsTraversal<Impl> {\n-    fn next_back(&mut self) -> Option<TraversalItem<K, V, E>> {\n-        let tail_is_edge = self.tail_is_edge;\n-        self.tail_is_edge = !tail_is_edge;\n+macro_rules! node_slice_impl {\n+    ($NodeSlice:ident, $Traversal:ident,\n+     $as_slices_internal:ident, $slice_from:ident, $slice_to:ident, $iter:ident) => {\n+        impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n+            /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n+            fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n+                    where Q: BorrowFrom<K> + Ord {\n+                for (i, k) in self.keys.iter().enumerate() {\n+                    match key.cmp(BorrowFrom::borrow_from(k)) {\n+                        Greater => {},\n+                        Equal => return (i, true),\n+                        Less => return (i, false),\n+                    }\n+                }\n+                (self.keys.len(), false)\n+            }\n \n-        if tail_is_edge && self.has_edges {\n-            self.inner.next_edge_back().map(|node| Edge(node))\n-        } else {\n-            self.inner.next_kv_back().map(|(k, v)| Elem(k, v))\n+            /// Returns a sub-slice with elements starting with `min_key`.\n+            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                // \\___|___|___|___/  slice_from(&0); pos = 0\n+                //     \\___|___|___/  slice_from(&2); pos = 1\n+                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n+                //         \\___|___/  slice_from(&4); pos = 2\n+                //             \\___/  slice_from(&6); pos = 3\n+                //                \\|/ slice_from(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(min_key);\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$slice_from(pos)\n+                    },\n+                    keys: self.keys.slice_from(pos),\n+                    vals: self.vals.$slice_from(pos),\n+                    head_is_edge: !pos_is_kv,\n+                    tail_is_edge: self.tail_is_edge,\n+                }\n+            }\n+\n+            /// Returns a sub-slice with elements up to and including `max_key`.\n+            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n+                // \\___/   |   |   |  slice_to(&2); pos = 1\n+                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n+                // \\___|___/   |   |  slice_to(&4); pos = 2\n+                // \\___|___|___/   |  slice_to(&6); pos = 3\n+                // \\___|___|___|___/  slice_to(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(max_key);\n+                let pos = pos + if pos_is_kv { 1 } else { 0 };\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$slice_to(pos + 1)\n+                    },\n+                    keys: self.keys.slice_to(pos),\n+                    vals: self.vals.$slice_to(pos),\n+                    head_is_edge: self.head_is_edge,\n+                    tail_is_edge: !pos_is_kv,\n+                }\n+            }\n+        }\n+\n+        impl<'a, K: 'a, V: 'a> $NodeSlice<'a, K, V> {\n+            /// Returns an iterator over key/value pairs and edges in a slice.\n+            #[inline]\n+            pub fn $iter(self) -> $Traversal<'a, K, V> {\n+                let mut edges = self.edges.$iter();\n+                // Skip edges at both ends, if excluded.\n+                if !self.head_is_edge { edges.next(); }\n+                if !self.tail_is_edge { edges.next_back(); }\n+                // The key iterator is always immutable.\n+                $Traversal {\n+                    inner: ElemsAndEdges(\n+                        self.keys.iter().zip(self.vals.$iter()),\n+                        edges\n+                    ),\n+                    head_is_edge: self.head_is_edge,\n+                    tail_is_edge: self.tail_is_edge,\n+                    has_edges: self.has_edges,\n+                }\n+            }\n         }\n     }\n }\n+\n+node_slice_impl!(NodeSlice, Traversal, as_slices_internal, slice_from, slice_to, iter);\n+node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, slice_from_mut,\n+                                                                     slice_to_mut, iter_mut);"}, {"sha": "4d71f9dbea8bef11066e0f3ad2b3230d134068fe", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "patch": "@@ -25,6 +25,7 @@ use core::iter::{Peekable, Map, FromIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use btree_map::{BTreeMap, Keys};\n+use Bound;\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -50,6 +51,11 @@ pub struct IntoIter<T> {\n     iter: Map<(T, ()), T, ::btree_map::IntoIter<T, ()>, fn((T, ())) -> T>\n }\n \n+/// An iterator over a sub-range of BTreeSet's items.\n+pub struct Range<'a, T: 'a> {\n+    iter: Map<(&'a T, &'a ()), &'a T, ::btree_map::Range<'a, T, ()>, fn((&'a T, &'a ())) -> &'a T>\n+}\n+\n /// A lazy iterator producing elements in the set difference (in-order).\n #[stable]\n pub struct Difference<'a, T:'a> {\n@@ -145,6 +151,36 @@ impl<T> BTreeSet<T> {\n     }\n }\n \n+impl<T: Ord> BTreeSet<T> {\n+    /// Constructs a double-ended iterator over a sub-range of elements in the set, starting\n+    /// at min, and ending at max. If min is `Unbounded`, then it will be treated as \"negative\n+    /// infinity\", and if max is `Unbounded`, then it will be treated as \"positive infinity\".\n+    /// Thus range(Unbounded, Unbounded) will yield the whole collection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeSet;\n+    /// use std::collections::Bound::{Included, Unbounded};\n+    ///\n+    /// let mut set = BTreeSet::new();\n+    /// set.insert(3u);\n+    /// set.insert(5u);\n+    /// set.insert(8u);\n+    /// for &elem in set.range(Included(&4), Included(&8)) {\n+    ///     println!(\"{}\", elem);\n+    /// }\n+    /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n+    /// ```\n+    #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n+    pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a T, &'a ())) -> &'a T = first; // coerce to fn pointer\n+\n+        Range { iter: self.map.range(min, max).map(first) }\n+    }\n+}\n+\n impl<T: Ord> BTreeSet<T> {\n     /// Visits the values representing the difference, in ascending order.\n     ///\n@@ -598,6 +634,16 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n #[stable]\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n+\n+impl<'a, T> Iterator for Range<'a, T> {\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+}\n+impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n+    fn next_back(&mut self) -> Option<&'a T> { self.iter.next_back() }\n+}\n+\n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>,\n                         short: Ordering, long: Ordering) -> Ordering {"}, {"sha": "10ea0421eee9067268ddab488c1bfb8f75ef1c5c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "patch": "@@ -26,7 +26,6 @@\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n-#![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(unstable)]\n #![no_std]\n@@ -142,3 +141,13 @@ mod prelude {\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }\n+\n+/// An endpoint of a range of keys.\n+pub enum Bound<T> {\n+    /// An inclusive bound.\n+    Included(T),\n+    /// An exclusive bound.\n+    Excluded(T),\n+    /// An infinite endpoint. Indicates that there is no bound in this direction.\n+    Unbounded,\n+}"}, {"sha": "f085fd259de8299b523e18a4e7f9dde727ca4a18", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=54c9a4655b8c662b5ce3a7ad8a47a4d4d12e78b7", "patch": "@@ -311,6 +311,7 @@\n \n #![stable]\n \n+pub use core_collections::Bound;\n pub use core_collections::{BinaryHeap, Bitv, BitvSet, BTreeMap, BTreeSet};\n pub use core_collections::{DList, RingBuf, VecMap};\n "}]}