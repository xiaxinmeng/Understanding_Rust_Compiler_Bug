{"sha": "69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "node_id": "C_kwDOAAsO6NoAKDY5ZTY2NmZkYmFhZWMxYTRlOWI5YjBlOTY0M2E4ZGJmYmI1MWNiODk", "commit": {"author": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-11-04T21:01:59Z"}, "committer": {"name": "Anatol Ulrich", "email": "anatol.ulrich@ferrous-systems.com", "date": "2021-11-04T21:01:59Z"}, "message": "maybe?", "tree": {"sha": "679882781925acee21ad86116556657c79c86378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/679882781925acee21ad86116556657c79c86378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "html_url": "https://github.com/rust-lang/rust/commit/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89/comments", "author": null, "committer": null, "parents": [{"sha": "c96481e25f08d1565cb9b3cac89323216e6f8d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96481e25f08d1565cb9b3cac89323216e6f8d7f", "html_url": "https://github.com/rust-lang/rust/commit/c96481e25f08d1565cb9b3cac89323216e6f8d7f"}], "stats": {"total": 57, "additions": 33, "deletions": 24}, "files": [{"sha": "ffecffc46d6832414b5a0e89cf98bc23b5eb2e14", "filename": "crates/ide_ssr/src/search.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89/crates%2Fide_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_ssr%2Fsrc%2Fsearch.rs?ref=69e666fdbaaec1a4e9b9b0e9643a8dbfbb51cb89", "patch": "@@ -58,7 +58,7 @@ impl<'db> MatchFinder<'db> {\n         if let Some(resolved_path) = pick_path_for_usages(pattern) {\n             let definition: Definition = resolved_path.resolution.clone().into();\n             for file_range in self.find_usages(usage_cache, definition).file_ranges() {\n-                if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n+                for node_to_match in self.find_nodes_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n                         cov_mark::hit!(use_declaration_with_braces);\n                         continue;\n@@ -69,36 +69,45 @@ impl<'db> MatchFinder<'db> {\n         }\n     }\n \n-    fn find_node_to_match(\n+    fn find_nodes_to_match(\n         &self,\n         resolved_path: &ResolvedPath,\n         file_range: FileRange,\n-    ) -> Option<SyntaxNode> {\n+    ) -> Vec<SyntaxNode> {\n         let file = self.sema.parse(file_range.file_id);\n         let depth = resolved_path.depth as usize;\n         let offset = file_range.range.start();\n-        if let Some(path) =\n-            self.sema.find_node_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n-        {\n-            self.sema.ancestors_with_macros(path.syntax().clone()).nth(depth)\n-        } else if let Some(path) =\n-            self.sema.find_node_at_offset_with_descend::<ast::MethodCallExpr>(file.syntax(), offset)\n-        {\n-            // If the pattern contained a path and we found a reference to that path that wasn't\n-            // itself a path, but was a method call, then we need to adjust how far up to try\n-            // matching by how deep the path was within a CallExpr. The structure would have been\n-            // CallExpr, PathExpr, Path - i.e. a depth offset of 2. We don't need to check if the\n-            // path was part of a CallExpr because if it wasn't then all that will happen is we'll\n-            // fail to match, which is the desired behavior.\n-            const PATH_DEPTH_IN_CALL_EXPR: usize = 2;\n-            if depth < PATH_DEPTH_IN_CALL_EXPR {\n-                return None;\n-            }\n-            self.sema\n-                .ancestors_with_macros(path.syntax().clone())\n-                .nth(depth - PATH_DEPTH_IN_CALL_EXPR)\n+\n+        let mut paths = self\n+            .sema\n+            .find_nodes_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n+            .peekable();\n+\n+        if paths.peek().is_some() {\n+            paths\n+                .filter_map(|path| {\n+                    self.sema.ancestors_with_macros(path.syntax().clone()).nth(depth)\n+                })\n+                .collect::<Vec<_>>()\n         } else {\n-            None\n+            self.sema\n+                .find_nodes_at_offset_with_descend::<ast::MethodCallExpr>(file.syntax(), offset)\n+                .filter_map(|path| {\n+                    // If the pattern contained a path and we found a reference to that path that wasn't\n+                    // itself a path, but was a method call, then we need to adjust how far up to try\n+                    // matching by how deep the path was within a CallExpr. The structure would have been\n+                    // CallExpr, PathExpr, Path - i.e. a depth offset of 2. We don't need to check if the\n+                    // path was part of a CallExpr because if it wasn't then all that will happen is we'll\n+                    // fail to match, which is the desired behavior.\n+                    const PATH_DEPTH_IN_CALL_EXPR: usize = 2;\n+                    if depth < PATH_DEPTH_IN_CALL_EXPR {\n+                        return None;\n+                    }\n+                    self.sema\n+                        .ancestors_with_macros(path.syntax().clone())\n+                        .nth(depth - PATH_DEPTH_IN_CALL_EXPR)\n+                })\n+                .collect::<Vec<_>>()\n         }\n     }\n "}]}