{"sha": "b236819f7222c43749e500970b52ee671d68a67a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMzY4MTlmNzIyMmM0Mzc0OWU1MDA5NzBiNTJlZTY3MWQ2OGE2N2E=", "commit": {"author": {"name": "cassiersg", "email": "cassiersg@users.noreply.github.com", "date": "2016-01-11T00:16:52Z"}, "committer": {"name": "cassiersg", "email": "cassiersg@users.noreply.github.com", "date": "2016-01-11T00:16:52Z"}, "message": "Merge pull request #756 from cassiersg/missed-comments\n\nDetect (and recover) when comments disappear", "tree": {"sha": "89caa0bdef929c5e18c1281e47e7046837c9d067", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89caa0bdef929c5e18c1281e47e7046837c9d067"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b236819f7222c43749e500970b52ee671d68a67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b236819f7222c43749e500970b52ee671d68a67a", "html_url": "https://github.com/rust-lang/rust/commit/b236819f7222c43749e500970b52ee671d68a67a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b236819f7222c43749e500970b52ee671d68a67a/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0badc128f77ac975069c0769a2a26c4189491e5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0badc128f77ac975069c0769a2a26c4189491e5a", "html_url": "https://github.com/rust-lang/rust/commit/0badc128f77ac975069c0769a2a26c4189491e5a"}, {"sha": "b117d7b2b845fad5d5bb30a620a13b4810e7ffe3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b117d7b2b845fad5d5bb30a620a13b4810e7ffe3", "html_url": "https://github.com/rust-lang/rust/commit/b117d7b2b845fad5d5bb30a620a13b4810e7ffe3"}], "stats": {"total": 328, "additions": 285, "deletions": 43}, "files": [{"sha": "3382ab53276cc1599ea0f22ebc0c96bc42a5c375", "filename": "src/comment.rs", "status": "modified", "additions": 233, "deletions": 37, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/b236819f7222c43749e500970b52ee671d68a67a/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236819f7222c43749e500970b52ee671d68a67a/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=b236819f7222c43749e500970b52ee671d68a67a", "patch": "@@ -8,13 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Format comments.\n+// Formatting and tools for comments.\n \n-use std::iter;\n+use std::{self, iter};\n+\n+use syntax::codemap::Span;\n \n use Indent;\n use config::Config;\n+use rewrite::RewriteContext;\n use string::{StringFormat, rewrite_string};\n+use utils::wrap_str;\n \n pub fn rewrite_comment(orig: &str,\n                        block_style: bool,\n@@ -150,7 +154,7 @@ impl FindUncommented for str {\n                 }\n                 Some(c) => {\n                     match kind {\n-                        CodeCharKind::Normal if b == c => {}\n+                        FullCodeCharKind::Normal if b == c => {}\n                         _ => {\n                             needle_iter = pat.chars();\n                         }\n@@ -174,7 +178,7 @@ impl FindUncommented for str {\n pub fn find_comment_end(s: &str) -> Option<usize> {\n     let mut iter = CharClasses::new(s.char_indices());\n     for (kind, (i, _c)) in &mut iter {\n-        if kind == CodeCharKind::Normal {\n+        if kind == FullCodeCharKind::Normal {\n             return Some(i);\n         }\n     }\n@@ -189,7 +193,7 @@ pub fn find_comment_end(s: &str) -> Option<usize> {\n \n /// Returns true if text contains any comment.\n pub fn contains_comment(text: &str) -> bool {\n-    CharClasses::new(text.chars()).any(|(kind, _)| kind == CodeCharKind::Comment)\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind.is_comment())\n }\n \n struct CharClasses<T>\n@@ -234,12 +238,47 @@ enum CharClassesStatus {\n     LineComment,\n }\n \n+/// Distinguish between functionnal part of code and comments\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n pub enum CodeCharKind {\n     Normal,\n     Comment,\n }\n \n+/// Distinguish between functionnal part of code and comments,\n+/// describing opening and closing of comments for ease when chunking\n+/// code from tagged characters\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum FullCodeCharKind {\n+    Normal,\n+    /// The first character of a comment, there is only one for a comment (always '/')\n+    StartComment,\n+    /// Any character inside a comment including the second character of comment\n+    /// marks (\"//\", \"/*\")\n+    InComment,\n+    /// Last character of a comment, '\\n' for a line comment, '/' for a block comment.\n+    EndComment,\n+}\n+\n+impl FullCodeCharKind {\n+    fn is_comment(&self) -> bool {\n+        match *self {\n+            FullCodeCharKind::Normal => false,\n+            FullCodeCharKind::StartComment |\n+            FullCodeCharKind::InComment |\n+            FullCodeCharKind::EndComment => true,\n+        }\n+    }\n+\n+    fn to_codecharkind(&self) -> CodeCharKind {\n+        if self.is_comment() {\n+            CodeCharKind::Comment\n+        } else {\n+            CodeCharKind::Normal\n+        }\n+    }\n+}\n+\n impl<T> CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n@@ -256,9 +295,9 @@ impl<T> Iterator for CharClasses<T>\n     where T: Iterator,\n           T::Item: RichChar\n {\n-    type Item = (CodeCharKind, T::Item);\n+    type Item = (FullCodeCharKind, T::Item);\n \n-    fn next(&mut self) -> Option<(CodeCharKind, T::Item)> {\n+    fn next(&mut self) -> Option<(FullCodeCharKind, T::Item)> {\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n@@ -286,11 +325,11 @@ impl<T> Iterator for CharClasses<T>\n                         match self.base.peek() {\n                             Some(next) if next.get_char() == '*' => {\n                                 self.status = CharClassesStatus::BlockCommentOpening(1);\n-                                return Some((CodeCharKind::Comment, item));\n+                                return Some((FullCodeCharKind::StartComment, item));\n                             }\n                             Some(next) if next.get_char() == '/' => {\n                                 self.status = CharClassesStatus::LineComment;\n-                                return Some((CodeCharKind::Comment, item));\n+                                return Some((FullCodeCharKind::StartComment, item));\n                             }\n                             _ => CharClassesStatus::Normal,\n                         }\n@@ -299,12 +338,7 @@ impl<T> Iterator for CharClasses<T>\n                 }\n             }\n             CharClassesStatus::BlockComment(deepness) => {\n-                if deepness == 0 {\n-                    // This is the closing '/'\n-                    assert_eq!(chr, '/');\n-                    self.status = CharClassesStatus::Normal;\n-                    return Some((CodeCharKind::Comment, item));\n-                }\n+                assert!(deepness != 0);\n                 self.status = match self.base.peek() {\n                     Some(next) if next.get_char() == '/' && chr == '*' => {\n                         CharClassesStatus::BlockCommentClosing(deepness - 1)\n@@ -314,34 +348,92 @@ impl<T> Iterator for CharClasses<T>\n                     }\n                     _ => CharClassesStatus::BlockComment(deepness),\n                 };\n-                return Some((CodeCharKind::Comment, item));\n+                return Some((FullCodeCharKind::InComment, item));\n             }\n             CharClassesStatus::BlockCommentOpening(deepness) => {\n                 assert_eq!(chr, '*');\n                 self.status = CharClassesStatus::BlockComment(deepness);\n-                return Some((CodeCharKind::Comment, item));\n+                return Some((FullCodeCharKind::InComment, item));\n             }\n             CharClassesStatus::BlockCommentClosing(deepness) => {\n                 assert_eq!(chr, '/');\n-                self.status = if deepness == 0 {\n-                    CharClassesStatus::Normal\n+                if deepness == 0 {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n                 } else {\n-                    CharClassesStatus::BlockComment(deepness)\n-                };\n-                return Some((CodeCharKind::Comment, item));\n+                    self.status = CharClassesStatus::BlockComment(deepness);\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n             }\n             CharClassesStatus::LineComment => {\n-                self.status = match chr {\n-                    '\\n' => CharClassesStatus::Normal,\n-                    _ => CharClassesStatus::LineComment,\n-                };\n-                return Some((CodeCharKind::Comment, item));\n+                match chr {\n+                    '\\n' => {\n+                        self.status = CharClassesStatus::Normal;\n+                        return Some((FullCodeCharKind::EndComment, item));\n+                    }\n+                    _ => {\n+                        self.status = CharClassesStatus::LineComment;\n+                        return Some((FullCodeCharKind::InComment, item));\n+                    }\n+                }\n+            }\n+        };\n+        Some((FullCodeCharKind::Normal, item))\n+    }\n+}\n+\n+/// Iterator over functional and commented parts of a string. Any part of a string is either\n+/// functional code, either *one* block comment, either *one* line comment. Whitespace between\n+/// comments is functional code. Line comments contain their ending newlines.\n+struct UngroupedCommentCodeSlices<'a> {\n+    slice: &'a str,\n+    iter: iter::Peekable<CharClasses<std::str::CharIndices<'a>>>,\n+}\n+\n+impl<'a> UngroupedCommentCodeSlices<'a> {\n+    fn new(code: &'a str) -> UngroupedCommentCodeSlices<'a> {\n+        UngroupedCommentCodeSlices {\n+            slice: code,\n+            iter: CharClasses::new(code.char_indices()).peekable(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n+    type Item = (CodeCharKind, usize, &'a str);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (kind, (start_idx, _)) = try_opt!(self.iter.next());\n+        match kind {\n+            FullCodeCharKind::Normal => {\n+                // Consume all the Normal code\n+                while let Some(&(FullCodeCharKind::Normal, (_, _))) = self.iter.peek() {\n+                    let _ = self.iter.next();\n+                }\n             }\n+            FullCodeCharKind::StartComment => {\n+                // Consume the whole comment\n+                while let Some((FullCodeCharKind::InComment, (_, _))) = self.iter.next() {}\n+            }\n+            _ => panic!(),\n+        }\n+        let slice = match self.iter.peek() {\n+            Some(&(_, (end_idx, _))) => &self.slice[start_idx..end_idx],\n+            None => &self.slice[start_idx..],\n         };\n-        Some((CodeCharKind::Normal, item))\n+        Some((if kind.is_comment() {\n+            CodeCharKind::Comment\n+        } else {\n+            CodeCharKind::Normal\n+        },\n+              start_idx,\n+              slice))\n     }\n }\n \n+\n+\n+\n /// Iterator over an alternating sequence of functional and commented parts of\n /// a string. The first item is always a, possibly zero length, subslice of\n /// functional text. Line style comments contain their ending newlines.\n@@ -383,7 +475,7 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n                 first_whitespace = Some(i);\n             }\n \n-            if kind == self.last_slice_kind && !is_comment_connector {\n+            if kind.to_codecharkind() == self.last_slice_kind && !is_comment_connector {\n                 let last_index = match first_whitespace {\n                     Some(j) => j,\n                     None => i,\n@@ -419,20 +511,124 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n     }\n }\n \n+/// Checks is `new` didn't miss any comment from `span`, if it removed any, return previous text\n+/// (if it fits in the width/offset, else return None), else return `new`\n+pub fn recover_comment_removed(new: String,\n+                               span: Span,\n+                               context: &RewriteContext,\n+                               width: usize,\n+                               offset: Indent)\n+                               -> Option<String> {\n+    let snippet = context.snippet(span);\n+    if changed_comment_content(&snippet, &new) {\n+        // We missed some comments\n+        // Keep previous formatting if it satisfies the constrains\n+        return wrap_str(snippet, context.config.max_width, width, offset);\n+    } else {\n+        Some(new)\n+    }\n+}\n+\n+/// Return true if the two strings of code have the same payload of comments.\n+/// The payload of comments is everything in the string except:\n+/// \t- actual code (not comments)\n+/// \t- comment start/end marks\n+///\t\t- whitespace\n+///\t\t- '*' at the beginning of lines in block comments\n+fn changed_comment_content(orig: &str, new: &str) -> bool {\n+    // Cannot write this as a fn since we cannot return types containing closures\n+    let code_comment_content = |code| {\n+        let slices = UngroupedCommentCodeSlices::new(code);\n+        slices.filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n+              .flat_map(|(_, _, s)| CommentReducer::new(s))\n+    };\n+    let res = code_comment_content(orig).ne(code_comment_content(new));\n+    debug!(\"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\",\n+           res,\n+           orig,\n+           new,\n+           code_comment_content(orig).collect::<String>(),\n+           code_comment_content(new).collect::<String>());\n+    res\n+}\n+\n+\n+/// Iterator over the 'payload' characters of a comment.\n+/// It skips whitespace, comment start/end marks, and '*' at the beginning of lines.\n+/// The comment must be one comment, ie not more than one start mark (no multiple line comments,\n+/// for example).\n+struct CommentReducer<'a> {\n+    is_block: bool,\n+    at_start_line: bool,\n+    iter: std::str::Chars<'a>,\n+}\n+\n+impl<'a> CommentReducer<'a> {\n+    fn new(comment: &'a str) -> CommentReducer<'a> {\n+        let is_block = comment.starts_with(\"/*\");\n+        let comment = remove_comment_header(comment);\n+        CommentReducer {\n+            is_block: is_block,\n+            at_start_line: false, // There are no supplementary '*' on the first line\n+            iter: comment.chars(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for CommentReducer<'a> {\n+    type Item = char;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            let mut c = try_opt!(self.iter.next());\n+            if self.is_block && self.at_start_line {\n+                while c.is_whitespace() {\n+                    c = try_opt!(self.iter.next());\n+                }\n+                // Ignore leading '*'\n+                if c == '*' {\n+                    c = try_opt!(self.iter.next());\n+                }\n+            } else {\n+                if c == '\\n' {\n+                    self.at_start_line = true;\n+                }\n+            }\n+            if !c.is_whitespace() {\n+                return Some(c);\n+            }\n+        }\n+    }\n+}\n+\n+\n+fn remove_comment_header(comment: &str) -> &str {\n+    if comment.starts_with(\"///\") || comment.starts_with(\"//!\") {\n+        &comment[3..]\n+    } else if comment.starts_with(\"//\") {\n+        &comment[2..]\n+    } else if comment.starts_with(\"/**\") || comment.starts_with(\"/*!\") {\n+        &comment[3..comment.len() - 2]\n+    } else {\n+        assert!(comment.starts_with(\"/*\"),\n+                format!(\"string '{}' is not a comment\", comment));\n+        &comment[2..comment.len() - 2]\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::{CharClasses, CodeCharKind, contains_comment, rewrite_comment, FindUncommented,\n-                CommentCodeSlices};\n+    use super::{CharClasses, CodeCharKind, FullCodeCharKind, contains_comment, rewrite_comment,\n+                FindUncommented, CommentCodeSlices};\n     use Indent;\n \n     #[test]\n     fn char_classes() {\n         let mut iter = CharClasses::new(\"//\\n\\n\".chars());\n \n-        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, '/'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Comment, '\\n'), iter.next().unwrap());\n-        assert_eq!((CodeCharKind::Normal, '\\n'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::StartComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::InComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::EndComment, '\\n'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::Normal, '\\n'), iter.next().unwrap());\n         assert_eq!(None, iter.next());\n     }\n \n@@ -507,8 +703,8 @@ mod test {\n         CharClasses::new(text.chars())\n             .filter_map(|(s, c)| {\n                 match s {\n-                    CodeCharKind::Normal => Some(c),\n-                    CodeCharKind::Comment => None,\n+                    FullCodeCharKind::Normal => Some(c),\n+                    _ => None,\n                 }\n             })\n             .collect()"}, {"sha": "269e45f9e9fb21d26ba4d99b290e07a6b01aae87", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b236819f7222c43749e500970b52ee671d68a67a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236819f7222c43749e500970b52ee671d68a67a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b236819f7222c43749e500970b52ee671d68a67a", "patch": "@@ -23,7 +23,7 @@ use utils::{span_after, extra_offset, last_line_width, wrap_str, binary_search,\n             semicolon_for_stmt};\n use visitor::FmtVisitor;\n use config::{Config, StructLitStyle, MultilineStyle};\n-use comment::{FindUncommented, rewrite_comment, contains_comment};\n+use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};\n use chains::rewrite_chain;\n@@ -35,7 +35,7 @@ use syntax::visit::Visitor;\n \n impl Rewrite for ast::Expr {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        match self.node {\n+        let result = match self.node {\n             ast::Expr_::ExprVec(ref expr_vec) => {\n                 rewrite_array(expr_vec.iter().map(|e| &**e),\n                               mk_sp(span_after(self.span, \"[\", context.codemap), self.span.hi),\n@@ -207,7 +207,8 @@ impl Rewrite for ast::Expr {\n                          width,\n                          offset)\n             }\n-        }\n+        };\n+        result.and_then(|res| recover_comment_removed(res, self.span, context, width, offset))\n     }\n }\n \n@@ -478,7 +479,7 @@ impl Rewrite for ast::Block {\n \n impl Rewrite for ast::Stmt {\n     fn rewrite(&self, context: &RewriteContext, _width: usize, offset: Indent) -> Option<String> {\n-        match self.node {\n+        let result = match self.node {\n             ast::Stmt_::StmtDecl(ref decl, _) => {\n                 if let ast::Decl_::DeclLocal(ref local) = decl.node {\n                     local.rewrite(context, context.config.max_width, offset)\n@@ -499,7 +500,8 @@ impl Rewrite for ast::Stmt {\n                   .map(|s| s + suffix)\n             }\n             ast::Stmt_::StmtMac(..) => None,\n-        }\n+        };\n+        result.and_then(|res| recover_comment_removed(res, self.span, context, _width, offset))\n     }\n }\n "}, {"sha": "af61ba89b1cb613a6406171dc46719b09d3d88fb", "filename": "tests/source/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b236819f7222c43749e500970b52ee671d68a67a/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236819f7222c43749e500970b52ee671d68a67a/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=b236819f7222c43749e500970b52ee671d68a67a", "patch": "@@ -17,7 +17,8 @@ fn main() {\n \n     < *mut JSObject >:: relocate(entry);\n \n-    let x: Foo/*::*/<A   >;\n+    let x: Foo<A   >;\n+    let x: Foo/*::*/<A>;\n }\n \n fn op(foo: Bar, key : &[u8], upd : Fn(Option<&memcache::Item> , Baz  ) -> Result) -> MapResult {}"}, {"sha": "23c00c418be47d598d0dcbe800ddc49b7e96615d", "filename": "tests/target/comment-not-disappear.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b236819f7222c43749e500970b52ee671d68a67a/tests%2Ftarget%2Fcomment-not-disappear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236819f7222c43749e500970b52ee671d68a67a/tests%2Ftarget%2Fcomment-not-disappear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment-not-disappear.rs?ref=b236819f7222c43749e500970b52ee671d68a67a", "patch": "@@ -0,0 +1,42 @@\n+// All the comments here should not disappear.\n+\n+fn a() {\n+    match x {\n+        X |\n+        // A comment\n+        Y => {}\n+    };\n+}\n+\n+fn b() {\n+    match x {\n+        X =>\n+            // A comment\n+            y\n+    }\n+}\n+\n+fn c() {\n+    a() /* ... */;\n+}\n+\n+fn foo() -> Vec<i32> {\n+    (0..11)\n+        .map(|x|\n+        // This comment disappears.\n+        if x % 2 == 0 { x } else { x * 2 })\n+        .collect()\n+}\n+\n+fn d() {\n+    if true /* and ... */ {\n+        a();\n+    }\n+}\n+\n+fn calc_page_len(prefix_len: usize, sofar: usize) -> usize {\n+    2 // page type and flags\n+    + 1 // stored depth\n+    + 2 // stored count\n+    + prefix_len + sofar // sum of size of all the actual items\n+}"}, {"sha": "adae879e647cb957d3927cc2749fd62ed80efb71", "filename": "tests/target/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b236819f7222c43749e500970b52ee671d68a67a/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b236819f7222c43749e500970b52ee671d68a67a/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=b236819f7222c43749e500970b52ee671d68a67a", "patch": "@@ -17,6 +17,7 @@ fn main() {\n     <*mut JSObject>::relocate(entry);\n \n     let x: Foo<A>;\n+    let x: Foo/*::*/<A>;\n }\n \n fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {}"}]}