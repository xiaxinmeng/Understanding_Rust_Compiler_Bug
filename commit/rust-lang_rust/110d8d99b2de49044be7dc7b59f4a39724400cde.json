{"sha": "110d8d99b2de49044be7dc7b59f4a39724400cde", "node_id": "C_kwDOAAsO6NoAKDExMGQ4ZDk5YjJkZTQ5MDQ0YmU3ZGM3YjU5ZjRhMzk3MjQ0MDBjZGU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-23T15:10:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-23T15:10:06Z"}, "message": "Rollup merge of #100851 - Alexendoo:rpf-width-prec-spans, r=fee1-dead\n\nFix rustc_parse_format precision & width spans\n\nWhen a `precision`/`width` was `CountIsName - {:name$}` or `CountIs - {:10}` the `precision_span`/`width_span` was set to `None`\n\nFor `width` the name span in `CountIsName(_, name_span)` had its `.start` off by one\n\nr? ``@fee1-dead`` / cc ``@PrestonFrom`` since this is similar to #99987", "tree": {"sha": "b51828bd6ca0938f1ca293d4b8f9b8f5d45ecd15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b51828bd6ca0938f1ca293d4b8f9b8f5d45ecd15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/110d8d99b2de49044be7dc7b59f4a39724400cde", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjBO3OCRBK7hj4Ov3rIwAAWuoIAKjy+2pKYLyaQvYc9mqi9mxy\ne9KyWAoq+SYIPkDs/iKdFYFeK52CyZdVwxSEvbS0EE1c0LfSC+Z4nmrKD6x3/qlE\n/aAoZlAQqJaLHQzRPyKe1kTmiA9a3q1baNbEdhLdL2APTusuzrSuB6eE/VxPsppR\nLaCzLdvia/OwbcctYrpIKapOR+p/as7AUE1tdDidc3nHtt6u+CWcNQcH8swGfGS1\nGN3zOaY6OEQTAPbfIeENZs1BTMMHbR+tWF/NxNCNdQooUBJXjrdQDGorVwSlzMB/\nGCxGxoU5cb1jGDcK5dHJ9NynNSZunysHiVvn3FFZSPS7WkOFq2oR73YDMJYUSeM=\n=R+tI\n-----END PGP SIGNATURE-----\n", "payload": "tree b51828bd6ca0938f1ca293d4b8f9b8f5d45ecd15\nparent a163659b1b619d3e7872fda88de5c09c3d47635e\nparent 586c84a0522072b68d38d1d062b7264ab323a87e\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661267406 +0530\ncommitter GitHub <noreply@github.com> 1661267406 +0530\n\nRollup merge of #100851 - Alexendoo:rpf-width-prec-spans, r=fee1-dead\n\nFix rustc_parse_format precision & width spans\n\nWhen a `precision`/`width` was `CountIsName - {:name$}` or `CountIs - {:10}` the `precision_span`/`width_span` was set to `None`\n\nFor `width` the name span in `CountIsName(_, name_span)` had its `.start` off by one\n\nr? ``@fee1-dead`` / cc ``@PrestonFrom`` since this is similar to #99987\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/110d8d99b2de49044be7dc7b59f4a39724400cde", "html_url": "https://github.com/rust-lang/rust/commit/110d8d99b2de49044be7dc7b59f4a39724400cde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/110d8d99b2de49044be7dc7b59f4a39724400cde/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a163659b1b619d3e7872fda88de5c09c3d47635e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a163659b1b619d3e7872fda88de5c09c3d47635e", "html_url": "https://github.com/rust-lang/rust/commit/a163659b1b619d3e7872fda88de5c09c3d47635e"}, {"sha": "586c84a0522072b68d38d1d062b7264ab323a87e", "url": "https://api.github.com/repos/rust-lang/rust/commits/586c84a0522072b68d38d1d062b7264ab323a87e", "html_url": "https://github.com/rust-lang/rust/commit/586c84a0522072b68d38d1d062b7264ab323a87e"}], "stats": {"total": 149, "additions": 84, "deletions": 65}, "files": [{"sha": "2816f81fef1218a9a5aa7f5de81d4ea675d135ee", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=110d8d99b2de49044be7dc7b59f4a39724400cde", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string, and remembers it if valid.\n     /// All errors are not emitted as fatal so we can continue giving errors\n     /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece<'_>) {\n+    fn verify_piece(&mut self, p: &parse::Piece<'a>) {\n         match *p {\n             parse::String(..) => {}\n             parse::NextArgument(ref arg) => {\n@@ -433,6 +433,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let has_precision = arg.format.precision != Count::CountImplied;\n                 let has_width = arg.format.width != Count::CountImplied;\n \n+                if has_precision || has_width {\n+                    // push before named params are resolved to aid diagnostics\n+                    self.arg_with_formatting.push(arg.format);\n+                }\n+\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n@@ -581,7 +586,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         let mut zero_based_note = false;\n \n         let count = self.pieces.len()\n-            + self.arg_with_formatting.iter().filter(|fmt| fmt.precision_span.is_some()).count();\n+            + self\n+                .arg_with_formatting\n+                .iter()\n+                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n+                .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n             e = self.ecx.struct_span_err(\n                 sp,\n@@ -647,7 +656,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                             + self\n                                 .arg_with_formatting\n                                 .iter()\n-                                .filter(|fmt| fmt.precision_span.is_some())\n+                                .filter(|fmt| matches!(fmt.precision, parse::CountIsParam(_)))\n                                 .count();\n                         e.span_label(\n                             span,\n@@ -899,26 +908,22 @@ impl<'a, 'b> Context<'a, 'b> {\n                     },\n                     position_span: arg.position_span,\n                     format: parse::FormatSpec {\n-                        fill: arg.format.fill,\n+                        fill: None,\n                         align: parse::AlignUnknown,\n                         flags: 0,\n                         precision: parse::CountImplied,\n-                        precision_span: None,\n+                        precision_span: arg.format.precision_span,\n                         width: parse::CountImplied,\n-                        width_span: None,\n+                        width_span: arg.format.width_span,\n                         ty: arg.format.ty,\n                         ty_span: arg.format.ty_span,\n                     },\n                 };\n \n                 let fill = arg.format.fill.unwrap_or(' ');\n-\n                 let pos_simple = arg.position.index() == simple_arg.position.index();\n \n-                if arg.format.precision_span.is_some() || arg.format.width_span.is_some() {\n-                    self.arg_with_formatting.push(arg.format);\n-                }\n-                if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n+                if !pos_simple || arg.format != simple_arg.format {\n                     self.all_pieces_simple = false;\n                 }\n "}, {"sha": "b63a173cc29e6cd3a5dc8806dacc825e6949bb3e", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=110d8d99b2de49044be7dc7b59f4a39724400cde", "patch": "@@ -264,9 +264,7 @@ impl<'a> Iterator for Parser<'a> {\n             }\n         } else {\n             if self.is_literal {\n-                let start = self.to_span_index(self.cur_line_start);\n-                let end = self.to_span_index(self.input.len());\n-                let span = start.to(end);\n+                let span = self.span(self.cur_line_start, self.input.len());\n                 if self.line_spans.last() != Some(&span) {\n                     self.line_spans.push(span);\n                 }\n@@ -384,6 +382,12 @@ impl<'a> Parser<'a> {\n         InnerOffset(raw + pos + 1)\n     }\n \n+    fn span(&self, start_pos: usize, end_pos: usize) -> InnerSpan {\n+        let start = self.to_span_index(start_pos);\n+        let end = self.to_span_index(end_pos);\n+        start.to(end)\n+    }\n+\n     /// Forces consumption of the specified character. If the character is not\n     /// found, an error is emitted.\n     fn must_consume(&mut self, c: char) -> Option<usize> {\n@@ -472,9 +476,7 @@ impl<'a> Parser<'a> {\n                     return &self.input[start..pos];\n                 }\n                 '\\n' if self.is_literal => {\n-                    let start = self.to_span_index(self.cur_line_start);\n-                    let end = self.to_span_index(pos);\n-                    self.line_spans.push(start.to(end));\n+                    self.line_spans.push(self.span(self.cur_line_start, pos));\n                     self.cur_line_start = pos + 1;\n                     self.cur.next();\n                 }\n@@ -537,6 +539,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn current_pos(&mut self) -> usize {\n+        if let Some(&(pos, _)) = self.cur.peek() { pos } else { self.input.len() }\n+    }\n+\n     /// Parses a format specifier at the current position, returning all of the\n     /// relevant information in the `FormatSpec` struct.\n     fn format(&mut self) -> FormatSpec<'a> {\n@@ -590,39 +596,37 @@ impl<'a> Parser<'a> {\n             // no '0' flag and '0$' as the width instead.\n             if let Some(end) = self.consume_pos('$') {\n                 spec.width = CountIsParam(0);\n-\n-                if let Some((pos, _)) = self.cur.peek().cloned() {\n-                    spec.width_span = Some(self.to_span_index(pos - 2).to(self.to_span_index(pos)));\n-                }\n+                spec.width_span = Some(self.span(end - 1, end + 1));\n                 havewidth = true;\n-                spec.width_span = Some(self.to_span_index(end - 1).to(self.to_span_index(end + 1)));\n             } else {\n                 spec.flags |= 1 << (FlagSignAwareZeroPad as u32);\n             }\n         }\n+\n         if !havewidth {\n-            let width_span_start = if let Some((pos, _)) = self.cur.peek() { *pos } else { 0 };\n-            let (w, sp) = self.count(width_span_start);\n-            spec.width = w;\n-            spec.width_span = sp;\n+            let start = self.current_pos();\n+            spec.width = self.count(start);\n+            if spec.width != CountImplied {\n+                let end = self.current_pos();\n+                spec.width_span = Some(self.span(start, end));\n+            }\n         }\n \n         if let Some(start) = self.consume_pos('.') {\n-            if let Some(end) = self.consume_pos('*') {\n+            if self.consume('*') {\n                 // Resolve `CountIsNextParam`.\n                 // We can do this immediately as `position` is resolved later.\n                 let i = self.curarg;\n                 self.curarg += 1;\n                 spec.precision = CountIsParam(i);\n-                spec.precision_span =\n-                    Some(self.to_span_index(start).to(self.to_span_index(end + 1)));\n             } else {\n-                let (p, sp) = self.count(start);\n-                spec.precision = p;\n-                spec.precision_span = sp;\n+                spec.precision = self.count(start + 1);\n             }\n+            let end = self.current_pos();\n+            spec.precision_span = Some(self.span(start, end));\n         }\n-        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+\n+        let ty_span_start = self.current_pos();\n         // Optional radix followed by the actual format specifier\n         if self.consume('x') {\n             if self.consume('?') {\n@@ -642,11 +646,9 @@ impl<'a> Parser<'a> {\n             spec.ty = \"?\";\n         } else {\n             spec.ty = self.word();\n-            let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n             if !spec.ty.is_empty() {\n-                spec.ty_span = ty_span_start\n-                    .and_then(|s| ty_span_end.map(|e| (s, e)))\n-                    .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+                let ty_span_end = self.current_pos();\n+                spec.ty_span = Some(self.span(ty_span_start, ty_span_end));\n             }\n         }\n         spec\n@@ -670,13 +672,11 @@ impl<'a> Parser<'a> {\n             return spec;\n         }\n \n-        let ty_span_start = self.cur.peek().map(|(pos, _)| *pos);\n+        let ty_span_start = self.current_pos();\n         spec.ty = self.word();\n-        let ty_span_end = self.cur.peek().map(|(pos, _)| *pos);\n         if !spec.ty.is_empty() {\n-            spec.ty_span = ty_span_start\n-                .and_then(|s| ty_span_end.map(|e| (s, e)))\n-                .map(|(start, end)| self.to_span_index(start).to(self.to_span_index(end)));\n+            let ty_span_end = self.current_pos();\n+            spec.ty_span = Some(self.span(ty_span_start, ty_span_end));\n         }\n \n         spec\n@@ -685,26 +685,21 @@ impl<'a> Parser<'a> {\n     /// Parses a `Count` parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self, start: usize) -> (Count<'a>, Option<InnerSpan>) {\n+    fn count(&mut self, start: usize) -> Count<'a> {\n         if let Some(i) = self.integer() {\n-            if let Some(end) = self.consume_pos('$') {\n-                let span = self.to_span_index(start).to(self.to_span_index(end + 1));\n-                (CountIsParam(i), Some(span))\n-            } else {\n-                (CountIs(i), None)\n-            }\n+            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n             if word.is_empty() {\n                 self.cur = tmp;\n-                (CountImplied, None)\n+                CountImplied\n             } else if let Some(end) = self.consume_pos('$') {\n-                let span = self.to_span_index(start + 1).to(self.to_span_index(end));\n-                (CountIsName(word, span), None)\n+                let name_span = self.span(start, end);\n+                CountIsName(word, name_span)\n             } else {\n                 self.cur = tmp;\n-                (CountImplied, None)\n+                CountImplied\n             }\n         }\n     }\n@@ -737,7 +732,7 @@ impl<'a> Parser<'a> {\n                 \"invalid argument name `_`\",\n                 \"invalid argument name\",\n                 \"argument name cannot be a single underscore\",\n-                self.to_span_index(start).to(self.to_span_index(end)),\n+                self.span(start, end),\n             );\n         }\n         word"}, {"sha": "44ef0cd0eb5d2f0e0df69d2d117a9a875bf7e751", "filename": "compiler/rustc_parse_format/src/tests.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/110d8d99b2de49044be7dc7b59f4a39724400cde/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Ftests.rs?ref=110d8d99b2de49044be7dc7b59f4a39724400cde", "patch": "@@ -1,5 +1,6 @@\n use super::*;\n \n+#[track_caller]\n fn same(fmt: &'static str, p: &[Piece<'static>]) {\n     let parser = Parser::new(fmt, None, None, false, ParseMode::Format);\n     assert_eq!(parser.collect::<Vec<Piece<'static>>>(), p);\n@@ -190,9 +191,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n-                width: CountIs(10),\n                 precision_span: None,\n-                width_span: None,\n+                width: CountIs(10),\n+                width_span: Some(InnerSpan { start: 3, end: 5 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -208,9 +209,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n+                precision_span: Some(InnerSpan { start: 6, end: 9 }),\n                 width: CountIsParam(10),\n-                precision_span: None,\n-                width_span: Some(InnerSpan::new(3, 6)),\n+                width_span: Some(InnerSpan { start: 3, end: 6 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -226,9 +227,9 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n+                precision_span: Some(InnerSpan { start: 6, end: 9 }),\n                 width: CountIsParam(0),\n-                precision_span: None,\n-                width_span: Some(InnerSpan::new(4, 6)),\n+                width_span: Some(InnerSpan { start: 4, end: 6 }),\n                 ty: \"x\",\n                 ty_span: None,\n             },\n@@ -244,8 +245,8 @@ fn format_counts() {\n                 align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsParam(0),\n+                precision_span: Some(InnerSpan { start: 3, end: 5 }),\n                 width: CountImplied,\n-                precision_span: Some(InnerSpan::new(3, 5)),\n                 width_span: None,\n                 ty: \"x\",\n                 ty_span: None,\n@@ -279,15 +280,33 @@ fn format_counts() {\n                 fill: None,\n                 align: AlignUnknown,\n                 flags: 0,\n-                precision: CountIsName(\"b\", InnerSpan::new(6, 7)),\n-                width: CountIsName(\"a\", InnerSpan::new(4, 4)),\n-                precision_span: None,\n-                width_span: None,\n+                precision: CountIsName(\"b\", InnerSpan { start: 6, end: 7 }),\n+                precision_span: Some(InnerSpan { start: 5, end: 8 }),\n+                width: CountIsName(\"a\", InnerSpan { start: 3, end: 4 }),\n+                width_span: Some(InnerSpan { start: 3, end: 5 }),\n                 ty: \"?\",\n                 ty_span: None,\n             },\n         })],\n     );\n+    same(\n+        \"{:.4}\",\n+        &[NextArgument(Argument {\n+            position: ArgumentImplicitlyIs(0),\n+            position_span: InnerSpan { start: 2, end: 2 },\n+            format: FormatSpec {\n+                fill: None,\n+                align: AlignUnknown,\n+                flags: 0,\n+                precision: CountIs(4),\n+                precision_span: Some(InnerSpan { start: 3, end: 5 }),\n+                width: CountImplied,\n+                width_span: None,\n+                ty: \"\",\n+                ty_span: None,\n+            },\n+        })],\n+    )\n }\n #[test]\n fn format_flags() {"}]}