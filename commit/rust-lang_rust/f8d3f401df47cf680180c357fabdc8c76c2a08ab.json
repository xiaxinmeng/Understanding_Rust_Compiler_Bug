{"sha": "f8d3f401df47cf680180c357fabdc8c76c2a08ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZDNmNDAxZGY0N2NmNjgwMTgwYzM1N2ZhYmRjOGM3NmMyYTA4YWI=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-22T08:54:09Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-09-24T07:03:50Z"}, "message": "walk hir to get const evaluatable predicates", "tree": {"sha": "4a99d7ccc899d9cc71cefbbb6d8eaa2693877673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a99d7ccc899d9cc71cefbbb6d8eaa2693877673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8d3f401df47cf680180c357fabdc8c76c2a08ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8d3f401df47cf680180c357fabdc8c76c2a08ab", "html_url": "https://github.com/rust-lang/rust/commit/f8d3f401df47cf680180c357fabdc8c76c2a08ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8d3f401df47cf680180c357fabdc8c76c2a08ab/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1d0d8b28008277a39a3f4d4a6bc34772c06888", "html_url": "https://github.com/rust-lang/rust/commit/ac1d0d8b28008277a39a3f4d4a6bc34772c06888"}], "stats": {"total": 169, "additions": 96, "deletions": 73}, "files": [{"sha": "d341e7eec41a34466144c7cdcb802168a21a2950", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 84, "deletions": 59, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f8d3f401df47cf680180c357fabdc8c76c2a08ab/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8d3f401df47cf680180c357fabdc8c76c2a08ab/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=f8d3f401df47cf680180c357fabdc8c76c2a08ab", "patch": "@@ -37,12 +37,11 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate, WithConstness};\n-use rustc_middle::ty::{TypeFoldable, TypeVisitor};\n use rustc_session::config::SanitizerSet;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -51,8 +50,6 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n-use smallvec::SmallVec;\n-\n mod type_of;\n \n struct OnlySelfBounds(bool);\n@@ -1676,65 +1673,10 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n         }\n     }\n \n-    if tcx.features().const_evaluatable_checked {\n-        let const_evaluatable = const_evaluatable_predicates_of(tcx, def_id, &result);\n-        if !const_evaluatable.is_empty() {\n-            result.predicates = tcx\n-                .arena\n-                .alloc_from_iter(result.predicates.iter().copied().chain(const_evaluatable));\n-        }\n-    }\n-\n     debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result\n }\n \n-pub fn const_evaluatable_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    predicates: &ty::GenericPredicates<'tcx>,\n-) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-    #[derive(Default)]\n-    struct ConstCollector<'tcx> {\n-        ct: SmallVec<[(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>, Span); 4]>,\n-        curr_span: Span,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for ConstCollector<'tcx> {\n-        fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n-            if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n-                self.ct.push((def, substs, self.curr_span));\n-            }\n-            false\n-        }\n-    }\n-\n-    let mut collector = ConstCollector::default();\n-    for &(pred, span) in predicates.predicates.iter() {\n-        collector.curr_span = span;\n-        pred.visit_with(&mut collector);\n-    }\n-\n-    match tcx.def_kind(def_id) {\n-        DefKind::Fn | DefKind::AssocFn => {\n-            tcx.fn_sig(def_id).visit_with(&mut collector);\n-        }\n-        _ => (),\n-    }\n-    debug!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.ct);\n-\n-    // We only want unique const evaluatable predicates.\n-    collector.ct.sort();\n-    collector.ct.dedup();\n-    collector\n-        .ct\n-        .into_iter()\n-        .map(move |(def_id, subst, span)| {\n-            (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), span)\n-        })\n-        .collect()\n-}\n-\n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n@@ -2061,6 +2003,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }))\n     }\n \n+    if tcx.features().const_evaluatable_checked {\n+        predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n+    }\n+\n     let mut predicates: Vec<_> = predicates.into_iter().collect();\n \n     // Subtle: before we store the predicates into the tcx, we\n@@ -2087,6 +2033,85 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     result\n }\n \n+fn const_evaluatable_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> FxIndexSet<(ty::Predicate<'tcx>, Span)> {\n+    struct ConstCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        preds: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n+    }\n+\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstCollector<'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+            let def_id = self.tcx.hir().local_def_id(c.hir_id);\n+            let ct = ty::Const::from_anon_const(self.tcx, def_id);\n+            if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n+                let span = self.tcx.hir().span(c.hir_id);\n+                self.preds.insert((\n+                    ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                    span,\n+                ));\n+            }\n+        }\n+\n+        // Look into `TyAlias`.\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n+            use ty::fold::{TypeFoldable, TypeVisitor};\n+            struct TyAliasVisitor<'a, 'tcx> {\n+                tcx: TyCtxt<'tcx>,\n+                preds: &'a mut FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n+                span: Span,\n+            }\n+\n+            impl<'a, 'tcx> TypeVisitor<'tcx> for TyAliasVisitor<'a, 'tcx> {\n+                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n+                    if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n+                        self.preds.insert((\n+                            ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                            self.span,\n+                        ));\n+                    }\n+                    false\n+                }\n+            }\n+\n+            if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind {\n+                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n+                    let mut visitor =\n+                        TyAliasVisitor { tcx: self.tcx, preds: &mut self.preds, span: path.span };\n+                    self.tcx.type_of(def_id).visit_with(&mut visitor);\n+                }\n+            }\n+\n+            intravisit::walk_ty(self, ty)\n+        }\n+    }\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(hir_id);\n+\n+    let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n+    if let Some(generics) = node.generics() {\n+        warn!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n+        collector.visit_generics(generics);\n+    }\n+\n+    if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n+        warn!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n+        collector.visit_fn_decl(fn_sig.decl);\n+    }\n+    warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n+\n+    collector.preds\n+}\n+\n fn projection_ty_from_predicates(\n     tcx: TyCtxt<'tcx>,\n     key: ("}, {"sha": "e7da191e670ec5646c56ccb1bd8b8268ef5df490", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8d3f401df47cf680180c357fabdc8c76c2a08ab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d3f401df47cf680180c357fabdc8c76c2a08ab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr?ref=f8d3f401df47cf680180c357fabdc8c76c2a08ab", "patch": "@@ -4,10 +4,10 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1`\n+   |          ---------------------------- required by this bound in `test1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n@@ -17,10 +17,10 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1`\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ---------------------------- required by this bound in `test1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n@@ -30,10 +30,10 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1::{{constant}}#1`\n+   |          ---------------------------- required by this bound in `test1::{{constant}}#1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n@@ -43,10 +43,10 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n    |\n-LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1::{{constant}}#1`\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ---------------------------- required by this bound in `test1::{{constant}}#1`\n    |\n    = note: this may fail depending on what value the parameter takes\n "}, {"sha": "b76e300663d762e5f715bf90ce5203b63b06f138", "filename": "src/test/ui/const-generics/const_evaluatable_checked/let-bindings.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f8d3f401df47cf680180c357fabdc8c76c2a08ab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f8d3f401df47cf680180c357fabdc8c76c2a08ab/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Flet-bindings.stderr?ref=f8d3f401df47cf680180c357fabdc8c76c2a08ab", "patch": "@@ -1,10 +1,8 @@\n-error: overly complex generic constant\n+error: constant expression depends on a generic parameter\n   --> $DIR/let-bindings.rs:6:68\n    |\n LL | fn test<const N: usize>() -> [u8; { let x = N; N + 1 }] where [u8; { let x = N; N + 1 }]: Default {\n-   |                                                                    ^^^^^^-^^^^^^^^^^^^^\n-   |                                                                          |\n-   |                                                                          unsupported statement\n+   |                                                                    ^^^^^^^^^^^^^^^^^^^^ required by this bound in `test::{{constant}}#0`\n    |\n    = help: consider moving this anonymous constant into a `const` function\n "}]}