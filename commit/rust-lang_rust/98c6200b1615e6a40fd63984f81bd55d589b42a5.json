{"sha": "98c6200b1615e6a40fd63984f81bd55d589b42a5", "node_id": "C_kwDOAAsO6NoAKDk4YzYyMDBiMTYxNWU2YTQwZmQ2Mzk4NGY4MWJkNTVkNTg5YjQyYTU", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2021-01-18T06:28:18Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2021-11-03T05:47:20Z"}, "message": "read_buf", "tree": {"sha": "b74676c6ccc86d5877173250d255bd9d55400ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b74676c6ccc86d5877173250d255bd9d55400ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c6200b1615e6a40fd63984f81bd55d589b42a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c6200b1615e6a40fd63984f81bd55d589b42a5", "html_url": "https://github.com/rust-lang/rust/commit/98c6200b1615e6a40fd63984f81bd55d589b42a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c6200b1615e6a40fd63984f81bd55d589b42a5/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3802025f400af7817ba4874587e6a2df95abd65d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3802025f400af7817ba4874587e6a2df95abd65d", "html_url": "https://github.com/rust-lang/rust/commit/3802025f400af7817ba4874587e6a2df95abd65d"}], "stats": {"total": 1070, "additions": 774, "deletions": 296}, "files": [{"sha": "3609afa9479acda34b8f0eb78191f18bf8a3e9de", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -13,7 +13,7 @@ mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n+use crate::io::{self, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n@@ -629,12 +629,6 @@ impl Read for File {\n         self.inner.is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n-\n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         buf.reserve(buffer_capacity_required(self));\n@@ -687,12 +681,6 @@ impl Read for &File {\n         self.inner.is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n-\n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         buf.reserve(buffer_capacity_required(self));"}, {"sha": "b297e4bf7d9dd5053cf5ca870a530da394f55264", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -1,8 +1,9 @@\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, Initializer, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n+    self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n };\n+use crate::mem::MaybeUninit;\n \n /// The `BufReader<R>` struct adds buffering to any reader.\n ///\n@@ -47,9 +48,10 @@ use crate::io::{\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n-    buf: Box<[u8]>,\n+    buf: Box<[MaybeUninit<u8>]>,\n     pos: usize,\n     cap: usize,\n+    init: usize,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -91,11 +93,8 @@ impl<R: Read> BufReader<R> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(capacity: usize, inner: R) -> BufReader<R> {\n-        unsafe {\n-            let mut buf = Box::new_uninit_slice(capacity).assume_init();\n-            inner.initializer().initialize(&mut buf);\n-            BufReader { inner, buf, pos: 0, cap: 0 }\n-        }\n+        let buf = Box::new_uninit_slice(capacity);\n+        BufReader { inner, buf, pos: 0, cap: 0, init: 0 }\n     }\n }\n \n@@ -171,7 +170,7 @@ impl<R> BufReader<R> {\n     /// ```\n     #[stable(feature = \"bufreader_buffer\", since = \"1.37.0\")]\n     pub fn buffer(&self) -> &[u8] {\n-        &self.buf[self.pos..self.cap]\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[self.pos..self.cap]) }\n     }\n \n     /// Returns the number of bytes the internal buffer can hold at once.\n@@ -271,6 +270,25 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        // If we don't have any buffered data and we're doing a massive read\n+        // (larger than our internal buffer), bypass our internal buffer\n+        // entirely.\n+        if self.pos == self.cap && buf.remaining() >= self.buf.len() {\n+            self.discard_buffer();\n+            return self.inner.read_buf(buf);\n+        }\n+\n+        let prev = buf.filled_len();\n+\n+        let mut rem = self.fill_buf()?;\n+        rem.read_buf(buf)?;\n+\n+        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf\n+\n+        Ok(())\n+    }\n+\n     // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n     // The default implementation calls read in a loop, which results in surprisingly poor code\n     // generation for the common path where the buffer has enough bytes to fill the passed-in\n@@ -303,16 +321,11 @@ impl<R: Read> Read for BufReader<R> {\n         self.inner.is_read_vectored()\n     }\n \n-    // we can't skip unconditionally because of the large buffer case in read.\n-    unsafe fn initializer(&self) -> Initializer {\n-        self.inner.initializer()\n-    }\n-\n     // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n     // delegate to the inner implementation.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         let nread = self.cap - self.pos;\n-        buf.extend_from_slice(&self.buf[self.pos..self.cap]);\n+        buf.extend_from_slice(&self.buffer());\n         self.discard_buffer();\n         Ok(nread + self.inner.read_to_end(buf)?)\n     }\n@@ -363,10 +376,24 @@ impl<R: Read> BufRead for BufReader<R> {\n         // to tell the compiler that the pos..cap slice is always valid.\n         if self.pos >= self.cap {\n             debug_assert!(self.pos == self.cap);\n-            self.cap = self.inner.read(&mut self.buf)?;\n+\n+            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n+\n+            // SAFETY: `self.init` is either 0 set to `readbuf.initialized_len()`\n+            // from the last time this function was called\n+            unsafe {\n+                readbuf.assume_init(self.init);\n+            }\n+\n+            self.inner.read_buf(&mut readbuf)?;\n+\n+            self.cap = readbuf.filled_len();\n+            self.init = readbuf.initialized_len();\n+\n             self.pos = 0;\n         }\n-        Ok(&self.buf[self.pos..self.cap])\n+        // SAFETY: self.cap is always <= self.init, so self.buf[self.pos..self.cap] is always init\n+        unsafe { Ok(MaybeUninit::slice_assume_init_ref(&self.buf[self.pos..self.cap])) }\n     }\n \n     fn consume(&mut self, amt: usize) {"}, {"sha": "9d429e7090e83cb25cecd289af329e53be31ac40", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -1,5 +1,6 @@\n use crate::io::prelude::*;\n-use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\n+use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, ReadBuf, SeekFrom};\n+use crate::mem::MaybeUninit;\n use crate::panic;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::thread;\n@@ -55,6 +56,55 @@ fn test_buffered_reader() {\n     assert_eq!(reader.read(&mut buf).unwrap(), 0);\n }\n \n+#[test]\n+fn test_buffered_reader_read_buf() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(2, inner);\n+\n+    let mut buf = [MaybeUninit::uninit(); 3];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled(), [5, 6, 7]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    let mut buf = [MaybeUninit::uninit(); 2];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled(), [0, 1]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    let mut buf = [MaybeUninit::uninit(); 1];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled(), [2]);\n+    assert_eq!(reader.buffer(), [3]);\n+\n+    let mut buf = [MaybeUninit::uninit(); 3];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled(), [3]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled(), [3, 4]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    buf.clear();\n+\n+    reader.read_buf(&mut buf).unwrap();\n+\n+    assert_eq!(buf.filled_len(), 0);\n+}\n+\n #[test]\n fn test_buffered_reader_seek() {\n     let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];"}, {"sha": "60962d5afc5b7d3e70ccf87ce3109c12fa1b9afb", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -1,4 +1,4 @@\n-use super::{BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n+use super::{BufWriter, ErrorKind, Read, ReadBuf, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -82,33 +82,23 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n             return stack_buffer_copy(reader, writer);\n         }\n \n-        // FIXME: #42788\n-        //\n-        //   - This creates a (mut) reference to a slice of\n-        //     _uninitialized_ integers, which is **undefined behavior**\n-        //\n-        //   - Only the standard library gets to soundly \"ignore\" this,\n-        //     based on its privileged knowledge of unstable rustc\n-        //     internals;\n-        unsafe {\n-            let spare_cap = writer.buffer_mut().spare_capacity_mut();\n-            reader.initializer().initialize(MaybeUninit::slice_assume_init_mut(spare_cap));\n-        }\n-\n         let mut len = 0;\n \n         loop {\n             let buf = writer.buffer_mut();\n-            let spare_cap = buf.spare_capacity_mut();\n-\n-            if spare_cap.len() >= DEFAULT_BUF_SIZE {\n-                match reader.read(unsafe { MaybeUninit::slice_assume_init_mut(spare_cap) }) {\n-                    Ok(0) => return Ok(len), // EOF reached\n-                    Ok(bytes_read) => {\n-                        assert!(bytes_read <= spare_cap.len());\n-                        // SAFETY: The initializer contract guarantees that either it or `read`\n-                        // will have initialized these bytes. And we just checked that the number\n-                        // of bytes is within the buffer capacity.\n+            let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+\n+            if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n+                match reader.read_buf(&mut read_buf) {\n+                    //Ok(0) => return Ok(len), // EOF reached\n+                    Ok(()) => {\n+                        let bytes_read = read_buf.filled_len();\n+\n+                        if bytes_read == 0 {\n+                            return Ok(len);\n+                        }\n+\n+                        // SAFETY: ReadBuf guarantees all of its filled bytes are init\n                         unsafe { buf.set_len(buf.len() + bytes_read) };\n                         len += bytes_read as u64;\n                         // Read again if the buffer still has enough capacity, as BufWriter itself would do\n@@ -129,28 +119,26 @@ fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n     reader: &mut R,\n     writer: &mut W,\n ) -> Result<u64> {\n-    let mut buf = MaybeUninit::<[u8; DEFAULT_BUF_SIZE]>::uninit();\n-    // FIXME: #42788\n-    //\n-    //   - This creates a (mut) reference to a slice of\n-    //     _uninitialized_ integers, which is **undefined behavior**\n-    //\n-    //   - Only the standard library gets to soundly \"ignore\" this,\n-    //     based on its privileged knowledge of unstable rustc\n-    //     internals;\n-    unsafe {\n-        reader.initializer().initialize(buf.assume_init_mut());\n-    }\n+    let mut buf = [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+\n+    let mut len = 0;\n \n-    let mut written = 0;\n     loop {\n-        let len = match reader.read(unsafe { buf.assume_init_mut() }) {\n-            Ok(0) => return Ok(written),\n-            Ok(len) => len,\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+        match reader.read_buf(&mut buf) {\n+            Ok(()) => {}\n+            Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         };\n-        writer.write_all(unsafe { &buf.assume_init_ref()[..len] })?;\n-        written += len as u64;\n+\n+        if buf.filled().is_empty() {\n+            break;\n+        }\n+\n+        len += buf.filled().len() as u64;\n+        writer.write_all(buf.filled())?;\n+        buf.clear();\n     }\n+\n+    Ok(len)\n }"}, {"sha": "416cc906e65a56d0162dd13a639cb010675f8235", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -4,7 +4,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::cmp;\n-use crate::io::{self, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, SeekFrom};\n+use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n \n use core::convert::TryInto;\n \n@@ -324,6 +324,16 @@ where\n         Ok(n)\n     }\n \n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        let prev_filled = buf.filled_len();\n+\n+        Read::read_buf(&mut self.fill_buf()?, buf)?;\n+\n+        self.pos += (buf.filled_len() - prev_filled) as u64;\n+\n+        Ok(())\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let mut nread = 0;\n         for buf in bufs {\n@@ -346,11 +356,6 @@ where\n         self.pos += n as u64;\n         Ok(())\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "23201f9fc5c94deeaee0516f0fdc99bb5ea03e81", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -5,7 +5,7 @@ use crate::alloc::Allocator;\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, Error, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n+    self, BufRead, Error, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -19,6 +19,11 @@ impl<R: Read + ?Sized> Read for &mut R {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        (**self).read_buf(buf)\n+    }\n+\n     #[inline]\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         (**self).read_vectored(bufs)\n@@ -29,11 +34,6 @@ impl<R: Read + ?Sized> Read for &mut R {\n         (**self).is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        (**self).initializer()\n-    }\n-\n     #[inline]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_to_end(buf)\n@@ -123,6 +123,11 @@ impl<R: Read + ?Sized> Read for Box<R> {\n         (**self).read(buf)\n     }\n \n+    #[inline]\n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        (**self).read_buf(buf)\n+    }\n+\n     #[inline]\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         (**self).read_vectored(bufs)\n@@ -133,11 +138,6 @@ impl<R: Read + ?Sized> Read for Box<R> {\n         (**self).is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        (**self).initializer()\n-    }\n-\n     #[inline]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         (**self).read_to_end(buf)\n@@ -247,6 +247,17 @@ impl Read for &[u8] {\n         Ok(amt)\n     }\n \n+    #[inline]\n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        let amt = cmp::min(buf.remaining(), self.len());\n+        let (a, b) = self.split_at(amt);\n+\n+        buf.append(a);\n+\n+        *self = b;\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let mut nread = 0;\n@@ -265,11 +276,6 @@ impl Read for &[u8] {\n         true\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {"}, {"sha": "c1e3afd389d31db6e53a942deeb2667866c6be0a", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 103, "deletions": 133, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -256,7 +256,6 @@ use crate::convert::TryInto;\n use crate::fmt;\n use crate::mem::replace;\n use crate::ops::{Deref, DerefMut};\n-use crate::ptr;\n use crate::slice;\n use crate::str;\n use crate::sys;\n@@ -288,12 +287,16 @@ pub use self::stdio::{_eprint, _print};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::util::{empty, repeat, sink, Empty, Repeat, Sink};\n \n+#[unstable(feature = \"read_buf\", issue = \"78485\")]\n+pub use self::readbuf::ReadBuf;\n+\n mod buffered;\n pub(crate) mod copy;\n mod cursor;\n mod error;\n mod impls;\n pub mod prelude;\n+mod readbuf;\n mod stdio;\n mod util;\n \n@@ -359,68 +362,39 @@ where\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    let start_len = buf.len();\n-    let start_cap = buf.capacity();\n-    let mut g = Guard { len: buf.len(), buf };\n+    let initial_len = buf.len(); // need to know so we can return how many bytes we read\n+\n+    let mut initialized = 0; // Extra initalized bytes from previous loop iteration\n     loop {\n-        // If we've read all the way up to the capacity, reserve more space.\n-        if g.len == g.buf.capacity() {\n-            g.buf.reserve(32);\n+        if buf.len() == buf.capacity() {\n+            buf.reserve(32); // buf is full, need more space\n         }\n \n-        // Initialize any excess capacity and adjust the length so we can write\n-        // to it.\n-        if g.buf.len() < g.buf.capacity() {\n-            unsafe {\n-                // FIXME(danielhenrymantilla): #42788\n-                //\n-                //   - This creates a (mut) reference to a slice of\n-                //     _uninitialized_ integers, which is **undefined behavior**\n-                //\n-                //   - Only the standard library gets to soundly \"ignore\" this,\n-                //     based on its privileged knowledge of unstable rustc\n-                //     internals;\n-                let capacity = g.buf.capacity();\n-                g.buf.set_len(capacity);\n-                r.initializer().initialize(&mut g.buf[g.len..]);\n-            }\n+        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+        unsafe {\n+            // add back extra initalized bytes, we don't want to reinitalize initalized bytes\n+            read_buf.assume_init(initialized);\n         }\n \n-        let buf = &mut g.buf[g.len..];\n-        match r.read(buf) {\n-            Ok(0) => return Ok(g.len - start_len),\n-            Ok(n) => {\n-                // We can't allow bogus values from read. If it is too large, the returned vec could have its length\n-                // set past its capacity, or if it overflows the vec could be shortened which could create an invalid\n-                // string if this is called via read_to_string.\n-                assert!(n <= buf.len());\n-                g.len += n;\n-            }\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+        match r.read_buf(&mut read_buf) {\n+            Ok(()) => {}\n+            Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         }\n \n-        if g.len == g.buf.capacity() && g.buf.capacity() == start_cap {\n-            // The buffer might be an exact fit. Let's read into a probe buffer\n-            // and see if it returns `Ok(0)`. If so, we've avoided an\n-            // unnecessary doubling of the capacity. But if not, append the\n-            // probe buffer to the primary buffer and let its capacity grow.\n-            let mut probe = [0u8; 32];\n-\n-            loop {\n-                match r.read(&mut probe) {\n-                    Ok(0) => return Ok(g.len - start_len),\n-                    Ok(n) => {\n-                        g.buf.extend_from_slice(&probe[..n]);\n-                        g.len += n;\n-                        break;\n-                    }\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-                    Err(e) => return Err(e),\n-                }\n-            }\n+        if read_buf.filled_len() == 0 {\n+            break;\n+        }\n+\n+        // store how much was initialized but not filled\n+        initialized = read_buf.initialized_len() - read_buf.filled_len();\n+        let new_len = read_buf.filled_len() + buf.len();\n+        unsafe {\n+            buf.set_len(new_len);\n         }\n     }\n+\n+    Ok(buf.len() - initial_len)\n }\n \n pub(crate) fn default_read_to_string<R: Read + ?Sized>(\n@@ -656,31 +630,6 @@ pub trait Read {\n         false\n     }\n \n-    /// Determines if this `Read`er can work with buffers of uninitialized\n-    /// memory.\n-    ///\n-    /// The default implementation returns an initializer which will zero\n-    /// buffers.\n-    ///\n-    /// If a `Read`er guarantees that it can work properly with uninitialized\n-    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n-    /// [`Initializer`] for details.\n-    ///\n-    /// The behavior of this method must be independent of the state of the\n-    /// `Read`er - the method only takes `&self` so that it can be used through\n-    /// trait objects.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method is unsafe because a `Read`er could otherwise return a\n-    /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n-    /// block.\n-    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::zeroing()\n-    }\n-\n     /// Read all bytes until EOF in this source, placing them into `buf`.\n     ///\n     /// All bytes read from this source will be appended to the specified buffer\n@@ -830,7 +779,42 @@ pub trait Read {\n         default_read_exact(self, buf)\n     }\n \n-    /// Creates a \"by reference\" adapter for this instance of `Read`.\n+    /// Pull some bytes from this source into the specified buffer.\n+    ///\n+    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to allow use\n+    /// with uninitialized buffers. The new data will be appended to any existing contents of `buf`.\n+    ///\n+    /// The default implementation delegates to `read`.\n+    #[unstable(feature = \"read_buf\", issue = \"78485\")]\n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+        let n = self.read(buf.initialize_unfilled())?;\n+        buf.add_filled(n);\n+        Ok(())\n+    }\n+\n+    /// Read the exact number of bytes required to fill `buf`.\n+    ///\n+    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to\n+    /// allow use with uninitialized buffers.\n+    #[unstable(feature = \"read_buf\", issue = \"78485\")]\n+    fn read_buf_exact(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+        while buf.remaining() > 0 {\n+            let prev_filled = buf.filled().len();\n+            match self.read_buf(buf) {\n+                Ok(()) => {}\n+                Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n+                Err(e) => return Err(e),\n+            }\n+\n+            if buf.filled().len() == prev_filled {\n+                return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill buffer\"));\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n     ///\n     /// The returned adapter also implements `Read` and will simply borrow this\n     /// current reader.\n@@ -1300,53 +1284,6 @@ impl<'a> Deref for IoSlice<'a> {\n     }\n }\n \n-/// A type used to conditionally initialize buffers passed to `Read` methods.\n-#[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-#[derive(Debug)]\n-pub struct Initializer(bool);\n-\n-impl Initializer {\n-    /// Returns a new `Initializer` which will zero out buffers.\n-    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-    #[must_use]\n-    #[inline]\n-    pub fn zeroing() -> Initializer {\n-        Initializer(true)\n-    }\n-\n-    /// Returns a new `Initializer` which will not zero out buffers.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This may only be called by `Read`ers which guarantee that they will not\n-    /// read from buffers passed to `Read` methods, and that the return value of\n-    /// the method accurately reflects the number of bytes that have been\n-    /// written to the head of the buffer.\n-    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-    #[must_use]\n-    #[inline]\n-    pub unsafe fn nop() -> Initializer {\n-        Initializer(false)\n-    }\n-\n-    /// Indicates if a buffer should be initialized.\n-    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-    #[must_use]\n-    #[inline]\n-    pub fn should_initialize(&self) -> bool {\n-        self.0\n-    }\n-\n-    /// Initializes a buffer if necessary.\n-    #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n-    #[inline]\n-    pub fn initialize(&self, buf: &mut [u8]) {\n-        if self.should_initialize() {\n-            unsafe { ptr::write_bytes(buf.as_mut_ptr(), 0, buf.len()) }\n-        }\n-    }\n-}\n-\n /// A trait for objects which are byte-oriented sinks.\n ///\n /// Implementors of the `Write` trait are sometimes called 'writers'.\n@@ -2403,11 +2340,6 @@ impl<T: Read, U: Read> Read for Chain<T, U> {\n         }\n         self.second.read_vectored(bufs)\n     }\n-\n-    unsafe fn initializer(&self) -> Initializer {\n-        let initializer = self.first.initializer();\n-        if initializer.should_initialize() { initializer } else { self.second.initializer() }\n-    }\n }\n \n #[stable(feature = \"chain_bufread\", since = \"1.9.0\")]\n@@ -2610,8 +2542,46 @@ impl<T: Read> Read for Take<T> {\n         Ok(n)\n     }\n \n-    unsafe fn initializer(&self) -> Initializer {\n-        self.inner.initializer()\n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+        // Don't call into inner reader at all at EOF because it may still block\n+        if self.limit == 0 {\n+            return Ok(());\n+        }\n+\n+        let prev_filled = buf.filled_len();\n+\n+        if self.limit <= buf.remaining() as u64 {\n+            let extra_init = buf.initialized_len() - buf.filled_len();\n+            let ibuf = unsafe { &mut buf.unfilled_mut()[..self.limit as usize] };\n+\n+            let mut sliced_buf = ReadBuf::uninit(ibuf);\n+\n+            unsafe {\n+                sliced_buf.assume_init(extra_init);\n+            }\n+\n+            self.inner.read_buf(&mut sliced_buf)?;\n+\n+            let new_init = sliced_buf.initialized_len();\n+            let filled = sliced_buf.filled_len();\n+\n+            // sliced_buf / ibuf must drop here\n+\n+            unsafe {\n+                buf.assume_init(new_init);\n+            }\n+\n+            buf.add_filled(filled);\n+\n+            self.limit -= filled as u64;\n+        } else {\n+            self.inner.read_buf(buf)?;\n+\n+            //inner may unfill\n+            self.limit -= buf.filled_len().saturating_sub(prev_filled) as u64;\n+        }\n+\n+        Ok(())\n     }\n }\n "}, {"sha": "76698d6c5bce97bacad1101e884c98d7408c8ce9", "filename": "library/std/src/io/readbuf.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -0,0 +1,245 @@\n+#![unstable(feature = \"read_buf\", issue = \"78485\")]\n+\n+#[cfg(test)]\n+mod tests;\n+\n+use crate::cmp;\n+use crate::fmt::{self, Debug, Formatter};\n+use crate::mem::MaybeUninit;\n+\n+/// A wrapper around a byte buffer that is incrementally filled and initialized.\n+///\n+/// This type is a sort of \"double cursor\". It tracks three regions in the buffer: a region at the beginning of the\n+/// buffer that has been logically filled with data, a region that has been initialized at some point but not yet\n+/// logically filled, and a region at the end that is fully uninitialized. The filled region is guaranteed to be a\n+/// subset of the initialized region.\n+///\n+/// In summary, the contents of the buffer can be visualized as:\n+/// ```not_rust\n+/// [             capacity              ]\n+/// [ filled |         unfilled         ]\n+/// [    initialized    | uninitialized ]\n+/// ```\n+pub struct ReadBuf<'a> {\n+    buf: &'a mut [MaybeUninit<u8>],\n+    filled: usize,\n+    initialized: usize,\n+}\n+\n+impl Debug for ReadBuf<'_> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ReadBuf\")\n+            .field(\"init\", &self.initialized())\n+            .field(\"filled\", &self.filled)\n+            .field(\"capacity\", &self.capacity())\n+            .finish()\n+    }\n+}\n+\n+impl<'a> ReadBuf<'a> {\n+    /// Creates a new `ReadBuf` from a fully initialized buffer.\n+    #[inline]\n+    pub fn new(buf: &'a mut [u8]) -> ReadBuf<'a> {\n+        let len = buf.len();\n+\n+        ReadBuf {\n+            //SAFETY: inintialized data never becoming uninitialized is an invariant of ReadBuf\n+            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },\n+            filled: 0,\n+            initialized: len,\n+        }\n+    }\n+\n+    /// Creates a new `ReadBuf` from a fully uninitialized buffer.\n+    ///\n+    /// Use `assume_init` if part of the buffer is known to be already inintialized.\n+    #[inline]\n+    pub fn uninit(buf: &'a mut [MaybeUninit<u8>]) -> ReadBuf<'a> {\n+        ReadBuf { buf, filled: 0, initialized: 0 }\n+    }\n+\n+    /// Returns the total capacity of the buffer.\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.buf.len()\n+    }\n+\n+    /// Returns a shared reference to the filled portion of the buffer.\n+    #[inline]\n+    pub fn filled(&self) -> &[u8] {\n+        //SAFETY: We only slice the filled part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.filled]) }\n+    }\n+\n+    /// Returns a mutable reference to the filled portion of the buffer.\n+    #[inline]\n+    pub fn filled_mut(&mut self) -> &mut [u8] {\n+        //SAFETY: We only slice the filled part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.filled]) }\n+    }\n+\n+    /// Returns a shared reference to the initialized portion of the buffer.\n+    ///\n+    /// This includes the filled portion.\n+    #[inline]\n+    pub fn initialized(&self) -> &[u8] {\n+        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.initialized]) }\n+    }\n+\n+    /// Returns a mutable reference to the initialized portion of the buffer.\n+    ///\n+    /// This includes the filled portion.\n+    #[inline]\n+    pub fn initialized_mut(&mut self) -> &mut [u8] {\n+        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.initialized]) }\n+    }\n+\n+    /// Returns a mutable reference to the unfilled part of the buffer without ensuring that it has been fully\n+    /// initialized.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must not de-initialize portions of the buffer that have already been initialized.\n+    #[inline]\n+    pub unsafe fn unfilled_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf[self.filled..]\n+    }\n+\n+    /// Returns a mutable reference to the uninitialized part of the buffer.\n+    ///\n+    /// It is safe to uninitialize any of these bytes.\n+    #[inline]\n+    pub fn uninitialized_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf[self.initialized..]\n+    }\n+\n+    /// Returns a mutable reference to the unfilled part of the buffer, ensuring it is fully initialized.\n+    ///\n+    /// Since `ReadBuf` tracks the region of the buffer that has been initialized, this is effectively \"free\" after\n+    /// the first use.\n+    #[inline]\n+    pub fn initialize_unfilled(&mut self) -> &mut [u8] {\n+        // should optimize out the assertion\n+        self.initialize_unfilled_to(self.remaining())\n+    }\n+\n+    /// Returns a mutable reference to the first `n` bytes of the unfilled part of the buffer, ensuring it is\n+    /// fully initialized.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `self.remaining()` is less than `n`.\n+    #[inline]\n+    pub fn initialize_unfilled_to(&mut self, n: usize) -> &mut [u8] {\n+        assert!(self.remaining() >= n);\n+\n+        //dont try to do any zeroing if we already have enough initialized\n+        if n > (self.initialized - self.filled) {\n+            let uninit = (n + self.filled) - self.initialized;\n+\n+            let unfilled = &mut self.uninitialized_mut()[0..uninit];\n+\n+            for byte in unfilled.iter_mut() {\n+                byte.write(0);\n+            }\n+\n+            // SAFETY: we just inintialized uninit bytes, and the previous bytes were already init\n+            unsafe {\n+                self.assume_init(n);\n+            }\n+        }\n+\n+        let filled = self.filled;\n+\n+        &mut self.initialized_mut()[filled..filled + n]\n+    }\n+\n+    /// Returns the number of bytes at the end of the slice that have not yet been filled.\n+    #[inline]\n+    pub fn remaining(&self) -> usize {\n+        self.capacity() - self.filled\n+    }\n+\n+    /// Clears the buffer, resetting the filled region to empty.\n+    ///\n+    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.set_filled(0); // The assertion in `set_filled` is optimized out\n+    }\n+\n+    /// Increases the size of the filled region of the buffer.\n+    ///\n+    /// The number of initialized bytes is not changed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    #[inline]\n+    pub fn add_filled(&mut self, n: usize) {\n+        self.set_filled(self.filled + n);\n+    }\n+\n+    /// Sets the size of the filled region of the buffer.\n+    ///\n+    /// The number of initialized bytes is not changed.\n+    ///\n+    /// Note that this can be used to *shrink* the filled region of the buffer in addition to growing it (for\n+    /// example, by a `Read` implementation that compresses data in-place).\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    #[inline]\n+    pub fn set_filled(&mut self, n: usize) {\n+        assert!(n <= self.initialized);\n+\n+        self.filled = n;\n+    }\n+\n+    /// Asserts that the first `n` unfilled bytes of the buffer are initialized.\n+    ///\n+    /// `ReadBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n+    /// bytes than are already known to be initialized.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n+    #[inline]\n+    pub unsafe fn assume_init(&mut self, n: usize) {\n+        self.initialized = cmp::max(self.initialized, self.filled + n);\n+    }\n+\n+    /// Appends data to the buffer, advancing the written position and possibly also the initialized position.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `self.remaining()` is less than `buf.len()`.\n+    #[inline]\n+    pub fn append(&mut self, buf: &[u8]) {\n+        assert!(self.remaining() >= buf.len());\n+\n+        // SAFETY: we do not de-initialize any of the elements of the slice\n+        unsafe {\n+            MaybeUninit::write_slice(&mut self.unfilled_mut()[..buf.len()], buf);\n+        }\n+\n+        // SAFETY: We just added the entire contents of buf to the filled section.\n+        unsafe { self.assume_init(buf.len()) }\n+        self.add_filled(buf.len());\n+    }\n+\n+    /// Returns the amount of bytes that have been filled.\n+    #[inline]\n+    pub fn filled_len(&self) -> usize {\n+        self.filled\n+    }\n+\n+    /// Returns the amount of bytes that have been initialized.\n+    #[inline]\n+    pub fn initialized_len(&self) -> usize {\n+        self.initialized\n+    }\n+}"}, {"sha": "ef5fe798f4c2f8bc6bb68818fa50437b2574082b", "filename": "library/std/src/io/readbuf/tests.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -0,0 +1,169 @@\n+use super::ReadBuf;\n+use crate::mem::MaybeUninit;\n+\n+/// Test that ReadBuf has the correct numbers when created with new\n+#[test]\n+fn new() {\n+    let mut buf = [0; 16];\n+    let rbuf = ReadBuf::new(&mut buf);\n+\n+    assert_eq!(rbuf.filled_len(), 0);\n+    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.capacity(), 16);\n+    assert_eq!(rbuf.remaining(), 16);\n+}\n+\n+/// Test that ReadBuf has the correct numbers when created with uninit\n+#[test]\n+fn uninit() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let rbuf = ReadBuf::uninit(&mut buf);\n+\n+    assert_eq!(rbuf.filled_len(), 0);\n+    assert_eq!(rbuf.initialized_len(), 0);\n+    assert_eq!(rbuf.capacity(), 16);\n+    assert_eq!(rbuf.remaining(), 16);\n+}\n+\n+#[test]\n+fn initialize_unfilled() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    rbuf.initialize_unfilled();\n+\n+    assert_eq!(rbuf.initialized_len(), 16);\n+}\n+\n+#[test]\n+fn initialize_unfilled_to() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    rbuf.initialize_unfilled_to(8);\n+\n+    assert_eq!(rbuf.initialized_len(), 8);\n+\n+    rbuf.initialize_unfilled_to(4);\n+\n+    assert_eq!(rbuf.initialized_len(), 8);\n+\n+    rbuf.set_filled(8);\n+\n+    rbuf.initialize_unfilled_to(6);\n+\n+    assert_eq!(rbuf.initialized_len(), 14);\n+\n+    rbuf.initialize_unfilled_to(8);\n+\n+    assert_eq!(rbuf.initialized_len(), 16);\n+}\n+\n+#[test]\n+fn add_filled() {\n+    let mut buf = [0; 16];\n+    let mut rbuf = ReadBuf::new(&mut buf);\n+\n+    rbuf.add_filled(1);\n+\n+    assert_eq!(rbuf.filled_len(), 1);\n+    assert_eq!(rbuf.remaining(), 15);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn add_filled_panic() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    rbuf.add_filled(1);\n+}\n+\n+#[test]\n+fn set_filled() {\n+    let mut buf = [0; 16];\n+    let mut rbuf = ReadBuf::new(&mut buf);\n+\n+    rbuf.set_filled(16);\n+\n+    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.remaining(), 0);\n+\n+    rbuf.set_filled(6);\n+\n+    assert_eq!(rbuf.filled_len(), 6);\n+    assert_eq!(rbuf.remaining(), 10);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn set_filled_panic() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    rbuf.set_filled(16);\n+}\n+\n+#[test]\n+fn clear() {\n+    let mut buf = [255; 16];\n+    let mut rbuf = ReadBuf::new(&mut buf);\n+\n+    rbuf.set_filled(16);\n+\n+    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.remaining(), 0);\n+\n+    rbuf.clear();\n+\n+    assert_eq!(rbuf.filled_len(), 0);\n+    assert_eq!(rbuf.remaining(), 16);\n+\n+    assert_eq!(rbuf.initialized(), [255; 16]);\n+}\n+\n+#[test]\n+fn assume_init() {\n+    let mut buf = [MaybeUninit::uninit(); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    unsafe {\n+        rbuf.assume_init(8);\n+    }\n+\n+    assert_eq!(rbuf.initialized_len(), 8);\n+\n+    rbuf.add_filled(4);\n+\n+    unsafe {\n+        rbuf.assume_init(2);\n+    }\n+\n+    assert_eq!(rbuf.initialized_len(), 8);\n+\n+    unsafe {\n+        rbuf.assume_init(8);\n+    }\n+\n+    assert_eq!(rbuf.initialized_len(), 12);\n+}\n+\n+#[test]\n+fn append() {\n+    let mut buf = [MaybeUninit::new(255); 16];\n+    let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+    rbuf.append(&[0; 8]);\n+\n+    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.filled_len(), 8);\n+    assert_eq!(rbuf.filled(), [0; 8]);\n+\n+    rbuf.clear();\n+\n+    rbuf.append(&[1; 16]);\n+\n+    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.filled(), [1; 16]);\n+}"}, {"sha": "9888d3a09c48d76d9d94776d72c64b9e2e3f94c0", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -7,7 +7,7 @@ use crate::io::prelude::*;\n \n use crate::cell::{Cell, RefCell};\n use crate::fmt;\n-use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter, Lines, Split};\n+use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines, Split};\n use crate::lazy::SyncOnceCell;\n use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n@@ -108,11 +108,6 @@ impl Read for StdinRaw {\n         self.0.is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         handle_ebadf(self.0.read_to_end(buf), 0)\n     }\n@@ -514,10 +509,6 @@ impl Read for Stdin {\n     fn is_read_vectored(&self) -> bool {\n         self.lock().is_read_vectored()\n     }\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         self.lock().read_to_end(buf)\n     }\n@@ -552,11 +543,6 @@ impl Read for StdinLock<'_> {\n         self.inner.is_read_vectored()\n     }\n \n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n         self.inner.read_to_end(buf)\n     }"}, {"sha": "ea49bfe3421d1beb6a83f64b211c947c67536887", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -1,7 +1,8 @@\n-use super::{repeat, Cursor, SeekFrom};\n+use super::{repeat, Cursor, ReadBuf, SeekFrom};\n use crate::cmp::{self, min};\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::io::{BufRead, BufReader, Read, Seek, Write};\n+use crate::mem::MaybeUninit;\n use crate::ops::Deref;\n \n #[test]\n@@ -156,6 +157,28 @@ fn read_exact_slice() {\n     assert_eq!(c, b\"9\");\n }\n \n+#[test]\n+fn read_buf_exact() {\n+    let mut buf = [0; 4];\n+    let mut buf = ReadBuf::new(&mut buf);\n+\n+    let mut c = Cursor::new(&b\"\"[..]);\n+    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+\n+    let mut c = Cursor::new(&b\"123456789\"[..]);\n+    c.read_buf_exact(&mut buf).unwrap();\n+    assert_eq!(buf.filled(), b\"1234\");\n+\n+    buf.clear();\n+\n+    c.read_buf_exact(&mut buf).unwrap();\n+    assert_eq!(buf.filled(), b\"5678\");\n+\n+    buf.clear();\n+\n+    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+}\n+\n #[test]\n fn take_eof() {\n     struct R;\n@@ -559,3 +582,23 @@ fn test_write_all_vectored() {\n         }\n     }\n }\n+\n+#[bench]\n+fn bench_take_read(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        let mut buf = [0; 64];\n+\n+        [255; 128].take(64).read(&mut buf).unwrap();\n+    });\n+}\n+\n+#[bench]\n+fn bench_take_read_buf(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        let mut buf = [MaybeUninit::uninit(); 64];\n+\n+        let mut rbuf = ReadBuf::uninit(&mut buf);\n+\n+        [255; 128].take(64).read_buf(&mut rbuf).unwrap();\n+    });\n+}"}, {"sha": "0d4fd5fedf73404ba20e62df3074d48d69053f8f", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -5,7 +5,7 @@ mod tests;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n+    self, BufRead, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, Write,\n };\n \n /// A reader which is always at EOF.\n@@ -47,8 +47,8 @@ impl Read for Empty {\n     }\n \n     #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n+    fn read_buf(&mut self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        Ok(())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -130,6 +130,22 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n+    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+        for slot in unsafe { buf.unfilled_mut() } {\n+            slot.write(self.byte);\n+        }\n+\n+        let remaining = buf.remaining();\n+\n+        unsafe {\n+            buf.assume_init(remaining);\n+        }\n+\n+        buf.add_filled(remaining);\n+\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let mut nwritten = 0;\n@@ -143,11 +159,6 @@ impl Read for Repeat {\n     fn is_read_vectored(&self) -> bool {\n         true\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n }\n \n impl SizeHint for Repeat {"}, {"sha": "08972a59a833fbb070c004265be161b33767ad56", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -1,9 +1,12 @@\n use crate::cmp::{max, min};\n use crate::io::prelude::*;\n use crate::io::{\n-    copy, empty, repeat, sink, BufWriter, Empty, Repeat, Result, SeekFrom, Sink, DEFAULT_BUF_SIZE,\n+    copy, empty, repeat, sink, BufWriter, Empty, ReadBuf, Repeat, Result, SeekFrom, Sink,\n+    DEFAULT_BUF_SIZE,\n };\n \n+use crate::mem::MaybeUninit;\n+\n #[test]\n fn copy_copies() {\n     let mut r = repeat(0).take(4);\n@@ -75,6 +78,30 @@ fn empty_reads() {\n     assert_eq!(e.read(&mut [0]).unwrap(), 0);\n     assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n     assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n+\n+    let mut buf = [];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+    e.read_buf(&mut buf).unwrap();\n+    assert_eq!(buf.filled_len(), 0);\n+    assert_eq!(buf.initialized_len(), 0);\n+\n+    let mut buf = [MaybeUninit::uninit()];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+    e.read_buf(&mut buf).unwrap();\n+    assert_eq!(buf.filled_len(), 0);\n+    assert_eq!(buf.initialized_len(), 0);\n+\n+    let mut buf = [MaybeUninit::uninit(); 1024];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+    e.read_buf(&mut buf).unwrap();\n+    assert_eq!(buf.filled_len(), 0);\n+    assert_eq!(buf.initialized_len(), 0);\n+\n+    let mut buf = [MaybeUninit::uninit(); 1024];\n+    let mut buf = ReadBuf::uninit(&mut buf);\n+    e.by_ref().read_buf(&mut buf).unwrap();\n+    assert_eq!(buf.filled_len(), 0);\n+    assert_eq!(buf.initialized_len(), 0);\n }\n \n #[test]"}, {"sha": "dd55ba573174019b8acfa7a55455848168412952", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -306,6 +306,7 @@\n #![feature(maybe_uninit_extra)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n+#![feature(maybe_uninit_write_slice)]\n #![feature(min_specialization)]\n #![feature(mixed_integer_ops)]\n #![feature(must_not_suspend)]\n@@ -321,6 +322,7 @@\n #![feature(panic_unwind)]\n #![feature(pin_static_ref)]\n #![feature(prelude_import)]\n+#![feature(ptr_as_uninit)]\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]"}, {"sha": "1ba54d892e3ce4eabd2b89997528ac9a215dee50", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -6,7 +6,7 @@ mod tests;\n use crate::io::prelude::*;\n \n use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut};\n use crate::net::{Shutdown, SocketAddr, ToSocketAddrs};\n use crate::sys_common::net as net_imp;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -626,12 +626,6 @@ impl Read for TcpStream {\n     fn is_read_vectored(&self) -> bool {\n         self.0.is_read_vectored()\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n@@ -666,12 +660,6 @@ impl Read for &TcpStream {\n     fn is_read_vectored(&self) -> bool {\n         self.0.is_read_vectored()\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for &TcpStream {"}, {"sha": "583f861a92535c809946c664a10403c64a63edc4", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -11,7 +11,7 @@\n use super::{recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to, SocketAncillary};\n use super::{sockaddr_un, SocketAddr};\n use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut};\n use crate::net::Shutdown;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n #[cfg(any(\n@@ -624,11 +624,6 @@ impl io::Read for UnixStream {\n     fn is_read_vectored(&self) -> bool {\n         io::Read::is_read_vectored(&&*self)\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -645,11 +640,6 @@ impl<'a> io::Read for &'a UnixStream {\n     fn is_read_vectored(&self) -> bool {\n         self.0.is_read_vectored()\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]"}, {"sha": "2e51d28b104d40f5f91ecc594d00eab35684858b", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -109,7 +109,7 @@ use crate::io::prelude::*;\n use crate::ffi::OsStr;\n use crate::fmt;\n use crate::fs;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::io::{self, IoSlice, IoSliceMut};\n use crate::num::NonZeroI32;\n use crate::path::Path;\n use crate::str;\n@@ -361,12 +361,6 @@ impl Read for ChildStdout {\n     fn is_read_vectored(&self) -> bool {\n         self.inner.is_read_vectored()\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n }\n \n impl AsInner<AnonPipe> for ChildStdout {\n@@ -428,12 +422,6 @@ impl Read for ChildStderr {\n     fn is_read_vectored(&self) -> bool {\n         self.inner.is_read_vectored()\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        // SAFETY: Read is guaranteed to work on uninitialized memory\n-        unsafe { Initializer::nop() }\n-    }\n }\n \n impl AsInner<AnonPipe> for ChildStderr {"}, {"sha": "a05e8f6c3db3c9783ac23fe308aef013c218a495", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c6200b1615e6a40fd63984f81bd55d589b42a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=98c6200b1615e6a40fd63984f81bd55d589b42a5", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n+use crate::io::{self, IoSlice, IoSliceMut, Read};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -289,11 +289,6 @@ impl<'a> Read for &'a FileDesc {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         (**self).read(buf)\n     }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n }\n \n impl AsInner<OwnedFd> for FileDesc {"}]}