{"sha": "f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NWJiNTVhMWM0Y2IyNThhYzhlNmFkZGU5OWNmMWFhZGM1ZDc3NmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-25T12:20:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:34:38Z"}, "message": "Move the scalar types out of static data so that we can put `Rc` into sty.", "tree": {"sha": "1d51732773bc60cfb8eadce4e51d3aecaf0714d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d51732773bc60cfb8eadce4e51d3aecaf0714d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "html_url": "https://github.com/rust-lang/rust/commit/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/771dd54ea6c09ac32093a46a0d9ed80502ce3b02", "html_url": "https://github.com/rust-lang/rust/commit/771dd54ea6c09ac32093a46a0d9ed80502ce3b02"}], "stats": {"total": 855, "additions": 464, "deletions": 391}, "files": [{"sha": "01cde5138c533493333e53be63ab5d7e0fefb35d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -384,39 +384,40 @@ fn parse_trait_ref<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n }\n \n fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n+    let tcx = st.tcx;\n     match next(st) {\n-      'b' => return ty::mk_bool(),\n-      'i' => return ty::mk_int(),\n-      'u' => return ty::mk_uint(),\n+      'b' => return tcx.types.bool,\n+      'i' => return tcx.types.int,\n+      'u' => return tcx.types.uint,\n       'M' => {\n         match next(st) {\n-          'b' => return ty::mk_mach_uint(ast::TyU8),\n-          'w' => return ty::mk_mach_uint(ast::TyU16),\n-          'l' => return ty::mk_mach_uint(ast::TyU32),\n-          'd' => return ty::mk_mach_uint(ast::TyU64),\n-          'B' => return ty::mk_mach_int(ast::TyI8),\n-          'W' => return ty::mk_mach_int(ast::TyI16),\n-          'L' => return ty::mk_mach_int(ast::TyI32),\n-          'D' => return ty::mk_mach_int(ast::TyI64),\n-          'f' => return ty::mk_mach_float(ast::TyF32),\n-          'F' => return ty::mk_mach_float(ast::TyF64),\n+          'b' => return tcx.types.u8,\n+          'w' => return tcx.types.u16,\n+          'l' => return tcx.types.u32,\n+          'd' => return tcx.types.u64,\n+          'B' => return tcx.types.i8,\n+          'W' => return tcx.types.i16,\n+          'L' => return tcx.types.i32,\n+          'D' => return tcx.types.i64,\n+          'f' => return tcx.types.f32,\n+          'F' => return tcx.types.f64,\n           _ => panic!(\"parse_ty: bad numeric type\")\n         }\n       }\n-      'c' => return ty::mk_char(),\n+      'c' => return tcx.types.char,\n       't' => {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_enum(st.tcx, def, st.tcx.mk_substs(substs));\n+        return ty::mk_enum(tcx, def, st.tcx.mk_substs(substs));\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n         let trait_ref = ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, trait_ref, bounds);\n+        return ty::mk_trait(tcx, trait_ref, bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n@@ -425,41 +426,41 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        return ty::mk_param(st.tcx, space, index, did);\n+        return ty::mk_param(tcx, space, index, did);\n       }\n-      '~' => return ty::mk_uniq(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n-      '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '~' => return ty::mk_uniq(tcx, parse_ty(st, |x,y| conv(x,y))),\n+      '*' => return ty::mk_ptr(tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {\n         let r = parse_region(st, |x,y| conv(x,y));\n         let mt = parse_mt(st, |x,y| conv(x,y));\n-        return ty::mk_rptr(st.tcx, st.tcx.mk_region(r), mt);\n+        return ty::mk_rptr(tcx, tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty(st, |x,y| conv(x,y));\n         let sz = parse_size(st);\n-        return ty::mk_vec(st.tcx, t, sz);\n+        return ty::mk_vec(tcx, t, sz);\n       }\n       'v' => {\n-        return ty::mk_str(st.tcx);\n+        return ty::mk_str(tcx);\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n         let mut params = Vec::new();\n         while peek(st) != ']' { params.push(parse_ty(st, |x,y| conv(x,y))); }\n         st.pos = st.pos + 1u;\n-        return ty::mk_tup(st.tcx, params);\n+        return ty::mk_tup(tcx, params);\n       }\n       'f' => {\n-        return ty::mk_closure(st.tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n+        return ty::mk_closure(tcx, parse_closure_ty(st, |x,y| conv(x,y)));\n       }\n       'F' => {\n           let def_id = parse_def(st, NominalType, |x,y| conv(x,y));\n-          return ty::mk_bare_fn(st.tcx, Some(def_id),\n-                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+          return ty::mk_bare_fn(tcx, Some(def_id),\n+                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       'G' => {\n-          return ty::mk_bare_fn(st.tcx, None,\n-                                st.tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n+          return ty::mk_bare_fn(tcx, None,\n+                                tcx.mk_bare_fn(parse_bare_fn_ty(st, |x,y| conv(x,y))));\n       }\n       '#' => {\n         let pos = parse_hex(st);\n@@ -470,7 +471,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n                                          pos: pos,\n                                          len: len };\n \n-        match st.tcx.rcache.borrow().get(&key).cloned() {\n+        match tcx.rcache.borrow().get(&key).cloned() {\n           Some(tt) => return tt,\n           None => {}\n         }\n@@ -479,7 +480,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n             .. *st\n         };\n         let tt = parse_ty(&mut ps, |x,y| conv(x,y));\n-        st.tcx.rcache.borrow_mut().insert(key, tt);\n+        tcx.rcache.borrow_mut().insert(key, tt);\n         return tt;\n       }\n       '\\\"' => {\n@@ -504,7 +505,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n                   st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'e' => {\n-          return ty::mk_err();\n+          return tcx.types.err;\n       }\n       c => { panic!(\"unexpected char in type string: {}\", c);}\n     }"}, {"sha": "b1b4fd831a0fa97ccc19838c485b4e2f02baffc6", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -57,23 +57,23 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                     match nty {\n                         ast::TyBool => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_bool())\n+                            Some(tcx.types.bool)\n                         }\n                         ast::TyChar => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_char())\n+                            Some(tcx.types.char)\n                         }\n                         ast::TyInt(it) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_int(it))\n+                            Some(ty::mk_mach_int(tcx, it))\n                         }\n                         ast::TyUint(uit) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_uint(uit))\n+                            Some(ty::mk_mach_uint(tcx, uit))\n                         }\n                         ast::TyFloat(ft) => {\n                             check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                            Some(ty::mk_mach_float(ft))\n+                            Some(ty::mk_mach_float(tcx, ft))\n                         }\n                         ast::TyStr => {\n                             Some(ty::mk_str(tcx))"}, {"sha": "9f5eca142c36cc82cc759cdefc526657a8975873", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -397,8 +397,8 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                                          a: Ty<'tcx>,\n                                          b: Ty<'tcx>)\n-                                         -> cres<'tcx, Ty<'tcx>> {\n-\n+                                         -> cres<'tcx, Ty<'tcx>>\n+{\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n@@ -415,7 +415,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-          Ok(ty::mk_err())\n+          Ok(tcx.types.err)\n       }\n \n         // Relate integral variables to other types\n@@ -592,8 +592,8 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n-            IntType(v) => Ok(ty::mk_mach_int(v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(v))\n+            IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n+            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v))\n         }\n     }\n \n@@ -604,7 +604,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n         val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n     {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        Ok(ty::mk_mach_float(val))\n+        Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n }\n \n@@ -763,7 +763,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ty_infer(ty::TyVar(vid)) => {\n                 if vid == self.for_vid {\n                     self.cycle_detected = true;\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 } else {\n                     match self.infcx.type_variables.borrow().probe(vid) {\n                         Some(u) => self.fold_ty(u),"}, {"sha": "2231c0088e725f5ea5121d0919770724b3db9ea9", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -324,7 +324,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         Ok(t) => t,\n         Err(ref err) => {\n             cx.report_and_explain_type_error(trace, err);\n-            ty::mk_err()\n+            cx.tcx.types.err\n         }\n     }\n }\n@@ -1058,12 +1058,12 @@ impl<'tcx> TypeTrace<'tcx> {\n         self.origin.span()\n     }\n \n-    pub fn dummy() -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(ty::expected_found {\n-                expected: ty::mk_err(),\n-                found: ty::mk_err(),\n+                expected: tcx.types.err,\n+                found: tcx.types.err,\n             })\n         }\n     }"}, {"sha": "ca2ae25e6c63a7700fa7d81cda152f9ef6f3745a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -83,15 +83,15 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             match t.sty {\n                 ty::ty_infer(ty::TyVar(vid)) => {\n                     self.err = Some(unresolved_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(ty::IntVar(vid)) => {\n                     self.err = Some(unresolved_int_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(ty::FloatVar(vid)) => {\n                     self.err = Some(unresolved_float_ty(vid));\n-                    ty::mk_err()\n+                    self.tcx().types.err\n                 }\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug("}, {"sha": "4bd3308728c10e86857b3eaf058cb8558f821388", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -146,7 +146,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n \n             (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-                Ok(ty::mk_err())\n+                Ok(self.tcx().types.err)\n             }\n \n             _ => {"}, {"sha": "3127ef5d8a5f5ba7a1bcb64ffff87052127e3881", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -225,7 +225,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n-    fn to_type(&self) -> Ty<'tcx>;\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n \n@@ -337,7 +337,7 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n         let node_a = table.borrow_mut().get(tcx, a_id);\n         match node_a.value {\n             None => None,\n-            Some(ref a_t) => Some(a_t.to_type())\n+            Some(ref a_t) => Some(a_t.to_type(tcx))\n         }\n     }\n }\n@@ -363,10 +363,10 @@ impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n-    fn to_type(&self) -> Ty<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n-            ty::IntType(i) => ty::mk_mach_int(i),\n-            ty::UintType(i) => ty::mk_mach_uint(i),\n+            ty::IntType(i) => ty::mk_mach_int(tcx, i),\n+            ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n         }\n     }\n \n@@ -399,8 +399,8 @@ impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n-    fn to_type(&self) -> Ty<'tcx> {\n-        ty::mk_mach_float(*self)\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        ty::mk_mach_float(tcx, *self)\n     }\n \n     fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {"}, {"sha": "df06b3b7789c98c779448b12f051ac3c0d4881ec", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -28,8 +28,8 @@ pub fn check_crate(tcx: &ctxt) {\n     let mut visitor = IntrinsicCheckingVisitor {\n         tcx: tcx,\n         param_envs: Vec::new(),\n-        dummy_sized_ty: ty::mk_int(),\n-        dummy_unsized_ty: ty::mk_vec(tcx, ty::mk_int(), None),\n+        dummy_sized_ty: tcx.types.int,\n+        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.int, None),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "c15001af68d96e0f78510eebdbfad67824b3f84b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -755,7 +755,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         // instead of bothering to construct a proper\n                         // one.\n                         base.mutbl = McImmutable;\n-                        base.ty = ty::mk_err();\n+                        base.ty = self.tcx().types.err;\n                         Rc::new(cmt_ {\n                             id: id,\n                             span: span,\n@@ -781,7 +781,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         is_unboxed: is_unboxed\n                     }),\n                     mutbl: McImmutable,\n-                    ty: ty::mk_err(),\n+                    ty: self.tcx().types.err,\n                     note: NoteNone\n                 };\n \n@@ -792,7 +792,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                             span: span,\n                             cat: cat_deref(Rc::new(base), 0, env_ptr),\n                             mutbl: env_mutbl,\n-                            ty: ty::mk_err(),\n+                            ty: self.tcx().types.err,\n                             note: NoteClosureEnv(upvar_id)\n                         };\n                     }\n@@ -987,7 +987,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 ty::ty_fn_args(method_ty)[0]\n             }\n             None => {\n-                match ty::array_element_ty(base_cmt.ty) {\n+                match ty::array_element_ty(self.tcx(), base_cmt.ty) {\n                     Some(ty) => ty,\n                     None => {\n                         self.tcx().sess.span_bug("}, {"sha": "a22a602ddff2501fb3cfa8c13553c96efb0e1a77", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -1100,8 +1100,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n-                            let tmp_tr = data.principal_trait_ref_with_self_ty(self.tcx(),\n-                                                                               ty::mk_err());\n+                            let tmp_tr =\n+                                data.principal_trait_ref_with_self_ty(self.tcx(),\n+                                                                      self.tcx().types.err);\n                             for tr in util::supertraits(self.tcx(), tmp_tr) {\n                                 let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n "}, {"sha": "8a0e5ea0bb314ced02e00aae56c2440db7cf1f6e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 85, "deletions": 80, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -639,6 +639,24 @@ impl<'tcx> CtxtArenas<'tcx> {\n     }\n }\n \n+pub struct CommonTypes<'tcx> {\n+    pub bool: Ty<'tcx>,\n+    pub char: Ty<'tcx>,\n+    pub int: Ty<'tcx>,\n+    pub i8: Ty<'tcx>,\n+    pub i16: Ty<'tcx>,\n+    pub i32: Ty<'tcx>,\n+    pub i64: Ty<'tcx>,\n+    pub uint: Ty<'tcx>,\n+    pub u8: Ty<'tcx>,\n+    pub u16: Ty<'tcx>,\n+    pub u32: Ty<'tcx>,\n+    pub u64: Ty<'tcx>,\n+    pub f32: Ty<'tcx>,\n+    pub f64: Ty<'tcx>,\n+    pub err: Ty<'tcx>,\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -651,11 +669,15 @@ pub struct ctxt<'tcx> {\n     // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n     // queried from a HashSet.\n     interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+\n     // FIXME as above, use a hashset if equivalent elements can be queried.\n     substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n     bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n     region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n \n+    /// Common types, pre-interned for your convenience.\n+    pub types: CommonTypes<'tcx>,\n+\n     pub sess: Session,\n     pub def_map: DefMap,\n \n@@ -1297,54 +1319,6 @@ pub enum BoundRegion {\n     BrEnv\n }\n \n-#[inline]\n-pub fn mk_prim_t<'tcx>(primitive: &'tcx TyS<'static>) -> Ty<'tcx> {\n-    // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-    unsafe { &*(primitive as *const _ as *const TyS<'tcx>) }\n-}\n-\n-// Do not change these from static to const, interning types requires\n-// the primitives to have a significant address.\n-macro_rules! def_prim_tys {\n-    ($($name:ident -> $sty:expr;)*) => (\n-        $(#[inline] pub fn $name<'tcx>() -> Ty<'tcx> {\n-            static PRIM_TY: TyS<'static> = TyS {\n-                sty: $sty,\n-                flags: NO_TYPE_FLAGS,\n-                region_depth: 0,\n-            };\n-            mk_prim_t(&PRIM_TY)\n-        })*\n-    )\n-}\n-\n-def_prim_tys!{\n-    mk_bool ->  ty_bool;\n-    mk_char ->  ty_char;\n-    mk_int ->   ty_int(ast::TyI);\n-    mk_i8 ->    ty_int(ast::TyI8);\n-    mk_i16 ->   ty_int(ast::TyI16);\n-    mk_i32 ->   ty_int(ast::TyI32);\n-    mk_i64 ->   ty_int(ast::TyI64);\n-    mk_uint ->  ty_uint(ast::TyU);\n-    mk_u8 ->    ty_uint(ast::TyU8);\n-    mk_u16 ->   ty_uint(ast::TyU16);\n-    mk_u32 ->   ty_uint(ast::TyU32);\n-    mk_u64 ->   ty_uint(ast::TyU64);\n-    mk_f32 ->   ty_float(ast::TyF32);\n-    mk_f64 ->   ty_float(ast::TyF64);\n-}\n-\n-#[inline]\n-pub fn mk_err<'tcx>() -> Ty<'tcx> {\n-    static TY_ERR: TyS<'static> = TyS {\n-        sty: ty_err,\n-        flags: HAS_TY_ERR,\n-        region_depth: 0,\n-    };\n-    mk_prim_t(&TY_ERR)\n-}\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -2102,6 +2076,31 @@ impl UnboxedClosureKind {\n     }\n }\n \n+impl<'tcx> CommonTypes<'tcx> {\n+    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n+           interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>)\n+           -> CommonTypes<'tcx>\n+    {\n+        CommonTypes {\n+            bool: intern_ty(arena, interner, ty_bool),\n+            char: intern_ty(arena, interner, ty_char),\n+            err: intern_ty(arena, interner, ty_err),\n+            int: intern_ty(arena, interner, ty_int(ast::TyI)),\n+            i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n+            i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n+            i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n+            i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n+            uint: intern_ty(arena, interner, ty_uint(ast::TyU)),\n+            u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n+            u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n+            u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n+            u64: intern_ty(arena, interner, ty_uint(ast::TyU64)),\n+            f32: intern_ty(arena, interner, ty_float(ast::TyF32)),\n+            f64: intern_ty(arena, interner, ty_float(ast::TyF64)),\n+        }\n+    }\n+}\n+\n pub fn mk_ctxt<'tcx>(s: Session,\n                      arenas: &'tcx CtxtArenas<'tcx>,\n                      dm: DefMap,\n@@ -2111,13 +2110,18 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      capture_modes: RefCell<CaptureModeMap>,\n                      region_maps: middle::region::RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n-                     stability: stability::Index) -> ctxt<'tcx> {\n+                     stability: stability::Index) -> ctxt<'tcx>\n+{\n+    let mut interner = FnvHashMap::new();\n+    let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n+\n     ctxt {\n         arenas: arenas,\n         interner: RefCell::new(FnvHashMap::new()),\n         substs_interner: RefCell::new(FnvHashMap::new()),\n         bare_fn_interner: RefCell::new(FnvHashMap::new()),\n         region_interner: RefCell::new(FnvHashMap::new()),\n+        types: common_types,\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n@@ -2212,31 +2216,32 @@ impl<'tcx> ctxt<'tcx> {\n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n pub fn mk_t<'tcx>(cx: &ctxt<'tcx>, st: sty<'tcx>) -> Ty<'tcx> {\n-    // Check for primitive types.\n-    match st {\n-        ty_err => return mk_err(),\n-        ty_bool => return mk_bool(),\n-        ty_int(i) => return mk_mach_int(i),\n-        ty_uint(u) => return mk_mach_uint(u),\n-        ty_float(f) => return mk_mach_float(f),\n-        ty_char => return mk_char(),\n-        _ => {}\n-    };\n+    let mut interner = cx.interner.borrow_mut();\n+    intern_ty(cx.type_arena, &mut *interner, st)\n+}\n \n-    match cx.interner.borrow().get(&st) {\n+fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+                   interner: &mut FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>,\n+                   st: sty<'tcx>)\n+                   -> Ty<'tcx>\n+{\n+    match interner.get(&st) {\n         Some(ty) => return *ty,\n         _ => ()\n     }\n \n     let flags = FlagComputation::for_sty(&st);\n \n-    let ty = cx.arenas.type_.alloc(TyS {\n+    let ty = type_arena.alloc(TyS {\n         sty: st,\n         flags: flags.flags,\n         region_depth: flags.depth,\n     });\n \n-    cx.interner.borrow_mut().insert(InternedTy { ty: ty }, ty);\n+    debug!(\"Interned type: {} Pointer: {}\",\n+           ty, ty as *const _);\n+\n+    interner.insert(InternedTy { ty: ty }, ty);\n \n     ty\n }\n@@ -2416,30 +2421,30 @@ impl FlagComputation {\n     }\n }\n \n-pub fn mk_mach_int<'tcx>(tm: ast::IntTy) -> Ty<'tcx> {\n+pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyI    => mk_int(),\n-        ast::TyI8   => mk_i8(),\n-        ast::TyI16  => mk_i16(),\n-        ast::TyI32  => mk_i32(),\n-        ast::TyI64  => mk_i64(),\n+        ast::TyI    => tcx.types.int,\n+        ast::TyI8   => tcx.types.i8,\n+        ast::TyI16  => tcx.types.i16,\n+        ast::TyI32  => tcx.types.i32,\n+        ast::TyI64  => tcx.types.i64,\n     }\n }\n \n-pub fn mk_mach_uint<'tcx>(tm: ast::UintTy) -> Ty<'tcx> {\n+pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyU    => mk_uint(),\n-        ast::TyU8   => mk_u8(),\n-        ast::TyU16  => mk_u16(),\n-        ast::TyU32  => mk_u32(),\n-        ast::TyU64  => mk_u64(),\n+        ast::TyU    => tcx.types.uint,\n+        ast::TyU8   => tcx.types.u8,\n+        ast::TyU16  => tcx.types.u16,\n+        ast::TyU32  => tcx.types.u32,\n+        ast::TyU64  => tcx.types.u64,\n     }\n }\n \n-pub fn mk_mach_float<'tcx>(tm: ast::FloatTy) -> Ty<'tcx> {\n+pub fn mk_mach_float<'tcx>(tcx: &ctxt<'tcx>, tm: ast::FloatTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyF32  => mk_f32(),\n-        ast::TyF64  => mk_f64(),\n+        ast::TyF32  => tcx.types.f32,\n+        ast::TyF64  => tcx.types.f64,\n     }\n }\n \n@@ -2769,7 +2774,7 @@ pub fn type_is_simd(cx: &ctxt, ty: Ty) -> bool {\n pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_vec(ty, _) => ty,\n-        ty_str => mk_mach_uint(ast::TyU8),\n+        ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n                                  ty_to_string(cx, ty))[]),\n@@ -3760,10 +3765,10 @@ pub fn index<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n // Returns the type of elements contained within an 'array-like' type.\n // This is exactly the same as the above, except it supports strings,\n // which can't actually be indexed.\n-pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.sty {\n         ty_vec(ty, _) => Some(ty),\n-        ty_str => Some(mk_u8()),\n+        ty_str => Some(tcx.types.u8),\n         _ => None\n     }\n }"}, {"sha": "6329acfb57805c5372a30eeed9dfd99199c76ada", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -28,7 +28,7 @@ use rustc_typeck::middle::infer::glb::Glb;\n use rustc_typeck::middle::infer::sub::Sub;\n use rustc_typeck::util::ppaux::{ty_to_string, Repr, UserString};\n use rustc::session::{mod,config};\n-use syntax::{abi, ast, ast_map, ast_util};\n+use syntax::{abi, ast, ast_map};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n@@ -145,6 +145,10 @@ fn test_env<F>(source_string: &str,\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n+    pub fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     pub fn create_region_hierarchy(&self, rh: &RH) {\n         for child_rh in rh.sub.iter() {\n             self.create_region_hierarchy(child_rh);\n@@ -296,7 +300,8 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n-        ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n+        let name = format!(\"T{}\", index);\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(name[]))\n     }\n \n     pub fn re_early_bound(&self,\n@@ -314,14 +319,16 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        ty::mk_int())\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n@@ -331,12 +338,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        ty::mk_int())\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -346,15 +354,19 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(r),\n+                        self.tcx().types.int)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n-        ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(ty::ReStatic), ty::mk_int())\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.infcx.tcx.mk_region(ty::ReStatic),\n+                        self.tcx().types.int)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n-        infer::TypeTrace::dummy()\n+        infer::TypeTrace::dummy(self.tcx())\n     }\n \n     pub fn sub(&self) -> Sub<'a, 'tcx> {\n@@ -480,8 +492,8 @@ fn sub_free_bound_false() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -496,8 +508,8 @@ fn sub_bound_free_true() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     })\n }\n \n@@ -512,8 +524,8 @@ fn sub_free_bound_false_infer() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], ty::mk_int()),\n-                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.int),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -531,9 +543,9 @@ fn lub_free_bound_infer() {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_infer1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     });\n }\n \n@@ -542,9 +554,9 @@ fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -553,9 +565,9 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n     })\n }\n \n@@ -564,9 +576,9 @@ fn lub_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n     })\n }\n \n@@ -587,9 +599,9 @@ fn lub_free_free() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n     })\n }\n \n@@ -612,9 +624,9 @@ fn glb_free_free_with_common_scope() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_scope], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_scope], env.tcx().types.int));\n     })\n }\n \n@@ -623,9 +635,9 @@ fn glb_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -634,9 +646,9 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -648,9 +660,9 @@ fn glb_bound_free_infer() {\n \n         // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n         // which should yield for<'b> fn(&'b int) -> int\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_infer1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_infer1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n \n         // as a side-effect, computing GLB should unify `_` with\n         // `&'_ int`\n@@ -667,9 +679,9 @@ fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n-                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n     })\n }\n \n@@ -790,7 +802,6 @@ fn escaping() {\n /// late-bound region.\n #[test]\n fn subst_region_renumber_region() {\n-\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n "}, {"sha": "0e37cd0f3b8d62cb1d275dd8d28fd48257272841", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -1122,7 +1122,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let t = if kind == Compare {\n                         left_ty\n                     } else {\n-                        ty::mk_uint() // vector length\n+                        tcx.types.uint // vector length\n                     };\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {"}, {"sha": "d01047c53b955003e2482e254e7555d98702ca50", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -163,7 +163,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n-            if dtor { ftys.push(ty::mk_bool()); }\n+            if dtor { ftys.push(cx.tcx().types.bool); }\n \n             Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n         }\n@@ -183,7 +183,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let ftys = if dtor { vec!(ty::mk_bool()) } else { vec!() };\n+                let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n                 return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n@@ -215,7 +215,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 return Univariant(mk_struct(cx, ftys[], false, t),\n                                   dtor);\n             }\n@@ -261,9 +261,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // Create the set of structs that represent each variant\n             // Use the minimum integer type we figured out above\n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(min_ity));\n+                let mut ftys = vec!(ty_of_inttype(cx.tcx(), min_ity));\n                 ftys.push_all(c.tys.as_slice());\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, ftys.as_slice(), false, t)\n             }).collect();\n \n@@ -314,9 +314,9 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(ity));\n+                let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n                 ftys.push_all(c.tys[]);\n-                if dtor { ftys.push(ty::mk_bool()); }\n+                if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, ftys[], false, t)\n             }).collect();\n \n@@ -553,11 +553,10 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-// FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-pub fn ty_of_inttype<'tcx>(ity: IntType) -> Ty<'tcx> {\n+pub fn ty_of_inttype<'tcx>(tcx: &ty::ctxt<'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n-        attr::SignedInt(t) => ty::mk_mach_int(t),\n-        attr::UnsignedInt(t) => ty::mk_mach_uint(t)\n+        attr::SignedInt(t) => ty::mk_mach_int(tcx, t),\n+        attr::UnsignedInt(t) => ty::mk_mach_uint(tcx, t)\n     }\n }\n \n@@ -995,8 +994,10 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n /// Access the struct drop flag, if present.\n pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>, val: ValueRef)\n-                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr> {\n-    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n+                                       -> datum::DatumBlock<'blk, 'tcx, datum::Expr>\n+{\n+    let tcx = bcx.tcx();\n+    let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), tcx.types.bool);\n     match *r {\n         Univariant(ref st, true) => {\n             let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n@@ -1006,7 +1007,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr<'tcx\n             let fcx = bcx.fcx;\n             let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n             let scratch = unpack_datum!(bcx, datum::lvalue_scratch_datum(\n-                bcx, ty::mk_bool(), \"drop_flag\", false,\n+                bcx, tcx.types.bool, \"drop_flag\", false,\n                 cleanup::CustomScope(custom_cleanup_scope), (), |_, bcx, _| bcx\n             ));\n             bcx = fold_variants(bcx, r, val, |variant_cx, st, value| {"}, {"sha": "e0a717d8073c9010a19e0da4dd0a99d680407c57", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -786,7 +786,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                     substs, f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, ty::mk_int());\n+                  cx = f(cx, lldiscrim_a, cx.tcx().types.int);\n                   let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n@@ -1765,7 +1765,7 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                 retptr.erase_from_parent();\n             }\n \n-            let retval = if retty == ty::FnConverging(ty::mk_bool()) {\n+            let retval = if retty == ty::FnConverging(fcx.ccx.tcx().types.bool) {\n                 Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n             } else {\n                 retval"}, {"sha": "b4deea4c72fc812a12828e9fb934b98d72eb756d", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -736,7 +736,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                         let f = base::decl_cdecl_fn(self.ccx,\n                                                     \"rust_eh_personality\",\n                                                     fty,\n-                                                    ty::mk_i32());\n+                                                    self.ccx.tcx().types.i32);\n                         *personality = Some(f);\n                         f\n                     }"}, {"sha": "ed3c820f2faf4e999d10ba3417dce30cc6f05522", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -133,8 +133,8 @@ pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n }\n \n fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n-    ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n+    let ptr = ty::mk_imm_ptr(tcx, tcx.types.i8);\n+    ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n \n fn allocate_cbox<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,"}, {"sha": "98f87b273852d2276d7774969ffec2b3674bb7d3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -2487,9 +2487,10 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let discriminant_llvm_type = adt::ll_inttype(cx, inttype);\n                 let (discriminant_size, discriminant_align) =\n                     size_and_align_of(cx, discriminant_llvm_type);\n-                let discriminant_base_type_metadata = type_metadata(cx,\n-                                                                    adt::ty_of_inttype(inttype),\n-                                                                    codemap::DUMMY_SP);\n+                let discriminant_base_type_metadata =\n+                    type_metadata(cx,\n+                                  adt::ty_of_inttype(cx.tcx(), inttype),\n+                                  codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n                 let discriminant_type_metadata = discriminant_name.get().with_c_str(|name| {\n@@ -2797,7 +2798,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"length\".to_string(),\n             llvm_type: member_llvm_types[1],\n-            type_metadata: type_metadata(cx, ty::mk_uint(), span),\n+            type_metadata: type_metadata(cx, cx.tcx().types.uint, span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n@@ -2963,7 +2964,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         // FIXME Can we do better than this for unsized vec/str fields?\n         ty::ty_vec(typ, None) => fixed_vec_metadata(cx, unique_type_id, typ, 0, usage_site_span),\n-        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, ty::mk_i8(), 0, usage_site_span),\n+        ty::ty_str => fixed_vec_metadata(cx, unique_type_id, cx.tcx().types.i8, 0, usage_site_span),\n         ty::ty_trait(..) => {\n             MetadataCreationResult::new(\n                         trait_pointer_metadata(cx, t, None, unique_type_id),\n@@ -2975,7 +2976,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_str => {\n-                    vec_slice_metadata(cx, t, ty::mk_u8(), unique_type_id, usage_site_span)\n+                    vec_slice_metadata(cx, t, cx.tcx().types.u8, unique_type_id, usage_site_span)\n                 }\n                 ty::ty_trait(..) => {\n                     MetadataCreationResult::new("}, {"sha": "ab5c670ef5a2dd03a6769f4145a61e20078f84ad", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -85,15 +85,15 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return t\n     }\n     if !type_needs_drop(tcx, t) {\n-        return ty::mk_i8();\n+        return tcx.types.i8;\n     }\n     match t.sty {\n         ty::ty_uniq(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n             let llty = sizing_type_of(ccx, typ);\n             // `Box<ZeroSizeType>` does not allocate.\n             if llsize_of_alloc(ccx, llty) == 0 {\n-                ty::mk_i8()\n+                tcx.types.i8\n             } else {\n                 t\n             }\n@@ -200,7 +200,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n-    with_cond(bcx, load_ty(bcx, drop_flag.val, ty::mk_bool()), |cx| {\n+    with_cond(bcx, load_ty(bcx, drop_flag.val, bcx.tcx().types.bool), |cx| {\n         trans_struct_drop(cx, t, v0, dtor_did, class_did, substs)\n     })\n }"}, {"sha": "0ba528ad0303d66da40781ec060736e3a009033c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -932,7 +932,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                  trait_ref, bounds[])\n                     }\n                     Err(ErrorReported) => {\n-                        ty::mk_err()\n+                        this.tcx().types.err\n                     }\n                 }\n             }\n@@ -1046,7 +1046,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                           .unwrap()\n                                                           .identifier)\n                                                   .get())[]);\n-                        ty::mk_err()\n+                        this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(typ, assoc_ident) => {\n                         // FIXME(#19541): in both branches we should consider\n@@ -1485,8 +1485,8 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n                                                         partitioned_bounds);\n \n     match main_trait_bound {\n-        None => ty::mk_err(),\n-        Some(principal) => ty::mk_trait(this.tcx(), (*principal).clone(), bounds)\n+        None => this.tcx().types.err,\n+        Some(principal) => ty::mk_trait(this.tcx(), principal, bounds)\n     }\n }\n "}, {"sha": "dc77a1e782bba7cbb989edd708009b9a0f66025c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -142,7 +142,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, ty::mk_err());\n+                check_pat(pcx, &**inner, tcx.types.err);\n             }\n         }\n         ast::PatRegion(ref inner) => {\n@@ -162,7 +162,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 check_pat(pcx, &**inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, ty::mk_err());\n+                check_pat(pcx, &**inner, tcx.types.err);\n             }\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n@@ -285,11 +285,11 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &**e, ty::mk_bool());\n+            check_expr_has_type(fcx, &**e, tcx.types.bool);\n         }\n \n         if ty::type_is_error(result_ty) || ty::type_is_error(bty) {\n-            ty::mk_err()\n+            tcx.types.err\n         } else {\n             let (origin, expected, found) = match match_src {\n                 /* if-let construct without an else block */\n@@ -339,7 +339,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n             fcx.write_error(pat.id);\n \n             for field in fields.iter() {\n-                check_pat(pcx, &*field.node.pat, ty::mk_err());\n+                check_pat(pcx, &*field.node.pat, tcx.types.err);\n             }\n             return;\n         },\n@@ -358,7 +358,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                     fcx.write_error(pat.id);\n \n                     for field in fields.iter() {\n-                        check_pat(pcx, &*field.node.pat, ty::mk_err());\n+                        check_pat(pcx, &*field.node.pat, tcx.types.err);\n                     }\n                     return;\n                 }\n@@ -430,7 +430,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n \n             if let Some(ref subpats) = *subpats {\n                 for pat in subpats.iter() {\n-                    check_pat(pcx, &**pat, ty::mk_err());\n+                    check_pat(pcx, &**pat, tcx.types.err);\n                 }\n             }\n             return;\n@@ -448,7 +448,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n             for pat in subpats.iter() {\n-                check_pat(pcx, &**pat, ty::mk_err());\n+                check_pat(pcx, &**pat, tcx.types.err);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n@@ -458,7 +458,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &ast::Pat,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n             for pat in subpats.iter() {\n-                check_pat(pcx, &**pat, ty::mk_err());\n+                check_pat(pcx, &**pat, tcx.types.err);\n             }\n         }\n     }\n@@ -496,7 +496,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 span_note!(tcx.sess, *occupied.get(),\n                     \"field `{}` previously bound here\",\n                     token::get_ident(field.ident));\n-                ty::mk_err()\n+                tcx.types.err\n             }\n             Vacant(vacant) => {\n                 vacant.set(span);\n@@ -506,7 +506,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                             \"struct `{}` does not have a field named `{}`\",\n                             ty::item_path_str(tcx, struct_id),\n                             token::get_ident(field.ident));\n-                        ty::mk_err()\n+                        tcx.types.err\n                     })\n             }\n         };"}, {"sha": "791ebc5d0ea803b311da06ca8e62bc9a546b9e02", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -342,7 +342,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n-                Vec::from_elem(num_method_types, ty::mk_err())\n+                Vec::from_elem(num_method_types, self.tcx().types.err)\n             } else {\n                 supplied_method_types\n             }\n@@ -410,7 +410,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let method_bounds_substs = match pick.kind {\n             probe::ObjectPick(..) => {\n                 let mut temp_substs = all_substs.clone();\n-                temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = ty::mk_err();\n+                temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = self.tcx().types.err;\n                 temp_substs\n             }\n             _ => {"}, {"sha": "7a6b2d54dc1679573ece4ba5e640e348227051e0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 197, "deletions": 145, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, ty::mk_uint());\n+                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n             }\n             _ => {}\n         }\n@@ -505,7 +505,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, ty::mk_uint());\n+                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.uint);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -1766,7 +1766,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_err());\n+        self.write_ty(node_id, self.tcx().types.err);\n     }\n \n     pub fn require_type_meets(&self,\n@@ -2072,7 +2072,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     span_err!(fcx.tcx().sess, sp, E0055,\n         \"reached the recursion limit while auto-dereferencing {}\",\n         base_ty.repr(fcx.tcx()));\n-    (ty::mk_err(), 0, None)\n+    (fcx.tcx().types.err, 0, None)\n }\n \n /// Attempts to resolve a call expression as an overloaded call.\n@@ -2228,6 +2228,57 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n+/// Autoderefs `base_expr`, looking for a `Slice` impl. If it finds one, installs the relevant\n+/// method info and returns the result type (else None).\n+fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                  method_call: MethodCall,\n+                                  expr: &ast::Expr,\n+                                  base_expr: &ast::Expr,\n+                                  base_ty: Ty<'tcx>,\n+                                  start_expr: &Option<P<ast::Expr>>,\n+                                  end_expr: &Option<P<ast::Expr>>,\n+                                  mutbl: ast::Mutability)\n+                                  -> Option<Ty<'tcx>> // return type is result of slice\n+{\n+    let lvalue_pref = match mutbl {\n+        ast::MutMutable => PreferMutLvalue,\n+        ast::MutImmutable => NoPreference\n+    };\n+\n+    let opt_method_ty =\n+        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n+            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n+                                      adjusted_ty, autoderefref, mutbl,\n+                                      start_expr, end_expr)\n+        });\n+\n+    // Regardless of whether the lookup succeeds, check the method arguments\n+    // so that we have *some* type for each argument.\n+    let method_ty_or_err = opt_method_ty.unwrap_or(fcx.tcx().types.err);\n+\n+    let mut args = vec![];\n+    start_expr.as_ref().map(|x| args.push(x));\n+    end_expr.as_ref().map(|x| args.push(x));\n+\n+    check_method_argument_types(fcx,\n+                                expr.span,\n+                                method_ty_or_err,\n+                                expr,\n+                                args.as_slice(),\n+                                AutorefArgs::Yes,\n+                                DontTupleArguments);\n+\n+    opt_method_ty.map(|method_ty| {\n+        let result_ty = ty::ty_fn_ret(method_ty);\n+        match result_ty {\n+            ty::FnConverging(result_ty) => result_ty,\n+            ty::FnDiverging => {\n+                fcx.tcx().sess.span_bug(expr.span,\n+                                        \"slice trait does not define a `!` return\")\n+            }\n+        }\n+    })\n+}\n \n /// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n /// installs method info and returns type of method (else None).\n@@ -2336,7 +2387,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match ty::index(adjusted_ty) {\n         Some(ty) => {\n             fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n-            return Some((ty::mk_uint(), ty));\n+            return Some((fcx.tcx().types.uint, ty));\n         }\n \n         None => { }\n@@ -2398,7 +2449,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n                                     err_string[]);\n-            return ty::mk_err()\n+            return fcx.tcx().types.err\n         }\n     };\n \n@@ -2426,7 +2477,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 maybe try .iter()\",\n                                                 ty_string)[]);\n             }\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         }\n     };\n     let return_type = check_method_argument_types(fcx,\n@@ -2447,27 +2498,27 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let return_type = match return_type {\n                 ty::FnConverging(return_type) =>\n                     structurally_resolved_type(fcx, iterator_expr.span, return_type),\n-                ty::FnDiverging => ty::mk_err()\n+                ty::FnDiverging => fcx.tcx().types.err\n             };\n             match return_type.sty {\n                 ty::ty_enum(_, ref substs)\n                         if !substs.types.is_empty_in(subst::TypeSpace) => {\n                     *substs.types.get(subst::TypeSpace, 0)\n                 }\n                 ty::ty_err => {\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n                                             format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n                                             []);\n-                    ty::mk_err()\n+                    fcx.tcx().types.err\n                 }\n             }\n         }\n-        None => ty::mk_err()\n+        None => fcx.tcx().types.err\n     }\n }\n \n@@ -2480,7 +2531,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          tuple_arguments: TupleArgumentsFlag)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n-        let err_inputs = err_args(args_no_rcvr.len());\n+        let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n@@ -2495,7 +2546,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              autoref_args,\n                              false,\n                              tuple_arguments);\n-        ty::FnConverging(ty::mk_err())\n+        ty::FnConverging(fcx.tcx().types.err)\n     } else {\n         match method_fn_ty.sty {\n             ty::ty_bare_fn(_, ref fty) => {\n@@ -2550,7 +2601,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    err_args(args.len())\n+                    err_args(fcx.tcx(), args.len())\n                 } else {\n                     (*arg_types).clone()\n                 }\n@@ -2559,7 +2610,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n-                err_args(args.len())\n+                err_args(fcx.tcx(), args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {\n@@ -2575,7 +2626,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-            err_args(supplied_arg_count)\n+            err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n         span_err!(tcx.sess, sp, E0061,\n@@ -2584,7 +2635,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-        err_args(supplied_arg_count)\n+        err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n     debug!(\"check_argument_types: formal_tys={}\",\n@@ -2640,7 +2691,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 // mismatch impl/trait method phase no need to\n                                 // ICE here.\n                                 // See: #11450\n-                                formal_ty = ty::mk_err();\n+                                formal_ty = tcx.types.err;\n                             }\n                         }\n                     }\n@@ -2691,8 +2742,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-fn err_args<'tcx>(len: uint) -> Vec<Ty<'tcx>> {\n-    Vec::from_fn(len, |_| ty::mk_err())\n+fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n+    Vec::from_fn(len, |_| tcx.types.err)\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2715,27 +2766,28 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match lit.node {\n         ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n         ast::LitBinary(..) => {\n-            ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n-                         ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n-        }\n-        ast::LitByte(_) => ty::mk_u8(),\n-        ast::LitChar(_) => ty::mk_char(),\n-        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(t),\n-        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(t),\n+            ty::mk_slice(tcx,\n+                         tcx.mk_region(ty::ReStatic),\n+                         ty::mt{ ty: tcx.types.u8, mutbl: ast::MutImmutable })\n+        }\n+        ast::LitByte(_) => tcx.types.u8,\n+        ast::LitChar(_) => tcx.types.char,\n+        ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n+        ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n             let opt_ty = expected.map_to_option(fcx, |ty| {\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n-                    ty::ty_char => Some(ty::mk_mach_uint(ast::TyU8)),\n-                    ty::ty_ptr(..) => Some(ty::mk_mach_uint(ast::TyU)),\n-                    ty::ty_bare_fn(..) => Some(ty::mk_mach_uint(ast::TyU)),\n+                    ty::ty_char => Some(tcx.types.u8),\n+                    ty::ty_ptr(..) => Some(tcx.types.uint),\n+                    ty::ty_bare_fn(..) => Some(tcx.types.uint),\n                     _ => None\n                 }\n             });\n             opt_ty.unwrap_or_else(\n                 || ty::mk_int_var(tcx, fcx.infcx().next_int_var_id()))\n         }\n-        ast::LitFloat(_, t) => ty::mk_mach_float(t),\n+        ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n         ast::LitFloatUnsuffixed(_) => {\n             let opt_ty = expected.map_to_option(fcx, |ty| {\n                 match ty.sty {\n@@ -2746,7 +2798,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             opt_ty.unwrap_or_else(\n                 || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitBool(_) => ty::mk_bool()\n+        ast::LitBool(_) => tcx.types.bool\n     }\n }\n \n@@ -2921,8 +2973,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = ty::Binder(FnSig {\n-            inputs: err_args(args.len()),\n-            output: ty::FnConverging(ty::mk_err()),\n+            inputs: err_args(fcx.tcx(), args.len()),\n+            output: ty::FnConverging(fcx.tcx().types.err),\n             variadic: false\n         });\n \n@@ -2989,7 +3041,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             Err(error) => {\n                 method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n                 fcx.write_error(expr.id);\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n         };\n \n@@ -3015,7 +3067,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  id: ast::NodeId,\n                                  sp: Span,\n                                  expected: Expectation<'tcx>) {\n-        check_expr_has_type(fcx, cond_expr, ty::mk_bool());\n+        check_expr_has_type(fcx, cond_expr, fcx.tcx().types.bool);\n \n         let expected = expected.adjust_for_branches(fcx);\n         check_block_with_expected(fcx, then_blk, expected);\n@@ -3042,7 +3094,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let cond_ty = fcx.expr_ty(cond_expr);\n         let if_ty = if ty::type_is_error(cond_ty) {\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         } else {\n             branches_ty\n         };\n@@ -3114,22 +3166,22 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             autoref_args,\n                                             DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n-                    ty::FnDiverging => ty::mk_err()\n+                    ty::FnDiverging => fcx.tcx().types.err\n                 }\n             }\n             None => {\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n-                let expected_ty = ty::mk_err();\n+                let expected_ty = fcx.tcx().types.err;\n                 check_method_argument_types(fcx,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n                                             args.as_slice(),\n                                             autoref_args,\n                                             DontTupleArguments);\n-                ty::mk_err()\n+                fcx.tcx().types.err\n             }\n         }\n     }\n@@ -3155,7 +3207,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n-            check_expr_has_type(fcx, &**rhs, ty::mk_uint());\n+            check_expr_has_type(fcx, &**rhs, fcx.tcx().types.uint);\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n         }\n@@ -3182,12 +3234,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 lhs_t,\n                                 None\n                             );\n-                            ty::mk_err()\n+                            fcx.tcx().types.err\n                         } else {\n                             lhs_t\n                         }\n                     } else {\n-                        ty::mk_bool()\n+                        fcx.tcx().types.bool\n                     }\n                 },\n                 _ => lhs_t,\n@@ -3229,7 +3281,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    lhs_t,\n                                    None);\n             check_expr(fcx, &**rhs);\n-            ty::mk_err()\n+            fcx.tcx().types.err\n         };\n \n         fcx.write_ty(expr.id, result_t);\n@@ -3265,7 +3317,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n                 check_expr(fcx, &**rhs);\n-                return ty::mk_err();\n+                return tcx.types.err;\n             }\n         };\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n@@ -3438,7 +3490,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Typecheck each field.\n         for field in ast_fields.iter() {\n-            let mut expected_field_type = ty::mk_err();\n+            let mut expected_field_type = tcx.types.err;\n \n             let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n             match pair {\n@@ -3545,7 +3597,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        base_expr.is_none(),\n                                        None);\n         if ty::type_is_error(fcx.node_ty(id)) {\n-            struct_type = ty::mk_err();\n+            struct_type = tcx.types.err;\n         }\n \n         // Check the base expression if necessary.\n@@ -3634,7 +3686,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,\n                   \"only the managed heap and exchange heap are currently supported\");\n-              fcx.write_ty(id, ty::mk_err());\n+              fcx.write_ty(id, tcx.types.err);\n           }\n       }\n \n@@ -3734,7 +3786,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n-                                ty::mk_err()\n+                                tcx.types.err\n                             }\n                         }\n                     };\n@@ -3791,7 +3843,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let tm = ty::mt { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n         let oprnd_t = if ty::type_is_error(tm.ty) {\n-            ty::mk_err()\n+            tcx.types.err\n         } else {\n             // Note: at this point, we cannot say what the best lifetime\n             // is to use for resulting pointer.  We want to use the\n@@ -3909,7 +3961,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n       }\n       ast::ExprWhile(ref cond, ref body, _) => {\n-        check_expr_has_type(fcx, &**cond, ty::mk_bool());\n+        check_expr_has_type(fcx, &**cond, tcx.types.bool);\n         check_block_no_value(fcx, &**body);\n         let cond_ty = fcx.expr_ty(&**cond);\n         let body_ty = fcx.node_ty(body.id);\n@@ -3989,7 +4041,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprCast(ref e, ref t) => {\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, ty::mk_uint());\n+            check_expr_with_hint(fcx, &**count_expr, tcx.types.uint);\n         }\n         check_cast(fcx, expr, &**e, &**t);\n       }\n@@ -4020,7 +4072,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, ty::mk_uint());\n+        check_expr_has_type(fcx, &**count_expr, tcx.types.uint);\n         let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n@@ -4824,12 +4876,12 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => ty::mk_int(),\n+                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => fcx.tcx().types.int,\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n-                            ty::mk_mach_int(ity)\n+                            ty::mk_mach_int(fcx.tcx(), ity)\n                         }\n                         attr::ReprInt(_, attr::UnsignedInt(ity)) => {\n-                            ty::mk_mach_uint(ity)\n+                            ty::mk_mach_uint(fcx.tcx(), ity)\n                         },\n                     };\n                     check_const_with_ty(&fcx, e.span, &**e, declty);\n@@ -5366,7 +5418,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 , found {} parameter(s)\",\n                 qualifier, required_len, provided_len);\n             substs.types.replace(space,\n-                                 Vec::from_elem(desired.len(), ty::mk_err()));\n+                                 Vec::from_elem(desired.len(), fcx.tcx().types.err));\n             return;\n         }\n \n@@ -5450,8 +5502,8 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n             \"the type of this value must be known in this \\\n              context\".to_string()\n         }, ty, None);\n-        demand::suptype(fcx, sp, ty::mk_err(), ty);\n-        ty = ty::mk_err();\n+        demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n+        ty = fcx.tcx().types.err;\n     }\n \n     ty\n@@ -5554,7 +5606,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         let (n_tps, inputs, output) = match name.get() {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n+            \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ccx.tcx.types.uint),\n             \"init\" => (1u, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1u, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n@@ -5570,8 +5622,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ),\n                ty::mk_nil(tcx))\n             }\n-            \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n-            \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n+            \"needs_drop\" => (1u, Vec::new(), ccx.tcx.types.bool),\n+            \"owns_managed\" => (1u, Vec::new(), ccx.tcx.types.bool),\n \n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n@@ -5603,7 +5655,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_int()\n+                  ccx.tcx.types.int\n                ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n@@ -5622,7 +5674,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ty::mk_uint()\n+                  tcx.types.uint,\n                ),\n                ty::mk_nil(tcx))\n             }\n@@ -5633,129 +5685,129 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutMutable\n                   }),\n-                  ty::mk_u8(),\n-                  ty::mk_uint()\n+                  tcx.types.u8,\n+                  tcx.types.uint,\n                ),\n                ty::mk_nil(tcx))\n             }\n-            \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"powif32\" => {\n                (0,\n-                vec!( ty::mk_f32(), ty::mk_i32() ),\n-                ty::mk_f32())\n+                vec!( tcx.types.f32, tcx.types.i32 ),\n+                tcx.types.f32)\n             }\n             \"powif64\" => {\n                (0,\n-                vec!( ty::mk_f64(), ty::mk_i32() ),\n-                ty::mk_f64())\n+                vec!( tcx.types.f64, tcx.types.i32 ),\n+                tcx.types.f64)\n             }\n-            \"sinf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"sinf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"cosf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"cosf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"powf32\" => {\n                (0,\n-                vec!( ty::mk_f32(), ty::mk_f32() ),\n-                ty::mk_f32())\n+                vec!( tcx.types.f32, tcx.types.f32 ),\n+                tcx.types.f32)\n             }\n             \"powf64\" => {\n                (0,\n-                vec!( ty::mk_f64(), ty::mk_f64() ),\n-                ty::mk_f64())\n-            }\n-            \"expf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"expf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"exp2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"exp2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"logf32\"   => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"logf64\"   => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"log10f32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"log10f64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"log2f32\"  => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"log2f64\"  => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n+                vec!( tcx.types.f64, tcx.types.f64 ),\n+                tcx.types.f64)\n+            }\n+            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n             \"fmaf32\" => {\n                 (0,\n-                 vec!( ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ),\n-                 ty::mk_f32())\n+                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n+                 tcx.types.f32)\n             }\n             \"fmaf64\" => {\n                 (0,\n-                 vec!( ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ),\n-                 ty::mk_f64())\n-            }\n-            \"fabsf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"fabsf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"copysignf32\"  => (0, vec!( ty::mk_f32(), ty::mk_f32() ), ty::mk_f32()),\n-            \"copysignf64\"  => (0, vec!( ty::mk_f64(), ty::mk_f64() ), ty::mk_f64()),\n-            \"floorf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"floorf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ceilf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"ceilf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"truncf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"truncf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"rintf32\"      => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"rintf64\"      => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"nearbyintf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"nearbyintf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"roundf32\"     => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n-            \"roundf64\"     => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n-            \"ctpop8\"       => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"ctpop16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"ctpop32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"ctpop64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"ctlz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"ctlz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"ctlz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"ctlz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"cttz8\"        => (0, vec!( ty::mk_u8()  ), ty::mk_u8()),\n-            \"cttz16\"       => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"cttz32\"       => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"cttz64\"       => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n-            \"bswap16\"      => (0, vec!( ty::mk_u16() ), ty::mk_u16()),\n-            \"bswap32\"      => (0, vec!( ty::mk_u32() ), ty::mk_u32()),\n-            \"bswap64\"      => (0, vec!( ty::mk_u64() ), ty::mk_u64()),\n+                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n+                 tcx.types.f64)\n+            }\n+            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n+            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n+            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n \n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n                 (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i8(), ty::mk_i8()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i8(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i8, tcx.types.i8),\n+                ty::mk_tup(tcx, vec!(tcx.types.i8, tcx.types.bool))),\n \n             \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i16(), ty::mk_i16()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i16(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i16, tcx.types.i16),\n+                ty::mk_tup(tcx, vec!(tcx.types.i16, tcx.types.bool))),\n \n             \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i32(), ty::mk_i32()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i32(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i32, tcx.types.i32),\n+                ty::mk_tup(tcx, vec!(tcx.types.i32, tcx.types.bool))),\n \n             \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_i64(), ty::mk_i64()),\n-                ty::mk_tup(tcx, vec!(ty::mk_i64(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.i64, tcx.types.i64),\n+                ty::mk_tup(tcx, vec!(tcx.types.i64, tcx.types.bool))),\n \n             \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u8(), ty::mk_u8()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u8(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u8, tcx.types.u8),\n+                ty::mk_tup(tcx, vec!(tcx.types.u8, tcx.types.bool))),\n \n             \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u16(), ty::mk_u16()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u16(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u16, tcx.types.u16),\n+                ty::mk_tup(tcx, vec!(tcx.types.u16, tcx.types.bool))),\n \n             \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, vec!(ty::mk_u32(), ty::mk_u32()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u32(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u32, tcx.types.u32),\n+                ty::mk_tup(tcx, vec!(tcx.types.u32, tcx.types.bool))),\n \n             \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, vec!(ty::mk_u64(), ty::mk_u64()),\n-                ty::mk_tup(tcx, vec!(ty::mk_u64(), ty::mk_bool()))),\n+                (0, vec!(tcx.types.u64, tcx.types.u64),\n+                ty::mk_tup(tcx, vec!(tcx.types.u64, tcx.types.bool))),\n \n-            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, ty::mk_u8())),\n+            \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, tcx.types.u8)),\n \n-            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil(tcx)),\n+            \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),\n \n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,"}, {"sha": "626845613b41a8631bb24cb2dfa7dcb40f516d9c", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -133,7 +133,8 @@ pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                  object_trait: &ty::TyTrait<'tcx>,\n                                  span: Span)\n {\n-    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(tcx, ty::mk_err());\n+    let object_trait_ref =\n+        object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err);\n     for tr in traits::supertraits(tcx, object_trait_ref) {\n         check_object_safety_inner(tcx, &*tr, span);\n     }"}, {"sha": "5ef9757b91ac250367a9fee6176eca09041e95c2", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -169,7 +169,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                write_ty_to_tcx(self.tcx(), count_expr.id, ty::mk_uint());\n+                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.uint);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -441,7 +441,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n                 debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n                        t.repr(self.tcx));\n                 self.report_error(e);\n-                ty::mk_err()\n+                self.tcx().types.err\n             }\n         }\n     }"}, {"sha": "6bbf464441460863d72e30942b9e18fb4ebe447b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx.sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n-        ty::mk_err()\n+        self.tcx().types.err\n     }\n \n     fn associated_types_of_trait_are_valid(&self, _: Ty<'tcx>, _: ast::DefId)"}, {"sha": "353db82eb027de64c2ad4fb6c0f19d41521d9dff", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f95bb55a1c4cb258ac8e6adde99cf1aadc5d776b", "patch": "@@ -278,11 +278,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n-                        ty::mk_int(),\n-                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n+                        tcx.types.int,\n+                        ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(ty::mk_int()),\n-                    variadic: false\n+                    output: ty::FnConverging(tcx.types.int),\n+                    variadic: false,\n                 }),\n             }));\n "}]}