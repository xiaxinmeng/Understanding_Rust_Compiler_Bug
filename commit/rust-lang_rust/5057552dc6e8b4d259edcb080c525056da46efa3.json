{"sha": "5057552dc6e8b4d259edcb080c525056da46efa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNTc1NTJkYzZlOGI0ZDI1OWVkY2IwODBjNTI1MDU2ZGE0NmVmYTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T01:32:16Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T02:01:39Z"}, "message": "typeck/expr.rs: move check_field + struct helpers here.", "tree": {"sha": "c599fec62088cda074498eecff597e724ba6297c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c599fec62088cda074498eecff597e724ba6297c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5057552dc6e8b4d259edcb080c525056da46efa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5057552dc6e8b4d259edcb080c525056da46efa3", "html_url": "https://github.com/rust-lang/rust/commit/5057552dc6e8b4d259edcb080c525056da46efa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5057552dc6e8b4d259edcb080c525056da46efa3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "html_url": "https://github.com/rust-lang/rust/commit/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9"}], "stats": {"total": 820, "additions": 412, "deletions": 408}, "files": [{"sha": "fa9e0d8a8578afd94a12ad3ea7a080f2b379adee", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 409, "deletions": 2, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/5057552dc6e8b4d259edcb080c525056da46efa3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5057552dc6e8b4d259edcb080c525056da46efa3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5057552dc6e8b4d259edcb080c525056da46efa3", "patch": "@@ -15,12 +15,15 @@ use crate::check::TupleArgumentsFlag::DontTupleArguments;\n use crate::check::method::SelfSource;\n use crate::middle::lang_items;\n use crate::util::common::ErrorReported;\n+use crate::util::nodemap::FxHashMap;\n+use crate::astconv::AstConv as _;\n \n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n use syntax::ast;\n use syntax::ptr::P;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n use syntax::source_map::Span;\n+use syntax::util::lev_distance::find_best_match_for_name;\n use rustc::hir;\n use rustc::hir::{ExprKind, QPath};\n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -31,11 +34,14 @@ use rustc::ty;\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n+use rustc::ty::{AdtKind, Visibility};\n use rustc::ty::Ty;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::InternalSubsts;\n use rustc::traits::{self, ObligationCauseCode};\n \n+use std::fmt::Display;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n@@ -1057,6 +1063,407 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         adt_ty\n     }\n \n+    fn check_expr_struct_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        expected: Expectation<'tcx>,\n+        expr_id: hir::HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        ast_fields: &'tcx [hir::Field],\n+        check_completeness: bool,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let adt_ty_hint =\n+            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n+                .get(0).cloned().unwrap_or(adt_ty);\n+        // re-link the regions that EIfEO can erase.\n+        self.demand_eqtype(span, adt_ty_hint, adt_ty);\n+\n+        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n+            &ty::Adt(adt, substs) => {\n+                (substs, adt.adt_kind(), adt.variant_descr())\n+            }\n+            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n+        };\n+\n+        let mut remaining_fields = variant.fields.iter().enumerate().map(|(i, field)|\n+            (field.ident.modern(), (i, field))\n+        ).collect::<FxHashMap<_, _>>();\n+\n+        let mut seen_fields = FxHashMap::default();\n+\n+        let mut error_happened = false;\n+\n+        // Type-check each field.\n+        for field in ast_fields {\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n+            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n+                seen_fields.insert(ident, field.span);\n+                self.write_field_index(field.hir_id, i);\n+\n+                // We don't look at stability attributes on\n+                // struct-like enums (yet...), but it's definitely not\n+                // a bug to have constructed one.\n+                if adt_kind != AdtKind::Enum {\n+                    tcx.check_stability(v_field.did, Some(expr_id), field.span);\n+                }\n+\n+                self.field_ty(field.span, v_field, substs)\n+            } else {\n+                error_happened = true;\n+                if let Some(prev_span) = seen_fields.get(&ident) {\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   field.ident.span,\n+                                                   E0062,\n+                                                   \"field `{}` specified more than once\",\n+                                                   ident);\n+\n+                    err.span_label(field.ident.span, \"used more than once\");\n+                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n+\n+                    err.emit();\n+                } else {\n+                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n+                }\n+\n+                tcx.types.err\n+            };\n+\n+            // Make sure to give a type to the field even if there's\n+            // an error, so we can continue type-checking.\n+            self.check_expr_coercable_to_type(&field.expr, field_type);\n+        }\n+\n+        // Make sure the programmer specified correct number of fields.\n+        if kind_name == \"union\" {\n+            if ast_fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n+            }\n+        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n+            let len = remaining_fields.len();\n+\n+            let mut displayable_field_names = remaining_fields\n+                                              .keys()\n+                                              .map(|ident| ident.as_str())\n+                                              .collect::<Vec<_>>();\n+\n+            displayable_field_names.sort();\n+\n+            let truncated_fields_error = if len <= 3 {\n+                String::new()\n+            } else {\n+                format!(\" and {} other field{}\", (len - 3), if len - 3 == 1 {\"\"} else {\"s\"})\n+            };\n+\n+            let remaining_fields_names = displayable_field_names.iter().take(3)\n+                                        .map(|n| format!(\"`{}`\", n))\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \");\n+\n+            struct_span_err!(tcx.sess, span, E0063,\n+                             \"missing field{} {}{} in initializer of `{}`\",\n+                             if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n+                             remaining_fields_names,\n+                             truncated_fields_error,\n+                             adt_ty)\n+                .span_label(span, format!(\"missing {}{}\",\n+                                          remaining_fields_names,\n+                                          truncated_fields_error))\n+                .emit();\n+        }\n+        error_happened\n+    }\n+\n+    fn check_struct_fields_on_error(\n+        &self,\n+        fields: &'tcx [hir::Field],\n+        base_expr: &'tcx Option<P<hir::Expr>>,\n+    ) {\n+        for field in fields {\n+            self.check_expr(&field.expr);\n+        }\n+        if let Some(ref base) = *base_expr {\n+            self.check_expr(&base);\n+        }\n+    }\n+\n+    fn report_unknown_field(\n+        &self,\n+        ty: Ty<'tcx>,\n+        variant: &'tcx ty::VariantDef,\n+        field: &hir::Field,\n+        skip_fields: &[hir::Field],\n+        kind_name: &str,\n+    ) {\n+        if variant.recovered {\n+            return;\n+        }\n+        let mut err = self.type_error_struct_with_diag(\n+            field.ident.span,\n+            |actual| match ty.sty {\n+                ty::Adt(adt, ..) if adt.is_enum() => {\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n+                                     \"{} `{}::{}` has no field named `{}`\",\n+                                     kind_name, actual, variant.ident, field.ident)\n+                }\n+                _ => {\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n+                                     \"{} `{}` has no field named `{}`\",\n+                                     kind_name, actual, field.ident)\n+                }\n+            },\n+            ty);\n+        // prevent all specified fields from being suggested\n+        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n+        if let Some(field_name) = Self::suggest_field_name(variant,\n+                                                           &field.ident.as_str(),\n+                                                           skip_fields.collect()) {\n+            err.span_suggestion(\n+                field.ident.span,\n+                \"a field with a similar name exists\",\n+                field_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            match ty.sty {\n+                ty::Adt(adt, ..) => {\n+                    if adt.is_enum() {\n+                        err.span_label(field.ident.span,\n+                                       format!(\"`{}::{}` does not have this field\",\n+                                               ty, variant.ident));\n+                    } else {\n+                        err.span_label(field.ident.span,\n+                                       format!(\"`{}` does not have this field\", ty));\n+                    }\n+                    let available_field_names = self.available_field_names(variant);\n+                    if !available_field_names.is_empty() {\n+                        err.note(&format!(\"available fields are: {}\",\n+                                          self.name_series_display(available_field_names)));\n+                    }\n+                }\n+                _ => bug!(\"non-ADT passed to report_unknown_field\")\n+            }\n+        };\n+        err.emit();\n+    }\n+\n+    // Return an hint about the closest match in field names\n+    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n+                          field: &str,\n+                          skip: Vec<LocalInternedString>)\n+                          -> Option<Symbol> {\n+        let names = variant.fields.iter().filter_map(|field| {\n+            // ignore already set fields and private fields from non-local crates\n+            if skip.iter().any(|x| *x == field.ident.as_str()) ||\n+               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n+            {\n+                None\n+            } else {\n+                Some(&field.ident.name)\n+            }\n+        });\n+\n+        find_best_match_for_name(names, field, None)\n+    }\n+\n+    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n+        variant.fields.iter().filter(|field| {\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n+            field.vis.is_accessible_from(def_scope, self.tcx)\n+        })\n+        .map(|field| field.ident.name)\n+        .collect()\n+    }\n+\n+    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n+        // dynamic limit, to never omit just one field\n+        let limit = if names.len() == 6 { 6 } else { 5 };\n+        let mut display = names.iter().take(limit)\n+            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        if names.len() > limit {\n+            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n+        }\n+        display\n+    }\n+\n+    // Check field access expressions\n+    fn check_field(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        needs: Needs,\n+        base: &'tcx hir::Expr,\n+        field: ast::Ident,\n+    ) -> Ty<'tcx> {\n+        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.structurally_resolved_type(base.span,\n+                                                     expr_t);\n+        let mut private_candidate = None;\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, _)) = autoderef.next() {\n+            match base_t.sty {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    debug!(\"struct named {:?}\",  base_t);\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n+                    let fields = &base_def.non_enum_variant().fields;\n+                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n+                        let field = &fields[index];\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+                        // Save the index of all fields regardless of their visibility in case\n+                        // of error recovery.\n+                        self.write_field_index(expr.hir_id, index);\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n+                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            self.apply_adjustments(base, adjustments);\n+                            autoderef.finalize(self);\n+\n+                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n+                            return field_ty;\n+                        }\n+                        private_candidate = Some((base_def.did, field_ty));\n+                    }\n+                }\n+                ty::Tuple(ref tys) => {\n+                    let fstr = field.as_str();\n+                    if let Ok(index) = fstr.parse::<usize>() {\n+                        if fstr == index.to_string() {\n+                            if let Some(field_ty) = tys.get(index) {\n+                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                self.apply_adjustments(base, adjustments);\n+                                autoderef.finalize(self);\n+\n+                                self.write_field_index(expr.hir_id, index);\n+                                return field_ty.expect_ty();\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        autoderef.unambiguous_final_ty(self);\n+\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = self.tcx().def_path_str(did);\n+            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n+                                           \"field `{}` of struct `{}` is private\",\n+                                           field, struct_path);\n+            // Also check if an accessible method exists, which is often what is meant.\n+            if self.method_exists(field, expr_t, expr.hir_id, false)\n+                && !self.expr_in_place(expr.hir_id)\n+            {\n+                self.suggest_method_call(\n+                    &mut err,\n+                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                    field,\n+                    expr_t,\n+                    expr.hir_id,\n+                );\n+            }\n+            err.emit();\n+            field_ty\n+        } else if field.name == kw::Invalid {\n+            self.tcx().types.err\n+        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n+            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n+                               \"attempted to take value of method `{}` on type `{}`\",\n+                               field, expr_t);\n+\n+            if !self.expr_in_place(expr.hir_id) {\n+                self.suggest_method_call(\n+                    &mut err,\n+                    \"use parentheses to call the method\",\n+                    field,\n+                    expr_t,\n+                    expr.hir_id\n+                );\n+            } else {\n+                err.help(\"methods are immutable and cannot be assigned to\");\n+            }\n+\n+            err.emit();\n+            self.tcx().types.err\n+        } else {\n+            if !expr_t.is_primitive_ty() {\n+                let mut err = self.no_such_field_err(field.span, field, expr_t);\n+\n+                match expr_t.sty {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n+                        if let Some(suggested_field_name) =\n+                            Self::suggest_field_name(def.non_enum_variant(),\n+                                                     &field.as_str(), vec![]) {\n+                                err.span_suggestion(\n+                                    field.span,\n+                                    \"a field with a similar name exists\",\n+                                    suggested_field_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(field.span, \"unknown field\");\n+                                let struct_variant_def = def.non_enum_variant();\n+                                let field_names = self.available_field_names(struct_variant_def);\n+                                if !field_names.is_empty() {\n+                                    err.note(&format!(\"available fields are: {}\",\n+                                                      self.name_series_display(field_names)));\n+                                }\n+                            };\n+                    }\n+                    ty::Array(_, len) => {\n+                        if let (Some(len), Ok(user_index)) = (\n+                            len.assert_usize(self.tcx),\n+                            field.as_str().parse::<u64>()\n+                        ) {\n+                            let base = self.tcx.sess.source_map()\n+                                .span_to_snippet(base.span)\n+                                .unwrap_or_else(|_|\n+                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+                            let help = \"instead of using tuple indexing, use array indexing\";\n+                            let suggestion = format!(\"{}[{}]\", base, field);\n+                            let applicability = if len < user_index {\n+                                Applicability::MachineApplicable\n+                            } else {\n+                                Applicability::MaybeIncorrect\n+                            };\n+                            err.span_suggestion(\n+                                expr.span, help, suggestion, applicability\n+                            );\n+                        }\n+                    }\n+                    ty::RawPtr(..) => {\n+                        let base = self.tcx.sess.source_map()\n+                            .span_to_snippet(base.span)\n+                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+                        let suggestion = format!(\"(*{}).{}\", base, field);\n+                        err.span_suggestion(\n+                            expr.span,\n+                            &msg,\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                }\n+                err\n+            } else {\n+                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n+                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n+                                   expr_t)\n+            }.emit();\n+            self.tcx().types.err\n+        }\n+    }\n+\n+    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n+        -> DiagnosticBuilder<'_> {\n+        type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n+                           \"no field `{}` on type `{}`\",\n+                           field, expr_t)\n+    }\n+\n     fn check_expr_index(\n         &self,\n         base: &'tcx hir::Expr,"}, {"sha": "4c8ad66441f3277cbb3f27be236f1640756e6a38", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 406, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/5057552dc6e8b4d259edcb080c525056da46efa3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5057552dc6e8b4d259edcb080c525056da46efa3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5057552dc6e8b4d259edcb080c525056da46efa3", "patch": "@@ -106,7 +106,7 @@ use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{\n-    self, AdtKind, CanonicalUserType, Ty, TyCtxt, Const, GenericParamDefKind, Visibility,\n+    self, AdtKind, CanonicalUserType, Ty, TyCtxt, Const, GenericParamDefKind,\n     ToPolyTraitRef, ToPredicate, RegionKind, UserType\n };\n use rustc::ty::adjustment::{\n@@ -124,13 +124,11 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n-use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::{kw, sym};\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::hash_map::Entry;\n use std::cmp;\n-use std::fmt::Display;\n use std::iter;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -143,7 +141,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashSet, HirIdMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -3266,407 +3264,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expect_args\n     }\n \n-    // Check field access expressions\n-    fn check_field(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        needs: Needs,\n-        base: &'tcx hir::Expr,\n-        field: ast::Ident,\n-    ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n-        let expr_t = self.structurally_resolved_type(base.span,\n-                                                     expr_t);\n-        let mut private_candidate = None;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            match base_t.sty {\n-                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n-                    debug!(\"struct named {:?}\",  base_t);\n-                    let (ident, def_scope) =\n-                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n-                    let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n-                        let field = &fields[index];\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        // Save the index of all fields regardless of their visibility in case\n-                        // of error recovery.\n-                        self.write_field_index(expr.hir_id, index);\n-                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n-                            self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize(self);\n-\n-                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n-                            return field_ty;\n-                        }\n-                        private_candidate = Some((base_def.did, field_ty));\n-                    }\n-                }\n-                ty::Tuple(ref tys) => {\n-                    let fstr = field.as_str();\n-                    if let Ok(index) = fstr.parse::<usize>() {\n-                        if fstr == index.to_string() {\n-                            if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n-                                self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize(self);\n-\n-                                self.write_field_index(expr.hir_id, index);\n-                                return field_ty.expect_ty();\n-                            }\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        autoderef.unambiguous_final_ty(self);\n-\n-        if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().def_path_str(did);\n-            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n-                                           \"field `{}` of struct `{}` is private\",\n-                                           field, struct_path);\n-            // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.hir_id, false)\n-                && !self.expr_in_place(expr.hir_id)\n-            {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n-                    field,\n-                    expr_t,\n-                    expr.hir_id,\n-                );\n-            }\n-            err.emit();\n-            field_ty\n-        } else if field.name == kw::Invalid {\n-            self.tcx().types.err\n-        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                               \"attempted to take value of method `{}` on type `{}`\",\n-                               field, expr_t);\n-\n-            if !self.expr_in_place(expr.hir_id) {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    \"use parentheses to call the method\",\n-                    field,\n-                    expr_t,\n-                    expr.hir_id\n-                );\n-            } else {\n-                err.help(\"methods are immutable and cannot be assigned to\");\n-            }\n-\n-            err.emit();\n-            self.tcx().types.err\n-        } else {\n-            if !expr_t.is_primitive_ty() {\n-                let mut err = self.no_such_field_err(field.span, field, expr_t);\n-\n-                match expr_t.sty {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        if let Some(suggested_field_name) =\n-                            Self::suggest_field_name(def.non_enum_variant(),\n-                                                     &field.as_str(), vec![]) {\n-                                err.span_suggestion(\n-                                    field.span,\n-                                    \"a field with a similar name exists\",\n-                                    suggested_field_name.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(field.span, \"unknown field\");\n-                                let struct_variant_def = def.non_enum_variant();\n-                                let field_names = self.available_field_names(struct_variant_def);\n-                                if !field_names.is_empty() {\n-                                    err.note(&format!(\"available fields are: {}\",\n-                                                      self.name_series_display(field_names)));\n-                                }\n-                            };\n-                    }\n-                    ty::Array(_, len) => {\n-                        if let (Some(len), Ok(user_index)) = (\n-                            len.assert_usize(self.tcx),\n-                            field.as_str().parse::<u64>()\n-                        ) {\n-                            let base = self.tcx.sess.source_map()\n-                                .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_|\n-                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                            let help = \"instead of using tuple indexing, use array indexing\";\n-                            let suggestion = format!(\"{}[{}]\", base, field);\n-                            let applicability = if len < user_index {\n-                                Applicability::MachineApplicable\n-                            } else {\n-                                Applicability::MaybeIncorrect\n-                            };\n-                            err.span_suggestion(\n-                                expr.span, help, suggestion, applicability\n-                            );\n-                        }\n-                    }\n-                    ty::RawPtr(..) => {\n-                        let base = self.tcx.sess.source_map()\n-                            .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-                        let suggestion = format!(\"(*{}).{}\", base, field);\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &msg,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n-                }\n-                err\n-            } else {\n-                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n-                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n-                                   expr_t)\n-            }.emit();\n-            self.tcx().types.err\n-        }\n-    }\n-\n-    // Return an hint about the closest match in field names\n-    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n-                          field: &str,\n-                          skip: Vec<LocalInternedString>)\n-                          -> Option<Symbol> {\n-        let names = variant.fields.iter().filter_map(|field| {\n-            // ignore already set fields and private fields from non-local crates\n-            if skip.iter().any(|x| *x == field.ident.as_str()) ||\n-               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n-            {\n-                None\n-            } else {\n-                Some(&field.ident.name)\n-            }\n-        });\n-\n-        find_best_match_for_name(names, field, None)\n-    }\n-\n-    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n-        variant.fields.iter().filter(|field| {\n-            let def_scope =\n-                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n-            field.vis.is_accessible_from(def_scope, self.tcx)\n-        })\n-        .map(|field| field.ident.name)\n-        .collect()\n-    }\n-\n-    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n-        // dynamic limit, to never omit just one field\n-        let limit = if names.len() == 6 { 6 } else { 5 };\n-        let mut display = names.iter().take(limit)\n-            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n-        if names.len() > limit {\n-            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n-        }\n-        display\n-    }\n-\n-    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n-        -> DiagnosticBuilder<'_> {\n-        type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n-                           \"no field `{}` on type `{}`\",\n-                           field, expr_t)\n-    }\n-\n-    fn report_unknown_field(\n-        &self,\n-        ty: Ty<'tcx>,\n-        variant: &'tcx ty::VariantDef,\n-        field: &hir::Field,\n-        skip_fields: &[hir::Field],\n-        kind_name: &str,\n-    ) {\n-        if variant.recovered {\n-            return;\n-        }\n-        let mut err = self.type_error_struct_with_diag(\n-            field.ident.span,\n-            |actual| match ty.sty {\n-                ty::Adt(adt, ..) if adt.is_enum() => {\n-                    struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n-                                     \"{} `{}::{}` has no field named `{}`\",\n-                                     kind_name, actual, variant.ident, field.ident)\n-                }\n-                _ => {\n-                    struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n-                                     \"{} `{}` has no field named `{}`\",\n-                                     kind_name, actual, field.ident)\n-                }\n-            },\n-            ty);\n-        // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n-        if let Some(field_name) = Self::suggest_field_name(variant,\n-                                                           &field.ident.as_str(),\n-                                                           skip_fields.collect()) {\n-            err.span_suggestion(\n-                field.ident.span,\n-                \"a field with a similar name exists\",\n-                field_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            match ty.sty {\n-                ty::Adt(adt, ..) => {\n-                    if adt.is_enum() {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}::{}` does not have this field\",\n-                                               ty, variant.ident));\n-                    } else {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}` does not have this field\", ty));\n-                    }\n-                    let available_field_names = self.available_field_names(variant);\n-                    if !available_field_names.is_empty() {\n-                        err.note(&format!(\"available fields are: {}\",\n-                                          self.name_series_display(available_field_names)));\n-                    }\n-                }\n-                _ => bug!(\"non-ADT passed to report_unknown_field\")\n-            }\n-        };\n-        err.emit();\n-    }\n-\n-    fn check_expr_struct_fields(\n-        &self,\n-        adt_ty: Ty<'tcx>,\n-        expected: Expectation<'tcx>,\n-        expr_id: hir::HirId,\n-        span: Span,\n-        variant: &'tcx ty::VariantDef,\n-        ast_fields: &'tcx [hir::Field],\n-        check_completeness: bool,\n-    ) -> bool {\n-        let tcx = self.tcx;\n-\n-        let adt_ty_hint =\n-            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n-                .get(0).cloned().unwrap_or(adt_ty);\n-        // re-link the regions that EIfEO can erase.\n-        self.demand_eqtype(span, adt_ty_hint, adt_ty);\n-\n-        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n-            &ty::Adt(adt, substs) => {\n-                (substs, adt.adt_kind(), adt.variant_descr())\n-            }\n-            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n-        };\n-\n-        let mut remaining_fields = variant.fields.iter().enumerate().map(|(i, field)|\n-            (field.ident.modern(), (i, field))\n-        ).collect::<FxHashMap<_, _>>();\n-\n-        let mut seen_fields = FxHashMap::default();\n-\n-        let mut error_happened = false;\n-\n-        // Type-check each field.\n-        for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n-            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n-                seen_fields.insert(ident, field.span);\n-                self.write_field_index(field.hir_id, i);\n-\n-                // We don't look at stability attributes on\n-                // struct-like enums (yet...), but it's definitely not\n-                // a bug to have constructed one.\n-                if adt_kind != AdtKind::Enum {\n-                    tcx.check_stability(v_field.did, Some(expr_id), field.span);\n-                }\n-\n-                self.field_ty(field.span, v_field, substs)\n-            } else {\n-                error_happened = true;\n-                if let Some(prev_span) = seen_fields.get(&ident) {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   field.ident.span,\n-                                                   E0062,\n-                                                   \"field `{}` specified more than once\",\n-                                                   ident);\n-\n-                    err.span_label(field.ident.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n-\n-                    err.emit();\n-                } else {\n-                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n-                }\n-\n-                tcx.types.err\n-            };\n-\n-            // Make sure to give a type to the field even if there's\n-            // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n-        }\n-\n-        // Make sure the programmer specified correct number of fields.\n-        if kind_name == \"union\" {\n-            if ast_fields.len() != 1 {\n-                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n-            }\n-        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n-            let len = remaining_fields.len();\n-\n-            let mut displayable_field_names = remaining_fields\n-                                              .keys()\n-                                              .map(|ident| ident.as_str())\n-                                              .collect::<Vec<_>>();\n-\n-            displayable_field_names.sort();\n-\n-            let truncated_fields_error = if len <= 3 {\n-                String::new()\n-            } else {\n-                format!(\" and {} other field{}\", (len - 3), if len - 3 == 1 {\"\"} else {\"s\"})\n-            };\n-\n-            let remaining_fields_names = displayable_field_names.iter().take(3)\n-                                        .map(|n| format!(\"`{}`\", n))\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \");\n-\n-            struct_span_err!(tcx.sess, span, E0063,\n-                             \"missing field{} {}{} in initializer of `{}`\",\n-                             if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n-                             remaining_fields_names,\n-                             truncated_fields_error,\n-                             adt_ty)\n-                .span_label(span, format!(\"missing {}{}\",\n-                                          remaining_fields_names,\n-                                          truncated_fields_error))\n-                .emit();\n-        }\n-        error_happened\n-    }\n-\n-    fn check_struct_fields_on_error(\n-        &self,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n-    ) {\n-        for field in fields {\n-            self.check_expr(&field.expr);\n-        }\n-        if let Some(ref base) = *base_expr {\n-            self.check_expr(&base);\n-        }\n-    }\n-\n     pub fn check_struct_path(&self,\n                              qpath: &QPath,\n                              hir_id: hir::HirId)"}]}