{"sha": "a202dcccca09e49f65251f012f55c93f92c869a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDJkY2NjY2EwOWU0OWY2NTI1MWYwMTJmNTVjOTNmOTJjODY5YTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T04:10:47Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-24T04:10:47Z"}, "message": "Merge pull request #4594 from thestinger/map\n\nmore work on the map trait and TreeMap/LinearMap", "tree": {"sha": "7fc1ec5d206e1c862b72f7bdbcd697770cd4dfe5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fc1ec5d206e1c862b72f7bdbcd697770cd4dfe5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a202dcccca09e49f65251f012f55c93f92c869a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a202dcccca09e49f65251f012f55c93f92c869a7", "html_url": "https://github.com/rust-lang/rust/commit/a202dcccca09e49f65251f012f55c93f92c869a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a202dcccca09e49f65251f012f55c93f92c869a7/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e29e21281512f71d33a87995002bd438c5b42f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e29e21281512f71d33a87995002bd438c5b42f1", "html_url": "https://github.com/rust-lang/rust/commit/0e29e21281512f71d33a87995002bd438c5b42f1"}, {"sha": "bba5520d62e0c662ec2e2ccabe725294e17e9738", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba5520d62e0c662ec2e2ccabe725294e17e9738", "html_url": "https://github.com/rust-lang/rust/commit/bba5520d62e0c662ec2e2ccabe725294e17e9738"}], "stats": {"total": 622, "additions": 327, "deletions": 295}, "files": [{"sha": "193adc10997ae5f5406f8f425edaedf22e143d3d", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -52,7 +52,7 @@ use core::*;\n use core::dvec::DVec;\n use core::io::WriterUtil;\n use core::result::{Ok, Err};\n-use core::send_map::linear::LinearMap;\n+use core::hashmap::linear::LinearMap;\n use std::getopts::{optflag, optopt, opt_present};\n use std::map::HashMap;\n use std::{map, json, tempfile, term, sort, getopts};\n@@ -465,19 +465,19 @@ fn parse_source(name: ~str, j: &json::Json) -> @Source {\n \n     match *j {\n         json::Object(j) => {\n-            let mut url = match j.find(&~\"url\") {\n+            let mut url = match j.find_copy(&~\"url\") {\n                 Some(json::String(u)) => u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n-            let method = match j.find(&~\"method\") {\n+            let method = match j.find_copy(&~\"method\") {\n                 Some(json::String(u)) => u,\n                 _ => assume_source_method(url)\n             };\n-            let key = match j.find(&~\"key\") {\n+            let key = match j.find_copy(&~\"key\") {\n                 Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n-            let keyfp = match j.find(&~\"keyfp\") {\n+            let keyfp = match j.find_copy(&~\"keyfp\") {\n                 Some(json::String(u)) => Some(u),\n                 _ => None\n             };\n@@ -512,7 +512,7 @@ fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n }\n \n fn load_one_source_package(src: @Source, p: &json::Object) {\n-    let name = match p.find(&~\"name\") {\n+    let name = match p.find_copy(&~\"name\") {\n         Some(json::String(n)) => {\n             if !valid_pkg_name(n) {\n                 warn(~\"malformed source json: \"\n@@ -529,7 +529,7 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         }\n     };\n \n-    let uuid = match p.find(&~\"uuid\") {\n+    let uuid = match p.find_copy(&~\"uuid\") {\n         Some(json::String(n)) => {\n             if !is_uuid(n) {\n                 warn(~\"malformed source json: \"\n@@ -545,15 +545,15 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         }\n     };\n \n-    let url = match p.find(&~\"url\") {\n+    let url = match p.find_copy(&~\"url\") {\n         Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n-    let method = match p.find(&~\"method\") {\n+    let method = match p.find_copy(&~\"method\") {\n         Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \"\n@@ -562,13 +562,13 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         }\n     };\n \n-    let reference = match p.find(&~\"ref\") {\n+    let reference = match p.find_copy(&~\"ref\") {\n         Some(json::String(n)) => Some(n),\n         _ => None\n     };\n \n     let mut tags = ~[];\n-    match p.find(&~\"tags\") {\n+    match p.find_copy(&~\"tags\") {\n         Some(json::List(js)) => {\n           for js.each |j| {\n                 match *j {\n@@ -580,7 +580,7 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         _ => ()\n     }\n \n-    let description = match p.find(&~\"description\") {\n+    let description = match p.find_copy(&~\"description\") {\n         Some(json::String(n)) => n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n@@ -1619,7 +1619,7 @@ fn dump_cache(c: &Cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n-    let _root = json::Object(~LinearMap());\n+    let _root = json::Object(~LinearMap::new());\n \n     if os::path_exists(&out) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n@@ -1640,10 +1640,10 @@ fn dump_sources(c: &Cargo) {\n \n     match io::buffered_file_writer(&out) {\n         result::Ok(writer) => {\n-            let mut hash = ~LinearMap();\n+            let mut hash = ~LinearMap::new();\n \n             for c.sources.each |k, v| {\n-                let mut chash = ~LinearMap();\n+                let mut chash = ~LinearMap::new();\n \n                 chash.insert(~\"url\", json::String(v.url));\n                 chash.insert(~\"method\", json::String(v.method));"}, {"sha": "272a2efc035538a0b7e9c9e2bf52ee60204249ea", "filename": "src/libcore/container.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -13,6 +13,8 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use option::Option;\n+\n pub trait Container {\n     /// Return the number of elements in the container\n     pure fn len(&self) -> uint;\n@@ -39,6 +41,9 @@ pub trait Map<K, V>: Mutable {\n     /// Visit all values\n     pure fn each_value(&self, f: fn(&V) -> bool);\n \n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &K) -> Option<&self/V>;\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map."}, {"sha": "20057fa10385386f09803cf4f28cc0400e860a5c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -138,7 +138,7 @@ pub mod dvec_iter;\n pub mod dlist;\n #[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n pub mod dlist_iter;\n-pub mod send_map;\n+pub mod hashmap;\n \n \n /* Tasks and communication */"}, {"sha": "d27681d46300b63d7eeb94ead8bf6ca33d9695ed", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -44,7 +44,7 @@ use io;\n use libc::{size_t, uintptr_t};\n use option::{None, Option, Some};\n use ptr;\n-use send_map::linear::LinearSet;\n+use hashmap::linear::LinearSet;\n use stackwalk;\n use sys;\n "}, {"sha": "40b80bddf84ad185b47a440f5a940bd399d680e6", "filename": "src/libcore/hashmap.rs", "status": "renamed", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -8,11 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Sendable hash maps.  Very much a work in progress.\n-\n-*/\n+//! Sendable hash maps.\n \n // NB: transitionary, de-mode-ing.\n #[forbid(deprecated_mode)];\n@@ -102,9 +98,7 @@ pub mod linear {\n                             idx: uint,\n                             len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n-            unsafe{ // argh. log not considered pure.\n-                debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n-            }\n+            debug!(\"next_bucket(%?, %?) = %?\", idx, len_buckets, n);\n             return n;\n         }\n \n@@ -259,11 +253,15 @@ pub mod linear {\n     }\n \n     impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Container {\n+        /// Return the number of elements in the map\n         pure fn len(&self) -> uint { self.size }\n+\n+        /// Return true if the map contains no elements\n         pure fn is_empty(&self) -> bool { self.len() == 0 }\n     }\n \n     impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Mutable {\n+        /// Clear the map, removing all key-value pairs.\n         fn clear(&mut self) {\n             for uint::range(0, self.buckets.len()) |idx| {\n                 self.buckets[idx] = None;\n@@ -273,13 +271,15 @@ pub mod linear {\n     }\n \n     impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Map<K, V> {\n+        /// Return true if the map contains a value for the specified key\n         pure fn contains_key(&self, k: &K) -> bool {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(_) => {true}\n                 TableFull | FoundHole(_) => {false}\n             }\n         }\n \n+        /// Visit all key-value pairs\n         pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n             for vec::each(self.buckets) |slot| {\n                 let mut broke = false;\n@@ -292,14 +292,40 @@ pub mod linear {\n             }\n         }\n \n+        /// Visit all keys\n         pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n+        /// Visit all values\n         pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n \n+        /// Return the value corresponding to the key in the map\n+        pure fn find(&self, k: &K) -> Option<&self/V> {\n+            match self.bucket_for_key(self.buckets, k) {\n+                FoundEntry(idx) => {\n+                    match self.buckets[idx] {\n+                        Some(ref bkt) => {\n+                            // FIXME(#3148)---should be inferred\n+                            let bkt: &self/Bucket<K,V> = bkt;\n+                            Some(&bkt.value)\n+                        }\n+                        None => {\n+                            fail ~\"LinearMap::find: internal logic error\"\n+                        }\n+                    }\n+                }\n+                TableFull | FoundHole(_) => {\n+                    None\n+                }\n+            }\n+        }\n+\n+        /// Insert a key-value pair into the map. An existing value for a\n+        /// key is replaced by the new value. Return true if the key did\n+        /// not already exist in the map.\n         fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n@@ -315,6 +341,8 @@ pub mod linear {\n             self.insert_internal(hash, move k, move v)\n         }\n \n+        /// Remove a key-value pair from the map. Return true if the key\n+        /// was present in the map, otherwise false.\n         fn remove(&mut self, k: &K) -> bool {\n             match self.pop(k) {\n                 Some(_) => true,\n@@ -324,6 +352,10 @@ pub mod linear {\n     }\n \n     impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n+        static fn new() -> LinearMap<K, V> {\n+            linear_map_with_capacity(INITIAL_CAPACITY)\n+        }\n+\n         fn pop(&mut self, k: &K) -> Option<V> {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.pop_internal(hash, k)\n@@ -369,36 +401,16 @@ pub mod linear {\n             }\n         }\n \n-        pure fn find_ref(&self, k: &K) -> Option<&self/V> {\n-            match self.bucket_for_key(self.buckets, k) {\n-                FoundEntry(idx) => {\n-                    match self.buckets[idx] {\n-                        Some(ref bkt) => {\n-                            // FIXME(#3148)---should be inferred\n-                            let bkt: &self/Bucket<K,V> = bkt;\n-                            Some(&bkt.value)\n-                        }\n-                        None => {\n-                            fail ~\"LinearMap::find: internal logic error\"\n-                        }\n-                    }\n-                }\n-                TableFull | FoundHole(_) => {\n-                    None\n-                }\n-            }\n-        }\n-\n-        pure fn get_ref(&self, k: &K) -> &self/V {\n-            match self.find_ref(k) {\n+        pure fn get(&self, k: &K) -> &self/V {\n+            match self.find(k) {\n                 Some(v) => v,\n                 None => fail fmt!(\"No entry found for key: %?\", k),\n             }\n         }\n     }\n \n-    impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K,V> {\n-        pure fn find(&const self, k: &K) -> Option<V> {\n+    impl<K:Hash IterBytes Eq, V: Copy> LinearMap<K, V> {\n+        pure fn find_copy(&const self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n                 FoundEntry(idx) => {\n                     // FIXME (#3148): Once we rewrite found_entry, this\n@@ -413,22 +425,14 @@ pub mod linear {\n                 }\n             }\n         }\n-\n-        pure fn get(&const self, k: &K) -> V {\n-            let value = self.find(k);\n-            if value.is_none() {\n-                fail fmt!(\"No entry found for key: %?\", k);\n-            }\n-            option::unwrap(move value)\n-        }\n     }\n \n     impl<K:Hash IterBytes Eq, V: Eq> LinearMap<K, V>: Eq {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n             for self.each |key, value| {\n-                match other.find_ref(key) {\n+                match other.find(key) {\n                     None => return false,\n                     Some(v) => if value != v { return false },\n                 }\n@@ -462,11 +466,15 @@ pub mod linear {\n     }\n \n     impl <T: Hash IterBytes Eq> LinearSet<T>: Container {\n+        /// Return the number of elements in the set\n         pure fn len(&self) -> uint { self.map.len() }\n+\n+        /// Return true if the set contains no elements\n         pure fn is_empty(&self) -> bool { self.map.is_empty() }\n     }\n \n     impl <T: Hash IterBytes Eq> LinearSet<T>: Mutable {\n+        /// Clear the set, removing all values.\n         fn clear(&mut self) { self.map.clear() }\n     }\n \n@@ -494,26 +502,26 @@ pub mod linear {\n #[test]\n pub mod test {\n     use option::{None, Some};\n-    use send_map::linear::LinearMap;\n-    use send_map::linear;\n+    use hashmap::linear::LinearMap;\n+    use hashmap::linear;\n     use uint;\n \n     #[test]\n     pub fn inserts() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n         assert m.insert(1, 2);\n         assert m.insert(2, 4);\n-        assert m.get(&1) == 2;\n-        assert m.get(&2) == 4;\n+        assert *m.get(&1) == 2;\n+        assert *m.get(&2) == 4;\n     }\n \n     #[test]\n     pub fn overwrite() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n         assert m.insert(1, 2);\n-        assert m.get(&1) == 2;\n+        assert *m.get(&1) == 2;\n         assert !m.insert(1, 3);\n-        assert m.get(&1) == 3;\n+        assert *m.get(&1) == 3;\n     }\n \n     #[test]\n@@ -522,9 +530,9 @@ pub mod test {\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n         assert m.insert(9, 4);\n-        assert m.get(&9) == 4;\n-        assert m.get(&5) == 3;\n-        assert m.get(&1) == 2;\n+        assert *m.get(&9) == 4;\n+        assert *m.get(&5) == 3;\n+        assert *m.get(&1) == 2;\n     }\n \n     #[test]\n@@ -534,8 +542,8 @@ pub mod test {\n         assert m.insert(5, 3);\n         assert m.insert(9, 4);\n         assert m.remove(&1);\n-        assert m.get(&9) == 4;\n-        assert m.get(&5) == 3;\n+        assert *m.get(&9) == 4;\n+        assert *m.get(&5) == 3;\n     }\n \n     #[test]\n@@ -549,33 +557,33 @@ pub mod test {\n \n     #[test]\n     pub fn pops() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n         m.insert(1, 2);\n         assert m.pop(&1) == Some(2);\n         assert m.pop(&1) == None;\n     }\n \n     #[test]\n     pub fn swaps() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n         assert m.swap(1, 2) == None;\n         assert m.swap(1, 3) == Some(2);\n         assert m.swap(1, 4) == Some(3);\n     }\n \n     #[test]\n     pub fn consumes() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n         assert m.insert(1, 2);\n         assert m.insert(2, 3);\n-        let mut m2 = ~LinearMap();\n+        let mut m2 = LinearMap::new();\n         do m.consume |k, v| {\n             m2.insert(k, v);\n         }\n         assert m.len() == 0;\n         assert m2.len() == 2;\n-        assert m2.find(&1) == Some(2);\n-        assert m2.find(&2) == Some(3);\n+        assert m2.find_copy(&1) == Some(2);\n+        assert m2.find_copy(&2) == Some(3);\n     }\n \n     #[test]\n@@ -593,24 +601,24 @@ pub mod test {\n     }\n \n     #[test]\n-    pub fn find_ref() {\n-        let mut m = ~LinearMap();\n-        assert m.find_ref(&1).is_none();\n+    pub fn find() {\n+        let mut m = LinearMap::new();\n+        assert m.find(&1).is_none();\n         m.insert(1, 2);\n-        match m.find_ref(&1) {\n+        match m.find(&1) {\n             None => fail,\n             Some(v) => assert *v == 2\n         }\n     }\n \n     #[test]\n     pub fn test_eq() {\n-        let mut m1 = ~LinearMap();\n+        let mut m1 = LinearMap::new();\n         m1.insert(1, 2);\n         m1.insert(2, 3);\n         m1.insert(3, 4);\n \n-        let mut m2 = ~LinearMap();\n+        let mut m2 = LinearMap::new();\n         m2.insert(1, 2);\n         m2.insert(2, 3);\n \n@@ -623,7 +631,7 @@ pub mod test {\n \n     #[test]\n     pub fn test_expand() {\n-        let mut m = ~LinearMap();\n+        let mut m = LinearMap::new();\n \n         assert m.len() == 0;\n         assert m.is_empty();", "previous_filename": "src/libcore/send_map.rs"}, {"sha": "4e9a0e43b3661ec12b0423f5ac24caf39321eb9a", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -81,7 +81,7 @@ use pipes;\n use prelude::*;\n use private;\n use ptr;\n-use send_map;\n+use hashmap::linear::LinearSet;\n use task::local_data_priv::{local_get, local_set};\n use task::rt::rust_task;\n use task::rt::rust_closure;\n@@ -96,10 +96,10 @@ macro_rules! move_it (\n     { $x:expr } => ( unsafe { let y = move *ptr::addr_of(&($x)); move y } )\n )\n \n-type TaskSet = send_map::linear::LinearSet<*rust_task>;\n+type TaskSet = LinearSet<*rust_task>;\n \n fn new_taskset() -> TaskSet {\n-    send_map::linear::LinearSet::new()\n+    LinearSet::new()\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task);"}, {"sha": "aa7f3b71a500c498aa4db6053a7abaf4d38f5a9f", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -30,7 +30,7 @@ use util::common::indenter;\n use util::ppaux::{expr_repr, region_to_str};\n \n use core::dvec;\n-use core::send_map::linear::LinearSet;\n+use core::hashmap::linear::LinearSet;\n use core::vec;\n use std::map::HashMap;\n use syntax::ast::{m_const, m_imm, m_mutbl};"}, {"sha": "b0c98cfa2b17e6a628b12f9e0c315f3c1b30a0c2", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -57,7 +57,7 @@ use util::ppaux::ty_to_str;\n \n use core::dvec::DVec;\n use core::result::Ok;\n-use core::send_map;\n+use core::hashmap::linear::LinearSet;\n use core::uint::range;\n use core::uint;\n use core::vec::{len, push};\n@@ -693,7 +693,7 @@ impl CoherenceChecker {\n \n         let tcx = self.crate_context.tcx;\n \n-        let mut provided_names = send_map::linear::LinearSet::new();\n+        let mut provided_names = LinearSet::new();\n         // Implemented methods\n         for uint::range(0, all_methods.len()) |i| {\n             provided_names.insert(all_methods[i].ident);"}, {"sha": "ed3dbb48b2aab184ad2003a60046fb502b270de5", "filename": "src/libstd/json.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -24,7 +24,7 @@ use core::float;\n use core::io::{WriterUtil, ReaderUtil};\n use core::io;\n use core::prelude::*;\n-use core::send_map::linear;\n+use core::hashmap::linear::LinearMap;\n use core::str;\n use core::to_str;\n use core::vec;\n@@ -40,7 +40,7 @@ pub enum Json {\n }\n \n pub type List = ~[Json];\n-pub type Object = linear::LinearMap<~str, Json>;\n+pub type Object = LinearMap<~str, Json>;\n \n pub struct Error {\n     line: uint,\n@@ -673,7 +673,7 @@ priv impl Parser {\n         self.bump();\n         self.parse_whitespace();\n \n-        let mut values = ~linear::LinearMap();\n+        let mut values = ~LinearMap::new();\n \n         if self.ch == '}' {\n           self.bump();\n@@ -913,7 +913,7 @@ pub impl Decoder: serialize::Decoder {\n                 // FIXME(#3148) This hint should not be necessary.\n                 let obj: &self/~Object = obj;\n \n-                match obj.find_ref(&name.to_owned()) {\n+                match obj.find(&name.to_owned()) {\n                     None => fail fmt!(\"no such field: %s\", name),\n                     Some(json) => {\n                         self.stack.push(json);\n@@ -971,7 +971,7 @@ impl Json : Eq {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n                             for d0.each |k, v0| {\n-                                match d1.find_ref(k) {\n+                                match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n                                 }\n@@ -1177,9 +1177,9 @@ impl <A: ToJson> ~[A]: ToJson {\n     fn to_json() -> Json { List(self.map(|elt| elt.to_json())) }\n }\n \n-impl <A: ToJson Copy> linear::LinearMap<~str, A>: ToJson {\n+impl <A: ToJson Copy> LinearMap<~str, A>: ToJson {\n     fn to_json() -> Json {\n-        let mut d = linear::LinearMap();\n+        let mut d = LinearMap::new();\n         for self.each() |key, value| {\n             d.insert(copy *key, value.to_json());\n         }\n@@ -1190,7 +1190,7 @@ impl <A: ToJson Copy> linear::LinearMap<~str, A>: ToJson {\n /*\n impl <A: ToJson Copy> @std::map::HashMap<~str, A>: ToJson {\n     fn to_json() -> Json {\n-        let mut d = linear::LinearMap();\n+        let mut d = LinearMap::new();\n         for self.each_ref |key, value| {\n             d.insert(copy *key, value.to_json());\n         }\n@@ -1225,10 +1225,10 @@ mod tests {\n     use json::*;\n \n     use core::result;\n-    use core::send_map::linear;\n+    use core::hashmap::linear::LinearMap;\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n-        let mut d = ~linear::LinearMap();\n+        let mut d = ~LinearMap::new();\n \n         for items.each |item| {\n             match *item {"}, {"sha": "4c05dd154cad6d625d6c02aa7de7e271e08901f9", "filename": "src/libstd/map.rs", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -19,7 +19,6 @@ use core::ops;\n use core::to_str::ToStr;\n use core::mutable::Mut;\n use core::prelude::*;\n-use core::send_map::linear::LinearMap;\n use core::to_bytes::IterBytes;\n use core::uint;\n use core::vec;\n@@ -500,121 +499,6 @@ pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n     map\n }\n \n-// FIXME #4431: Transitional\n-impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n-    Map<K, V> {\n-    pure fn size() -> uint {\n-        unsafe {\n-            do self.borrow_const |p| {\n-                p.len()\n-            }\n-        }\n-    }\n-\n-    fn insert(key: K, value: V) -> bool {\n-        do self.borrow_mut |p| {\n-            p.insert(key, value)\n-        }\n-    }\n-\n-    pure fn contains_key(key: K) -> bool {\n-        do self.borrow_const |p| {\n-            p.contains_key(&key)\n-        }\n-    }\n-\n-    pure fn contains_key_ref(key: &K) -> bool {\n-        do self.borrow_const |p| {\n-            p.contains_key(key)\n-        }\n-    }\n-\n-    pure fn get(key: K) -> V {\n-        do self.borrow_const |p| {\n-            p.get(&key)\n-        }\n-    }\n-\n-    pure fn find(key: K) -> Option<V> {\n-        unsafe {\n-            do self.borrow_const |p| {\n-                p.find(&key)\n-            }\n-        }\n-    }\n-\n-    fn update_with_key(key: K, newval: V, ff: fn(K, V, V) -> V) -> bool {\n-        match self.find(key) {\n-            None            => return self.insert(key, newval),\n-            Some(copy orig) => return self.insert(key, ff(key, orig, newval))\n-        }\n-    }\n-\n-    fn update(key: K, newval: V, ff: fn(V, V) -> V) -> bool {\n-        return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n-    }\n-\n-    fn remove(key: K) -> bool {\n-        do self.borrow_mut |p| {\n-            p.remove(&key)\n-        }\n-    }\n-\n-    fn clear() {\n-        do self.borrow_mut |p| {\n-            p.clear()\n-        }\n-    }\n-\n-    pure fn each(op: fn(key: K, value: V) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each(|k, v| op(*k, *v))\n-            }\n-        }\n-    }\n-\n-    pure fn each_key(op: fn(key: K) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each_key(|k| op(*k))\n-            }\n-        }\n-    }\n-\n-    pure fn each_value(op: fn(value: V) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each_value(|v| op(*v))\n-            }\n-        }\n-    }\n-\n-    pure fn each_ref(op: fn(key: &K, value: &V) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each(op)\n-            }\n-        }\n-    }\n-\n-    pure fn each_key_ref(op: fn(key: &K) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each_key(op)\n-            }\n-        }\n-    }\n-\n-    pure fn each_value_ref(op: fn(value: &V) -> bool) {\n-        unsafe {\n-            do self.borrow_imm |p| {\n-                p.each_value(op)\n-            }\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use map;"}, {"sha": "0e352c78611f093aa25edb64331b9b1e9d126e94", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -11,17 +11,13 @@\n //! Types/fns concerning URLs (see RFC 3986)\n #[forbid(deprecated_mode)];\n \n-use map;\n-use map::HashMap;\n-\n use core::cmp::Eq;\n use core::dvec::DVec;\n use core::from_str::FromStr;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n use core::prelude::*;\n-use core::send_map::linear::LinearMap;\n-use core::send_map;\n+use core::hashmap::linear::LinearMap;\n use core::str;\n use core::to_bytes::IterBytes;\n use core::to_bytes;\n@@ -244,11 +240,9 @@ pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n-pub fn decode_form_urlencoded(\n-    s: &[u8]\n-) -> send_map::linear::LinearMap<~str, ~[~str]> {\n+pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n     do io::with_bytes_reader(s) |rdr| {\n-        let mut m = LinearMap();\n+        let mut m = LinearMap::new();\n         let mut key = ~\"\";\n         let mut value = ~\"\";\n         let mut parsing_key = true;\n@@ -1061,18 +1055,18 @@ mod tests {\n \n     #[test]\n     fn test_encode_form_urlencoded() {\n-        let mut m = LinearMap();\n+        let mut m = LinearMap::new();\n         assert encode_form_urlencoded(&m) == ~\"\";\n \n         m.insert(~\"\", ~[]);\n         m.insert(~\"foo\", ~[]);\n         assert encode_form_urlencoded(&m) == ~\"\";\n \n-        let mut m = LinearMap();\n+        let mut m = LinearMap::new();\n         m.insert(~\"foo\", ~[~\"bar\", ~\"123\"]);\n         assert encode_form_urlencoded(&m) == ~\"foo=bar&foo=123\";\n \n-        let mut m = LinearMap();\n+        let mut m = LinearMap::new();\n         m.insert(~\"foo bar\", ~[~\"abc\", ~\"12 = 34\"]);\n         assert encode_form_urlencoded(&m) == ~\"foo+bar=abc&foo+bar=12+%3D+34\";\n     }"}, {"sha": "953972541719e81977c2bbe71c37365d4c6b3ffd", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -100,6 +100,26 @@ impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n     /// Visit all values in order\n     pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n \n+    /// Return the value corresponding to the key in the map\n+    pure fn find(&self, key: &K) -> Option<&self/V> {\n+        let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n+        loop {\n+            match *current {\n+              Some(ref r) => {\n+                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n+                if *key < r.key {\n+                    current = &r.left;\n+                } else if r.key < *key {\n+                    current = &r.right;\n+                } else {\n+                    return Some(&r.value);\n+                }\n+              }\n+              None => return None\n+            }\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -122,7 +142,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&K, &V) -> bool) {\n         each_reverse(&self.root, f);\n@@ -138,26 +157,6 @@ impl <K: Ord, V> TreeMap<K, V> {\n         self.each_reverse(|_, v| f(v))\n     }\n \n-    /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&self/V> {\n-        let mut current: &self/Option<~TreeNode<K, V>> = &self.root;\n-        loop {\n-            match *current {\n-              Some(ref r) => {\n-                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n-                if *key < r.key {\n-                    current = &r.left;\n-                } else if r.key < *key {\n-                    current = &r.right;\n-                } else {\n-                    return Some(&r.value);\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n-    }\n-\n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n@@ -209,10 +208,10 @@ impl <T: Eq Ord> TreeSet<T>: Eq {\n }\n \n impl <T: Ord> TreeSet<T>: Container {\n-    /// Return the number of elements in the map\n+    /// Return the number of elements in the set\n     pure fn len(&self) -> uint { self.map.len() }\n \n-    /// Return true if the map contains no elements\n+    /// Return true if the set contains no elements\n     pure fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n "}, {"sha": "9572c07e715c498423816d00806490f1e20e0762", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -22,7 +22,7 @@ use core::pipes::{recv, oneshot, PortOne, send_one};\n use core::prelude::*;\n use core::result;\n use core::run;\n-use core::send_map::linear::LinearMap;\n+use core::hashmap::linear::LinearMap;\n use core::task;\n use core::to_bytes;\n use core::mutable::Mut;\n@@ -152,7 +152,7 @@ pub impl<S: Encoder> WorkMap: Encodable<S> {\n pub impl<D: Decoder> WorkMap: Decodable<D> {\n     static fn decode(&self, d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n-        let mut w = LinearMap();\n+        let mut w = LinearMap::new();\n         for v.each |&(k,v)| {\n             w.insert(copy k, copy v);\n         }\n@@ -173,7 +173,7 @@ impl Database {\n                declared_inputs: &WorkMap) ->\n         Option<(WorkMap, WorkMap, ~str)> {\n         let k = json_encode(&(fn_name, declared_inputs));\n-        match self.db_cache.find(&k) {\n+        match self.db_cache.find_copy(&k) {\n             None => None,\n             Some(v) => Some(json_decode(v))\n         }\n@@ -297,7 +297,7 @@ impl @Mut<Prep> : TPrep {\n                 name: &str, val: &str) -> bool {\n         do self.borrow_imm |p| {\n             let k = kind.to_owned();\n-            let f = (p.ctxt.freshness.get(&k))(name, val);\n+            let f = (*p.ctxt.freshness.get(&k))(name, val);\n             do p.ctxt.logger.borrow_imm |lg| {\n                 if f {\n                     lg.info(fmt!(\"%s %s:%s is fresh\",\n@@ -348,8 +348,8 @@ impl @Mut<Prep> : TPrep {\n                     let blk = blk.unwrap();\n                     let chan = ~mut Some(move chan);\n                     do task::spawn |move blk, move chan| {\n-                        let exe = Exec { discovered_inputs: LinearMap(),\n-                                         discovered_outputs: LinearMap() };\n+                        let exe = Exec{discovered_inputs: LinearMap::new(),\n+                                       discovered_outputs: LinearMap::new()};\n                         let chan = option::swap_unwrap(&mut *chan);\n                         let v = blk(&exe);\n                         send_one(move chan, (move exe, move v));\n@@ -411,10 +411,10 @@ fn test() {\n     use io::WriterUtil;\n \n     let db = @Mut(Database { db_filename: Path(\"db.json\"),\n-                             db_cache: LinearMap(),\n+                             db_cache: LinearMap::new(),\n                              db_dirty: false });\n     let lg = @Mut(Logger { a: () });\n-    let cfg = @LinearMap();\n+    let cfg = @LinearMap::new();\n     let cx = @Context::new(db, lg, cfg);\n     let w:Work<~str> = do cx.prep(\"test1\") |prep| {\n         let pth = Path(\"foo.c\");"}, {"sha": "d401b594c4c069d7b2cff6b5b5de8f383cae7eea", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 176, "deletions": 34, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -8,16 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n-\n-\n-\n-*/\n-\n extern mod std;\n use std::map;\n-use core::mutable::Mut;\n-use core::send_map::linear::*;\n+use std::treemap::TreeMap;\n+use core::hashmap::linear::*;\n use core::io::WriterUtil;\n \n struct Results {\n@@ -38,13 +32,10 @@ fn timed(result: &mut float,\n     *result = (end - start);\n }\n \n-fn int_benchmarks<M: map::Map<uint, uint>>(make_map: fn() -> M,\n-                                           rng: @rand::Rng,\n-                                           num_keys: uint,\n-                                           results: &mut Results) {\n+fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         do timed(&mut results.sequential_ints) {\n             for uint::range(0, num_keys) |i| {\n                 map.insert(i, i+1);\n@@ -57,7 +48,7 @@ fn int_benchmarks<M: map::Map<uint, uint>>(make_map: fn() -> M,\n     }\n \n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         do timed(&mut results.random_ints) {\n             for uint::range(0, num_keys) |i| {\n                 map.insert(rng.next() as uint, i);\n@@ -66,7 +57,7 @@ fn int_benchmarks<M: map::Map<uint, uint>>(make_map: fn() -> M,\n     }\n \n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         for uint::range(0, num_keys) |i| {\n             map.insert(i, i);;\n         }\n@@ -79,12 +70,9 @@ fn int_benchmarks<M: map::Map<uint, uint>>(make_map: fn() -> M,\n     }\n }\n \n-fn str_benchmarks<M: map::Map<~str, uint>>(make_map: fn() -> M,\n-                                           rng: @rand::Rng,\n-                                           num_keys: uint,\n-                                           results: &mut Results) {\n+fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         do timed(&mut results.sequential_strings) {\n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i, 10);\n@@ -99,7 +87,7 @@ fn str_benchmarks<M: map::Map<~str, uint>>(make_map: fn() -> M,\n     }\n \n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         do timed(&mut results.random_strings) {\n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(rng.next() as uint, 10);\n@@ -109,7 +97,7 @@ fn str_benchmarks<M: map::Map<~str, uint>>(make_map: fn() -> M,\n     }\n \n     {\n-        let map = make_map();\n+        let map = map::HashMap();\n         for uint::range(0, num_keys) |i| {\n             map.insert(uint::to_str(i, 10), i);\n         }\n@@ -121,6 +109,158 @@ fn str_benchmarks<M: map::Map<~str, uint>>(make_map: fn() -> M,\n     }\n }\n \n+fn linear_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n+    {\n+        let mut map = LinearMap::new();\n+        do timed(&mut results.sequential_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(i, i+1);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                assert map.find(&i).unwrap() == &(i+1);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = LinearMap::new();\n+        do timed(&mut results.random_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(rng.next() as uint, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = LinearMap::new();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(i, i);;\n+        }\n+\n+        do timed(&mut results.delete_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(&i);\n+            }\n+        }\n+    }\n+}\n+\n+fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n+    {\n+        let mut map = LinearMap::new();\n+        do timed(&mut results.sequential_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                map.insert(s, i);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                assert map.find(&s).unwrap() == &i;\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = LinearMap::new();\n+        do timed(&mut results.random_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(rng.next() as uint, 10);\n+                map.insert(s, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = LinearMap::new();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(uint::to_str(i, 10), i);\n+        }\n+        do timed(&mut results.delete_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(&uint::to_str(i, 10));\n+            }\n+        }\n+    }\n+}\n+\n+fn tree_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n+    {\n+        let mut map = TreeMap::new();\n+        do timed(&mut results.sequential_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(i, i+1);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                assert map.find(&i).unwrap() == &(i+1);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = TreeMap::new();\n+        do timed(&mut results.random_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                map.insert(rng.next() as uint, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = TreeMap::new();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(i, i);;\n+        }\n+\n+        do timed(&mut results.delete_ints) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(&i);\n+            }\n+        }\n+    }\n+}\n+\n+fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n+    {\n+        let mut map = TreeMap::new();\n+        do timed(&mut results.sequential_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                map.insert(s, i);\n+            }\n+\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(i, 10);\n+                assert map.find(&s).unwrap() == &i;\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = TreeMap::new();\n+        do timed(&mut results.random_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                let s = uint::to_str(rng.next() as uint, 10);\n+                map.insert(s, i);\n+            }\n+        }\n+    }\n+\n+    {\n+        let mut map = TreeMap::new();\n+        for uint::range(0, num_keys) |i| {\n+            map.insert(uint::to_str(i, 10), i);\n+        }\n+        do timed(&mut results.delete_strings) {\n+            for uint::range(0, num_keys) |i| {\n+                assert map.remove(&uint::to_str(i, 10));\n+            }\n+        }\n+    }\n+}\n+\n fn write_header(header: &str) {\n     io::stdout().write_str(header);\n     io::stdout().write_str(\"\\n\");\n@@ -167,22 +307,24 @@ fn main() {\n     {\n         let rng = rand::seeded_rng(&seed);\n         let mut results = empty_results();\n-        int_benchmarks::<map::HashMap<uint, uint>>(\n-            map::HashMap, rng, num_keys, &mut results);\n-        str_benchmarks::<map::HashMap<~str, uint>>(\n-            map::HashMap, rng, num_keys, &mut results);\n-        write_results(\"libstd::map::hashmap\", &results);\n+        old_int_benchmarks(rng, num_keys, &mut results);\n+        old_str_benchmarks(rng, num_keys, &mut results);\n+        write_results(\"std::map::HashMap\", &results);\n+    }\n+\n+    {\n+        let rng = rand::seeded_rng(&seed);\n+        let mut results = empty_results();\n+        linear_int_benchmarks(rng, num_keys, &mut results);\n+        linear_str_benchmarks(rng, num_keys, &mut results);\n+        write_results(\"core::hashmap::linear::LinearMap\", &results);\n     }\n \n     {\n         let rng = rand::seeded_rng(&seed);\n         let mut results = empty_results();\n-        int_benchmarks::<@Mut<LinearMap<uint, uint>>>(\n-            || @Mut(LinearMap()),\n-            rng, num_keys, &mut results);\n-        str_benchmarks::<@Mut<LinearMap<~str, uint>>>(\n-            || @Mut(LinearMap()),\n-            rng, num_keys, &mut results);\n-        write_results(\"libstd::map::hashmap\", &results);\n+        tree_int_benchmarks(rng, num_keys, &mut results);\n+        tree_str_benchmarks(rng, num_keys, &mut results);\n+        write_results(\"std::treemap::TreeMap\", &results);\n     }\n }"}, {"sha": "c360a184d01ae7b516ecb8c013a699473fa036ce", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -23,7 +23,7 @@ enum object\n \n fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n-    match table.find(&key)\n+    match table.find_copy(&key)\n     {\n         option::Some(std::json::String(copy s)) =>\n         {"}, {"sha": "253e0bd633b35ee0db1b5aaa9716c278d2c18b4d", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a202dcccca09e49f65251f012f55c93f92c869a7/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=a202dcccca09e49f65251f012f55c93f92c869a7", "patch": "@@ -11,7 +11,7 @@\n // xfail-test\n extern mod std;\n \n-use send_map::linear;\n+use hashmap::linear;\n use std::json;\n use std::serialization::{Deserializable, deserialize};\n "}]}