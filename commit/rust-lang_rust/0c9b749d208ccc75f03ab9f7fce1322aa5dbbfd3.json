{"sha": "0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOWI3NDlkMjA4Y2NjNzVmMDNhYjlmN2ZjZTEzMjJhYTVkYmJmZDM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-30T01:38:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-30T01:48:15Z"}, "message": "Enable kind checking on typarams, fix kind constraints in library and comp.", "tree": {"sha": "9b61946d3cacaa67e89fb948af5f11e723e1dc30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b61946d3cacaa67e89fb948af5f11e723e1dc30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "html_url": "https://github.com/rust-lang/rust/commit/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ba4e349598aa736449a985d38348f083efdfb9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba4e349598aa736449a985d38348f083efdfb9d", "html_url": "https://github.com/rust-lang/rust/commit/6ba4e349598aa736449a985d38348f083efdfb9d"}], "stats": {"total": 147, "additions": 85, "deletions": 62}, "files": [{"sha": "3366299653003968c01ab2ce9762540ec4c190a8", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -47,7 +47,7 @@ fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt[()]) {\n     visit::visit_expr(ex, e, v);\n }\n \n-fn new_smallintmap_int_adapter[V]() -> std::map::hashmap[int, V] {\n+fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap[int, V] {\n     let key_idx = fn (key: &int) -> uint { key as uint };\n     let idx_key = fn (idx: &uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n@@ -58,15 +58,15 @@ fn new_smallintmap_int_adapter[V]() -> std::map::hashmap[int, V] {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter[K,\n-                           V](key_idx: fn(&K) -> uint ,\n-                              idx_key: fn(&uint) -> K ) ->\n+fn new_smallintmap_adapter[@K,\n+                           @V](key_idx: fn(&K) -> uint ,\n+                               idx_key: fn(&uint) -> K ) ->\n    std::map::hashmap[K, V] {\n \n-    obj adapter[K,\n-                V](map: smallintmap::smallintmap[V],\n-                   key_idx: fn(&K) -> uint ,\n-                   idx_key: fn(&uint) -> K ) {\n+    obj adapter[@K,\n+                @V](map: smallintmap::smallintmap[V],\n+                    key_idx: fn(&K) -> uint ,\n+                    idx_key: fn(&uint) -> K ) {\n \n         fn size() -> uint { fail }\n "}, {"sha": "4ff4e2c846fbba6fde2ab7dec9ab477d041b62f3", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -74,6 +74,8 @@\n import syntax::ast;\n import syntax::visit;\n \n+import std::ivec;\n+\n import ast::kind;\n import ast::kind_unique;\n import ast::kind_shared;\n@@ -138,10 +140,31 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n       ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n       ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, \"=\"); }\n       ast::expr_swap(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<->\"); }\n-      ast::expr_call(callee, args) {\n-        // FIXME: when ready, start checking param kinds against args.\n-        // This will break stdlib again.\n-        // let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n+      ast::expr_call(callee, _) {\n+        let tpt = ty::expr_ty_params_and_ty(tcx, callee);\n+        // If we have typarams, we're calling an item; we need to check\n+        // that all the types we're supplying as typarams conform to the\n+        // typaram kind constraints on that item.\n+        if ivec::len(tpt.params) != 0u {\n+            let callee_def = ast::def_id_of_def(tcx.def_map.get(callee.id));\n+            let item_tk = ty::lookup_item_type(tcx, callee_def);\n+            let i = 0;\n+            assert ivec::len(item_tk.kinds) == ivec::len(tpt.params);\n+            for k_need: ast::kind in item_tk.kinds {\n+                let t = tpt.params.(i);\n+                let k = ty::type_kind(tcx, t);\n+                if ! kind_lteq(k_need, k) {\n+                    let s = #fmt(\"mismatched kinds for typaram %d: \\\n+                                  needed %s type, got %s type %s\",\n+                                 i,\n+                                 kind_to_str(k_need),\n+                                 kind_to_str(k),\n+                                 util::ppaux::ty_to_str(tcx, t));\n+                    tcx.sess.span_err(e.span, s);\n+                }\n+                i += 1;\n+            }\n+        }\n       }\n       _ { }\n     }"}, {"sha": "9474ddd16d2c89ce29a3197a7135e48e4f7e11d7", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -16,11 +16,11 @@ type interner[T] =\n      hasher: hashfn[T],\n      eqer: eqfn[T]};\n \n-fn mk[T](hasher: hashfn[T], eqer: eqfn[T]) -> interner[T] {\n+fn mk[@T](hasher: hashfn[T], eqer: eqfn[T]) -> interner[T] {\n     let m = map::mk_hashmap[T, uint](hasher, eqer);\n     ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n }\n-fn intern[T](itr: &interner[T], val: &T) -> uint {\n+fn intern[@T](itr: &interner[T], val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {"}, {"sha": "cbca8e905a97d39227388d38a1e842b7770d831b", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -41,7 +41,7 @@ fn hash_def(d: &ast::def_id) -> uint {\n     ret h;\n }\n \n-fn new_def_hash[V]() -> std::map::hashmap[ast::def_id, V] {\n+fn new_def_hash[@V]() -> std::map::hashmap[ast::def_id, V] {\n     let hasher: std::map::hashfn[ast::def_id] = hash_def;\n     let eqer: std::map::eqfn[ast::def_id] = def_eq;\n     ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);"}, {"sha": "fb9df536df35ffa100000ff858a39e070bdc39bc", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -19,15 +19,15 @@ native \"rust\" mod rustrt {\n                                     count: uint);\n }\n \n-fn from_vec[T](v: &vec[T]) -> T[] {\n+fn from_vec[@T](v: &vec[T]) -> T[] {\n     let iv: T[] = ~[];\n     for e in v {\n         iv += ~[e];\n     }\n     ret iv;\n }\n \n-fn to_vec[T](iv: &T[]) -> vec[T] {\n+fn to_vec[@T](iv: &T[]) -> vec[T] {\n     let v: vec[T] = [];\n     for e in iv {\n         v += [e];\n@@ -36,7 +36,7 @@ fn to_vec[T](iv: &T[]) -> vec[T] {\n }\n \n /// Reserves space for `n` elements in the given vector.\n-fn reserve[T](v: &mutable T[mutable? ], n: uint) {\n+fn reserve[@T](v: &mutable T[mutable? ], n: uint) {\n     rustrt::ivec_reserve_shared(v, n);\n }\n \n@@ -48,7 +48,7 @@ fn len[T](v: &T[mutable? ]) -> uint { ret rusti::ivec_len(v); }\n \n type init_op[T] = fn(uint) -> T ;\n \n-fn init_fn[T](op: &init_op[T], n_elts: uint) -> T[] {\n+fn init_fn[@T](op: &init_op[T], n_elts: uint) -> T[] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -57,15 +57,15 @@ fn init_fn[T](op: &init_op[T], n_elts: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut[T](op: &init_op[T], n_elts: uint) -> T[mutable ] {\n+fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> T[mutable ] {\n     let v = ~[mutable ];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_elt[T](t: &T, n_elts: uint) -> T[] {\n+fn init_elt[@T](t: &T, n_elts: uint) -> T[] {\n     let v = ~[];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -74,21 +74,21 @@ fn init_elt[T](t: &T, n_elts: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_elt_mut[T](t: &T, n_elts: uint) -> T[mutable ] {\n+fn init_elt_mut[@T](t: &T, n_elts: uint) -> T[mutable ] {\n     let v = ~[mutable ];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += ~[mutable t]; i += 1u; }\n     ret v;\n }\n \n-fn to_mut[T](v: &T[]) -> T[mutable ] {\n+fn to_mut[@T](v: &T[]) -> T[mutable ] {\n     let vres = ~[mutable ];\n     for t: T  in v { vres += ~[mutable t]; }\n     ret vres;\n }\n \n-fn from_mut[T](v: &T[mutable ]) -> T[] {\n+fn from_mut[@T](v: &T[mutable ]) -> T[] {\n     let vres = ~[];\n     for t: T  in v { vres += ~[t]; }\n     ret vres;\n@@ -106,21 +106,21 @@ pred is_not_empty[T](v: &T[mutable? ]) -> bool { ret !is_empty(v); }\n // Accessors\n \n /// Returns the first element of a vector\n-fn head[T](v: &T[mutable?]) : is_not_empty(v) -> T { ret v.(0); }\n+fn head[@T](v: &T[mutable?]) : is_not_empty(v) -> T { ret v.(0); }\n \n /// Returns all but the first element of a vector\n-fn tail[T](v: &T[mutable? ]) : is_not_empty(v)  -> T[mutable?] {\n+fn tail[@T](v: &T[mutable? ]) : is_not_empty(v)  -> T[mutable?] {\n     ret slice(v, 1u, len(v));\n }\n \n /// Returns the last element of `v`.\n-fn last[T](v: &T[mutable? ]) -> option::t[T] {\n+fn last[@T](v: &T[mutable? ]) -> option::t[T] {\n     if len(v) == 0u { ret none; }\n     ret some(v.(len(v) - 1u));\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-fn slice[T](v: &T[mutable? ], start: uint, end: uint) -> T[] {\n+fn slice[@T](v: &T[mutable? ], start: uint, end: uint) -> T[] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = ~[];\n@@ -131,7 +131,7 @@ fn slice[T](v: &T[mutable? ], start: uint, end: uint) -> T[] {\n }\n \n // TODO: Remove me once we have slots.\n-fn slice_mut[T](v: &T[mutable? ], start: uint, end: uint) -> T[mutable ] {\n+fn slice_mut[@T](v: &T[mutable? ], start: uint, end: uint) -> T[mutable ] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = ~[mutable ];\n@@ -145,7 +145,7 @@ fn slice_mut[T](v: &T[mutable? ], start: uint, end: uint) -> T[mutable ] {\n // Mutators\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n-fn pop[T](v: &mutable T[mutable? ]) -> T {\n+fn pop[@T](v: &mutable T[mutable? ]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -160,22 +160,22 @@ fn pop[T](v: &mutable T[mutable? ]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow[T](v: &mutable T[], n: uint, initval: &T) {\n+fn grow[@T](v: &mutable T[], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut[T](v: &mutable T[mutable ], n: uint, initval: &T) {\n+fn grow_mut[@T](v: &mutable T[mutable ], n: uint, initval: &T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn[T](v: &mutable T[], n: uint, init_fn: fn(uint) -> T ) {\n+fn grow_fn[@T](v: &mutable T[], n: uint, init_fn: fn(uint) -> T ) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += ~[init_fn(i)]; i += 1u; }\n@@ -192,7 +192,7 @@ fn grow_set[@T](v: &mutable T[mutable ], index: uint, initval: &T, val: &T) {\n \n // Functional utilities\n \n-fn map[T, U](f: fn(&T) -> U , v: &T[mutable? ]) -> U[] {\n+fn map[@T, @U](f: fn(&T) -> U , v: &T[mutable? ]) -> U[] {\n     let result = ~[];\n     reserve(result, len(v));\n     for elem: T  in v {\n@@ -202,7 +202,7 @@ fn map[T, U](f: fn(&T) -> U , v: &T[mutable? ]) -> U[] {\n     ret result;\n }\n \n-fn filter_map[T, U](f: fn(&T) -> option::t[U] , v: &T[mutable? ]) -> U[] {\n+fn filter_map[@T, @U](f: fn(&T) -> option::t[U] , v: &T[mutable? ]) -> U[] {\n     let result = ~[];\n     for elem: T  in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -214,7 +214,7 @@ fn filter_map[T, U](f: fn(&T) -> option::t[U] , v: &T[mutable? ]) -> U[] {\n     ret result;\n }\n \n-fn foldl[T, U](p: fn(&U, &T) -> U , z: &U, v: &T[mutable? ]) -> U {\n+fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &T[mutable? ]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v.(0);\n@@ -243,12 +243,12 @@ fn count[T](x: &T, v: &T[mutable? ]) -> uint {\n     ret cnt;\n }\n \n-fn find[T](f: fn(&T) -> bool , v: &T[]) -> option::t[T] {\n+fn find[@T](f: fn(&T) -> bool , v: &T[]) -> option::t[T] {\n     for elt: T  in v { if f(elt) { ret some[T](elt); } }\n     ret none[T];\n }\n \n-fn unzip[T, U](v: &{_0: T, _1: U}[]) -> {_0: T[], _1: U[]} {\n+fn unzip[@T, @U](v: &{_0: T, _1: U}[]) -> {_0: T[], _1: U[]} {\n     let sz = len(v);\n     if sz == 0u {\n         ret {_0: ~[], _1: ~[]};\n@@ -263,7 +263,7 @@ fn unzip[T, U](v: &{_0: T, _1: U}[]) -> {_0: T[], _1: U[]} {\n \n \n // FIXME make the lengths being equal a constraint\n-fn zip[T, U](v: &T[], u: &U[]) -> {_0: T, _1: U}[] {\n+fn zip[@T, @U](v: &T[], u: &U[]) -> {_0: T, _1: U}[] {\n     let sz = len(v);\n     assert (sz == len(u));\n     if sz == 0u {\n@@ -309,5 +309,5 @@ mod unsafe {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "a53ea671e9079fdd04d0ccc989a5fb068708a5bc", "filename": "src/lib/list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -55,7 +55,7 @@ fn has[@T](ls_: &list[T], elt: &T) -> bool {\n \n }\n \n-fn length[T](ls: &list[T]) -> uint {\n+fn length[@T](ls: &list[T]) -> uint {\n     fn count[T](t: &T, u: &uint) -> uint { ret u + 1u; }\n     ret foldl[T, uint](ls, 0u, bind count[T](_, _));\n }"}, {"sha": "3883d0b94e85da0947308a0f3c24fc061513a994", "filename": "src/lib/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -25,8 +25,8 @@ fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n-    tag bucket[K, V] { nil; deleted; some(K, V); }\n-    fn make_buckets[K, V](nbkts: uint) -> (bucket[K, V])[mutable ] {\n+    tag bucket[@K, @V] { nil; deleted; some(K, V); }\n+    fn make_buckets[@K, @V](nbkts: uint) -> (bucket[K, V])[mutable ] {\n         ret ivec::init_elt_mut[bucket[K, V]](nil[K, V], nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper"}, {"sha": "a67408ac17885f185178294808026b31ae543143", "filename": "src/lib/option.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -2,34 +2,34 @@\n \n \n // lib/option::rs\n-tag t[T] { none; some(T); }\n+tag t[@T] { none; some(T); }\n \n-type operator[T, U] = fn(&T) -> U ;\n+type operator[@T, @U] = fn(&T) -> U ;\n \n-fn get[T](opt: &t[T]) -> T { ret alt opt { some(x) { x } none. { fail } }; }\n+fn get[@T](opt: &t[T]) -> T { ret alt opt { some(x) { x } none. { fail } }; }\n \n-fn map[T, U](f: &operator[T, U], opt: &t[T]) -> t[U] {\n+fn map[@T, @U](f: &operator[T, U], opt: &t[T]) -> t[U] {\n     ret alt opt { some(x) { some[U](f(x)) } none. { none[U] } };\n }\n \n-fn is_none[T](opt: &t[T]) -> bool {\n+fn is_none[@T](opt: &t[T]) -> bool {\n     ret alt opt { none. { true } some(_) { false } };\n }\n \n-fn is_some[T](opt: &t[T]) -> bool { ret !is_none(opt); }\n+fn is_some[@T](opt: &t[T]) -> bool { ret !is_none(opt); }\n \n-fn from_maybe[T](def: &T, opt: &t[T]) -> T {\n+fn from_maybe[@T](def: &T, opt: &t[T]) -> T {\n     let f = bind util::id[T](_);\n     ret maybe[T, T](def, f, opt);\n }\n \n-fn maybe[T, U](def: &U, f: fn(&T) -> U , opt: &t[T]) -> U {\n+fn maybe[@T, @U](def: &U, f: fn(&T) -> U , opt: &t[T]) -> U {\n     ret alt opt { none. { def } some(t) { f(t) } };\n }\n \n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may[T](f: fn(&T) , opt: &t[T]) {\n+fn may[@T](f: fn(&T) , opt: &t[T]) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n // Local Variables:"}, {"sha": "fdee322d30ee084af236e2256dbd3bd15c9844dd", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -9,32 +9,32 @@ import option::some;\n // to be.\n type smallintmap[T] = @{mutable v: (option::t[T])[mutable ]};\n \n-fn mk[T]() -> smallintmap[T] {\n+fn mk[@T]() -> smallintmap[T] {\n     let v: (option::t[T])[mutable ] = ~[mutable ];\n     ret @{mutable v: v};\n }\n \n-fn insert[T](m: &smallintmap[T], key: uint, val: &T) {\n+fn insert[@T](m: &smallintmap[T], key: uint, val: &T) {\n     ivec::grow_set[option::t[T]](m.v, key, none[T], some[T](val));\n }\n \n-fn find[T](m: &smallintmap[T], key: uint) -> option::t[T] {\n+fn find[@T](m: &smallintmap[T], key: uint) -> option::t[T] {\n     if key < ivec::len[option::t[T]](m.v) { ret m.v.(key); }\n     ret none[T];\n }\n \n-fn get[T](m: &smallintmap[T], key: uint) -> T {\n+fn get[@T](m: &smallintmap[T], key: uint) -> T {\n     alt find[T](m, key) {\n       none[T]. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some[T](v) { ret v; }\n     }\n }\n \n-fn contains_key[T](m: &smallintmap[T], key: uint) -> bool {\n+fn contains_key[@T](m: &smallintmap[T], key: uint) -> bool {\n     ret !option::is_none(find[T](m, key));\n }\n \n-fn truncate[T](m: &smallintmap[T], len: uint) {\n+fn truncate[@T](m: &smallintmap[T], len: uint) {\n     m.v = ivec::slice_mut[option::t[T]](m.v, 0u, len);\n }\n "}, {"sha": "2a7348b354f10cf89df53ae6603c3e2d2c1c11d3", "filename": "src/lib/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -12,7 +12,7 @@ export quick_sort3;\n type lteq[T] = fn(&T, &T) -> bool ;\n \n fn merge_sort[@T](le: lteq[T], v: vec[T]) -> vec[T] {\n-    fn merge[T](le: lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n+    fn merge[@T](le: lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n         let rs: vec[T] = [];\n         let a_len: uint = len[T](a);\n         let a_ix: uint = 0u;"}, {"sha": "6d405f2eae85ea0eef6642e218dd65859b661f21", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=0c9b749d208ccc75f03ab9f7fce1322aa5dbbfd3", "patch": "@@ -81,7 +81,7 @@ fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n \n type eqfn[T] = fn(&T, &T) -> bool ;\n \n-fn test_parameterized[T](e: eqfn[T], a: &T, b: &T, c: &T, d: &T) {\n+fn test_parameterized[@T](e: eqfn[T], a: &T, b: &T, c: &T, d: &T) {\n     let deq: deque::t[T] = deque::create[T]();\n     assert (deq.size() == 0u);\n     deq.add_front(a);\n@@ -113,7 +113,7 @@ fn test_parameterized[T](e: eqfn[T], a: &T, b: &T, c: &T, d: &T) {\n \n tag taggy { one(int); two(int, int); three(int, int, int); }\n \n-tag taggypar[T] { onepar(int); twopar(int, int); threepar(int, int, int); }\n+tag taggypar[@T] { onepar(int); twopar(int, int); threepar(int, int, int); }\n \n type reccy = {x: int, y: int, t: taggy};\n \n@@ -138,7 +138,7 @@ fn test() {\n           }\n         }\n     }\n-    fn taggypareq[T](a: &taggypar[T], b: &taggypar[T]) -> bool {\n+    fn taggypareq[@T](a: &taggypar[T], b: &taggypar[T]) -> bool {\n         alt a {\n           onepar[T](a1) {\n             alt b { onepar[T](b1) { ret a1 == b1; } _ { ret false; } }"}]}