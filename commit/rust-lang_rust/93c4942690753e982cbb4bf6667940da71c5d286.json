{"sha": "93c4942690753e982cbb4bf6667940da71c5d286", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzYzQ5NDI2OTA3NTNlOTgyY2JiNGJmNjY2Nzk0MGRhNzFjNWQyODY=", "commit": {"author": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2014-11-14T02:04:28Z"}, "committer": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2014-11-14T06:57:33Z"}, "message": "Rewrite std::sync::TaskPool to be load balancing and panic-resistant\n\nThe previous implementation was very likely to cause panics during\nunwinding through this process:\n\n- child panics, drops its receiver\n- taskpool comes back around and sends another job over to that child\n- the child receiver has hung up, so the taskpool panics on send\n- during unwinding, the taskpool attempts to send a quit message to\n  the child, causing a panic during unwinding\n- panic during unwinding causes a process abort\n\nThis meant that TaskPool upgraded any child panic to a full process\nabort. This came up in Iron when it caused crashes in long-running\nservers.\n\nThis implementation uses a single channel to communicate between\nspawned tasks and the TaskPool, which significantly reduces the complexity\nof the implementation and cuts down on allocation. The TaskPool uses\nthe channel as a single-producer-multiple-consumer queue.\n\nAdditionally, through the use of send_opt and recv_opt instead of\nsend and recv, this TaskPool is robust on the face of child panics,\nboth before, during, and after the TaskPool itself is dropped.\n\nDue to the TaskPool no longer using an `init_fn_factory`, this is a\n\n[breaking-change]\n\notherwise, the API has not changed.\n\nIf you used `init_fn_factory` in your code, and this change breaks for\nyou, you can instead use an `AtomicUint` counter and a channel to\nmove information into child tasks.", "tree": {"sha": "5cd06a4031ab7b8ec510eaf36e5b677e4dfcdd02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cd06a4031ab7b8ec510eaf36e5b677e4dfcdd02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93c4942690753e982cbb4bf6667940da71c5d286", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93c4942690753e982cbb4bf6667940da71c5d286", "html_url": "https://github.com/rust-lang/rust/commit/93c4942690753e982cbb4bf6667940da71c5d286", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93c4942690753e982cbb4bf6667940da71c5d286/comments", "author": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ba87f0314fda5e81603f37ae5f40e2022bcfc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ba87f0314fda5e81603f37ae5f40e2022bcfc1", "html_url": "https://github.com/rust-lang/rust/commit/15ba87f0314fda5e81603f37ae5f40e2022bcfc1"}], "stats": {"total": 230, "additions": 167, "deletions": 63}, "files": [{"sha": "2682582d708a871084e040584c75ab7b2ae7e475", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 167, "deletions": 63, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/93c4942690753e982cbb4bf6667940da71c5d286/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c4942690753e982cbb4bf6667940da71c5d286/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=93c4942690753e982cbb4bf6667940da71c5d286", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,91 +12,195 @@\n \n use core::prelude::*;\n \n-use task;\n use task::spawn;\n-use vec::Vec;\n-use comm::{channel, Sender};\n+use comm::{channel, Sender, Receiver};\n+use sync::{Arc, Mutex};\n \n-enum Msg<T> {\n-    Execute(proc(&T):Send),\n-    Quit\n+struct Sentinel<'a> {\n+    jobs: &'a Arc<Mutex<Receiver<proc(): Send>>>,\n+    active: bool\n }\n \n-/// A task pool used to execute functions in parallel.\n-pub struct TaskPool<T> {\n-    channels: Vec<Sender<Msg<T>>>,\n-    next_index: uint,\n+impl<'a> Sentinel<'a> {\n+    fn new(jobs: &Arc<Mutex<Receiver<proc(): Send>>>) -> Sentinel {\n+        Sentinel {\n+            jobs: jobs,\n+            active: true\n+        }\n+    }\n+\n+    // Cancel and destroy this sentinel.\n+    fn cancel(mut self) {\n+        self.active = false;\n+    }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for TaskPool<T> {\n+impl<'a> Drop for Sentinel<'a> {\n     fn drop(&mut self) {\n-        for channel in self.channels.iter_mut() {\n-            channel.send(Quit);\n+        if self.active {\n+            spawn_in_pool(self.jobs.clone())\n         }\n     }\n }\n \n-impl<T> TaskPool<T> {\n-    /// Spawns a new task pool with `n_tasks` tasks. The provided\n-    /// `init_fn_factory` returns a function which, given the index of the\n-    /// task, should return local data to be kept around in that task.\n+/// A task pool used to execute functions in parallel.\n+///\n+/// Spawns `n` worker tasks and replenishes the pool if any worker tasks\n+/// panic.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # use sync::TaskPool;\n+/// # use iter::AdditiveIterator;\n+///\n+/// let pool = TaskPool::new(4u);\n+///\n+/// let (tx, rx) = channel();\n+/// for _ in range(0, 8u) {\n+///     let tx = tx.clone();\n+///     pool.execute(proc() {\n+///         tx.send(1u);\n+///     });\n+/// }\n+///\n+/// assert_eq!(rx.iter().take(8u).sum(), 8u);\n+/// ```\n+pub struct TaskPool {\n+    // How the taskpool communicates with subtasks.\n+    //\n+    // This is the only such Sender, so when it is dropped all subtasks will\n+    // quit.\n+    jobs: Sender<proc(): Send>\n+}\n+\n+impl TaskPool {\n+    /// Spawns a new task pool with `tasks` tasks.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `n_tasks` is less than 1.\n-    pub fn new(n_tasks: uint,\n-               init_fn_factory: || -> proc(uint):Send -> T)\n-               -> TaskPool<T> {\n-        assert!(n_tasks >= 1);\n-\n-        let channels = Vec::from_fn(n_tasks, |i| {\n-            let (tx, rx) = channel::<Msg<T>>();\n-            let init_fn = init_fn_factory();\n-\n-            let task_body = proc() {\n-                let local_data = init_fn(i);\n-                loop {\n-                    match rx.recv() {\n-                        Execute(f) => f(&local_data),\n-                        Quit => break\n-                    }\n-                }\n-            };\n+    /// This function will panic if `tasks` is 0.\n+    pub fn new(tasks: uint) -> TaskPool {\n+        assert!(tasks >= 1);\n \n-            // Run on this scheduler.\n-            task::spawn(task_body);\n+        let (tx, rx) = channel::<proc(): Send>();\n+        let rx = Arc::new(Mutex::new(rx));\n \n-            tx\n-        });\n+        // Taskpool tasks.\n+        for _ in range(0, tasks) {\n+            spawn_in_pool(rx.clone());\n+        }\n \n-        return TaskPool {\n-            channels: channels,\n-            next_index: 0,\n-        };\n+        TaskPool { jobs: tx }\n     }\n \n-    /// Executes the function `f` on a task in the pool. The function\n-    /// receives a reference to the local data returned by the `init_fn`.\n-    pub fn execute(&mut self, f: proc(&T):Send) {\n-        self.channels[self.next_index].send(Execute(f));\n-        self.next_index += 1;\n-        if self.next_index == self.channels.len() { self.next_index = 0; }\n+    /// Executes the function `job` on a task in the pool.\n+    pub fn execute(&self, job: proc():Send) {\n+        self.jobs.send(job);\n     }\n }\n \n-#[test]\n-fn test_task_pool() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    let mut pool = TaskPool::new(4, f);\n-    for _ in range(0u, 8) {\n-        pool.execute(proc(i) println!(\"Hello from thread {}!\", *i));\n-    }\n+fn spawn_in_pool(jobs: Arc<Mutex<Receiver<proc(): Send>>>) {\n+    spawn(proc() {\n+        // Will spawn a new task on panic unless it is cancelled.\n+        let sentinel = Sentinel::new(&jobs);\n+\n+        loop {\n+            let message = {\n+                // Only lock jobs for the time it takes\n+                // to get a job, not run it.\n+                let lock = jobs.lock();\n+                lock.recv_opt()\n+            };\n+\n+            match message {\n+                Ok(job) => job(),\n+\n+                // The Taskpool was dropped.\n+                Err(..) => break\n+            }\n+        }\n+\n+        sentinel.cancel();\n+    })\n }\n \n-#[test]\n-#[should_fail]\n-fn test_zero_tasks_panic() {\n-    let f: || -> proc(uint):Send -> uint = || { proc(i) i };\n-    TaskPool::new(0, f);\n+#[cfg(test)]\n+mod test {\n+    use core::prelude::*;\n+    use super::*;\n+    use comm::channel;\n+    use iter::range;\n+\n+    const TEST_TASKS: uint = 4u;\n+\n+    #[test]\n+    fn test_works() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_zero_tasks_panic() {\n+        TaskPool::new(0);\n+    }\n+\n+    #[test]\n+    fn test_recovery_from_subtask_panic() {\n+        use iter::AdditiveIterator;\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+\n+        // Panic all the existing tasks.\n+        for _ in range(0, TEST_TASKS) {\n+            pool.execute(proc() { panic!() });\n+        }\n+\n+        // Ensure new tasks were spawned to compensate.\n+        let (tx, rx) = channel();\n+        for _ in range(0, TEST_TASKS) {\n+            let tx = tx.clone();\n+            pool.execute(proc() {\n+                tx.send(1u);\n+            });\n+        }\n+\n+        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n+    }\n+\n+    #[test]\n+    fn test_should_not_panic_on_drop_if_subtasks_panic_after_drop() {\n+        use sync::{Arc, Barrier};\n+\n+        let pool = TaskPool::new(TEST_TASKS);\n+        let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n+\n+        // Panic all the existing tasks in a bit.\n+        for _ in range(0, TEST_TASKS) {\n+            let waiter = waiter.clone();\n+            pool.execute(proc() {\n+                waiter.wait();\n+                panic!();\n+            });\n+        }\n+\n+        drop(pool);\n+\n+        // Kick off the failure.\n+        waiter.wait();\n+    }\n }\n+"}]}