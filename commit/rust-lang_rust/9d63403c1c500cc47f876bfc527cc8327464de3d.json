{"sha": "9d63403c1c500cc47f876bfc527cc8327464de3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNjM0MDNjMWM1MDBjYzQ3Zjg3NmJmYzUyN2NjODMyNzQ2NGRlM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-09T20:31:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-09T20:31:35Z"}, "message": "auto merge of #11417 : eddyb/rust/desnaking, r=bstrie", "tree": {"sha": "df2ace956c0631a5c6f3edb2e9f020330f863a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2ace956c0631a5c6f3edb2e9f020330f863a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d63403c1c500cc47f876bfc527cc8327464de3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d63403c1c500cc47f876bfc527cc8327464de3d", "html_url": "https://github.com/rust-lang/rust/commit/9d63403c1c500cc47f876bfc527cc8327464de3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d63403c1c500cc47f876bfc527cc8327464de3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63ba93f91d6988506fd25a91c7d80820818159ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/63ba93f91d6988506fd25a91c7d80820818159ab", "html_url": "https://github.com/rust-lang/rust/commit/63ba93f91d6988506fd25a91c7d80820818159ab"}, {"sha": "72ee4a57b7ab3651db1ec99ff3167b86f2583c43", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ee4a57b7ab3651db1ec99ff3167b86f2583c43", "html_url": "https://github.com/rust-lang/rust/commit/72ee4a57b7ab3651db1ec99ff3167b86f2583c43"}], "stats": {"total": 8610, "additions": 4253, "deletions": 4357}, "files": [{"sha": "0284dc3b92d2bcf1d6e968a76ebfe1b48ac3f9ed", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -38,7 +38,8 @@ use extra::hex::ToHex;\n use extra::tempfile::TempDir;\n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n+use syntax::ast_map::{PathMod, PathName, PathPrettyName};\n+use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::crateid::CrateId;\n@@ -583,7 +584,7 @@ pub fn sanitize(s: &str) -> ~str {\n     return result;\n }\n \n-pub fn mangle(sess: Session, ss: path,\n+pub fn mangle(sess: Session, ss: ast_map::Path,\n               hash: Option<&str>, vers: Option<&str>) -> ~str {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n@@ -609,7 +610,7 @@ pub fn mangle(sess: Session, ss: path,\n     // First, connect each component with <len, name> pairs.\n     for s in ss.iter() {\n         match *s {\n-            path_name(s) | path_mod(s) | path_pretty_name(s, _) => {\n+            PathName(s) | PathMod(s) | PathPrettyName(s, _) => {\n                 push(sess.str_of(s))\n             }\n         }\n@@ -625,7 +626,7 @@ pub fn mangle(sess: Session, ss: path,\n     let mut hash = match hash { Some(s) => s.to_owned(), None => ~\"\" };\n     for s in ss.iter() {\n         match *s {\n-            path_pretty_name(_, extra) => {\n+            PathPrettyName(_, extra) => {\n                 let hi = (extra >> 32) as u32 as uint;\n                 let lo = extra as u32 as uint;\n                 hash.push_char(EXTRA_CHARS[hi % EXTRA_CHARS.len()] as char);\n@@ -647,7 +648,7 @@ pub fn mangle(sess: Session, ss: path,\n }\n \n pub fn exported_name(sess: Session,\n-                     path: path,\n+                     path: ast_map::Path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n     // The version will get mangled to have a leading '_', but it makes more\n@@ -662,7 +663,7 @@ pub fn exported_name(sess: Session,\n }\n \n pub fn mangle_exported_name(ccx: &CrateContext,\n-                            path: path,\n+                            path: ast_map::Path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n     return exported_name(ccx.sess, path,\n@@ -676,8 +677,8 @@ pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     return mangle(ccx.sess,\n-                  ~[path_name(ccx.sess.ident_of(name)),\n-                    path_name(ccx.sess.ident_of(s))],\n+                  ~[PathName(ccx.sess.ident_of(name)),\n+                    PathName(ccx.sess.ident_of(s))],\n                   Some(hash.as_slice()),\n                   None);\n }\n@@ -689,20 +690,21 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n     let hash = get_symbol_hash(ccx, t);\n     let (_, name) = gensym_name(name);\n     return mangle(ccx.sess,\n-                  ~[path_name(ccx.sess.ident_of(s)), name],\n+                  ~[PathName(ccx.sess.ident_of(s)), name],\n                   Some(hash.as_slice()),\n                   None);\n }\n \n pub fn mangle_internal_name_by_path_and_seq(ccx: &CrateContext,\n-                                            mut path: path,\n+                                            mut path: ast_map::Path,\n                                             flav: &str) -> ~str {\n     let (_, name) = gensym_name(flav);\n     path.push(name);\n     mangle(ccx.sess, path, None, None)\n }\n \n-pub fn mangle_internal_name_by_path(ccx: &CrateContext, path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: &CrateContext,\n+                                    path: ast_map::Path) -> ~str {\n     mangle(ccx.sess, path, None, None)\n }\n "}, {"sha": "4657d697323549cf75941dc2358948a74d6eadcf", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -164,7 +164,7 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &input)\n pub fn phase_2_configure_and_expand(sess: Session,\n                                     cfg: ast::CrateConfig,\n                                     mut crate: ast::Crate)\n-                                    -> (ast::Crate, syntax::ast_map::map) {\n+                                    -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n     sess.building_library.set(session::building_library(sess.opts, &crate));\n@@ -220,7 +220,7 @@ pub struct CrateAnalysis {\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes(sess: Session,\n                                    crate: &ast::Crate,\n-                                   ast_map: syntax::ast_map::map) -> CrateAnalysis {\n+                                   ast_map: syntax::ast_map::Map) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n \n@@ -515,29 +515,29 @@ struct IdentifiedAnnotation {\n     contents: (),\n }\n \n-impl pprust::pp_ann for IdentifiedAnnotation {\n-    fn pre(&self, node: pprust::ann_node) {\n+impl pprust::PpAnn for IdentifiedAnnotation {\n+    fn pre(&self, node: pprust::AnnNode) {\n         match node {\n-            pprust::node_expr(s, _) => pprust::popen(s),\n+            pprust::NodeExpr(s, _) => pprust::popen(s),\n             _ => ()\n         }\n     }\n-    fn post(&self, node: pprust::ann_node) {\n+    fn post(&self, node: pprust::AnnNode) {\n         match node {\n-            pprust::node_item(s, item) => {\n+            pprust::NodeItem(s, item) => {\n                 pp::space(&mut s.s);\n                 pprust::synth_comment(s, item.id.to_str());\n             }\n-            pprust::node_block(s, blk) => {\n+            pprust::NodeBlock(s, blk) => {\n                 pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n             }\n-            pprust::node_expr(s, expr) => {\n+            pprust::NodeExpr(s, expr) => {\n                 pp::space(&mut s.s);\n                 pprust::synth_comment(s, expr.id.to_str());\n                 pprust::pclose(s);\n             }\n-            pprust::node_pat(s, pat) => {\n+            pprust::NodePat(s, pat) => {\n                 pp::space(&mut s.s);\n                 pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n             }\n@@ -549,17 +549,17 @@ struct TypedAnnotation {\n     analysis: CrateAnalysis,\n }\n \n-impl pprust::pp_ann for TypedAnnotation {\n-    fn pre(&self, node: pprust::ann_node) {\n+impl pprust::PpAnn for TypedAnnotation {\n+    fn pre(&self, node: pprust::AnnNode) {\n         match node {\n-            pprust::node_expr(s, _) => pprust::popen(s),\n+            pprust::NodeExpr(s, _) => pprust::popen(s),\n             _ => ()\n         }\n     }\n-    fn post(&self, node: pprust::ann_node) {\n+    fn post(&self, node: pprust::AnnNode) {\n         let tcx = self.analysis.ty_cx;\n         match node {\n-            pprust::node_expr(s, expr) => {\n+            pprust::NodeExpr(s, expr) => {\n                 pp::space(&mut s.s);\n                 pp::word(&mut s.s, \"as\");\n                 pp::space(&mut s.s);\n@@ -589,16 +589,16 @@ pub fn pretty_print_input(sess: Session,\n         PpmIdentified | PpmExpandedIdentified => {\n             @IdentifiedAnnotation {\n                 contents: (),\n-            } as @pprust::pp_ann\n+            } as @pprust::PpAnn\n         }\n         PpmTyped => {\n             let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n             let analysis = phase_3_run_analysis_passes(sess, &crate, ast_map);\n             @TypedAnnotation {\n                 analysis: analysis\n-            } as @pprust::pp_ann\n+            } as @pprust::PpAnn\n         }\n-        _ => @pprust::no_ann::new() as @pprust::pp_ann,\n+        _ => @pprust::NoAnn as @pprust::PpAnn,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n@@ -662,10 +662,10 @@ pub fn build_target_config(sopts: @session::options,\n                           \"unknown architecture: \" + sopts.target_triple)\n     };\n     let (int_type, uint_type) = match arch {\n-      abi::X86 => (ast::ty_i32, ast::ty_u32),\n-      abi::X86_64 => (ast::ty_i64, ast::ty_u64),\n-      abi::Arm => (ast::ty_i32, ast::ty_u32),\n-      abi::Mips => (ast::ty_i32, ast::ty_u32)\n+      abi::X86 => (ast::TyI32, ast::TyU32),\n+      abi::X86_64 => (ast::TyI64, ast::TyU64),\n+      abi::Arm => (ast::TyI32, ast::TyU32),\n+      abi::Mips => (ast::TyI32, ast::TyU32)\n     };\n     let target_triple = sopts.target_triple.clone();\n     let target_strs = match arch {\n@@ -1116,7 +1116,7 @@ pub fn build_output_filenames(input: &input,\n }\n \n pub fn early_error(emitter: &diagnostic::Emitter, msg: &str) -> ! {\n-    emitter.emit(None, msg, diagnostic::fatal);\n+    emitter.emit(None, msg, diagnostic::Fatal);\n     fail!();\n }\n "}, {"sha": "0176c3fa1e06f1e8b17aa1d5920d5f9cce7924bf", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -19,7 +19,7 @@ use middle::lint;\n \n use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n-use syntax::ast::{int_ty, uint_ty};\n+use syntax::ast::{IntTy, UintTy};\n use syntax::codemap::Span;\n use syntax::diagnostic;\n use syntax::parse::ParseSess;\n@@ -35,8 +35,8 @@ pub struct config {\n     os: abi::Os,\n     arch: abi::Architecture,\n     target_strs: target_strs::t,\n-    int_type: int_ty,\n-    uint_type: uint_ty,\n+    int_type: IntTy,\n+    uint_type: UintTy,\n }\n \n pub static verbose:                 uint = 1 <<  0;\n@@ -368,7 +368,7 @@ impl Session_ {\n     }\n \n     // pointless function, now...\n-    pub fn intr(&self) -> @syntax::parse::token::ident_interner {\n+    pub fn intr(&self) -> @syntax::parse::token::IdentInterner {\n         token::get_ident_interner()\n     }\n }"}, {"sha": "d77ef1f3534eacd583793cb7c26e252f8ce26352", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -24,6 +24,6 @@ impl ast_map::FoldOps for NodeIdAssigner {\n     }\n }\n \n-pub fn assign_node_ids_and_map(sess: Session, crate: ast::Crate) -> (ast::Crate, ast_map::map) {\n+pub fn assign_node_ids_and_map(sess: Session, crate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n     ast_map::map_crate(sess.diagnostic(), crate, NodeIdAssigner { sess: sess })\n }"}, {"sha": "0c41b35f6ea43ea7ebece724254c3f76a4adf9ea", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use syntax::fold::ast_fold;\n+use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n use syntax::codemap;\n \n@@ -24,18 +24,17 @@ pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n     strip_items(crate, |attrs| in_cfg(config, attrs))\n }\n \n-impl<'a> fold::ast_fold for Context<'a> {\n-    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+impl<'a> fold::Folder for Context<'a> {\n+    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n     fn fold_block(&mut self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         fold_block(self, block)\n     }\n-    fn fold_foreign_mod(&mut self, foreign_module: &ast::foreign_mod)\n-                        -> ast::foreign_mod {\n-        fold_foreign_mod(self, foreign_module)\n+    fn fold_foreign_mod(&mut self, foreign_mod: &ast::ForeignMod) -> ast::ForeignMod {\n+        fold_foreign_mod(self, foreign_mod)\n     }\n-    fn fold_item_underscore(&mut self, item: &ast::item_) -> ast::item_ {\n+    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n }\n@@ -49,89 +48,89 @@ pub fn strip_items(crate: ast::Crate,\n     ctxt.fold_crate(crate)\n }\n \n-fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::view_item)\n-                        -> Option<&'r ast::view_item> {\n+fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n+                        -> Option<&'r ast::ViewItem> {\n     if view_item_in_cfg(cx, view_item) {\n         Some(view_item)\n     } else {\n         None\n     }\n }\n \n-fn fold_mod(cx: &mut Context, m: &ast::_mod) -> ast::_mod {\n+fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n     let filtered_items = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n             .collect();\n     let filtered_view_items = m.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n-    ast::_mod {\n+    ast::Mod {\n         view_items: filtered_view_items,\n         items: filtered_items\n     }\n }\n \n-fn filter_foreign_item(cx: &Context, item: @ast::foreign_item)\n-                       -> Option<@ast::foreign_item> {\n+fn filter_foreign_item(cx: &Context, item: @ast::ForeignItem)\n+                       -> Option<@ast::ForeignItem> {\n     if foreign_item_in_cfg(cx, item) {\n         Some(item)\n     } else {\n         None\n     }\n }\n \n-fn fold_foreign_mod(cx: &mut Context, nm: &ast::foreign_mod) -> ast::foreign_mod {\n+fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n     let filtered_items = nm.items\n                            .iter()\n                            .filter_map(|a| filter_foreign_item(cx, *a))\n                            .collect();\n     let filtered_view_items = nm.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n-    ast::foreign_mod {\n+    ast::ForeignMod {\n         abis: nm.abis,\n         view_items: filtered_view_items,\n         items: filtered_items\n     }\n }\n \n-fn fold_item_underscore(cx: &mut Context, item: &ast::item_) -> ast::item_ {\n+fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, ref b, c, ref methods) => {\n+        ast::ItemImpl(ref a, ref b, c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .map(|x| *x).collect();\n-            ast::item_impl((*a).clone(), (*b).clone(), c, methods)\n+            ast::ItemImpl((*a).clone(), (*b).clone(), c, methods)\n         }\n-        ast::item_trait(ref a, ref b, ref methods) => {\n+        ast::ItemTrait(ref a, ref b, ref methods) => {\n             let methods = methods.iter()\n                                  .filter(|m| trait_method_in_cfg(cx, *m) )\n                                  .map(|x| (*x).clone())\n                                  .collect();\n-            ast::item_trait((*a).clone(), (*b).clone(), methods)\n+            ast::ItemTrait((*a).clone(), (*b).clone(), methods)\n         }\n-        ast::item_struct(def, ref generics) => {\n-            ast::item_struct(fold_struct(cx, def), generics.clone())\n+        ast::ItemStruct(def, ref generics) => {\n+            ast::ItemStruct(fold_struct(cx, def), generics.clone())\n         }\n-        ast::item_enum(ref def, ref generics) => {\n+        ast::ItemEnum(ref def, ref generics) => {\n             let mut variants = def.variants.iter().map(|c| c.clone()).filter(|m| {\n                 (cx.in_cfg)(m.node.attrs)\n             }).map(|v| {\n                 match v.node.kind {\n-                    ast::tuple_variant_kind(..) => v,\n-                    ast::struct_variant_kind(def) => {\n+                    ast::TupleVariantKind(..) => v,\n+                    ast::StructVariantKind(def) => {\n                         let def = fold_struct(cx, def);\n                         @codemap::Spanned {\n-                            node: ast::variant_ {\n-                                kind: ast::struct_variant_kind(def),\n+                            node: ast::Variant_ {\n+                                kind: ast::StructVariantKind(def),\n                                 ..v.node.clone()\n                             },\n                             ..*v\n                         }\n                     }\n                 }\n             });\n-            ast::item_enum(ast::enum_def {\n+            ast::ItemEnum(ast::EnumDef {\n                 variants: variants.collect(),\n             }, generics.clone())\n         }\n@@ -141,11 +140,11 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::item_) -> ast::item_ {\n     fold::noop_fold_item_underscore(&item, cx)\n }\n \n-fn fold_struct(cx: &Context, def: &ast::struct_def) -> @ast::struct_def {\n+fn fold_struct(cx: &Context, def: &ast::StructDef) -> @ast::StructDef {\n     let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n         (cx.in_cfg)(m.node.attrs)\n     });\n-    @ast::struct_def {\n+    @ast::StructDef {\n         fields: fields.collect(),\n         ctor_id: def.ctor_id,\n     }\n@@ -183,26 +182,26 @@ fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n     })\n }\n \n-fn item_in_cfg(cx: &Context, item: @ast::item) -> bool {\n+fn item_in_cfg(cx: &Context, item: &ast::Item) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn foreign_item_in_cfg(cx: &Context, item: @ast::foreign_item) -> bool {\n+fn foreign_item_in_cfg(cx: &Context, item: &ast::ForeignItem) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn view_item_in_cfg(cx: &Context, item: &ast::view_item) -> bool {\n+fn view_item_in_cfg(cx: &Context, item: &ast::ViewItem) -> bool {\n     return (cx.in_cfg)(item.attrs);\n }\n \n-fn method_in_cfg(cx: &Context, meth: @ast::method) -> bool {\n+fn method_in_cfg(cx: &Context, meth: &ast::Method) -> bool {\n     return (cx.in_cfg)(meth.attrs);\n }\n \n-fn trait_method_in_cfg(cx: &Context, meth: &ast::trait_method) -> bool {\n+fn trait_method_in_cfg(cx: &Context, meth: &ast::TraitMethod) -> bool {\n     match *meth {\n-        ast::required(ref meth) => (cx.in_cfg)(meth.attrs),\n-        ast::provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n+        ast::Required(ref meth) => (cx.in_cfg)(meth.attrs),\n+        ast::Provided(@ref meth) => (cx.in_cfg)(meth.attrs)\n     }\n }\n "}, {"sha": "9bd7c8fc44a9ad2d1e2e8f2d57b6dbb7cb20bd0a", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -100,12 +100,12 @@ impl Visitor<()> for Context {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::view_item, _: ()) {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n         match i.node {\n-            ast::view_item_use(ref paths) => {\n+            ast::ViewItemUse(ref paths) => {\n                 for path in paths.iter() {\n                     match path.node {\n-                        ast::view_path_glob(..) => {\n+                        ast::ViewPathGlob(..) => {\n                             self.gate_feature(\"globs\", path.span,\n                                               \"glob import statements are \\\n                                                experimental and possibly buggy\");\n@@ -119,7 +119,7 @@ impl Visitor<()> for Context {\n         visit::walk_view_item(self, i, ())\n     }\n \n-    fn visit_item(&mut self, i: &ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::Item, _:()) {\n         for attr in i.attrs.iter() {\n             if \"thread_local\" == attr.name() {\n                 self.gate_feature(\"thread_local\", i.span,\n@@ -129,10 +129,10 @@ impl Visitor<()> for Context {\n             }\n         }\n         match i.node {\n-            ast::item_enum(ref def, _) => {\n+            ast::ItemEnum(ref def, _) => {\n                 for variant in def.variants.iter() {\n                     match variant.node.kind {\n-                        ast::struct_variant_kind(..) => {\n+                        ast::StructVariantKind(..) => {\n                             self.gate_feature(\"struct_variant\", variant.span,\n                                               \"enum struct variants are \\\n                                                experimental and possibly buggy\");\n@@ -142,7 +142,7 @@ impl Visitor<()> for Context {\n                 }\n             }\n \n-            ast::item_foreign_mod(..) => {\n+            ast::ItemForeignMod(..) => {\n                 if attr::contains_name(i.attrs, \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n@@ -157,8 +157,8 @@ impl Visitor<()> for Context {\n         visit::walk_item(self, i, ());\n     }\n \n-    fn visit_mac(&mut self, macro: &ast::mac, _: ()) {\n-        let ast::mac_invoc_tt(ref path, _, _) = macro.node;\n+    fn visit_mac(&mut self, macro: &ast::Mac, _: ()) {\n+        let ast::MacInvocTT(ref path, _, _) = macro.node;\n \n         if path.segments.last().identifier == self.sess.ident_of(\"macro_rules\") {\n             self.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n@@ -173,14 +173,14 @@ impl Visitor<()> for Context {\n \n     fn visit_ty(&mut self, t: &ast::Ty, _: ()) {\n         match t.node {\n-            ast::ty_closure(closure) if closure.onceness == ast::Once &&\n+            ast::TyClosure(closure) if closure.onceness == ast::Once &&\n                     closure.sigil != ast::OwnedSigil => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");\n \n             },\n-            ast::ty_box(_) => { self.gate_box(t.span); }\n+            ast::TyBox(_) => { self.gate_box(t.span); }\n             _ => {}\n         }\n "}, {"sha": "ae593783213ce1af3c3687d408b101e5f982371c", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use syntax::codemap;\n-use syntax::fold::ast_fold;\n+use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n use syntax::util::small_vector::SmallVector;\n@@ -55,41 +55,41 @@ struct StandardLibraryInjector {\n     sess: Session,\n }\n \n-impl fold::ast_fold for StandardLibraryInjector {\n+impl fold::Folder for StandardLibraryInjector {\n     fn fold_crate(&mut self, crate: ast::Crate) -> ast::Crate {\n-        let mut vis = ~[ast::view_item {\n-            node: ast::view_item_extern_mod(self.sess.ident_of(\"std\"),\n-                                            Some((format!(\"std\\\\#{}\", VERSION).to_managed(),\n-                                                  ast::CookedStr)),\n-                                            ast::DUMMY_NODE_ID),\n+        let mut vis = ~[ast::ViewItem {\n+            node: ast::ViewItemExternMod(self.sess.ident_of(\"std\"),\n+                                         Some((format!(\"std\\\\#{}\", VERSION).to_managed(),\n+                                               ast::CookedStr)),\n+                                         ast::DUMMY_NODE_ID),\n             attrs: ~[],\n-            vis: ast::private,\n+            vis: ast::Private,\n             span: DUMMY_SP\n         }];\n \n         if use_uv(&crate) && !self.sess.building_library.get() {\n-            vis.push(ast::view_item {\n-                node: ast::view_item_extern_mod(self.sess.ident_of(\"green\"),\n-                                                Some((format!(\"green\\\\#{}\", VERSION).to_managed(),\n-                                                      ast::CookedStr)),\n-                                                ast::DUMMY_NODE_ID),\n+            vis.push(ast::ViewItem {\n+                node: ast::ViewItemExternMod(self.sess.ident_of(\"green\"),\n+                                             Some((format!(\"green\\\\#{}\", VERSION).to_managed(),\n+                                                   ast::CookedStr)),\n+                                             ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n-                vis: ast::private,\n+                vis: ast::Private,\n                 span: DUMMY_SP\n             });\n-            vis.push(ast::view_item {\n-                node: ast::view_item_extern_mod(self.sess.ident_of(\"rustuv\"),\n-                                                Some((format!(\"rustuv\\\\#{}\", VERSION).to_managed(),\n-                                                      ast::CookedStr)),\n-                                                ast::DUMMY_NODE_ID),\n+            vis.push(ast::ViewItem {\n+                node: ast::ViewItemExternMod(self.sess.ident_of(\"rustuv\"),\n+                                             Some((format!(\"rustuv\\\\#{}\", VERSION).to_managed(),\n+                                                   ast::CookedStr)),\n+                                             ast::DUMMY_NODE_ID),\n                 attrs: ~[],\n-                vis: ast::private,\n+                vis: ast::Private,\n                 span: DUMMY_SP\n             });\n         }\n \n         vis.push_all(crate.module.view_items);\n-        let mut new_module = ast::_mod {\n+        let mut new_module = ast::Mod {\n             view_items: vis,\n             ..crate.module.clone()\n         };\n@@ -106,7 +106,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         if !no_prelude(item.attrs) {\n             // only recur if there wasn't `#[no_implicit_prelude];`\n             // on this item, i.e. this means that the prelude is not\n@@ -117,7 +117,7 @@ impl fold::ast_fold for StandardLibraryInjector {\n         }\n     }\n \n-    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n@@ -135,19 +135,18 @@ impl fold::ast_fold for StandardLibraryInjector {\n             ],\n         };\n \n-        let vp = @spanned(ast::view_path_glob(prelude_path,\n-                                              ast::DUMMY_NODE_ID));\n-        let vi2 = ast::view_item {\n-            node: ast::view_item_use(~[vp]),\n+        let vp = @spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID));\n+        let vi2 = ast::ViewItem {\n+            node: ast::ViewItemUse(~[vp]),\n             attrs: ~[],\n-            vis: ast::private,\n+            vis: ast::Private,\n             span: DUMMY_SP,\n         };\n \n         let vis = vec::append(~[vi2], module.view_items);\n \n         // FIXME #2543: Bad copy.\n-        let new_module = ast::_mod {\n+        let new_module = ast::Mod {\n             view_items: vis,\n             ..(*module).clone()\n         };"}, {"sha": "f78f1b2407d97e571d5b06d44a66093b7473b7c9", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -23,7 +23,7 @@ use syntax::attr;\n use syntax::codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n-use syntax::fold::ast_fold;\n+use syntax::fold::Folder;\n use syntax::fold;\n use syntax::opt_vec;\n use syntax::print::pprust;\n@@ -67,7 +67,7 @@ struct TestHarnessGenerator {\n     cx: TestCtxt,\n }\n \n-impl fold::ast_fold for TestHarnessGenerator {\n+impl fold::Folder for TestHarnessGenerator {\n     fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let folded = fold::noop_fold_crate(c, self);\n \n@@ -79,7 +79,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n         }\n     }\n \n-    fn fold_item(&mut self, i: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, i: @ast::Item) -> SmallVector<@ast::Item> {\n         {\n             let mut path = self.cx.path.borrow_mut();\n             path.get().push(i.ident);\n@@ -89,8 +89,8 @@ impl fold::ast_fold for TestHarnessGenerator {\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n             match i.node {\n-                ast::item_fn(_, purity, _, _, _)\n-                    if purity == ast::unsafe_fn => {\n+                ast::ItemFn(_, purity, _, _, _)\n+                    if purity == ast::UnsafeFn => {\n                     let sess = self.cx.sess;\n                     sess.span_fatal(i.span,\n                                     \"unsafe functions cannot be used for \\\n@@ -123,13 +123,13 @@ impl fold::ast_fold for TestHarnessGenerator {\n         res\n     }\n \n-    fn fold_mod(&mut self, m: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(cx: &TestCtxt, item: @ast::item) -> @ast::item {\n+        fn nomain(cx: &TestCtxt, item: @ast::Item) -> @ast::Item {\n             if !cx.sess.building_library.get() {\n-                @ast::item {\n+                @ast::Item {\n                     attrs: item.attrs.iter().filter_map(|attr| {\n                         if \"main\" != attr.name() {\n                             Some(*attr)\n@@ -144,7 +144,7 @@ impl fold::ast_fold for TestHarnessGenerator {\n             }\n         }\n \n-        let mod_nomain = ast::_mod {\n+        let mod_nomain = ast::Mod {\n             view_items: m.view_items.clone(),\n             items: m.items.iter().map(|i| nomain(&self.cx, *i)).collect(),\n         };\n@@ -190,14 +190,14 @@ fn strip_test_functions(crate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: @ast::item) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: @ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs, \"test\");\n \n-    fn has_test_signature(i: @ast::item) -> bool {\n+    fn has_test_signature(i: @ast::Item) -> bool {\n         match &i.node {\n-          &ast::item_fn(ref decl, _, _, ref generics, _) => {\n+          &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n-                ast::ty_nil => true,\n+                ast::TyNil => true,\n                 _ => false\n             };\n             decl.inputs.is_empty()\n@@ -219,15 +219,15 @@ fn is_test_fn(cx: &TestCtxt, i: @ast::item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(i: @ast::item) -> bool {\n+fn is_bench_fn(i: @ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs, \"bench\");\n \n-    fn has_test_signature(i: @ast::item) -> bool {\n+    fn has_test_signature(i: @ast::Item) -> bool {\n         match i.node {\n-            ast::item_fn(ref decl, _, _, ref generics, _) => {\n+            ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output.node {\n-                    ast::ty_nil => true,\n+                    ast::TyNil => true,\n                     _ => false\n                 };\n                 let tparm_cnt = generics.ty_params.len();\n@@ -243,7 +243,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: &TestCtxt, i: @ast::item) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: @ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n@@ -253,13 +253,13 @@ fn is_ignored(cx: &TestCtxt, i: @ast::item) -> bool {\n     })\n }\n \n-fn should_fail(i: @ast::item) -> bool {\n+fn should_fail(i: @ast::Item) -> bool {\n     attr::contains_name(i.attrs, \"should_fail\")\n }\n \n-fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: &TestCtxt, m: &ast::Mod) -> ast::Mod {\n     let testmod = mk_test_module(cx);\n-    ast::_mod {\n+    ast::Mod {\n         items: vec::append_one(m.items.clone(), testmod),\n         ..(*m).clone()\n     }\n@@ -284,28 +284,28 @@ mod __test {\n \n */\n \n-fn mk_std(cx: &TestCtxt) -> ast::view_item {\n+fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_extra = cx.sess.ident_of(\"extra\");\n     let vi = if cx.is_extra {\n-        ast::view_item_use(\n-            ~[@nospan(ast::view_path_simple(id_extra,\n-                                            path_node(~[id_extra]),\n-                                            ast::DUMMY_NODE_ID))])\n+        ast::ViewItemUse(\n+            ~[@nospan(ast::ViewPathSimple(id_extra,\n+                                          path_node(~[id_extra]),\n+                                          ast::DUMMY_NODE_ID))])\n     } else {\n-        ast::view_item_extern_mod(id_extra,\n-                                  Some((format!(\"extra\\\\#{}\", VERSION).to_managed(),\n-                                        ast::CookedStr)),\n-                                  ast::DUMMY_NODE_ID)\n+        ast::ViewItemExternMod(id_extra,\n+                               Some((format!(\"extra\\\\#{}\", VERSION).to_managed(),\n+                                    ast::CookedStr)),\n+                               ast::DUMMY_NODE_ID)\n     };\n-    ast::view_item {\n+    ast::ViewItem {\n         node: vi,\n         attrs: ~[],\n-        vis: ast::public,\n+        vis: ast::Public,\n         span: DUMMY_SP\n     }\n }\n \n-fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n+fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n \n     // Link to extra\n     let view_items = ~[mk_std(cx)];\n@@ -322,22 +322,22 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n         }\n     )).unwrap();\n \n-    let testmod = ast::_mod {\n+    let testmod = ast::Mod {\n         view_items: view_items,\n         items: ~[mainfn, tests],\n     };\n-    let item_ = ast::item_mod(testmod);\n+    let item_ = ast::ItemMod(testmod);\n \n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n         attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n \n-    let item = ast::item {\n+    let item = ast::Item {\n         ident: cx.sess.ident_of(\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: item_,\n-        vis: ast::public,\n+        vis: ast::Public,\n         span: DUMMY_SP,\n      };\n \n@@ -375,7 +375,7 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n-fn mk_tests(cx: &TestCtxt) -> @ast::item {\n+fn mk_tests(cx: &TestCtxt) -> @ast::Item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n@@ -422,8 +422,8 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n \n     debug!(\"encoding {}\", ast_util::path_name_i(path));\n \n-    let name_lit: ast::lit =\n-        nospan(ast::lit_str(ast_util::path_name_i(path).to_managed(), ast::CookedStr));\n+    let name_lit: ast::Lit =\n+        nospan(ast::LitStr(ast_util::path_name_i(path).to_managed(), ast::CookedStr));\n \n     let name_expr = @ast::Expr {\n           id: ast::DUMMY_NODE_ID,"}, {"sha": "82fed27b56521334b0d53b915b3a6f676b147ca6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -363,8 +363,8 @@ impl diagnostic::Emitter for RustcEmitter {\n     fn emit(&self,\n             cmsp: Option<(&codemap::CodeMap, codemap::Span)>,\n             msg: &str,\n-            lvl: diagnostic::level) {\n-        if lvl == diagnostic::fatal {\n+            lvl: diagnostic::Level) {\n+        if lvl == diagnostic::Fatal {\n             let this = unsafe { cast::transmute_mut(self) };\n             this.ch_capture.send(fatal)\n         }\n@@ -434,7 +434,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n                 diagnostic::DefaultEmitter.emit(\n                     None,\n                     diagnostic::ice_msg(\"unexpected failure\"),\n-                    diagnostic::error);\n+                    diagnostic::Error);\n \n                 let xs = [\n                     ~\"the compiler hit an unexpected failure path. \\\n@@ -446,7 +446,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n                 for note in xs.iter() {\n                     diagnostic::DefaultEmitter.emit(None,\n                                                     *note,\n-                                                    diagnostic::note)\n+                                                    diagnostic::Note)\n                 }\n             }\n             // Fail so the process returns a failure code"}, {"sha": "2d86a36dd60ab01219809355d47fe3c91968794c", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -83,11 +83,11 @@ pub static tag_item_super_trait_ref: uint = 0x33u;\n // discriminator value for variants\n pub static tag_disr_val: uint = 0x34u;\n \n-// used to encode ast_map::path and ast_map::path_elt\n+// used to encode ast_map::Path and ast_map::PathElem\n pub static tag_path: uint = 0x40u;\n pub static tag_path_len: uint = 0x41u;\n-pub static tag_path_elt_mod: uint = 0x42u;\n-pub static tag_path_elt_name: uint = 0x43u;\n+pub static tag_path_elem_mod: uint = 0x42u;\n+pub static tag_path_elem_name: uint = 0x43u;\n pub static tag_item_field: uint = 0x44u;\n pub static tag_struct_mut: uint = 0x45u;\n \n@@ -191,9 +191,9 @@ pub static tag_impls_impl: uint = 0x84;\n pub static tag_items_data_item_inherent_impl: uint = 0x85;\n pub static tag_items_data_item_extension_impl: uint = 0x86;\n \n-pub static tag_path_elt_pretty_name: uint = 0x87;\n-pub static tag_path_elt_pretty_name_ident: uint = 0x88;\n-pub static tag_path_elt_pretty_name_extra: uint = 0x89;\n+pub static tag_path_elem_pretty_name: uint = 0x87;\n+pub static tag_path_elem_pretty_name_ident: uint = 0x88;\n+pub static tag_path_elem_pretty_name_extra: uint = 0x89;\n \n pub static tag_region_param_def: uint = 0x100;\n pub static tag_region_param_def_ident: uint = 0x101;"}, {"sha": "6508da88f3d4e9b840c768c5d92790820021c69e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -24,7 +24,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n-use syntax::parse::token::ident_interner;\n+use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n use syntax::visit;\n \n@@ -33,7 +33,7 @@ use syntax::visit;\n pub fn read_crates(sess: Session,\n                    crate: &ast::Crate,\n                    os: loader::Os,\n-                   intr: @ident_interner) {\n+                   intr: @IdentInterner) {\n     let mut e = Env {\n         sess: sess,\n         os: os,\n@@ -58,11 +58,11 @@ struct ReadCrateVisitor<'a> {\n }\n \n impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n-    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n+    fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n         visit_view_item(self.e, a);\n         visit::walk_view_item(self, a, ());\n     }\n-    fn visit_item(&mut self, a: &ast::item, _: ()) {\n+    fn visit_item(&mut self, a: &ast::Item, _: ()) {\n         visit_item(self.e, a);\n         visit::walk_item(self, a, ());\n     }\n@@ -114,7 +114,7 @@ struct Env {\n     os: loader::Os,\n     crate_cache: @RefCell<~[cache_entry]>,\n     next_crate_num: ast::CrateNum,\n-    intr: @ident_interner\n+    intr: @IdentInterner\n }\n \n fn visit_crate(e: &Env, c: &ast::Crate) {\n@@ -130,9 +130,9 @@ fn visit_crate(e: &Env, c: &ast::Crate) {\n     }\n }\n \n-fn visit_view_item(e: &mut Env, i: &ast::view_item) {\n+fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n     match i.node {\n-      ast::view_item_extern_mod(ident, path_opt, id) => {\n+      ast::ViewItemExternMod(ident, path_opt, id) => {\n           let ident = token::ident_to_str(&ident);\n           debug!(\"resolving extern mod stmt. ident: {:?} path_opt: {:?}\",\n                  ident, path_opt);\n@@ -164,9 +164,9 @@ fn visit_view_item(e: &mut Env, i: &ast::view_item) {\n   }\n }\n \n-fn visit_item(e: &Env, i: &ast::item) {\n+fn visit_item(e: &Env, i: &ast::Item) {\n     match i.node {\n-        ast::item_foreign_mod(ref fm) => {\n+        ast::ItemForeignMod(ref fm) => {\n             if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n                 return;\n             }"}, {"sha": "6dad364e661ba9a361f02debcd7460b054703421", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -26,8 +26,8 @@ use syntax::diagnostic::expect;\n pub struct StaticMethodInfo {\n     ident: ast::Ident,\n     def_id: ast::DefId,\n-    purity: ast::purity,\n-    vis: ast::visibility,\n+    purity: ast::Purity,\n+    vis: ast::Visibility,\n }\n \n pub fn get_symbol(cstore: @cstore::CStore, def: ast::DefId) -> ~str {\n@@ -55,7 +55,7 @@ pub fn each_child_of_item(cstore: @cstore::CStore,\n                           def_id: ast::DefId,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n-                                     ast::visibility|) {\n+                                     ast::Visibility|) {\n     let crate_data = cstore.get_crate_data(def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -72,7 +72,7 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: |decoder::DefLike,\n                                                ast::Ident,\n-                                               ast::visibility|) {\n+                                               ast::Visibility|) {\n     let crate_data = cstore.get_crate_data(cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore.get_crate_data(cnum)\n@@ -83,20 +83,20 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::path {\n+pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> ast_map::Path {\n     let cstore = tcx.cstore;\n     let cdata = cstore.get_crate_data(def.crate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n+    vec::append(~[ast_map::PathMod(tcx.sess.ident_of(\n         cdata.name))], path)\n }\n \n pub enum found_ast {\n-    found(ast::inlined_item),\n-    found_parent(ast::DefId, ast::inlined_item),\n+    found(ast::InlinedItem),\n+    found_parent(ast::DefId, ast::InlinedItem),\n     not_found,\n }\n \n@@ -133,7 +133,7 @@ pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n \n pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n                                          def: ast::DefId)\n-                                     -> (ast::Ident, ast::explicit_self_)\n+                                     -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.crate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n@@ -257,7 +257,7 @@ pub fn get_impl_method(cstore: @cstore::CStore,\n \n pub fn get_item_visibility(cstore: @cstore::CStore,\n                            def_id: ast::DefId)\n-                        -> ast::visibility {\n+                        -> ast::Visibility {\n     let cdata = cstore.get_crate_data(def_id.crate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }"}, {"sha": "5be69e9452c0355c5dfa42987248fa1576d9e8df", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -18,7 +18,7 @@ use metadata::loader;\n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use syntax::ast;\n-use syntax::parse::token::ident_interner;\n+use syntax::parse::token::IdentInterner;\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -66,14 +66,14 @@ pub struct CStore {\n     priv used_crate_sources: RefCell<~[CrateSource]>,\n     priv used_libraries: RefCell<~[(~str, NativeLibaryKind)]>,\n     priv used_link_args: RefCell<~[~str]>,\n-    intr: @ident_interner\n+    intr: @IdentInterner\n }\n \n // Map from NodeId's of local extern mod statements to crate numbers\n type extern_mod_crate_map = HashMap<ast::NodeId, ast::CrateNum>;\n \n impl CStore {\n-    pub fn new(intr: @ident_interner) -> CStore {\n+    pub fn new(intr: @IdentInterner) -> CStore {\n         CStore {\n             metas: RefCell::new(HashMap::new()),\n             extern_mod_crate_map: RefCell::new(HashMap::new()),"}, {"sha": "ca35b1ae96b0285a3d5a717797de067fbce0e7f2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 61, "deletions": 65, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -36,7 +36,7 @@ use extra::ebml;\n use extra::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n-use syntax::parse::token::{ident_interner, special_idents};\n+use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n@@ -152,14 +152,14 @@ fn item_family(item: ebml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: ebml::Doc) -> ast::visibility {\n+fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => ast::public,\n+        None => ast::Public,\n         Some(visibility_doc) => {\n             match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => ast::public,\n-                'n' => ast::private,\n-                'i' => ast::inherited,\n+                'y' => ast::Public,\n+                'n' => ast::Private,\n+                'i' => ast::Inherited,\n                 _ => fail!(\"unknown visibility character\")\n             }\n         }\n@@ -306,29 +306,29 @@ fn enum_variant_ids(item: ebml::Doc, cdata: Cmd) -> ~[ast::DefId] {\n     return ids;\n }\n \n-pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n+pub fn item_path(item_doc: ebml::Doc) -> ast_map::Path {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n-        if tag == tag_path_elt_mod {\n+        if tag == tag_path_elem_mod {\n             let str = elt_doc.as_str_slice();\n-            result.push(ast_map::path_mod(token::str_to_ident(str)));\n-        } else if tag == tag_path_elt_name {\n+            result.push(ast_map::PathMod(token::str_to_ident(str)));\n+        } else if tag == tag_path_elem_name {\n             let str = elt_doc.as_str_slice();\n-            result.push(ast_map::path_name(token::str_to_ident(str)));\n-        } else if tag == tag_path_elt_pretty_name {\n+            result.push(ast_map::PathName(token::str_to_ident(str)));\n+        } else if tag == tag_path_elem_pretty_name {\n             let name_doc = reader::get_doc(elt_doc,\n-                                           tag_path_elt_pretty_name_ident);\n+                                           tag_path_elem_pretty_name_ident);\n             let extra_doc = reader::get_doc(elt_doc,\n-                                            tag_path_elt_pretty_name_extra);\n+                                            tag_path_elem_pretty_name_extra);\n             let str = name_doc.as_str_slice();\n             let extra = reader::doc_as_u64(extra_doc);\n-            result.push(ast_map::path_pretty_name(token::str_to_ident(str),\n-                                                  extra));\n+            result.push(ast_map::PathPrettyName(token::str_to_ident(str),\n+                                                extra));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -338,7 +338,7 @@ pub fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::Ident {\n+fn item_name(intr: @IdentInterner, item: ebml::Doc) -> ast::Ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n@@ -354,12 +354,12 @@ pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         ImmStatic => DlDef(ast::DefStatic(did, false)),\n         MutStatic => DlDef(ast::DefStatic(did, true)),\n         Struct    => DlDef(ast::DefStruct(did)),\n-        UnsafeFn  => DlDef(ast::DefFn(did, ast::unsafe_fn)),\n-        Fn        => DlDef(ast::DefFn(did, ast::impure_fn)),\n-        ForeignFn => DlDef(ast::DefFn(did, ast::extern_fn)),\n+        UnsafeFn  => DlDef(ast::DefFn(did, ast::UnsafeFn)),\n+        Fn        => DlDef(ast::DefFn(did, ast::ImpureFn)),\n+        ForeignFn => DlDef(ast::DefFn(did, ast::ExternFn)),\n         StaticMethod | UnsafeStaticMethod => {\n-            let purity = if fam == UnsafeStaticMethod { ast::unsafe_fn } else\n-                { ast::impure_fn };\n+            let purity = if fam == UnsafeStaticMethod { ast::UnsafeFn } else\n+                { ast::ImpureFn };\n             // def_static_method carries an optional field of its enclosing\n             // trait or enclosing impl (if this is an inherent static method).\n             // So we need to detect whether this is in a trait or not, which\n@@ -475,7 +475,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n }\n \n \n-pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_impl_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n                        name: ast::Ident) -> Option<ast::DefId> {\n     let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     let mut found = None;\n@@ -524,13 +524,13 @@ pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n     })\n }\n \n-fn each_child_of_item_or_crate(intr: @ident_interner,\n+fn each_child_of_item_or_crate(intr: @IdentInterner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n                                callback: |DefLike,\n                                           ast::Ident,\n-                                          ast::visibility|) {\n+                                          ast::Visibility|) {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -644,7 +644,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                                 cdata.cnum);\n                 // These items have a public visibility because they're part of\n                 // a public re-export.\n-                callback(def_like, token::str_to_ident(name), ast::public);\n+                callback(def_like, token::str_to_ident(name), ast::Public);\n             }\n         }\n \n@@ -653,11 +653,11 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(intr: @ident_interner,\n+pub fn each_child_of_item(intr: @IdentInterner,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: |DefLike, ast::Ident, ast::visibility|) {\n+                          callback: |DefLike, ast::Ident, ast::Visibility|) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -674,12 +674,12 @@ pub fn each_child_of_item(intr: @ident_interner,\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate(intr: @ident_interner,\n+pub fn each_top_level_item_of_crate(intr: @IdentInterner,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n                                     callback: |DefLike,\n                                                ast::Ident,\n-                                               ast::visibility|) {\n+                                               ast::Visibility|) {\n     let root_doc = reader::Doc(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -692,15 +692,15 @@ pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                 callback)\n }\n \n-pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::path {\n+pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::Path {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n pub type decode_inlined_item<'a> = 'a |cdata: @cstore::crate_metadata,\n                                              tcx: ty::ctxt,\n-                                             path: ast_map::path,\n+                                             path: ast_map::Path,\n                                              par_doc: ebml::Doc|\n-                                             -> Option<ast::inlined_item>;\n+                                             -> Option<ast::InlinedItem>;\n \n pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           id: ast::NodeId,\n@@ -730,7 +730,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n     }\n }\n \n-pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n@@ -760,13 +760,13 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n             // for variants -- TEST -- tjc\n             id: *did,\n             disr_val: disr_val,\n-            vis: ast::inherited});\n+            vis: ast::Inherited});\n         disr_val += 1;\n     }\n     return infos;\n }\n \n-fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n+fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     fn get_mutability(ch: u8) -> ast::Mutability {\n         match ch as char {\n             'i' => ast::MutImmutable,\n@@ -780,21 +780,17 @@ fn get_explicit_self(item: ebml::Doc) -> ast::explicit_self_ {\n \n     let explicit_self_kind = string[0];\n     match explicit_self_kind as char {\n-        's' => { return ast::sty_static; }\n-        'v' => { return ast::sty_value(get_mutability(string[1])); }\n-        '@' => { return ast::sty_box(get_mutability(string[1])); }\n-        '~' => { return ast::sty_uniq(get_mutability(string[1])); }\n-        '&' => {\n-            // FIXME(#4846) expl. region\n-            return ast::sty_region(None, get_mutability(string[1]));\n-        }\n-        _ => {\n-            fail!(\"unknown self type code: `{}`\", explicit_self_kind as char);\n-        }\n+        's' => ast::SelfStatic,\n+        'v' => ast::SelfValue(get_mutability(string[1])),\n+        '@' => ast::SelfBox(get_mutability(string[1])),\n+        '~' => ast::SelfUniq(get_mutability(string[1])),\n+        // FIXME(#4846) expl. region\n+        '&' => ast::SelfRegion(None, get_mutability(string[1])),\n+        _ => fail!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n     }\n }\n \n-fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n+fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n                      tcx: ty::ctxt) -> ~[@ty::Method] {\n     let mut rslt = ~[];\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n@@ -807,7 +803,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n+pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n                tcx: ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data();\n@@ -823,17 +819,17 @@ pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n }\n \n pub fn get_method_name_and_explicit_self(\n-    intr: @ident_interner,\n+    intr: @IdentInterner,\n     cdata: Cmd,\n-    id: ast::NodeId) -> (ast::Ident, ast::explicit_self_)\n+    id: ast::NodeId) -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let method_doc = lookup_item(id, cdata.data());\n     let name = item_name(intr, method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n     (name, explicit_self)\n }\n \n-pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n+pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n                   tcx: ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data());\n@@ -893,7 +889,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder)\n }\n \n-pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n+pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {\n     let data = cdata.data();\n@@ -947,7 +943,7 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n     ret\n }\n \n-pub fn get_static_methods_if_impl(intr: @ident_interner,\n+pub fn get_static_methods_if_impl(intr: @IdentInterner,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n                                -> Option<~[StaticMethodInfo]> {\n@@ -977,8 +973,8 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n             StaticMethod | UnsafeStaticMethod => {\n                 let purity;\n                 match item_family(impl_method_doc) {\n-                    StaticMethod => purity = ast::impure_fn,\n-                    UnsafeStaticMethod => purity = ast::unsafe_fn,\n+                    StaticMethod => purity = ast::ImpureFn,\n+                    UnsafeStaticMethod => purity = ast::UnsafeFn,\n                     _ => fail!()\n                 }\n \n@@ -1009,16 +1005,16 @@ pub fn get_item_attrs(cdata: Cmd,\n     });\n }\n \n-fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n     match family {\n-      PublicField => ast::public,\n-      PrivateField => ast::private,\n-      InheritedField => ast::inherited,\n+      PublicField => ast::Public,\n+      PrivateField => ast::Private,\n+      InheritedField => ast::Inherited,\n       _ => fail!()\n     }\n }\n \n-pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n+pub fn get_struct_fields(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId)\n     -> ~[ty::field_ty] {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n@@ -1042,15 +1038,15 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n-            vis: ast::inherited,\n+            vis: ast::Inherited,\n         });\n         true\n     });\n     result\n }\n \n pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n-                        -> ast::visibility {\n+                        -> ast::Visibility {\n     item_visibility(lookup_item(id, cdata.data()))\n }\n \n@@ -1109,7 +1105,7 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::Attribute] {\n     return attrs;\n }\n \n-fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n+fn list_crate_attributes(intr: @IdentInterner, md: ebml::Doc, hash: &str,\n                          out: &mut io::Writer) {\n     write!(out, \"=Crate Attributes ({})=\\n\", hash);\n \n@@ -1179,7 +1175,7 @@ pub fn get_crate_vers(data: &[u8]) -> @str {\n     }\n }\n \n-pub fn list_crate_metadata(intr: @ident_interner, bytes: &[u8],\n+pub fn list_crate_metadata(intr: @IdentInterner, bytes: &[u8],\n                            out: &mut io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);"}, {"sha": "a860b148aa9d29ad4bb34d4ba96a7102abcf19d5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 135, "deletions": 135, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -49,16 +49,16 @@ use writer = extra::ebml::writer;\n // used by astencode:\n type abbrev_map = @RefCell<HashMap<ty::t, tyencode::ty_abbrev>>;\n \n-/// A borrowed version of ast::inlined_item.\n+/// A borrowed version of ast::InlinedItem.\n pub enum InlinedItemRef<'a> {\n-    ii_item_ref(&'a ast::item),\n-    ii_method_ref(ast::DefId, bool, &'a ast::method),\n-    ii_foreign_ref(&'a ast::foreign_item)\n+    IIItemRef(&'a ast::Item),\n+    IIMethodRef(ast::DefId, bool, &'a ast::Method),\n+    IIForeignRef(&'a ast::ForeignItem)\n }\n \n pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n                                        ebml_w: &mut writer::Encoder,\n-                                       path: &[ast_map::path_elt],\n+                                       path: &[ast_map::PathElem],\n                                        ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n@@ -318,17 +318,17 @@ fn encode_parent_item(ebml_w: &mut writer::Encoder, id: DefId) {\n \n fn encode_struct_fields(ecx: &EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n-                             def: @struct_def) {\n+                             def: @StructDef) {\n     for f in def.fields.iter() {\n         match f.node.kind {\n-            named_field(ident, vis) => {\n+            NamedField(ident, vis) => {\n                ebml_w.start_tag(tag_item_field);\n                encode_struct_field_family(ebml_w, vis);\n                encode_name(ecx, ebml_w, ident);\n                encode_def_id(ebml_w, local_def(f.node.id));\n                ebml_w.end_tag();\n             }\n-            unnamed_field => {\n+            UnnamedField => {\n                 ebml_w.start_tag(tag_item_unnamed_field);\n                 encode_def_id(ebml_w, local_def(f.node.id));\n                 ebml_w.end_tag();\n@@ -340,8 +340,8 @@ fn encode_struct_fields(ecx: &EncodeContext,\n fn encode_enum_variant_info(ecx: &EncodeContext,\n                             ebml_w: &mut writer::Encoder,\n                             id: NodeId,\n-                            variants: &[P<variant>],\n-                            path: &[ast_map::path_elt],\n+                            variants: &[P<Variant>],\n+                            path: &[ast_map::PathElem],\n                             index: @RefCell<~[entry<i64>]>,\n                             generics: &ast::Generics) {\n     debug!(\"encode_enum_variant_info(id={:?})\", id);\n@@ -362,20 +362,20 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         match variant.node.kind {\n-            ast::tuple_variant_kind(_) => encode_family(ebml_w, 'v'),\n-            ast::struct_variant_kind(_) => encode_family(ebml_w, 'V')\n+            ast::TupleVariantKind(_) => encode_family(ebml_w, 'v'),\n+            ast::StructVariantKind(_) => encode_family(ebml_w, 'V')\n         }\n         encode_name(ecx, ebml_w, variant.node.name);\n         encode_parent_item(ebml_w, local_def(id));\n         encode_visibility(ebml_w, variant.node.vis);\n         encode_attributes(ebml_w, variant.node.attrs);\n         match variant.node.kind {\n-            ast::tuple_variant_kind(ref args)\n+            ast::TupleVariantKind(ref args)\n                     if args.len() > 0 && generics.ty_params.len() == 0 => {\n                 encode_symbol(ecx, ebml_w, variant.node.id);\n             }\n-            ast::tuple_variant_kind(_) => {},\n-            ast::struct_variant_kind(def) => {\n+            ast::TupleVariantKind(_) => {},\n+            ast::StructVariantKind(def) => {\n                 let idx = encode_info_for_struct(ecx, ebml_w, path,\n                                          def.fields, index);\n                 encode_struct_fields(ecx, ebml_w, def);\n@@ -390,7 +390,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n         encode_path(ecx, ebml_w, path,\n-                    ast_map::path_name(variant.node.name));\n+                    ast_map::PathName(variant.node.name));\n         ebml_w.end_tag();\n         disr_val += 1;\n         i += 1;\n@@ -399,23 +399,23 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n \n fn encode_path(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n-               path: &[ast_map::path_elt],\n-               name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: &EncodeContext,\n+               path: &[ast_map::PathElem],\n+               name: ast_map::PathElem) {\n+    fn encode_path_elem(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n-                       elt: ast_map::path_elt) {\n+                       elt: ast_map::PathElem) {\n         match elt {\n-            ast_map::path_mod(n) => {\n-                ebml_w.wr_tagged_str(tag_path_elt_mod, ecx.tcx.sess.str_of(n));\n+            ast_map::PathMod(n) => {\n+                ebml_w.wr_tagged_str(tag_path_elem_mod, ecx.tcx.sess.str_of(n));\n             }\n-            ast_map::path_name(n) => {\n-                ebml_w.wr_tagged_str(tag_path_elt_name, ecx.tcx.sess.str_of(n));\n+            ast_map::PathName(n) => {\n+                ebml_w.wr_tagged_str(tag_path_elem_name, ecx.tcx.sess.str_of(n));\n             }\n-            ast_map::path_pretty_name(n, extra) => {\n-                ebml_w.start_tag(tag_path_elt_pretty_name);\n-                ebml_w.wr_tagged_str(tag_path_elt_pretty_name_ident,\n+            ast_map::PathPrettyName(n, extra) => {\n+                ebml_w.start_tag(tag_path_elem_pretty_name);\n+                ebml_w.wr_tagged_str(tag_path_elem_pretty_name_ident,\n                                      ecx.tcx.sess.str_of(n));\n-                ebml_w.wr_tagged_u64(tag_path_elt_pretty_name_extra, extra);\n+                ebml_w.wr_tagged_u64(tag_path_elem_pretty_name_extra, extra);\n                 ebml_w.end_tag();\n             }\n         }\n@@ -424,9 +424,9 @@ fn encode_path(ecx: &EncodeContext,\n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, (path.len() + 1) as u32);\n     for pe in path.iter() {\n-        encode_path_elt(ecx, ebml_w, *pe);\n+        encode_path_elem(ecx, ebml_w, *pe);\n     }\n-    encode_path_elt(ecx, ebml_w, name);\n+    encode_path_elem(ecx, ebml_w, name);\n     ebml_w.end_tag();\n }\n \n@@ -457,7 +457,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n             let implementations = implementations.borrow();\n             for &base_impl in implementations.get().iter() {\n                 for &m in base_impl.methods.iter() {\n-                    if m.explicit_self == ast::sty_static {\n+                    if m.explicit_self == ast::SelfStatic {\n                         encode_reexported_static_method(ecx, ebml_w, exp,\n                                                         m.def_id, m.ident);\n                     }\n@@ -478,7 +478,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n     match trait_methods_cache.get().find(&exp.def_id) {\n         Some(methods) => {\n             for &m in methods.iter() {\n-                if m.explicit_self == ast::sty_static {\n+                if m.explicit_self == ast::SelfStatic {\n                     encode_reexported_static_method(ecx, ebml_w, exp,\n                                                     m.def_id, m.ident);\n                 }\n@@ -492,11 +492,11 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n \n fn encode_reexported_static_methods(ecx: &EncodeContext,\n                                     ebml_w: &mut writer::Encoder,\n-                                    mod_path: &[ast_map::path_elt],\n+                                    mod_path: &[ast_map::PathElem],\n                                     exp: &middle::resolve::Export2) {\n     let items = ecx.tcx.items.borrow();\n     match items.get().find(&exp.def_id.node) {\n-        Some(&ast_map::node_item(item, path)) => {\n+        Some(&ast_map::NodeItem(item, path)) => {\n             let original_name = ecx.tcx.sess.str_of(item.ident);\n \n             //\n@@ -533,23 +533,23 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: @item, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n-        item_enum(ref enum_def, _) => {\n+        ItemEnum(ref enum_def, _) => {\n             for variant in enum_def.variants.iter() {\n                 continue_ = callback(variant.node.id);\n                 if !continue_ {\n                     break\n                 }\n             }\n         }\n-        item_struct(struct_def, _) => {\n+        ItemStruct(struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n                         struct_def.fields[0].node.kind ==\n-                        ast::unnamed_field => {\n+                        ast::UnnamedField => {\n                     continue_ = callback(ctor_id);\n                 }\n                 _ => {}\n@@ -564,7 +564,7 @@ fn each_auxiliary_node_id(item: @item, callback: |NodeId| -> bool) -> bool {\n fn encode_reexports(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     id: NodeId,\n-                    path: &[ast_map::path_elt]) {\n+                    path: &[ast_map::PathElem]) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n     let reexports2 = ecx.reexports2.borrow();\n     match reexports2.get().find(&id) {\n@@ -597,11 +597,11 @@ fn encode_reexports(ecx: &EncodeContext,\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n-                       md: &_mod,\n+                       md: &Mod,\n                        id: NodeId,\n-                       path: &[ast_map::path_elt],\n+                       path: &[ast_map::PathElem],\n                        name: Ident,\n-                       vis: visibility) {\n+                       vis: Visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n@@ -622,7 +622,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         match item.node {\n-            item_impl(..) => {\n+            ItemImpl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({:?}/{:?})\",\n@@ -638,11 +638,11 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         }\n     }\n \n-    encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n+    encode_path(ecx, ebml_w, path, ast_map::PathMod(name));\n     encode_visibility(ebml_w, vis);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == public {\n+    if vis == Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, ebml_w, id, path);\n     }\n@@ -651,47 +651,47 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n-                              visibility: visibility) {\n+                              visibility: Visibility) {\n     encode_family(ebml_w, match visibility {\n-        public => 'g',\n-        private => 'j',\n-        inherited => 'N'\n+        Public => 'g',\n+        Private => 'j',\n+        Inherited => 'N'\n     });\n }\n \n-fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: visibility) {\n+fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: Visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n-        public => 'y',\n-        private => 'n',\n-        inherited => 'i',\n+        Public => 'y',\n+        Private => 'n',\n+        Inherited => 'i',\n     };\n     ebml_w.wr_str(str::from_char(ch));\n     ebml_w.end_tag();\n }\n \n-fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::explicit_self_) {\n+fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::ExplicitSelf_) {\n     ebml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n     match explicit_self {\n-        sty_static => {\n+        SelfStatic => {\n             ebml_w.writer.write(&[ 's' as u8 ]);\n         }\n-        sty_value(m) => {\n+        SelfValue(m) => {\n             ebml_w.writer.write(&[ 'v' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_region(_, m) => {\n+        SelfRegion(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n             ebml_w.writer.write(&[ '&' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_box(m) => {\n+        SelfBox(m) => {\n             ebml_w.writer.write(&[ '@' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n-        sty_uniq(m) => {\n+        SelfUniq(m) => {\n             ebml_w.writer.write(&[ '~' as u8 ]);\n             encode_mutability(ebml_w, m);\n         }\n@@ -727,8 +727,8 @@ fn encode_provided_source(ebml_w: &mut writer::Encoder,\n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n-                          path: &[ast_map::path_elt],\n-                          fields: &[struct_field],\n+                          path: &[ast_map::PathElem],\n+                          fields: &[StructField],\n                           global_index: @RefCell<~[entry<i64>]>)\n                           -> ~[entry<i64>] {\n     /* Each class has its own index, since different classes\n@@ -739,8 +739,8 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n         private fields to get the offsets right */\n     for field in fields.iter() {\n         let (nm, vis) = match field.node.kind {\n-            named_field(nm, vis) => (nm, vis),\n-            unnamed_field => (special_idents::unnamed_field, inherited)\n+            NamedField(nm, vis) => (nm, vis),\n+            UnnamedField => (special_idents::unnamed_field, Inherited)\n         };\n \n         let id = field.node.id;\n@@ -757,7 +757,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n                tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(nm));\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n         encode_def_id(ebml_w, local_def(id));\n         ebml_w.end_tag();\n@@ -767,7 +767,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n-                               path: &[ast_map::path_elt],\n+                               path: &[ast_map::PathElem],\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: @RefCell<~[entry<i64>]>,\n@@ -785,7 +785,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n     encode_family(ebml_w, 'f');\n     encode_name(ecx, ebml_w, name);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, ctor_id));\n-    encode_path(ecx, ebml_w, path, ast_map::path_name(name));\n+    encode_path(ecx, ebml_w, path, ast_map::PathName(name));\n     encode_parent_item(ebml_w, local_def(struct_id));\n \n     let item_symbols = ecx.item_symbols.borrow();\n@@ -810,7 +810,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_explicit_self(ebml_w, method_ty.explicit_self);\n     let purity = method_ty.fty.purity;\n     match method_ty.explicit_self {\n-        ast::sty_static => {\n+        ast::SelfStatic => {\n             encode_family(ebml_w, purity_static_method_family(purity));\n         }\n         _ => encode_family(ebml_w, purity_fn_family(purity))\n@@ -821,10 +821,10 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n fn encode_info_for_method(ecx: &EncodeContext,\n                           ebml_w: &mut writer::Encoder,\n                           m: &ty::Method,\n-                          impl_path: &[ast_map::path_elt],\n+                          impl_path: &[ast_map::PathElem],\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_method_opt: Option<@method>) {\n+                          ast_method_opt: Option<@Method>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            ecx.tcx.sess.str_of(m.ident));\n@@ -837,7 +837,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     let tpt = lookup_item_type(ecx.tcx, m.def_id);\n     encode_bounds_and_type(ebml_w, ecx, &tpt);\n \n-    encode_path(ecx, ebml_w, impl_path, ast_map::path_name(m.ident));\n+    encode_path(ecx, ebml_w, impl_path, ast_map::PathName(m.ident));\n     match ast_method_opt {\n         Some(ast_method) => encode_attributes(ebml_w, ast_method.attrs),\n         None => ()\n@@ -849,7 +849,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n             || should_inline(ast_method.attrs) {\n             (ecx.encode_inlined_item)(\n                 ecx, ebml_w, impl_path,\n-                ii_method_ref(local_def(parent_id), false, ast_method));\n+                IIMethodRef(local_def(parent_id), false, ast_method));\n         } else {\n             encode_symbol(ecx, ebml_w, m.def_id.node);\n         }\n@@ -858,19 +858,19 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn purity_fn_family(p: purity) -> char {\n+fn purity_fn_family(p: Purity) -> char {\n     match p {\n-      unsafe_fn => 'u',\n-      impure_fn => 'f',\n-      extern_fn => 'e'\n+        UnsafeFn => 'u',\n+        ImpureFn => 'f',\n+        ExternFn => 'e'\n     }\n }\n \n-fn purity_static_method_family(p: purity) -> char {\n+fn purity_static_method_family(p: Purity) -> char {\n     match p {\n-      unsafe_fn => 'U',\n-      impure_fn => 'F',\n-      _ => fail!(\"extern fn can't be static\")\n+        UnsafeFn => 'U',\n+        ImpureFn => 'F',\n+        _ => fail!(\"extern fn can't be static\")\n     }\n }\n \n@@ -921,13 +921,13 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n \n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n-                        item: &item,\n+                        item: &Item,\n                         index: @RefCell<~[entry<i64>]>,\n-                        path: &[ast_map::path_elt],\n-                        vis: ast::visibility) {\n+                        path: &[ast_map::PathElem],\n+                        vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &item, ebml_w: &writer::Encoder,\n+    fn add_to_index(item: &Item, ebml_w: &writer::Encoder,\n                      index: @RefCell<~[entry<i64>]>) {\n         let mut index = index.borrow_mut();\n         index.get().push(entry {\n@@ -942,7 +942,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n     let def_id = local_def(item.id);\n     match item.node {\n-      item_static(_, m, _) => {\n+      ItemStatic(_, m, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -954,7 +954,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_name(ecx, ebml_w, item.ident);\n-        let elt = ast_map::path_pretty_name(item.ident, item.id as u64);\n+        let elt = ast_map::PathPrettyName(item.ident, item.id as u64);\n         encode_path(ecx, ebml_w, path, elt);\n \n         let non_inlineable;\n@@ -964,30 +964,30 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n \n         if !non_inlineable {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      item_fn(_, purity, _, ref generics, _) => {\n+      ItemFn(_, purity, _, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, purity_fn_family(purity));\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n         } else {\n             encode_symbol(ecx, ebml_w, item.id);\n         }\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      item_mod(ref m) => {\n+      ItemMod(ref m) => {\n         add_to_index();\n         encode_info_for_mod(ecx,\n                             ebml_w,\n@@ -997,13 +997,13 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.ident,\n                             item.vis);\n       }\n-      item_foreign_mod(ref fm) => {\n+      ItemForeignMod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n \n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n@@ -1014,18 +1014,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      item_ty(..) => {\n+      ItemTy(..) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'y');\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      item_enum(ref enum_definition, ref generics) => {\n+      ItemEnum(ref enum_definition, ref generics) => {\n         add_to_index();\n \n         ebml_w.start_tag(tag_items_data_item);\n@@ -1038,8 +1038,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n         }\n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n \n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1055,7 +1055,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  index,\n                                  generics);\n       }\n-      item_struct(struct_def, _) => {\n+      ItemStruct(struct_def, _) => {\n         /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n@@ -1075,15 +1075,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(ebml_w, ecx, item.id);\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n         encode_visibility(ebml_w, vis);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n         encode_struct_fields(ecx, ebml_w, struct_def);\n \n-        (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item_ref(item));\n+        (ecx.encode_inlined_item)(ecx, ebml_w, path, IIItemRef(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1096,7 +1096,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // If this is a tuple- or enum-like struct, encode the type of the\n         // constructor.\n         if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::unnamed_field {\n+                struct_def.fields[0].node.kind == ast::UnnamedField {\n             let ctor_id = match struct_def.ctor_id {\n                 Some(ctor_id) => ctor_id,\n                 None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n@@ -1111,7 +1111,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         def_id.node);\n         }\n       }\n-      item_impl(_, ref opt_trait, ty, ref ast_methods) => {\n+      ItemImpl(_, ref opt_trait, ty, ref ast_methods) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impls = tcx.impls.borrow();\n@@ -1125,8 +1125,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(ref path, ref bounds, _) if path.segments\n-                                                         .len() == 1 => {\n+            ast::TyPath(ref path, ref bounds, _) if path.segments\n+                                                        .len() == 1 => {\n                 assert!(bounds.is_none());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n@@ -1180,7 +1180,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                    ast_method)\n         }\n       }\n-      item_trait(_, ref super_traits, ref ms) => {\n+      ItemTrait(_, ref super_traits, ref ms) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -1204,7 +1204,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.wr_str(def_to_str(method_def_id));\n             ebml_w.end_tag();\n         }\n-        encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+        encode_path(ecx, ebml_w, path, ast_map::PathName(item.ident));\n         // FIXME(#8559): This should use the tcx's supertrait cache instead of\n         // reading the AST's list, because the former has already filtered out\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n@@ -1240,11 +1240,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_parent_item(ebml_w, def_id);\n \n             let mut trait_path = vec::append(~[], path);\n-            trait_path.push(ast_map::path_name(item.ident));\n-            encode_path(ecx, ebml_w, trait_path, ast_map::path_name(method_ty.ident));\n+            trait_path.push(ast_map::PathName(item.ident));\n+            encode_path(ecx, ebml_w, trait_path, ast_map::PathName(method_ty.ident));\n \n             match method_ty.explicit_self {\n-                sty_static => {\n+                SelfStatic => {\n                     encode_family(ebml_w,\n                                   purity_static_method_family(\n                                       method_ty.fty.purity));\n@@ -1261,24 +1261,24 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n \n             match ms[i] {\n-                required(ref tm) => {\n+                Required(ref tm) => {\n                     encode_attributes(ebml_w, tm.attrs);\n                     encode_method_sort(ebml_w, 'r');\n                 }\n \n-                provided(m) => {\n+                Provided(m) => {\n                     encode_attributes(ebml_w, m.attrs);\n                     // If this is a static method, we've already encoded\n                     // this.\n-                    if method_ty.explicit_self != sty_static {\n+                    if method_ty.explicit_self != SelfStatic {\n                         // XXX: I feel like there is something funny going on.\n                         let tpt = ty::lookup_item_type(tcx, method_def_id);\n                         encode_bounds_and_type(ebml_w, ecx, &tpt);\n                     }\n                     encode_method_sort(ebml_w, 'p');\n                     (ecx.encode_inlined_item)(\n                         ecx, ebml_w, path,\n-                        ii_method_ref(def_id, true, m));\n+                        IIMethodRef(def_id, true, m));\n                 }\n             }\n \n@@ -1288,15 +1288,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      item_mac(..) => fail!(\"item macros unimplemented\")\n+      ItemMac(..) => fail!(\"item macros unimplemented\")\n     }\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 ebml_w: &mut writer::Encoder,\n-                                nitem: &foreign_item,\n+                                nitem: &ForeignItem,\n                                 index: @RefCell<~[entry<i64>]>,\n-                                path: &ast_map::path,\n+                                path: &ast_map::Path,\n                                 abi: AbiSet) {\n     {\n         let mut index = index.borrow_mut();\n@@ -1308,20 +1308,20 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n-      foreign_item_fn(..) => {\n+      ForeignItemFn(..) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n-        encode_family(ebml_w, purity_fn_family(impure_fn));\n+        encode_family(ebml_w, purity_fn_family(ImpureFn));\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n-            (ecx.encode_inlined_item)(ecx, ebml_w, *path, ii_foreign_ref(nitem));\n+            (ecx.encode_inlined_item)(ecx, ebml_w, *path, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n         }\n-        encode_path(ecx, ebml_w, *path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, *path, ast_map::PathName(nitem.ident));\n       }\n-      foreign_item_static(_, mutbl) => {\n+      ForeignItemStatic(_, mutbl) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         if mutbl {\n             encode_family(ebml_w, 'b');\n@@ -1331,22 +1331,22 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n         encode_name(ecx, ebml_w, nitem.ident);\n-        encode_path(ecx, ebml_w, *path, ast_map::path_name(nitem.ident));\n+        encode_path(ecx, ebml_w, *path, ast_map::PathName(nitem.ident));\n       }\n     }\n     ebml_w.end_tag();\n }\n \n fn my_visit_expr(_e: &Expr) { }\n \n-fn my_visit_item(i: &item,\n-                 items: ast_map::map,\n+fn my_visit_item(i: &Item,\n+                 items: ast_map::Map,\n                  ebml_w: &mut writer::Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<~[entry<i64>]>) {\n     let items = items.borrow();\n     match items.get().get_copy(&i.id) {\n-        ast_map::node_item(_, pt) => {\n+        ast_map::NodeItem(_, pt) => {\n             let mut ebml_w = unsafe {\n                 ebml_w.unsafe_clone()\n             };\n@@ -1358,14 +1358,14 @@ fn my_visit_item(i: &item,\n     }\n }\n \n-fn my_visit_foreign_item(ni: &foreign_item,\n-                         items: ast_map::map,\n+fn my_visit_foreign_item(ni: &ForeignItem,\n+                         items: ast_map::Map,\n                          ebml_w: &mut writer::Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<~[entry<i64>]>) {\n     let items = items.borrow();\n     match items.get().get_copy(&ni.id) {\n-        ast_map::node_foreign_item(_, abi, _, pt) => {\n+        ast_map::NodeForeignItem(_, abi, _, pt) => {\n             debug!(\"writing foreign item {}::{}\",\n                    ast_map::path_to_str(\n                        *pt,\n@@ -1392,7 +1392,7 @@ fn my_visit_foreign_item(ni: &foreign_item,\n struct EncodeVisitor<'a,'b> {\n     ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n     ecx_ptr:*int,\n-    items: ast_map::map,\n+    items: ast_map::Map,\n     index: @RefCell<~[entry<i64>]>,\n }\n \n@@ -1401,15 +1401,15 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n         visit::walk_expr(self, ex, ());\n         my_visit_expr(ex);\n     }\n-    fn visit_item(&mut self, i: &item, _: ()) {\n+    fn visit_item(&mut self, i: &Item, _: ()) {\n         visit::walk_item(self, i, ());\n         my_visit_item(i,\n                       self.items,\n                       self.ebml_w_for_visit_item,\n                       self.ecx_ptr,\n                       self.index);\n     }\n-    fn visit_foreign_item(&mut self, ni: &foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, ni: &ForeignItem, _: ()) {\n         visit::walk_foreign_item(self, ni, ());\n         my_visit_foreign_item(ni,\n                               self.items,\n@@ -1438,7 +1438,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         CRATE_NODE_ID,\n                         [],\n                         syntax::parse::token::special_idents::invalid,\n-                        public);\n+                        Public);\n     let items = ecx.tcx.items;\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n@@ -1531,7 +1531,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n       }\n       MetaNameValue(name, value) => {\n         match value.node {\n-          lit_str(value, _) => {\n+          LitStr(value, _) => {\n             ebml_w.start_tag(tag_meta_item_name_value);\n             ebml_w.start_tag(tag_meta_item_name);\n             ebml_w.writer.write(name.as_bytes());\n@@ -1698,9 +1698,9 @@ struct ImplVisitor<'a,'b> {\n }\n \n impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n-    fn visit_item(&mut self, item: &item, _: ()) {\n+    fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n-            item_impl(_, Some(ref trait_ref), _, _) => {\n+            ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 let def_map = self.ecx.tcx.def_map;\n                 let def_map = def_map.borrow();\n                 let trait_def = def_map.get().get_copy(&trait_ref.ref_id);"}, {"sha": "12bfcb4b1983c5c3fb52a6ce2d85a48e07c3f544", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -20,7 +20,7 @@ use metadata::filesearch::{FileMatches, FileDoesntMatch};\n use metadata::filesearch;\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use syntax::parse::token::ident_interner;\n+use syntax::parse::token::IdentInterner;\n use syntax::crateid::CrateId;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -52,7 +52,7 @@ pub struct Context {\n     version: @str,\n     hash: @str,\n     os: Os,\n-    intr: @ident_interner\n+    intr: @IdentInterner\n }\n \n pub struct Library {\n@@ -376,7 +376,7 @@ pub fn read_meta_section_name(os: Os) -> &'static str {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(intr: @ident_interner,\n+pub fn list_file_metadata(intr: @IdentInterner,\n                           os: Os,\n                           path: &Path,\n                           out: &mut io::Writer) {"}, {"sha": "5f57aef2b16e4d5870a8d623834029ac7d3d6a6a", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -302,16 +302,16 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'u' => return ty::mk_uint(),\n       'M' => {\n         match next(st) {\n-          'b' => return ty::mk_mach_uint(ast::ty_u8),\n-          'w' => return ty::mk_mach_uint(ast::ty_u16),\n-          'l' => return ty::mk_mach_uint(ast::ty_u32),\n-          'd' => return ty::mk_mach_uint(ast::ty_u64),\n-          'B' => return ty::mk_mach_int(ast::ty_i8),\n-          'W' => return ty::mk_mach_int(ast::ty_i16),\n-          'L' => return ty::mk_mach_int(ast::ty_i32),\n-          'D' => return ty::mk_mach_int(ast::ty_i64),\n-          'f' => return ty::mk_mach_float(ast::ty_f32),\n-          'F' => return ty::mk_mach_float(ast::ty_f64),\n+          'b' => return ty::mk_mach_uint(ast::TyU8),\n+          'w' => return ty::mk_mach_uint(ast::TyU16),\n+          'l' => return ty::mk_mach_uint(ast::TyU32),\n+          'd' => return ty::mk_mach_uint(ast::TyU64),\n+          'B' => return ty::mk_mach_int(ast::TyI8),\n+          'W' => return ty::mk_mach_int(ast::TyI16),\n+          'L' => return ty::mk_mach_int(ast::TyI32),\n+          'D' => return ty::mk_mach_int(ast::TyI64),\n+          'f' => return ty::mk_mach_float(ast::TyF32),\n+          'F' => return ty::mk_mach_float(ast::TyF64),\n           _ => fail!(\"parse_ty: bad numeric type\")\n         }\n       }\n@@ -463,12 +463,12 @@ fn parse_hex(st: &mut PState) -> uint {\n     };\n }\n \n-fn parse_purity(c: char) -> purity {\n+fn parse_purity(c: char) -> Purity {\n     match c {\n-      'u' => unsafe_fn,\n-      'i' => impure_fn,\n-      'c' => extern_fn,\n-      _ => fail!(\"parse_purity: bad purity {}\", c)\n+        'u' => UnsafeFn,\n+        'i' => ImpureFn,\n+        'c' => ExternFn,\n+        _ => fail!(\"parse_purity: bad purity {}\", c)\n     }\n }\n "}, {"sha": "8929859b2d60528cb24338929abc6065c2e1427a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -249,26 +249,26 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {\n             match t {\n-                ty_i => mywrite!(w, \"i\"),\n-                ty_i8 => mywrite!(w, \"MB\"),\n-                ty_i16 => mywrite!(w, \"MW\"),\n-                ty_i32 => mywrite!(w, \"ML\"),\n-                ty_i64 => mywrite!(w, \"MD\")\n+                TyI => mywrite!(w, \"i\"),\n+                TyI8 => mywrite!(w, \"MB\"),\n+                TyI16 => mywrite!(w, \"MW\"),\n+                TyI32 => mywrite!(w, \"ML\"),\n+                TyI64 => mywrite!(w, \"MD\")\n             }\n         }\n         ty::ty_uint(t) => {\n             match t {\n-                ty_u => mywrite!(w, \"u\"),\n-                ty_u8 => mywrite!(w, \"Mb\"),\n-                ty_u16 => mywrite!(w, \"Mw\"),\n-                ty_u32 => mywrite!(w, \"Ml\"),\n-                ty_u64 => mywrite!(w, \"Md\")\n+                TyU => mywrite!(w, \"u\"),\n+                TyU8 => mywrite!(w, \"Mb\"),\n+                TyU16 => mywrite!(w, \"Mw\"),\n+                TyU32 => mywrite!(w, \"Ml\"),\n+                TyU64 => mywrite!(w, \"Md\")\n             }\n         }\n         ty::ty_float(t) => {\n             match t {\n-                ty_f32 => mywrite!(w, \"Mf\"),\n-                ty_f64 => mywrite!(w, \"MF\"),\n+                TyF32 => mywrite!(w, \"Mf\"),\n+                TyF64 => mywrite!(w, \"MF\"),\n             }\n         }\n         ty::ty_enum(def, ref substs) => {\n@@ -349,11 +349,11 @@ fn enc_sigil(w: &mut MemWriter, sigil: Sigil) {\n     }\n }\n \n-fn enc_purity(w: &mut MemWriter, p: purity) {\n+fn enc_purity(w: &mut MemWriter, p: Purity) {\n     match p {\n-        impure_fn => mywrite!(w, \"i\"),\n-        unsafe_fn => mywrite!(w, \"u\"),\n-        extern_fn => mywrite!(w, \"c\")\n+        ImpureFn => mywrite!(w, \"i\"),\n+        UnsafeFn => mywrite!(w, \"u\"),\n+        ExternFn => mywrite!(w, \"c\")\n     }\n }\n "}, {"sha": "9541afe719b06a41a77a6eac670fae8d5b03d449", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -27,7 +27,7 @@ use util::ppaux::ty_to_str;\n use syntax::{ast, ast_map, ast_util, codemap, fold};\n use syntax::codemap::Span;\n use syntax::diagnostic::SpanHandler;\n-use syntax::fold::ast_fold;\n+use syntax::fold::Folder;\n use syntax::parse::token;\n use syntax;\n \n@@ -62,8 +62,8 @@ struct DecodeContext {\n \n struct ExtendedDecodeContext {\n     dcx: @DecodeContext,\n-    from_id_range: ast_util::id_range,\n-    to_id_range: ast_util::id_range\n+    from_id_range: ast_util::IdRange,\n+    to_id_range: ast_util::IdRange\n }\n \n trait tr {\n@@ -79,13 +79,13 @@ trait tr_intern {\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n-                           path: &[ast_map::path_elt],\n+                           path: &[ast_map::PathElem],\n                            ii: e::InlinedItemRef,\n                            maps: Maps) {\n     let ident = match ii {\n-        e::ii_item_ref(i) => i.ident,\n-        e::ii_foreign_ref(i) => i.ident,\n-        e::ii_method_ref(_, _, m) => m.ident,\n+        e::IIItemRef(i) => i.ident,\n+        e::IIForeignRef(i) => i.ident,\n+        e::IIMethodRef(_, _, m) => m.ident,\n     };\n     debug!(\"> Encoding inlined item: {}::{} ({})\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n@@ -110,9 +110,9 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                            tcx: ty::ctxt,\n                            maps: Maps,\n-                           path: &[ast_map::path_elt],\n+                           path: &[ast_map::PathElem],\n                            par_doc: ebml::Doc)\n-                        -> Option<ast::inlined_item> {\n+                        -> Option<ast::InlinedItem> {\n     let dcx = @DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n@@ -138,17 +138,17 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n                                       path.to_owned(),\n                                       raw_ii);\n         let ident = match ii {\n-            ast::ii_item(i) => i.ident,\n-            ast::ii_foreign(i) => i.ident,\n-            ast::ii_method(_, _, m) => m.ident,\n+            ast::IIItem(i) => i.ident,\n+            ast::IIForeign(i) => i.ident,\n+            ast::IIMethod(_, _, m) => m.ident,\n         };\n         debug!(\"Fn named: {}\", tcx.sess.str_of(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n                tcx.sess.str_of(ident));\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n-          ast::ii_item(i) => {\n+          ast::IIItem(i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_str(i, tcx.sess.intr()));\n           }\n@@ -163,13 +163,13 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n // Enumerating the IDs which appear in an AST\n \n fn reserve_id_range(sess: Session,\n-                    from_id_range: ast_util::id_range) -> ast_util::id_range {\n+                    from_id_range: ast_util::IdRange) -> ast_util::IdRange {\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n     let to_id_min = sess.reserve_node_ids(cnt);\n     let to_id_max = to_id_min + cnt;\n-    ast_util::id_range { min: to_id_min, max: to_id_max }\n+    ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n impl ExtendedDecodeContext {\n@@ -296,15 +296,15 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     item.encode(ebml_w);\n     ebml_w.end_tag();\n }\n \n struct NestedItemsDropper;\n \n-impl ast_fold for NestedItemsDropper {\n+impl Folder for NestedItemsDropper {\n     fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n         let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n             match stmt.node {\n@@ -343,19 +343,19 @@ impl ast_fold for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: e::InlinedItemRef) -> ast::inlined_item {\n+fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n     let mut fld = NestedItemsDropper;\n \n     match ii {\n         // HACK we're not dropping items.\n-        e::ii_item_ref(i) => ast::ii_item(fold::noop_fold_item(i, &mut fld)\n-                                          .expect_one(\"expected one item\")),\n-        e::ii_method_ref(d, p, m) => ast::ii_method(d, p, fold::noop_fold_method(m, &mut fld)),\n-        e::ii_foreign_ref(i) => ast::ii_foreign(fold::noop_fold_foreign_item(i, &mut fld))\n+        e::IIItemRef(i) => ast::IIItem(fold::noop_fold_item(i, &mut fld)\n+                                       .expect_one(\"expected one item\")),\n+        e::IIMethodRef(d, p, m) => ast::IIMethod(d, p, fold::noop_fold_method(m, &mut fld)),\n+        e::IIForeignRef(i) => ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n     }\n }\n \n-fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n+fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n     Decodable::decode(&mut d)\n@@ -376,18 +376,18 @@ impl ast_map::FoldOps for AstRenumberer {\n \n fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n                         diag: @SpanHandler,\n-                        map: ast_map::map,\n-                        path: ast_map::path,\n-                        ii: ast::inlined_item) -> ast::inlined_item {\n+                        map: ast_map::Map,\n+                        path: ast_map::Path,\n+                        ii: ast::InlinedItem) -> ast::InlinedItem {\n     ast_map::map_decoded_item(diag, map, path, AstRenumberer { xcx: xcx }, |fld| {\n         match ii {\n-            ast::ii_item(i) => {\n-                ast::ii_item(fld.fold_item(i).expect_one(\"expected one item\"))\n+            ast::IIItem(i) => {\n+                ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n             }\n-            ast::ii_method(d, is_provided, m) => {\n-                ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m))\n+            ast::IIMethod(d, is_provided, m) => {\n+                ast::IIMethod(xcx.tr_def_id(d), is_provided, fld.fold_method(m))\n             }\n-            ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n+            ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n         }\n     })\n }\n@@ -595,7 +595,7 @@ impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n                 explicit_self: this.read_struct_field(\"explicit_self\",\n                                                       2,\n                                                       |this| {\n-                    let explicit_self: ast::explicit_self_ = Decodable::decode(this);\n+                    let explicit_self: ast::ExplicitSelf_ = Decodable::decode(this);\n                     explicit_self\n                 }),\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n@@ -921,7 +921,7 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              maps: Maps,\n                              ebml_w: &mut writer::Encoder,\n-                             ii: &ast::inlined_item) {\n+                             ii: &ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_table as uint);\n     let mut new_ebml_w = unsafe {\n         ebml_w.unsafe_clone()\n@@ -1418,14 +1418,14 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::item) {\n+fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::Item) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(ebml_w);\n     ebml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n+fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n     @Decodable::decode(&mut d)\n@@ -1464,7 +1464,7 @@ fn mk_ctxt() -> @fake_ext_ctxt {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<@ast::item>) {\n+fn roundtrip(in_item: Option<@ast::Item>) {\n     use std::io::mem::MemWriter;\n \n     let in_item = in_item.unwrap();\n@@ -1515,15 +1515,15 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).unwrap();\n-    let item_in = e::ii_item_ref(item);\n+    let item_in = e::IIItemRef(item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::ii_item(quote_item!(cx,\n+    let item_exp = ast::IIItem(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).unwrap());\n     match (item_out, item_exp) {\n-      (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n+      (ast::IIItem(item_out), ast::IIItem(item_exp)) => {\n         assert!(pprust::item_to_str(item_out,\n                                     token::get_ident_interner())\n                      == pprust::item_to_str(item_exp,"}, {"sha": "ea7979b855e3a6e1553895f84af83ddfa380c0a9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -51,7 +51,7 @@ impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n         check_loans_in_pat(self, p);\n     }\n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n         check_loans_in_fn(self, fk, fd, b, s, n);\n     }\n@@ -682,19 +682,18 @@ impl<'a> CheckLoanCtxt<'a> {\n }\n \n fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n-                         fk: &visit::fn_kind,\n-                         decl: &ast::fn_decl,\n+                         fk: &visit::FnKind,\n+                         decl: &ast::FnDecl,\n                          body: &ast::Block,\n                          sp: Span,\n                          id: ast::NodeId) {\n     match *fk {\n-        visit::fk_item_fn(..) |\n-        visit::fk_method(..) => {\n+        visit::FkItemFn(..) | visit::FkMethod(..) => {\n             // Don't process nested items.\n             return;\n         }\n \n-        visit::fk_fn_block(..) => {\n+        visit::FkFnBlock(..) => {\n             check_captured_variables(this, id, sp);\n         }\n     }"}, {"sha": "e35bafd6ebfa4e7079b00aad7be46de65b6946f1", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,12 +28,12 @@ use util::ppaux::{Repr};\n \n use std::cell::RefCell;\n use syntax::ast;\n-use syntax::ast_util::id_range;\n+use syntax::ast_util::IdRange;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n use syntax::visit;\n-use syntax::visit::{Visitor, fn_kind};\n-use syntax::ast::{Expr, fn_decl, Block, NodeId, Stmt, Pat, Local};\n+use syntax::visit::{Visitor, FnKind};\n+use syntax::ast::{Expr, FnDecl, Block, NodeId, Stmt, Pat, Local};\n \n mod lifetime;\n mod restrictions;\n@@ -67,7 +67,7 @@ mod gather_moves;\n /// because it would have to be rooted for a region greater than `root_ub`.\n struct GatherLoanCtxt<'a> {\n     bccx: &'a BorrowckCtxt,\n-    id_range: id_range,\n+    id_range: IdRange,\n     move_data: move_data::MoveData,\n     all_loans: @RefCell<~[Loan]>,\n     item_ub: ast::NodeId,\n@@ -81,7 +81,7 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     fn visit_block(&mut self, b: &Block, _: ()) {\n         gather_loans_in_block(self, b);\n     }\n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block,\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block,\n                 s: Span, n: NodeId, _: ()) {\n         gather_loans_in_fn(self, fk, fd, b, s, n);\n     }\n@@ -98,16 +98,14 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     // #7740: Do not visit items here, not even fn items nor methods\n     // of impl items; the outer loop in borrowck/mod will visit them\n     // for us in turn.  Thus override visit_item's walk with a no-op.\n-    fn visit_item(&mut self, _: &ast::item, _: ()) { }\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) { }\n }\n \n-pub fn gather_loans(bccx: &BorrowckCtxt,\n-                    decl: &ast::fn_decl,\n-                    body: &ast::Block)\n-                    -> (id_range, @RefCell<~[Loan]>, move_data::MoveData) {\n+pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n+                    -> (IdRange, @RefCell<~[Loan]>, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n-        id_range: id_range::max(),\n+        id_range: IdRange::max(),\n         all_loans: @RefCell::new(~[]),\n         item_ub: body.id,\n         repeating_ids: ~[body.id],\n@@ -129,19 +127,16 @@ fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n     visit::walk_pat(this, p, ());\n }\n \n-fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n-                      fk: &fn_kind,\n-                      decl: &ast::fn_decl,\n-                      body: &ast::Block,\n-                      sp: Span,\n-                      id: ast::NodeId) {\n+fn gather_loans_in_fn(this: &mut GatherLoanCtxt, fk: &FnKind,\n+                      decl: &ast::FnDecl, body: &ast::Block,\n+                      sp: Span, id: ast::NodeId) {\n     match fk {\n-        &visit::fk_item_fn(..) | &visit::fk_method(..) => {\n+        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n             fail!(\"cannot occur, due to visit_item override\");\n         }\n \n         // Visit closures as part of the containing item.\n-        &visit::fk_fn_block(..) => {\n+        &visit::FkFnBlock(..) => {\n             this.push_repeating_id(body.id);\n             visit::walk_fn(this, fk, decl, body, sp, id, ());\n             this.pop_repeating_id(body.id);\n@@ -677,7 +672,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     fn gather_fn_arg_patterns(&mut self,\n-                              decl: &ast::fn_decl,\n+                              decl: &ast::FnDecl,\n                               body: &ast::Block) {\n         /*!\n          * Walks the patterns for fn arguments, checking that they"}, {"sha": "5160233ecbf136583bd82cafbf9390575953ee45", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,8 +28,8 @@ use syntax::ast_map;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n-use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{fn_decl,Block,NodeId};\n+use syntax::visit::{Visitor, FnKind};\n+use syntax::ast::{FnDecl, Block, NodeId};\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -61,7 +61,7 @@ impl Clone for LoanDataFlowOperator {\n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n impl Visitor<()> for BorrowckCtxt {\n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl,\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n@@ -114,18 +114,17 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n fn borrowck_fn(this: &mut BorrowckCtxt,\n-               fk: &visit::fn_kind,\n-               decl: &ast::fn_decl,\n+               fk: &FnKind,\n+               decl: &ast::FnDecl,\n                body: &ast::Block,\n                sp: Span,\n                id: ast::NodeId) {\n     match fk {\n-        &visit::fk_fn_block(..) => {\n+        &visit::FkFnBlock(..) => {\n             // Closures are checked as part of their containing fn item.\n         }\n \n-        &visit::fk_item_fn(..) |\n-        &visit::fk_method(..) => {\n+        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n             debug!(\"borrowck_fn(id={:?})\", id);\n \n             // Check the body of fn items.\n@@ -553,7 +552,7 @@ impl BorrowckCtxt {\n             move_data::MoveExpr => {\n                 let items = self.tcx.items.borrow();\n                 let (expr_ty, expr_span) = match items.get().find(&move.id) {\n-                    Some(&ast_map::node_expr(expr)) => {\n+                    Some(&ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"MoveExpr({:?}) maps to {:?}, not Expr\",\n@@ -581,7 +580,7 @@ impl BorrowckCtxt {\n             move_data::Captured => {\n                 let items = self.tcx.items.borrow();\n                 let (expr_ty, expr_span) = match items.get().find(&move.id) {\n-                    Some(&ast_map::node_expr(expr)) => {\n+                    Some(&ast_map::NodeExpr(expr)) => {\n                         (ty::expr_ty_adjusted(self.tcx, expr), expr.span)\n                     }\n                     r => self.tcx.sess.bug(format!(\"Captured({:?}) maps to {:?}, not Expr\",\n@@ -771,7 +770,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 let items = self.tcx.items.borrow();\n                 match items.get().find(&id) {\n-                    Some(&ast_map::node_local(ref ident, _)) => {\n+                    Some(&ast_map::NodeLocal(ref ident, _)) => {\n                         out.push_str(token::ident_to_str(ident));\n                     }\n                     r => {"}, {"sha": "e61ebd39ca766c666ad80283564ea311fdab1925", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -566,7 +566,7 @@ impl FlowedMoveData {\n     pub fn new(move_data: MoveData,\n                tcx: ty::ctxt,\n                method_map: typeck::method_map,\n-               id_range: ast_util::id_range,\n+               id_range: ast_util::IdRange,\n                body: &ast::Block)\n                -> FlowedMoveData {\n         let mut dfcx_moves = {"}, {"sha": "b440be8b0bee19749ac74a36707d3db0968456e5", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -23,14 +23,14 @@ use syntax::visit;\n \n struct CheckCrateVisitor {\n     sess: Session,\n-    ast_map: ast_map::map,\n+    ast_map: ast_map::Map,\n     def_map: resolve::DefMap,\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n }\n \n impl Visitor<bool> for CheckCrateVisitor {\n-    fn visit_item(&mut self, i: &item, env: bool) {\n+    fn visit_item(&mut self, i: &Item, env: bool) {\n         check_item(self, self.sess, self.ast_map, self.def_map, i, env);\n     }\n     fn visit_pat(&mut self, p: &Pat, env: bool) {\n@@ -44,7 +44,7 @@ impl Visitor<bool> for CheckCrateVisitor {\n \n pub fn check_crate(sess: Session,\n                    crate: &Crate,\n-                   ast_map: ast_map::map,\n+                   ast_map: ast_map::Map,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::method_map,\n                    tcx: ty::ctxt) {\n@@ -61,23 +61,23 @@ pub fn check_crate(sess: Session,\n \n pub fn check_item(v: &mut CheckCrateVisitor,\n                   sess: Session,\n-                  ast_map: ast_map::map,\n+                  ast_map: ast_map::Map,\n                   def_map: resolve::DefMap,\n-                  it: &item,\n+                  it: &Item,\n                   _is_const: bool) {\n     match it.node {\n-      item_static(_, _, ex) => {\n-        v.visit_expr(ex, true);\n-        check_item_recursion(sess, ast_map, def_map, it);\n-      }\n-      item_enum(ref enum_definition, _) => {\n-        for var in (*enum_definition).variants.iter() {\n-            for ex in var.node.disr_expr.iter() {\n-                v.visit_expr(*ex, true);\n+        ItemStatic(_, _, ex) => {\n+            v.visit_expr(ex, true);\n+            check_item_recursion(sess, ast_map, def_map, it);\n+        }\n+        ItemEnum(ref enum_definition, _) => {\n+            for var in (*enum_definition).variants.iter() {\n+                for ex in var.node.disr_expr.iter() {\n+                    v.visit_expr(*ex, true);\n+                }\n             }\n         }\n-      }\n-      _ => visit::walk_item(v, it, false)\n+        _ => visit::walk_item(v, it, false)\n     }\n }\n \n@@ -86,7 +86,7 @@ pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n         match e.node {\n             ExprVstore(\n                 @Expr { node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(..),\n+                    node: LitStr(..),\n                     ..}),\n                        .. },\n                 ExprVstoreUniq\n@@ -120,7 +120,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                           \"cannot do allocations in constant expressions\");\n             return;\n           }\n-          ExprLit(@codemap::Spanned {node: lit_str(..), ..}) => { }\n+          ExprLit(@codemap::Spanned {node: LitStr(..), ..}) => { }\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_map = method_map.borrow();\n             if method_map.get().contains_key(&e.id) {\n@@ -211,19 +211,19 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n }\n \n struct CheckItemRecursionVisitor<'a> {\n-    root_it: &'a item,\n+    root_it: &'a Item,\n     sess: Session,\n-    ast_map: ast_map::map,\n+    ast_map: ast_map::Map,\n     def_map: resolve::DefMap,\n     idstack: ~[NodeId]\n }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n pub fn check_item_recursion(sess: Session,\n-                            ast_map: ast_map::map,\n+                            ast_map: ast_map::Map,\n                             def_map: resolve::DefMap,\n-                            it: &item) {\n+                            it: &Item) {\n \n     let mut visitor = CheckItemRecursionVisitor {\n         root_it: it,\n@@ -236,7 +236,7 @@ pub fn check_item_recursion(sess: Session,\n }\n \n impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n-    fn visit_item(&mut self, it: &item, _: ()) {\n+    fn visit_item(&mut self, it: &Item, _: ()) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_fatal(self.root_it.span, \"recursive constant\");\n         }\n@@ -254,7 +254,7 @@ impl<'a> Visitor<()> for CheckItemRecursionVisitor<'a> {\n                             ast_util::is_local(def_id) => {\n                         let ast_map = self.ast_map.borrow();\n                         match ast_map.get().get_copy(&def_id.node) {\n-                            ast_map::node_item(it, _) => {\n+                            ast_map::NodeItem(it, _) => {\n                                 self.visit_item(it, ());\n                             }\n                             _ => fail!(\"const not bound to an item\")"}, {"sha": "c1be9ea69eaa361193a56f2e73d2cf2892d9cda8", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -29,7 +29,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n }\n \n impl Visitor<Context> for CheckLoopVisitor {\n-    fn visit_item(&mut self, i: &ast::item, _cx: Context) {\n+    fn visit_item(&mut self, i: &ast::Item, _cx: Context) {\n         visit::walk_item(self, i, Normal);\n     }\n "}, {"sha": "47a90311c3166c3200b6dad4ff7e0b45a883fd40", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -25,7 +25,7 @@ use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{Span, DUMMY_SP, Spanned};\n use syntax::visit;\n-use syntax::visit::{Visitor,fn_kind};\n+use syntax::visit::{Visitor, FnKind};\n \n struct MatchCheckCtxt {\n     tcx: ty::ctxt,\n@@ -44,7 +44,7 @@ impl Visitor<()> for CheckMatchVisitor {\n     fn visit_local(&mut self, l: &Local, _: ()) {\n         check_local(self, self.cx, l, ());\n     }\n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, _: ()) {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, self.cx, fk, fd, b, s, n, ());\n     }\n }\n@@ -843,8 +843,8 @@ fn check_local(v: &mut CheckMatchVisitor,\n \n fn check_fn(v: &mut CheckMatchVisitor,\n                 cx: &MatchCheckCtxt,\n-                kind: &visit::fn_kind,\n-                decl: &fn_decl,\n+                kind: &FnKind,\n+                decl: &FnDecl,\n                 body: &Block,\n                 sp: Span,\n                 id: NodeId,\n@@ -879,7 +879,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n         is_refutable(cx, sub)\n       }\n       PatWild | PatWildMulti | PatIdent(_, _, None) => { false }\n-      PatLit(@Expr {node: ExprLit(@Spanned { node: lit_nil, ..}), ..}) => {\n+      PatLit(@Expr {node: ExprLit(@Spanned { node: LitNil, ..}), ..}) => {\n         // \"()\"\n         false\n       }"}, {"sha": "340c8d67ce33358fea9e4ca924d2f1f529907b16", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -97,7 +97,7 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n                        -> Option<@Expr> {\n-    fn variant_expr(variants: &[ast::P<ast::variant>], id: ast::NodeId) -> Option<@Expr> {\n+    fn variant_expr(variants: &[ast::P<ast::Variant>], id: ast::NodeId) -> Option<@Expr> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n                 return variant.node.disr_expr;\n@@ -111,8 +111,8 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             let items = tcx.items.borrow();\n             match items.get().find(&enum_def.node) {\n                 None => None,\n-                Some(&ast_map::node_item(it, _)) => match it.node {\n-                    item_enum(ast::enum_def { variants: ref variants }, _) => {\n+                Some(&ast_map::NodeItem(it, _)) => match it.node {\n+                    ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                         variant_expr(*variants, variant_def.node)\n                     }\n                     _ => None\n@@ -140,8 +140,8 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n                                                         maps,\n                                                         /*bad*/ c.clone(),\n                                                         d)) {\n-            csearch::found(ast::ii_item(item)) => match item.node {\n-                item_enum(ast::enum_def { variants: ref variants }, _) => {\n+            csearch::found(ast::IIItem(item)) => match item.node {\n+                ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                     variant_expr(*variants, variant_def.node)\n                 }\n                 _ => None\n@@ -164,8 +164,8 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n             let items = tcx.items.borrow();\n             match items.get().find(&def_id.node) {\n                 None => None,\n-                Some(&ast_map::node_item(it, _)) => match it.node {\n-                    item_static(_, ast::MutImmutable, const_expr) => {\n+                Some(&ast_map::NodeItem(it, _)) => match it.node {\n+                    ItemStatic(_, ast::MutImmutable, const_expr) => {\n                         Some(const_expr)\n                     }\n                     _ => None\n@@ -189,8 +189,8 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n-            csearch::found(ast::ii_item(item)) => match item.node {\n-                item_static(_, ast::MutImmutable, const_expr) => Some(const_expr),\n+            csearch::found(ast::IIItem(item)) => match item.node {\n+                ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None\n             },\n             _ => None\n@@ -219,7 +219,7 @@ impl ConstEvalVisitor {\n         let cn = match e.node {\n             ast::ExprLit(lit) => {\n                 match lit.node {\n-                    ast::lit_str(..) | ast::lit_float(..) => general_const,\n+                    ast::LitStr(..) | ast::LitFloat(..) => general_const,\n                     _ => integral_const\n                 }\n             }\n@@ -497,19 +497,19 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n     }\n }\n \n-pub fn lit_to_const(lit: &lit) -> const_val {\n+pub fn lit_to_const(lit: &Lit) -> const_val {\n     match lit.node {\n-      lit_str(s, _) => const_str(s),\n-      lit_binary(data) => const_binary(data),\n-      lit_char(n) => const_uint(n as u64),\n-      lit_int(n, _) => const_int(n),\n-      lit_uint(n, _) => const_uint(n),\n-      lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(from_str::<f64>(n).unwrap() as f64),\n-      lit_float_unsuffixed(n) =>\n-        const_float(from_str::<f64>(n).unwrap() as f64),\n-      lit_nil => const_int(0i64),\n-      lit_bool(b) => const_bool(b)\n+        LitStr(s, _) => const_str(s),\n+        LitBinary(data) => const_binary(data),\n+        LitChar(n) => const_uint(n as u64),\n+        LitInt(n, _) => const_int(n),\n+        LitUint(n, _) => const_uint(n),\n+        LitIntUnsuffixed(n) => const_int(n),\n+        LitFloat(n, _) => const_float(from_str::<f64>(n).unwrap() as f64),\n+        LitFloatUnsuffixed(n) =>\n+            const_float(from_str::<f64>(n).unwrap() as f64),\n+        LitNil => const_int(0i64),\n+        LitBool(b) => const_bool(b)\n     }\n }\n \n@@ -535,6 +535,6 @@ pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n     compare_lit_exprs(tcx, a, b).map(|val| val == 0)\n }\n \n-pub fn lit_eq(a: &lit, b: &lit) -> Option<bool> {\n+pub fn lit_eq(a: &Lit, b: &Lit) -> Option<bool> {\n     compare_const_vals(&lit_to_const(a), &lit_to_const(b)).map(|val| val == 0)\n }"}, {"sha": "c50190f0b6849dfd00797b0991b21c42fc11e7a5", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -24,7 +24,7 @@ use std::vec;\n use std::hashmap::HashMap;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::ast_util::id_range;\n+use syntax::ast_util::IdRange;\n use syntax::print::{pp, pprust};\n use middle::ty;\n use middle::typeck;\n@@ -87,13 +87,13 @@ struct LoopScope<'a> {\n     break_bits: ~[uint]\n }\n \n-impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n-    fn pre(&self, node: pprust::ann_node) {\n+impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n+    fn pre(&self, node: pprust::AnnNode) {\n         let (ps, id) = match node {\n-            pprust::node_expr(ps, expr) => (ps, expr.id),\n-            pprust::node_block(ps, blk) => (ps, blk.id),\n-            pprust::node_item(ps, _) => (ps, 0),\n-            pprust::node_pat(ps, pat) => (ps, pat.id)\n+            pprust::NodeExpr(ps, expr) => (ps, expr.id),\n+            pprust::NodeBlock(ps, blk) => (ps, blk.id),\n+            pprust::NodeItem(ps, _) => (ps, 0),\n+            pprust::NodePat(ps, pat) => (ps, pat.id)\n         };\n \n         if self.nodeid_to_bitset.contains_key(&id) {\n@@ -127,7 +127,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn new(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                oper: O,\n-               id_range: id_range,\n+               id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<O> {\n         let words_per_id = (bits_per_id + uint::bits - 1) / uint::bits;\n \n@@ -353,9 +353,8 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n \n     fn pretty_print_to(@self, wr: ~io::Writer, blk: &ast::Block) {\n-        let mut ps = pprust::rust_printer_annotated(wr,\n-                                                    self.tcx.sess.intr(),\n-                                                    self as @pprust::pp_ann);\n+        let mut ps = pprust::rust_printer_annotated(wr, self.tcx.sess.intr(),\n+                                                    self as @pprust::PpAnn);\n         pprust::cbox(&mut ps, pprust::indent_unit);\n         pprust::ibox(&mut ps, 0u);\n         pprust::print_block(&mut ps, blk);"}, {"sha": "e7136358aad804800dc900aa88c9b9236ee33182", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -27,7 +27,7 @@ use syntax::visit::Visitor;\n use syntax::visit;\n \n // Any local node that may call something in its body block should be\n-// explored. For example, if it's a live node_item that is a\n+// explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n@@ -37,10 +37,10 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n \n     let items = tcx.items.borrow();\n     match items.get().find(&def_id.node) {\n-        Some(&ast_map::node_item(..))\n-        | Some(&ast_map::node_method(..))\n-        | Some(&ast_map::node_foreign_item(..))\n-        | Some(&ast_map::node_trait_method(..)) => true,\n+        Some(&ast_map::NodeItem(..))\n+        | Some(&ast_map::NodeMethod(..))\n+        | Some(&ast_map::NodeForeignItem(..))\n+        | Some(&ast_map::NodeTraitMethod(..)) => true,\n         _ => false\n     }\n }\n@@ -144,27 +144,27 @@ impl MarkSymbolVisitor {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &ast_map::ast_node) {\n+    fn visit_node(&mut self, node: &ast_map::Node) {\n         match *node {\n-            ast_map::node_item(item, _) => {\n+            ast_map::NodeItem(item, _) => {\n                 match item.node {\n-                    ast::item_fn(..)\n-                    | ast::item_ty(..)\n-                    | ast::item_enum(..)\n-                    | ast::item_struct(..)\n-                    | ast::item_static(..) => {\n+                    ast::ItemFn(..)\n+                    | ast::ItemTy(..)\n+                    | ast::ItemEnum(..)\n+                    | ast::ItemStruct(..)\n+                    | ast::ItemStatic(..) => {\n                         visit::walk_item(self, item, ());\n                     }\n                     _ => ()\n                 }\n             }\n-            ast_map::node_trait_method(trait_method, _, _) => {\n+            ast_map::NodeTraitMethod(trait_method, _, _) => {\n                 visit::walk_trait_method(self, trait_method, ());\n             }\n-            ast_map::node_method(method, _, _) => {\n+            ast_map::NodeMethod(method, _, _) => {\n                 visit::walk_block(self, method.body, ());\n             }\n-            ast_map::node_foreign_item(foreign_item, _, _, _) => {\n+            ast_map::NodeForeignItem(foreign_item, _, _, _) => {\n                 visit::walk_foreign_item(self, foreign_item, ());\n             }\n             _ => ()\n@@ -190,7 +190,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n         visit::walk_path(self, path, ());\n     }\n \n-    fn visit_item(&mut self, _item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, _item: &ast::Item, _: ()) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }\n@@ -204,14 +204,14 @@ struct TraitMethodSeeder {\n }\n \n impl Visitor<()> for TraitMethodSeeder {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match item.node {\n-            ast::item_impl(_, Some(ref _trait_ref), _, ref methods) => {\n+            ast::ItemImpl(_, Some(ref _trait_ref), _, ref methods) => {\n                 for method in methods.iter() {\n                     self.worklist.push(method.id);\n                 }\n             }\n-            ast::item_mod(..) | ast::item_fn(..) => {\n+            ast::ItemMod(..) | ast::ItemFn(..) => {\n                 visit::walk_item(self, item, ());\n             }\n             _ => ()\n@@ -265,19 +265,19 @@ fn find_live(tcx: ty::ctxt,\n     symbol_visitor.live_symbols\n }\n \n-fn should_warn(item: &ast::item) -> bool {\n+fn should_warn(item: &ast::Item) -> bool {\n     match item.node {\n-        ast::item_static(..)\n-        | ast::item_fn(..)\n-        | ast::item_enum(..)\n-        | ast::item_struct(..) => true,\n+        ast::ItemStatic(..)\n+        | ast::ItemFn(..)\n+        | ast::ItemEnum(..)\n+        | ast::ItemStruct(..) => true,\n         _ => false\n     }\n }\n \n-fn get_struct_ctor_id(item: &ast::item) -> Option<ast::NodeId> {\n+fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        ast::item_struct(struct_def, _) => struct_def.ctor_id,\n+        ast::ItemStruct(struct_def, _) => struct_def.ctor_id,\n         _ => None\n     }\n }\n@@ -335,27 +335,27 @@ impl DeadVisitor {\n }\n \n impl Visitor<()> for DeadVisitor {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n             self.warn_dead_code(item.id, item.span, &item.ident);\n         }\n         visit::walk_item(self, item, ());\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem, _: ()) {\n         if !self.symbol_is_live(fi.id, None) {\n             self.warn_dead_code(fi.id, fi.span, &fi.ident);\n         }\n         visit::walk_foreign_item(self, fi, ());\n     }\n \n-    fn visit_fn(&mut self, fk: &visit::fn_kind,\n-                _: &ast::fn_decl, block: &ast::Block,\n+    fn visit_fn(&mut self, fk: &visit::FnKind,\n+                _: &ast::FnDecl, block: &ast::Block,\n                 span: codemap::Span, id: ast::NodeId, _: ()) {\n-        // Have to warn method here because methods are not ast::item\n+        // Have to warn method here because methods are not ast::Item\n         match *fk {\n-            visit::fk_method(..) => {\n+            visit::FkMethod(..) => {\n                 let ident = visit::name_of_fn(fk);\n                 if !self.symbol_is_live(id, None) {\n                     self.warn_dead_code(id, span, &ident);\n@@ -367,10 +367,10 @@ impl Visitor<()> for DeadVisitor {\n     }\n \n     // Overwrite so that we don't warn the trait method itself.\n-    fn visit_trait_method(&mut self, trait_method: &ast::trait_method, _: ()) {\n+    fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {\n-            ast::provided(method) => visit::walk_block(self, method.body, ()),\n-            ast::required(_) => ()\n+            ast::Provided(method) => visit::walk_block(self, method.body, ()),\n+            ast::Required(_) => ()\n         }\n     }\n }"}, {"sha": "f46e570bb9d02658777c13deb98cc660402f44d8", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -29,8 +29,8 @@ enum UnsafeContext {\n \n fn type_is_unsafe_function(ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n-        ty::ty_bare_fn(ref f) => f.purity == ast::unsafe_fn,\n-        ty::ty_closure(ref f) => f.purity == ast::unsafe_fn,\n+        ty::ty_bare_fn(ref f) => f.purity == ast::UnsafeFn,\n+        ty::ty_closure(ref f) => f.purity == ast::UnsafeFn,\n         _ => false,\n     }\n }\n@@ -81,14 +81,14 @@ impl EffectCheckVisitor {\n }\n \n impl Visitor<()> for EffectCheckVisitor {\n-    fn visit_fn(&mut self, fn_kind: &visit::fn_kind, fn_decl: &ast::fn_decl,\n+    fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n                 block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n \n         let (is_item_fn, is_unsafe_fn) = match *fn_kind {\n-            visit::fk_item_fn(_, _, purity, _) =>\n-                (true, purity == ast::unsafe_fn),\n-            visit::fk_method(_, _, method) =>\n-                (true, method.purity == ast::unsafe_fn),\n+            visit::FkItemFn(_, _, purity, _) =>\n+                (true, purity == ast::UnsafeFn),\n+            visit::FkMethod(_, _, method) =>\n+                (true, method.purity == ast::UnsafeFn),\n             _ => (false, false),\n         };\n "}, {"sha": "d6e4ad641822a5428189a1bbdd63047948334174", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -11,7 +11,7 @@\n \n use driver::session;\n use driver::session::Session;\n-use syntax::ast::{Crate, NodeId, item, item_fn};\n+use syntax::ast::{Crate, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -22,7 +22,7 @@ use syntax::visit::Visitor;\n struct EntryContext {\n     session: Session,\n \n-    ast_map: ast_map::map,\n+    ast_map: ast_map::Map,\n \n     // The top-level function called 'main'\n     main_fn: Option<(NodeId, Span)>,\n@@ -39,12 +39,12 @@ struct EntryContext {\n }\n \n impl Visitor<()> for EntryContext {\n-    fn visit_item(&mut self, item: &item, _:()) {\n+    fn visit_item(&mut self, item: &Item, _:()) {\n         find_item(item, self);\n     }\n }\n \n-pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map) {\n+pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::Map) {\n     if session.building_library.get() {\n         // No need to find a main function\n         return;\n@@ -70,14 +70,14 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n     configure_main(&mut ctxt);\n }\n \n-fn find_item(item: &item, ctxt: &mut EntryContext) {\n+fn find_item(item: &Item, ctxt: &mut EntryContext) {\n     match item.node {\n-        item_fn(..) => {\n+        ItemFn(..) => {\n             if item.ident.name == special_idents::main.name {\n                 {\n                     let ast_map = ctxt.ast_map.borrow();\n                     match ast_map.get().find(&item.id) {\n-                        Some(&ast_map::node_item(_, path)) => {\n+                        Some(&ast_map::NodeItem(_, path)) => {\n                             if path.len() == 0 {\n                                 // This is a top-level function so can be 'main'\n                                 if ctxt.main_fn.is_none() {"}, {"sha": "4ee8eb4108d1643801a774d2c527cf94dc55a114", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -20,7 +20,6 @@ use syntax::codemap::Span;\n use syntax::{ast, ast_util};\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ast::{item};\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n@@ -40,7 +39,7 @@ struct CollectFreevarsVisitor {\n \n impl Visitor<int> for CollectFreevarsVisitor {\n \n-    fn visit_item(&mut self, _: &item, _: int) {\n+    fn visit_item(&mut self, _: &ast::Item, _: int) {\n         // ignore_item\n     }\n \n@@ -112,7 +111,7 @@ struct AnnotateFreevarsVisitor {\n }\n \n impl Visitor<()> for AnnotateFreevarsVisitor {\n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 blk: &ast::Block, s: Span, nid: ast::NodeId, _: ()) {\n         let vars = collect_freevars(self.def_map, blk);\n         self.freevars.insert(nid, vars);"}, {"sha": "c3d050ac559b393422da4d5bab820ad214050b19", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -62,15 +62,15 @@ impl Visitor<()> for Context {\n         check_expr(self, ex);\n     }\n \n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n \n     fn visit_ty(&mut self, t: &Ty, _: ()) {\n         check_ty(self, t);\n     }\n-    fn visit_item(&mut self, i: &item, _: ()) {\n+    fn visit_item(&mut self, i: &Item, _: ()) {\n         check_item(self, i);\n     }\n }\n@@ -116,7 +116,7 @@ fn check_struct_safe_for_destructor(cx: &mut Context,\n     }\n }\n \n-fn check_impl_of_trait(cx: &mut Context, it: &item, trait_ref: &trait_ref, self_type: &Ty) {\n+fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_type: &Ty) {\n     let def_map = cx.tcx.def_map.borrow();\n     let ast_trait_def = def_map.get()\n                                .find(&trait_ref.ref_id)\n@@ -145,7 +145,7 @@ fn check_impl_of_trait(cx: &mut Context, it: &item, trait_ref: &trait_ref, self_\n     // If this is a destructor, check kinds.\n     if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) {\n         match self_type.node {\n-            ty_path(_, ref bounds, path_node_id) => {\n+            TyPath(_, ref bounds, path_node_id) => {\n                 assert!(bounds.is_none());\n                 let struct_def = def_map.get().get_copy(&path_node_id);\n                 let struct_did = ast_util::def_id_of_def(struct_def);\n@@ -159,10 +159,10 @@ fn check_impl_of_trait(cx: &mut Context, it: &item, trait_ref: &trait_ref, self_\n     }\n }\n \n-fn check_item(cx: &mut Context, item: &item) {\n+fn check_item(cx: &mut Context, item: &Item) {\n     if !attr::contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(ref trait_ref), self_type, _) => {\n+            ItemImpl(_, Some(ref trait_ref), self_type, _) => {\n                 check_impl_of_trait(cx, item, trait_ref, self_type);\n             }\n             _ => {}\n@@ -246,8 +246,8 @@ fn with_appropriate_checker(cx: &Context,\n // to the copy/move kind bounds. Then recursively check the function body.\n fn check_fn(\n     cx: &mut Context,\n-    fk: &visit::fn_kind,\n-    decl: &fn_decl,\n+    fk: &visit::FnKind,\n+    decl: &FnDecl,\n     body: &Block,\n     sp: Span,\n     fn_id: NodeId) {\n@@ -353,20 +353,20 @@ fn check_trait_cast(cx: &mut Context, source_ty: ty::t, target_ty: ty::t, span:\n \n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n-      ty_path(_, _, id) => {\n-          let node_type_substs = cx.tcx.node_type_substs.borrow();\n-          let r = node_type_substs.get().find(&id);\n-          for ts in r.iter() {\n-              let def_map = cx.tcx.def_map.borrow();\n-              let did = ast_util::def_id_of_def(def_map.get().get_copy(&id));\n-              let type_param_defs =\n-                  ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n-              for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n-                  check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n-              }\n-          }\n-      }\n-      _ => {}\n+        TyPath(_, _, id) => {\n+            let node_type_substs = cx.tcx.node_type_substs.borrow();\n+            let r = node_type_substs.get().find(&id);\n+            for ts in r.iter() {\n+                let def_map = cx.tcx.def_map.borrow();\n+                let did = ast_util::def_id_of_def(def_map.get().get_copy(&id));\n+                let type_param_defs =\n+                    ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n+                for (&ty, type_param_def) in ts.iter().zip(type_param_defs.iter()) {\n+                    check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+                }\n+            }\n+        }\n+        _ => {}\n     }\n     visit::walk_ty(cx, aty, ());\n }"}, {"sha": "f95fec4c9df49acaea60a635d74cf00360d5fb4e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -109,7 +109,7 @@ struct LanguageItemVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match extract(item.attrs) {\n             Some(value) => {\n                 let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);"}, {"sha": "a954c59ff12760f9d0dd9747e93ec38f64656d16", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -380,7 +380,7 @@ struct Context<'a> {\n     method_map: typeck::method_map,\n     // Items exported by the crate; used by the missing_doc lint.\n     exported_items: &'a privacy::ExportedItems,\n-    // The id of the current `ast::struct_def` being walked.\n+    // The id of the current `ast::StructDef` being walked.\n     cur_struct_def_id: ast::NodeId,\n     // Whether some ancestor of the current node was marked\n     // #[doc(hidden)].\n@@ -569,7 +569,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n         ast::ExprWhile(cond, _) => {\n             match cond.node {\n                 ast::ExprLit(@codemap::Spanned {\n-                    node: ast::lit_bool(true), ..}) =>\n+                    node: ast::LitBool(true), ..}) =>\n                 {\n                     cx.span_lint(while_true, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n@@ -623,14 +623,14 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n         ast::ExprLit(lit) => {\n             match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                 ty::ty_int(t) => {\n-                    let int_type = if t == ast::ty_i {\n+                    let int_type = if t == ast::TyI {\n                         cx.tcx.sess.targ_cfg.int_type\n                     } else { t };\n                     let (min, max) = int_ty_range(int_type);\n                     let mut lit_val: i64 = match lit.node {\n-                        ast::lit_int(v, _) => v,\n-                        ast::lit_uint(v, _) => v as i64,\n-                        ast::lit_int_unsuffixed(v) => v,\n+                        ast::LitInt(v, _) => v,\n+                        ast::LitUint(v, _) => v as i64,\n+                        ast::LitIntUnsuffixed(v) => v,\n                         _ => fail!()\n                     };\n                     if cx.negated_expr_id == e.id {\n@@ -642,14 +642,14 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                     }\n                 },\n                 ty::ty_uint(t) => {\n-                    let uint_type = if t == ast::ty_u {\n+                    let uint_type = if t == ast::TyU {\n                         cx.tcx.sess.targ_cfg.uint_type\n                     } else { t };\n                     let (min, max) = uint_ty_range(uint_type);\n                     let lit_val: u64 = match lit.node {\n-                        ast::lit_int(v, _) => v as u64,\n-                        ast::lit_uint(v, _) => v,\n-                        ast::lit_int_unsuffixed(v) => v as u64,\n+                        ast::LitInt(v, _) => v as u64,\n+                        ast::LitUint(v, _) => v,\n+                        ast::LitIntUnsuffixed(v) => v as u64,\n                         _ => fail!()\n                     };\n                     if  lit_val < min || lit_val > max {\n@@ -688,23 +688,23 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n \n     // for int & uint, be conservative with the warnings, so that the\n     // warnings are consistent between 32- and 64-bit platforms\n-    fn int_ty_range(int_ty: ast::int_ty) -> (i64, i64) {\n+    fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n         match int_ty {\n-            ast::ty_i =>    (i64::min_value,        i64::max_value),\n-            ast::ty_i8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n-            ast::ty_i16 =>  (i16::min_value as i64, i16::max_value as i64),\n-            ast::ty_i32 =>  (i32::min_value as i64, i32::max_value as i64),\n-            ast::ty_i64 =>  (i64::min_value,        i64::max_value)\n+            ast::TyI =>    (i64::min_value,        i64::max_value),\n+            ast::TyI8 =>   (i8::min_value  as i64, i8::max_value  as i64),\n+            ast::TyI16 =>  (i16::min_value as i64, i16::max_value as i64),\n+            ast::TyI32 =>  (i32::min_value as i64, i32::max_value as i64),\n+            ast::TyI64 =>  (i64::min_value,        i64::max_value)\n         }\n     }\n \n-    fn uint_ty_range(uint_ty: ast::uint_ty) -> (u64, u64) {\n+    fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n         match uint_ty {\n-            ast::ty_u =>   (u64::min_value,         u64::max_value),\n-            ast::ty_u8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n-            ast::ty_u16 => (u16::min_value  as u64, u16::max_value  as u64),\n-            ast::ty_u32 => (u32::min_value  as u64, u32::max_value  as u64),\n-            ast::ty_u64 => (u64::min_value,         u64::max_value)\n+            ast::TyU =>   (u64::min_value,         u64::max_value),\n+            ast::TyU8 =>  (u8::min_value   as u64, u8::max_value   as u64),\n+            ast::TyU16 => (u16::min_value  as u64, u16::max_value  as u64),\n+            ast::TyU32 => (u32::min_value  as u64, u32::max_value  as u64),\n+            ast::TyU64 => (u64::min_value,         u64::max_value)\n         }\n     }\n \n@@ -723,9 +723,9 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                 let (min, max) = int_ty_range(int_ty);\n                 let lit_val: i64 = match lit.node {\n                     ast::ExprLit(li) => match li.node {\n-                        ast::lit_int(v, _) => v,\n-                        ast::lit_uint(v, _) => v as i64,\n-                        ast::lit_int_unsuffixed(v) => v,\n+                        ast::LitInt(v, _) => v,\n+                        ast::LitUint(v, _) => v as i64,\n+                        ast::LitIntUnsuffixed(v) => v,\n                         _ => return true\n                     },\n                     _ => fail!()\n@@ -736,9 +736,9 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n                 let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                 let lit_val: u64 = match lit.node {\n                     ast::ExprLit(li) => match li.node {\n-                        ast::lit_int(v, _) => v as u64,\n-                        ast::lit_uint(v, _) => v,\n-                        ast::lit_int_unsuffixed(v) => v as u64,\n+                        ast::LitInt(v, _) => v as u64,\n+                        ast::LitUint(v, _) => v,\n+                        ast::LitIntUnsuffixed(v) => v as u64,\n                         _ => return true\n                     },\n                     _ => fail!()\n@@ -758,18 +758,18 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n     }\n }\n \n-fn check_item_ctypes(cx: &Context, it: &ast::item) {\n+fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n     fn check_ty(cx: &Context, ty: &ast::Ty) {\n         match ty.node {\n-            ast::ty_path(_, _, id) => {\n+            ast::TyPath(_, _, id) => {\n                 let def_map = cx.tcx.def_map.borrow();\n                 match def_map.get().get_copy(&id) {\n-                    ast::DefPrimTy(ast::ty_int(ast::ty_i)) => {\n+                    ast::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                         cx.span_lint(ctypes, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                 libc::c_int or libc::c_long should be used\");\n                     }\n-                    ast::DefPrimTy(ast::ty_uint(ast::ty_u)) => {\n+                    ast::DefPrimTy(ast::TyUint(ast::TyU)) => {\n                         cx.span_lint(ctypes, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                 libc::c_uint or libc::c_ulong should be used\");\n@@ -785,26 +785,24 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                     _ => ()\n                 }\n             }\n-            ast::ty_ptr(ref mt) => { check_ty(cx, mt.ty) }\n-            _ => ()\n+            ast::TyPtr(ref mt) => { check_ty(cx, mt.ty) }\n+            _ => {}\n         }\n     }\n \n-    fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n+    fn check_foreign_fn(cx: &Context, decl: &ast::FnDecl) {\n         for input in decl.inputs.iter() {\n             check_ty(cx, input.ty);\n         }\n         check_ty(cx, decl.output)\n     }\n \n     match it.node {\n-      ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n+      ast::ItemForeignMod(ref nmod) if !nmod.abis.is_intrinsic() => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n-                ast::foreign_item_fn(decl, _) => {\n-                    check_foreign_fn(cx, decl);\n-                }\n-                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n+                ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),\n+                ast::ForeignItemStatic(t, _) => check_ty(cx, t)\n             }\n         }\n       }\n@@ -854,20 +852,20 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n     }\n }\n \n-fn check_heap_item(cx: &Context, it: &ast::item) {\n+fn check_heap_item(cx: &Context, it: &ast::Item) {\n     match it.node {\n-        ast::item_fn(..) |\n-        ast::item_ty(..) |\n-        ast::item_enum(..) |\n-        ast::item_struct(..) => check_heap_type(cx, it.span,\n+        ast::ItemFn(..) |\n+        ast::ItemTy(..) |\n+        ast::ItemEnum(..) |\n+        ast::ItemStruct(..) => check_heap_type(cx, it.span,\n                                                ty::node_id_to_type(cx.tcx,\n                                                                    it.id)),\n         _ => ()\n     }\n \n     // If it's a struct, we also have to check the fields' types\n     match it.node {\n-        ast::item_struct(struct_def, _) => {\n+        ast::ItemStruct(struct_def, _) => {\n             for struct_field in struct_def.fields.iter() {\n                 check_heap_type(cx, struct_field.span,\n                                 ty::node_id_to_type(cx.tcx,\n@@ -977,7 +975,7 @@ fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n     }\n }\n \n-fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n+fn check_item_non_camel_case_types(cx: &Context, it: &ast::Item) {\n     fn is_camel_case(cx: ty::ctxt, ident: ast::Ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n@@ -999,13 +997,13 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     }\n \n     match it.node {\n-        ast::item_ty(..) | ast::item_struct(..) => {\n+        ast::ItemTy(..) | ast::ItemStruct(..) => {\n             check_case(cx, \"type\", it.ident, it.span)\n         }\n-        ast::item_trait(..) => {\n+        ast::ItemTrait(..) => {\n             check_case(cx, \"trait\", it.ident, it.span)\n         }\n-        ast::item_enum(ref enum_definition, _) => {\n+        ast::ItemEnum(ref enum_definition, _) => {\n             check_case(cx, \"type\", it.ident, it.span);\n             for variant in enum_definition.variants.iter() {\n                 check_case(cx, \"variant\", variant.node.name, variant.span);\n@@ -1015,10 +1013,10 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     }\n }\n \n-fn check_item_non_uppercase_statics(cx: &Context, it: &ast::item) {\n+fn check_item_non_uppercase_statics(cx: &Context, it: &ast::Item) {\n     match it.node {\n         // only check static constants\n-        ast::item_static(_, ast::MutImmutable, _) => {\n+        ast::ItemStatic(_, ast::MutImmutable, _) => {\n             let s = cx.tcx.sess.str_of(it.ident);\n             // check for lowercase letters rather than non-uppercase\n             // ones (some scripts don't have a concept of\n@@ -1112,7 +1110,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n         ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n             match e2.node {\n-                ast::ExprLit(@codemap::Spanned{node: ast::lit_str(..), ..}) |\n+                ast::ExprLit(@codemap::Spanned{node: ast::LitStr(..), ..}) |\n                 ast::ExprVec(..) => VectorAllocation,\n                 _ => return\n             }\n@@ -1182,19 +1180,19 @@ fn check_missing_doc_attrs(cx: &Context,\n     }\n }\n \n-fn check_missing_doc_item(cx: &Context, it: &ast::item) {\n+fn check_missing_doc_item(cx: &Context, it: &ast::Item) {\n     let desc = match it.node {\n-        ast::item_fn(..) => \"a function\",\n-        ast::item_mod(..) => \"a module\",\n-        ast::item_enum(..) => \"an enum\",\n-        ast::item_struct(..) => \"a struct\",\n-        ast::item_trait(..) => \"a trait\",\n+        ast::ItemFn(..) => \"a function\",\n+        ast::ItemMod(..) => \"a module\",\n+        ast::ItemEnum(..) => \"an enum\",\n+        ast::ItemStruct(..) => \"a struct\",\n+        ast::ItemTrait(..) => \"a trait\",\n         _ => return\n     };\n     check_missing_doc_attrs(cx, Some(it.id), it.attrs, it.span, desc);\n }\n \n-fn check_missing_doc_method(cx: &Context, m: &ast::method) {\n+fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n     let did = ast::DefId {\n         crate: ast::LOCAL_CRATE,\n         node: m.id\n@@ -1231,16 +1229,16 @@ fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n     check_missing_doc_attrs(cx, Some(tm.id), tm.attrs, tm.span, \"a type method\");\n }\n \n-fn check_missing_doc_struct_field(cx: &Context, sf: &ast::struct_field) {\n+fn check_missing_doc_struct_field(cx: &Context, sf: &ast::StructField) {\n     match sf.node.kind {\n-        ast::named_field(_, vis) if vis != ast::private =>\n+        ast::NamedField(_, vis) if vis != ast::Private =>\n             check_missing_doc_attrs(cx, Some(cx.cur_struct_def_id), sf.node.attrs,\n                                     sf.span, \"a struct field\"),\n         _ => {}\n     }\n }\n \n-fn check_missing_doc_variant(cx: &Context, v: &ast::variant) {\n+fn check_missing_doc_variant(cx: &Context, v: &ast::Variant) {\n     check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs, v.span, \"a variant\");\n }\n \n@@ -1345,7 +1343,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n }\n \n impl<'a> Visitor<()> for Context<'a> {\n-    fn visit_item(&mut self, it: &ast::item, _: ()) {\n+    fn visit_item(&mut self, it: &ast::Item, _: ()) {\n         self.with_lint_attrs(it.attrs, |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n@@ -1360,14 +1358,14 @@ impl<'a> Visitor<()> for Context<'a> {\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, it: &ast::ForeignItem, _: ()) {\n         self.with_lint_attrs(it.attrs, |cx| {\n             check_attrs_usage(cx, it.attrs);\n             visit::walk_foreign_item(cx, it, ());\n         })\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::view_item, _: ()) {\n+    fn visit_view_item(&mut self, i: &ast::ViewItem, _: ()) {\n         self.with_lint_attrs(i.attrs, |cx| {\n             check_attrs_usage(cx, i.attrs);\n             visit::walk_view_item(cx, i, ());\n@@ -1414,14 +1412,14 @@ impl<'a> Visitor<()> for Context<'a> {\n         visit::walk_stmt(self, s, ());\n     }\n \n-    fn visit_fn(&mut self, fk: &visit::fn_kind, decl: &ast::fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, decl: &ast::FnDecl,\n                 body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n         let recurse = |this: &mut Context| {\n             visit::walk_fn(this, fk, decl, body, span, id, ());\n         };\n \n         match *fk {\n-            visit::fk_method(_, _, m) => {\n+            visit::FkMethod(_, _, m) => {\n                 self.with_lint_attrs(m.attrs, |cx| {\n                     check_missing_doc_method(cx, m);\n                     check_attrs_usage(cx, m.attrs);\n@@ -1447,7 +1445,7 @@ impl<'a> Visitor<()> for Context<'a> {\n     }\n \n     fn visit_struct_def(&mut self,\n-                        s: &ast::struct_def,\n+                        s: &ast::StructDef,\n                         i: ast::Ident,\n                         g: &ast::Generics,\n                         id: ast::NodeId,\n@@ -1458,7 +1456,7 @@ impl<'a> Visitor<()> for Context<'a> {\n         self.cur_struct_def_id = old_id;\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::struct_field, _: ()) {\n+    fn visit_struct_field(&mut self, s: &ast::StructField, _: ()) {\n         self.with_lint_attrs(s.node.attrs, |cx| {\n             check_missing_doc_struct_field(cx, s);\n             check_attrs_usage(cx, s.node.attrs);\n@@ -1467,7 +1465,7 @@ impl<'a> Visitor<()> for Context<'a> {\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::variant, g: &ast::Generics, _: ()) {\n+    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, _: ()) {\n         self.with_lint_attrs(v.node.attrs, |cx| {\n             check_missing_doc_variant(cx, v);\n             check_attrs_usage(cx, v.node.attrs);"}, {"sha": "8ffb78f8ac45c5526380ac2f93ad22c7ec01697b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -122,7 +122,7 @@ use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n use syntax::{visit, ast_util};\n-use syntax::visit::{Visitor,fn_kind};\n+use syntax::visit::{Visitor, FnKind};\n \n #[deriving(Eq)]\n struct Variable(uint);\n@@ -164,7 +164,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n struct LivenessVisitor;\n \n impl Visitor<@IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n         visit_fn(self, fk, fd, b, s, n, e);\n     }\n     fn visit_local(&mut self, l: &Local, e: @IrMaps) { visit_local(self, l, e); }\n@@ -364,7 +364,7 @@ impl IrMaps {\n }\n \n impl Visitor<()> for Liveness {\n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl, b: &Block, s: Span, n: NodeId, _: ()) {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n     fn visit_local(&mut self, l: &Local, _: ()) {\n@@ -379,8 +379,8 @@ impl Visitor<()> for Liveness {\n }\n \n fn visit_fn(v: &mut LivenessVisitor,\n-            fk: &visit::fn_kind,\n-            decl: &fn_decl,\n+            fk: &FnKind,\n+            decl: &FnDecl,\n             body: &Block,\n             sp: Span,\n             id: NodeId,\n@@ -407,16 +407,16 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n     // Add `this`, whether explicit or implicit.\n     match *fk {\n-        visit::fk_method(_, _, method) => {\n+        visit::FkMethod(_, _, method) => {\n             match method.explicit_self.node {\n-                sty_value(_) | sty_region(..) | sty_box(_) | sty_uniq(_) => {\n+                SelfValue(_) | SelfRegion(..) | SelfBox(_) | SelfUniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }\n-                sty_static => {}\n+                SelfStatic => {}\n             }\n         }\n-        visit::fk_item_fn(..) | visit::fk_fn_block(..) => {}\n+        visit::FkItemFn(..) | visit::FkFnBlock(..) => {}\n     }\n \n     // gather up the various local variables, significant expressions,\n@@ -932,7 +932,7 @@ impl Liveness {\n \n     // _______________________________________________________________________\n \n-    pub fn compute(&self, decl: &fn_decl, body: &Block) -> LiveNode {\n+    pub fn compute(&self, decl: &FnDecl, body: &Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -957,7 +957,7 @@ impl Liveness {\n         entry_ln\n     }\n \n-    pub fn propagate_through_fn_block(&self, _: &fn_decl, blk: &Block)\n+    pub fn propagate_through_fn_block(&self, _: &FnDecl, blk: &Block)\n                                       -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -1554,8 +1554,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n }\n \n fn check_fn(_v: &Liveness,\n-            _fk: &visit::fn_kind,\n-            _decl: &fn_decl,\n+            _fk: &FnKind,\n+            _decl: &FnDecl,\n             _body: &Block,\n             _sp: Span,\n             _id: NodeId) {\n@@ -1573,7 +1573,7 @@ impl Liveness {\n     pub fn check_ret(&self,\n                      id: NodeId,\n                      sp: Span,\n-                     _fk: &visit::fn_kind,\n+                     _fk: &FnKind,\n                      entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1665,7 +1665,7 @@ impl Liveness {\n         if name.len() == 0 || name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    pub fn warn_about_unused_args(&self, decl: &fn_decl, entry_ln: LiveNode) {\n+    pub fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n             pat_util::pat_bindings(self.tcx.def_map,\n                                    arg.pat,"}, {"sha": "fa83726a4644dc693a4798288fefa3c3edd14d72", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -193,7 +193,7 @@ enum UseMode {\n }\n \n impl visit::Visitor<()> for VisitContext {\n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         compute_modes_for_fn(self, fk, fd, b, s, n);\n     }\n@@ -248,8 +248,8 @@ fn compute_modes_for_local<'a>(cx: &mut VisitContext,\n }\n \n fn compute_modes_for_fn(cx: &mut VisitContext,\n-                        fk: &visit::fn_kind,\n-                        decl: &fn_decl,\n+                        fk: &visit::FnKind,\n+                        decl: &FnDecl,\n                         body: &Block,\n                         span: Span,\n                         id: NodeId) {"}, {"sha": "767ca7fcc70dd5c2d38788e63b27f81d7883a1c9", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 101, "deletions": 102, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -50,20 +50,20 @@ struct ParentVisitor {\n }\n \n impl Visitor<()> for ParentVisitor {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         self.parents.insert(item.id, self.curparent);\n \n         let prev = self.curparent;\n         match item.node {\n-            ast::item_mod(..) => { self.curparent = item.id; }\n+            ast::ItemMod(..) => { self.curparent = item.id; }\n             // Enum variants are parented to the enum definition itself beacuse\n             // they inherit privacy\n-            ast::item_enum(ref def, _) => {\n+            ast::ItemEnum(ref def, _) => {\n                 for variant in def.variants.iter() {\n                     // If variants are private, then their logical \"parent\" is\n                     // the enclosing module because everyone in the enclosing\n                     // module can still use the private variant\n-                    if variant.node.vis == ast::private {\n+                    if variant.node.vis == ast::Private {\n                         self.parents.insert(variant.node.id, self.curparent);\n \n                     // Otherwise, if the variant is public, then the parent is\n@@ -80,11 +80,11 @@ impl Visitor<()> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::item_trait(_, _, ref methods) if item.vis != ast::public => {\n+            ast::ItemTrait(_, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::provided(ref m) => self.parents.insert(m.id, item.id),\n-                        ast::required(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::Provided(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::Required(ref m) => self.parents.insert(m.id, item.id),\n                     };\n                 }\n             }\n@@ -95,12 +95,12 @@ impl Visitor<()> for ParentVisitor {\n         self.curparent = prev;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem, _: ()) {\n         self.parents.insert(a.id, self.curparent);\n         visit::walk_foreign_item(self, a, ());\n     }\n \n-    fn visit_fn(&mut self, a: &visit::fn_kind, b: &ast::fn_decl,\n+    fn visit_fn(&mut self, a: &visit::FnKind, b: &ast::FnDecl,\n                 c: &ast::Block, d: Span, id: ast::NodeId, _: ()) {\n         // We already took care of some trait methods above, otherwise things\n         // like impl methods and pub trait methods are parented to the\n@@ -111,7 +111,7 @@ impl Visitor<()> for ParentVisitor {\n         visit::walk_fn(self, a, b, c, d, id, ());\n     }\n \n-    fn visit_struct_def(&mut self, s: &ast::struct_def, i: ast::Ident,\n+    fn visit_struct_def(&mut self, s: &ast::StructDef, i: ast::Ident,\n                         g: &ast::Generics, n: ast::NodeId, _: ()) {\n         // Struct constructors are parented to their struct definitions because\n         // they essentially are the struct definitions.\n@@ -124,14 +124,14 @@ impl Visitor<()> for ParentVisitor {\n         // all the fields.\n         for field in s.fields.iter() {\n             let vis = match field.node.kind {\n-                ast::named_field(_, vis) => vis,\n-                ast::unnamed_field => continue\n+                ast::NamedField(_, vis) => vis,\n+                ast::UnnamedField => continue\n             };\n \n             // Private fields are scoped to this module, so parent them directly\n             // to the module instead of the struct. This is similar to the case\n             // of private enum variants.\n-            if vis == ast::private {\n+            if vis == ast::Private {\n                 self.parents.insert(field.node.id, self.curparent);\n \n             // Otherwise public fields are scoped to the visibility of the\n@@ -196,9 +196,9 @@ impl<'a> EmbargoVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let orig_all_pub = self.prev_public;\n-        self.prev_public = orig_all_pub && item.vis == ast::public;\n+        self.prev_public = orig_all_pub && item.vis == ast::Public;\n         if self.prev_public {\n             self.public_items.insert(item.id);\n         }\n@@ -207,19 +207,19 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n-            ast::item_impl(..) | ast::item_foreign_mod(..) => {}\n+            ast::ItemImpl(..) | ast::ItemForeignMod(..) => {}\n \n             // Traits are a little special in that even if they themselves are\n             // not public they may still be exported.\n-            ast::item_trait(..) => {\n+            ast::ItemTrait(..) => {\n                 self.prev_exported = self.exported_trait(item.id);\n             }\n \n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n             _ => {\n                 self.prev_exported =\n-                    (orig_all_exported && item.vis == ast::public) ||\n+                    (orig_all_exported && item.vis == ast::Public) ||\n                      self.reexports.contains(&item.id);\n             }\n         }\n@@ -230,9 +230,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         match item.node {\n             // Enum variants inherit from their parent, so if the enum is\n             // public all variants are public unless they're explicitly priv\n-            ast::item_enum(ref def, _) if public_first => {\n+            ast::ItemEnum(ref def, _) if public_first => {\n                 for variant in def.variants.iter() {\n-                    if variant.node.vis != ast::private {\n+                    if variant.node.vis != ast::Private {\n                         self.exported_items.insert(variant.node.id);\n                     }\n                 }\n@@ -257,9 +257,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             //   undefined symbols at linkage time if this case is not handled.\n             //\n             // * Private trait impls for private types can be completely ignored\n-            ast::item_impl(_, _, ref ty, ref methods) => {\n+            ast::ItemImpl(_, _, ref ty, ref methods) => {\n                 let public_ty = match ty.node {\n-                    ast::ty_path(_, _, id) => {\n+                    ast::TyPath(_, _, id) => {\n                         let def_map = self.tcx.def_map.borrow();\n                         match def_map.get().get_copy(&id) {\n                             ast::DefPrimTy(..) => true,\n@@ -281,9 +281,9 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                 if public_ty || public_trait {\n                     for method in methods.iter() {\n                         let meth_public = match method.explicit_self.node {\n-                            ast::sty_static => public_ty,\n+                            ast::SelfStatic => public_ty,\n                             _ => true,\n-                        } && method.vis == ast::public;\n+                        } && method.vis == ast::Public;\n                         if meth_public || tr.is_some() {\n                             self.exported_items.insert(method.id);\n                         }\n@@ -293,14 +293,14 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::item_trait(_, _, ref methods) if public_first => {\n+            ast::ItemTrait(_, _, ref methods) if public_first => {\n                 for method in methods.iter() {\n                     match *method {\n-                        ast::provided(ref m) => {\n+                        ast::Provided(ref m) => {\n                             debug!(\"provided {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n-                        ast::required(ref m) => {\n+                        ast::Required(ref m) => {\n                             debug!(\"required {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n@@ -309,7 +309,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n             }\n \n             // Struct constructors are public if the struct is all public.\n-            ast::item_struct(ref def, _) if public_first => {\n+            ast::ItemStruct(ref def, _) if public_first => {\n                 match def.ctor_id {\n                     Some(id) => { self.exported_items.insert(id); }\n                     None => {}\n@@ -325,13 +325,13 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n         self.prev_public = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &ast::foreign_item, _: ()) {\n-        if self.prev_exported && a.vis == ast::public {\n+    fn visit_foreign_item(&mut self, a: &ast::ForeignItem, _: ()) {\n+        if self.prev_exported && a.vis == ast::Public {\n             self.exported_items.insert(a.id);\n         }\n     }\n \n-    fn visit_mod(&mut self, m: &ast::_mod, _sp: Span, id: ast::NodeId, _: ()) {\n+    fn visit_mod(&mut self, m: &ast::Mod, _sp: Span, id: ast::NodeId, _: ()) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_exported {\n@@ -402,7 +402,7 @@ impl<'a> PrivacyVisitor<'a> {\n                                 None => {\n                                     debug!(\"privacy - found a method {:?}\",\n                                             meth.vis);\n-                                    if meth.vis == ast::public {\n+                                    if meth.vis == ast::Public {\n                                         Allowable\n                                     } else {\n                                         ExternallyDenied\n@@ -449,30 +449,30 @@ impl<'a> PrivacyVisitor<'a> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(&ast_map::node_method(ref m, imp, _)) => {\n+                Some(&ast_map::NodeMethod(ref m, imp, _)) => {\n                     match ty::impl_trait_ref(self.tcx, imp) {\n                         Some(..) => return Allowable,\n-                        _ if m.vis == ast::public => return Allowable,\n+                        _ if m.vis == ast::Public => return Allowable,\n                         _ => m.vis\n                     }\n                 }\n-                Some(&ast_map::node_trait_method(..)) => {\n+                Some(&ast_map::NodeTraitMethod(..)) => {\n                     return Allowable;\n                 }\n \n                 // This is not a method call, extract the visibility as one\n                 // would normally look at it\n-                Some(&ast_map::node_item(it, _)) => it.vis,\n-                Some(&ast_map::node_foreign_item(_, _, v, _)) => v,\n-                Some(&ast_map::node_variant(ref v, _, _)) => {\n+                Some(&ast_map::NodeItem(it, _)) => it.vis,\n+                Some(&ast_map::NodeForeignItem(_, _, v, _)) => v,\n+                Some(&ast_map::NodeVariant(ref v, _, _)) => {\n                     // sadly enum variants still inherit visibility, so only\n                     // break out of this is explicitly private\n-                    if v.node.vis == ast::private { break }\n-                    ast::public // need to move up a level (to the enum)\n+                    if v.node.vis == ast::Private { break }\n+                    ast::Public // need to move up a level (to the enum)\n                 }\n-                _ => ast::public,\n+                _ => ast::Public,\n             };\n-            if vis != ast::public { break }\n+            if vis != ast::Public { break }\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n@@ -540,10 +540,10 @@ impl<'a> PrivacyVisitor<'a> {\n                 }\n                 let items = self.tcx.items.borrow();\n                 match items.get().find(&id) {\n-                    Some(&ast_map::node_item(item, _)) => {\n+                    Some(&ast_map::NodeItem(item, _)) => {\n                         let desc = match item.node {\n-                            ast::item_mod(..) => \"module\",\n-                            ast::item_trait(..) => \"trait\",\n+                            ast::ItemMod(..) => \"module\",\n+                            ast::ItemTrait(..) => \"trait\",\n                             _ => return false,\n                         };\n                         let msg = format!(\"{} `{}` is private\", desc,\n@@ -565,7 +565,7 @@ impl<'a> PrivacyVisitor<'a> {\n         for field in fields.iter() {\n             if field.name != ident.name { continue; }\n             // public fields are public everywhere\n-            if field.vis != ast::private { break }\n+            if field.vis != ast::Private { break }\n             if !is_local(field.id) ||\n                !self.private_accessible(field.id.node) {\n                 self.tcx.sess.span_err(span, format!(\"field `{}` is private\",\n@@ -638,7 +638,7 @@ impl<'a> PrivacyVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         // Do not check privacy inside items with the resolve_unexported\n         // attribute. This is used for the test runner.\n         if attr::contains_name(item.attrs, \"!resolve_unexported\") {\n@@ -722,15 +722,14 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n         visit::walk_expr(self, expr, ());\n     }\n \n-    fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n+    fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n         match a.node {\n-            ast::view_item_extern_mod(..) => {}\n-            ast::view_item_use(ref uses) => {\n+            ast::ViewItemExternMod(..) => {}\n+            ast::ViewItemUse(ref uses) => {\n                 for vpath in uses.iter() {\n                     match vpath.node {\n-                        ast::view_path_simple(..) |\n-                        ast::view_path_glob(..) => {}\n-                        ast::view_path_list(_, ref list, _) => {\n+                        ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n+                        ast::ViewPathList(_, ref list, _) => {\n                             for pid in list.iter() {\n                                 debug!(\"privacy - list {}\", pid.node.id);\n                                 let seg = ast::PathSegment {\n@@ -796,7 +795,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n         visit::walk_pat(self, pattern, ());\n     }\n \n-    fn visit_foreign_item(&mut self, fi: &ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, fi: &ast::ForeignItem, _: ()) {\n         self.in_foreign = true;\n         visit::walk_foreign_item(self, fi, ());\n         self.in_foreign = false;\n@@ -818,22 +817,22 @@ struct SanePrivacyVisitor {\n }\n \n impl Visitor<()> for SanePrivacyVisitor {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n         } else {\n             self.check_sane_privacy(item);\n         }\n \n         let orig_in_fn = util::replace(&mut self.in_fn, match item.node {\n-            ast::item_mod(..) => false, // modules turn privacy back on\n+            ast::ItemMod(..) => false, // modules turn privacy back on\n             _ => self.in_fn,           // otherwise we inherit\n         });\n         visit::walk_item(self, item, ());\n         self.in_fn = orig_in_fn;\n     }\n \n-    fn visit_fn(&mut self, fk: &visit::fn_kind, fd: &ast::fn_decl,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n                 b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n         // This catches both functions and methods\n         let orig_in_fn = util::replace(&mut self.in_fn, true);\n@@ -847,42 +846,42 @@ impl SanePrivacyVisitor {\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n     /// later on down the road...\n-    fn check_sane_privacy(&self, item: &ast::item) {\n+    fn check_sane_privacy(&self, item: &ast::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::visibility, note: &str| {\n-            if vis != ast::inherited {\n+        let check_inherited = |sp: Span, vis: ast::Visibility, note: &str| {\n+            if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n                 if note.len() > 0 {\n                     tcx.sess.span_note(sp, note);\n                 }\n             }\n         };\n-        let check_not_priv = |sp: Span, vis: ast::visibility, note: &str| {\n-            if vis == ast::private {\n+        let check_not_priv = |sp: Span, vis: ast::Visibility, note: &str| {\n+            if vis == ast::Private {\n                 tcx.sess.span_err(sp, \"unnecessary `priv` qualifier\");\n                 if note.len() > 0 {\n                     tcx.sess.span_note(sp, note);\n                 }\n             }\n         };\n-        let check_struct = |def: &@ast::struct_def| {\n+        let check_struct = |def: &@ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n-                    ast::named_field(_, ast::public) => {\n+                    ast::NamedField(_, ast::Public) => {\n                         tcx.sess.span_err(f.span, \"unnecessary `pub` \\\n                                                    visibility\");\n                     }\n-                    ast::named_field(_, ast::private) => {\n+                    ast::NamedField(_, ast::Private) => {\n                         // Fields should really be private by default...\n                     }\n-                    ast::named_field(..) | ast::unnamed_field => {}\n+                    ast::NamedField(..) | ast::UnnamedField => {}\n                 }\n             }\n         };\n         match item.node {\n             // implementations of traits don't need visibility qualifiers because\n             // that's controlled by having the trait in scope.\n-            ast::item_impl(_, Some(..), _, ref methods) => {\n+            ast::ItemImpl(_, Some(..), _, ref methods) => {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n@@ -891,15 +890,15 @@ impl SanePrivacyVisitor {\n                 }\n             }\n \n-            ast::item_impl(_, _, _, ref methods) => {\n+            ast::ItemImpl(_, _, _, ref methods) => {\n                 check_inherited(item.span, item.vis,\n                                 \"place qualifiers on individual methods instead\");\n                 for i in methods.iter() {\n                     check_not_priv(i.span, i.vis, \"functions are private by \\\n                                                    default\");\n                 }\n             }\n-            ast::item_foreign_mod(ref fm) => {\n+            ast::ItemForeignMod(ref fm) => {\n                 check_inherited(item.span, item.vis,\n                                 \"place qualifiers on individual functions \\\n                                  instead\");\n@@ -909,48 +908,48 @@ impl SanePrivacyVisitor {\n                 }\n             }\n \n-            ast::item_enum(ref def, _) => {\n+            ast::ItemEnum(ref def, _) => {\n                 for v in def.variants.iter() {\n                     match v.node.vis {\n-                        ast::public => {\n-                            if item.vis == ast::public {\n+                        ast::Public => {\n+                            if item.vis == ast::Public {\n                                 tcx.sess.span_err(v.span, \"unnecessary `pub` \\\n                                                            visibility\");\n                             }\n                         }\n-                        ast::private => {\n-                            if item.vis != ast::public {\n+                        ast::Private => {\n+                            if item.vis != ast::Public {\n                                 tcx.sess.span_err(v.span, \"unnecessary `priv` \\\n                                                            visibility\");\n                             }\n                         }\n-                        ast::inherited => {}\n+                        ast::Inherited => {}\n                     }\n \n                     match v.node.kind {\n-                        ast::struct_variant_kind(ref s) => check_struct(s),\n-                        ast::tuple_variant_kind(..) => {}\n+                        ast::StructVariantKind(ref s) => check_struct(s),\n+                        ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::item_struct(ref def, _) => check_struct(def),\n+            ast::ItemStruct(ref def, _) => check_struct(def),\n \n-            ast::item_trait(_, _, ref methods) => {\n+            ast::ItemTrait(_, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::provided(ref m) => {\n+                        ast::Provided(ref m) => {\n                             check_inherited(m.span, m.vis,\n                                             \"unnecessary visibility\");\n                         }\n-                        ast::required(..) => {}\n+                        ast::Required(..) => {}\n                     }\n                 }\n             }\n \n-            ast::item_static(..) |\n-            ast::item_fn(..) | ast::item_mod(..) | ast::item_ty(..) |\n-            ast::item_mac(..) => {\n+            ast::ItemStatic(..) |\n+            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n+            ast::ItemMac(..) => {\n                 check_not_priv(item.span, item.vis, \"items are private by \\\n                                                      default\");\n             }\n@@ -959,58 +958,58 @@ impl SanePrivacyVisitor {\n \n     /// When inside of something like a function or a method, visibility has no\n     /// control over anything so this forbids any mention of any visibility\n-    fn check_all_inherited(&self, item: &ast::item) {\n+    fn check_all_inherited(&self, item: &ast::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::visibility| {\n-            if vis != ast::inherited {\n+        let check_inherited = |sp: Span, vis: ast::Visibility| {\n+            if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         };\n-        let check_struct = |def: &@ast::struct_def| {\n+        let check_struct = |def: &@ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n-                    ast::named_field(_, p) => check_inherited(f.span, p),\n-                    ast::unnamed_field => {}\n+                    ast::NamedField(_, p) => check_inherited(f.span, p),\n+                    ast::UnnamedField => {}\n                 }\n             }\n         };\n         check_inherited(item.span, item.vis);\n         match item.node {\n-            ast::item_impl(_, _, _, ref methods) => {\n+            ast::ItemImpl(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     check_inherited(m.span, m.vis);\n                 }\n             }\n-            ast::item_foreign_mod(ref fm) => {\n+            ast::ItemForeignMod(ref fm) => {\n                 for i in fm.items.iter() {\n                     check_inherited(i.span, i.vis);\n                 }\n             }\n-            ast::item_enum(ref def, _) => {\n+            ast::ItemEnum(ref def, _) => {\n                 for v in def.variants.iter() {\n                     check_inherited(v.span, v.node.vis);\n \n                     match v.node.kind {\n-                        ast::struct_variant_kind(ref s) => check_struct(s),\n-                        ast::tuple_variant_kind(..) => {}\n+                        ast::StructVariantKind(ref s) => check_struct(s),\n+                        ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::item_struct(ref def, _) => check_struct(def),\n+            ast::ItemStruct(ref def, _) => check_struct(def),\n \n-            ast::item_trait(_, _, ref methods) => {\n+            ast::ItemTrait(_, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::required(..) => {}\n-                        ast::provided(ref m) => check_inherited(m.span, m.vis),\n+                        ast::Required(..) => {}\n+                        ast::Provided(ref m) => check_inherited(m.span, m.vis),\n                     }\n                 }\n             }\n \n-            ast::item_static(..) |\n-            ast::item_fn(..) | ast::item_mod(..) | ast::item_ty(..) |\n-            ast::item_mac(..) => {}\n+            ast::ItemStatic(..) |\n+            ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n+            ast::ItemMac(..) => {}\n         }\n     }\n }"}, {"sha": "b95901b8d789ececb75f51479316b2536cdc68ea", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -44,21 +44,21 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: &ast::item) -> bool {\n+fn item_might_be_inlined(item: &ast::Item) -> bool {\n     if attributes_specify_inlining(item.attrs) {\n         return true\n     }\n \n     match item.node {\n-        ast::item_impl(ref generics, _, _, _) |\n-        ast::item_fn(_, _, _, ref generics, _) => {\n+        ast::ItemImpl(ref generics, _, _, _) |\n+        ast::ItemFn(_, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n     }\n }\n \n-fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n+fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs) ||\n         generics_require_inlining(&method.generics) {\n@@ -68,7 +68,7 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n         {\n             let items = tcx.items.borrow();\n             match items.get().find(&impl_src.node) {\n-                Some(&ast_map::node_item(item, _)) => {\n+                Some(&ast_map::NodeItem(item, _)) => {\n                     item_might_be_inlined(item)\n                 }\n                 Some(..) | None => {\n@@ -187,7 +187,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n         visit::walk_expr(self, expr, ())\n     }\n \n-    fn visit_item(&mut self, _item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, _item: &ast::Item, _: ()) {\n         // Do not recurse into items. These items will be added to the worklist\n         // and recursed into manually if necessary.\n     }\n@@ -215,19 +215,19 @@ impl ReachableContext {\n         let node_id = def_id.node;\n         let items = tcx.items.borrow();\n         match items.get().find(&node_id) {\n-            Some(&ast_map::node_item(item, _)) => {\n+            Some(&ast_map::NodeItem(item, _)) => {\n                 match item.node {\n-                    ast::item_fn(..) => item_might_be_inlined(item),\n+                    ast::ItemFn(..) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n-            Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+            Some(&ast_map::NodeTraitMethod(trait_method, _, _)) => {\n                 match *trait_method {\n-                    ast::required(_) => false,\n-                    ast::provided(_) => true,\n+                    ast::Required(_) => false,\n+                    ast::Provided(_) => true,\n                 }\n             }\n-            Some(&ast_map::node_method(method, impl_did, _)) => {\n+            Some(&ast_map::NodeMethod(method, impl_did, _)) => {\n                 if generics_require_inlining(&method.generics) ||\n                         attributes_specify_inlining(method.attrs) {\n                     true\n@@ -236,9 +236,9 @@ impl ReachableContext {\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.crate == ast::LOCAL_CRATE);\n                     match items.get().find(&impl_did.node) {\n-                        Some(&ast_map::node_item(item, _)) => {\n+                        Some(&ast_map::NodeItem(item, _)) => {\n                             match item.node {\n-                                ast::item_impl(ref generics, _, _, _) => {\n+                                ast::ItemImpl(ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n                                 _ => false\n@@ -308,7 +308,7 @@ impl ReachableContext {\n         }\n     }\n \n-    fn propagate_node(&self, node: &ast_map::ast_node,\n+    fn propagate_node(&self, node: &ast_map::Node,\n                       search_item: ast::NodeId,\n                       visitor: &mut MarkSymbolVisitor) {\n         if !self.tcx.sess.building_library.get() {\n@@ -318,9 +318,9 @@ impl ReachableContext {\n             // but all other rust-only interfaces can be private (they will not\n             // participate in linkage after this product is produced)\n             match *node {\n-                ast_map::node_item(item, _) => {\n+                ast_map::NodeItem(item, _) => {\n                     match item.node {\n-                        ast::item_fn(_, ast::extern_fn, _, _, _) => {\n+                        ast::ItemFn(_, ast::ExternFn, _, _, _) => {\n                             let mut reachable_symbols =\n                                 self.reachable_symbols.borrow_mut();\n                             reachable_symbols.get().insert(search_item);\n@@ -340,17 +340,17 @@ impl ReachableContext {\n         }\n \n         match *node {\n-            ast_map::node_item(item, _) => {\n+            ast_map::NodeItem(item, _) => {\n                 match item.node {\n-                    ast::item_fn(_, _, _, _, search_block) => {\n+                    ast::ItemFn(_, _, _, _, search_block) => {\n                         if item_might_be_inlined(item) {\n                             visit::walk_block(visitor, search_block, ())\n                         }\n                     }\n \n                     // Statics with insignificant addresses are not reachable\n                     // because they're inlined specially into all other crates.\n-                    ast::item_static(..) => {\n+                    ast::ItemStatic(..) => {\n                         if attr::contains_name(item.attrs,\n                                                \"address_insignificant\") {\n                             let mut reachable_symbols =\n@@ -362,10 +362,10 @@ impl ReachableContext {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::item_ty(..) |\n-                    ast::item_mod(..) | ast::item_foreign_mod(..) |\n-                    ast::item_impl(..) | ast::item_trait(..) |\n-                    ast::item_struct(..) | ast::item_enum(..) => {}\n+                    ast::ItemTy(..) |\n+                    ast::ItemMod(..) | ast::ItemForeignMod(..) |\n+                    ast::ItemImpl(..) | ast::ItemTrait(..) |\n+                    ast::ItemStruct(..) | ast::ItemEnum(..) => {}\n \n                     _ => {\n                         self.tcx.sess.span_bug(item.span,\n@@ -374,25 +374,25 @@ impl ReachableContext {\n                     }\n                 }\n             }\n-            ast_map::node_trait_method(trait_method, _, _) => {\n+            ast_map::NodeTraitMethod(trait_method, _, _) => {\n                 match *trait_method {\n-                    ast::required(..) => {\n+                    ast::Required(..) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    ast::provided(ref method) => {\n+                    ast::Provided(ref method) => {\n                         visit::walk_block(visitor, method.body, ())\n                     }\n                 }\n             }\n-            ast_map::node_method(method, did, _) => {\n+            ast_map::NodeMethod(method, did, _) => {\n                 if method_might_be_inlined(self.tcx, method, did) {\n                     visit::walk_block(visitor, method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these\n-            ast_map::node_foreign_item(..) |\n-            ast_map::node_variant(..) |\n-            ast_map::node_struct_ctor(..) => {}\n+            ast_map::NodeForeignItem(..) |\n+            ast_map::NodeVariant(..) |\n+            ast_map::NodeStructCtor(..) => {}\n             _ => {\n                 let ident_interner = token::get_ident_interner();\n                 let desc = ast_map::node_id_to_str(self.tcx.items,"}, {"sha": "ef755b12d15d18b9e11edc33dea2bbb59a18473e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -29,8 +29,8 @@ use std::cell::RefCell;\n use std::hashmap::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n-use syntax::visit::{Visitor,fn_kind};\n-use syntax::ast::{Block,item,fn_decl,NodeId,Arm,Pat,Stmt,Expr,Local};\n+use syntax::visit::{Visitor, FnKind};\n+use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n \n /**\n The region maps encode information about region relationships.\n@@ -425,16 +425,16 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n }\n \n fn resolve_item(visitor: &mut RegionResolutionVisitor,\n-                item: &ast::item,\n+                item: &ast::Item,\n                 cx: Context) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n     visit::walk_item(visitor, item, new_cx);\n }\n \n fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              fk: &visit::fn_kind,\n-              decl: &ast::fn_decl,\n+              fk: &FnKind,\n+              decl: &ast::FnDecl,\n               body: &ast::Block,\n               sp: Span,\n               id: ast::NodeId,\n@@ -453,7 +453,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                            var_parent: Some(body.id),\n                            ..cx};\n     match *fk {\n-        visit::fk_method(_, _, method) => {\n+        visit::FkMethod(_, _, method) => {\n             visitor.region_maps.record_parent(method.self_id, body.id);\n         }\n         _ => {}\n@@ -463,13 +463,10 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     let body_cx = match *fk {\n-        visit::fk_item_fn(..) |\n-        visit::fk_method(..) => {\n+        visit::FkItemFn(..) | visit::FkMethod(..) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n-        visit::fk_fn_block(..) => {\n-            cx\n-        }\n+        visit::FkFnBlock(..) => cx\n     };\n     visitor.visit_block(body, body_cx);\n }\n@@ -480,11 +477,11 @@ impl Visitor<Context> for RegionResolutionVisitor {\n         resolve_block(self, b, cx);\n     }\n \n-    fn visit_item(&mut self, i: &item, cx: Context) {\n+    fn visit_item(&mut self, i: &Item, cx: Context) {\n         resolve_item(self, i, cx);\n     }\n \n-    fn visit_fn(&mut self, fk: &fn_kind, fd: &fn_decl,\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, cx: Context) {\n         resolve_fn(self, fk, fd, b, s, n, cx);\n     }"}, {"sha": "cd190dc999b9d0395c7eb348399a2ad0baa7a298", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 112, "deletions": 118, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax::ast_util::{def_id_of_def, local_def, mtwt_resolve};\n use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::parse::token;\n-use syntax::parse::token::{ident_interner, interner_get};\n+use syntax::parse::token::{IdentInterner, interner_get};\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n@@ -133,11 +133,11 @@ enum NameDefinition {\n \n enum SelfBinding {\n     NoSelfBinding,\n-    HasSelfBinding(NodeId, explicit_self)\n+    HasSelfBinding(NodeId, ExplicitSelf)\n }\n \n impl Visitor<()> for Resolver {\n-    fn visit_item(&mut self, item: &item, _: ()) {\n+    fn visit_item(&mut self, item: &Item, _: ()) {\n         self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm: &Arm, _: ()) {\n@@ -735,13 +735,11 @@ fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Name,prim_ty>,\n+    primitive_types: HashMap<Name, PrimTy>,\n }\n \n impl PrimitiveTypeTable {\n-    fn intern(&mut self,\n-                  string: &str,\n-                  primitive_type: prim_ty) {\n+    fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n         self.primitive_types.insert(token::intern(string), primitive_type);\n     }\n }\n@@ -751,21 +749,21 @@ fn PrimitiveTypeTable() -> PrimitiveTypeTable {\n         primitive_types: HashMap::new()\n     };\n \n-    table.intern(\"bool\",    ty_bool);\n-    table.intern(\"char\",    ty_char);\n-    table.intern(\"f32\",     ty_float(ty_f32));\n-    table.intern(\"f64\",     ty_float(ty_f64));\n-    table.intern(\"int\",     ty_int(ty_i));\n-    table.intern(\"i8\",      ty_int(ty_i8));\n-    table.intern(\"i16\",     ty_int(ty_i16));\n-    table.intern(\"i32\",     ty_int(ty_i32));\n-    table.intern(\"i64\",     ty_int(ty_i64));\n-    table.intern(\"str\",     ty_str);\n-    table.intern(\"uint\",    ty_uint(ty_u));\n-    table.intern(\"u8\",      ty_uint(ty_u8));\n-    table.intern(\"u16\",     ty_uint(ty_u16));\n-    table.intern(\"u32\",     ty_uint(ty_u32));\n-    table.intern(\"u64\",     ty_uint(ty_u64));\n+    table.intern(\"bool\",    TyBool);\n+    table.intern(\"char\",    TyChar);\n+    table.intern(\"f32\",     TyFloat(TyF32));\n+    table.intern(\"f64\",     TyFloat(TyF64));\n+    table.intern(\"int\",     TyInt(TyI));\n+    table.intern(\"i8\",      TyInt(TyI8));\n+    table.intern(\"i16\",     TyInt(TyI16));\n+    table.intern(\"i32\",     TyInt(TyI32));\n+    table.intern(\"i64\",     TyInt(TyI64));\n+    table.intern(\"str\",     TyStr);\n+    table.intern(\"uint\",    TyUint(TyU));\n+    table.intern(\"u8\",      TyUint(TyU8));\n+    table.intern(\"u16\",     TyUint(TyU16));\n+    table.intern(\"u32\",     TyUint(TyU32));\n+    table.intern(\"u64\",     TyUint(TyU64));\n \n     return table;\n }\n@@ -841,7 +839,7 @@ struct Resolver {\n     session: @Session,\n     lang_items: LanguageItems,\n \n-    intr: @ident_interner,\n+    intr: @IdentInterner,\n \n     graph_root: @NameBindings,\n \n@@ -898,12 +896,12 @@ struct BuildReducedGraphVisitor<'a> {\n \n impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n-    fn visit_item(&mut self, item: &item, context: ReducedGraphParent) {\n+    fn visit_item(&mut self, item: &Item, context: ReducedGraphParent) {\n         let p = self.resolver.build_reduced_graph_for_item(item, context);\n         visit::walk_item(self, item, p);\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &foreign_item,\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem,\n                           context: ReducedGraphParent) {\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item,\n                                                            context,\n@@ -913,7 +911,7 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &view_item, context: ReducedGraphParent) {\n+    fn visit_view_item(&mut self, view_item: &ViewItem, context: ReducedGraphParent) {\n         self.resolver.build_reduced_graph_for_view_item(view_item, context);\n     }\n \n@@ -927,7 +925,7 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n struct UnusedImportCheckVisitor<'a> { resolver: &'a Resolver }\n \n impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n-    fn visit_view_item(&mut self, vi: &view_item, _: ()) {\n+    fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());\n     }\n@@ -1141,16 +1139,16 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self,\n-                                        item: &item,\n-                                        parent: ReducedGraphParent)\n-                                            -> ReducedGraphParent\n+                                    item: &Item,\n+                                    parent: ReducedGraphParent)\n+                                    -> ReducedGraphParent\n     {\n         let ident = item.ident;\n         let sp = item.span;\n-        let is_public = item.vis == ast::public;\n+        let is_public = item.vis == ast::Public;\n \n         match item.node {\n-            item_mod(..) => {\n+            ItemMod(..) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -1160,16 +1158,16 @@ impl Resolver {\n                                             Some(def_id),\n                                             NormalModuleKind,\n                                             false,\n-                                            item.vis == ast::public,\n+                                            item.vis == ast::Public,\n                                             sp);\n \n                 ModuleReducedGraphParent(name_bindings.get_module())\n             }\n \n-            item_foreign_mod(..) => parent,\n+            ItemForeignMod(..) => parent,\n \n             // These items live in the value namespace.\n-            item_static(_, m, _) => {\n+            ItemStatic(_, m, _) => {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == ast::MutMutable;\n@@ -1178,7 +1176,7 @@ impl Resolver {\n                     (DefStatic(local_def(item.id), mutbl), sp, is_public);\n                 parent\n             }\n-            item_fn(_, purity, _, _, _) => {\n+            ItemFn(_, purity, _, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n@@ -1188,7 +1186,7 @@ impl Resolver {\n             }\n \n             // These items live in the type namespace.\n-            item_ty(..) => {\n+            ItemTy(..) => {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1197,7 +1195,7 @@ impl Resolver {\n                 parent\n             }\n \n-            item_enum(ref enum_definition, _) => {\n+            ItemEnum(ref enum_definition, _) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1215,7 +1213,7 @@ impl Resolver {\n             }\n \n             // These items live in both the type and value namespaces.\n-            item_struct(struct_def, _) => {\n+            ItemStruct(struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n                 let (forbid, ctor_id) = match struct_def.ctor_id {\n                     Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n@@ -1241,7 +1239,7 @@ impl Resolver {\n                 new_parent\n             }\n \n-            item_impl(_, None, ty, ref methods) => {\n+            ItemImpl(_, None, ty, ref methods) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1252,7 +1250,7 @@ impl Resolver {\n \n                 // Create the module and add all methods.\n                 match ty.node {\n-                    ty_path(ref path, _, _) if path.segments.len() == 1 => {\n+                    TyPath(ref path, _, _) if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let existing_parent_opt = {\n@@ -1305,7 +1303,7 @@ impl Resolver {\n                                                ForbidDuplicateValues,\n                                                method.span);\n                             let def = match method.explicit_self.node {\n-                                sty_static => {\n+                                SelfStatic => {\n                                     // Static methods become\n                                     // `def_static_method`s.\n                                     DefStaticMethod(local_def(method.id),\n@@ -1320,7 +1318,7 @@ impl Resolver {\n                                 }\n                             };\n \n-                            let is_public = method.vis == ast::public;\n+                            let is_public = method.vis == ast::Public;\n                             method_name_bindings.define_value(def,\n                                                               method.span,\n                                                               is_public);\n@@ -1332,9 +1330,9 @@ impl Resolver {\n                 parent\n             }\n \n-            item_impl(_, Some(_), _, _) => parent,\n+            ItemImpl(_, Some(_), _, _) => parent,\n \n-            item_trait(_, _, ref methods) => {\n+            ItemTrait(_, _, ref methods) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1344,7 +1342,7 @@ impl Resolver {\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n                                             false,\n-                                            item.vis == ast::public,\n+                                            item.vis == ast::Public,\n                                             sp);\n                 let module_parent = ModuleReducedGraphParent(name_bindings.\n                                                              get_module());\n@@ -1358,7 +1356,7 @@ impl Resolver {\n \n                     // Add it as a name in the trait module.\n                     let def = match ty_m.explicit_self.node {\n-                        sty_static => {\n+                        SelfStatic => {\n                             // Static methods become `def_static_method`s.\n                             DefStaticMethod(local_def(ty_m.id),\n                                               FromTrait(local_def(item.id)),\n@@ -1380,7 +1378,7 @@ impl Resolver {\n \n                     // Add it to the trait info if not static.\n                     match ty_m.explicit_self.node {\n-                        sty_static => {}\n+                        SelfStatic => {}\n                         _ => {\n                             method_names.insert(ident.name, ());\n                         }\n@@ -1403,7 +1401,7 @@ impl Resolver {\n                 new_parent\n             }\n \n-            item_mac(..) => {\n+            ItemMac(..) => {\n                 fail!(\"item macros unimplemented\")\n             }\n         }\n@@ -1412,25 +1410,25 @@ impl Resolver {\n     // Constructs the reduced graph for one variant. Variants exist in the\n     // type and/or value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n-                                       variant: &variant,\n+                                       variant: &Variant,\n                                        item_id: DefId,\n                                        parent: ReducedGraphParent,\n                                        parent_public: bool) {\n         let ident = variant.node.name;\n         // XXX: this is unfortunate to have to do this privacy calculation\n         //      here. This should be living in middle::privacy, but it's\n         //      necessary to keep around in some form becaues of glob imports...\n-        let is_public = parent_public && variant.node.vis != ast::private;\n+        let is_public = parent_public && variant.node.vis != ast::Private;\n \n         match variant.node.kind {\n-            tuple_variant_kind(_) => {\n+            TupleVariantKind(_) => {\n                 let (child, _) = self.add_child(ident, parent, ForbidDuplicateValues,\n                                                 variant.span);\n                 child.define_value(DefVariant(item_id,\n                                               local_def(variant.node.id), false),\n                                    variant.span, is_public);\n             }\n-            struct_variant_kind(_) => {\n+            StructVariantKind(_) => {\n                 let (child, _) = self.add_child(ident, parent, ForbidDuplicateTypesAndValues,\n                                                 variant.span);\n                 child.define_type(DefVariant(item_id,\n@@ -1443,19 +1441,18 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n     /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self,\n-                                             view_item: &view_item,\n-                                             parent: ReducedGraphParent) {\n+    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem,\n+                                         parent: ReducedGraphParent) {\n         match view_item.node {\n-            view_item_use(ref view_paths) => {\n+            ViewItemUse(ref view_paths) => {\n                 for view_path in view_paths.iter() {\n                     // Extract and intern the module part of the path. For\n                     // globs and lists, the path is found directly in the AST;\n                     // for simple paths we have to munge the path a little.\n \n                     let mut module_path = ~[];\n                     match view_path.node {\n-                        view_path_simple(_, ref full_path, _) => {\n+                        ViewPathSimple(_, ref full_path, _) => {\n                             let path_len = full_path.segments.len();\n                             assert!(path_len != 0);\n \n@@ -1468,8 +1465,8 @@ impl Resolver {\n                             }\n                         }\n \n-                        view_path_glob(ref module_ident_path, _) |\n-                        view_path_list(ref module_ident_path, _, _) => {\n+                        ViewPathGlob(ref module_ident_path, _) |\n+                        ViewPathList(ref module_ident_path, _, _) => {\n                             for segment in module_ident_path.segments.iter() {\n                                 module_path.push(segment.identifier)\n                             }\n@@ -1478,9 +1475,9 @@ impl Resolver {\n \n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n-                    let is_public = view_item.vis == ast::public;\n+                    let is_public = view_item.vis == ast::Public;\n                     match view_path.node {\n-                        view_path_simple(binding, ref full_path, id) => {\n+                        ViewPathSimple(binding, ref full_path, id) => {\n                             let source_ident =\n                                 full_path.segments.last().identifier;\n                             let subclass = @SingleImport(binding,\n@@ -1492,7 +1489,7 @@ impl Resolver {\n                                                         id,\n                                                         is_public);\n                         }\n-                        view_path_list(_, ref source_idents, _) => {\n+                        ViewPathList(_, ref source_idents, _) => {\n                             for source_ident in source_idents.iter() {\n                                 let name = source_ident.node.name;\n                                 let subclass = @SingleImport(name, name);\n@@ -1505,7 +1502,7 @@ impl Resolver {\n                                     is_public);\n                             }\n                         }\n-                        view_path_glob(_, id) => {\n+                        ViewPathGlob(_, id) => {\n                             self.build_import_directive(module_,\n                                                         module_path,\n                                                         @GlobImport,\n@@ -1517,7 +1514,7 @@ impl Resolver {\n                 }\n             }\n \n-            view_item_extern_mod(name, _, node_id) => {\n+            ViewItemExternMod(name, _, node_id) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 match self.session.cstore.find_extern_mod_stmt_cnum(node_id) {\n                     Some(crate_id) => {\n@@ -1550,19 +1547,19 @@ impl Resolver {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self,\n-                                            foreign_item: &foreign_item,\n+                                            foreign_item: &ForeignItem,\n                                             parent: ReducedGraphParent,\n                                             f: |&mut Resolver,\n                                                 ReducedGraphParent|) {\n         let name = foreign_item.ident;\n-        let is_public = foreign_item.vis == ast::public;\n+        let is_public = foreign_item.vis == ast::Public;\n         let (name_bindings, new_parent) =\n             self.add_child(name, parent, ForbidDuplicateValues,\n                            foreign_item.span);\n \n         match foreign_item.node {\n-            foreign_item_fn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), unsafe_fn);\n+            ForeignItemFn(_, ref generics) => {\n+                let def = DefFn(local_def(foreign_item.id), UnsafeFn);\n                 name_bindings.define_value(def, foreign_item.span, is_public);\n \n                 self.with_type_parameter_rib(\n@@ -1572,7 +1569,7 @@ impl Resolver {\n                                       NormalRibKind),\n                     |this| f(this, new_parent));\n             }\n-            foreign_item_static(_, m) => {\n+            ForeignItemStatic(_, m) => {\n                 let def = DefStatic(local_def(foreign_item.id), m);\n                 name_bindings.define_value(def, foreign_item.span, is_public);\n \n@@ -1613,15 +1610,15 @@ impl Resolver {\n \n     fn handle_external_def(&mut self,\n                            def: Def,\n-                           vis: visibility,\n+                           vis: Visibility,\n                            child_name_bindings: @NameBindings,\n                            final_ident: &str,\n                            ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         debug!(\"(building reduced graph for \\\n                 external crate) building external def, priv {:?}\",\n                vis);\n-        let is_public = vis == ast::public;\n+        let is_public = vis == ast::Public;\n         let is_exported = is_public && match new_parent {\n             ModuleReducedGraphParent(module) => {\n                 match module.def_id.get() {\n@@ -1669,7 +1666,7 @@ impl Resolver {\n             // We assume the parent is visible, or else we wouldn't have seen\n             // it. Also variants are public-by-default if the parent was also\n             // public.\n-            let is_public = vis != ast::private;\n+            let is_public = vis != ast::Private;\n             if is_struct {\n                 child_name_bindings.define_type(def, DUMMY_SP, is_public);\n                 self.structs.insert(variant_id);\n@@ -1703,7 +1700,7 @@ impl Resolver {\n                          self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n-                  if explicit_self != sty_static {\n+                  if explicit_self != SelfStatic {\n                       interned_method_names.insert(method_name.name);\n                   }\n                   if is_exported {\n@@ -1767,7 +1764,7 @@ impl Resolver {\n                                                   root: @Module,\n                                                   def_like: DefLike,\n                                                   ident: Ident,\n-                                                  visibility: visibility) {\n+                                                  visibility: Visibility) {\n         match def_like {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n@@ -1881,7 +1878,7 @@ impl Resolver {\n \n                                     method_name_bindings.define_value(\n                                         def, DUMMY_SP,\n-                                        visibility == ast::public);\n+                                        visibility == ast::Public);\n                                 }\n                             }\n \n@@ -3633,15 +3630,15 @@ impl Resolver {\n         visit::walk_crate(self, crate, ());\n     }\n \n-    fn resolve_item(&mut self, item: &item) {\n+    fn resolve_item(&mut self, item: &Item) {\n         debug!(\"(resolving item) resolving {}\",\n                self.session.str_of(item.ident));\n \n         match item.node {\n \n             // enum item: resolve all the variants' discrs,\n             // then resolve the ty params\n-            item_enum(ref enum_def, ref generics) => {\n+            ItemEnum(ref enum_def, ref generics) => {\n                 for variant in (*enum_def).variants.iter() {\n                     for dis_expr in variant.node.disr_expr.iter() {\n                         // resolve the discriminator expr\n@@ -3664,7 +3661,7 @@ impl Resolver {\n                 });\n             }\n \n-            item_ty(_, ref generics) => {\n+            ItemTy(_, ref generics) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                item.id,\n                                                                0,\n@@ -3674,7 +3671,7 @@ impl Resolver {\n                 });\n             }\n \n-            item_impl(ref generics,\n+            ItemImpl(ref generics,\n                       ref implemented_traits,\n                       self_type,\n                       ref methods) => {\n@@ -3685,7 +3682,7 @@ impl Resolver {\n                                             *methods);\n             }\n \n-            item_trait(ref generics, ref traits, ref methods) => {\n+            ItemTrait(ref generics, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib::new(NormalRibKind);\n                 {\n@@ -3719,7 +3716,7 @@ impl Resolver {\n                         // FIXME #4951: Do we need a node ID here?\n \n                         match *method {\n-                          required(ref ty_m) => {\n+                          ast::Required(ref ty_m) => {\n                             this.with_type_parameter_rib\n                                 (HasTypeParameters(&ty_m.generics,\n                                                    item.id,\n@@ -3739,7 +3736,7 @@ impl Resolver {\n                                 this.resolve_type(ty_m.decl.output);\n                             });\n                           }\n-                          provided(m) => {\n+                          ast::Provided(m) => {\n                               this.resolve_method(MethodRibKind(item.id,\n                                                      Provided(m.id)),\n                                                   m,\n@@ -3753,24 +3750,24 @@ impl Resolver {\n                 type_ribs.get().pop();\n             }\n \n-            item_struct(ref struct_def, ref generics) => {\n+            ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n                                     struct_def.fields);\n             }\n \n-            item_mod(ref module_) => {\n+            ItemMod(ref module_) => {\n                 self.with_scope(Some(item.ident), |this| {\n                     this.resolve_module(module_, item.span, item.ident,\n                                         item.id);\n                 });\n             }\n \n-            item_foreign_mod(ref foreign_module) => {\n+            ItemForeignMod(ref foreign_module) => {\n                 self.with_scope(Some(item.ident), |this| {\n                     for foreign_item in foreign_module.items.iter() {\n                         match foreign_item.node {\n-                            foreign_item_fn(_, ref generics) => {\n+                            ForeignItemFn(_, ref generics) => {\n                                 this.with_type_parameter_rib(\n                                     HasTypeParameters(\n                                         generics, foreign_item.id, 0,\n@@ -3779,7 +3776,7 @@ impl Resolver {\n                                                                 *foreign_item,\n                                                                 ()));\n                             }\n-                            foreign_item_static(..) => {\n+                            ForeignItemStatic(..) => {\n                                 visit::walk_foreign_item(this,\n                                                          *foreign_item,\n                                                          ());\n@@ -3789,7 +3786,7 @@ impl Resolver {\n                 });\n             }\n \n-            item_fn(fn_decl, _, _, ref generics, block) => {\n+            ItemFn(fn_decl, _, _, ref generics, block) => {\n                 self.resolve_function(OpaqueFunctionRibKind,\n                                       Some(fn_decl),\n                                       HasTypeParameters\n@@ -3801,15 +3798,15 @@ impl Resolver {\n                                       NoSelfBinding);\n             }\n \n-            item_static(..) => {\n+            ItemStatic(..) => {\n                 self.with_constant_rib(|this| {\n                     visit::walk_item(this, item, ());\n                 });\n             }\n \n-          item_mac(..) => {\n-            fail!(\"item macros unimplemented\")\n-          }\n+            ItemMac(..) => {\n+                fail!(\"item macros unimplemented\")\n+            }\n         }\n     }\n \n@@ -3895,7 +3892,7 @@ impl Resolver {\n \n     fn resolve_function(&mut self,\n                             rib_kind: RibKind,\n-                            optional_declaration: Option<P<fn_decl>>,\n+                            optional_declaration: Option<P<FnDecl>>,\n                             type_parameters: TypeParameters,\n                             block: P<Block>,\n                             self_binding: SelfBinding) {\n@@ -3932,7 +3929,7 @@ impl Resolver {\n                 }\n                 HasSelfBinding(self_node_id, explicit_self) => {\n                     let mutable = match explicit_self.node {\n-                        sty_uniq(m) | sty_value(m) if m == MutMutable => true,\n+                        SelfUniq(m) | SelfValue(m) if m == MutMutable => true,\n                         _ => false\n                     };\n                     let def_like = DlDef(DefSelf(self_node_id, mutable));\n@@ -3996,7 +3993,7 @@ impl Resolver {\n \n     fn resolve_trait_reference(&mut self,\n                                    id: NodeId,\n-                                   trait_reference: &trait_ref,\n+                                   trait_reference: &TraitRef,\n                                    reference_type: TraitReferenceType) {\n         match self.resolve_path(id, &trait_reference.path, TypeNS, true) {\n             None => {\n@@ -4020,11 +4017,11 @@ impl Resolver {\n     fn resolve_struct(&mut self,\n                           id: NodeId,\n                           generics: &Generics,\n-                          fields: &[struct_field]) {\n-        let mut ident_map: HashMap<ast::Ident, &struct_field> = HashMap::new();\n+                          fields: &[StructField]) {\n+        let mut ident_map: HashMap<ast::Ident, &StructField> = HashMap::new();\n         for field in fields.iter() {\n             match field.node.kind {\n-                named_field(ident, _) => {\n+                NamedField(ident, _) => {\n                     match ident_map.find(&ident) {\n                         Some(&prev_field) => {\n                             let ident_str = self.session.str_of(ident);\n@@ -4062,7 +4059,7 @@ impl Resolver {\n     // to be NormalRibKind?\n     fn resolve_method(&mut self,\n                           rib_kind: RibKind,\n-                          method: @method,\n+                          method: @Method,\n                           outer_type_parameter_count: uint) {\n         let method_generics = &method.generics;\n         let type_parameters =\n@@ -4072,8 +4069,8 @@ impl Resolver {\n                               rib_kind);\n         // we only have self ty if it is a non static method\n         let self_binding = match method.explicit_self.node {\n-          sty_static => { NoSelfBinding }\n-          _ => { HasSelfBinding(method.self_id, method.explicit_self) }\n+            SelfStatic => NoSelfBinding,\n+            _ => HasSelfBinding(method.self_id, method.explicit_self)\n         };\n \n         self.resolve_function(rib_kind,\n@@ -4086,9 +4083,9 @@ impl Resolver {\n     fn resolve_implementation(&mut self,\n                                   id: NodeId,\n                                   generics: &Generics,\n-                                  opt_trait_reference: &Option<trait_ref>,\n+                                  opt_trait_reference: &Option<TraitRef>,\n                                   self_type: &Ty,\n-                                  methods: &[@method]) {\n+                                  methods: &[@Method]) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = generics.ty_params.len();\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4160,14 +4157,11 @@ impl Resolver {\n         });\n     }\n \n-    fn resolve_module(&mut self,\n-                          module_: &_mod,\n-                          _span: Span,\n-                          _name: Ident,\n-                          id: NodeId) {\n+    fn resolve_module(&mut self, module: &Mod, _span: Span,\n+                      _name: Ident, id: NodeId) {\n         // Write the implementations in scope into the module metadata.\n         debug!(\"(resolving module) resolving module ID {}\", id);\n-        visit::walk_mod(self, module_, ());\n+        visit::walk_mod(self, module, ());\n     }\n \n     fn resolve_local(&mut self, local: &Local) {\n@@ -4305,7 +4299,7 @@ impl Resolver {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(ref path, ref bounds, path_id) => {\n+            TyPath(ref path, ref bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4387,7 +4381,7 @@ impl Resolver {\n                 });\n             }\n \n-            ty_closure(c) => {\n+            TyClosure(c) => {\n                 c.bounds.as_ref().map(|bounds| {\n                     for bound in bounds.iter() {\n                         self.resolve_type_parameter_bound(ty.id, bound);\n@@ -5548,28 +5542,28 @@ impl Resolver {\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n-    fn check_for_item_unused_imports(&self, vi: &view_item) {\n+    fn check_for_item_unused_imports(&self, vi: &ViewItem) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if vi.vis == public { return }\n+        if vi.vis == Public { return }\n         if vi.span == DUMMY_SP { return }\n \n         match vi.node {\n-            view_item_extern_mod(..) => {} // ignore\n-            view_item_use(ref path) => {\n+            ViewItemExternMod(..) => {} // ignore\n+            ViewItemUse(ref path) => {\n                 for p in path.iter() {\n                     match p.node {\n-                        view_path_simple(_, _, id) | view_path_glob(_, id) => {\n+                        ViewPathSimple(_, _, id) | ViewPathGlob(_, id) => {\n                             if !self.used_imports.contains(&id) {\n                                 self.session.add_lint(unused_imports,\n                                                       id, p.span,\n                                                       ~\"unused import\");\n                             }\n                         }\n \n-                        view_path_list(_, ref list, _) => {\n+                        ViewPathList(_, ref list, _) => {\n                             for i in list.iter() {\n                                 if !self.used_imports.contains(&i.node.id) {\n                                     self.session.add_lint(unused_imports,"}, {"sha": "b26b47dc1192f464346f4b2547ba7838dd50c712", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -57,21 +57,21 @@ pub fn crate(sess: session::Session, crate: &ast::Crate)\n \n impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     fn visit_item(&mut self,\n-                  item: &ast::item,\n+                  item: &ast::Item,\n                   _: &'a ScopeChain<'a>) {\n         let scope = match item.node {\n-            ast::item_fn(..) | // fn lifetimes get added in visit_fn below\n-            ast::item_mod(..) |\n-            ast::item_mac(..) |\n-            ast::item_foreign_mod(..) |\n-            ast::item_static(..) => {\n+            ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n+            ast::ItemMod(..) |\n+            ast::ItemMac(..) |\n+            ast::ItemForeignMod(..) |\n+            ast::ItemStatic(..) => {\n                 RootScope\n             }\n-            ast::item_ty(_, ref generics) |\n-            ast::item_enum(_, ref generics) |\n-            ast::item_struct(_, ref generics) |\n-            ast::item_impl(ref generics, _, _, _) |\n-            ast::item_trait(ref generics, _, _) => {\n+            ast::ItemTy(_, ref generics) |\n+            ast::ItemEnum(_, ref generics) |\n+            ast::ItemStruct(_, ref generics) |\n+            ast::ItemImpl(ref generics, _, _, _) |\n+            ast::ItemTrait(ref generics, _, _) => {\n                 self.check_lifetime_names(&generics.lifetimes);\n                 ItemScope(&generics.lifetimes)\n             }\n@@ -81,34 +81,29 @@ impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n         debug!(\"exiting scope {:?}\", scope);\n     }\n \n-    fn visit_fn(&mut self,\n-                fk: &visit::fn_kind,\n-                fd: &ast::fn_decl,\n-                b: &ast::Block,\n-                s: Span,\n-                n: ast::NodeId,\n+    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n+                b: &ast::Block, s: Span, n: ast::NodeId,\n                 scope: &'a ScopeChain<'a>) {\n         match *fk {\n-            visit::fk_item_fn(_, generics, _, _) |\n-            visit::fk_method(_, generics, _) => {\n+            visit::FkItemFn(_, generics, _, _) |\n+            visit::FkMethod(_, generics, _) => {\n                 let scope1 = FnScope(n, &generics.lifetimes, scope);\n                 self.check_lifetime_names(&generics.lifetimes);\n                 debug!(\"pushing fn scope id={} due to item/method\", n);\n                 visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n                 debug!(\"popping fn scope id={} due to item/method\", n);\n             }\n-            visit::fk_fn_block(..) => {\n+            visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s, n, scope);\n             }\n         }\n     }\n \n-    fn visit_ty(&mut self,\n-                ty: &ast::Ty,\n+    fn visit_ty(&mut self, ty: &ast::Ty,\n                 scope: &'a ScopeChain<'a>) {\n         match ty.node {\n-            ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, .. }) |\n-            ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, .. }) => {\n+            ast::TyClosure(@ast::ClosureTy { lifetimes: ref lifetimes, .. }) |\n+            ast::TyBareFn(@ast::BareFnTy { lifetimes: ref lifetimes, .. }) => {\n                 let scope1 = FnScope(ty.id, lifetimes, scope);\n                 self.check_lifetime_names(lifetimes);\n                 debug!(\"pushing fn scope id={} due to type\", ty.id);"}, {"sha": "36a92e55e7b757b9b91f70257a60865b736137c7", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -303,11 +303,11 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     static choose_shortest: &'static[IntType] = &[\n-        attr::UnsignedInt(ast::ty_u8), attr::SignedInt(ast::ty_i8),\n-        attr::UnsignedInt(ast::ty_u16), attr::SignedInt(ast::ty_i16),\n-        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+        attr::UnsignedInt(ast::TyU8), attr::SignedInt(ast::TyI8),\n+        attr::UnsignedInt(ast::TyU16), attr::SignedInt(ast::TyI16),\n+        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n     static at_least_32: &'static[IntType] = &[\n-        attr::UnsignedInt(ast::ty_u32), attr::SignedInt(ast::ty_i32)];\n+        attr::UnsignedInt(ast::TyU32), attr::SignedInt(ast::TyI32)];\n \n     let attempts;\n     match hint {\n@@ -336,7 +336,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n     }\n-    return attr::UnsignedInt(ast::ty_u64);\n+    return attr::UnsignedInt(ast::TyU64);\n }\n \n pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {"}, {"sha": "ffcbd59c9e03ac1ba4a7167c5087731b8d8f9308", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -27,7 +27,7 @@ use middle::trans::type_::Type;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n-pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::inline_asm)\n+pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n                         -> &'a Block<'a> {\n     let mut bcx = bcx;\n     let mut constraints = ~[];\n@@ -98,8 +98,8 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::inline_asm)\n     };\n \n     let dialect = match ia.dialect {\n-        ast::asm_att   => lib::llvm::AD_ATT,\n-        ast::asm_intel => lib::llvm::AD_Intel\n+        ast::AsmAtt   => lib::llvm::AD_ATT,\n+        ast::AsmIntel => lib::llvm::AD_Intel\n     };\n \n     let r = ia.asm.with_c_str(|a| {"}, {"sha": "aaa8d071aff5de1d05194cd0ca5bd2b64a6f91e9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -77,7 +77,7 @@ use std::libc::c_uint;\n use std::vec;\n use std::local_data;\n use syntax::ast::Name;\n-use syntax::ast_map::{path, path_elt_to_str, path_name, path_pretty_name};\n+use syntax::ast_map::{PathName, PathPrettyName, path_elem_to_str};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -1745,7 +1745,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n-                        path: path,\n+                        path: ast_map::Path,\n                         llfndecl: ValueRef,\n                         id: ast::NodeId,\n                         output_type: ty::t,\n@@ -1841,7 +1841,7 @@ pub fn init_function<'a>(\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n-                   path: path,\n+                   path: ast_map::Path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n                    sp: Option<Span>)\n@@ -1867,7 +1867,7 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: &FunctionContext,\n                                  self_arg: self_arg,\n-                                 args: &[ast::arg])\n+                                 args: &[ast::Arg])\n                                  -> ~[ValueRef] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n@@ -1892,7 +1892,7 @@ pub fn create_llargs_for_fn_args(cx: &FunctionContext,\n pub fn copy_args_to_allocas<'a>(\n                             fcx: &FunctionContext<'a>,\n                             bcx: &'a Block<'a>,\n-                            args: &[ast::arg],\n+                            args: &[ast::Arg],\n                             raw_llargs: &[ValueRef],\n                             arg_tys: &[ty::t])\n                             -> &'a Block<'a> {\n@@ -2007,8 +2007,8 @@ pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n // If the function closes over its environment a closure will be\n // returned.\n pub fn trans_closure(ccx: @CrateContext,\n-                     path: path,\n-                     decl: &ast::fn_decl,\n+                     path: ast_map::Path,\n+                     decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n                      self_arg: self_arg,\n@@ -2085,8 +2085,8 @@ pub fn trans_closure(ccx: @CrateContext,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n pub fn trans_fn(ccx: @CrateContext,\n-                path: path,\n-                decl: &ast::fn_decl,\n+                path: ast_map::Path,\n+                decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n                 self_arg: self_arg,\n@@ -2115,7 +2115,7 @@ pub fn trans_fn(ccx: @CrateContext,\n }\n \n fn insert_synthetic_type_entries(bcx: &Block,\n-                                 fn_args: &[ast::arg],\n+                                 fn_args: &[ast::Arg],\n                                  arg_tys: &[ty::t]) {\n     /*!\n      * For tuple-like structs and enum-variants, we generate\n@@ -2144,8 +2144,8 @@ fn insert_synthetic_type_entries(bcx: &Block,\n \n pub fn trans_enum_variant(ccx: @CrateContext,\n                           _enum_id: ast::NodeId,\n-                          variant: &ast::variant,\n-                          args: &[ast::variant_arg],\n+                          variant: &ast::Variant,\n+                          args: &[ast::VariantArg],\n                           disr: ty::Disr,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n@@ -2161,7 +2161,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n }\n \n pub fn trans_tuple_struct(ccx: @CrateContext,\n-                          fields: &[ast::struct_field],\n+                          fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n@@ -2181,12 +2181,12 @@ trait IdAndTy {\n     fn ty(&self) -> ast::P<ast::Ty>;\n }\n \n-impl IdAndTy for ast::variant_arg {\n+impl IdAndTy for ast::VariantArg {\n     fn id(&self) -> ast::NodeId { self.id }\n     fn ty(&self) -> ast::P<ast::Ty> { self.ty }\n }\n \n-impl IdAndTy for ast::struct_field {\n+impl IdAndTy for ast::StructField {\n     fn id(&self) -> ast::NodeId { self.node.id }\n     fn ty(&self) -> ast::P<ast::Ty> { self.node.ty }\n }\n@@ -2201,7 +2201,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n {\n     // Translate variant arguments to function arguments.\n     let fn_args = args.map(|varg| {\n-        ast::arg {\n+        ast::Arg {\n             ty: varg.ty(),\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n@@ -2272,23 +2272,23 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     finish_fn(&fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n-            ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n+            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let llfn = get_item_val(ccx, variant.node.id);\n                 trans_enum_variant(ccx, id, variant, *args,\n                                    disr_val, None, llfn);\n             }\n-            ast::tuple_variant_kind(_) => {\n+            ast::TupleVariantKind(_) => {\n                 // Nothing to do.\n             }\n-            ast::struct_variant_kind(struct_def) => {\n+            ast::StructVariantKind(struct_def) => {\n                 trans_struct_def(ccx, struct_def);\n             }\n         }\n@@ -2300,29 +2300,28 @@ pub struct TransItemVisitor {\n }\n \n impl Visitor<()> for TransItemVisitor {\n-    fn visit_item(&mut self, i: &ast::item, _:()) {\n+    fn visit_item(&mut self, i: &ast::Item, _:()) {\n         trans_item(self.ccx, i);\n     }\n }\n \n-pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     let path = {\n         let items = ccx.tcx.items.borrow();\n         match items.get().get_copy(&item.id) {\n-            ast_map::node_item(_, p) => p,\n+            ast_map::NodeItem(_, p) => p,\n             // tjc: ?\n             _ => fail!(\"trans_item\"),\n         }\n     };\n     match item.node {\n-      ast::item_fn(decl, purity, _abis, ref generics, body) => {\n-        if purity == ast::extern_fn  {\n+      ast::ItemFn(decl, purity, _abis, ref generics, body) => {\n+        if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n                 ccx,\n-                &vec::append((*path).clone(),\n-                             [path_name(item.ident)]),\n+                &vec::append_one((*path).clone(), PathName(item.ident)),\n                 decl,\n                 body,\n                 item.attrs,\n@@ -2331,7 +2330,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     vec::append((*path).clone(), [path_name(item.ident)]),\n+                     vec::append_one((*path).clone(), PathName(item.ident)),\n                      decl,\n                      body,\n                      llfndecl,\n@@ -2346,25 +2345,25 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n             v.visit_block(body, ());\n         }\n       }\n-      ast::item_impl(ref generics, _, _, ref ms) => {\n+      ast::ItemImpl(ref generics, _, _, ref ms) => {\n         meth::trans_impl(ccx,\n                          (*path).clone(),\n                          item.ident,\n                          *ms,\n                          generics,\n                          item.id);\n       }\n-      ast::item_mod(ref m) => {\n+      ast::ItemMod(ref m) => {\n         trans_mod(ccx, m);\n       }\n-      ast::item_enum(ref enum_definition, ref generics) => {\n+      ast::ItemEnum(ref enum_definition, ref generics) => {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n             let mut i = 0;\n             trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n         }\n       }\n-      ast::item_static(_, m, expr) => {\n+      ast::ItemStatic(_, m, expr) => {\n           consts::trans_const(ccx, m, item.id);\n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n@@ -2384,15 +2383,15 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n               }\n           }\n       },\n-      ast::item_foreign_mod(ref foreign_mod) => {\n+      ast::ItemForeignMod(ref foreign_mod) => {\n         foreign::trans_foreign_mod(ccx, foreign_mod);\n       }\n-      ast::item_struct(struct_def, ref generics) => {\n+      ast::ItemStruct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n             trans_struct_def(ccx, struct_def);\n         }\n       }\n-      ast::item_trait(..) => {\n+      ast::ItemTrait(..) => {\n         // Inside of this trait definition, we won't be actually translating any\n         // functions, but the trait still needs to be walked. Otherwise default\n         // methods with items will not get translated and will cause ICE's when\n@@ -2404,7 +2403,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n+pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::StructDef) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -2423,7 +2422,7 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n         trans_item(ccx, *item);\n@@ -2580,18 +2579,19 @@ pub fn fill_fn_pair(bcx: &Block,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n+pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> ast_map::Path {\n     ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n \n-fn exported_name(ccx: &CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+fn exported_name(ccx: &CrateContext, path: ast_map::Path,\n+                 ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.to_owned(),\n \n         // Don't mangle\n         _ if attr::contains_name(attrs, \"no_mangle\")\n-            => path_elt_to_str(*path.last(), token::get_ident_interner()),\n+            => path_elem_to_str(*path.last(), token::get_ident_interner()),\n \n         // Usual name mangling\n         _ => mangle_exported_name(ccx, path, ty)\n@@ -2615,15 +2615,15 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                 items.get().get_copy(&id)\n             };\n             let val = match item {\n-                ast_map::node_item(i, pth) => {\n+                ast_map::NodeItem(i, pth) => {\n \n-                    let elt = path_pretty_name(i.ident, id as u64);\n+                    let elt = PathPrettyName(i.ident, id as u64);\n                     let my_path = vec::append_one((*pth).clone(), elt);\n                     let ty = ty::node_id_to_type(ccx.tcx, i.id);\n                     let sym = exported_name(ccx, my_path, ty, i.attrs);\n \n                     let v = match i.node {\n-                        ast::item_static(_, _, expr) => {\n+                        ast::ItemStatic(_, _, expr) => {\n                             // If this static came from an external crate, then\n                             // we need to get the symbol from csearch instead of\n                             // using the current crate's name/version\n@@ -2720,8 +2720,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             }\n                         }\n \n-                        ast::item_fn(_, purity, _, _, _) => {\n-                            let llfn = if purity != ast::extern_fn {\n+                        ast::ItemFn(_, purity, _, _, _) => {\n+                            let llfn = if purity != ast::ExternFn {\n                                 register_fn(ccx, i.span, sym, i.id, ty)\n                             } else {\n                                 foreign::register_rust_fn_with_foreign_abi(ccx,\n@@ -2748,33 +2748,33 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     v\n                 }\n \n-                ast_map::node_trait_method(trait_method, _, pth) => {\n-                    debug!(\"get_item_val(): processing a node_trait_method\");\n+                ast_map::NodeTraitMethod(trait_method, _, pth) => {\n+                    debug!(\"get_item_val(): processing a NodeTraitMethod\");\n                     match *trait_method {\n-                        ast::required(_) => {\n+                        ast::Required(_) => {\n                             ccx.sess.bug(\"unexpected variant: required trait method in \\\n                                          get_item_val()\");\n                         }\n-                        ast::provided(m) => {\n+                        ast::Provided(m) => {\n                             register_method(ccx, id, pth, m)\n                         }\n                     }\n                 }\n \n-                ast_map::node_method(m, _, pth) => {\n+                ast_map::NodeMethod(m, _, pth) => {\n                     register_method(ccx, id, pth, m)\n                 }\n \n-                ast_map::node_foreign_item(ni, abis, _, pth) => {\n+                ast_map::NodeForeignItem(ni, abis, _, pth) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n                     foreign = true;\n \n                     match ni.node {\n-                        ast::foreign_item_fn(..) => {\n-                            let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n+                        ast::ForeignItemFn(..) => {\n+                            let path = vec::append_one((*pth).clone(), PathName(ni.ident));\n                             foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n                         }\n-                        ast::foreign_item_static(..) => {\n+                        ast::ForeignItemStatic(..) => {\n                             // Treat the crate map static specially in order to\n                             // a weak-linkage-like functionality where it's\n                             // dynamically resolved at runtime. If we're\n@@ -2813,33 +2813,33 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast_map::node_variant(ref v, enm, pth) => {\n+                ast_map::NodeVariant(ref v, enm, pth) => {\n                     let llfn;\n                     match v.node.kind {\n-                        ast::tuple_variant_kind(ref args) => {\n+                        ast::TupleVariantKind(ref args) => {\n                             assert!(args.len() != 0u);\n                             let pth = vec::append((*pth).clone(),\n-                                                  [path_name(enm.ident),\n-                                                   path_name((*v).node.name)]);\n+                                                  [PathName(enm.ident),\n+                                                   PathName((*v).node.name)]);\n                             let ty = ty::node_id_to_type(ccx.tcx, id);\n                             let sym = exported_name(ccx, pth, ty, enm.attrs);\n \n                             llfn = match enm.node {\n-                                ast::item_enum(_, _) => {\n+                                ast::ItemEnum(_, _) => {\n                                     register_fn(ccx, (*v).span, sym, id, ty)\n                                 }\n-                                _ => fail!(\"node_variant, shouldn't happen\")\n+                                _ => fail!(\"NodeVariant, shouldn't happen\")\n                             };\n                         }\n-                        ast::struct_variant_kind(_) => {\n+                        ast::StructVariantKind(_) => {\n                             fail!(\"struct variant kind unexpected in get_item_val\")\n                         }\n                     }\n                     set_inline_hint(llfn);\n                     llfn\n                 }\n \n-                ast_map::node_struct_ctor(struct_def, struct_item, struct_path) => {\n+                ast_map::NodeStructCtor(struct_def, struct_item, struct_path) => {\n                     // Only register the constructor if this is a tuple-like struct.\n                     match struct_def.ctor_id {\n                         None => {\n@@ -2883,12 +2883,12 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n pub fn register_method(ccx: @CrateContext,\n                        id: ast::NodeId,\n-                       path: @ast_map::path,\n-                       m: @ast::method) -> ValueRef {\n+                       path: @ast_map::Path,\n+                       m: @ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n     let mut path = (*path).clone();\n-    path.push(path_pretty_name(m.ident, token::gensym(\"meth\") as u64));\n+    path.push(PathPrettyName(m.ident, token::gensym(\"meth\") as u64));\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n \n@@ -3138,7 +3138,7 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n \n pub fn symname(sess: session::Session, name: &str,\n                hash: &str, vers: &str) -> ~str {\n-    let elt = path_name(sess.ident_of(name));\n+    let elt = PathName(sess.ident_of(name));\n     link::exported_name(sess, ~[elt], hash, vers)\n }\n "}, {"sha": "795ccb200a0ab726cac45e026c7886298d35f1ec", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -370,7 +370,7 @@ pub fn trans_fn_ref_with_vtables(\n                 || format!(\"local item should be in ast map\"));\n \n             match *map_node {\n-                ast_map::node_foreign_item(_, abis, _, _) => {\n+                ast_map::NodeForeignItem(_, abis, _, _) => {\n                     must_monomorphise = abis.is_intrinsic()\n                 }\n                 _ => {"}, {"sha": "5a9d7b0a283d03a68671e85739f4dee45e77e703", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -26,7 +26,7 @@ use util::ppaux::ty_to_str;\n \n use std::vec;\n use syntax::ast;\n-use syntax::ast_map::path_name;\n+use syntax::ast_map::PathName;\n use syntax::ast_util;\n use syntax::parse::token::special_idents;\n \n@@ -358,7 +358,7 @@ pub fn load_environment(fcx: &FunctionContext,\n pub fn trans_expr_fn<'a>(\n                      bcx: &'a Block<'a>,\n                      sigil: ast::Sigil,\n-                     decl: &ast::fn_decl,\n+                     decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      outer_id: ast::NodeId,\n                      user_id: ast::NodeId,\n@@ -400,7 +400,7 @@ pub fn trans_expr_fn<'a>(\n     };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),\n-                                   path_name(special_idents::anon));\n+                                   PathName(special_idents::anon));\n     // XXX: Bad copy.\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),"}, {"sha": "dab701a0e1f922d80c94d9b54ecffbac4b0ab8a4", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -39,7 +39,7 @@ use std::hashmap::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::vec;\n use syntax::ast::{Name, Ident};\n-use syntax::ast_map::{path, path_elt, path_pretty_name};\n+use syntax::ast_map::{Path, PathElem, PathPrettyName};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n@@ -79,10 +79,10 @@ pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn gensym_name(name: &str) -> (Ident, path_elt) {\n+pub fn gensym_name(name: &str) -> (Ident, PathElem) {\n     let name = token::gensym(name);\n     let ident = Ident::new(name);\n-    (ident, path_pretty_name(ident, name as u64))\n+    (ident, PathPrettyName(ident, name as u64))\n }\n \n pub struct tydesc_info {\n@@ -257,7 +257,7 @@ pub struct FunctionContext<'a> {\n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n     span: Option<Span>,\n-    path: path,\n+    path: Path,\n \n     // The arena that blocks are allocated from.\n     block_arena: TypedArena<Block<'a>>,\n@@ -1078,13 +1078,13 @@ pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n+pub fn path_str(sess: session::Session, p: &[PathElem]) -> ~str {\n     let mut r = ~\"\";\n     let mut first = true;\n     for e in p.iter() {\n         match *e {\n-            ast_map::path_name(s) | ast_map::path_mod(s) |\n-            ast_map::path_pretty_name(s, _) => {\n+            ast_map::PathName(s) | ast_map::PathMod(s) |\n+            ast_map::PathPrettyName(s, _) => {\n                 if first {\n                     first = false\n                 } else {"}, {"sha": "8cde68225c9408638d19b3a756dd59268d4f8558", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -35,44 +35,44 @@ use std::libc::c_uint;\n use std::vec;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::lit)\n+pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n-      ast::lit_char(i) => C_integral(Type::char(), i as u64, false),\n-      ast::lit_int(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n-      ast::lit_uint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n-      ast::lit_int_unsuffixed(i) => {\n-        let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n-        match ty::get(lit_int_ty).sty {\n-          ty::ty_int(t) => {\n-            C_integral(Type::int_from_ty(cx, t), i as u64, true)\n-          }\n-          ty::ty_uint(t) => {\n-            C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n-          }\n-          _ => cx.sess.span_bug(lit.span,\n-                   format!(\"integer literal has type {} (expected int or uint)\",\n-                        ty_to_str(cx.tcx, lit_int_ty)))\n+        ast::LitChar(i) => C_integral(Type::char(), i as u64, false),\n+        ast::LitInt(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n+        ast::LitUint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n+        ast::LitIntUnsuffixed(i) => {\n+            let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            match ty::get(lit_int_ty).sty {\n+                ty::ty_int(t) => {\n+                    C_integral(Type::int_from_ty(cx, t), i as u64, true)\n+                }\n+                ty::ty_uint(t) => {\n+                    C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n+                }\n+                _ => cx.sess.span_bug(lit.span,\n+                        format!(\"integer literal has type {} (expected int or uint)\",\n+                                ty_to_str(cx.tcx, lit_int_ty)))\n+            }\n         }\n-      }\n-      ast::lit_float(fs, t) => C_floating(fs, Type::float_from_ty(t)),\n-      ast::lit_float_unsuffixed(fs) => {\n-        let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n-        match ty::get(lit_float_ty).sty {\n-          ty::ty_float(t) => {\n-            C_floating(fs, Type::float_from_ty(t))\n-          }\n-          _ => {\n-            cx.sess.span_bug(lit.span,\n-                             \"floating point literal doesn't have the right type\");\n-          }\n+        ast::LitFloat(fs, t) => C_floating(fs, Type::float_from_ty(t)),\n+        ast::LitFloatUnsuffixed(fs) => {\n+            let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            match ty::get(lit_float_ty).sty {\n+                ty::ty_float(t) => {\n+                    C_floating(fs, Type::float_from_ty(t))\n+                }\n+                _ => {\n+                    cx.sess.span_bug(lit.span,\n+                        \"floating point literal doesn't have the right type\");\n+                }\n+            }\n         }\n-      }\n-      ast::lit_bool(b) => C_bool(b),\n-      ast::lit_nil => C_nil(),\n-      ast::lit_str(s, _) => C_estr_slice(cx, s),\n-      ast::lit_binary(data) => C_binary_slice(cx, data),\n+        ast::LitBool(b) => C_bool(b),\n+        ast::LitNil => C_nil(),\n+        ast::LitStr(s, _) => C_estr_slice(cx, s),\n+        ast::LitBinary(data) => C_binary_slice(cx, data),\n     }\n }\n \n@@ -172,8 +172,8 @@ pub fn get_const_val(cx: @CrateContext,\n         };\n \n         match opt_item {\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_static(_, ast::MutImmutable, _), ..\n+            ast_map::NodeItem(@ast::Item {\n+                node: ast::ItemStatic(_, ast::MutImmutable, _), ..\n             }, _) => {\n                 trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n@@ -551,8 +551,8 @@ fn const_expr_unadjusted(cx: @CrateContext,\n             match sub.node {\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n-                  ast::lit_str(..) => { const_expr(cx, sub) }\n-                  _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n+                    ast::LitStr(..) => { const_expr(cx, sub) }\n+                    _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {"}, {"sha": "527308be0fffa8230fcd43e268318deff638c71e", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -62,7 +62,7 @@ pub struct CrateContext {\n      // came from)\n      external_srcs: RefCell<HashMap<ast::NodeId, ast::DefId>>,\n      // A set of static items which cannot be inlined into other crates. This\n-     // will pevent in ii_item() structures from being encoded into the metadata\n+     // will pevent in IIItem() structures from being encoded into the metadata\n      // that is generated\n      non_inlineable_statics: RefCell<HashSet<ast::NodeId>>,\n      // Cache instances of monomorphized functions"}, {"sha": "3197084f73c626d720328216474cbba3bcf84f67", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -330,8 +330,8 @@ pub fn create_captured_var_metadata(bcx: &Block,\n         None => {\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n         }\n-        Some(ast_map::node_local(ident, _)) => ident,\n-        Some(ast_map::node_arg(@ast::Pat { node: ast::PatIdent(_, ref path, _), .. })) => {\n+        Some(ast_map::NodeLocal(ident, _)) => ident,\n+        Some(ast_map::NodeArg(@ast::Pat { node: ast::PatIdent(_, ref path, _), .. })) => {\n             ast_util::path_to_ident(path)\n         }\n         _ => {\n@@ -429,12 +429,12 @@ pub fn create_self_argument_metadata(bcx: &Block,\n         items.get().get_copy(&bcx.fcx.id)\n     };\n     let span = match fnitem {\n-        ast_map::node_method(@ast::method { explicit_self: explicit_self, .. }, _, _) => {\n+        ast_map::NodeMethod(@ast::Method { explicit_self: explicit_self, .. }, _, _) => {\n             explicit_self.span\n         }\n-        ast_map::node_trait_method(\n-            @ast::provided(\n-                @ast::method {\n+        ast_map::NodeTraitMethod(\n+            @ast::Provided(\n+                @ast::Method {\n                     explicit_self: explicit_self,\n                     ..\n                 }),\n@@ -494,7 +494,7 @@ pub fn create_self_argument_metadata(bcx: &Block,\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_argument_metadata(bcx: &Block, arg: &ast::arg) {\n+pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n@@ -618,9 +618,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         items.get().get_copy(&fn_ast_id)\n     };\n     let (ident, fn_decl, generics, top_level_block, span, has_path) = match fnitem {\n-        ast_map::node_item(ref item, _) => {\n+        ast_map::NodeItem(ref item, _) => {\n             match item.node {\n-                ast::item_fn(fn_decl, _, _, ref generics, top_level_block) => {\n+                ast::ItemFn(fn_decl, _, _, ref generics, top_level_block) => {\n                     (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n@@ -629,8 +629,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 }\n             }\n         }\n-        ast_map::node_method(\n-            @ast::method {\n+        ast_map::NodeMethod(\n+            @ast::Method {\n                 decl: fn_decl,\n                 ident: ident,\n                 generics: ref generics,\n@@ -642,7 +642,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             _) => {\n             (ident, fn_decl, generics, top_level_block, span, true)\n         }\n-        ast_map::node_expr(ref expr) => {\n+        ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n                 ast::ExprFnBlock(fn_decl, top_level_block) |\n                 ast::ExprProc(fn_decl, top_level_block) => {\n@@ -661,9 +661,9 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n-        ast_map::node_trait_method(\n-            @ast::provided(\n-                @ast::method {\n+        ast_map::NodeTraitMethod(\n+            @ast::Provided(\n+                @ast::Method {\n                     decl: fn_decl,\n                     ident: ident,\n                     generics: ref generics,\n@@ -675,11 +675,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             _) => {\n             (ident, fn_decl, generics, top_level_block, span, true)\n         }\n-        ast_map::node_foreign_item(@ast::foreign_item { .. }, _, _, _) |\n-        ast_map::node_variant(..) |\n-        ast_map::node_struct_ctor(..) => {\n-            return FunctionWithoutDebugInfo;\n-        }\n+        ast_map::NodeForeignItem(..) | ast_map::NodeVariant(..)\n+        | ast_map::NodeStructCtor(..) => { return FunctionWithoutDebugInfo; }\n         _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n                                   unexpected sort of node: {:?}\", fnitem))\n     };\n@@ -705,7 +702,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                                       file_metadata,\n                                                       &mut function_name);\n \n-    // There is no ast_map::path for ast::ExprFnBlock-type functions. For now, just don't put them\n+    // There is no ast_map::Path for ast::ExprFnBlock-type functions. For now, just don't put them\n     // into a namespace. In the future this could be improved somehow (storing a path in the\n     // ast_map, or construct a path using the enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n@@ -779,7 +776,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n-                              fn_decl: &ast::fn_decl,\n+                              fn_decl: &ast::FnDecl,\n                               param_substs: Option<@param_substs>,\n                               error_span: Span) -> DIArray {\n         if !cx.sess.opts.extra_debuginfo {\n@@ -790,7 +787,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n         // Return type -- llvm::DIBuilder wants this at index 0\n         match fn_decl.output.node {\n-            ast::ty_nil => {\n+            ast::TyNil => {\n                 signature.push(ptr::null());\n             }\n             _ => {\n@@ -1118,22 +1115,22 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n         ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n         ty::ty_char => (~\"char\", DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n-            ast::ty_i => (~\"int\", DW_ATE_signed),\n-            ast::ty_i8 => (~\"i8\", DW_ATE_signed),\n-            ast::ty_i16 => (~\"i16\", DW_ATE_signed),\n-            ast::ty_i32 => (~\"i32\", DW_ATE_signed),\n-            ast::ty_i64 => (~\"i64\", DW_ATE_signed)\n+            ast::TyI => (~\"int\", DW_ATE_signed),\n+            ast::TyI8 => (~\"i8\", DW_ATE_signed),\n+            ast::TyI16 => (~\"i16\", DW_ATE_signed),\n+            ast::TyI32 => (~\"i32\", DW_ATE_signed),\n+            ast::TyI64 => (~\"i64\", DW_ATE_signed)\n         },\n         ty::ty_uint(uint_ty) => match uint_ty {\n-            ast::ty_u => (~\"uint\", DW_ATE_unsigned),\n-            ast::ty_u8 => (~\"u8\", DW_ATE_unsigned),\n-            ast::ty_u16 => (~\"u16\", DW_ATE_unsigned),\n-            ast::ty_u32 => (~\"u32\", DW_ATE_unsigned),\n-            ast::ty_u64 => (~\"u64\", DW_ATE_unsigned)\n+            ast::TyU => (~\"uint\", DW_ATE_unsigned),\n+            ast::TyU8 => (~\"u8\", DW_ATE_unsigned),\n+            ast::TyU16 => (~\"u16\", DW_ATE_unsigned),\n+            ast::TyU32 => (~\"u32\", DW_ATE_unsigned),\n+            ast::TyU64 => (~\"u64\", DW_ATE_unsigned)\n         },\n         ty::ty_float(float_ty) => match float_ty {\n-            ast::ty_f32 => (~\"f32\", DW_ATE_float),\n-            ast::ty_f64 => (~\"f64\", DW_ATE_float)\n+            ast::TyF32 => (~\"f32\", DW_ATE_float),\n+            ast::TyF64 => (~\"f64\", DW_ATE_float)\n         },\n         _ => cx.sess.bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n@@ -1422,7 +1419,7 @@ fn describe_enum_variant(cx: &CrateContext,\n         {\n             let items = cx.tcx.items.borrow();\n             match items.get().find(&variant_info.id.node) {\n-                Some(&ast_map::node_variant(ref variant, _, _)) => variant.span,\n+                Some(&ast_map::NodeVariant(ref variant, _, _)) => variant.span,\n                 ref node => {\n                     cx.sess.span_warn(span,\n                         format!(\"debuginfo::enum_metadata()::\\\n@@ -2311,7 +2308,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext,\n         {\n             let items = cx.tcx.items.borrow();\n             let definition_span = match items.get().find(&def_id.node) {\n-                Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n+                Some(&ast_map::NodeItem(@ast::Item { span, .. }, _)) => span,\n                 ref node => {\n                     cx.sess.span_warn(warning_span,\n                         format!(\"debuginfo::\\\n@@ -2704,7 +2701,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::arg { pat: pattern, .. } in decl.inputs.iter() {\n+                    for &ast::Arg { pat: pattern, .. } in decl.inputs.iter() {\n                         walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n@@ -2783,9 +2780,9 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::ExprInlineAsm(ast::inline_asm { inputs: ref inputs,\n-                                                 outputs: ref outputs,\n-                                                 .. }) => {\n+            ast::ExprInlineAsm(ast::InlineAsm { inputs: ref inputs,\n+                                                outputs: ref outputs,\n+                                                .. }) => {\n                 // inputs, outputs: ~[(@str, @expr)]\n                 for &(_, @ref exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n@@ -2852,7 +2849,7 @@ fn namespace_for_item(cx: &CrateContext,\n         if def_id.crate == ast::LOCAL_CRATE {\n             // prepend crate name if not already present\n             let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);\n-            item_path.insert(0, ast_map::path_mod(crate_namespace_ident));\n+            item_path.insert(0, ast_map::PathMod(crate_namespace_ident));\n         }\n \n         item_path"}, {"sha": "970e3e4eac789c734ae298553ad94ae3944c1e7c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -152,7 +152,7 @@ use std::hashmap::HashMap;\n use std::vec;\n use syntax::print::pprust::{expr_to_str};\n use syntax::ast;\n-use syntax::ast_map::path_mod;\n+use syntax::ast_map::PathMod;\n use syntax::codemap;\n \n // Destinations\n@@ -748,7 +748,7 @@ fn trans_rvalue_dps_unadjusted<'a>(\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n-        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s, _), ..}) => {\n+        ast::ExprLit(@codemap::Spanned {node: ast::LitStr(s, _), ..}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n@@ -1392,7 +1392,7 @@ fn trans_adt<'a>(\n fn trans_immediate_lit<'a>(\n                        bcx: &'a Block<'a>,\n                        expr: &ast::Expr,\n-                       lit: ast::lit)\n+                       lit: ast::Lit)\n                        -> DatumBlock<'a> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -1916,10 +1916,10 @@ pub fn trans_log_level<'a>(bcx: &'a Block<'a>) -> DatumBlock<'a> {\n                 None => ccx.link_meta.crateid.name.to_managed(),\n             };\n         };\n-        let mut modpath = ~[path_mod(ccx.sess.ident_of(srccrate))];\n+        let mut modpath = ~[PathMod(ccx.sess.ident_of(srccrate))];\n         for e in bcx.fcx.path.iter() {\n             match *e {\n-                path_mod(_) => { modpath.push(*e) }\n+                PathMod(_) => { modpath.push(*e) }\n                 _ => {}\n             }\n         }"}, {"sha": "487aaa528eda2101b728aeb5ed734160cf0db119", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -107,8 +107,8 @@ pub fn llvm_calling_convention(ccx: &CrateContext,\n \n pub fn register_foreign_item_fn(ccx: @CrateContext,\n                                 abis: AbiSet,\n-                                path: &ast_map::path,\n-                                foreign_item: @ast::foreign_item) -> ValueRef {\n+                                path: &ast_map::Path,\n+                                foreign_item: @ast::ForeignItem) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n@@ -352,15 +352,15 @@ pub fn trans_native_call<'a>(\n }\n \n pub fn trans_foreign_mod(ccx: @CrateContext,\n-                         foreign_mod: &ast::foreign_mod) {\n+                         foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n-            ast::foreign_item_fn(..) => {\n+            ast::ForeignItemFn(..) => {\n                 let items = ccx.tcx.items.borrow();\n                 let (abis, mut path) =\n                     match items.get().get_copy(&foreign_item.id) {\n-                        ast_map::node_foreign_item(_, abis, _, path) => {\n+                        ast_map::NodeForeignItem(_, abis, _, path) => {\n                             (abis, (*path).clone())\n                         }\n                         _ => {\n@@ -369,7 +369,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                         }\n                     };\n                 if !(abis.is_rust() || abis.is_intrinsic()) {\n-                    path.push(ast_map::path_name(foreign_item.ident));\n+                    path.push(ast_map::PathName(foreign_item.ident));\n                     register_foreign_item_fn(ccx, abis, &path, foreign_item);\n                 }\n             }\n@@ -437,8 +437,8 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n }\n \n pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n-                                      path: &ast_map::path,\n-                                      decl: &ast::fn_decl,\n+                                      path: &ast_map::Path,\n+                                      decl: &ast::FnDecl,\n                                       body: &ast::Block,\n                                       attrs: &[ast::Attribute],\n                                       llwrapfn: ValueRef,\n@@ -455,8 +455,8 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n     }\n \n     fn build_rust_fn(ccx: @CrateContext,\n-                     path: &ast_map::path,\n-                     decl: &ast::fn_decl,\n+                     path: &ast_map::Path,\n+                     decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      attrs: &[ast::Attribute],\n                      id: ast::NodeId)\n@@ -465,7 +465,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         let tcx = ccx.tcx;\n         let t = ty::node_id_to_type(tcx, id);\n         let ps = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one((*path).clone(), ast_map::path_name(\n+            ccx, vec::append_one((*path).clone(), ast_map::PathName(\n                 special_idents::clownshoe_abi\n             )));\n \n@@ -748,7 +748,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // This code is kind of a confused mess and needs to be reworked given\n // the massive simplifications that have occurred.\n \n-pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n+pub fn link_name(ccx: &CrateContext, i: @ast::ForeignItem) -> @str {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,"}, {"sha": "f571d35bb28e8ee272b7b4ebe4d3f7c99c0ea382", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -19,7 +19,7 @@ use util::ppaux::ty_to_str;\n \n use std::vec;\n use syntax::ast;\n-use syntax::ast_map::path_name;\n+use syntax::ast_map::PathName;\n use syntax::ast_util::local_def;\n use syntax::attr;\n \n@@ -56,7 +56,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n             external.get().insert(fn_id, None);\n             fn_id\n         }\n-        csearch::found(ast::ii_item(item)) => {\n+        csearch::found(ast::IIItem(item)) => {\n             {\n                 let mut external = ccx.external.borrow_mut();\n                 let mut external_srcs = ccx.external_srcs.borrow_mut();\n@@ -76,7 +76,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n             // however, so we use the available_externally linkage which llvm\n             // provides\n             match item.node {\n-                ast::item_static(..) => {\n+                ast::ItemStatic(..) => {\n                     let g = get_item_val(ccx, item.id);\n                     // see the comment in get_item_val() as to why this check is\n                     // performed here.\n@@ -90,7 +90,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n             local_def(item.id)\n         }\n-        csearch::found(ast::ii_foreign(item)) => {\n+        csearch::found(ast::IIForeign(item)) => {\n             {\n                 let mut external = ccx.external.borrow_mut();\n                 let mut external_srcs = ccx.external_srcs.borrow_mut();\n@@ -99,7 +99,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n             }\n             local_def(item.id)\n         }\n-        csearch::found_parent(parent_id, ast::ii_item(item)) => {\n+        csearch::found_parent(parent_id, ast::IIItem(item)) => {\n             {\n                 let mut external = ccx.external.borrow_mut();\n                 let mut external_srcs = ccx.external_srcs.borrow_mut();\n@@ -109,7 +109,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n           let mut my_id = 0;\n           match item.node {\n-            ast::item_enum(_, _) => {\n+            ast::ItemEnum(_, _) => {\n               let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n               let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n@@ -118,7 +118,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                   external.get().insert(there.id, Some(here.id.node));\n               }\n             }\n-            ast::item_struct(ref struct_def, _) => {\n+            ast::ItemStruct(ref struct_def, _) => {\n               match struct_def.ctor_id {\n                 None => {}\n                 Some(ctor_id) => {\n@@ -138,7 +138,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n             ccx.sess.bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n-        csearch::found(ast::ii_method(impl_did, is_provided, mth)) => {\n+        csearch::found(ast::IIMethod(impl_did, is_provided, mth)) => {\n             {\n                 let mut external = ccx.external.borrow_mut();\n                 let mut external_srcs = ccx.external_srcs.borrow_mut();\n@@ -159,18 +159,17 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n           if num_type_params == 0 {\n               let llfn = get_item_val(ccx, mth.id);\n-              let path = vec::append(\n-                  ty::item_path(ccx.tcx, impl_did),\n-                  [path_name(mth.ident)]);\n+              let path = vec::append_one(\n+                  ty::item_path(ccx.tcx, impl_did), PathName(mth.ident));\n               let self_kind = match mth.explicit_self.node {\n-                  ast::sty_static => no_self,\n+                  ast::SelfStatic => no_self,\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n                       debug!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n                       match mth.explicit_self.node {\n-                          ast::sty_value(_) => impl_self(self_ty, ty::ByRef),\n+                          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n                           _ => impl_self(self_ty, ty::ByCopy),\n                       }\n                   }"}, {"sha": "b001802f165073abff7b3fcfc9c4a995d62e48a4", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -31,8 +31,8 @@ use middle::trans::type_::Type;\n \n pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n-                       item: &ast::foreign_item,\n-                       path: ast_map::path,\n+                       item: &ast::ForeignItem,\n+                       path: ast_map::Path,\n                        substs: @param_substs,\n                        _attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n@@ -348,7 +348,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 let sp = {\n                     let items = ccx.tcx.items.borrow();\n                     match items.get().get_copy(&ref_id.unwrap()) {\n-                        ast_map::node_expr(e) => e.span,\n+                        ast_map::NodeExpr(e) => e.span,\n                         _ => fail!(\"transmute has non-expr arg\"),\n                     }\n                 };"}, {"sha": "f526fb528c5d8fc1e1586f7b1d8bb0886c87bcb4", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -34,11 +34,9 @@ use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n use std::vec;\n-use syntax::ast_map::{path, path_mod, path_name, path_pretty_name};\n-use syntax::ast_util;\n-use syntax::{ast, ast_map};\n+use syntax::ast_map::{Path, PathMod, PathName, PathPrettyName};\n use syntax::parse::token;\n-use syntax::visit;\n+use syntax::{ast, ast_map, ast_util, visit};\n \n /**\n The main \"translation\" pass for methods.  Generates code\n@@ -47,9 +45,9 @@ be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: @CrateContext,\n-                  path: path,\n+                  path: Path,\n                   name: ast::Ident,\n-                  methods: &[@ast::method],\n+                  methods: &[@ast::Method],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"impl::trans_impl\");\n@@ -67,12 +65,12 @@ pub fn trans_impl(ccx: @CrateContext,\n         }\n         return;\n     }\n-    let sub_path = vec::append_one(path, path_name(name));\n+    let sub_path = vec::append_one(path, PathName(name));\n     for method in methods.iter() {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(sub_path.clone(),\n-                                       path_name(method.ident));\n+                                       PathName(method.ident));\n \n             trans_method(ccx,\n                          path,\n@@ -98,13 +96,13 @@ pub fn trans_impl(ccx: @CrateContext,\n ///\n /// XXX(pcwalton) Can we take `path` by reference?\n pub fn trans_method(ccx: @CrateContext,\n-                    path: path,\n-                    method: &ast::method,\n+                    path: Path,\n+                    method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n                     llfn: ValueRef) {\n     // figure out how self is being passed\n     let self_arg = match method.explicit_self.node {\n-      ast::sty_static => {\n+      ast::SelfStatic => {\n         no_self\n       }\n       _ => {\n@@ -120,7 +118,7 @@ pub fn trans_method(ccx: @CrateContext,\n         debug!(\"calling trans_fn with self_ty {}\",\n                self_ty.repr(ccx.tcx));\n         match method.explicit_self.node {\n-          ast::sty_value(_) => impl_self(self_ty, ty::ByRef),\n+          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n           _ => impl_self(self_ty, ty::ByCopy),\n         }\n       }\n@@ -252,7 +250,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n         {\n             let items = bcx.tcx().items.borrow();\n             match items.get().get_copy(&method_id.node) {\n-                ast_map::node_trait_method(trait_method, _, _) => {\n+                ast_map::NodeTraitMethod(trait_method, _, _) => {\n                     ast_util::trait_method_to_ty_method(trait_method).ident\n                 }\n                 _ => fail!(\"callee is not a trait method\")\n@@ -261,8 +259,8 @@ pub fn trans_static_method_callee(bcx: &Block,\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n         match path[path.len()-1] {\n-            path_pretty_name(s, _) | path_name(s) => { s }\n-            path_mod(_) => { fail!(\"path doesn't have a name?\") }\n+            PathPrettyName(s, _) | PathName(s) => { s }\n+            PathMod(_) => { fail!(\"path doesn't have a name?\") }\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id={:?}, callee_id={:?}, \\"}, {"sha": "8365b54153251c943eded4f6a734bc9c25059075", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -107,44 +107,44 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     // Get the path so that we can create a symbol\n     let (pt, name, span) = match map_node {\n-      ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n-      ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n-      ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n-      ast_map::node_foreign_item(i, abis, _, pt) if abis.is_intrinsic()\n+      ast_map::NodeItem(i, pt) => (pt, i.ident, i.span),\n+      ast_map::NodeVariant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n+      ast_map::NodeMethod(m, _, pt) => (pt, m.ident, m.span),\n+      ast_map::NodeForeignItem(i, abis, _, pt) if abis.is_intrinsic()\n       => (pt, i.ident, i.span),\n-      ast_map::node_foreign_item(..) => {\n+      ast_map::NodeForeignItem(..) => {\n         // Foreign externs don't have to be monomorphized.\n         return (get_item_val(ccx, fn_id.node), true);\n       }\n-      ast_map::node_trait_method(@ast::provided(m), _, pt) => {\n+      ast_map::NodeTraitMethod(@ast::Provided(m), _, pt) => {\n         // If this is a static provided method, indicate that\n         // and stash the number of params on the method.\n-        if m.explicit_self.node == ast::sty_static {\n+        if m.explicit_self.node == ast::SelfStatic {\n             is_static_provided = Some(m.generics.ty_params.len());\n         }\n \n         (pt, m.ident, m.span)\n       }\n-      ast_map::node_trait_method(@ast::required(_), _, _) => {\n+      ast_map::NodeTraitMethod(@ast::Required(_), _, _) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n       }\n-      ast_map::node_expr(..) => {\n+      ast_map::NodeExpr(..) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize an expr\")\n       }\n-      ast_map::node_stmt(..) => {\n+      ast_map::NodeStmt(..) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize a stmt\")\n       }\n-      ast_map::node_arg(..) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n-      ast_map::node_block(..) => {\n+      ast_map::NodeArg(..) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n+      ast_map::NodeBlock(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n       }\n-      ast_map::node_local(..) => {\n+      ast_map::NodeLocal(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n       }\n-      ast_map::node_callee_scope(..) => {\n+      ast_map::NodeCalleeScope(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a callee-scope\")\n       }\n-      ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n+      ast_map::NodeStructCtor(_, i, pt) => (pt, i.ident, i.span)\n     };\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n@@ -219,8 +219,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     };\n \n     let lldecl = match map_node {\n-      ast_map::node_item(i@@ast::item {\n-                node: ast::item_fn(decl, _, _, _, body),\n+      ast_map::NodeItem(i@@ast::Item {\n+                node: ast::ItemFn(decl, _, _, _, body),\n                 ..\n             }, _) => {\n         let d = mk_lldecl();\n@@ -236,22 +236,22 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                  []);\n         d\n       }\n-      ast_map::node_item(..) => {\n+      ast_map::NodeItem(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n-      ast_map::node_foreign_item(i, _, _, _) => {\n+      ast_map::NodeForeignItem(i, _, _, _) => {\n           let d = mk_lldecl();\n           intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n                                      ref_id);\n           d\n       }\n-      ast_map::node_variant(v, enum_item, _) => {\n+      ast_map::NodeVariant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match v.node.kind {\n-            ast::tuple_variant_kind(ref args) => {\n+            ast::TupleVariantKind(ref args) => {\n                 trans_enum_variant(ccx,\n                                    enum_item.id,\n                                    v,\n@@ -260,25 +260,25 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                                    Some(psubsts),\n                                    d);\n             }\n-            ast::struct_variant_kind(_) =>\n+            ast::StructVariantKind(_) =>\n                 ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n         }\n         d\n       }\n-      ast_map::node_method(mth, _, _) => {\n+      ast_map::NodeMethod(mth, _, _) => {\n         // XXX: What should the self type be here?\n         let d = mk_lldecl();\n         set_llvm_fn_attrs(mth.attrs, d);\n         meth::trans_method(ccx, pt, mth, Some(psubsts), d);\n         d\n       }\n-      ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n+      ast_map::NodeTraitMethod(@ast::Provided(mth), _, pt) => {\n         let d = mk_lldecl();\n         set_llvm_fn_attrs(mth.attrs, d);\n         meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), d);\n         d\n       }\n-      ast_map::node_struct_ctor(struct_def, _, _) => {\n+      ast_map::NodeStructCtor(struct_def, _, _) => {\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n@@ -291,13 +291,13 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       }\n \n       // Ugh -- but this ensures any new variants won't be forgotten\n-      ast_map::node_expr(..) |\n-      ast_map::node_stmt(..) |\n-      ast_map::node_trait_method(..) |\n-      ast_map::node_arg(..) |\n-      ast_map::node_block(..) |\n-      ast_map::node_callee_scope(..) |\n-      ast_map::node_local(..) => {\n+      ast_map::NodeExpr(..) |\n+      ast_map::NodeStmt(..) |\n+      ast_map::NodeTraitMethod(..) |\n+      ast_map::NodeArg(..) |\n+      ast_map::NodeBlock(..) |\n+      ast_map::NodeCalleeScope(..) |\n+      ast_map::NodeLocal(..) => {\n         ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n       }\n     };"}, {"sha": "7810a99b2739e84d278e03b3edb6b85f2343db9a", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -29,7 +29,7 @@ use std::option::{Some,None};\n use std::vec;\n use syntax::ast::DefId;\n use syntax::ast;\n-use syntax::ast_map::path_name;\n+use syntax::ast_map::PathName;\n use syntax::parse::token::special_idents;\n \n use middle::trans::type_::Type;\n@@ -158,18 +158,18 @@ impl<'a> Reflector<'a> {\n           ty::ty_nil => self.leaf(\"nil\"),\n           ty::ty_bool => self.leaf(\"bool\"),\n           ty::ty_char => self.leaf(\"char\"),\n-          ty::ty_int(ast::ty_i) => self.leaf(\"int\"),\n-          ty::ty_int(ast::ty_i8) => self.leaf(\"i8\"),\n-          ty::ty_int(ast::ty_i16) => self.leaf(\"i16\"),\n-          ty::ty_int(ast::ty_i32) => self.leaf(\"i32\"),\n-          ty::ty_int(ast::ty_i64) => self.leaf(\"i64\"),\n-          ty::ty_uint(ast::ty_u) => self.leaf(\"uint\"),\n-          ty::ty_uint(ast::ty_u8) => self.leaf(\"u8\"),\n-          ty::ty_uint(ast::ty_u16) => self.leaf(\"u16\"),\n-          ty::ty_uint(ast::ty_u32) => self.leaf(\"u32\"),\n-          ty::ty_uint(ast::ty_u64) => self.leaf(\"u64\"),\n-          ty::ty_float(ast::ty_f32) => self.leaf(\"f32\"),\n-          ty::ty_float(ast::ty_f64) => self.leaf(\"f64\"),\n+          ty::ty_int(ast::TyI) => self.leaf(\"int\"),\n+          ty::ty_int(ast::TyI8) => self.leaf(\"i8\"),\n+          ty::ty_int(ast::TyI16) => self.leaf(\"i16\"),\n+          ty::ty_int(ast::TyI32) => self.leaf(\"i32\"),\n+          ty::ty_int(ast::TyI64) => self.leaf(\"i64\"),\n+          ty::ty_uint(ast::TyU) => self.leaf(\"uint\"),\n+          ty::ty_uint(ast::TyU8) => self.leaf(\"u8\"),\n+          ty::ty_uint(ast::TyU16) => self.leaf(\"u16\"),\n+          ty::ty_uint(ast::TyU32) => self.leaf(\"u32\"),\n+          ty::ty_uint(ast::TyU64) => self.leaf(\"u64\"),\n+          ty::ty_float(ast::TyF32) => self.leaf(\"f32\"),\n+          ty::ty_float(ast::TyF64) => self.leaf(\"f64\"),\n \n           ty::ty_unboxed_vec(ref mt) => {\n               let values = self.c_mt(mt);\n@@ -290,7 +290,7 @@ impl<'a> Reflector<'a> {\n                                                            mutbl: ast::MutImmutable });\n \n             let make_get_disr = || {\n-                let sub_path = bcx.fcx.path + &[path_name(special_idents::anon)];\n+                let sub_path = bcx.fcx.path + &[PathName(special_idents::anon)];\n                 let sym = mangle_internal_name_by_path_and_seq(ccx,\n                                                                sub_path,\n                                                                \"get_disr\");\n@@ -416,10 +416,10 @@ pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n     }\n }\n \n-pub fn ast_purity_constant(purity: ast::purity) -> uint {\n+pub fn ast_purity_constant(purity: ast::Purity) -> uint {\n     match purity {\n-        ast::unsafe_fn => 1u,\n-        ast::impure_fn => 2u,\n-        ast::extern_fn => 3u\n+        ast::UnsafeFn => 1u,\n+        ast::ImpureFn => 2u,\n+        ast::ExternFn => 3u\n     }\n }"}, {"sha": "5b8d2a0f6b56cab9bd452f2c1f7147aef2fe6fbc", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -225,7 +225,7 @@ pub fn trans_slice_vstore<'a>(\n \n     // Handle the &\"...\" case:\n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s, _), span: _}) => {\n+        ast::ExprLit(@codemap::Spanned {node: ast::LitStr(s, _), span: _}) => {\n             return trans_lit_str(bcx, content_expr, s, dest);\n         }\n         _ => {}\n@@ -320,7 +320,7 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n         heap_exchange => {\n             match content_expr.node {\n                 ast::ExprLit(@codemap::Spanned {\n-                    node: ast::lit_str(s, _), span\n+                    node: ast::LitStr(s, _), span\n                 }) => {\n                     let llptrval = C_cstr(bcx.ccx(), s);\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n@@ -382,7 +382,7 @@ pub fn write_content<'a>(\n     let _indenter = indenter();\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), .. }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::LitStr(s, _), .. }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -479,7 +479,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), .. }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::LitStr(s, _), .. }) => {\n             s.len()\n         },\n         ast::ExprVec(ref es, _) => es.len(),"}, {"sha": "e2338c1ad81108c2d54fd5d156147cc3b9e7ef96", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -117,30 +117,30 @@ impl Type {\n         Type::f64()\n     }\n \n-    pub fn int_from_ty(ctx: &CrateContext, t: ast::int_ty) -> Type {\n+    pub fn int_from_ty(ctx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::ty_i => ctx.int_type,\n-            ast::ty_i8 => Type::i8(),\n-            ast::ty_i16 => Type::i16(),\n-            ast::ty_i32 => Type::i32(),\n-            ast::ty_i64 => Type::i64()\n+            ast::TyI => ctx.int_type,\n+            ast::TyI8 => Type::i8(),\n+            ast::TyI16 => Type::i16(),\n+            ast::TyI32 => Type::i32(),\n+            ast::TyI64 => Type::i64()\n         }\n     }\n \n-    pub fn uint_from_ty(ctx: &CrateContext, t: ast::uint_ty) -> Type {\n+    pub fn uint_from_ty(ctx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::ty_u => ctx.int_type,\n-            ast::ty_u8 => Type::i8(),\n-            ast::ty_u16 => Type::i16(),\n-            ast::ty_u32 => Type::i32(),\n-            ast::ty_u64 => Type::i64()\n+            ast::TyU => ctx.int_type,\n+            ast::TyU8 => Type::i8(),\n+            ast::TyU16 => Type::i16(),\n+            ast::TyU32 => Type::i32(),\n+            ast::TyU64 => Type::i64()\n         }\n     }\n \n-    pub fn float_from_ty(t: ast::float_ty) -> Type {\n+    pub fn float_from_ty(t: ast::FloatTy) -> Type {\n         match t {\n-            ast::ty_f32 => Type::f32(),\n-            ast::ty_f64 => Type::f64()\n+            ast::TyF32 => Type::f32(),\n+            ast::TyF64 => Type::f64()\n         }\n     }\n "}, {"sha": "f6fb509e317fe59b2bad2ca8b420df4d8f64586a", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -267,7 +267,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n           let p_ty = type_of(cx, mt.ty).ptr_to();\n-          let u_ty = Type::uint_from_ty(cx, ast::ty_u);\n+          let u_ty = Type::uint_from_ty(cx, ast::TyU);\n           Type::struct_([p_ty, u_ty], false)\n       }\n "}, {"sha": "a202b810b75bd41a53cc0756f31dc9720d84df61", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 112, "deletions": 114, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -76,8 +76,8 @@ pub struct Method {\n     generics: ty::Generics,\n     transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n-    explicit_self: ast::explicit_self_,\n-    vis: ast::visibility,\n+    explicit_self: ast::ExplicitSelf_,\n+    vis: ast::Visibility,\n     def_id: ast::DefId,\n     container: MethodContainer,\n \n@@ -90,14 +90,14 @@ impl Method {\n                generics: ty::Generics,\n                transformed_self_ty: Option<ty::t>,\n                fty: BareFnTy,\n-               explicit_self: ast::explicit_self_,\n-               vis: ast::visibility,\n+               explicit_self: ast::ExplicitSelf_,\n+               vis: ast::Visibility,\n                def_id: ast::DefId,\n                container: MethodContainer,\n                provided_source: Option<ast::DefId>)\n                -> Method {\n         // Check the invariants.\n-        if explicit_self == ast::sty_static {\n+        if explicit_self == ast::SelfStatic {\n             assert!(transformed_self_ty.is_none());\n         } else {\n             assert!(transformed_self_ty.is_some());\n@@ -162,7 +162,7 @@ pub enum SelfMode {\n pub struct field_ty {\n     name: Name,\n     id: DefId,\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n }\n \n // Contains information needed to resolve types and (in the future) look up\n@@ -305,7 +305,7 @@ struct ctxt_ {\n \n     /// Despite its name, `items` does not only map NodeId to an item but\n     /// also to expr/stmt/local/arg/etc\n-    items: ast_map::map,\n+    items: ast_map::Map,\n     intrinsic_defs: RefCell<HashMap<ast::DefId, t>>,\n     freevars: RefCell<freevars::freevar_map>,\n     tcache: type_cache,\n@@ -435,14 +435,14 @@ pub fn type_id(t: t) -> uint { get(t).id }\n \n #[deriving(Clone, Eq, IterBytes)]\n pub struct BareFnTy {\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     abis: AbiSet,\n     sig: FnSig\n }\n \n #[deriving(Clone, Eq, IterBytes)]\n pub struct ClosureTy {\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     sigil: ast::Sigil,\n     onceness: ast::Onceness,\n     region: Region,\n@@ -596,18 +596,18 @@ mod primitives {\n     def_prim_ty!(TY_NIL,    super::ty_nil,                  0)\n     def_prim_ty!(TY_BOOL,   super::ty_bool,                 1)\n     def_prim_ty!(TY_CHAR,   super::ty_char,                 2)\n-    def_prim_ty!(TY_INT,    super::ty_int(ast::ty_i),       3)\n-    def_prim_ty!(TY_I8,     super::ty_int(ast::ty_i8),      4)\n-    def_prim_ty!(TY_I16,    super::ty_int(ast::ty_i16),     5)\n-    def_prim_ty!(TY_I32,    super::ty_int(ast::ty_i32),     6)\n-    def_prim_ty!(TY_I64,    super::ty_int(ast::ty_i64),     7)\n-    def_prim_ty!(TY_UINT,   super::ty_uint(ast::ty_u),      8)\n-    def_prim_ty!(TY_U8,     super::ty_uint(ast::ty_u8),     9)\n-    def_prim_ty!(TY_U16,    super::ty_uint(ast::ty_u16),    10)\n-    def_prim_ty!(TY_U32,    super::ty_uint(ast::ty_u32),    11)\n-    def_prim_ty!(TY_U64,    super::ty_uint(ast::ty_u64),    12)\n-    def_prim_ty!(TY_F32,    super::ty_float(ast::ty_f32),   14)\n-    def_prim_ty!(TY_F64,    super::ty_float(ast::ty_f64),   15)\n+    def_prim_ty!(TY_INT,    super::ty_int(ast::TyI),        3)\n+    def_prim_ty!(TY_I8,     super::ty_int(ast::TyI8),       4)\n+    def_prim_ty!(TY_I16,    super::ty_int(ast::TyI16),      5)\n+    def_prim_ty!(TY_I32,    super::ty_int(ast::TyI32),      6)\n+    def_prim_ty!(TY_I64,    super::ty_int(ast::TyI64),      7)\n+    def_prim_ty!(TY_UINT,   super::ty_uint(ast::TyU),       8)\n+    def_prim_ty!(TY_U8,     super::ty_uint(ast::TyU8),      9)\n+    def_prim_ty!(TY_U16,    super::ty_uint(ast::TyU16),     10)\n+    def_prim_ty!(TY_U32,    super::ty_uint(ast::TyU32),     11)\n+    def_prim_ty!(TY_U64,    super::ty_uint(ast::TyU64),     12)\n+    def_prim_ty!(TY_F32,    super::ty_float(ast::TyF32),    14)\n+    def_prim_ty!(TY_F64,    super::ty_float(ast::TyF64),    15)\n \n     pub static TY_BOT: t_box_ = t_box_ {\n         sty: super::ty_bot,\n@@ -632,9 +632,9 @@ pub enum sty {\n     ty_bot,\n     ty_bool,\n     ty_char,\n-    ty_int(ast::int_ty),\n-    ty_uint(ast::uint_ty),\n-    ty_float(ast::float_ty),\n+    ty_int(ast::IntTy),\n+    ty_uint(ast::UintTy),\n+    ty_float(ast::FloatTy),\n     ty_estr(vstore),\n     ty_enum(DefId, substs),\n     ty_box(t),\n@@ -672,8 +672,8 @@ pub struct TraitRef {\n \n #[deriving(Clone, Eq)]\n pub enum IntVarValue {\n-    IntType(ast::int_ty),\n-    UintType(ast::uint_ty),\n+    IntType(ast::IntTy),\n+    UintType(ast::UintTy),\n }\n \n #[deriving(Clone, ToStr)]\n@@ -694,7 +694,7 @@ pub struct expected_found<T> {\n #[deriving(Clone, ToStr)]\n pub enum type_err {\n     terr_mismatch,\n-    terr_purity_mismatch(expected_found<purity>),\n+    terr_purity_mismatch(expected_found<Purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<AbiSet>),\n     terr_mutability,\n@@ -720,7 +720,7 @@ pub enum type_err {\n     terr_sorts(expected_found<t>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n-    terr_float_mismatch(expected_found<ast::float_ty>),\n+    terr_float_mismatch(expected_found<ast::FloatTy>),\n     terr_traits(expected_found<ast::DefId>),\n     terr_builtin_bounds(expected_found<BuiltinBounds>),\n     terr_variadic_mismatch(expected_found<bool>)\n@@ -964,7 +964,7 @@ pub type node_type_table = RefCell<HashMap<uint,t>>;\n pub fn mk_ctxt(s: session::Session,\n                dm: resolve::DefMap,\n                named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n-               amap: ast_map::map,\n+               amap: ast_map::Map,\n                freevars: freevars::freevar_map,\n                region_maps: middle::region::RegionMaps,\n                lang_items: middle::lang_items::LanguageItems)\n@@ -1204,30 +1204,30 @@ pub fn mk_u32() -> t { mk_prim_t(&primitives::TY_U32) }\n #[inline]\n pub fn mk_u64() -> t { mk_prim_t(&primitives::TY_U64) }\n \n-pub fn mk_mach_int(tm: ast::int_ty) -> t {\n+pub fn mk_mach_int(tm: ast::IntTy) -> t {\n     match tm {\n-        ast::ty_i    => mk_int(),\n-        ast::ty_i8   => mk_i8(),\n-        ast::ty_i16  => mk_i16(),\n-        ast::ty_i32  => mk_i32(),\n-        ast::ty_i64  => mk_i64(),\n+        ast::TyI    => mk_int(),\n+        ast::TyI8   => mk_i8(),\n+        ast::TyI16  => mk_i16(),\n+        ast::TyI32  => mk_i32(),\n+        ast::TyI64  => mk_i64(),\n     }\n }\n \n-pub fn mk_mach_uint(tm: ast::uint_ty) -> t {\n+pub fn mk_mach_uint(tm: ast::UintTy) -> t {\n     match tm {\n-        ast::ty_u    => mk_uint(),\n-        ast::ty_u8   => mk_u8(),\n-        ast::ty_u16  => mk_u16(),\n-        ast::ty_u32  => mk_u32(),\n-        ast::ty_u64  => mk_u64(),\n+        ast::TyU    => mk_uint(),\n+        ast::TyU8   => mk_u8(),\n+        ast::TyU16  => mk_u16(),\n+        ast::TyU32  => mk_u32(),\n+        ast::TyU64  => mk_u64(),\n     }\n }\n \n-pub fn mk_mach_float(tm: ast::float_ty) -> t {\n+pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n     match tm {\n-        ast::ty_f32  => mk_f32(),\n-        ast::ty_f64  => mk_f64(),\n+        ast::TyF32  => mk_f32(),\n+        ast::TyF64  => mk_f64(),\n     }\n }\n \n@@ -1306,7 +1306,7 @@ pub fn mk_ctor_fn(cx: ctxt,\n     let input_args = input_tys.map(|t| *t);\n     mk_bare_fn(cx,\n                BareFnTy {\n-                   purity: ast::impure_fn,\n+                   purity: ast::ImpureFn,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n                     binder_id: binder_id,\n@@ -1550,7 +1550,7 @@ pub fn type_is_str(ty: t) -> bool {\n \n pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n-      ty_estr(_) => return mk_mach_uint(ast::ty_u8),\n+      ty_estr(_) => return mk_mach_uint(ast::TyU8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n@@ -2497,7 +2497,7 @@ pub fn type_is_signed(ty: t) -> bool {\n \n pub fn type_is_machine(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_int(ast::ty_i) | ty_uint(ast::ty_u) => false,\n+        ty_int(ast::TyI) | ty_uint(ast::TyU) => false,\n         ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n     }\n@@ -2735,7 +2735,7 @@ pub fn ty_closure_sigil(fty: t) -> Sigil {\n     }\n }\n \n-pub fn ty_fn_purity(fty: t) -> ast::purity {\n+pub fn ty_fn_purity(fty: t) -> ast::Purity {\n     match get(fty).sty {\n         ty_bare_fn(ref f) => f.purity,\n         ty_closure(ref f) => f.purity,\n@@ -3184,7 +3184,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprDoBody(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n-        ast::ExprLit(@codemap::Spanned {node: lit_str(..), ..}) |\n+        ast::ExprLit(@codemap::Spanned {node: LitStr(..), ..}) |\n         ast::ExprVstore(_, ast::ExprVstoreSlice) |\n         ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n         ast::ExprVec(..) => {\n@@ -3232,7 +3232,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n         ast::ExprLogLevel |\n-        ast::ExprLit(_) | // Note: lit_str is carved out above\n+        ast::ExprLit(_) | // Note: LitStr is carved out above\n         ast::ExprUnary(..) |\n         ast::ExprAddrOf(..) |\n         ast::ExprBinary(..) |\n@@ -3551,8 +3551,8 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n         {\n             let items = cx.items.borrow();\n             match items.get().find(&id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                            node: item_trait(_, _, ref ms),\n+                Some(&ast_map::NodeItem(@ast::Item {\n+                            node: ItemTrait(_, _, ref ms),\n                             ..\n                         }, _)) =>\n                     match ast_util::split_trait_methods(*ms) {\n@@ -3673,8 +3673,8 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         {\n             let items = cx.items.borrow();\n             match items.get().find(&id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                     node: ast::item_impl(_, ref opt_trait, _, _),\n+                Some(&ast_map::NodeItem(@ast::Item {\n+                     node: ast::ItemImpl(_, ref opt_trait, _, _),\n                      ..},\n                      _)) => {\n                     match opt_trait {\n@@ -3694,7 +3694,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     return ret;\n }\n \n-pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::trait_ref) -> ast::DefId {\n+pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def_map = tcx.def_map.borrow();\n     let def = def_map.get()\n                      .find(&tr.ref_id)\n@@ -3732,7 +3732,7 @@ pub struct VariantInfo {\n     name: ast::Ident,\n     id: ast::DefId,\n     disr_val: Disr,\n-    vis: visibility\n+    vis: Visibility\n }\n \n impl VariantInfo {\n@@ -3741,12 +3741,12 @@ impl VariantInfo {\n     ///\n     /// Does not do any caching of the value in the type context.\n     pub fn from_ast_variant(cx: ctxt,\n-                            ast_variant: &ast::variant,\n+                            ast_variant: &ast::Variant,\n                             discriminant: Disr) -> VariantInfo {\n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n \n         match ast_variant.node.kind {\n-            ast::tuple_variant_kind(ref args) => {\n+            ast::TupleVariantKind(ref args) => {\n                 let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { ~[] };\n \n                 return VariantInfo {\n@@ -3759,17 +3759,17 @@ impl VariantInfo {\n                     vis: ast_variant.node.vis\n                 };\n             },\n-            ast::struct_variant_kind(ref struct_def) => {\n+            ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[struct_field] = struct_def.fields;\n+                let fields: &[StructField] = struct_def.fields;\n \n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n                 let arg_names = fields.map(|field| {\n                     match field.node.kind {\n-                        named_field(ident, _) => ident,\n-                        unnamed_field => cx.sess.bug(\n+                        NamedField(ident, _) => ident,\n+                        UnnamedField => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }\n                 });\n@@ -3853,7 +3853,7 @@ pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n+pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::Path {\n     if id.crate != ast::LOCAL_CRATE {\n         return csearch::get_item_path(cx, id)\n     }\n@@ -3865,45 +3865,43 @@ pub fn item_path(cx: ctxt, id: ast::DefId) -> ast_map::path {\n     // match *node {\n     let items = cx.items.borrow();\n     match *items.get().get(&id.node) {\n-      ast_map::node_item(item, path) => {\n-        let item_elt = match item.node {\n-          item_mod(_) | item_foreign_mod(_) => {\n-            ast_map::path_mod(item.ident)\n-          }\n-          _ => {\n-            ast_map::path_name(item.ident)\n-          }\n-        };\n-        vec::append_one((*path).clone(), item_elt)\n-      }\n+        ast_map::NodeItem(item, path) => {\n+            let item_elt = match item.node {\n+                ItemMod(_) | ItemForeignMod(_) => {\n+                    ast_map::PathMod(item.ident)\n+                }\n+                _ => ast_map::PathName(item.ident)\n+            };\n+            vec::append_one((*path).clone(), item_elt)\n+        }\n \n-      ast_map::node_foreign_item(nitem, _, _, path) => {\n-        vec::append_one((*path).clone(),\n-                        ast_map::path_name(nitem.ident))\n-      }\n+        ast_map::NodeForeignItem(nitem, _, _, path) => {\n+            vec::append_one((*path).clone(),\n+                            ast_map::PathName(nitem.ident))\n+        }\n \n-      ast_map::node_method(method, _, path) => {\n-        vec::append_one((*path).clone(),\n-                        ast_map::path_name(method.ident))\n-      }\n-      ast_map::node_trait_method(trait_method, _, path) => {\n-        let method = ast_util::trait_method_to_ty_method(&*trait_method);\n-        vec::append_one((*path).clone(),\n-                        ast_map::path_name(method.ident))\n-      }\n+        ast_map::NodeMethod(method, _, path) => {\n+            vec::append_one((*path).clone(),\n+                            ast_map::PathName(method.ident))\n+        }\n+        ast_map::NodeTraitMethod(trait_method, _, path) => {\n+            let method = ast_util::trait_method_to_ty_method(&*trait_method);\n+            vec::append_one((*path).clone(),\n+                            ast_map::PathName(method.ident))\n+        }\n \n-      ast_map::node_variant(ref variant, _, path) => {\n-        vec::append_one(path.init().to_owned(),\n-                        ast_map::path_name((*variant).node.name))\n-      }\n+        ast_map::NodeVariant(ref variant, _, path) => {\n+            vec::append_one(path.init().to_owned(),\n+                            ast_map::PathName((*variant).node.name))\n+        }\n \n-      ast_map::node_struct_ctor(_, item, path) => {\n-        vec::append_one((*path).clone(), ast_map::path_name(item.ident))\n-      }\n+        ast_map::NodeStructCtor(_, item, path) => {\n+            vec::append_one((*path).clone(), ast_map::PathName(item.ident))\n+        }\n \n-      ref node => {\n-        cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n-      }\n+        ref node => {\n+            cx.sess.bug(format!(\"cannot find item_path for node {:?}\", node));\n+        }\n     }\n }\n \n@@ -3938,8 +3936,8 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n         {\n             let items = cx.items.borrow();\n             match items.get().get_copy(&id.node) {\n-              ast_map::node_item(@ast::item {\n-                        node: ast::item_enum(ref enum_definition, _),\n+              ast_map::NodeItem(@ast::Item {\n+                        node: ast::ItemEnum(ref enum_definition, _),\n                         ..\n                     }, _) => {\n                 let mut last_discriminant: Option<Disr> = None;\n@@ -4045,7 +4043,7 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n         {\n             let items = tcx.items.borrow();\n             match items.get().find(&did.node) {\n-                Some(&ast_map::node_item(@ast::item {\n+                Some(&ast_map::NodeItem(@ast::Item {\n                     attrs: ref attrs,\n                     ..\n                 }, _)) =>\n@@ -4131,17 +4129,17 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> ~[field_ty] {\n       {\n           let items = cx.items.borrow();\n           match items.get().find(&did.node) {\n-           Some(&ast_map::node_item(i,_)) => {\n+           Some(&ast_map::NodeItem(i,_)) => {\n              match i.node {\n-                ast::item_struct(struct_def, _) => {\n+                ast::ItemStruct(struct_def, _) => {\n                    struct_field_tys(struct_def.fields)\n                 }\n                 _ => cx.sess.bug(\"struct ID bound to non-struct\")\n              }\n            }\n-           Some(&ast_map::node_variant(ref variant, _, _)) => {\n+           Some(&ast_map::NodeVariant(ref variant, _, _)) => {\n               match (*variant).node.kind {\n-                ast::struct_variant_kind(struct_def) => {\n+                ast::StructVariantKind(struct_def) => {\n                   struct_field_tys(struct_def.fields)\n                 }\n                 _ => {\n@@ -4175,22 +4173,22 @@ pub fn lookup_struct_field(cx: ctxt,\n     }\n }\n \n-fn struct_field_tys(fields: &[struct_field]) -> ~[field_ty] {\n+fn struct_field_tys(fields: &[StructField]) -> ~[field_ty] {\n     fields.map(|field| {\n         match field.node.kind {\n-            named_field(ident, visibility) => {\n+            NamedField(ident, visibility) => {\n                 field_ty {\n                     name: ident.name,\n                     id: ast_util::local_def(field.node.id),\n                     vis: visibility,\n                 }\n             }\n-            unnamed_field => {\n+            UnnamedField => {\n                 field_ty {\n                     name:\n                         syntax::parse::token::special_idents::unnamed_field.name,\n                     id: ast_util::local_def(field.node.id),\n-                    vis: ast::public,\n+                    vis: ast::Public,\n                 }\n             }\n         }\n@@ -4417,15 +4415,15 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n }\n \n // Determine what purity to check a nested function under\n-pub fn determine_inherited_purity(parent: (ast::purity, ast::NodeId),\n-                                  child: (ast::purity, ast::NodeId),\n+pub fn determine_inherited_purity(parent: (ast::Purity, ast::NodeId),\n+                                  child: (ast::Purity, ast::NodeId),\n                                   child_sigil: ast::Sigil)\n-                                    -> (ast::purity, ast::NodeId) {\n+                                    -> (ast::Purity, ast::NodeId) {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n     match child_sigil {\n-        ast::BorrowedSigil if child.first() == ast::impure_fn => parent,\n+        ast::BorrowedSigil if child.first() == ast::ImpureFn => parent,\n         _ => child\n     }\n }\n@@ -4674,9 +4672,9 @@ pub fn trait_id_of_impl(tcx: ctxt,\n         None => return None\n     };\n     match node {\n-        &ast_map::node_item(item, _) => {\n+        &ast_map::NodeItem(item, _) => {\n             match item.node {\n-                ast::item_impl(_, Some(ref trait_ref), _, _) => {\n+                ast::ItemImpl(_, Some(ref trait_ref), _, _) => {\n                     Some(node_id_to_trait_ref(tcx, trait_ref.ref_id).def_id)\n                 }\n                 _ => None"}, {"sha": "882fb46e77258e6a31b7a28865a6b5a7e5cae424", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -288,7 +288,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n     }\n \n     fn ast_mt_to_mt<AC:AstConv, RS:RegionScope>(\n-        this: &AC, rscope: &RS, mt: &ast::mt) -> ty::mt {\n+        this: &AC, rscope: &RS, mt: &ast::MutTy) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n@@ -300,29 +300,29 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                   RS:RegionScope>(\n                   this: &AC,\n                   rscope: &RS,\n-                  a_seq_ty: &ast::mt,\n+                  a_seq_ty: &ast::MutTy,\n                   vst: ty::vstore,\n                   constr: |ty::mt| -> ty::t)\n                   -> ty::t {\n         let tcx = this.tcx();\n         debug!(\"mk_pointer(vst={:?})\", vst);\n \n         match a_seq_ty.ty.node {\n-            ast::ty_vec(ty) => {\n+            ast::TyVec(ty) => {\n                 let mut mt = ast_ty_to_mt(this, rscope, ty);\n                 if a_seq_ty.mutbl == ast::MutMutable {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 debug!(\"&[]: vst={:?}\", vst);\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(ref path, ref bounds, id) => {\n+            ast::TyPath(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n                 // restriction is enforced in the below case for ty_path, which\n                 // will run after this as long as the path isn't a trait.\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.get().find(&id) {\n-                    Some(&ast::DefPrimTy(ast::ty_str)) if a_seq_ty.mutbl == ast::MutImmutable => {\n+                    Some(&ast::DefPrimTy(ast::TyStr)) if a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n                     }\n@@ -400,44 +400,44 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n \n \n     let typ = match ast_ty.node {\n-      ast::ty_nil => ty::mk_nil(),\n-      ast::ty_bot => ty::mk_bot(),\n-      ast::ty_box(ty) => {\n-        let mt = ast::mt { ty: ty, mutbl: ast::MutImmutable };\n+      ast::TyNil => ty::mk_nil(),\n+      ast::TyBot => ty::mk_bot(),\n+      ast::TyBox(ty) => {\n+        let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n         mk_pointer(this, rscope, &mt, ty::vstore_box,\n                    |tmt| ty::mk_box(tcx, tmt.ty))\n       }\n-      ast::ty_uniq(ty) => {\n-        let mt = ast::mt { ty: ty, mutbl: ast::MutImmutable };\n+      ast::TyUniq(ty) => {\n+        let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n         mk_pointer(this, rscope, &mt, ty::vstore_uniq,\n                    |tmt| ty::mk_uniq(tcx, tmt))\n       }\n-      ast::ty_vec(ty) => {\n+      ast::TyVec(ty) => {\n         tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n         ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n       }\n-      ast::ty_ptr(ref mt) => {\n+      ast::TyPtr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n       }\n-      ast::ty_rptr(ref region, ref mt) => {\n+      ast::TyRptr(ref region, ref mt) => {\n         let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n         debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n         mk_pointer(this, rscope, mt, ty::vstore_slice(r),\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n-      ast::ty_tup(ref fields) => {\n+      ast::TyTup(ref fields) => {\n         let flds = fields.map(|&t| ast_ty_to_ty(this, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n-      ast::ty_bare_fn(ref bf) => {\n+      ast::TyBareFn(ref bf) => {\n           if bf.decl.variadic && !bf.abis.is_c() {\n             tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n           }\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n                                             bf.abis, bf.decl))\n       }\n-      ast::ty_closure(ref f) => {\n+      ast::TyClosure(ref f) => {\n         if f.sigil == ast::ManagedSigil {\n             tcx.sess.span_err(ast_ty.span,\n                               \"managed closures are not supported\");\n@@ -463,7 +463,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(ref path, ref bounds, id) => {\n+      ast::TyPath(ref path, ref bounds, id) => {\n         let def_map = tcx.def_map.borrow();\n         let a_def = match def_map.get().find(&id) {\n           None => tcx.sess.span_fatal(\n@@ -495,27 +495,27 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           }\n           ast::DefPrimTy(nty) => {\n             match nty {\n-              ast::ty_bool => {\n+              ast::TyBool => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_bool()\n               }\n-              ast::ty_char => {\n+              ast::TyChar => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_char()\n               }\n-              ast::ty_int(it) => {\n+              ast::TyInt(it) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_mach_int(it)\n               }\n-              ast::ty_uint(uit) => {\n+              ast::TyUint(uit) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_mach_uint(uit)\n               }\n-              ast::ty_float(ft) => {\n+              ast::TyFloat(ft) => {\n                 check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                 ty::mk_mach_float(ft)\n               }\n-              ast::ty_str => {\n+              ast::TyStr => {\n                 tcx.sess.span_err(ast_ty.span,\n                                   \"bare `str` is not a type\");\n                 // return /something/ so they can at least get more errors\n@@ -547,7 +547,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           }\n         }\n       }\n-      ast::ty_fixed_length_vec(ty, e) => {\n+      ast::TyFixedLengthVec(ty, e) => {\n         match const_eval::eval_const_expr_partial(&tcx, e) {\n           Ok(ref r) => {\n             match *r {\n@@ -570,10 +570,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           }\n         }\n       }\n-      ast::ty_typeof(_e) => {\n+      ast::TyTypeof(_e) => {\n           tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n       }\n-      ast::ty_infer => {\n+      ast::TyInfer => {\n         // ty_infer should only appear as the type of arguments or return\n         // values in a fn_expr, or as the type of local variables.  Both of\n         // these cases are handled specially and should not descend into this\n@@ -593,28 +593,28 @@ pub fn ty_of_arg<AC:AstConv,\n                  RS:RegionScope>(\n                  this: &AC,\n                  rscope: &RS,\n-                 a: &ast::arg,\n+                 a: &ast::Arg,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n-        ast::ty_infer if expected_ty.is_some() => expected_ty.unwrap(),\n-        ast::ty_infer => this.ty_infer(a.ty.span),\n+        ast::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n+        ast::TyInfer => this.ty_infer(a.ty.span),\n         _ => ast_ty_to_ty(this, rscope, a.ty),\n     }\n }\n \n struct SelfInfo {\n     untransformed_self_ty: ty::t,\n-    explicit_self: ast::explicit_self\n+    explicit_self: ast::ExplicitSelf\n }\n \n pub fn ty_of_method<AC:AstConv>(\n     this: &AC,\n     id: ast::NodeId,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     untransformed_self_ty: ty::t,\n-    explicit_self: ast::explicit_self,\n-    decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n+    explicit_self: ast::ExplicitSelf,\n+    decl: &ast::FnDecl) -> (Option<ty::t>, ty::BareFnTy)\n {\n     let self_info = SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n@@ -628,9 +628,9 @@ pub fn ty_of_method<AC:AstConv>(\n pub fn ty_of_bare_fn<AC:AstConv>(\n     this: &AC,\n     id: ast::NodeId,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     abi: AbiSet,\n-    decl: &ast::fn_decl) -> ty::BareFnTy\n+    decl: &ast::FnDecl) -> ty::BareFnTy\n {\n     let (_, b) = ty_of_method_or_bare_fn(this, id, purity,\n                                          abi, None, decl);\n@@ -640,10 +640,10 @@ pub fn ty_of_bare_fn<AC:AstConv>(\n fn ty_of_method_or_bare_fn<AC:AstConv>(\n     this: &AC,\n     id: ast::NodeId,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     abi: AbiSet,\n     opt_self_info: Option<&SelfInfo>,\n-    decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n+    decl: &ast::FnDecl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n     debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -658,7 +658,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n     let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n     let output_ty = match decl.output.node {\n-        ast::ty_infer => this.ty_infer(decl.output.span),\n+        ast::TyInfer => this.ty_infer(decl.output.span),\n         _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n \n@@ -678,11 +678,11 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n         self_info: &SelfInfo) -> Option<ty::t>\n     {\n         match self_info.explicit_self.node {\n-            ast::sty_static => None,\n-            ast::sty_value(_) => {\n+            ast::SelfStatic => None,\n+            ast::SelfValue(_) => {\n                 Some(self_info.untransformed_self_ty)\n             }\n-            ast::sty_region(ref lifetime, mutability) => {\n+            ast::SelfRegion(ref lifetime, mutability) => {\n                 let region =\n                     opt_ast_region_to_region(this, rscope,\n                                              self_info.explicit_self.span,\n@@ -691,10 +691,10 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::sty_box(_) => {\n+            ast::SelfBox(_) => {\n                 Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n             }\n-            ast::sty_uniq(_) => {\n+            ast::SelfUniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(),\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: ast::MutImmutable}))\n@@ -708,11 +708,11 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     rscope: &RS,\n     id: ast::NodeId,\n     sigil: ast::Sigil,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n     opt_lifetime: &Option<ast::Lifetime>,\n-    decl: &ast::fn_decl,\n+    decl: &ast::FnDecl,\n     expected_sig: Option<ty::FnSig>,\n     span: Span)\n     -> ty::ClosureTy\n@@ -755,8 +755,8 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n-        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n-        ast::ty_infer => this.ty_infer(decl.output.span),\n+        ast::TyInfer if expected_ret_ty.is_some() => expected_ret_ty.unwrap(),\n+        ast::TyInfer => this.ty_infer(decl.output.span),\n         _ => ast_ty_to_ty(this, &rb, decl.output)\n     };\n "}, {"sha": "4a9f7ea36240ffabe9f260ff4dbd84d052ce0632", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -100,8 +100,8 @@ use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n-use syntax::ast::{DefId, sty_value, sty_region, sty_box};\n-use syntax::ast::{sty_uniq, sty_static, NodeId};\n+use syntax::ast::{DefId, SelfValue, SelfRegion, SelfBox};\n+use syntax::ast::{SelfUniq, SelfStatic, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n use syntax::ast_map;\n@@ -505,7 +505,7 @@ impl<'a> LookupContext<'a> {\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n-                m.explicit_self != ast::sty_static &&\n+                m.explicit_self != ast::SelfStatic &&\n                 m.ident.name == self.m_name })\n             {\n                 Some(pos) => {\n@@ -944,7 +944,7 @@ impl<'a> LookupContext<'a> {\n         self.enforce_drop_trait_limitations(candidate);\n \n         // static methods should never have gotten this far:\n-        assert!(candidate.method_ty.explicit_self != sty_static);\n+        assert!(candidate.method_ty.explicit_self != SelfStatic);\n \n         let transformed_self_ty = match candidate.origin {\n             method_object(..) => {\n@@ -1078,27 +1078,27 @@ impl<'a> LookupContext<'a> {\n                                  self_ty: None,\n                                  tps: rcvr_substs.tps.clone()};\n         match method_ty.explicit_self {\n-            ast::sty_static => {\n+            ast::SelfStatic => {\n                 self.bug(~\"static method for object type receiver\");\n             }\n-            ast::sty_value(_) => {\n+            ast::SelfValue(_) => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n-            ast::sty_region(..) | ast::sty_box(..) | ast::sty_uniq(..) => {\n+            ast::SelfRegion(..) | ast::SelfBox(..) | ast::SelfUniq(..) => {\n                 let transformed_self_ty =\n                     method_ty.transformed_self_ty.clone().unwrap();\n                 match ty::get(transformed_self_ty).sty {\n-                    ty::ty_rptr(r, mt) => { // must be sty_region\n+                    ty::ty_rptr(r, mt) => { // must be SelfRegion\n                         ty::mk_trait(self.tcx(), trait_def_id,\n                                      substs, RegionTraitStore(r), mt.mutbl,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_box(_) => { // must be sty_box\n+                    ty::ty_box(_) => { // must be SelfBox\n                         ty::mk_trait(self.tcx(), trait_def_id,\n                                      substs, BoxTraitStore, ast::MutImmutable,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_uniq(mt) => { // must be sty_uniq\n+                    ty::ty_uniq(mt) => { // must be SelfUniq\n                         ty::mk_trait(self.tcx(), trait_def_id,\n                                      substs, UniqTraitStore, mt.mutbl,\n                                      ty::EmptyBuiltinBounds())\n@@ -1133,21 +1133,21 @@ impl<'a> LookupContext<'a> {\n         }\n \n         match candidate.method_ty.explicit_self {\n-            ast::sty_static => { // reason (a) above\n+            ast::SelfStatic => { // reason (a) above\n                 self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"cannot call a method without a receiver \\\n                      through an object\");\n             }\n \n-            ast::sty_value(_) => { // reason (a) above\n+            ast::SelfValue(_) => { // reason (a) above\n                 self.tcx().sess.span_err(\n                     self.expr.span,\n                     \"cannot call a method with a by-value receiver \\\n                      through an object\");\n             }\n \n-            ast::sty_region(..) | ast::sty_box(..) | ast::sty_uniq(..) => {}\n+            ast::SelfRegion(..) | ast::SelfBox(..) | ast::SelfUniq(..) => {}\n         }\n \n         if ty::type_has_self(method_fty) { // reason (a) above\n@@ -1196,16 +1196,16 @@ impl<'a> LookupContext<'a> {\n                self.ty_to_str(rcvr_ty), self.cand_to_str(candidate));\n \n         return match candidate.method_ty.explicit_self {\n-            sty_static => {\n+            SelfStatic => {\n                 debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n-            sty_value(_) => {\n+            SelfValue(_) => {\n                 rcvr_matches_ty(self.fcx, rcvr_ty, candidate)\n             }\n \n-            sty_region(_, m) => {\n+            SelfRegion(_, m) => {\n                 debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n@@ -1222,7 +1222,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            sty_box(m) => {\n+            SelfBox(m) => {\n                 debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(typ) => {\n@@ -1238,7 +1238,7 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            sty_uniq(_) => {\n+            SelfUniq(_) => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n@@ -1312,10 +1312,9 @@ impl<'a> LookupContext<'a> {\n             {\n                 let items = self.tcx().items.borrow();\n                 match items.get().find(&did.node) {\n-                  Some(&ast_map::node_method(m, _, _))\n-                  | Some(&ast_map::node_trait_method(@ast::provided(m),\n-                                                     _,\n-                                                     _)) => {\n+                  Some(&ast_map::NodeMethod(m, _, _))\n+                  | Some(&ast_map::NodeTraitMethod(@ast::Provided(m),\n+                                                   _, _)) => {\n                       m.span\n                   }\n                   _ => fail!(\"report_static_candidate: bad item {:?}\", did)\n@@ -1376,9 +1375,9 @@ impl<'a> LookupContext<'a> {\n     }\n }\n \n-pub fn get_mode_from_explicit_self(explicit_self: ast::explicit_self_) -> SelfMode {\n+pub fn get_mode_from_explicit_self(explicit_self: ast::ExplicitSelf_) -> SelfMode {\n     match explicit_self {\n-        sty_value(_) => ty::ByRef,\n+        SelfValue(_) => ty::ByRef,\n         _ => ty::ByCopy,\n     }\n }"}, {"sha": "a1e360dae8c199fc5c003451fa2b1916c9eceb10", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -116,7 +116,7 @@ use std::result;\n use std::util::replace;\n use std::vec;\n use syntax::abi::AbiSet;\n-use syntax::ast::{provided, required};\n+use syntax::ast::{Provided, Required};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -181,12 +181,12 @@ pub enum FnKind {\n #[deriving(Clone)]\n pub struct PurityState {\n     def: ast::NodeId,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     priv from_fn: bool\n }\n \n impl PurityState {\n-    pub fn function(purity: ast::purity, def: ast::NodeId) -> PurityState {\n+    pub fn function(purity: ast::Purity, def: ast::NodeId) -> PurityState {\n         PurityState { def: def, purity: purity, from_fn: true }\n     }\n \n@@ -196,11 +196,11 @@ impl PurityState {\n             // unsafe we shouldn't attribute the unsafe'ness to the block. This\n             // way the block can be warned about instead of ignoring this\n             // extraneous block (functions are never warned about).\n-            ast::unsafe_fn if self.from_fn => *self,\n+            ast::UnsafeFn if self.from_fn => *self,\n \n             purity => {\n                 let (purity, def) = match blk.rules {\n-                    ast::UnsafeBlock(..) => (ast::unsafe_fn, blk.id),\n+                    ast::UnsafeBlock(..) => (ast::UnsafeFn, blk.id),\n                     ast::DefaultBlock => (purity, self.def),\n                 };\n                 PurityState{ def: def,\n@@ -284,7 +284,7 @@ pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n     @FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n-        ps: RefCell::new(PurityState::function(ast::impure_fn, 0)),\n+        ps: RefCell::new(PurityState::function(ast::ImpureFn, 0)),\n         region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n         inh: @Inherited::new(ccx.tcx, param_env),\n@@ -305,7 +305,7 @@ impl ExprTyProvider for FnCtxt {\n struct CheckItemTypesVisitor { ccx: @CrateCtxt }\n \n impl Visitor<()> for CheckItemTypesVisitor {\n-    fn visit_item(&mut self, i: &ast::item, _: ()) {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n@@ -317,7 +317,7 @@ pub fn check_item_types(ccx: @CrateCtxt, crate: &ast::Crate) {\n }\n \n pub fn check_bare_fn(ccx: @CrateCtxt,\n-                     decl: &ast::fn_decl,\n+                     decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      id: ast::NodeId,\n                      self_info: Option<SelfInfo>,\n@@ -367,7 +367,7 @@ impl Visitor<()> for GatherLocalsVisitor {\n         // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n             let o_ty = match local.ty.node {\n-              ast::ty_infer => None,\n+              ast::TyInfer => None,\n               _ => Some(self.fcx.to_ty(local.ty))\n             };\n             self.assign(local.id, o_ty);\n@@ -409,17 +409,17 @@ impl Visitor<()> for GatherLocalsVisitor {\n     }\n \n     // Don't descend into fns and items\n-    fn visit_fn(&mut self, _: &visit::fn_kind, _: &ast::fn_decl,\n+    fn visit_fn(&mut self, _: &visit::FnKind, _: &ast::FnDecl,\n                 _: &ast::Block, _: Span, _: ast::NodeId, _: ()) { }\n-    fn visit_item(&mut self, _: &ast::item, _: ()) { }\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) { }\n \n }\n \n pub fn check_fn(ccx: @CrateCtxt,\n                 opt_self_info: Option<SelfInfo>,\n-                purity: ast::purity,\n+                purity: ast::Purity,\n                 fn_sig: &ty::FnSig,\n-                decl: &ast::fn_decl,\n+                decl: &ast::FnDecl,\n                 id: ast::NodeId,\n                 body: &ast::Block,\n                 fn_kind: FnKind,\n@@ -506,7 +506,7 @@ pub fn check_fn(ccx: @CrateCtxt,\n     return fcx;\n \n     fn gather_locals(fcx: @FnCtxt,\n-                     decl: &ast::fn_decl,\n+                     decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      arg_tys: &[ty::t],\n                      opt_self_info: Option<SelfInfo>) {\n@@ -576,21 +576,21 @@ pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n+pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n \n     match it.node {\n-      ast::item_static(_, _, e) => check_const(ccx, it.span, e, it.id),\n-      ast::item_enum(ref enum_definition, _) => {\n+      ast::ItemStatic(_, _, e) => check_const(ccx, it.span, e, it.id),\n+      ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n                             enum_definition.variants,\n                             it.id);\n       }\n-      ast::item_fn(decl, _, _, _, body) => {\n+      ast::ItemFn(decl, _, _, _, body) => {\n         let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n         // FIXME(#5121) -- won't work for lifetimes that appear in type bounds\n@@ -604,8 +604,8 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n \n         check_bare_fn(ccx, decl, body, it.id, None, fn_tpt.ty, param_env);\n       }\n-      ast::item_impl(_, ref opt_trait_ref, _, ref ms) => {\n-        debug!(\"item_impl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n+      ast::ItemImpl(_, ref opt_trait_ref, _, ref ms) => {\n+        debug!(\"ItemImpl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n \n         let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n@@ -629,29 +629,29 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n         }\n \n       }\n-      ast::item_trait(_, _, ref trait_methods) => {\n+      ast::ItemTrait(_, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n-              required(..) => {\n-                // Nothing to do, since required methods don't have\n-                // bodies to check.\n-              }\n-              provided(m) => {\n-                check_method_body(ccx, &trait_def.generics,\n-                                  Some(trait_def.trait_ref), m);\n-              }\n+                Required(..) => {\n+                    // Nothing to do, since required methods don't have\n+                    // bodies to check.\n+                }\n+                Provided(m) => {\n+                    check_method_body(ccx, &trait_def.generics,\n+                                      Some(trait_def.trait_ref), m);\n+                }\n             }\n         }\n       }\n-      ast::item_struct(..) => {\n+      ast::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n       }\n-      ast::item_ty(ref t, ref generics) => {\n+      ast::ItemTy(ref t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n-      ast::item_foreign_mod(ref m) => {\n+      ast::ItemForeignMod(ref m) => {\n         if m.abis.is_intrinsic() {\n             for item in m.items.iter() {\n                 check_intrinsic_type(ccx, *item);\n@@ -664,7 +664,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n                 }\n \n                 match item.node {\n-                    ast::foreign_item_fn(ref fn_decl, _) => {\n+                    ast::ForeignItemFn(ref fn_decl, _) => {\n                         if fn_decl.variadic && !m.abis.is_c() {\n                             ccx.tcx.sess.span_err(\n                                 item.span, \"variadic function must have C calling convention\");\n@@ -682,7 +682,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::item) {\n fn check_method_body(ccx: @CrateCtxt,\n                      item_generics: &ty::Generics,\n                      self_bound: Option<@ty::TraitRef>,\n-                     method: &ast::method) {\n+                     method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n      *\n@@ -734,9 +734,9 @@ fn check_method_body(ccx: @CrateCtxt,\n fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n-                                    ast_trait_ref: &ast::trait_ref,\n+                                    ast_trait_ref: &ast::TraitRef,\n                                     impl_trait_ref: &ty::TraitRef,\n-                                    impl_methods: &[@ast::method]) {\n+                                    impl_methods: &[@ast::Method]) {\n     // Locate trait methods\n     let tcx = ccx.tcx;\n     let trait_methods = ty::trait_methods(tcx, impl_trait_ref.def_id);\n@@ -831,8 +831,8 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // inscrutable, particularly for cases where one method has no\n     // self.\n     match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ast::sty_static, &ast::sty_static) => {}\n-        (&ast::sty_static, _) => {\n+        (&ast::SelfStatic, &ast::SelfStatic) => {}\n+        (&ast::SelfStatic, _) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n@@ -842,7 +842,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                                                      tcx.sess.intr())));\n             return;\n         }\n-        (_, &ast::sty_static) => {\n+        (_, &ast::SelfStatic) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n@@ -1378,31 +1378,31 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @FnCtxt, lit: &ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-      ast::lit_str(..) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n-      ast::lit_binary(..) => {\n-          ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                      ty::vstore_slice(ty::ReStatic))\n-      }\n-      ast::lit_char(_) => ty::mk_char(),\n-      ast::lit_int(_, t) => ty::mk_mach_int(t),\n-      ast::lit_uint(_, t) => ty::mk_mach_uint(t),\n-      ast::lit_int_unsuffixed(_) => {\n-        // An unsuffixed integer literal could have any integral type,\n-        // so we create an integral type variable for it.\n-        ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n-      }\n-      ast::lit_float(_, t) => ty::mk_mach_float(t),\n-      ast::lit_float_unsuffixed(_) => {\n-        // An unsuffixed floating point literal could have any floating point\n-        // type, so we create a floating point type variable for it.\n-        ty::mk_float_var(tcx, fcx.infcx().next_float_var_id())\n-      }\n-      ast::lit_nil => ty::mk_nil(),\n-      ast::lit_bool(_) => ty::mk_bool()\n+        ast::LitStr(..) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n+        ast::LitBinary(..) => {\n+            ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n+                        ty::vstore_slice(ty::ReStatic))\n+        }\n+        ast::LitChar(_) => ty::mk_char(),\n+        ast::LitInt(_, t) => ty::mk_mach_int(t),\n+        ast::LitUint(_, t) => ty::mk_mach_uint(t),\n+        ast::LitIntUnsuffixed(_) => {\n+            // An unsuffixed integer literal could have any integral type,\n+            // so we create an integral type variable for it.\n+            ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n+        }\n+        ast::LitFloat(_, t) => ty::mk_mach_float(t),\n+        ast::LitFloatUnsuffixed(_) => {\n+            // An unsuffixed floating point literal could have any floating point\n+            // type, so we create a floating point type variable for it.\n+            ty::mk_float_var(tcx, fcx.infcx().next_float_var_id())\n+        }\n+        ast::LitNil => ty::mk_nil(),\n+        ast::LitBool(_) => ty::mk_bool()\n     }\n }\n \n@@ -1815,17 +1815,17 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = structurally_resolved_type(fcx, arg.span, fcx.expr_ty(*arg));\n                 match ty::get(arg_ty).sty {\n-                    ty::ty_float(ast::ty_f32) => {\n+                    ty::ty_float(ast::TyF32) => {\n                         fcx.type_error_message(arg.span,\n                                 |t| format!(\"can't pass an {} to variadic function, \\\n                                              cast to c_double\", t), arg_ty, None);\n                     }\n-                    ty::ty_int(ast::ty_i8) | ty::ty_int(ast::ty_i16) | ty::ty_bool => {\n+                    ty::ty_int(ast::TyI8) | ty::ty_int(ast::TyI16) | ty::ty_bool => {\n                         fcx.type_error_message(arg.span,\n                                 |t| format!(\"can't pass {} to variadic function, cast to c_int\",\n                                             t), arg_ty, None);\n                     }\n-                    ty::ty_uint(ast::ty_u8) | ty::ty_uint(ast::ty_u16) => {\n+                    ty::ty_uint(ast::TyU8) | ty::ty_uint(ast::TyU16) => {\n                         fcx.type_error_message(arg.span,\n                                 |t| format!(\"can't pass {} to variadic function, cast to c_uint\",\n                                             t), arg_ty, None);\n@@ -2250,7 +2250,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     fn check_expr_fn(fcx: @FnCtxt,\n                      expr: &ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n-                     decl: &ast::fn_decl,\n+                     decl: &ast::FnDecl,\n                      body: ast::P<ast::Block>,\n                      fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n@@ -2295,7 +2295,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                         }\n                         _ => ()\n                     }\n-                    (None, ast::impure_fn, sigil,\n+                    (None, ast::ImpureFn, sigil,\n                      onceness, bounds)\n                 }\n             }\n@@ -2304,7 +2304,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         // If the proto is specified, use that, otherwise select a\n         // proto based on inference.\n         let (sigil, purity) = match ast_sigil_opt {\n-            Some(p) => (p, ast::impure_fn),\n+            Some(p) => (p, ast::ImpureFn),\n             None => (expected_sigil, expected_purity)\n         };\n \n@@ -2622,7 +2622,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     match expr.node {\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::ExprLit(@codemap::Spanned { node: ast::lit_str(..), .. }) => {\n+          ast::ExprLit(@codemap::Spanned { node: ast::LitStr(..), .. }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -3081,7 +3081,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     if type_is_c_like_enum(fcx, expr.span, t_e) && t_1_is_trivial {\n                         // casts from C-like enums are allowed\n                     } else if t_1_is_char {\n-                        if ty::get(te).sty != ty::ty_uint(ast::ty_u8) {\n+                        if ty::get(te).sty != ty::ty_uint(ast::TyU8) {\n                             fcx.type_error_message(expr.span, |actual| {\n                                 format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n                             }, t_e, None);\n@@ -3541,28 +3541,28 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n \n pub fn check_enum_variants(ccx: @CrateCtxt,\n                            sp: Span,\n-                           vs: &[ast::P<ast::variant>],\n+                           vs: &[ast::P<ast::Variant>],\n                            id: ast::NodeId) {\n \n     fn disr_in_range(ccx: @CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: @CrateCtxt, ty: ast::uint_ty, disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: @CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n             match ty {\n-                ast::ty_u8 => disr as u8 as Disr == disr,\n-                ast::ty_u16 => disr as u16 as Disr == disr,\n-                ast::ty_u32 => disr as u32 as Disr == disr,\n-                ast::ty_u64 => disr as u64 as Disr == disr,\n-                ast::ty_u => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n+                ast::TyU8 => disr as u8 as Disr == disr,\n+                ast::TyU16 => disr as u16 as Disr == disr,\n+                ast::TyU32 => disr as u32 as Disr == disr,\n+                ast::TyU64 => disr as u64 as Disr == disr,\n+                ast::TyU => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n             }\n         }\n-        fn int_in_range(ccx: @CrateCtxt, ty: ast::int_ty, disr: ty::Disr) -> bool {\n+        fn int_in_range(ccx: @CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n             match ty {\n-                ast::ty_i8 => disr as i8 as Disr == disr,\n-                ast::ty_i16 => disr as i16 as Disr == disr,\n-                ast::ty_i32 => disr as i32 as Disr == disr,\n-                ast::ty_i64 => disr as i64 as Disr == disr,\n-                ast::ty_i => int_in_range(ccx, ccx.tcx.sess.targ_cfg.int_type, disr)\n+                ast::TyI8 => disr as i8 as Disr == disr,\n+                ast::TyI16 => disr as i16 as Disr == disr,\n+                ast::TyI32 => disr as i32 as Disr == disr,\n+                ast::TyI64 => disr as i64 as Disr == disr,\n+                ast::TyI => int_in_range(ccx, ccx.tcx.sess.targ_cfg.int_type, disr)\n             }\n         }\n         match ty {\n@@ -3572,7 +3572,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n     }\n \n     fn do_check(ccx: @CrateCtxt,\n-                vs: &[ast::P<ast::variant>],\n+                vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n                 -> ~[@ty::VariantInfo] {\n@@ -3975,7 +3975,7 @@ pub fn check_bounds_are_used(ccx: @CrateCtxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::foreign_item) {\n+pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n     fn param(ccx: @CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n@@ -4277,7 +4277,7 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::foreign_item) {\n         }\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-        purity: ast::unsafe_fn,\n+        purity: ast::UnsafeFn,\n         abis: AbiSet::Intrinsic(),\n         sig: FnSig {binder_id: it.id,\n                     inputs: inputs,"}, {"sha": "668163881a9f60dd6257df7ea5e59e785c1b00db", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -175,7 +175,7 @@ impl Visitor<()> for Rcx {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_item(&mut self, i: &ast::item, _: ()) { visit_item(self, i); }\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(self, i); }\n \n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) { visit_expr(self, ex); }\n \n@@ -188,7 +188,7 @@ impl Visitor<()> for Rcx {\n     fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(self, b); }\n }\n \n-fn visit_item(_rcx: &mut Rcx, _item: &ast::item) {\n+fn visit_item(_rcx: &mut Rcx, _item: &ast::Item) {\n     // Ignore items\n }\n "}, {"sha": "d66e53ec8f4b8f69d96ed018d056776eb16277c3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -552,7 +552,7 @@ pub fn location_info_for_expr(expr: &ast::Expr) -> LocationInfo {\n         id: expr.id\n     }\n }\n-pub fn location_info_for_item(item: &ast::item) -> LocationInfo {\n+pub fn location_info_for_item(item: &ast::Item) -> LocationInfo {\n     LocationInfo {\n         span: item.span,\n         id: item.id\n@@ -760,7 +760,7 @@ fn resolve_expr(fcx: @FnCtxt, ex: &ast::Expr) {\n }\n \n pub fn resolve_impl(ccx: @CrateCtxt,\n-                    impl_item: &ast::item,\n+                    impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n     let param_env = ty::construct_parameter_environment(\n@@ -819,7 +819,7 @@ impl visit::Visitor<()> for @FnCtxt {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         resolve_expr(*self, ex);\n     }\n-    fn visit_item(&mut self, _: &ast::item, _: ()) {\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n         // no-op\n     }\n }"}, {"sha": "ef0a595f9b67fece8a618cce24bf476068ec8bfe", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -343,12 +343,12 @@ fn visit_local(l: &ast::Local, wbcx: &mut WbCtxt) {\n     }\n     visit::walk_local(wbcx, l, ());\n }\n-fn visit_item(_item: &ast::item, _wbcx: &mut WbCtxt) {\n+fn visit_item(_item: &ast::Item, _wbcx: &mut WbCtxt) {\n     // Ignore items\n }\n \n impl Visitor<()> for WbCtxt {\n-    fn visit_item(&mut self, i: &ast::item, _: ()) { visit_item(i, self); }\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(i, self); }\n     fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) { visit_stmt(s, self); }\n     fn visit_expr(&mut self, ex:&ast::Expr, _: ()) { visit_expr(ex, self); }\n     fn visit_block(&mut self, b: &ast::Block, _: ()) { visit_block(b, self); }\n@@ -366,7 +366,7 @@ pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n }\n \n pub fn resolve_type_vars_in_fn(fcx: @FnCtxt,\n-                               decl: &ast::fn_decl,\n+                               decl: &ast::FnDecl,\n                                blk: &ast::Block,\n                                self_info: Option<SelfInfo>) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };"}, {"sha": "9466792c62e944c14c8a3402c38625a3530811c9", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -36,10 +36,10 @@ use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use middle::typeck::infer;\n use util::ppaux::Repr;\n use syntax::ast::{Crate, DefId, DefStruct, DefTy};\n-use syntax::ast::{item, item_enum, item_impl, item_mod, item_struct};\n-use syntax::ast::{LOCAL_CRATE, trait_ref, ty_path};\n+use syntax::ast::{Item, ItemEnum, ItemImpl, ItemMod, ItemStruct};\n+use syntax::ast::{LOCAL_CRATE, TraitRef, TyPath};\n use syntax::ast;\n-use syntax::ast_map::node_item;\n+use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::Span;\n@@ -159,13 +159,13 @@ pub struct CoherenceChecker {\n struct CoherenceCheckVisitor { cc: CoherenceChecker }\n \n impl visit::Visitor<()> for CoherenceCheckVisitor {\n-    fn visit_item(&mut self, item: &item, _: ()) {\n+    fn visit_item(&mut self, item: &Item, _: ()) {\n \n //      debug!(\"(checking coherence) item '{}'\",\n //             self.cc.crate_context.tcx.sess.str_of(item.ident));\n \n         match item.node {\n-            item_impl(_, ref opt_trait, _, _) => {\n+            ItemImpl(_, ref opt_trait, _, _) => {\n                 match opt_trait.clone() {\n                     Some(opt_trait) => {\n                         self.cc.check_implementation(item, [opt_trait]);\n@@ -185,14 +185,14 @@ impl visit::Visitor<()> for CoherenceCheckVisitor {\n struct PrivilegedScopeVisitor { cc: CoherenceChecker }\n \n impl visit::Visitor<()> for PrivilegedScopeVisitor {\n-    fn visit_item(&mut self, item: &item, _: ()) {\n+    fn visit_item(&mut self, item: &Item, _: ()) {\n \n         match item.node {\n-            item_mod(ref module_) => {\n+            ItemMod(ref module_) => {\n                 // Then visit the module items.\n                 visit::walk_mod(self, module_, ());\n             }\n-            item_impl(_, None, ast_ty, _) => {\n+            ItemImpl(_, None, ast_ty, _) => {\n                 if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n                     // This is an error.\n                     let session = self.cc.crate_context.tcx.sess;\n@@ -202,7 +202,7 @@ impl visit::Visitor<()> for PrivilegedScopeVisitor {\n                                      a trait or new type instead\");\n                 }\n             }\n-            item_impl(_, Some(ref trait_ref), _, _) => {\n+            ItemImpl(_, Some(ref trait_ref), _, _) => {\n                 // `for_ty` is `Type` in `impl Trait for Type`\n                 let for_ty =\n                     ty::node_id_to_type(self.cc.crate_context.tcx,\n@@ -259,8 +259,8 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation(&self,\n-                                item: &item,\n-                                associated_traits: &[trait_ref]) {\n+                                item: &Item,\n+                                associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -546,7 +546,7 @@ impl CoherenceChecker {\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &trait_ref) -> DefId {\n+    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n         let def_map = self.crate_context.tcx.def_map;\n         let def_map = def_map.borrow();\n         let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n@@ -560,7 +560,7 @@ impl CoherenceChecker {\n     pub fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty)\n                                               -> bool {\n         match original_type.node {\n-            ty_path(_, _, path_id) => {\n+            TyPath(_, _, path_id) => {\n                 let def_map = self.crate_context.tcx.def_map.borrow();\n                 match def_map.get().get_copy(&path_id) {\n                     DefTy(def_id) | DefStruct(def_id) => {\n@@ -577,9 +577,9 @@ impl CoherenceChecker {\n                                     original_type.span,\n                                     \"resolve didn't resolve this type?!\");\n                             }\n-                            Some(&node_item(item, _)) => {\n+                            Some(&NodeItem(item, _)) => {\n                                 match item.node {\n-                                    item_struct(..) | item_enum(..) => true,\n+                                    ItemStruct(..) | ItemEnum(..) => true,\n                                     _ => false,\n                                 }\n                             }\n@@ -594,10 +594,10 @@ impl CoherenceChecker {\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n-    pub fn create_impl_from_item(&self, item: &item) -> @Impl {\n+    pub fn create_impl_from_item(&self, item: &Item) -> @Impl {\n         let tcx = self.crate_context.tcx;\n         match item.node {\n-            item_impl(_, ref trait_refs, _, ref ast_methods) => {\n+            ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n                 let mut methods = ~[];\n                 for ast_method in ast_methods.iter() {\n                     methods.push(ty::method(tcx, local_def(ast_method.id)));\n@@ -630,7 +630,7 @@ impl CoherenceChecker {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n         let items = self.crate_context.tcx.items.borrow();\n         match items.get().find(&implementation.did.node) {\n-            Some(&node_item(item, _)) => {\n+            Some(&NodeItem(item, _)) => {\n                 return item.span;\n             }\n             _ => {\n@@ -736,7 +736,7 @@ impl CoherenceChecker {\n                         {\n                             let items = tcx.items.borrow();\n                             match items.get().find(&impl_info.did.node) {\n-                                Some(&ast_map::node_item(@ref item, _)) => {\n+                                Some(&ast_map::NodeItem(@ref item, _)) => {\n                                     tcx.sess.span_err((*item).span,\n                                                       \"the Drop trait may \\\n                                                        only be implemented \\"}, {"sha": "c5499ffb24131232f1dc37e393cd4d82727f8a40", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -62,11 +62,11 @@ struct CollectItemTypesVisitor {\n }\n \n impl visit::Visitor<()> for CollectItemTypesVisitor {\n-    fn visit_item(&mut self, i: &ast::item, _: ()) {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n-    fn visit_foreign_item(&mut self, i: &ast::foreign_item, _: ()) {\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n         convert_foreign(self.ccx, i);\n         visit::walk_foreign_item(self, i, ());\n     }\n@@ -112,8 +112,8 @@ impl AstConv for CrateCtxt {\n \n         let items = self.tcx.items.borrow();\n         match items.get().find(&id.node) {\n-            Some(&ast_map::node_item(item, _)) => ty_of_item(self, item),\n-            Some(&ast_map::node_foreign_item(foreign_item, abis, _, _)) => {\n+            Some(&ast_map::NodeItem(item, _)) => ty_of_item(self, item),\n+            Some(&ast_map::NodeForeignItem(foreign_item, abis, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item, abis)\n             }\n             ref x => {\n@@ -135,7 +135,7 @@ impl AstConv for CrateCtxt {\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n-                              variants: &[ast::P<ast::variant>],\n+                              variants: &[ast::P<ast::Variant>],\n                               generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n@@ -145,17 +145,17 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         // constructors get turned into functions.\n         let scope = variant.node.id;\n         let result_ty = match variant.node.kind {\n-            ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n+            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n                 ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n \n-            ast::tuple_variant_kind(_) => {\n+            ast::TupleVariantKind(_) => {\n                 enum_ty\n             }\n \n-            ast::struct_variant_kind(struct_def) => {\n+            ast::StructVariantKind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n                     generics: ty_generics(ccx, generics, 0),\n                     ty: enum_ty\n@@ -189,8 +189,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let items = tcx.items.borrow();\n     match items.get().get_copy(&trait_id) {\n-        ast_map::node_item(@ast::item {\n-            node: ast::item_trait(ref generics, _, ref ms),\n+        ast_map::NodeItem(@ast::Item {\n+            node: ast::ItemTrait(ref generics, _, ref ms),\n             ..\n         }, _) => {\n             let trait_ty_generics =\n@@ -200,22 +200,22 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             // store it into the `tcx.methods` table:\n             for m in ms.iter() {\n                 let ty_method = @match m {\n-                    &ast::required(ref m) => {\n+                    &ast::Required(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, m.decl)\n                     }\n \n-                    &ast::provided(ref m) => {\n+                    &ast::Provided(ref m) => {\n                         ty_method_of_trait_method(\n                             ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, m.decl)\n                     }\n                 };\n \n-                if ty_method.explicit_self == ast::sty_static {\n+                if ty_method.explicit_self == ast::SelfStatic {\n                     make_static_method_ty(ccx, trait_id, ty_method,\n                                           &trait_ty_generics);\n                 }\n@@ -227,8 +227,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             // Add an entry mapping\n             let method_def_ids = @ms.map(|m| {\n                 match m {\n-                    &ast::required(ref ty_method) => local_def(ty_method.id),\n-                    &ast::provided(ref method) => local_def(method.id)\n+                    &ast::Required(ref ty_method) => local_def(ty_method.id),\n+                    &ast::Provided(ref method) => local_def(method.id)\n                 }\n             });\n \n@@ -372,10 +372,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  trait_generics: &ty::Generics,\n                                  m_id: &ast::NodeId,\n                                  m_ident: &ast::Ident,\n-                                 m_explicit_self: &ast::explicit_self,\n+                                 m_explicit_self: &ast::ExplicitSelf,\n                                  m_generics: &ast::Generics,\n-                                 m_purity: &ast::purity,\n-                                 m_decl: &ast::fn_decl) -> ty::Method\n+                                 m_purity: &ast::Purity,\n+                                 m_decl: &ast::FnDecl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n         let (transformed_self_ty, fty) =\n@@ -390,7 +390,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             fty,\n             m_explicit_self.node,\n             // assume public, because this is only invoked on trait methods\n-            ast::public,\n+            ast::Public,\n             local_def(*m_id),\n             TraitContainer(local_def(trait_id)),\n             None\n@@ -401,7 +401,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::NodeId,\n                           sp: codemap::Span,\n-                          ast_trait_refs: &[ast::trait_ref])\n+                          ast_trait_refs: &[ast::TraitRef])\n                           -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n@@ -443,7 +443,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n \n pub fn convert_field(ccx: &CrateCtxt,\n                      struct_generics: &ty::Generics,\n-                     v: &ast::struct_field) {\n+                     v: &ast::StructField) {\n     let tt = ccx.to_ty(&ExplicitRscope, v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n@@ -457,11 +457,11 @@ pub fn convert_field(ccx: &CrateCtxt,\n \n fn convert_methods(ccx: &CrateCtxt,\n                    container: MethodContainer,\n-                   ms: &[@ast::method],\n+                   ms: &[@ast::Method],\n                    untransformed_rcvr_ty: ty::t,\n                    rcvr_ty_generics: &ty::Generics,\n                    rcvr_ast_generics: &ast::Generics,\n-                   rcvr_visibility: ast::visibility)\n+                   rcvr_visibility: ast::Visibility)\n {\n     let tcx = ccx.tcx;\n     for m in ms.iter() {\n@@ -505,10 +505,10 @@ fn convert_methods(ccx: &CrateCtxt,\n \n     fn ty_of_method(ccx: &CrateCtxt,\n                     container: MethodContainer,\n-                    m: &ast::method,\n+                    m: &ast::Method,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_generics: &ast::Generics,\n-                    rcvr_visibility: ast::visibility) -> ty::Method\n+                    rcvr_visibility: ast::Visibility) -> ty::Method\n     {\n         let (transformed_self_ty, fty) =\n             astconv::ty_of_method(ccx, m.id, m.purity,\n@@ -551,13 +551,13 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n+pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n     match it.node {\n       // These don't define types.\n-      ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(ref enum_definition, ref generics) => {\n+      ast::ItemForeignMod(_) | ast::ItemMod(_) => {}\n+      ast::ItemEnum(ref enum_definition, ref generics) => {\n           ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n           let tpt = ty_of_item(ccx, it);\n           write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -566,7 +566,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                  enum_definition.variants,\n                                  generics);\n       }\n-      ast::item_impl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n+      ast::ItemImpl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, generics, 0);\n         let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -585,7 +585,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         // from the trait, not the impl. Forcing the visibility to be public\n         // makes things sorta work.\n         let parent_visibility = if opt_trait_ref.is_some() {\n-            ast::public\n+            ast::Public\n         } else {\n             it.vis\n         };\n@@ -609,7 +609,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             }\n         }\n       }\n-      ast::item_trait(ref generics, _, ref trait_methods) => {\n+      ast::ItemTrait(ref generics, _, ref trait_methods) => {\n           let trait_def = trait_def_of_item(ccx, it);\n \n           // Run convert_methods on the provided methods.\n@@ -629,7 +629,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n           // static trait methods. This is somewhat unfortunate.\n           ensure_trait_methods(ccx, it.id);\n       }\n-      ast::item_struct(struct_def, ref generics) => {\n+      ast::ItemStruct(struct_def, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"structure\");\n \n         // Write the class type\n@@ -643,7 +643,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n \n         convert_struct(ccx, struct_def, tpt, it.id);\n       }\n-      ast::item_ty(_, ref generics) => {\n+      ast::ItemTy(_, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -659,7 +659,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n }\n \n pub fn convert_struct(ccx: &CrateCtxt,\n-                      struct_def: &ast::struct_def,\n+                      struct_def: &ast::StructDef,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::NodeId) {\n     let tcx = ccx.tcx;\n@@ -684,7 +684,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                     let mut tcache = tcx.tcache.borrow_mut();\n                     tcache.get().insert(local_def(ctor_id), tpt);\n                 }\n-            } else if struct_def.fields[0].node.kind == ast::unnamed_field {\n+            } else if struct_def.fields[0].node.kind == ast::UnnamedField {\n                 // Tuple-like.\n                 let inputs = {\n                     let tcache = tcx.tcache.borrow();\n@@ -707,7 +707,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     }\n }\n \n-pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n+pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -718,7 +718,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n     // convenient way to extract the ABI. - ndm\n     let items = ccx.tcx.items.borrow();\n     let abis = match items.get().find(&i.id) {\n-        Some(&ast_map::node_foreign_item(_, abis, _, _)) => abis,\n+        Some(&ast_map::NodeForeignItem(_, abis, _, _)) => abis,\n         ref x => {\n             ccx.tcx.sess.bug(format!(\"unexpected sort of item \\\n                                    in get_item_ty(): {:?}\", (*x)));\n@@ -733,7 +733,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n }\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n-                             ast_trait_ref: &ast::trait_ref,\n+                             ast_trait_ref: &ast::TraitRef,\n                              self_ty: ty::t) -> @ty::TraitRef\n {\n     /*!\n@@ -772,13 +772,13 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n \n     let items = ccx.tcx.items.borrow();\n     match items.get().get(&trait_id.node) {\n-        &ast_map::node_item(item, _) => trait_def_of_item(ccx, item),\n+        &ast_map::NodeItem(item, _) => trait_def_of_item(ccx, item),\n         _ => ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n                                    trait_id.node))\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     {\n@@ -790,7 +790,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     }\n \n     match it.node {\n-        ast::item_trait(ref generics, ref supertraits, _) => {\n+        ast::ItemTrait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n@@ -812,7 +812,7 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n     }\n }\n \n-pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n+pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                   -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -824,15 +824,15 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n         }\n     }\n     match it.node {\n-        ast::item_static(t, _, _) => {\n+        ast::ItemStatic(t, _, _) => {\n             let typ = ccx.to_ty(&ExplicitRscope, t);\n             let tpt = no_params(typ);\n \n             let mut tcache = tcx.tcache.borrow_mut();\n             tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_fn(decl, purity, abi, ref generics, _) => {\n+        ast::ItemFn(decl, purity, abi, ref generics, _) => {\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n@@ -855,7 +855,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_ty(t, ref generics) => {\n+        ast::ItemTy(t, ref generics) => {\n             {\n                 let mut tcache = tcx.tcache.borrow_mut();\n                 match tcache.get().find(&local_def(it.id)) {\n@@ -876,7 +876,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_enum(_, ref generics) => {\n+        ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n@@ -890,12 +890,12 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_trait(..) => {\n+        ast::ItemTrait(..) => {\n             tcx.sess.span_bug(\n                 it.span,\n                 format!(\"Invoked ty_of_item on trait\"));\n         }\n-        ast::item_struct(_, ref generics) => {\n+        ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics(ccx, generics, 0);\n             let substs = mk_item_substs(ccx, &ty_generics, None);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n@@ -908,25 +908,25 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcache.get().insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_impl(..) | ast::item_mod(_) |\n-        ast::item_foreign_mod(_) => fail!(),\n-        ast::item_mac(..) => fail!(\"item macros unimplemented\")\n+        ast::ItemImpl(..) | ast::ItemMod(_) |\n+        ast::ItemForeignMod(_) => fail!(),\n+        ast::ItemMac(..) => fail!(\"item macros unimplemented\")\n     }\n }\n \n pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n-                          it: &ast::foreign_item,\n+                          it: &ast::ForeignItem,\n                           abis: AbiSet) -> ty::ty_param_bounds_and_ty\n {\n     match it.node {\n-        ast::foreign_item_fn(fn_decl, ref generics) => {\n+        ast::ForeignItemFn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n                                   fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_static(t, _) => {\n+        ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -1016,7 +1016,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n-                             decl: &ast::fn_decl,\n+                             decl: &ast::FnDecl,\n                              def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n                              abis: AbiSet)\n@@ -1030,7 +1030,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ccx.tcx,\n         ty::BareFnTy {\n             abis: abis,\n-            purity: ast::unsafe_fn,\n+            purity: ast::UnsafeFn,\n             sig: ty::FnSig {binder_id: def_id.node,\n                             inputs: input_tys,\n                             output: output_ty,"}, {"sha": "2b2115173ae57628250bba5ee7d70ab9d4c1b1d7", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -63,7 +63,7 @@ use util::common::indent;\n use util::ppaux::Repr;\n \n use std::result;\n-use syntax::ast::{Onceness, purity};\n+use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n use syntax::opt_vec;\n use syntax::abi::AbiSet;\n@@ -245,7 +245,7 @@ pub trait Combine {\n         }\n     }\n \n-    fn purities(&self, a: purity, b: purity) -> cres<purity>;\n+    fn purities(&self, a: Purity, b: Purity) -> cres<Purity>;\n \n     fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet> {\n         if a == b {\n@@ -591,7 +591,7 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n         this: &C,\n         vid_is_expected: bool,\n         vid: ty::FloatVid,\n-        val: ast::float_ty) -> cres<ty::t>\n+        val: ast::FloatTy) -> cres<ty::t>\n     {\n         if_ok!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(val))"}, {"sha": "075a45e16130ed7f1384340a35cbd1975cb70839", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -21,9 +21,9 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn, MutImmutable, MutMutable};\n-use syntax::ast::{unsafe_fn, NodeId};\n-use syntax::ast::{Onceness, purity};\n+use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n+use syntax::ast::{ExternFn, ImpureFn, UnsafeFn, NodeId};\n+use syntax::ast::{Onceness, Purity};\n use std::hashmap::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n@@ -81,11 +81,11 @@ impl Combine for Glb {\n         Lub(*self.get_ref()).tys(a, b)\n     }\n \n-    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n         match (a, b) {\n-          (extern_fn, _) | (_, extern_fn) => Ok(extern_fn),\n-          (impure_fn, _) | (_, impure_fn) => Ok(impure_fn),\n-          (unsafe_fn, unsafe_fn) => Ok(unsafe_fn)\n+          (ExternFn, _) | (_, ExternFn) => Ok(ExternFn),\n+          (ImpureFn, _) | (_, ImpureFn) => Ok(ImpureFn),\n+          (UnsafeFn, UnsafeFn) => Ok(UnsafeFn)\n         }\n     }\n "}, {"sha": "23bd0600383dd3f3a20173766931b857a13b91ed", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -22,9 +22,9 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use std::hashmap::HashMap;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn, NodeId};\n-use syntax::ast::{unsafe_fn};\n-use syntax::ast::{Onceness, purity};\n+use syntax::ast::{Many, Once, NodeId};\n+use syntax::ast::{ExternFn, ImpureFn, UnsafeFn};\n+use syntax::ast::{Onceness, Purity};\n use util::ppaux::mt_to_str;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n@@ -79,11 +79,11 @@ impl Combine for Lub {\n         Glb(*self.get_ref()).tys(a, b)\n     }\n \n-    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n         match (a, b) {\n-          (unsafe_fn, _) | (_, unsafe_fn) => Ok(unsafe_fn),\n-          (impure_fn, _) | (_, impure_fn) => Ok(impure_fn),\n-          (extern_fn, extern_fn) => Ok(extern_fn),\n+          (UnsafeFn, _) | (_, UnsafeFn) => Ok(UnsafeFn),\n+          (ImpureFn, _) | (_, ImpureFn) => Ok(ImpureFn),\n+          (ExternFn, ExternFn) => Ok(ExternFn),\n         }\n     }\n "}, {"sha": "cb714399c16524b9e494a0aa57991100e4ae5304", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -89,7 +89,7 @@ pub struct InferCtxt {\n \n     // Map from floating variable to the kind of float it represents\n     float_var_bindings: RefCell<ValsAndBindings<ty::FloatVid,\n-                                                Option<ast::float_ty>>>,\n+                                                Option<ast::FloatTy>>>,\n     float_var_counter: Cell<uint>,\n \n     // For region variables."}, {"sha": "498f4707f92b7983a0e08a00a452d033eb87caf5", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -260,8 +260,7 @@ impl ResolveState {\n             if self.should(force_ivar) {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int();\n-                self.infcx.set(vid,\n-                               Root(Some(IntType(ast::ty_i)), node.rank));\n+                self.infcx.set(vid, Root(Some(IntType(ast::TyI)), node.rank));\n                 ty\n             } else {\n                 ty::mk_int_var(self.infcx.tcx, vid)\n@@ -282,7 +281,7 @@ impl ResolveState {\n             if self.should(force_fvar) {\n                 // As a last resort, default to f64.\n                 let ty = ty::mk_f64();\n-                self.infcx.set(vid, Root(Some(ast::ty_f64), node.rank));\n+                self.infcx.set(vid, Root(Some(ast::TyF64), node.rank));\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "6e370a85096c20ac27812d56276be15618ff1e94", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -25,7 +25,7 @@ use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n-use syntax::ast::{Onceness, purity};\n+use syntax::ast::{Onceness, Purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n@@ -87,7 +87,7 @@ impl Combine for Sub {\n         }\n     }\n \n-    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: Purity, b: Purity) -> cres<Purity> {\n         self.lub().purities(a, b).compare(b, || {\n             ty::terr_purity_mismatch(expected_found(self, a, b))\n         })"}, {"sha": "dc8e090596d0cea18d4516fb1b82d53cdf18b2de", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -105,7 +105,7 @@ impl Env {\n         };\n \n         fn search_mod(self: &Env,\n-                      m: &ast::_mod,\n+                      m: &ast::Mod,\n                       idx: uint,\n                       names: &[~str]) -> Option<ast::node_id> {\n             assert!(idx < names.len());\n@@ -118,26 +118,26 @@ impl Env {\n         }\n \n         fn search(self: &Env,\n-                  it: @ast::item,\n+                  it: @ast::Item,\n                   idx: uint,\n                   names: &[~str]) -> Option<ast::node_id> {\n             if idx == names.len() {\n                 return Some(it.id);\n             }\n \n             return match it.node {\n-                ast::item_const(..) | ast::item_fn(..) |\n-                ast::item_foreign_mod(..) | ast::item_ty(..) => {\n+                ast::ItemConst(..) | ast::ItemFn(..) |\n+                ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None\n                 }\n \n-                ast::item_enum(..) | ast::item_struct(..) |\n-                ast::item_trait(..) | ast::item_impl(..) |\n-                ast::item_mac(..) => {\n+                ast::ItemEnum(..) | ast::ItemStruct(..) |\n+                ast::ItemTrait(..) | ast::ItemImpl(..) |\n+                ast::ItemMac(..) => {\n                     None\n                 }\n \n-                ast::item_mod(ref m) => {\n+                ast::ItemMod(ref m) => {\n                     search_mod(self, m, idx, names)\n                 }\n             };\n@@ -185,7 +185,7 @@ impl Env {\n         let inputs = input_tys.map(|t| {mode: ast::expl(ast::by_copy),\n                                         ty: *t});\n         ty::mk_fn(self.tcx, FnTyBase {\n-            meta: FnMeta {purity: ast::impure_fn,\n+            meta: FnMeta {purity: ast::ImpureFn,\n                           proto: ast::ProtoBare,\n                           onceness: ast::Many,\n                           region: ty::ReStatic,"}, {"sha": "d604d68dd54d7f6af4950d80ba372e23e3d4798a", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -82,7 +82,7 @@ impl InferStr for IntVarValue {\n     }\n }\n \n-impl InferStr for ast::float_ty {\n+impl InferStr for ast::FloatTy {\n     fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n         self.to_str()\n     }"}, {"sha": "e34947930fa1cb7aa2942ddf67ac9ed95b4d8c47", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -296,16 +296,15 @@ impl SimplyUnifiable for IntVarValue {\n     }\n }\n \n-impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n+impl UnifyVid<Option<ast::FloatTy>> for ty::FloatVid {\n     fn appropriate_vals_and_bindings<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<ValsAndBindings<ty::FloatVid,\n-                                           Option<ast::float_ty>>> {\n+        -> &'v RefCell<ValsAndBindings<ty::FloatVid, Option<ast::FloatTy>>> {\n         return &infcx.float_var_bindings;\n     }\n }\n \n-impl SimplyUnifiable for ast::float_ty {\n-    fn to_type_err(err: expected_found<ast::float_ty>) -> ty::type_err {\n+impl SimplyUnifiable for ast::FloatTy {\n+    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }\n }"}, {"sha": "d3f075774c5249d423830491749d82ff72b5621e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -152,7 +152,7 @@ pub struct method_map_entry {\n     self_mode: ty::SelfMode,\n \n     // the type of explicit self on the method\n-    explicit_self: ast::explicit_self_,\n+    explicit_self: ast::ExplicitSelf_,\n \n     // method details being invoked\n     origin: method_origin,\n@@ -352,9 +352,9 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n         ty::ty_bare_fn(..) => {\n             let items = tcx.items.borrow();\n             match items.get().find(&main_id) {\n-                Some(&ast_map::node_item(it,_)) => {\n+                Some(&ast_map::NodeItem(it,_)) => {\n                     match it.node {\n-                        ast::item_fn(_, _, _, ref ps, _)\n+                        ast::ItemFn(_, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 main_span,\n@@ -367,7 +367,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 _ => ()\n             }\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-                purity: ast::impure_fn,\n+                purity: ast::ImpureFn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n@@ -398,9 +398,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n         ty::ty_bare_fn(_) => {\n             let items = tcx.items.borrow();\n             match items.get().find(&start_id) {\n-                Some(&ast_map::node_item(it,_)) => {\n+                Some(&ast_map::NodeItem(it,_)) => {\n                     match it.node {\n-                        ast::item_fn(_,_,_,ref ps,_)\n+                        ast::ItemFn(_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 start_span,\n@@ -414,7 +414,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             }\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-                purity: ast::impure_fn,\n+                purity: ast::ImpureFn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n                     binder_id: start_id,"}, {"sha": "b5e5bdfd65bfa8325771d2f695b44ff1b912e549", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -328,7 +328,7 @@ impl<'a> TermsContext<'a> {\n }\n \n impl<'a> Visitor<()> for TermsContext<'a> {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         debug!(\"add_inferreds for item {}\", item.repr(self.tcx));\n \n         let inferreds_on_entry = self.num_inferred();\n@@ -337,16 +337,16 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n         // tcx, we rely on the fact that all inferreds for a particular\n         // item are assigned continuous indices.\n         match item.node {\n-            ast::item_trait(..) => {\n+            ast::ItemTrait(..) => {\n                 self.add_inferred(item.id, SelfParam, 0, item.id);\n             }\n             _ => { }\n         }\n \n         match item.node {\n-            ast::item_enum(_, ref generics) |\n-            ast::item_struct(_, ref generics) |\n-            ast::item_trait(ref generics, _, _) => {\n+            ast::ItemEnum(_, ref generics) |\n+            ast::ItemStruct(_, ref generics) |\n+            ast::ItemTrait(ref generics, _, _) => {\n                 for (i, p) in generics.lifetimes.iter().enumerate() {\n                     self.add_inferred(item.id, RegionParam, i, p.id);\n                 }\n@@ -374,13 +374,13 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n                 visit::walk_item(self, item, ());\n             }\n \n-            ast::item_impl(..) |\n-            ast::item_static(..) |\n-            ast::item_fn(..) |\n-            ast::item_mod(..) |\n-            ast::item_foreign_mod(..) |\n-            ast::item_ty(..) |\n-            ast::item_mac(..) => {\n+            ast::ItemImpl(..) |\n+            ast::ItemStatic(..) |\n+            ast::ItemFn(..) |\n+            ast::ItemMod(..) |\n+            ast::ItemForeignMod(..) |\n+            ast::ItemTy(..) |\n+            ast::ItemMac(..) => {\n                 visit::walk_item(self, item, ());\n             }\n         }\n@@ -433,12 +433,12 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n }\n \n impl<'a> Visitor<()> for ConstraintContext<'a> {\n-    fn visit_item(&mut self, item: &ast::item, _: ()) {\n+    fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let did = ast_util::local_def(item.id);\n         let tcx = self.terms_cx.tcx;\n \n         match item.node {\n-            ast::item_enum(ref enum_definition, _) => {\n+            ast::ItemEnum(ref enum_definition, _) => {\n                 // Hack: If we directly call `ty::enum_variants`, it\n                 // annoyingly takes it upon itself to run off and\n                 // evaluate the discriminants eagerly (*grumpy* that's\n@@ -460,7 +460,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                 }\n             }\n \n-            ast::item_struct(..) => {\n+            ast::ItemStruct(..) => {\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in struct_fields.iter() {\n                     assert_eq!(field_info.id.crate, ast::LOCAL_CRATE);\n@@ -469,7 +469,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                 }\n             }\n \n-            ast::item_trait(..) => {\n+            ast::ItemTrait(..) => {\n                 let methods = ty::trait_methods(tcx, did);\n                 for method in methods.iter() {\n                     match method.transformed_self_ty {\n@@ -493,13 +493,13 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                 }\n             }\n \n-            ast::item_static(..) |\n-            ast::item_fn(..) |\n-            ast::item_mod(..) |\n-            ast::item_foreign_mod(..) |\n-            ast::item_ty(..) |\n-            ast::item_impl(..) |\n-            ast::item_mac(..) => {\n+            ast::ItemStatic(..) |\n+            ast::ItemFn(..) |\n+            ast::ItemMod(..) |\n+            ast::ItemForeignMod(..) |\n+            ast::ItemTy(..) |\n+            ast::ItemImpl(..) |\n+            ast::ItemMac(..) => {\n                 visit::walk_item(self, item, ());\n             }\n         }"}, {"sha": "6ef00fa9d007e42c87fa1971173752f7bd7b3f49", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -74,13 +74,13 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       ReScope(node_id) => {\n         let items = cx.items.borrow();\n         match items.get().find(&node_id) {\n-          Some(&ast_map::node_block(ref blk)) => {\n+          Some(&ast_map::NodeBlock(ref blk)) => {\n             explain_span(cx, \"block\", blk.span)\n           }\n-          Some(&ast_map::node_callee_scope(expr)) => {\n+          Some(&ast_map::NodeCalleeScope(expr)) => {\n               explain_span(cx, \"callee\", expr.span)\n           }\n-          Some(&ast_map::node_expr(expr)) => {\n+          Some(&ast_map::NodeExpr(expr)) => {\n             match expr.node {\n               ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n               ast::ExprMethodCall(..) => {\n@@ -90,11 +90,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n               _ => explain_span(cx, \"expression\", expr.span)\n             }\n           }\n-          Some(&ast_map::node_stmt(stmt)) => {\n+          Some(&ast_map::NodeStmt(stmt)) => {\n               explain_span(cx, \"statement\", stmt.span)\n           }\n-          Some(&ast_map::node_item(it, _)) if (match it.node {\n-                ast::item_fn(..) => true, _ => false}) => {\n+          Some(&ast_map::NodeItem(it, _)) if (match it.node {\n+                ast::ItemFn(..) => true, _ => false}) => {\n               explain_span(cx, \"function body\", it.span)\n           }\n           Some(_) | None => {\n@@ -116,12 +116,12 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n         let items = cx.items.borrow();\n         match items.get().find(&fr.scope_id) {\n-          Some(&ast_map::node_block(ref blk)) => {\n+          Some(&ast_map::NodeBlock(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n-          Some(&ast_map::node_item(it, _)) if match it.node {\n-                ast::item_impl(..) => true, _ => false} => {\n+          Some(&ast_map::NodeItem(it, _)) if match it.node {\n+                ast::ItemImpl(..) => true, _ => false} => {\n             let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n@@ -176,11 +176,11 @@ pub fn bound_region_to_str(cx: ctxt,\n pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n     let items = cx.items.borrow();\n     match items.get().find(&node_id) {\n-      Some(&ast_map::node_block(ref blk)) => {\n+      Some(&ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n              cx.sess.codemap.span_to_str(blk.span))\n       }\n-      Some(&ast_map::node_expr(expr)) => {\n+      Some(&ast_map::NodeExpr(expr)) => {\n         match expr.node {\n           ast::ExprCall(..) => {\n             format!(\"<call at {}>\",\n@@ -314,7 +314,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         ty_to_str(cx, input)\n     }\n     fn bare_fn_to_str(cx: ctxt,\n-                      purity: ast::purity,\n+                      purity: ast::Purity,\n                       abis: AbiSet,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n@@ -326,7 +326,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         };\n \n         match purity {\n-            ast::impure_fn => {}\n+            ast::ImpureFn => {}\n             _ => {\n                 s.push_str(purity.to_str());\n                 s.push_char(' ');\n@@ -368,7 +368,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         }\n \n         match cty.purity {\n-            ast::impure_fn => {}\n+            ast::ImpureFn => {}\n             _ => {\n                 s.push_str(cty.purity.to_str());\n                 s.push_char(' ');\n@@ -449,9 +449,9 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_bot => ~\"!\",\n       ty_bool => ~\"bool\",\n       ty_char => ~\"char\",\n-      ty_int(ast::ty_i) => ~\"int\",\n+      ty_int(ast::TyI) => ~\"int\",\n       ty_int(t) => ast_util::int_ty_to_str(t),\n-      ty_uint(ast::ty_u) => ~\"uint\",\n+      ty_uint(ast::TyU) => ~\"uint\",\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n       ty_float(t) => ast_util::float_ty_to_str(t),\n       ty_box(typ) => ~\"@\" + ty_to_str(cx, typ),\n@@ -665,7 +665,7 @@ impl Repr for ast::Expr {\n     }\n }\n \n-impl Repr for ast::item {\n+impl Repr for ast::Item {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         format!(\"item({})\",\n                 ast_map::node_id_to_str(tcx.items,\n@@ -746,12 +746,12 @@ impl Repr for ast::DefId {\n             {\n                 let items = tcx.items.borrow();\n                 match items.get().find(&self.node) {\n-                    Some(&ast_map::node_item(..)) |\n-                    Some(&ast_map::node_foreign_item(..)) |\n-                    Some(&ast_map::node_method(..)) |\n-                    Some(&ast_map::node_trait_method(..)) |\n-                    Some(&ast_map::node_variant(..)) |\n-                    Some(&ast_map::node_struct_ctor(..)) => {\n+                    Some(&ast_map::NodeItem(..)) |\n+                    Some(&ast_map::NodeForeignItem(..)) |\n+                    Some(&ast_map::NodeMethod(..)) |\n+                    Some(&ast_map::NodeTraitMethod(..)) |\n+                    Some(&ast_map::NodeVariant(..)) |\n+                    Some(&ast_map::NodeStructCtor(..)) => {\n                         return format!(\"{:?}:{}\",\n                                        *self,\n                                        ty::item_path_str(tcx, *self));\n@@ -815,13 +815,13 @@ impl Repr for ast::Ident {\n     }\n }\n \n-impl Repr for ast::explicit_self_ {\n+impl Repr for ast::ExplicitSelf_ {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n-impl Repr for ast::visibility {\n+impl Repr for ast::Visibility {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n@@ -911,12 +911,12 @@ impl Repr for ty::vstore {\n     }\n }\n \n-impl Repr for ast_map::path_elt {\n+impl Repr for ast_map::PathElem {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match *self {\n-            ast_map::path_mod(id) => id.repr(tcx),\n-            ast_map::path_name(id) => id.repr(tcx),\n-            ast_map::path_pretty_name(id, _) => id.repr(tcx),\n+            ast_map::PathMod(id) => id.repr(tcx),\n+            ast_map::PathName(id) => id.repr(tcx),\n+            ast_map::PathPrettyName(id, _) => id.repr(tcx),\n         }\n     }\n }"}, {"sha": "bc70dcb935a975536dc0fef8a059a3c1dc7361e1", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 77, "deletions": 78, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -324,11 +324,11 @@ impl Clean<Generics> for ast::Generics {\n pub struct Method {\n     generics: Generics,\n     self_: SelfTy,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     decl: FnDecl,\n }\n \n-impl Clean<Item> for ast::method {\n+impl Clean<Item> for ast::Method {\n     fn clean(&self) -> Item {\n         Item {\n             name: Some(self.ident.clean()),\n@@ -348,7 +348,7 @@ impl Clean<Item> for ast::method {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyMethod {\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     decl: FnDecl,\n     generics: Generics,\n     self_: SelfTy,\n@@ -381,14 +381,14 @@ pub enum SelfTy {\n     SelfOwned,\n }\n \n-impl Clean<SelfTy> for ast::explicit_self {\n+impl Clean<SelfTy> for ast::ExplicitSelf {\n     fn clean(&self) -> SelfTy {\n         match self.node {\n-            ast::sty_static => SelfStatic,\n-            ast::sty_value(_) => SelfValue,\n-            ast::sty_uniq(_) => SelfOwned,\n-            ast::sty_region(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n-            ast::sty_box(mt) => SelfManaged(mt.clean()),\n+            ast::SelfStatic => SelfStatic,\n+            ast::SelfValue(_) => SelfValue,\n+            ast::SelfUniq(_) => SelfOwned,\n+            ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n+            ast::SelfBox(mt) => SelfManaged(mt.clean()),\n         }\n     }\n }\n@@ -397,7 +397,7 @@ impl Clean<SelfTy> for ast::explicit_self {\n pub struct Function {\n     decl: FnDecl,\n     generics: Generics,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -424,11 +424,11 @@ pub struct ClosureDecl {\n     lifetimes: ~[Lifetime],\n     decl: FnDecl,\n     onceness: ast::Onceness,\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     bounds: ~[TyParamBound]\n }\n \n-impl Clean<ClosureDecl> for ast::TyClosure {\n+impl Clean<ClosureDecl> for ast::ClosureTy {\n     fn clean(&self) -> ClosureDecl {\n         ClosureDecl {\n             sigil: self.sigil,\n@@ -453,7 +453,7 @@ pub struct FnDecl {\n     attrs: ~[Attribute]\n }\n \n-impl Clean<FnDecl> for ast::fn_decl {\n+impl Clean<FnDecl> for ast::FnDecl {\n     fn clean(&self) -> FnDecl {\n         FnDecl {\n             inputs: self.inputs.iter().map(|x| x.clean()).collect(),\n@@ -471,7 +471,7 @@ pub struct Argument {\n     id: ast::NodeId\n }\n \n-impl Clean<Argument> for ast::arg {\n+impl Clean<Argument> for ast::Arg {\n     fn clean(&self) -> Argument {\n         Argument {\n             name: name_from_pat(self.pat),\n@@ -487,11 +487,11 @@ pub enum RetStyle {\n     Return\n }\n \n-impl Clean<RetStyle> for ast::ret_style {\n+impl Clean<RetStyle> for ast::RetStyle {\n     fn clean(&self) -> RetStyle {\n         match *self {\n-            ast::return_val => Return,\n-            ast::noreturn => NoReturn\n+            ast::Return => Return,\n+            ast::NoReturn => NoReturn\n         }\n     }\n }\n@@ -520,7 +520,7 @@ impl Clean<Item> for doctree::Trait {\n     }\n }\n \n-impl Clean<Type> for ast::trait_ref {\n+impl Clean<Type> for ast::TraitRef {\n     fn clean(&self) -> Type {\n         resolve_type(self.path.clean(), None, self.ref_id)\n     }\n@@ -553,11 +553,11 @@ impl TraitMethod {\n     }\n }\n \n-impl Clean<TraitMethod> for ast::trait_method {\n+impl Clean<TraitMethod> for ast::TraitMethod {\n     fn clean(&self) -> TraitMethod {\n         match self {\n-            &ast::required(ref t) => Required(t.clean()),\n-            &ast::provided(ref t) => Provided(t.clean()),\n+            &ast::Required(ref t) => Required(t.clean()),\n+            &ast::Provided(ref t) => Provided(t.clean()),\n         }\n     }\n }\n@@ -567,7 +567,7 @@ impl Clean<TraitMethod> for ast::trait_method {\n /// it does not preserve mutability or boxes.\n #[deriving(Clone, Encodable, Decodable)]\n pub enum Type {\n-    /// structs/enums/traits (anything that'd be an ast::ty_path)\n+    /// structs/enums/traits (anything that'd be an ast::TyPath)\n     ResolvedPath {\n         path: Path,\n         typarams: Option<~[TyParamBound]>,\n@@ -589,7 +589,7 @@ pub enum Type {\n     /// For references to self\n     Self(ast::NodeId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n-    Primitive(ast::prim_ty),\n+    Primitive(ast::PrimTy),\n     Closure(~ClosureDecl),\n     /// extern \"ABI\" fn\n     BareFunction(~BareFunctionDecl),\n@@ -598,9 +598,9 @@ pub enum Type {\n     FixedVector(~Type, ~str),\n     String,\n     Bool,\n-    /// aka ty_nil\n+    /// aka TyNil\n     Unit,\n-    /// aka ty_bot\n+    /// aka TyBot\n     Bottom,\n     Unique(~Type),\n     Managed(~Type),\n@@ -624,22 +624,22 @@ impl Clean<Type> for ast::Ty {\n         let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n-            ty_nil => Unit,\n-            ty_ptr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n-            ty_rptr(ref l, ref m) =>\n+            TyNil => Unit,\n+            TyPtr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n+            TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n                              type_: ~m.ty.clean()},\n-            ty_box(ty) => Managed(~ty.clean()),\n-            ty_uniq(ty) => Unique(~ty.clean()),\n-            ty_vec(ty) => Vector(~ty.clean()),\n-            ty_fixed_length_vec(ty, ref e) => FixedVector(~ty.clean(),\n-                                                          e.span.to_src()),\n-            ty_tup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n-            ty_path(ref p, ref tpbs, id) =>\n+            TyBox(ty) => Managed(~ty.clean()),\n+            TyUniq(ty) => Unique(~ty.clean()),\n+            TyVec(ty) => Vector(~ty.clean()),\n+            TyFixedLengthVec(ty, ref e) => FixedVector(~ty.clean(),\n+                                                       e.span.to_src()),\n+            TyTup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n+            TyPath(ref p, ref tpbs, id) =>\n                 resolve_type(p.clean(), tpbs.clean(), id),\n-            ty_closure(ref c) => Closure(~c.clean()),\n-            ty_bare_fn(ref barefn) => BareFunction(~barefn.clean()),\n-            ty_bot => Bottom,\n+            TyClosure(ref c) => Closure(~c.clean()),\n+            TyBareFn(ref barefn) => BareFunction(~barefn.clean()),\n+            TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }\n     }\n@@ -650,10 +650,10 @@ pub struct StructField {\n     type_: Type,\n }\n \n-impl Clean<Item> for ast::struct_field {\n+impl Clean<Item> for ast::StructField {\n     fn clean(&self) -> Item {\n         let (name, vis) = match self.node.kind {\n-            ast::named_field(id, vis) => (Some(id), Some(vis)),\n+            ast::NamedField(id, vis) => (Some(id), Some(vis)),\n             _ => (None, None)\n         };\n         Item {\n@@ -669,9 +669,9 @@ impl Clean<Item> for ast::struct_field {\n     }\n }\n \n-pub type Visibility = ast::visibility;\n+pub type Visibility = ast::Visibility;\n \n-impl Clean<Option<Visibility>> for ast::visibility {\n+impl Clean<Option<Visibility>> for ast::Visibility {\n     fn clean(&self) -> Option<Visibility> {\n         Some(*self)\n     }\n@@ -713,7 +713,7 @@ pub struct VariantStruct {\n     fields_stripped: bool,\n }\n \n-impl Clean<VariantStruct> for syntax::ast::struct_def {\n+impl Clean<VariantStruct> for syntax::ast::StructDef {\n     fn clean(&self) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n@@ -774,17 +774,17 @@ pub enum VariantKind {\n     StructVariant(VariantStruct),\n }\n \n-impl Clean<VariantKind> for ast::variant_kind {\n+impl Clean<VariantKind> for ast::VariantKind {\n     fn clean(&self) -> VariantKind {\n         match self {\n-            &ast::tuple_variant_kind(ref args) => {\n+            &ast::TupleVariantKind(ref args) => {\n                 if args.len() == 0 {\n                     CLikeVariant\n                 } else {\n                     TupleVariant(args.iter().map(|x| x.ty.clean()).collect())\n                 }\n             },\n-            &ast::struct_variant_kind(ref sd) => StructVariant(sd.clean()),\n+            &ast::StructVariantKind(ref sd) => StructVariant(sd.clean()),\n         }\n     }\n }\n@@ -892,13 +892,13 @@ impl Clean<Item> for doctree::Typedef {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct BareFunctionDecl {\n-    purity: ast::purity,\n+    purity: ast::Purity,\n     generics: Generics,\n     decl: FnDecl,\n     abi: ~str\n }\n \n-impl Clean<BareFunctionDecl> for ast::TyBareFn {\n+impl Clean<BareFunctionDecl> for ast::BareFnTy {\n     fn clean(&self) -> BareFunctionDecl {\n         BareFunctionDecl {\n             purity: self.purity,\n@@ -986,7 +986,7 @@ pub struct ViewItem {\n     inner: ViewItemInner\n }\n \n-impl Clean<Item> for ast::view_item {\n+impl Clean<Item> for ast::ViewItem {\n     fn clean(&self) -> Item {\n         Item {\n             name: None,\n@@ -1007,12 +1007,12 @@ pub enum ViewItemInner {\n     Import(~[ViewPath])\n }\n \n-impl Clean<ViewItemInner> for ast::view_item_ {\n+impl Clean<ViewItemInner> for ast::ViewItem_ {\n     fn clean(&self) -> ViewItemInner {\n         match self {\n-            &ast::view_item_extern_mod(ref i, ref p, ref id) =>\n+            &ast::ViewItemExternMod(ref i, ref p, ref id) =>\n                 ExternMod(i.clean(), p.map(|(ref x, _)| x.to_owned()), *id),\n-            &ast::view_item_use(ref vp) => Import(vp.clean())\n+            &ast::ViewItemUse(ref vp) => Import(vp.clean())\n         }\n     }\n }\n@@ -1033,14 +1033,14 @@ pub struct ImportSource {\n     did: Option<ast::DefId>,\n }\n \n-impl Clean<ViewPath> for ast::view_path {\n+impl Clean<ViewPath> for ast::ViewPath {\n     fn clean(&self) -> ViewPath {\n         match self.node {\n-            ast::view_path_simple(ref i, ref p, id) =>\n+            ast::ViewPathSimple(ref i, ref p, id) =>\n                 SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n-            ast::view_path_glob(ref p, id) =>\n+            ast::ViewPathGlob(ref p, id) =>\n                 GlobImport(resolve_use_source(p.clean(), id)),\n-            ast::view_path_list(ref p, ref pl, id) =>\n+            ast::ViewPathList(ref p, ref pl, id) =>\n                 ImportList(resolve_use_source(p.clean(), id), pl.clean()),\n         }\n     }\n@@ -1052,7 +1052,7 @@ pub struct ViewListIdent {\n     source: Option<ast::DefId>,\n }\n \n-impl Clean<ViewListIdent> for ast::path_list_ident {\n+impl Clean<ViewListIdent> for ast::PathListIdent {\n     fn clean(&self) -> ViewListIdent {\n         ViewListIdent {\n             name: self.node.name.clean(),\n@@ -1061,23 +1061,23 @@ impl Clean<ViewListIdent> for ast::path_list_ident {\n     }\n }\n \n-impl Clean<~[Item]> for ast::foreign_mod {\n+impl Clean<~[Item]> for ast::ForeignMod {\n     fn clean(&self) -> ~[Item] {\n         self.items.clean()\n     }\n }\n \n-impl Clean<Item> for ast::foreign_item {\n+impl Clean<Item> for ast::ForeignItem {\n     fn clean(&self) -> Item {\n         let inner = match self.node {\n-            ast::foreign_item_fn(ref decl, ref generics) => {\n+            ast::ForeignItemFn(ref decl, ref generics) => {\n                 ForeignFunctionItem(Function {\n                     decl: decl.clean(),\n                     generics: generics.clean(),\n-                    purity: ast::extern_fn,\n+                    purity: ast::ExternFn,\n                 })\n             }\n-            ast::foreign_item_static(ref ty, mutbl) => {\n+            ast::ForeignItemStatic(ref ty, mutbl) => {\n                 ForeignStaticItem(Static {\n                     type_: ty.clean(),\n                     mutability: if mutbl {Mutable} else {Immutable},\n@@ -1115,18 +1115,18 @@ impl ToSource for syntax::codemap::Span {\n     }\n }\n \n-fn lit_to_str(lit: &ast::lit) -> ~str {\n+fn lit_to_str(lit: &ast::Lit) -> ~str {\n     match lit.node {\n-        ast::lit_str(st, _) => st.to_owned(),\n-        ast::lit_binary(data) => format!(\"{:?}\", data.as_slice()),\n-        ast::lit_char(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n-        ast::lit_int(i, _t) => i.to_str(),\n-        ast::lit_uint(u, _t) => u.to_str(),\n-        ast::lit_int_unsuffixed(i) => i.to_str(),\n-        ast::lit_float(f, _t) => f.to_str(),\n-        ast::lit_float_unsuffixed(f) => f.to_str(),\n-        ast::lit_bool(b) => b.to_str(),\n-        ast::lit_nil => ~\"\",\n+        ast::LitStr(st, _) => st.to_owned(),\n+        ast::LitBinary(data) => format!(\"{:?}\", data.as_slice()),\n+        ast::LitChar(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n+        ast::LitInt(i, _t) => i.to_str(),\n+        ast::LitUint(u, _t) => u.to_str(),\n+        ast::LitIntUnsuffixed(i) => i.to_str(),\n+        ast::LitFloat(f, _t) => f.to_str(),\n+        ast::LitFloatUnsuffixed(f) => f.to_str(),\n+        ast::LitBool(b) => b.to_str(),\n+        ast::LitNil => ~\"\",\n     }\n }\n \n@@ -1186,8 +1186,8 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n             (i, TypeTrait)\n         },\n         ast::DefPrimTy(p) => match p {\n-            ast::ty_str => return String,\n-            ast::ty_bool => return Bool,\n+            ast::TyStr => return String,\n+            ast::TyBool => return Bool,\n             _ => return Primitive(p)\n         },\n         ast::DefTyParam(i, _) => return Generic(i.node),\n@@ -1204,9 +1204,8 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n         let fqn = csearch::get_item_path(tycx, def_id);\n         let fqn = fqn.move_iter().map(|i| {\n             match i {\n-                ast_map::path_mod(id) |\n-                ast_map::path_name(id) |\n-                ast_map::path_pretty_name(id, _) => id.clean()\n+                ast_map::PathMod(id) | ast_map::PathName(id) |\n+                ast_map::PathPrettyName(id, _) => id.clean()\n             }\n         }).to_owned_vec();\n         ExternalPath{ path: path, typarams: tpbs, fqn: fqn, kind: kind,"}, {"sha": "f1bd3a62e01623ad7f8107ac4e75b88cbd18b269", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,18 +28,18 @@ pub struct Module {\n     typedefs: ~[Typedef],\n     statics: ~[Static],\n     traits: ~[Trait],\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     impls: ~[Impl],\n-    foreigns: ~[ast::foreign_mod],\n-    view_items: ~[ast::view_item],\n+    foreigns: ~[ast::ForeignMod],\n+    view_items: ~[ast::ViewItem],\n }\n \n impl Module {\n     pub fn new(name: Option<Ident>) -> Module {\n         Module {\n             name       : name,\n             id: 0,\n-            vis: ast::private,\n+            vis: ast::Private,\n             where: syntax::codemap::DUMMY_SP,\n             attrs      : ~[],\n             structs    : ~[],\n@@ -70,22 +70,22 @@ pub enum StructType {\n \n pub enum TypeBound {\n     RegionBound,\n-    TraitBound(ast::trait_ref)\n+    TraitBound(ast::TraitRef)\n }\n \n pub struct Struct {\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     id: NodeId,\n     struct_type: StructType,\n     name: Ident,\n     generics: ast::Generics,\n     attrs: ~[ast::Attribute],\n-    fields: ~[ast::struct_field],\n+    fields: ~[ast::StructField],\n     where: Span,\n }\n \n pub struct Enum {\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     variants: ~[Variant],\n     generics: ast::Generics,\n     attrs: ~[ast::Attribute],\n@@ -97,19 +97,19 @@ pub struct Enum {\n pub struct Variant {\n     name: Ident,\n     attrs: ~[ast::Attribute],\n-    kind: ast::variant_kind,\n+    kind: ast::VariantKind,\n     id: ast::NodeId,\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     where: Span,\n }\n \n pub struct Function {\n-    decl: ast::fn_decl,\n+    decl: ast::FnDecl,\n     attrs: ~[ast::Attribute],\n     id: NodeId,\n     name: Ident,\n-    vis: ast::visibility,\n-    purity: ast::purity,\n+    vis: ast::Visibility,\n+    purity: ast::Purity,\n     where: Span,\n     generics: ast::Generics,\n }\n@@ -121,7 +121,7 @@ pub struct Typedef {\n     id: ast::NodeId,\n     attrs: ~[ast::Attribute],\n     where: Span,\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n }\n \n pub struct Static {\n@@ -130,34 +130,34 @@ pub struct Static {\n     expr: @ast::Expr,\n     name: Ident,\n     attrs: ~[ast::Attribute],\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     id: ast::NodeId,\n     where: Span,\n }\n \n pub struct Trait {\n     name: Ident,\n-    methods: ~[ast::trait_method], //should be TraitMethod\n+    methods: ~[ast::TraitMethod], //should be TraitMethod\n     generics: ast::Generics,\n-    parents: ~[ast::trait_ref],\n+    parents: ~[ast::TraitRef],\n     attrs: ~[ast::Attribute],\n     id: ast::NodeId,\n     where: Span,\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n }\n \n pub struct Impl {\n     generics: ast::Generics,\n-    trait_: Option<ast::trait_ref>,\n+    trait_: Option<ast::TraitRef>,\n     for_: ast::P<ast::Ty>,\n-    methods: ~[@ast::method],\n+    methods: ~[@ast::Method],\n     attrs: ~[ast::Attribute],\n     where: Span,\n-    vis: ast::visibility,\n+    vis: ast::Visibility,\n     id: ast::NodeId,\n }\n \n-pub fn struct_type_from_def(sd: &ast::struct_def) -> StructType {\n+pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {\n     if sd.ctor_id.is_some() {\n         // We are in a tuple-struct\n         match sd.fields.len() {"}, {"sha": "0838085b9cbeee57633104ea82ddd84f54f2bd1a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,21 +28,21 @@ use html::render::{cache_key, current_location_key};\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n-pub struct VisSpace(Option<ast::visibility>);\n+pub struct VisSpace(Option<ast::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a purity with a\n /// space after it.\n-pub struct PuritySpace(ast::purity);\n+pub struct PuritySpace(ast::Purity);\n /// Wrapper struct for properly emitting a method declaration.\n pub struct Method<'a>(&'a clean::SelfTy, &'a clean::FnDecl);\n \n impl VisSpace {\n-    pub fn get(&self) -> Option<ast::visibility> {\n+    pub fn get(&self) -> Option<ast::Visibility> {\n         let VisSpace(v) = *self; v\n     }\n }\n \n impl PuritySpace {\n-    pub fn get(&self) -> ast::purity {\n+    pub fn get(&self) -> ast::Purity {\n         let PuritySpace(v) = *self; v\n     }\n }\n@@ -290,21 +290,21 @@ impl fmt::Default for clean::Type {\n             clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n-                    ast::ty_int(ast::ty_i) => \"int\",\n-                    ast::ty_int(ast::ty_i8) => \"i8\",\n-                    ast::ty_int(ast::ty_i16) => \"i16\",\n-                    ast::ty_int(ast::ty_i32) => \"i32\",\n-                    ast::ty_int(ast::ty_i64) => \"i64\",\n-                    ast::ty_uint(ast::ty_u) => \"uint\",\n-                    ast::ty_uint(ast::ty_u8) => \"u8\",\n-                    ast::ty_uint(ast::ty_u16) => \"u16\",\n-                    ast::ty_uint(ast::ty_u32) => \"u32\",\n-                    ast::ty_uint(ast::ty_u64) => \"u64\",\n-                    ast::ty_float(ast::ty_f32) => \"f32\",\n-                    ast::ty_float(ast::ty_f64) => \"f64\",\n-                    ast::ty_str => \"str\",\n-                    ast::ty_bool => \"bool\",\n-                    ast::ty_char => \"char\",\n+                    ast::TyInt(ast::TyI) => \"int\",\n+                    ast::TyInt(ast::TyI8) => \"i8\",\n+                    ast::TyInt(ast::TyI16) => \"i16\",\n+                    ast::TyInt(ast::TyI32) => \"i32\",\n+                    ast::TyInt(ast::TyI64) => \"i64\",\n+                    ast::TyUint(ast::TyU) => \"uint\",\n+                    ast::TyUint(ast::TyU8) => \"u8\",\n+                    ast::TyUint(ast::TyU16) => \"u16\",\n+                    ast::TyUint(ast::TyU32) => \"u32\",\n+                    ast::TyUint(ast::TyU64) => \"u64\",\n+                    ast::TyFloat(ast::TyF32) => \"f32\",\n+                    ast::TyFloat(ast::TyF64) => \"f64\",\n+                    ast::TyStr => \"str\",\n+                    ast::TyBool => \"bool\",\n+                    ast::TyChar => \"char\",\n                 };\n                 f.buf.write(s.as_bytes());\n             }\n@@ -437,19 +437,19 @@ impl<'a> fmt::Default for Method<'a> {\n impl fmt::Default for VisSpace {\n     fn fmt(v: &VisSpace, f: &mut fmt::Formatter) {\n         match v.get() {\n-            Some(ast::public) => { write!(f.buf, \"pub \"); }\n-            Some(ast::private) => { write!(f.buf, \"priv \"); }\n-            Some(ast::inherited) | None => {}\n+            Some(ast::Public) => { write!(f.buf, \"pub \"); }\n+            Some(ast::Private) => { write!(f.buf, \"priv \"); }\n+            Some(ast::Inherited) | None => {}\n         }\n     }\n }\n \n impl fmt::Default for PuritySpace {\n     fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) {\n         match p.get() {\n-            ast::unsafe_fn => write!(f.buf, \"unsafe \"),\n-            ast::extern_fn => write!(f.buf, \"extern \"),\n-            ast::impure_fn => {}\n+            ast::UnsafeFn => write!(f.buf, \"unsafe \"),\n+            ast::ExternFn => write!(f.buf, \"extern \"),\n+            ast::ImpureFn => {}\n         }\n     }\n }"}, {"sha": "35eb9e88a4a62e02775bfced8e2cd80bb95109e2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -1149,7 +1149,7 @@ fn item_trait(w: &mut Writer, it: &clean::Item, t: &clean::Trait) {\n }\n \n fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n-    fn fun(w: &mut Writer, it: &clean::Item, purity: ast::purity,\n+    fn fun(w: &mut Writer, it: &clean::Item, purity: ast::Purity,\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n            withlink: bool) {\n         write!(w, \"{}fn {withlink, select,\n@@ -1158,7 +1158,7 @@ fn render_method(w: &mut Writer, meth: &clean::Item, withlink: bool) {\n                             other{<span class='fnname'>{name}</span>}\n                         }{generics}{decl}\",\n                match purity {\n-                   ast::unsafe_fn => \"unsafe \",\n+                   ast::UnsafeFn => \"unsafe \",\n                    _ => \"\",\n                },\n                ty = shortty(it),"}, {"sha": "f333c98789cccbd652908f20a237288999cf2565", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -96,13 +96,13 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             }\n \n             clean::ViewItemItem(..) => {\n-                if i.visibility != Some(ast::public) {\n+                if i.visibility != Some(ast::Public) {\n                     return None\n                 }\n             }\n \n             clean::StructFieldItem(..) => {\n-                if i.visibility == Some(ast::private) {\n+                if i.visibility == Some(ast::Private) {\n                     return None;\n                 }\n             }"}, {"sha": "ce29584f5b9d12774de6fc3b9f426a1488fb871a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -42,13 +42,12 @@ impl<'a> RustdocVisitor<'a> {\n         self.attrs = crate.attrs.clone();\n \n         self.module = self.visit_mod_contents(crate.span, crate.attrs.clone(),\n-                                              ast::public, ast::CRATE_NODE_ID,\n+                                              ast::Public, ast::CRATE_NODE_ID,\n                                               &crate.module, None);\n     }\n \n-    pub fn visit_struct_def(&mut self, item: &ast::item, sd: @ast::struct_def,\n-\n-                        generics: &ast::Generics) -> Struct {\n+    pub fn visit_struct_def(&mut self, item: &ast::Item, sd: @ast::StructDef,\n+                            generics: &ast::Generics) -> Struct {\n         debug!(\"Visiting struct\");\n         let struct_type = struct_type_from_def(sd);\n         Struct {\n@@ -63,8 +62,8 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_enum_def(&mut self, it: &ast::item, def: &ast::enum_def,\n-                      params: &ast::Generics) -> Enum {\n+    pub fn visit_enum_def(&mut self, it: &ast::Item, def: &ast::EnumDef,\n+                          params: &ast::Generics) -> Enum {\n         debug!(\"Visiting enum\");\n         let mut vars: ~[Variant] = ~[];\n         for x in def.variants.iter() {\n@@ -88,8 +87,8 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_fn(&mut self, item: &ast::item, fd: &ast::fn_decl,\n-                    purity: &ast::purity, _abi: &AbiSet,\n+    pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n+                    purity: &ast::Purity, _abi: &AbiSet,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n@@ -105,8 +104,8 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     pub fn visit_mod_contents(&mut self, span: Span, attrs: ~[ast::Attribute],\n-                              vis: ast::visibility, id: ast::NodeId,\n-                              m: &ast::_mod,\n+                              vis: ast::Visibility, id: ast::NodeId,\n+                              m: &ast::Mod,\n                               name: Option<ast::Ident>) -> Module {\n         let mut om = Module::new(name);\n         for item in m.view_items.iter() {\n@@ -122,36 +121,36 @@ impl<'a> RustdocVisitor<'a> {\n         om\n     }\n \n-    pub fn visit_view_item(&mut self, item: &ast::view_item, om: &mut Module) {\n-        if item.vis != ast::public {\n+    pub fn visit_view_item(&mut self, item: &ast::ViewItem, om: &mut Module) {\n+        if item.vis != ast::Public {\n             return om.view_items.push(item.clone());\n         }\n         let item = match item.node {\n-            ast::view_item_use(ref paths) => {\n+            ast::ViewItemUse(ref paths) => {\n                 // rustc no longer supports \"use foo, bar;\"\n                 assert_eq!(paths.len(), 1);\n                 match self.visit_view_path(paths[0], om) {\n                     None => return,\n                     Some(path) => {\n-                        ast::view_item {\n-                            node: ast::view_item_use(~[path]),\n+                        ast::ViewItem {\n+                            node: ast::ViewItemUse(~[path]),\n                             .. item.clone()\n                         }\n                     }\n                 }\n             }\n-            ast::view_item_extern_mod(..) => item.clone()\n+            ast::ViewItemExternMod(..) => item.clone()\n         };\n         om.view_items.push(item);\n     }\n \n-    fn visit_view_path(&mut self, path: @ast::view_path,\n-                       om: &mut Module) -> Option<@ast::view_path> {\n+    fn visit_view_path(&mut self, path: @ast::ViewPath,\n+                       om: &mut Module) -> Option<@ast::ViewPath> {\n         match path.node {\n-            ast::view_path_simple(_, _, id) => {\n+            ast::ViewPathSimple(_, _, id) => {\n                 if self.resolve_id(id, false, om) { return None }\n             }\n-            ast::view_path_list(ref p, ref paths, ref b) => {\n+            ast::ViewPathList(ref p, ref paths, ref b) => {\n                 let mut mine = ~[];\n                 for path in paths.iter() {\n                     if !self.resolve_id(path.node.id, false, om) {\n@@ -161,13 +160,13 @@ impl<'a> RustdocVisitor<'a> {\n \n                 if mine.len() == 0 { return None }\n                 return Some(@::syntax::codemap::Spanned {\n-                    node: ast::view_path_list(p.clone(), mine, b.clone()),\n+                    node: ast::ViewPathList(p.clone(), mine, b.clone()),\n                     span: path.span,\n                 })\n             }\n \n             // these are feature gated anyway\n-            ast::view_path_glob(_, id) => {\n+            ast::ViewPathGlob(_, id) => {\n                 if self.resolve_id(id, true, om) { return None }\n             }\n         }\n@@ -194,10 +193,10 @@ impl<'a> RustdocVisitor<'a> {\n             *items.get().get(&def.node)\n         };\n         match item {\n-            ast_map::node_item(it, _) => {\n+            ast_map::NodeItem(it, _) => {\n                 if glob {\n                     match it.node {\n-                        ast::item_mod(ref m) => {\n+                        ast::ItemMod(ref m) => {\n                             for vi in m.view_items.iter() {\n                                 self.visit_view_item(vi, om);\n                             }\n@@ -216,21 +215,21 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_item(&mut self, item: &ast::item, om: &mut Module) {\n+    pub fn visit_item(&mut self, item: &ast::Item, om: &mut Module) {\n         debug!(\"Visiting item {:?}\", item);\n         match item.node {\n-            ast::item_mod(ref m) => {\n+            ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span, item.attrs.clone(),\n                                                 item.vis, item.id, m,\n                                                 Some(item.ident)));\n             },\n-            ast::item_enum(ref ed, ref gen) =>\n+            ast::ItemEnum(ref ed, ref gen) =>\n                 om.enums.push(self.visit_enum_def(item, ed, gen)),\n-            ast::item_struct(sd, ref gen) =>\n+            ast::ItemStruct(sd, ref gen) =>\n                 om.structs.push(self.visit_struct_def(item, sd, gen)),\n-            ast::item_fn(fd, ref pur, ref abi, ref gen, _) =>\n+            ast::ItemFn(fd, ref pur, ref abi, ref gen, _) =>\n                 om.fns.push(self.visit_fn(item, fd, pur, abi, gen)),\n-            ast::item_ty(ty, ref gen) => {\n+            ast::ItemTy(ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty,\n                     gen: gen.clone(),\n@@ -242,7 +241,7 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.typedefs.push(t);\n             },\n-            ast::item_static(ty, ref mut_, ref exp) => {\n+            ast::ItemStatic(ty, ref mut_, ref exp) => {\n                 let s = Static {\n                     type_: ty,\n                     mutability: mut_.clone(),\n@@ -255,7 +254,7 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.statics.push(s);\n             },\n-            ast::item_trait(ref gen, ref tr, ref met) => {\n+            ast::ItemTrait(ref gen, ref tr, ref met) => {\n                 let t = Trait {\n                     name: item.ident,\n                     methods: met.clone(),\n@@ -268,7 +267,7 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.traits.push(t);\n             },\n-            ast::item_impl(ref gen, ref tr, ty, ref meths) => {\n+            ast::ItemImpl(ref gen, ref tr, ty, ref meths) => {\n                 let i = Impl {\n                     generics: gen.clone(),\n                     trait_: tr.clone(),\n@@ -281,7 +280,7 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.impls.push(i);\n             },\n-            ast::item_foreign_mod(ref fm) => {\n+            ast::ItemForeignMod(ref fm) => {\n                 om.foreigns.push(fm.clone());\n             }\n             _ => (),"}, {"sha": "135b659871dd74f74fbe26f57d3216f5ca3cce0d", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -88,7 +88,7 @@ struct PkgScript<'a> {\n     /// The config for compiling the custom build script\n     cfg: ast::CrateConfig,\n     /// The crate and ast_map for the custom build script\n-    crate_and_map: Option<(ast::Crate, syntax::ast_map::map)>,\n+    crate_and_map: Option<(ast::Crate, syntax::ast_map::Map)>,\n     /// Directory in which to store build output\n     build_dir: Path\n }"}, {"sha": "73356078eaca482cf3d3da0bebec219c609c6516", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -23,7 +23,7 @@ use syntax::codemap::{DUMMY_SP, Spanned};\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n-use syntax::fold::ast_fold;\n+use syntax::fold::Folder;\n use syntax::visit::Visitor;\n use syntax::util::small_vector::SmallVector;\n use rustc::back::link::output_type_exe;\n@@ -70,9 +70,9 @@ struct ReadyCtx {\n     fns: ~[ListenerFn]\n }\n \n-fn fold_mod(m: &ast::_mod, fold: &mut CrateSetup) -> ast::_mod {\n-    fn strip_main(item: @ast::item) -> @ast::item {\n-        @ast::item {\n+fn fold_mod(m: &ast::Mod, fold: &mut CrateSetup) -> ast::Mod {\n+    fn strip_main(item: @ast::Item) -> @ast::Item {\n+        @ast::Item {\n             attrs: item.attrs.iter().filter_map(|attr| {\n                 if \"main\" != attr.name() {\n                     Some(*attr)\n@@ -84,14 +84,14 @@ fn fold_mod(m: &ast::_mod, fold: &mut CrateSetup) -> ast::_mod {\n         }\n     }\n \n-    fold::noop_fold_mod(&ast::_mod {\n+    fold::noop_fold_mod(&ast::Mod {\n         items: m.items.map(|item| strip_main(*item)),\n         .. (*m).clone()\n     }, fold)\n }\n \n-fn fold_item(item: @ast::item, fold: &mut CrateSetup)\n-             -> SmallVector<@ast::item> {\n+fn fold_item(item: @ast::Item, fold: &mut CrateSetup)\n+             -> SmallVector<@ast::Item> {\n     fold.ctx.path.push(item.ident);\n \n     let mut cmds = ~[];\n@@ -133,11 +133,11 @@ struct CrateSetup<'a> {\n     ctx: &'a mut ReadyCtx,\n }\n \n-impl<'a> fold::ast_fold for CrateSetup<'a> {\n-    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n+impl<'a> fold::Folder for CrateSetup<'a> {\n+    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         fold_item(item, self)\n     }\n-    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n         fold_mod(module, self)\n     }\n }\n@@ -350,7 +350,7 @@ pub fn compile_crate_from_input(input: &Path,\n // Returns None if one of the flags that suppresses compilation output was\n // given\n                                 crate: ast::Crate,\n-                                ast_map: syntax::ast_map::map,\n+                                ast_map: syntax::ast_map::Map,\n                                 what: OutputType) -> Option<Path> {\n     debug!(\"Calling build_output_filenames with {}, building library? {:?}\",\n            out_dir.display(), sess.building_library);\n@@ -447,12 +447,12 @@ struct ViewItemVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n+    fn visit_view_item(&mut self, vi: &ast::ViewItem, env: ()) {\n         use conditions::nonexistent_package::cond;\n \n         match vi.node {\n             // ignore metadata, I guess\n-            ast::view_item_extern_mod(lib_ident, path_opt, _) => {\n+            ast::ViewItemExternMod(lib_ident, path_opt, _) => {\n                 let lib_name = match path_opt {\n                     Some((p, _)) => p,\n                     None => self.sess.str_of(lib_ident)\n@@ -619,9 +619,9 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n     visit::walk_crate(&mut visitor, c, ())\n }\n \n-pub fn mk_string_lit(s: @str) -> ast::lit {\n+pub fn mk_string_lit(s: @str) -> ast::Lit {\n     Spanned {\n-        node: ast::lit_str(s, ast::CookedStr),\n+        node: ast::LitStr(s, ast::CookedStr),\n         span: DUMMY_SP\n     }\n }"}, {"sha": "9194acfcdec4592304fed100d657405f1edb71c6", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -32,6 +32,7 @@ pub enum Abi {\n     RustIntrinsic,\n }\n \n+#[allow(non_camel_case_types)]\n #[deriving(Eq)]\n pub enum Architecture {\n     // NB. You cannot change the ordering of these"}, {"sha": "2458577aa86ab6e71e2e81846afe4242f922a1f4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 222, "deletions": 215, "changes": 437, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -197,7 +197,7 @@ pub static DUMMY_NODE_ID: NodeId = -1;\n // detects Copy, Send, Send, and Freeze.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum TyParamBound {\n-    TraitTyParamBound(trait_ref),\n+    TraitTyParamBound(TraitRef),\n     RegionTyParamBound\n }\n \n@@ -234,8 +234,8 @@ pub enum MethodProvenance {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum Def {\n-    DefFn(DefId, purity),\n-    DefStaticMethod(/* method */ DefId, MethodProvenance, purity),\n+    DefFn(DefId, Purity),\n+    DefStaticMethod(/* method */ DefId, MethodProvenance, Purity),\n     DefSelf(NodeId, bool /* is_mutbl */),\n     DefSelfTy(/* trait id */ NodeId),\n     DefMod(DefId),\n@@ -246,7 +246,7 @@ pub enum Def {\n     DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n     DefTy(DefId),\n     DefTrait(DefId),\n-    DefPrimTy(prim_ty),\n+    DefPrimTy(PrimTy),\n     DefTyParam(DefId, uint),\n     DefBinding(NodeId, BindingMode),\n     DefUse(DefId),\n@@ -256,13 +256,13 @@ pub enum Def {\n               NodeId), // id for the block/body of the closure expr\n \n     /// Note that if it's a tuple struct's definition, the node id of the DefId\n-    /// may either refer to the item definition's id or the struct_def.ctor_id.\n+    /// may either refer to the item definition's id or the StructDef.ctor_id.\n     ///\n     /// The cases that I have encountered so far are (this is not exhaustive):\n     /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n     ///   it to a def whose id is the item definition's id.\n     /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the struct_def.ctor_id.\n+    ///   it to a def whose id is the StructDef.ctor_id.\n     DefStruct(DefId),\n     DefTyParamBinder(NodeId), /* struct, impl or trait with ty params */\n     DefRegion(NodeId),\n@@ -284,7 +284,7 @@ pub type CrateConfig = ~[@MetaItem];\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Crate {\n-    module: _mod,\n+    module: Mod,\n     attrs: ~[Attribute],\n     config: CrateConfig,\n     span: Span,\n@@ -296,7 +296,7 @@ pub type MetaItem = Spanned<MetaItem_>;\n pub enum MetaItem_ {\n     MetaWord(@str),\n     MetaList(@str, ~[@MetaItem]),\n-    MetaNameValue(@str, lit),\n+    MetaNameValue(@str, Lit),\n }\n \n // can't be derived because the MetaList requires an unordered comparison\n@@ -326,7 +326,7 @@ impl Eq for MetaItem_ {\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n pub struct Block {\n-    view_items: ~[view_item],\n+    view_items: ~[ViewItem],\n     stmts: ~[@Stmt],\n     expr: Option<@Expr>,\n     id: NodeId,\n@@ -464,7 +464,7 @@ pub enum Stmt_ {\n     StmtSemi(@Expr, NodeId),\n \n     // bool: is there a trailing sem-colon?\n-    StmtMac(mac, bool),\n+    StmtMac(Mac, bool),\n }\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n@@ -486,7 +486,7 @@ pub enum Decl_ {\n     // a local (let) binding:\n     DeclLocal(@Local),\n     // an item binding:\n-    DeclItem(@item),\n+    DeclItem(@Item),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -553,7 +553,7 @@ pub enum Expr_ {\n     ExprTup(~[@Expr]),\n     ExprBinary(NodeId, BinOp, @Expr, @Expr),\n     ExprUnary(NodeId, UnOp, @Expr),\n-    ExprLit(@lit),\n+    ExprLit(@Lit),\n     ExprCast(@Expr, P<Ty>),\n     ExprIf(@Expr, P<Block>, Option<@Expr>),\n     ExprWhile(@Expr, P<Block>),\n@@ -563,8 +563,8 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(@Expr, ~[Arm]),\n-    ExprFnBlock(P<fn_decl>, P<Block>),\n-    ExprProc(P<fn_decl>, P<Block>),\n+    ExprFnBlock(P<FnDecl>, P<Block>),\n+    ExprProc(P<FnDecl>, P<Block>),\n     ExprDoBody(@Expr),\n     ExprBlock(P<Block>),\n \n@@ -588,9 +588,9 @@ pub enum Expr_ {\n     /// Gets the log level for the enclosing module\n     ExprLogLevel,\n \n-    ExprInlineAsm(inline_asm),\n+    ExprInlineAsm(InlineAsm),\n \n-    ExprMac(mac),\n+    ExprMac(Mac),\n \n     // A struct literal expression.\n     ExprStruct(Path, ~[Field], Option<@Expr> /* base */),\n@@ -610,31 +610,38 @@ pub enum Expr_ {\n // If the syntax extension is an MBE macro, it will attempt to match its\n // LHS \"matchers\" against the provided token tree, and if it finds a\n // match, will transcribe the RHS token tree, splicing in any captured\n-// macro_parser::matched_nonterminals into the tt_nonterminals it finds.\n+// macro_parser::matched_nonterminals into the TTNonterminals it finds.\n //\n-// The RHS of an MBE macro is the only place a tt_nonterminal or tt_seq\n+// The RHS of an MBE macro is the only place a TTNonterminal or TTSeq\n // makes any real sense. You could write them elsewhere but nothing\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n-pub enum token_tree {\n+pub enum TokenTree {\n     // a single token\n-    tt_tok(Span, ::parse::token::Token),\n+    TTTok(Span, ::parse::token::Token),\n     // a delimited sequence (the delimiters appear as the first\n     // and last elements of the vector)\n-    tt_delim(@~[token_tree]),\n+    TTDelim(@~[TokenTree]),\n \n     // These only make sense for right-hand-sides of MBE macros:\n \n-    // a kleene-style repetition sequence with a span, a tt_forest,\n+    // a kleene-style repetition sequence with a span, a TTForest,\n     // an optional separator, and a boolean where true indicates\n     // zero or more (..), and false indicates one or more (+).\n-    tt_seq(Span, @~[token_tree], Option<::parse::token::Token>, bool),\n+    TTSeq(Span, @~[TokenTree], Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion.\n-    tt_nonterminal(Span, Ident)\n+    TTNonterminal(Span, Ident)\n+}\n+\n+// NOTE remove after next snapshot\n+// Required for ext::quote macros.\n+#[cfg(stage0)]\n+pub fn tt_tok(span: Span, tok: ::parse::token::Token) -> TokenTree {\n+    TTTok(span, tok)\n }\n \n //\n@@ -646,15 +653,15 @@ pub enum token_tree {\n // token-trees, and are thus primarily used by the macro-defining extension\n // itself.\n //\n-// match_tok\n-// ---------\n+// MatchTok\n+// --------\n //\n //     A matcher that matches a single token, denoted by the token itself. So\n //     long as there's no $ involved.\n //\n //\n-// match_seq\n-// ---------\n+// MatchSeq\n+// --------\n //\n //     A matcher that matches a sequence of sub-matchers, denoted various\n //     possible ways:\n@@ -665,7 +672,7 @@ pub enum token_tree {\n //             $(A B C);*  zero or more semi-separated 'A B C' seqs\n //\n //\n-// match_nonterminal\n+// MatchNonterminal\n // -----------------\n //\n //     A matcher that matches one of a few interesting named rust\n@@ -682,35 +689,35 @@ pub enum token_tree {\n //\n // As a final, horrifying aside, note that macro-by-example's input is\n // also matched by one of these matchers. Holy self-referential! It is matched\n-// by an match_seq, specifically this one:\n+// by an MatchSeq, specifically this one:\n //\n //                   $( $lhs:matchers => $rhs:tt );+\n //\n // If you understand that, you have closed to loop and understand the whole\n // macro system. Congratulations.\n //\n-pub type matcher = Spanned<matcher_>;\n+pub type Matcher = Spanned<Matcher_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum matcher_ {\n+pub enum Matcher_ {\n     // match one token\n-    match_tok(::parse::token::Token),\n+    MatchTok(::parse::token::Token),\n     // match repetitions of a sequence: body, separator, zero ok?,\n     // lo, hi position-in-match-array used:\n-    match_seq(~[matcher], Option<::parse::token::Token>, bool, uint, uint),\n+    MatchSeq(~[Matcher], Option<::parse::token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n-    match_nonterminal(Ident, Ident, uint)\n+    MatchNonterminal(Ident, Ident, uint)\n }\n \n-pub type mac = Spanned<mac_>;\n+pub type Mac = Spanned<Mac_>;\n \n // represents a macro invocation. The Path indicates which macro\n // is being invoked, and the vector of token-trees contains the source\n // of the macro invocation.\n // There's only one flavor, now, so this could presumably be simplified.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum mac_ {\n-    mac_invoc_tt(Path,~[token_tree],SyntaxContext),   // new macro-invocation\n+pub enum Mac_ {\n+    MacInvocTT(Path, ~[TokenTree], SyntaxContext),   // new macro-invocation\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -719,45 +726,45 @@ pub enum StrStyle {\n     RawStr(uint)\n }\n \n-pub type lit = Spanned<lit_>;\n+pub type Lit = Spanned<Lit_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum lit_ {\n-    lit_str(@str, StrStyle),\n-    lit_binary(@[u8]),\n-    lit_char(u32),\n-    lit_int(i64, int_ty),\n-    lit_uint(u64, uint_ty),\n-    lit_int_unsuffixed(i64),\n-    lit_float(@str, float_ty),\n-    lit_float_unsuffixed(@str),\n-    lit_nil,\n-    lit_bool(bool),\n+pub enum Lit_ {\n+    LitStr(@str, StrStyle),\n+    LitBinary(@[u8]),\n+    LitChar(u32),\n+    LitInt(i64, IntTy),\n+    LitUint(u64, UintTy),\n+    LitIntUnsuffixed(i64),\n+    LitFloat(@str, FloatTy),\n+    LitFloatUnsuffixed(@str),\n+    LitNil,\n+    LitBool(bool),\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct mt {\n+pub struct MutTy {\n     ty: P<Ty>,\n     mutbl: Mutability,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TypeField {\n     ident: Ident,\n-    mt: mt,\n+    mt: MutTy,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct TypeMethod {\n     ident: Ident,\n     attrs: ~[Attribute],\n-    purity: purity,\n-    decl: P<fn_decl>,\n+    purity: Purity,\n+    decl: P<FnDecl>,\n     generics: Generics,\n-    explicit_self: explicit_self,\n+    explicit_self: ExplicitSelf,\n     id: NodeId,\n     span: Span,\n }\n@@ -766,48 +773,48 @@ pub struct TypeMethod {\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum trait_method {\n-    required(TypeMethod),\n-    provided(@method),\n+pub enum TraitMethod {\n+    Required(TypeMethod),\n+    Provided(@Method),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum int_ty {\n-    ty_i,\n-    ty_i8,\n-    ty_i16,\n-    ty_i32,\n-    ty_i64,\n+pub enum IntTy {\n+    TyI,\n+    TyI8,\n+    TyI16,\n+    TyI32,\n+    TyI64,\n }\n \n-impl ToStr for int_ty {\n+impl ToStr for IntTy {\n     fn to_str(&self) -> ~str {\n         ::ast_util::int_ty_to_str(*self)\n     }\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum uint_ty {\n-    ty_u,\n-    ty_u8,\n-    ty_u16,\n-    ty_u32,\n-    ty_u64,\n+pub enum UintTy {\n+    TyU,\n+    TyU8,\n+    TyU16,\n+    TyU32,\n+    TyU64,\n }\n \n-impl ToStr for uint_ty {\n+impl ToStr for UintTy {\n     fn to_str(&self) -> ~str {\n         ::ast_util::uint_ty_to_str(*self)\n     }\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum float_ty {\n-    ty_f32,\n-    ty_f64,\n+pub enum FloatTy {\n+    TyF32,\n+    TyF64,\n }\n \n-impl ToStr for float_ty {\n+impl ToStr for FloatTy {\n     fn to_str(&self) -> ~str {\n         ::ast_util::float_ty_to_str(*self)\n     }\n@@ -817,19 +824,19 @@ impl ToStr for float_ty {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Ty {\n     id: NodeId,\n-    node: ty_,\n+    node: Ty_,\n     span: Span,\n }\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum prim_ty {\n-    ty_int(int_ty),\n-    ty_uint(uint_ty),\n-    ty_float(float_ty),\n-    ty_str,\n-    ty_bool,\n-    ty_char\n+pub enum PrimTy {\n+    TyInt(IntTy),\n+    TyUint(UintTy),\n+    TyFloat(FloatTy),\n+    TyStr,\n+    TyBool,\n+    TyChar\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -848,13 +855,13 @@ impl ToStr for Onceness {\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct TyClosure {\n+pub struct ClosureTy {\n     sigil: Sigil,\n     region: Option<Lifetime>,\n     lifetimes: OptVec<Lifetime>,\n-    purity: purity,\n+    purity: Purity,\n     onceness: Onceness,\n-    decl: P<fn_decl>,\n+    decl: P<FnDecl>,\n     // Optional optvec distinguishes between \"fn()\" and \"fn:()\" so we can\n     // implement issue #7264. None means \"fn()\", which means infer a default\n     // bound based on pointer sigil during typeck. Some(Empty) means \"fn:()\",\n@@ -863,202 +870,202 @@ pub struct TyClosure {\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct TyBareFn {\n-    purity: purity,\n+pub struct BareFnTy {\n+    purity: Purity,\n     abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n-    decl: P<fn_decl>\n+    decl: P<FnDecl>\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum ty_ {\n-    ty_nil,\n-    ty_bot, /* bottom type */\n-    ty_box(P<Ty>),\n-    ty_uniq(P<Ty>),\n-    ty_vec(P<Ty>),\n-    ty_fixed_length_vec(P<Ty>, @Expr),\n-    ty_ptr(mt),\n-    ty_rptr(Option<Lifetime>, mt),\n-    ty_closure(@TyClosure),\n-    ty_bare_fn(@TyBareFn),\n-    ty_tup(~[P<Ty>]),\n-    ty_path(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n-    ty_typeof(@Expr),\n+pub enum Ty_ {\n+    TyNil,\n+    TyBot, /* bottom type */\n+    TyBox(P<Ty>),\n+    TyUniq(P<Ty>),\n+    TyVec(P<Ty>),\n+    TyFixedLengthVec(P<Ty>, @Expr),\n+    TyPtr(MutTy),\n+    TyRptr(Option<Lifetime>, MutTy),\n+    TyClosure(@ClosureTy),\n+    TyBareFn(@BareFnTy),\n+    TyTup(~[P<Ty>]),\n+    TyPath(Path, Option<OptVec<TyParamBound>>, NodeId), // for #7264; see above\n+    TyTypeof(@Expr),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n     // nested in one.\n-    ty_infer,\n+    TyInfer,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum asm_dialect {\n-    asm_att,\n-    asm_intel\n+pub enum AsmDialect {\n+    AsmAtt,\n+    AsmIntel\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct inline_asm {\n+pub struct InlineAsm {\n     asm: @str,\n     asm_str_style: StrStyle,\n     clobbers: @str,\n     inputs: ~[(@str, @Expr)],\n     outputs: ~[(@str, @Expr)],\n     volatile: bool,\n     alignstack: bool,\n-    dialect: asm_dialect\n+    dialect: AsmDialect\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct arg {\n+pub struct Arg {\n     ty: P<Ty>,\n     pat: @Pat,\n     id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct fn_decl {\n-    inputs: ~[arg],\n+pub struct FnDecl {\n+    inputs: ~[Arg],\n     output: P<Ty>,\n-    cf: ret_style,\n+    cf: RetStyle,\n     variadic: bool\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum purity {\n-    unsafe_fn, // declared with \"unsafe fn\"\n-    impure_fn, // declared with \"fn\"\n-    extern_fn, // declared with \"extern fn\"\n+pub enum Purity {\n+    UnsafeFn, // declared with \"unsafe fn\"\n+    ImpureFn, // declared with \"fn\"\n+    ExternFn, // declared with \"extern fn\"\n }\n \n-impl ToStr for purity {\n+impl ToStr for Purity {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            impure_fn => ~\"impure\",\n-            unsafe_fn => ~\"unsafe\",\n-            extern_fn => ~\"extern\"\n+            ImpureFn => ~\"impure\",\n+            UnsafeFn => ~\"unsafe\",\n+            ExternFn => ~\"extern\"\n         }\n     }\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum ret_style {\n-    noreturn, // functions with return type _|_ that always\n+pub enum RetStyle {\n+    NoReturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n-    return_val, // everything else\n+    Return, // everything else\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum explicit_self_ {\n-    sty_static,                                // no self\n-    sty_value(Mutability),                     // `self`\n-    sty_region(Option<Lifetime>, Mutability),  // `&'lt self`\n-    sty_box(Mutability),                       // `@self`\n-    sty_uniq(Mutability)                       // `~self`\n+pub enum ExplicitSelf_ {\n+    SelfStatic,                                // no self\n+    SelfValue(Mutability),                     // `self`\n+    SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`\n+    SelfBox(Mutability),                       // `@self`\n+    SelfUniq(Mutability)                       // `~self`\n }\n \n-pub type explicit_self = Spanned<explicit_self_>;\n+pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct method {\n+pub struct Method {\n     ident: Ident,\n     attrs: ~[Attribute],\n     generics: Generics,\n-    explicit_self: explicit_self,\n-    purity: purity,\n-    decl: P<fn_decl>,\n+    explicit_self: ExplicitSelf,\n+    purity: Purity,\n+    decl: P<FnDecl>,\n     body: P<Block>,\n     id: NodeId,\n     span: Span,\n     self_id: NodeId,\n-    vis: visibility,\n+    vis: Visibility,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct _mod {\n-    view_items: ~[view_item],\n-    items: ~[@item],\n+pub struct Mod {\n+    view_items: ~[ViewItem],\n+    items: ~[@Item],\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub struct foreign_mod {\n+pub struct ForeignMod {\n     abis: AbiSet,\n-    view_items: ~[view_item],\n-    items: ~[@foreign_item],\n+    view_items: ~[ViewItem],\n+    items: ~[@ForeignItem],\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct variant_arg {\n+pub struct VariantArg {\n     ty: P<Ty>,\n     id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum variant_kind {\n-    tuple_variant_kind(~[variant_arg]),\n-    struct_variant_kind(@struct_def),\n+pub enum VariantKind {\n+    TupleVariantKind(~[VariantArg]),\n+    StructVariantKind(@StructDef),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct enum_def {\n-    variants: ~[P<variant>],\n+pub struct EnumDef {\n+    variants: ~[P<Variant>],\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct variant_ {\n+pub struct Variant_ {\n     name: Ident,\n     attrs: ~[Attribute],\n-    kind: variant_kind,\n+    kind: VariantKind,\n     id: NodeId,\n     disr_expr: Option<@Expr>,\n-    vis: visibility,\n+    vis: Visibility,\n }\n \n-pub type variant = Spanned<variant_>;\n+pub type Variant = Spanned<Variant_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct path_list_ident_ {\n+pub struct PathListIdent_ {\n     name: Ident,\n     id: NodeId,\n }\n \n-pub type path_list_ident = Spanned<path_list_ident_>;\n+pub type PathListIdent = Spanned<PathListIdent_>;\n \n-pub type view_path = Spanned<view_path_>;\n+pub type ViewPath = Spanned<ViewPath_>;\n \n #[deriving(Eq, Encodable, Decodable, IterBytes)]\n-pub enum view_path_ {\n+pub enum ViewPath_ {\n \n     // quux = foo::bar::baz\n     //\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(Ident, Path, NodeId),\n+    ViewPathSimple(Ident, Path, NodeId),\n \n     // foo::bar::*\n-    view_path_glob(Path, NodeId),\n+    ViewPathGlob(Path, NodeId),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(Path, ~[path_list_ident], NodeId)\n+    ViewPathList(Path, ~[PathListIdent], NodeId)\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct view_item {\n-    node: view_item_,\n+pub struct ViewItem {\n+    node: ViewItem_,\n     attrs: ~[Attribute],\n-    vis: visibility,\n+    vis: Visibility,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum view_item_ {\n+pub enum ViewItem_ {\n     // ident: name used to refer to this crate in the code\n     // optional @str: if present, this is a location (containing\n     // arbitrary characters) from which to fetch the crate sources\n     // For example, extern mod whatever = \"github.com/mozilla/rust\"\n-    view_item_extern_mod(Ident, Option<(@str, StrStyle)>, NodeId),\n-    view_item_use(~[@view_path]),\n+    ViewItemExternMod(Ident, Option<(@str, StrStyle)>, NodeId),\n+    ViewItemUse(~[@ViewPath]),\n }\n \n // Meta-data associated with an item\n@@ -1082,53 +1089,53 @@ pub struct Attribute_ {\n }\n \n /*\n-  trait_refs appear in impls.\n-  resolve maps each trait_ref's ref_id to its defining trait; that's all\n+  TraitRef's appear in impls.\n+  resolve maps each TraitRef's ref_id to its defining trait; that's all\n   that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n-  If this impl is an item_impl, the impl_id is redundant (it could be the\n+  If this impl is an ItemImpl, the impl_id is redundant (it could be the\n   same as the impl's node id).\n  */\n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub struct trait_ref {\n+pub struct TraitRef {\n     path: Path,\n     ref_id: NodeId,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub enum visibility {\n-    public,\n-    private,\n-    inherited,\n+pub enum Visibility {\n+    Public,\n+    Private,\n+    Inherited,\n }\n \n-impl visibility {\n-    pub fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n+impl Visibility {\n+    pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n         match self {\n-            &inherited => parent_visibility,\n-            &public | &private => *self\n+            &Inherited => parent_visibility,\n+            &Public | &Private => *self\n         }\n     }\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub struct struct_field_ {\n-    kind: struct_field_kind,\n+pub struct StructField_ {\n+    kind: StructFieldKind,\n     id: NodeId,\n     ty: P<Ty>,\n     attrs: ~[Attribute],\n }\n \n-pub type struct_field = Spanned<struct_field_>;\n+pub type StructField = Spanned<StructField_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable,IterBytes)]\n-pub enum struct_field_kind {\n-    named_field(Ident, visibility),\n-    unnamed_field   // element of a tuple-like struct\n+pub enum StructFieldKind {\n+    NamedField(Ident, Visibility),\n+    UnnamedField // element of a tuple-like struct\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct struct_def {\n-    fields: ~[struct_field], /* fields, not including ctor */\n+pub struct StructDef {\n+    fields: ~[StructField], /* fields, not including ctor */\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n     ctor_id: Option<NodeId>\n@@ -1139,57 +1146,57 @@ pub struct struct_def {\n   we just use dummy names for anon items.\n  */\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub struct item {\n+pub struct Item {\n     ident: Ident,\n     attrs: ~[Attribute],\n     id: NodeId,\n-    node: item_,\n-    vis: visibility,\n+    node: Item_,\n+    vis: Visibility,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n-pub enum item_ {\n-    item_static(P<Ty>, Mutability, @Expr),\n-    item_fn(P<fn_decl>, purity, AbiSet, Generics, P<Block>),\n-    item_mod(_mod),\n-    item_foreign_mod(foreign_mod),\n-    item_ty(P<Ty>, Generics),\n-    item_enum(enum_def, Generics),\n-    item_struct(@struct_def, Generics),\n-    item_trait(Generics, ~[trait_ref], ~[trait_method]),\n-    item_impl(Generics,\n-              Option<trait_ref>, // (optional) trait this impl implements\n-              P<Ty>, // self\n-              ~[@method]),\n+pub enum Item_ {\n+    ItemStatic(P<Ty>, Mutability, @Expr),\n+    ItemFn(P<FnDecl>, Purity, AbiSet, Generics, P<Block>),\n+    ItemMod(Mod),\n+    ItemForeignMod(ForeignMod),\n+    ItemTy(P<Ty>, Generics),\n+    ItemEnum(EnumDef, Generics),\n+    ItemStruct(@StructDef, Generics),\n+    ItemTrait(Generics, ~[TraitRef], ~[TraitMethod]),\n+    ItemImpl(Generics,\n+             Option<TraitRef>, // (optional) trait this impl implements\n+             P<Ty>, // self\n+             ~[@Method]),\n     // a macro invocation (which includes macro definition)\n-    item_mac(mac),\n+    ItemMac(Mac),\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub struct foreign_item {\n+pub struct ForeignItem {\n     ident: Ident,\n     attrs: ~[Attribute],\n-    node: foreign_item_,\n+    node: ForeignItem_,\n     id: NodeId,\n     span: Span,\n-    vis: visibility,\n+    vis: Visibility,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum foreign_item_ {\n-    foreign_item_fn(P<fn_decl>, Generics),\n-    foreign_item_static(P<Ty>, /* is_mutbl */ bool),\n+pub enum ForeignItem_ {\n+    ForeignItemFn(P<FnDecl>, Generics),\n+    ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n-pub enum inlined_item {\n-    ii_item(@item),\n-    ii_method(DefId /* impl id */, bool /* is provided */, @method),\n-    ii_foreign(@foreign_item),\n+pub enum InlinedItem {\n+    IIItem(@Item),\n+    IIMethod(DefId /* impl id */, bool /* is provided */, @Method),\n+    IIForeign(@ForeignItem),\n }\n \n #[cfg(test)]\n@@ -1200,7 +1207,7 @@ mod test {\n \n     // Assert that the AST remains Freeze (#10693).\n     #[test] fn ast_is_freeze() {\n-        is_freeze::<item>();\n+        is_freeze::<Item>();\n     }\n }\n \n@@ -1292,7 +1299,7 @@ mod test {\n         let e : crate =\n             spanned{\n             node: crate_{\n-                module: _mod {view_items: ~[], items: ~[]},\n+                module: Mod {view_items: ~[], items: ~[]},\n                 attrs: ~[],\n                 config: ~[]\n             },"}, {"sha": "0f5737d775e073fff4afaea60a7a92bcab09bdb5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 158, "deletions": 165, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -14,10 +14,9 @@ use ast;\n use ast_util;\n use codemap::Span;\n use diagnostic::SpanHandler;\n-use fold::ast_fold;\n+use fold::Folder;\n use fold;\n-use parse::token::get_ident_interner;\n-use parse::token::ident_interner;\n+use parse::token::{get_ident_interner, IdentInterner};\n use parse::token::special_idents;\n use print::pprust;\n use util::small_vector::SmallVector;\n@@ -26,56 +25,56 @@ use std::cell::RefCell;\n use std::hashmap::HashMap;\n \n #[deriving(Clone, Eq)]\n-pub enum path_elt {\n-    path_mod(Ident),\n-    path_name(Ident),\n+pub enum PathElem {\n+    PathMod(Ident),\n+    PathName(Ident),\n \n     // A pretty name can come from an `impl` block. We attempt to select a\n     // reasonable name for debuggers to see, but to guarantee uniqueness with\n     // other paths the hash should also be taken into account during symbol\n     // generation.\n-    path_pretty_name(Ident, u64),\n+    PathPrettyName(Ident, u64),\n }\n \n-impl path_elt {\n+impl PathElem {\n     pub fn ident(&self) -> Ident {\n         match *self {\n-            path_mod(ident)            |\n-            path_name(ident)           |\n-            path_pretty_name(ident, _) => ident\n+            PathMod(ident)            |\n+            PathName(ident)           |\n+            PathPrettyName(ident, _) => ident\n         }\n     }\n }\n \n-pub type path = ~[path_elt];\n+pub type Path = ~[PathElem];\n \n-pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n-                         -> ~str {\n+pub fn path_to_str_with_sep(p: &[PathElem], sep: &str, itr: @IdentInterner)\n+                            -> ~str {\n     let strs = p.map(|e| {\n         match *e {\n-            path_mod(s) | path_name(s) | path_pretty_name(s, _) => {\n+            PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n                 itr.get(s.name)\n             }\n         }\n     });\n     strs.connect(sep)\n }\n \n-pub fn path_ident_to_str(p: &path, i: Ident, itr: @ident_interner) -> ~str {\n+pub fn path_ident_to_str(p: &Path, i: Ident, itr: @IdentInterner) -> ~str {\n     if p.is_empty() {\n         itr.get(i.name).to_owned()\n     } else {\n         format!(\"{}::{}\", path_to_str(*p, itr), itr.get(i.name))\n     }\n }\n \n-pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n+pub fn path_to_str(p: &[PathElem], itr: @IdentInterner) -> ~str {\n     path_to_str_with_sep(p, \"::\", itr)\n }\n \n-pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n+pub fn path_elem_to_str(pe: PathElem, itr: @IdentInterner) -> ~str {\n     match pe {\n-        path_mod(s) | path_name(s) | path_pretty_name(s, _) => {\n+        PathMod(s) | PathName(s) | PathPrettyName(s, _) => {\n             itr.get(s.name).to_owned()\n         }\n     }\n@@ -90,26 +89,26 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n //      relic of $ being one of the very few valid symbol names on\n //      unix. These kinds of details shouldn't be exposed way up here\n //      in the ast.\n-fn pretty_ty(ty: &Ty, itr: @ident_interner, out: &mut ~str) {\n+fn pretty_ty(ty: &Ty, itr: @IdentInterner, out: &mut ~str) {\n     let (prefix, subty) = match ty.node {\n-        ty_uniq(ty) => (\"$UP$\", &*ty),\n-        ty_box(ty) => (\"$SP$\", &*ty),\n-        ty_ptr(mt { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n-                                     &*ty),\n-        ty_rptr(_, mt { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},\n-                                      &*ty),\n+        TyUniq(ty) => (\"$UP$\", &*ty),\n+        TyBox(ty) => (\"$SP$\", &*ty),\n+        TyPtr(MutTy { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n+                                       &*ty),\n+        TyRptr(_, MutTy { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},\n+                                           &*ty),\n \n-        ty_vec(ty) => (\"$VEC$\", &*ty),\n-        ty_fixed_length_vec(ty, _) => (\"$FIXEDVEC$\", &*ty),\n+        TyVec(ty) => (\"$VEC$\", &*ty),\n+        TyFixedLengthVec(ty, _) => (\"$FIXEDVEC$\", &*ty),\n \n         // these can't be represented as <prefix><contained ty>, so\n         // need custom handling.\n-        ty_nil => { out.push_str(\"$NIL$\"); return }\n-        ty_path(ref path, _, _) => {\n-                        out.push_str(itr.get(path.segments.last().identifier.name));\n-                        return\n-                    }\n-        ty_tup(ref tys) => {\n+        TyNil => { out.push_str(\"$NIL$\"); return }\n+        TyPath(ref path, _, _) => {\n+            out.push_str(itr.get(path.segments.last().identifier.name));\n+            return\n+        }\n+        TyTup(ref tys) => {\n             out.push_str(format!(\"$TUP_{}$\", tys.len()));\n             for subty in tys.iter() {\n                 pretty_ty(*subty, itr, out);\n@@ -119,19 +118,19 @@ fn pretty_ty(ty: &Ty, itr: @ident_interner, out: &mut ~str) {\n         }\n \n         // meh, better than nothing.\n-        ty_bot => { out.push_str(\"$BOT$\"); return }\n-        ty_closure(..) => { out.push_str(\"$CLOSURE$\"); return }\n-        ty_bare_fn(..) => { out.push_str(\"$FN$\"); return }\n-        ty_typeof(..) => { out.push_str(\"$TYPEOF$\"); return }\n-        ty_infer(..) => { out.push_str(\"$INFER$\"); return }\n+        TyBot => { out.push_str(\"$BOT$\"); return }\n+        TyClosure(..) => { out.push_str(\"$CLOSURE$\"); return }\n+        TyBareFn(..) => { out.push_str(\"$FN$\"); return }\n+        TyTypeof(..) => { out.push_str(\"$TYPEOF$\"); return }\n+        TyInfer(..) => { out.push_str(\"$INFER$\"); return }\n \n     };\n \n     out.push_str(prefix);\n     pretty_ty(subty, itr, out);\n }\n \n-pub fn impl_pretty_name(trait_ref: &Option<trait_ref>, ty: &Ty) -> path_elt {\n+pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> PathElem {\n     let itr = get_ident_interner();\n \n     let hash = (trait_ref, ty).hash();\n@@ -145,56 +144,56 @@ pub fn impl_pretty_name(trait_ref: &Option<trait_ref>, ty: &Ty) -> path_elt {\n     };\n     pretty_ty(ty, itr, &mut pretty);\n \n-    path_pretty_name(Ident::new(itr.gensym(pretty)), hash)\n+    PathPrettyName(Ident::new(itr.gensym(pretty)), hash)\n }\n \n #[deriving(Clone)]\n-pub enum ast_node {\n-    node_item(@item, @path),\n-    node_foreign_item(@foreign_item, AbiSet, visibility, @path),\n-    node_trait_method(@trait_method, DefId /* trait did */,\n-                      @path /* path to the trait */),\n-    node_method(@method, DefId /* impl did */, @path /* path to the impl */),\n-\n-    /// node_variant represents a variant of an enum, e.g., for\n-    /// `enum A { B, C, D }`, there would be a node_item for `A`, and a\n-    /// node_variant item for each of `B`, `C`, and `D`.\n-    node_variant(P<variant>, @item, @path),\n-    node_expr(@Expr),\n-    node_stmt(@Stmt),\n-    node_arg(@Pat),\n+pub enum Node {\n+    NodeItem(@Item, @Path),\n+    NodeForeignItem(@ForeignItem, AbiSet, Visibility, @Path),\n+    NodeTraitMethod(@TraitMethod, DefId /* trait did */,\n+                    @Path /* path to the trait */),\n+    NodeMethod(@Method, DefId /* impl did */, @Path /* path to the impl */),\n+\n+    /// NodeVariant represents a variant of an enum, e.g., for\n+    /// `enum A { B, C, D }`, there would be a NodeItem for `A`, and a\n+    /// NodeVariant item for each of `B`, `C`, and `D`.\n+    NodeVariant(P<Variant>, @Item, @Path),\n+    NodeExpr(@Expr),\n+    NodeStmt(@Stmt),\n+    NodeArg(@Pat),\n     // HACK(eddyb) should always be a pattern, but `self` is not, and thus it\n     // is identified only by an ident and no span is available. In all other\n     // cases, node_span will return the proper span (required by borrowck).\n-    node_local(Ident, Option<@Pat>),\n-    node_block(P<Block>),\n+    NodeLocal(Ident, Option<@Pat>),\n+    NodeBlock(P<Block>),\n \n-    /// node_struct_ctor represents a tuple struct.\n-    node_struct_ctor(@struct_def, @item, @path),\n-    node_callee_scope(@Expr)\n+    /// NodeStructCtor represents a tuple struct.\n+    NodeStructCtor(@StructDef, @Item, @Path),\n+    NodeCalleeScope(@Expr)\n }\n \n-impl ast_node {\n+impl Node {\n     pub fn with_attrs<T>(&self, f: |Option<&[Attribute]>| -> T) -> T {\n         let attrs = match *self {\n-            node_item(i, _) => Some(i.attrs.as_slice()),\n-            node_foreign_item(fi, _, _, _) => Some(fi.attrs.as_slice()),\n-            node_trait_method(tm, _, _) => match *tm {\n-                required(ref type_m) => Some(type_m.attrs.as_slice()),\n-                provided(m) => Some(m.attrs.as_slice())\n+            NodeItem(i, _) => Some(i.attrs.as_slice()),\n+            NodeForeignItem(fi, _, _, _) => Some(fi.attrs.as_slice()),\n+            NodeTraitMethod(tm, _, _) => match *tm {\n+                Required(ref type_m) => Some(type_m.attrs.as_slice()),\n+                Provided(m) => Some(m.attrs.as_slice())\n             },\n-            node_method(m, _, _) => Some(m.attrs.as_slice()),\n-            node_variant(ref v, _, _) => Some(v.node.attrs.as_slice()),\n+            NodeMethod(m, _, _) => Some(m.attrs.as_slice()),\n+            NodeVariant(ref v, _, _) => Some(v.node.attrs.as_slice()),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n-            node_struct_ctor(_, strct, _) => Some(strct.attrs.as_slice()),\n+            NodeStructCtor(_, strct, _) => Some(strct.attrs.as_slice()),\n             _ => None\n         };\n         f(attrs)\n     }\n }\n \n-pub type map = @RefCell<HashMap<NodeId, ast_node>>;\n+pub type Map = @RefCell<HashMap<NodeId, Node>>;\n \n pub trait FoldOps {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n@@ -206,24 +205,24 @@ pub trait FoldOps {\n }\n \n pub struct Ctx<F> {\n-    map: map,\n-    path: path,\n+    map: Map,\n+    path: Path,\n     diag: @SpanHandler,\n     fold_ops: F\n }\n \n impl<F> Ctx<F> {\n-    fn insert(&self, id: ast::NodeId, node: ast_node) {\n+    fn insert(&self, id: ast::NodeId, node: Node) {\n         let mut map = self.map.borrow_mut();\n         map.get().insert(id, node);\n     }\n \n-    fn map_self(&self, m: @method) {\n-        self.insert(m.self_id, node_local(special_idents::self_, None));\n+    fn map_self(&self, m: @Method) {\n+        self.insert(m.self_id, NodeLocal(special_idents::self_, None));\n     }\n }\n \n-impl<F: FoldOps> ast_fold for Ctx<F> {\n+impl<F: FoldOps> Folder for Ctx<F> {\n     fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n         self.fold_ops.new_id(id)\n     }\n@@ -232,81 +231,77 @@ impl<F: FoldOps> ast_fold for Ctx<F> {\n         self.fold_ops.new_span(span)\n     }\n \n-    fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n+    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n         // clone is FIXME #2543\n         let item_path = @self.path.clone();\n         self.path.push(match i.node {\n-            item_impl(_, ref maybe_trait, ty, _) => {\n+            ItemImpl(_, ref maybe_trait, ty, _) => {\n                 // Right now the ident on impls is __extensions__ which isn't\n                 // very pretty when debugging, so attempt to select a better\n                 // name to use.\n                 impl_pretty_name(maybe_trait, ty)\n             }\n-            item_mod(_) | item_foreign_mod(_) => path_mod(i.ident),\n-            _ => path_name(i.ident)\n+            ItemMod(_) | ItemForeignMod(_) => PathMod(i.ident),\n+            _ => PathName(i.ident)\n         });\n \n         let i = fold::noop_fold_item(i, self).expect_one(\"expected one item\");\n-        self.insert(i.id, node_item(i, item_path));\n+        self.insert(i.id, NodeItem(i, item_path));\n \n         match i.node {\n-            item_impl(_, _, _, ref ms) => {\n+            ItemImpl(_, _, _, ref ms) => {\n                 // clone is FIXME #2543\n                 let p = @self.path.clone();\n                 let impl_did = ast_util::local_def(i.id);\n                 for &m in ms.iter() {\n-                    self.insert(m.id, node_method(m, impl_did, p));\n+                    self.insert(m.id, NodeMethod(m, impl_did, p));\n                     self.map_self(m);\n                 }\n \n             }\n-            item_enum(ref enum_definition, _) => {\n+            ItemEnum(ref enum_definition, _) => {\n                 // clone is FIXME #2543\n                 let p = @self.path.clone();\n                 for &v in enum_definition.variants.iter() {\n-                    self.insert(v.node.id, node_variant(v, i, p));\n+                    self.insert(v.node.id, NodeVariant(v, i, p));\n                 }\n             }\n-            item_foreign_mod(ref nm) => {\n+            ItemForeignMod(ref nm) => {\n                 for nitem in nm.items.iter() {\n                     // Compute the visibility for this native item.\n-                    let visibility = match nitem.vis {\n-                        public => public,\n-                        private => private,\n-                        inherited => i.vis\n-                    };\n+                    let visibility = nitem.vis.inherit_from(i.vis);\n \n                     self.insert(nitem.id,\n                                 // Anonymous extern mods go in the parent scope.\n-                                node_foreign_item(*nitem, nm.abis, visibility, item_path));\n+                                NodeForeignItem(*nitem, nm.abis, visibility, item_path));\n                 }\n             }\n-            item_struct(struct_def, _) => {\n+            ItemStruct(struct_def, _) => {\n                 // If this is a tuple-like struct, register the constructor.\n                 match struct_def.ctor_id {\n                     None => {}\n                     Some(ctor_id) => {\n                         // clone is FIXME #2543\n                         let p = @self.path.clone();\n-                        self.insert(ctor_id, node_struct_ctor(struct_def, i, p));\n+                        self.insert(ctor_id, NodeStructCtor(struct_def, i, p));\n                     }\n                 }\n             }\n-            item_trait(_, ref traits, ref methods) => {\n+            ItemTrait(_, ref traits, ref methods) => {\n                 for t in traits.iter() {\n-                    self.insert(t.ref_id, node_item(i, item_path));\n+                    self.insert(t.ref_id, NodeItem(i, item_path));\n                 }\n \n                 // clone is FIXME #2543\n                 let p = @self.path.clone();\n                 for tm in methods.iter() {\n                     let d_id = ast_util::local_def(i.id);\n                     match *tm {\n-                        required(ref m) => {\n-                            self.insert(m.id, node_trait_method(@(*tm).clone(), d_id, p));\n+                        Required(ref m) => {\n+                            self.insert(m.id, NodeTraitMethod(@(*tm).clone(), d_id, p));\n                         }\n-                        provided(m) => {\n-                            self.insert(m.id, node_trait_method(@provided(m), d_id, p));\n+                        Provided(m) => {\n+                            self.insert(m.id, NodeTraitMethod(@Provided(m), d_id, p));\n                             self.map_self(m);\n                         }\n                     }\n@@ -325,7 +320,7 @@ impl<F: FoldOps> ast_fold for Ctx<F> {\n         match pat.node {\n             PatIdent(_, ref path, _) => {\n                 // Note: this is at least *potentially* a pattern...\n-                self.insert(pat.id, node_local(ast_util::path_to_ident(path), Some(pat)));\n+                self.insert(pat.id, NodeLocal(ast_util::path_to_ident(path), Some(pat)));\n             }\n             _ => {}\n         }\n@@ -336,13 +331,13 @@ impl<F: FoldOps> ast_fold for Ctx<F> {\n     fn fold_expr(&mut self, expr: @Expr) -> @Expr {\n         let expr = fold::noop_fold_expr(expr, self);\n \n-        self.insert(expr.id, node_expr(expr));\n+        self.insert(expr.id, NodeExpr(expr));\n \n         // Expressions which are or might be calls:\n         {\n             let r = expr.get_callee_id();\n             for callee_id in r.iter() {\n-                self.insert(*callee_id, node_callee_scope(expr));\n+                self.insert(*callee_id, NodeCalleeScope(expr));\n             }\n         }\n \n@@ -351,34 +346,34 @@ impl<F: FoldOps> ast_fold for Ctx<F> {\n \n     fn fold_stmt(&mut self, stmt: &Stmt) -> SmallVector<@Stmt> {\n         let stmt = fold::noop_fold_stmt(stmt, self).expect_one(\"expected one statement\");\n-        self.insert(ast_util::stmt_id(stmt), node_stmt(stmt));\n+        self.insert(ast_util::stmt_id(stmt), NodeStmt(stmt));\n         SmallVector::one(stmt)\n     }\n \n-    fn fold_method(&mut self, m: @method) -> @method {\n-        self.path.push(path_name(m.ident));\n+    fn fold_method(&mut self, m: @Method) -> @Method {\n+        self.path.push(PathName(m.ident));\n         let m = fold::noop_fold_method(m, self);\n         self.path.pop();\n         m\n     }\n \n-    fn fold_fn_decl(&mut self, decl: &fn_decl) -> P<fn_decl> {\n+    fn fold_fn_decl(&mut self, decl: &FnDecl) -> P<FnDecl> {\n         let decl = fold::noop_fold_fn_decl(decl, self);\n         for a in decl.inputs.iter() {\n-            self.insert(a.id, node_arg(a.pat));\n+            self.insert(a.id, NodeArg(a.pat));\n         }\n         decl\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n         let block = fold::noop_fold_block(block, self);\n-        self.insert(block.id, node_block(block));\n+        self.insert(block.id, NodeBlock(block));\n         block\n     }\n }\n \n pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n-                                       fold_ops: F) -> (Crate, map) {\n+                                       fold_ops: F) -> (Crate, Map) {\n     let mut cx = Ctx {\n         map: @RefCell::new(HashMap::new()),\n         path: ~[],\n@@ -392,11 +387,11 @@ pub fn map_crate<F: 'static + FoldOps>(diag: @SpanHandler, c: Crate,\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n-                                              map: map,\n-                                              path: path,\n+                                              map: Map,\n+                                              path: Path,\n                                               fold_ops: F,\n-                                              fold_ii: |&mut Ctx<F>| -> inlined_item)\n-                                              -> inlined_item {\n+                                              fold_ii: |&mut Ctx<F>| -> InlinedItem)\n+                                              -> InlinedItem {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.\n@@ -413,18 +408,18 @@ pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n     match ii {\n-        ii_item(..) => {} // fallthrough\n-        ii_foreign(i) => {\n-            cx.insert(i.id, node_foreign_item(i,\n-                                              AbiSet::Intrinsic(),\n-                                              i.vis,    // Wrong but OK\n-                                              @path));\n+        IIItem(..) => {} // fallthrough\n+        IIForeign(i) => {\n+            cx.insert(i.id, NodeForeignItem(i,\n+                                            AbiSet::Intrinsic(),\n+                                            i.vis,    // Wrong but OK\n+                                            @path));\n         }\n-        ii_method(impl_did, is_provided, m) => {\n+        IIMethod(impl_did, is_provided, m) => {\n             let entry = if is_provided {\n-                node_trait_method(@provided(m), impl_did, @path)\n+                NodeTraitMethod(@Provided(m), impl_did, @path)\n             } else {\n-                node_method(m, impl_did, @path)\n+                NodeMethod(m, impl_did, @path)\n             };\n             cx.insert(m.id, entry);\n             cx.map_self(m);\n@@ -434,100 +429,98 @@ pub fn map_decoded_item<F: 'static + FoldOps>(diag: @SpanHandler,\n     ii\n }\n \n-pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n+pub fn node_id_to_str(map: Map, id: NodeId, itr: @IdentInterner) -> ~str {\n     let map = map.borrow();\n     match map.get().find(&id) {\n       None => {\n         format!(\"unknown node (id={})\", id)\n       }\n-      Some(&node_item(item, path)) => {\n+      Some(&NodeItem(item, path)) => {\n         let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n-          item_static(..) => ~\"static\",\n-          item_fn(..) => ~\"fn\",\n-          item_mod(..) => ~\"mod\",\n-          item_foreign_mod(..) => ~\"foreign mod\",\n-          item_ty(..) => ~\"ty\",\n-          item_enum(..) => ~\"enum\",\n-          item_struct(..) => ~\"struct\",\n-          item_trait(..) => ~\"trait\",\n-          item_impl(..) => ~\"impl\",\n-          item_mac(..) => ~\"macro\"\n+            ItemStatic(..) => ~\"static\",\n+            ItemFn(..) => ~\"fn\",\n+            ItemMod(..) => ~\"mod\",\n+            ItemForeignMod(..) => ~\"foreign mod\",\n+            ItemTy(..) => ~\"ty\",\n+            ItemEnum(..) => ~\"enum\",\n+            ItemStruct(..) => ~\"struct\",\n+            ItemTrait(..) => ~\"trait\",\n+            ItemImpl(..) => ~\"impl\",\n+            ItemMac(..) => ~\"macro\"\n         };\n         format!(\"{} {} (id={})\", item_str, path_str, id)\n       }\n-      Some(&node_foreign_item(item, abi, _, path)) => {\n+      Some(&NodeForeignItem(item, abi, _, path)) => {\n         format!(\"foreign item {} with abi {:?} (id={})\",\n              path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n-      Some(&node_method(m, _, path)) => {\n+      Some(&NodeMethod(m, _, path)) => {\n         format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n-      Some(&node_trait_method(ref tm, _, path)) => {\n+      Some(&NodeTraitMethod(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n         format!(\"method {} in {} (id={})\",\n              itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n-      Some(&node_variant(ref variant, _, path)) => {\n+      Some(&NodeVariant(ref variant, _, path)) => {\n         format!(\"variant {} in {} (id={})\",\n              itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n-      Some(&node_expr(expr)) => {\n+      Some(&NodeExpr(expr)) => {\n         format!(\"expr {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n-      Some(&node_callee_scope(expr)) => {\n+      Some(&NodeCalleeScope(expr)) => {\n         format!(\"callee_scope {} (id={})\", pprust::expr_to_str(expr, itr), id)\n       }\n-      Some(&node_stmt(stmt)) => {\n+      Some(&NodeStmt(stmt)) => {\n         format!(\"stmt {} (id={})\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&node_arg(pat)) => {\n+      Some(&NodeArg(pat)) => {\n         format!(\"arg {} (id={})\", pprust::pat_to_str(pat, itr), id)\n       }\n-      Some(&node_local(ident, _)) => {\n+      Some(&NodeLocal(ident, _)) => {\n         format!(\"local (id={}, name={})\", id, itr.get(ident.name))\n       }\n-      Some(&node_block(block)) => {\n+      Some(&NodeBlock(block)) => {\n         format!(\"block {} (id={})\", pprust::block_to_str(block, itr), id)\n       }\n-      Some(&node_struct_ctor(_, _, path)) => {\n+      Some(&NodeStructCtor(_, _, path)) => {\n         format!(\"struct_ctor {} (id={})\", path_to_str(*path, itr), id)\n       }\n     }\n }\n \n-pub fn node_item_query<Result>(items: map, id: NodeId, query: |@item| -> Result, error_msg: ~str)\n+pub fn node_item_query<Result>(items: Map, id: NodeId, query: |@Item| -> Result, error_msg: ~str)\n                        -> Result {\n     let items = items.borrow();\n     match items.get().find(&id) {\n-        Some(&node_item(it, _)) => query(it),\n+        Some(&NodeItem(it, _)) => query(it),\n         _ => fail!(\"{}\", error_msg)\n     }\n }\n \n-pub fn node_span(items: map,\n-                 id: ast::NodeId)\n-                 -> Span {\n+pub fn node_span(items: Map, id: ast::NodeId) -> Span {\n     let items = items.borrow();\n     match items.get().find(&id) {\n-        Some(&node_item(item, _)) => item.span,\n-        Some(&node_foreign_item(foreign_item, _, _, _)) => foreign_item.span,\n-        Some(&node_trait_method(@required(ref type_method), _, _)) => type_method.span,\n-        Some(&node_trait_method(@provided(ref method), _, _)) => method.span,\n-        Some(&node_method(method, _, _)) => method.span,\n-        Some(&node_variant(variant, _, _)) => variant.span,\n-        Some(&node_expr(expr)) => expr.span,\n-        Some(&node_stmt(stmt)) => stmt.span,\n-        Some(&node_arg(pat)) => pat.span,\n-        Some(&node_local(_, pat)) => match pat {\n+        Some(&NodeItem(item, _)) => item.span,\n+        Some(&NodeForeignItem(foreign_item, _, _, _)) => foreign_item.span,\n+        Some(&NodeTraitMethod(@Required(ref type_method), _, _)) => type_method.span,\n+        Some(&NodeTraitMethod(@Provided(ref method), _, _)) => method.span,\n+        Some(&NodeMethod(method, _, _)) => method.span,\n+        Some(&NodeVariant(variant, _, _)) => variant.span,\n+        Some(&NodeExpr(expr)) => expr.span,\n+        Some(&NodeStmt(stmt)) => stmt.span,\n+        Some(&NodeArg(pat)) => pat.span,\n+        Some(&NodeLocal(_, pat)) => match pat {\n             Some(pat) => pat.span,\n-            None => fail!(\"node_span: cannot get span from node_local (likely `self`)\")\n+            None => fail!(\"node_span: cannot get span from NodeLocal (likely `self`)\")\n         },\n-        Some(&node_block(block)) => block.span,\n-        Some(&node_struct_ctor(_, item, _)) => item.span,\n-        Some(&node_callee_scope(expr)) => expr.span,\n+        Some(&NodeBlock(block)) => block.span,\n+        Some(&NodeStructCtor(_, item, _)) => item.span,\n+        Some(&NodeCalleeScope(expr)) => expr.span,\n         None => fail!(\"node_span: could not find id {}\", id),\n     }\n }"}, {"sha": "bcac69c188a80af822d79586fb81ede30e8306b1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 83, "deletions": 84, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -151,46 +151,46 @@ pub fn is_path(e: @Expr) -> bool {\n     return match e.node { ExprPath(_) => true, _ => false };\n }\n \n-pub fn int_ty_to_str(t: int_ty) -> ~str {\n+pub fn int_ty_to_str(t: IntTy) -> ~str {\n     match t {\n-      ty_i => ~\"\",\n-      ty_i8 => ~\"i8\",\n-      ty_i16 => ~\"i16\",\n-      ty_i32 => ~\"i32\",\n-      ty_i64 => ~\"i64\"\n+        TyI => ~\"\",\n+        TyI8 => ~\"i8\",\n+        TyI16 => ~\"i16\",\n+        TyI32 => ~\"i32\",\n+        TyI64 => ~\"i64\"\n     }\n }\n \n-pub fn int_ty_max(t: int_ty) -> u64 {\n+pub fn int_ty_max(t: IntTy) -> u64 {\n     match t {\n-      ty_i8 => 0x80u64,\n-      ty_i16 => 0x8000u64,\n-      ty_i | ty_i32 => 0x80000000u64, // actually ni about ty_i\n-      ty_i64 => 0x8000000000000000u64\n+        TyI8 => 0x80u64,\n+        TyI16 => 0x8000u64,\n+        TyI | TyI32 => 0x80000000u64, // actually ni about TyI\n+        TyI64 => 0x8000000000000000u64\n     }\n }\n \n-pub fn uint_ty_to_str(t: uint_ty) -> ~str {\n+pub fn uint_ty_to_str(t: UintTy) -> ~str {\n     match t {\n-      ty_u => ~\"u\",\n-      ty_u8 => ~\"u8\",\n-      ty_u16 => ~\"u16\",\n-      ty_u32 => ~\"u32\",\n-      ty_u64 => ~\"u64\"\n+        TyU => ~\"u\",\n+        TyU8 => ~\"u8\",\n+        TyU16 => ~\"u16\",\n+        TyU32 => ~\"u32\",\n+        TyU64 => ~\"u64\"\n     }\n }\n \n-pub fn uint_ty_max(t: uint_ty) -> u64 {\n+pub fn uint_ty_max(t: UintTy) -> u64 {\n     match t {\n-      ty_u8 => 0xffu64,\n-      ty_u16 => 0xffffu64,\n-      ty_u | ty_u32 => 0xffffffffu64, // actually ni about ty_u\n-      ty_u64 => 0xffffffffffffffffu64\n+        TyU8 => 0xffu64,\n+        TyU16 => 0xffffu64,\n+        TyU | TyU32 => 0xffffffffu64, // actually ni about TyU\n+        TyU64 => 0xffffffffffffffffu64\n     }\n }\n \n-pub fn float_ty_to_str(t: float_ty) -> ~str {\n-    match t { ty_f32 => ~\"f32\", ty_f64 => ~\"f64\" }\n+pub fn float_ty_to_str(t: FloatTy) -> ~str {\n+    match t { TyF32 => ~\"f32\", TyF64 => ~\"f64\" }\n }\n \n pub fn is_call_expr(e: @Expr) -> bool {\n@@ -243,21 +243,21 @@ pub fn unguarded_pat(a: &Arm) -> Option<~[@Pat]> {\n     }\n }\n \n-pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n+pub fn public_methods(ms: ~[@Method]) -> ~[@Method] {\n     ms.move_iter().filter(|m| {\n         match m.vis {\n-            public => true,\n+            Public => true,\n             _   => false\n         }\n     }).collect()\n }\n \n-// extract a TypeMethod from a trait_method. if the trait_method is\n+// extract a TypeMethod from a TraitMethod. if the TraitMethod is\n // a default, pull out the useful fields to make a TypeMethod\n-pub fn trait_method_to_ty_method(method: &trait_method) -> TypeMethod {\n+pub fn trait_method_to_ty_method(method: &TraitMethod) -> TypeMethod {\n     match *method {\n-        required(ref m) => (*m).clone(),\n-        provided(ref m) => {\n+        Required(ref m) => (*m).clone(),\n+        Provided(ref m) => {\n             TypeMethod {\n                 ident: m.ident,\n                 attrs: m.attrs.clone(),\n@@ -272,23 +272,23 @@ pub fn trait_method_to_ty_method(method: &trait_method) -> TypeMethod {\n     }\n }\n \n-pub fn split_trait_methods(trait_methods: &[trait_method])\n-    -> (~[TypeMethod], ~[@method]) {\n+pub fn split_trait_methods(trait_methods: &[TraitMethod])\n+    -> (~[TypeMethod], ~[@Method]) {\n     let mut reqd = ~[];\n     let mut provd = ~[];\n     for trt_method in trait_methods.iter() {\n         match *trt_method {\n-          required(ref tm) => reqd.push((*tm).clone()),\n-          provided(m) => provd.push(m)\n+            Required(ref tm) => reqd.push((*tm).clone()),\n+            Provided(m) => provd.push(m)\n         }\n     };\n     (reqd, provd)\n }\n \n-pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n+pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n-        ast::named_field(_, visibility) => visibility,\n-        ast::unnamed_field => ast::public\n+        ast::NamedField(_, visibility) => visibility,\n+        ast::UnnamedField => ast::Public\n     }\n }\n \n@@ -332,14 +332,14 @@ pub fn empty_generics() -> Generics {\n // Enumerating the IDs which appear in an AST\n \n #[deriving(Encodable, Decodable)]\n-pub struct id_range {\n+pub struct IdRange {\n     min: NodeId,\n     max: NodeId,\n }\n \n-impl id_range {\n-    pub fn max() -> id_range {\n-        id_range {\n+impl IdRange {\n+    pub fn max() -> IdRange {\n+        IdRange {\n             min: u32::max_value,\n             max: u32::min_value,\n         }\n@@ -378,27 +378,27 @@ impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n \n impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     fn visit_mod(&mut self,\n-                 module: &_mod,\n+                 module: &Mod,\n                  _: Span,\n                  node_id: NodeId,\n                  env: ()) {\n         self.operation.visit_id(node_id);\n         visit::walk_mod(self, module, env)\n     }\n \n-    fn visit_view_item(&mut self, view_item: &view_item, env: ()) {\n+    fn visit_view_item(&mut self, view_item: &ViewItem, env: ()) {\n         match view_item.node {\n-            view_item_extern_mod(_, _, node_id) => {\n+            ViewItemExternMod(_, _, node_id) => {\n                 self.operation.visit_id(node_id)\n             }\n-            view_item_use(ref view_paths) => {\n+            ViewItemUse(ref view_paths) => {\n                 for view_path in view_paths.iter() {\n                     match view_path.node {\n-                        view_path_simple(_, _, node_id) |\n-                        view_path_glob(_, node_id) => {\n+                        ViewPathSimple(_, _, node_id) |\n+                        ViewPathGlob(_, node_id) => {\n                             self.operation.visit_id(node_id)\n                         }\n-                        view_path_list(_, ref paths, node_id) => {\n+                        ViewPathList(_, ref paths, node_id) => {\n                             self.operation.visit_id(node_id);\n                             for path in paths.iter() {\n                                 self.operation.visit_id(path.node.id)\n@@ -411,12 +411,12 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         visit::walk_view_item(self, view_item, env)\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &foreign_item, env: ()) {\n+    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem, env: ()) {\n         self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item, env)\n     }\n \n-    fn visit_item(&mut self, item: &item, env: ()) {\n+    fn visit_item(&mut self, item: &Item, env: ()) {\n         if !self.pass_through_items {\n             if self.visited_outermost {\n                 return\n@@ -427,7 +427,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n \n         self.operation.visit_id(item.id);\n         match item.node {\n-            item_enum(ref enum_definition, _) => {\n+            ItemEnum(ref enum_definition, _) => {\n                 for variant in enum_definition.variants.iter() {\n                     self.operation.visit_id(variant.node.id)\n                 }\n@@ -475,7 +475,7 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     fn visit_ty(&mut self, typ: &Ty, env: ()) {\n         self.operation.visit_id(typ.id);\n         match typ.node {\n-            ty_path(_, _, id) => self.operation.visit_id(id),\n+            TyPath(_, _, id) => self.operation.visit_id(id),\n             _ => {}\n         }\n         visit::walk_ty(self, typ, env)\n@@ -487,31 +487,31 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     }\n \n     fn visit_fn(&mut self,\n-                function_kind: &visit::fn_kind,\n-                function_declaration: &fn_decl,\n+                function_kind: &visit::FnKind,\n+                function_declaration: &FnDecl,\n                 block: &Block,\n                 span: Span,\n                 node_id: NodeId,\n                 env: ()) {\n         if !self.pass_through_items {\n             match *function_kind {\n-                visit::fk_method(..) if self.visited_outermost => return,\n-                visit::fk_method(..) => self.visited_outermost = true,\n+                visit::FkMethod(..) if self.visited_outermost => return,\n+                visit::FkMethod(..) => self.visited_outermost = true,\n                 _ => {}\n             }\n         }\n \n         self.operation.visit_id(node_id);\n \n         match *function_kind {\n-            visit::fk_item_fn(_, generics, _, _) => {\n+            visit::FkItemFn(_, generics, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n-            visit::fk_method(_, generics, method) => {\n+            visit::FkMethod(_, generics, method) => {\n                 self.operation.visit_id(method.self_id);\n                 self.visit_generics_helper(generics)\n             }\n-            visit::fk_fn_block => {}\n+            visit::FkFnBlock => {}\n         }\n \n         for argument in function_declaration.inputs.iter() {\n@@ -528,19 +528,19 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n \n         if !self.pass_through_items {\n             match *function_kind {\n-                visit::fk_method(..) => self.visited_outermost = false,\n+                visit::FkMethod(..) => self.visited_outermost = false,\n                 _ => {}\n             }\n         }\n     }\n \n-    fn visit_struct_field(&mut self, struct_field: &struct_field, env: ()) {\n+    fn visit_struct_field(&mut self, struct_field: &StructField, env: ()) {\n         self.operation.visit_id(struct_field.node.id);\n         visit::walk_struct_field(self, struct_field, env)\n     }\n \n     fn visit_struct_def(&mut self,\n-                        struct_def: &struct_def,\n+                        struct_def: &StructDef,\n                         ident: ast::Ident,\n                         generics: &ast::Generics,\n                         id: NodeId,\n@@ -550,16 +550,16 @@ impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n         visit::walk_struct_def(self, struct_def, ident, generics, id, ());\n     }\n \n-    fn visit_trait_method(&mut self, tm: &ast::trait_method, _: ()) {\n+    fn visit_trait_method(&mut self, tm: &ast::TraitMethod, _: ()) {\n         match *tm {\n-            ast::required(ref m) => self.operation.visit_id(m.id),\n-            ast::provided(ref m) => self.operation.visit_id(m.id),\n+            ast::Required(ref m) => self.operation.visit_id(m.id),\n+            ast::Provided(ref m) => self.operation.visit_id(m.id),\n         }\n         visit::walk_trait_method(self, tm, ());\n     }\n }\n \n-pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &inlined_item,\n+pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n                                                           operation: &O) {\n     let mut id_visitor = IdVisitor {\n         operation: operation,\n@@ -568,14 +568,14 @@ pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &inlined_item,\n     };\n \n     match *item {\n-        ii_item(i) => id_visitor.visit_item(i, ()),\n-        ii_foreign(i) => id_visitor.visit_foreign_item(i, ()),\n-        ii_method(_, _, m) => visit::walk_method_helper(&mut id_visitor, m, ()),\n+        IIItem(i) => id_visitor.visit_item(i, ()),\n+        IIForeign(i) => id_visitor.visit_foreign_item(i, ()),\n+        IIMethod(_, _, m) => visit::walk_method_helper(&mut id_visitor, m, ()),\n     }\n }\n \n struct IdRangeComputingVisitor {\n-    result: Cell<id_range>,\n+    result: Cell<IdRange>,\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n@@ -586,18 +586,18 @@ impl IdVisitingOperation for IdRangeComputingVisitor {\n     }\n }\n \n-pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n+pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n     let visitor = IdRangeComputingVisitor {\n-        result: Cell::new(id_range::max())\n+        result: Cell::new(IdRange::max())\n     };\n     visit_ids_for_inlined_item(item, &visitor);\n     visitor.result.get()\n }\n \n-pub fn is_item_impl(item: @ast::item) -> bool {\n+pub fn is_item_impl(item: @ast::Item) -> bool {\n     match item.node {\n-       item_impl(..) => true,\n-       _            => false\n+        ItemImpl(..) => true,\n+        _            => false\n     }\n }\n \n@@ -630,21 +630,21 @@ pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n }\n \n pub trait EachViewItem {\n-    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool;\n+    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool;\n }\n \n struct EachViewItemData<'a> {\n-    callback: 'a |&ast::view_item| -> bool,\n+    callback: 'a |&ast::ViewItem| -> bool,\n }\n \n impl<'a> Visitor<()> for EachViewItemData<'a> {\n-    fn visit_view_item(&mut self, view_item: &ast::view_item, _: ()) {\n+    fn visit_view_item(&mut self, view_item: &ast::ViewItem, _: ()) {\n         let _ = (self.callback)(view_item);\n     }\n }\n \n impl EachViewItem for ast::Crate {\n-    fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool {\n+    fn each_view_item(&self, f: |&ast::ViewItem| -> bool) -> bool {\n         let mut visit = EachViewItemData {\n             callback: f,\n         };\n@@ -653,17 +653,16 @@ impl EachViewItem for ast::Crate {\n     }\n }\n \n-pub fn view_path_id(p: &view_path) -> NodeId {\n+pub fn view_path_id(p: &ViewPath) -> NodeId {\n     match p.node {\n-      view_path_simple(_, _, id) |\n-      view_path_glob(_, id) |\n-      view_path_list(_, _, id) => id\n+        ViewPathSimple(_, _, id) | ViewPathGlob(_, id)\n+        | ViewPathList(_, _, id) => id\n     }\n }\n \n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n-pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n+pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {\n     struct_def.ctor_id.is_some()\n }\n "}, {"sha": "c44861bd7d7f729318f81f7fc47f3ab4a5866546", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -66,7 +66,7 @@ impl AttrMetaMethods for MetaItem {\n         match self.node {\n             MetaNameValue(_, ref v) => {\n                 match v.node {\n-                    ast::lit_str(s, _) => Some(s),\n+                    ast::LitStr(s, _) => Some(s),\n                     _ => None,\n                 }\n             },\n@@ -126,11 +126,11 @@ impl AttributeMethods for Attribute {\n /* Constructors */\n \n pub fn mk_name_value_item_str(name: @str, value: @str) -> @MetaItem {\n-    let value_lit = dummy_spanned(ast::lit_str(value, ast::CookedStr));\n+    let value_lit = dummy_spanned(ast::LitStr(value, ast::CookedStr));\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @str, value: ast::lit) -> @MetaItem {\n+pub fn mk_name_value_item(name: @str, value: ast::Lit) -> @MetaItem {\n     @dummy_spanned(MetaNameValue(name, value))\n }\n \n@@ -152,7 +152,7 @@ pub fn mk_attr(item: @MetaItem) -> Attribute {\n \n pub fn mk_sugared_doc_attr(text: @str, lo: BytePos, hi: BytePos) -> Attribute {\n     let style = doc_comment_style(text);\n-    let lit = spanned(lo, hi, ast::lit_str(text, ast::CookedStr));\n+    let lit = spanned(lo, hi, ast::LitStr(text, ast::CookedStr));\n     let attr = Attribute_ {\n         style: style,\n         value: @spanned(lo, hi, MetaNameValue(@\"doc\", lit)),\n@@ -423,16 +423,16 @@ pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprA\n \n fn int_type_of_word(s: &str) -> Option<IntType> {\n     match s {\n-        \"i8\" => Some(SignedInt(ast::ty_i8)),\n-        \"u8\" => Some(UnsignedInt(ast::ty_u8)),\n-        \"i16\" => Some(SignedInt(ast::ty_i16)),\n-        \"u16\" => Some(UnsignedInt(ast::ty_u16)),\n-        \"i32\" => Some(SignedInt(ast::ty_i32)),\n-        \"u32\" => Some(UnsignedInt(ast::ty_u32)),\n-        \"i64\" => Some(SignedInt(ast::ty_i64)),\n-        \"u64\" => Some(UnsignedInt(ast::ty_u64)),\n-        \"int\" => Some(SignedInt(ast::ty_i)),\n-        \"uint\" => Some(UnsignedInt(ast::ty_u)),\n+        \"i8\" => Some(SignedInt(ast::TyI8)),\n+        \"u8\" => Some(UnsignedInt(ast::TyU8)),\n+        \"i16\" => Some(SignedInt(ast::TyI16)),\n+        \"u16\" => Some(UnsignedInt(ast::TyU16)),\n+        \"i32\" => Some(SignedInt(ast::TyI32)),\n+        \"u32\" => Some(UnsignedInt(ast::TyU32)),\n+        \"i64\" => Some(SignedInt(ast::TyI64)),\n+        \"u64\" => Some(UnsignedInt(ast::TyU64)),\n+        \"int\" => Some(SignedInt(ast::TyI)),\n+        \"uint\" => Some(UnsignedInt(ast::TyU)),\n         _ => None\n     }\n }\n@@ -456,8 +456,8 @@ impl ReprAttr {\n \n #[deriving(Eq)]\n pub enum IntType {\n-    SignedInt(ast::int_ty),\n-    UnsignedInt(ast::uint_ty)\n+    SignedInt(ast::IntTy),\n+    UnsignedInt(ast::UintTy)\n }\n \n impl IntType {\n@@ -470,10 +470,10 @@ impl IntType {\n     }\n     fn is_ffi_safe(self) -> bool {\n         match self {\n-            SignedInt(ast::ty_i8) | UnsignedInt(ast::ty_u8) |\n-            SignedInt(ast::ty_i16) | UnsignedInt(ast::ty_u16) |\n-            SignedInt(ast::ty_i32) | UnsignedInt(ast::ty_u32) |\n-            SignedInt(ast::ty_i64) | UnsignedInt(ast::ty_u64) => true,\n+            SignedInt(ast::TyI8) | UnsignedInt(ast::TyU8) |\n+            SignedInt(ast::TyI16) | UnsignedInt(ast::TyU16) |\n+            SignedInt(ast::TyI32) | UnsignedInt(ast::TyU32) |\n+            SignedInt(ast::TyI64) | UnsignedInt(ast::TyU64) => true,\n             _ => false\n         }\n     }"}, {"sha": "18479d4ef414dcf795870c1a2907476aa671762d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 37, "deletions": 35, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -24,7 +24,7 @@ pub trait Emitter {\n     fn emit(&self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n-            lvl: level);\n+            lvl: Level);\n }\n \n // a span-handler is like a handler but also\n@@ -37,18 +37,18 @@ pub struct SpanHandler {\n \n impl SpanHandler {\n     pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, fatal);\n+        self.handler.emit(Some((&*self.cm, sp)), msg, Fatal);\n         fail!();\n     }\n     pub fn span_err(@self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, error);\n+        self.handler.emit(Some((&*self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n     }\n     pub fn span_warn(@self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, warning);\n+        self.handler.emit(Some((&*self.cm, sp)), msg, Warning);\n     }\n     pub fn span_note(@self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, note);\n+        self.handler.emit(Some((&*self.cm, sp)), msg, Note);\n     }\n     pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n@@ -71,11 +71,11 @@ pub struct Handler {\n \n impl Handler {\n     pub fn fatal(@self, msg: &str) -> ! {\n-        self.emit.emit(None, msg, fatal);\n+        self.emit.emit(None, msg, Fatal);\n         fail!();\n     }\n     pub fn err(@self, msg: &str) {\n-        self.emit.emit(None, msg, error);\n+        self.emit.emit(None, msg, Error);\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(@self) {\n@@ -100,10 +100,10 @@ impl Handler {\n         self.fatal(s);\n     }\n     pub fn warn(@self, msg: &str) {\n-        self.emit.emit(None, msg, warning);\n+        self.emit.emit(None, msg, Warning);\n     }\n     pub fn note(@self, msg: &str) {\n-        self.emit.emit(None, msg, note);\n+        self.emit.emit(None, msg, Note);\n     }\n     pub fn bug(@self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n@@ -114,7 +114,7 @@ impl Handler {\n     pub fn emit(@self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n-            lvl: level) {\n+            lvl: Level) {\n         self.emit.emit(cmsp, msg, lvl);\n     }\n }\n@@ -145,28 +145,30 @@ pub fn mk_handler(emitter: Option<@Emitter>) -> @Handler {\n }\n \n #[deriving(Eq)]\n-pub enum level {\n-    fatal,\n-    error,\n-    warning,\n-    note,\n+pub enum Level {\n+    Fatal,\n+    Error,\n+    Warning,\n+    Note,\n }\n \n-fn diagnosticstr(lvl: level) -> ~str {\n-    match lvl {\n-        fatal => ~\"error\",\n-        error => ~\"error\",\n-        warning => ~\"warning\",\n-        note => ~\"note\"\n+impl ToStr for Level {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            Fatal | Error => ~\"error\",\n+            Warning => ~\"warning\",\n+            Note => ~\"note\"\n+        }\n     }\n }\n \n-fn diagnosticcolor(lvl: level) -> term::color::Color {\n-    match lvl {\n-        fatal => term::color::BRIGHT_RED,\n-        error => term::color::BRIGHT_RED,\n-        warning => term::color::BRIGHT_YELLOW,\n-        note => term::color::BRIGHT_GREEN\n+impl Level {\n+    fn color(self) -> term::color::Color {\n+        match self {\n+            Fatal | Error => term::color::BRIGHT_RED,\n+            Warning => term::color::BRIGHT_YELLOW,\n+            Note => term::color::BRIGHT_GREEN\n+        }\n     }\n }\n \n@@ -212,15 +214,15 @@ fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n     }\n }\n \n-fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n+fn print_diagnostic(topic: &str, lvl: Level, msg: &str) {\n     let mut stderr = io::stderr();\n \n     if !topic.is_empty() {\n         write!(&mut stderr as &mut io::Writer, \"{} \", topic);\n     }\n \n-    print_maybe_styled(format!(\"{}: \", diagnosticstr(lvl)),\n-                            term::attr::ForegroundColor(diagnosticcolor(lvl)));\n+    print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n+                       term::attr::ForegroundColor(lvl.color()));\n     print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold);\n }\n \n@@ -230,7 +232,7 @@ impl Emitter for DefaultEmitter {\n     fn emit(&self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n-            lvl: level) {\n+            lvl: Level) {\n         match cmsp {\n             Some((cm, sp)) => {\n                 let sp = cm.adjust_span(sp);\n@@ -247,7 +249,7 @@ impl Emitter for DefaultEmitter {\n \n fn highlight_lines(cm: &codemap::CodeMap,\n                    sp: Span,\n-                   lvl: level,\n+                   lvl: Level,\n                    lines: &codemap::FileLines) {\n     let fm = lines.file;\n     let mut err = io::stderr();\n@@ -308,7 +310,7 @@ fn highlight_lines(cm: &codemap::CodeMap,\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             num_squigglies.times(|| s.push_char('~'));\n         }\n-        print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(diagnosticcolor(lvl)));\n+        print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()));\n     }\n }\n \n@@ -319,10 +321,10 @@ fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        print_diagnostic(ss, note,\n+        print_diagnostic(ss, Note,\n                          format!(\"in expansion of {}{}{}\", pre, ei.callee.name, post));\n         let ss = cm.span_to_str(ei.call_site);\n-        print_diagnostic(ss, note, \"expansion site\");\n+        print_diagnostic(ss, Note, \"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);\n     }\n }"}, {"sha": "e5145d37278712c5d0ff2183d61b7d5d6ec11a57", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -37,7 +37,7 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n@@ -50,7 +50,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let mut cons = ~\"\";\n     let mut volatile = false;\n     let mut alignstack = false;\n-    let mut dialect = ast::asm_att;\n+    let mut dialect = ast::AsmAtt;\n \n     let mut state = Asm;\n \n@@ -139,7 +139,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                 } else if \"alignstack\" == option {\n                     alignstack = true;\n                 } else if \"intel\" == option {\n-                    dialect = ast::asm_intel;\n+                    dialect = ast::AsmIntel;\n                 }\n \n                 if p.token == token::COMMA {\n@@ -187,7 +187,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n \n     MRExpr(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprInlineAsm(ast::inline_asm {\n+        node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: asm,\n             asm_str_style: asm_str_style.unwrap(),\n             clobbers: cons.to_managed(),"}, {"sha": "76135f31e31fedbec836bed62268d62ca19d1b57", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -25,17 +25,17 @@ use std::hashmap::HashMap;\n //\n //    MacResult, NormalTT, IdentTT\n //\n-// also note that ast::mac used to have a bunch of extraneous cases and\n+// also note that ast::Mac used to have a bunch of extraneous cases and\n // is now probably a redundant AST node, can be merged with\n-// ast::mac_invoc_tt.\n+// ast::MacInvocTT.\n \n pub struct MacroDef {\n     name: @str,\n     ext: SyntaxExtension\n }\n \n pub type ItemDecorator =\n-    fn(&ExtCtxt, Span, @ast::MetaItem, ~[@ast::item]) -> ~[@ast::item];\n+    fn(&ExtCtxt, Span, @ast::MetaItem, ~[@ast::Item]) -> ~[@ast::Item];\n \n pub struct SyntaxExpanderTT {\n     expander: SyntaxExpanderTTExpander,\n@@ -46,13 +46,13 @@ pub trait SyntaxExpanderTTTrait {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              token_tree: &[ast::token_tree],\n+              token_tree: &[ast::TokenTree],\n               context: ast::SyntaxContext)\n               -> MacResult;\n }\n \n pub type SyntaxExpanderTTFunNoCtxt =\n-    fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::token_tree])\n+    fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n        -> MacResult;\n \n enum SyntaxExpanderTTExpander {\n@@ -63,7 +63,7 @@ impl SyntaxExpanderTTTrait for SyntaxExpanderTT {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n-              token_tree: &[ast::token_tree],\n+              token_tree: &[ast::TokenTree],\n               _: ast::SyntaxContext)\n               -> MacResult {\n         match self.expander {\n@@ -89,7 +89,7 @@ pub trait SyntaxExpanderTTItemTrait {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::token_tree],\n+              token_tree: ~[ast::TokenTree],\n               context: ast::SyntaxContext)\n               -> MacResult;\n }\n@@ -99,7 +99,7 @@ impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               ident: ast::Ident,\n-              token_tree: ~[ast::token_tree],\n+              token_tree: ~[ast::TokenTree],\n               context: ast::SyntaxContext)\n               -> MacResult {\n         match self.expander {\n@@ -114,21 +114,21 @@ impl SyntaxExpanderTTItemTrait for SyntaxExpanderTTItem {\n }\n \n pub type SyntaxExpanderTTItemFun =\n-    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::token_tree], ast::SyntaxContext)\n+    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::TokenTree], ast::SyntaxContext)\n        -> MacResult;\n \n pub type SyntaxExpanderTTItemFunNoCtxt =\n-    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::token_tree]) -> MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, ~[ast::TokenTree]) -> MacResult;\n \n pub trait AnyMacro {\n     fn make_expr(&self) -> @ast::Expr;\n-    fn make_items(&self) -> SmallVector<@ast::item>;\n+    fn make_items(&self) -> SmallVector<@ast::Item>;\n     fn make_stmt(&self) -> @ast::Stmt;\n }\n \n pub enum MacResult {\n     MRExpr(@ast::Expr),\n-    MRItem(@ast::item),\n+    MRItem(@ast::Item),\n     MRAny(@AnyMacro),\n     MRDef(MacroDef),\n }\n@@ -393,15 +393,15 @@ impl ExtCtxt {\n \n pub fn expr_to_str(cx: &ExtCtxt, expr: @ast::Expr, err_msg: &str) -> (@str, ast::StrStyle) {\n     match expr.node {\n-      ast::ExprLit(l) => match l.node {\n-        ast::lit_str(s, style) => (s, style),\n-        _ => cx.span_fatal(l.span, err_msg)\n-      },\n-      _ => cx.span_fatal(expr.span, err_msg)\n+        ast::ExprLit(l) => match l.node {\n+            ast::LitStr(s, style) => (s, style),\n+            _ => cx.span_fatal(l.span, err_msg)\n+        },\n+        _ => cx.span_fatal(expr.span, err_msg)\n     }\n }\n \n-pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, format!(\"{} takes no arguments\", name));\n@@ -410,23 +410,23 @@ pub fn check_zero_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree],\n \n pub fn get_single_str_from_tts(cx: &ExtCtxt,\n                                sp: Span,\n-                               tts: &[ast::token_tree],\n+                               tts: &[ast::TokenTree],\n                                name: &str)\n                                -> @str {\n     if tts.len() != 1 {\n         cx.span_fatal(sp, format!(\"{} takes 1 argument.\", name));\n     }\n \n     match tts[0] {\n-        ast::tt_tok(_, token::LIT_STR(ident))\n-        | ast::tt_tok(_, token::LIT_STR_RAW(ident, _)) => cx.str_of(ident),\n+        ast::TTTok(_, token::LIT_STR(ident))\n+        | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => cx.str_of(ident),\n         _ => cx.span_fatal(sp, format!(\"{} requires a string.\", name)),\n     }\n }\n \n pub fn get_exprs_from_tts(cx: &ExtCtxt,\n                           sp: Span,\n-                          tts: &[ast::token_tree]) -> ~[@ast::Expr] {\n+                          tts: &[ast::TokenTree]) -> ~[@ast::Expr] {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.to_owned());"}, {"sha": "85cda0bd1ae83d363b9ca9411305da93989f72e4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 99, "deletions": 108, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -15,7 +15,7 @@ use ast_util;\n use codemap::{Span, respan, DUMMY_SP};\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n-use fold::ast_fold;\n+use fold::Folder;\n use opt_vec;\n use opt_vec::OptVec;\n \n@@ -43,9 +43,9 @@ pub trait AstBuilder {\n         -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy;\n \n-    fn ty(&self, span: Span, ty: ast::ty_) -> P<ast::Ty>;\n+    fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty>;\n     fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> P<ast::Ty>;\n     fn ty_ident(&self, span: Span, idents: ast::Ident) -> P<ast::Ty>;\n \n@@ -67,7 +67,7 @@ pub trait AstBuilder {\n \n     fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n-    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n+    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n \n@@ -86,7 +86,7 @@ pub trait AstBuilder {\n     fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@ast::Expr>) -> P<ast::Block>;\n     fn block_expr(&self, expr: @ast::Expr) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: ~[ast::view_item],\n+                 view_items: ~[ast::ViewItem],\n                  stmts: ~[@ast::Stmt],\n                  expr: Option<@ast::Expr>) -> P<ast::Block>;\n \n@@ -119,7 +119,7 @@ pub trait AstBuilder {\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::Expr;\n     fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::Expr;\n \n-    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::Expr;\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr;\n \n     fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr;\n     fn expr_int(&self, sp: Span, i: int) -> @ast::Expr;\n@@ -160,7 +160,7 @@ pub trait AstBuilder {\n                cond: @ast::Expr, then: @ast::Expr, els: Option<@ast::Expr>) -> @ast::Expr;\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::fn_decl>, blk: P<ast::Block>) -> @ast::Expr;\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr;\n \n     fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr;\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> @ast::Expr;\n@@ -176,64 +176,64 @@ pub trait AstBuilder {\n \n     // items\n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n+            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item;\n \n-    fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::arg;\n+    fn arg(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::Arg;\n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: P<ast::Ty>) -> P<ast::fn_decl>;\n+    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl>;\n \n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::arg],\n+                    inputs: ~[ast::Arg],\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::item;\n+                    body: P<ast::Block>) -> @ast::Item;\n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::arg],\n+               inputs: ~[ast::Arg],\n                output: P<ast::Ty>,\n-               body: P<ast::Block>) -> @ast::item;\n+               body: P<ast::Block>) -> @ast::Item;\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::variant;\n+    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n                       name: Ident,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item;\n-    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::enum_def) -> @ast::item;\n+                      enum_definition: ast::EnumDef,\n+                      generics: Generics) -> @ast::Item;\n+    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::EnumDef) -> @ast::Item;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n                         name: Ident,\n-                        struct_def: ast::struct_def,\n-                        generics: Generics) -> @ast::item;\n-    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::struct_def) -> @ast::item;\n+                        struct_def: ast::StructDef,\n+                        generics: Generics) -> @ast::Item;\n+    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::StructDef) -> @ast::Item;\n \n     fn item_mod(&self, span: Span,\n                 name: Ident, attrs: ~[ast::Attribute],\n-                vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n+                vi: ~[ast::ViewItem], items: ~[@ast::Item]) -> @ast::Item;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n                     ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::item;\n+                    generics: Generics) -> @ast::Item;\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item;\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n     fn meta_word(&self, sp: Span, w: @str) -> @ast::MetaItem;\n     fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem;\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::lit_) -> @ast::MetaItem;\n+    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem;\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n-    fn view_use_list(&self, sp: Span, vis: ast::visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item;\n+                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem;\n+    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem;\n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item;\n+                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem;\n }\n \n impl AstBuilder for ExtCtxt {\n@@ -274,14 +274,14 @@ impl AstBuilder for ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::mt {\n-        ast::mt {\n+    fn ty_mt(&self, ty: P<ast::Ty>, mutbl: ast::Mutability) -> ast::MutTy {\n+        ast::MutTy {\n             ty: ty,\n             mutbl: mutbl\n         }\n     }\n \n-    fn ty(&self, span: Span, ty: ast::ty_) -> P<ast::Ty> {\n+    fn ty(&self, span: Span, ty: ast::Ty_) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n             span: span,\n@@ -292,7 +292,7 @@ impl AstBuilder for ExtCtxt {\n     fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n               -> P<ast::Ty> {\n         self.ty(path.span,\n-                ast::ty_path(path, bounds, ast::DUMMY_NODE_ID))\n+                ast::TyPath(path, bounds, ast::DUMMY_NODE_ID))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n@@ -309,15 +309,15 @@ impl AstBuilder for ExtCtxt {\n                mutbl: ast::Mutability)\n         -> P<ast::Ty> {\n         self.ty(span,\n-                ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n+                ast::TyRptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n \n     fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty(span, ast::ty_uniq(ty))\n+        self.ty(span, ast::TyUniq(ty))\n     }\n \n     fn ty_box(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty(span, ast::ty_box(ty))\n+        self.ty(span, ast::TyBox(ty))\n     }\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n@@ -336,19 +336,19 @@ impl AstBuilder for ExtCtxt {\n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {\n         ast::TypeField {\n             ident: name,\n-            mt: ast::mt { ty: ty, mutbl: ast::MutImmutable },\n+            mt: ast::MutTy { ty: ty, mutbl: ast::MutImmutable },\n             span: span,\n         }\n     }\n \n     fn ty_infer(&self, span: Span) -> P<ast::Ty> {\n-        self.ty(span, ast::ty_infer)\n+        self.ty(span, ast::TyInfer)\n     }\n \n     fn ty_nil(&self) -> P<ast::Ty> {\n         P(ast::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::ty_nil,\n+            node: ast::TyNil,\n             span: DUMMY_SP,\n         })\n     }\n@@ -381,8 +381,8 @@ impl AstBuilder for ExtCtxt {\n         }\n     }\n \n-    fn trait_ref(&self, path: ast::Path) -> ast::trait_ref {\n-        ast::trait_ref {\n+    fn trait_ref(&self, path: ast::Path) -> ast::TraitRef {\n+        ast::TraitRef {\n             path: path,\n             ref_id: ast::DUMMY_NODE_ID\n         }\n@@ -449,7 +449,7 @@ impl AstBuilder for ExtCtxt {\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: ~[ast::view_item],\n+                 view_items: ~[ast::ViewItem],\n                  stmts: ~[@ast::Stmt],\n                  expr: Option<@ast::Expr>) -> P<ast::Block> {\n             P(ast::Block {\n@@ -541,20 +541,20 @@ impl AstBuilder for ExtCtxt {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n-    fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::Expr {\n+    fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> @ast::Expr {\n         self.expr(sp, ast::ExprLit(@respan(sp, lit)))\n     }\n     fn expr_uint(&self, span: Span, i: uint) -> @ast::Expr {\n-        self.expr_lit(span, ast::lit_uint(i as u64, ast::ty_u))\n+        self.expr_lit(span, ast::LitUint(i as u64, ast::TyU))\n     }\n     fn expr_int(&self, sp: Span, i: int) -> @ast::Expr {\n-        self.expr_lit(sp, ast::lit_int(i as i64, ast::ty_i))\n+        self.expr_lit(sp, ast::LitInt(i as i64, ast::TyI))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> @ast::Expr {\n-        self.expr_lit(sp, ast::lit_uint(u as u64, ast::ty_u8))\n+        self.expr_lit(sp, ast::LitUint(u as u64, ast::TyU8))\n     }\n     fn expr_bool(&self, sp: Span, value: bool) -> @ast::Expr {\n-        self.expr_lit(sp, ast::lit_bool(value))\n+        self.expr_lit(sp, ast::LitBool(value))\n     }\n \n     fn expr_vstore(&self, sp: Span, expr: @ast::Expr, vst: ast::ExprVstore) -> @ast::Expr {\n@@ -570,7 +570,7 @@ impl AstBuilder for ExtCtxt {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::ExprVstoreSlice)\n     }\n     fn expr_str(&self, sp: Span, s: @str) -> @ast::Expr {\n-        self.expr_lit(sp, ast::lit_str(s, ast::CookedStr))\n+        self.expr_lit(sp, ast::LitStr(s, ast::CookedStr))\n     }\n     fn expr_str_uniq(&self, sp: Span, s: @str) -> @ast::Expr {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::ExprVstoreUniq)\n@@ -675,7 +675,7 @@ impl AstBuilder for ExtCtxt {\n     }\n \n     fn lambda_fn_decl(&self, span: Span,\n-                      fn_decl: P<ast::fn_decl>, blk: P<ast::Block>) -> @ast::Expr {\n+                      fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> @ast::Expr {\n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: P<ast::Block>) -> @ast::Expr {\n@@ -715,61 +715,61 @@ impl AstBuilder for ExtCtxt {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::arg {\n+    fn arg(&self, span: Span, ident: ast::Ident, ty: P<ast::Ty>) -> ast::Arg {\n         let arg_pat = self.pat_ident(span, ident);\n-        ast::arg {\n+        ast::Arg {\n             ty: ty,\n             pat: arg_pat,\n             id: ast::DUMMY_NODE_ID\n         }\n     }\n \n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: P<ast::Ty>) -> P<ast::fn_decl> {\n-        P(ast::fn_decl {\n+    fn fn_decl(&self, inputs: ~[ast::Arg], output: P<ast::Ty>) -> P<ast::FnDecl> {\n+        P(ast::FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: ast::return_val,\n+            cf: ast::Return,\n             variadic: false\n         })\n     }\n \n     fn item(&self, span: Span,\n-            name: Ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item {\n+            name: Ident, attrs: ~[ast::Attribute], node: ast::Item_) -> @ast::Item {\n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n-        @ast::item { ident: name,\n+        @ast::Item { ident: name,\n                     attrs: attrs,\n                     id: ast::DUMMY_NODE_ID,\n                     node: node,\n-                    vis: ast::inherited,\n+                    vis: ast::Inherited,\n                     span: span }\n     }\n \n     fn item_fn_poly(&self,\n                     span: Span,\n                     name: Ident,\n-                    inputs: ~[ast::arg],\n+                    inputs: ~[ast::Arg],\n                     output: P<ast::Ty>,\n                     generics: Generics,\n-                    body: P<ast::Block>) -> @ast::item {\n+                    body: P<ast::Block>) -> @ast::Item {\n         self.item(span,\n                   name,\n                   ~[],\n-                  ast::item_fn(self.fn_decl(inputs, output),\n-                               ast::impure_fn,\n-                               AbiSet::Rust(),\n-                               generics,\n-                               body))\n+                  ast::ItemFn(self.fn_decl(inputs, output),\n+                              ast::ImpureFn,\n+                              AbiSet::Rust(),\n+                              generics,\n+                              body))\n     }\n \n     fn item_fn(&self,\n                span: Span,\n                name: Ident,\n-               inputs: ~[ast::arg],\n+               inputs: ~[ast::Arg],\n                output: P<ast::Ty>,\n                body: P<ast::Block>\n-              ) -> @ast::item {\n+              ) -> @ast::Item {\n         self.item_fn_poly(\n             span,\n             name,\n@@ -779,40 +779,36 @@ impl AstBuilder for ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::variant {\n+    fn variant(&self, span: Span, name: Ident, tys: ~[P<ast::Ty>]) -> ast::Variant {\n         let args = tys.move_iter().map(|ty| {\n-            ast::variant_arg { ty: ty, id: ast::DUMMY_NODE_ID }\n+            ast::VariantArg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n \n         respan(span,\n-               ast::variant_ {\n+               ast::Variant_ {\n                    name: name,\n                    attrs: ~[],\n-                   kind: ast::tuple_variant_kind(args),\n+                   kind: ast::TupleVariantKind(args),\n                    id: ast::DUMMY_NODE_ID,\n                    disr_expr: None,\n-                   vis: ast::public\n+                   vis: ast::Public\n                })\n     }\n \n     fn item_enum_poly(&self, span: Span, name: Ident,\n-                      enum_definition: ast::enum_def,\n-                      generics: Generics) -> @ast::item {\n-        self.item(span, name, ~[], ast::item_enum(enum_definition, generics))\n+                      enum_definition: ast::EnumDef,\n+                      generics: Generics) -> @ast::Item {\n+        self.item(span, name, ~[], ast::ItemEnum(enum_definition, generics))\n     }\n \n     fn item_enum(&self, span: Span, name: Ident,\n-                 enum_definition: ast::enum_def) -> @ast::item {\n+                 enum_definition: ast::EnumDef) -> @ast::Item {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n     }\n \n-    fn item_struct(\n-        &self,\n-        span: Span,\n-        name: Ident,\n-        struct_def: ast::struct_def\n-    ) -> @ast::item {\n+    fn item_struct(&self, span: Span, name: Ident,\n+                   struct_def: ast::StructDef) -> @ast::Item {\n         self.item_struct_poly(\n             span,\n             name,\n@@ -821,37 +817,32 @@ impl AstBuilder for ExtCtxt {\n         )\n     }\n \n-    fn item_struct_poly(\n-        &self,\n-        span: Span,\n-        name: Ident,\n-        struct_def: ast::struct_def,\n-        generics: Generics\n-    ) -> @ast::item {\n-        self.item(span, name, ~[], ast::item_struct(@struct_def, generics))\n+    fn item_struct_poly(&self, span: Span, name: Ident,\n+        struct_def: ast::StructDef, generics: Generics) -> @ast::Item {\n+        self.item(span, name, ~[], ast::ItemStruct(@struct_def, generics))\n     }\n \n     fn item_mod(&self, span: Span, name: Ident,\n                 attrs: ~[ast::Attribute],\n-                vi: ~[ast::view_item],\n-                items: ~[@ast::item]) -> @ast::item {\n+                vi: ~[ast::ViewItem],\n+                items: ~[@ast::Item]) -> @ast::Item {\n         self.item(\n             span,\n             name,\n             attrs,\n-            ast::item_mod(ast::_mod {\n+            ast::ItemMod(ast::Mod {\n                 view_items: vi,\n                 items: items,\n             })\n         )\n     }\n \n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n-                    generics: Generics) -> @ast::item {\n-        self.item(span, name, ~[], ast::item_ty(ty, generics))\n+                    generics: Generics) -> @ast::Item {\n+        self.item(span, name, ~[], ast::ItemTy(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::item {\n+    fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> @ast::Item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n@@ -869,46 +860,46 @@ impl AstBuilder for ExtCtxt {\n     fn meta_list(&self, sp: Span, name: @str, mis: ~[@ast::MetaItem]) -> @ast::MetaItem {\n         @respan(sp, ast::MetaList(name, mis))\n     }\n-    fn meta_name_value(&self, sp: Span, name: @str, value: ast::lit_) -> @ast::MetaItem {\n+    fn meta_name_value(&self, sp: Span, name: @str, value: ast::Lit_) -> @ast::MetaItem {\n         @respan(sp, ast::MetaNameValue(name, respan(sp, value)))\n     }\n \n     fn view_use(&self, sp: Span,\n-                vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item {\n-        ast::view_item {\n-            node: ast::view_item_use(vp),\n+                vis: ast::Visibility, vp: ~[@ast::ViewPath]) -> ast::ViewItem {\n+        ast::ViewItem {\n+            node: ast::ViewItemUse(vp),\n             attrs: ~[],\n             vis: vis,\n             span: sp\n         }\n     }\n \n-    fn view_use_list(&self, sp: Span, vis: ast::visibility,\n-                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item {\n+    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::ViewItem {\n         let imports = imports.map(|id| {\n-            respan(sp, ast::path_list_ident_ { name: *id, id: ast::DUMMY_NODE_ID })\n+            respan(sp, ast::PathListIdent_ { name: *id, id: ast::DUMMY_NODE_ID })\n         });\n \n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n-                                ast::view_path_list(self.path(sp, path),\n-                                                    imports,\n-                                                    ast::DUMMY_NODE_ID))])\n+                                ast::ViewPathList(self.path(sp, path),\n+                                                  imports,\n+                                                  ast::DUMMY_NODE_ID))])\n     }\n \n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item {\n+                     vis: ast::Visibility, path: ~[ast::Ident]) -> ast::ViewItem {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n-                                ast::view_path_glob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n+                                ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n     }\n }\n \n struct Duplicator<'a> {\n     cx: &'a ExtCtxt,\n }\n \n-impl<'a> ast_fold for Duplicator<'a> {\n+impl<'a> Folder for Duplicator<'a> {\n     fn new_id(&mut self, _: NodeId) -> NodeId {\n         ast::DUMMY_NODE_ID\n     }"}, {"sha": "945e7c0d66693e988193ed916a0506626d0c6272", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -18,7 +18,7 @@ use ext::build::AstBuilder;\n \n use std::char;\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n     let mut bytes = ~[];\n@@ -28,14 +28,14 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) ->\n             // expression is a literal\n             ast::ExprLit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n-                ast::lit_str(s, _) => {\n+                ast::LitStr(s, _) => {\n                     for byte in s.bytes() {\n                         bytes.push(cx.expr_u8(expr.span, byte));\n                     }\n                 }\n \n                 // u8 literal, push to vector expression\n-                ast::lit_uint(v, ast::ty_u8) => {\n+                ast::LitUint(v, ast::TyU8) => {\n                     if v > 0xFF {\n                         cx.span_err(expr.span, \"Too large u8 literal in bytes!\")\n                     } else {\n@@ -44,7 +44,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) ->\n                 }\n \n                 // integer literal, push to vector expression\n-                ast::lit_int_unsuffixed(v) => {\n+                ast::LitIntUnsuffixed(v) => {\n                     if v > 0xFF {\n                         cx.span_err(expr.span, \"Too large integer literal in bytes!\")\n                     } else if v < 0 {\n@@ -55,7 +55,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) ->\n                 }\n \n                 // char literal, push to vector expression\n-                ast::lit_char(v) => {\n+                ast::LitChar(v) => {\n                     if char::from_u32(v).unwrap().is_ascii() {\n                         bytes.push(cx.expr_u8(expr.span, v as u8));\n                     } else {"}, {"sha": "9af295c0b113c77a229ce475ceec4af5fe678738", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -23,9 +23,9 @@ use attr;\n use attr::*;\n use parse;\n use parse::token;\n-use parse::attr::parser_attr;\n+use parse::attr::ParserAttr;\n \n-pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.to_owned());"}, {"sha": "251492141c8fd9a5fc4ecf3c41b7ddfbc53fcfb3", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -17,34 +17,32 @@ use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let es = base::get_exprs_from_tts(cx, sp, tts);\n     let mut accumulator = ~\"\";\n     for e in es.move_iter() {\n         let e = cx.expand_expr(e);\n         match e.node {\n             ast::ExprLit(lit) => {\n                 match lit.node {\n-                    ast::lit_str(s, _) |\n-                    ast::lit_float(s, _) |\n-                    ast::lit_float_unsuffixed(s) => {\n+                    ast::LitStr(s, _) | ast::LitFloat(s, _)\n+                    | ast::LitFloatUnsuffixed(s) => {\n                         accumulator.push_str(s);\n                     }\n-                    ast::lit_char(c) => {\n+                    ast::LitChar(c) => {\n                         accumulator.push_char(char::from_u32(c).unwrap());\n                     }\n-                    ast::lit_int(i, _) |\n-                    ast::lit_int_unsuffixed(i) => {\n+                    ast::LitInt(i, _) | ast::LitIntUnsuffixed(i) => {\n                         accumulator.push_str(format!(\"{}\", i));\n                     }\n-                    ast::lit_uint(u, _) => {\n+                    ast::LitUint(u, _) => {\n                         accumulator.push_str(format!(\"{}\", u));\n                     }\n-                    ast::lit_nil => {}\n-                    ast::lit_bool(b) => {\n+                    ast::LitNil => {}\n+                    ast::LitBool(b) => {\n                         accumulator.push_str(format!(\"{}\", b));\n                     }\n-                    ast::lit_binary(..) => {\n+                    ast::LitBinary(..) => {\n                         cx.span_err(e.span, \"cannot concatenate a binary literal\");\n                     }\n                 }"}, {"sha": "0d053bb1d12ca41ea6bf6bd038a0f4d8b76c1328", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -16,18 +16,18 @@ use opt_vec;\n use parse::token;\n use parse::token::{str_to_ident};\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n-                ast::tt_tok(_, token::COMMA) => (),\n+                ast::TTTok(_, token::COMMA) => (),\n                 _ => cx.span_fatal(sp, \"concat_idents! expecting comma.\")\n             }\n         } else {\n             match *e {\n-                ast::tt_tok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n+                ast::TTTok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n                 _ => cx.span_fatal(sp, \"concat_idents! requires ident args.\")\n             }\n         }"}, {"sha": "aa8dcc3981b909a6cb2152b677d2ce6ecfb7c569", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,8 +17,8 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_clone(cx: &ExtCtxt,\n                              span: Span,\n                              mitem: @MetaItem,\n-                             in_items: ~[@item])\n-                          -> ~[@item] {\n+                             in_items: ~[@Item])\n+                          -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n \n@@ -45,8 +45,8 @@ pub fn expand_deriving_clone(cx: &ExtCtxt,\n pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n-                                  in_items: ~[@item])\n-    -> ~[@item] {\n+                                  in_items: ~[@Item])\n+    -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "99b5163214a5e90093dee33c50d0a77f742627a8", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,7 +17,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_eq(cx: &ExtCtxt,\n                           span: Span,\n                           mitem: @MetaItem,\n-                          in_items: ~[@item]) -> ~[@item] {\n+                          in_items: ~[@Item]) -> ~[@Item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {"}, {"sha": "8a2b11b798cda5241994232cd3fdba0bca34060f", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -18,7 +18,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_ord(cx: &ExtCtxt,\n                            span: Span,\n                            mitem: @MetaItem,\n-                           in_items: ~[@item]) -> ~[@item] {\n+                           in_items: ~[@Item]) -> ~[@Item] {\n     macro_rules! md (\n         ($name:expr, $op:expr, $equal:expr) => {\n             MethodDef {"}, {"sha": "6a1aaeb2f9eaaddcd79da6e90a2c3eb2f4e64df1", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,7 +17,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_totaleq(cx: &ExtCtxt,\n                                span: Span,\n                                mitem: @MetaItem,\n-                               in_items: ~[@item]) -> ~[@item] {\n+                               in_items: ~[@Item]) -> ~[@Item] {\n     fn cs_equals(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cs_and(|cx, span, _, _| cx.expr_bool(span, false),\n                cx, span, substr)"}, {"sha": "f1e360f20ba0c918d9d8935449cc552ba4f886b8", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -19,7 +19,7 @@ use std::cmp::{Ordering, Equal, Less, Greater};\n pub fn expand_deriving_totalord(cx: &ExtCtxt,\n                                 span: Span,\n                                 mitem: @MetaItem,\n-                                in_items: ~[@item]) -> ~[@item] {\n+                                in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "9272152e8d57838b057323125a78e4ef5ac90e88", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -13,7 +13,7 @@ The compiler code necessary for #[deriving(Decodable)]. See\n encodable.rs for more.\n */\n \n-use ast::{MetaItem, item, Expr, MutMutable, Ident};\n+use ast::{MetaItem, Item, Expr, MutMutable, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -22,7 +22,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_decodable(cx: &ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n-                                 in_items: ~[@item]) -> ~[@item] {\n+                                 in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "0ae3c6f45933b363cf8723b15f2d10386c39ce79", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,8 +17,8 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_default(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n-                            in_items: ~[@item])\n-    -> ~[@item] {\n+                            in_items: ~[@Item])\n+    -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "285bf86916e349c7b8e246db3d896e1f5214d564", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -75,7 +75,7 @@ would yield functions like:\n     }\n */\n \n-use ast::{MetaItem, item, Expr, MutImmutable, MutMutable};\n+use ast::{MetaItem, Item, Expr, MutImmutable, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -84,7 +84,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_encodable(cx: &ExtCtxt,\n                                  span: Span,\n                                  mitem: @MetaItem,\n-                                 in_items: ~[@item]) -> ~[@item] {\n+                                 in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "826d5381d4743c9d5a00f4186168a3db023f3385", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -126,7 +126,7 @@ When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n ~~~\n-EnumMatching(0, <ast::variant for C0>,\n+EnumMatching(0, <ast::Variant for C0>,\n              ~[FieldInfo {\n                 span: <span of int>\n                 name: None,\n@@ -138,7 +138,7 @@ EnumMatching(0, <ast::variant for C0>,\n For `C1 {x}` and `C1 {x}`,\n \n ~~~\n-EnumMatching(1, <ast::variant for C1>,\n+EnumMatching(1, <ast::Variant for C1>,\n              ~[FieldInfo {\n                 span: <span of x>\n                 name: Some(<ident of x>),\n@@ -150,9 +150,9 @@ EnumMatching(1, <ast::variant for C1>,\n For `C0(a)` and `C1 {x}` ,\n \n ~~~\n-EnumNonMatching(~[(0, <ast::variant for B0>,\n+EnumNonMatching(~[(0, <ast::Variant for B0>,\n                    ~[(<span of int>, None, <expr for &a>)]),\n-                  (1, <ast::variant for B1>,\n+                  (1, <ast::Variant for B1>,\n                    ~[(<span of x>, Some(<ident of x>),\n                       <expr for &other.x>)])])\n ~~~\n@@ -164,18 +164,18 @@ EnumNonMatching(~[(0, <ast::variant for B0>,\n A static method on the above would result in,\n \n ~~~~\n-StaticStruct(<ast::struct_def of A>, Named(~[(<ident of x>, <span of x>)]))\n+StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n \n-StaticStruct(<ast::struct_def of B>, Unnamed(~[<span of x>]))\n+StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n \n-StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n-                                   (<ident of C1>, Named(~[(<ident of x>, <span of x>)]))])\n+StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n+                                  (<ident of C1>, Named(~[(<ident of x>, <span of x>)]))])\n ~~~\n \n */\n \n use ast;\n-use ast::{P, enum_def, Expr, Ident, Generics, struct_def};\n+use ast::{P, EnumDef, Expr, Ident, Generics, StructDef};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -274,23 +274,23 @@ pub enum StaticFields {\n pub enum SubstructureFields<'a> {\n     Struct(~[FieldInfo]),\n     /**\n-    Matching variants of the enum: variant index, ast::variant,\n+    Matching variants of the enum: variant index, ast::Variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'a ast::variant, ~[FieldInfo]),\n+    EnumMatching(uint, &'a ast::Variant, ~[FieldInfo]),\n \n     /**\n-    non-matching variants of the enum, [(variant index, ast::variant,\n+    non-matching variants of the enum, [(variant index, ast::Variant,\n     [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'a [(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])]),\n \n     /// A static method where Self is a struct.\n-    StaticStruct(&'a ast::struct_def, StaticFields),\n+    StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::enum_def, ~[(Ident, StaticFields)])\n+    StaticEnum(&'a ast::EnumDef, ~[(Ident, StaticFields)])\n }\n \n \n@@ -304,31 +304,31 @@ pub type CombineSubstructureFunc<'a> =\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n-representing each variant: (variant index, ast::variant instance,\n+representing each variant: (variant index, ast::Variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'a> =\n     'a |&ExtCtxt,\n            Span,\n-           &[(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])],\n+           &[(uint, P<ast::Variant>, ~[(Span, Option<Ident>, @Expr)])],\n            &[@Expr]|\n            -> @Expr;\n \n \n impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   _mitem: @ast::MetaItem,\n-                  in_items: ~[@ast::item]) -> ~[@ast::item] {\n+                  in_items: ~[@ast::Item]) -> ~[@ast::Item] {\n         let mut result = ~[];\n         for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n-                ast::item_struct(struct_def, ref generics) => {\n+                ast::ItemStruct(struct_def, ref generics) => {\n                     result.push(self.expand_struct_def(struct_def,\n                                                        item.ident,\n                                                        generics));\n                 }\n-                ast::item_enum(ref enum_def, ref generics) => {\n+                ast::ItemEnum(ref enum_def, ref generics) => {\n                     result.push(self.expand_enum_def(enum_def,\n                                                      item.ident,\n                                                      generics));\n@@ -351,7 +351,7 @@ impl<'a> TraitDef<'a> {\n      */\n     fn create_derived_impl(&self,\n                            type_ident: Ident, generics: &Generics,\n-                           methods: ~[@ast::method]) -> @ast::item {\n+                           methods: ~[@ast::Method]) -> @ast::Item {\n         let cx = self.cx;\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n@@ -395,21 +395,19 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             cx.meta_name_value(self.span,\n                                @\"doc\",\n-                               ast::lit_str(@\"Automatically derived.\", ast::CookedStr)));\n+                               ast::LitStr(@\"Automatically derived.\", ast::CookedStr)));\n         cx.item(\n             self.span,\n             ::parse::token::special_idents::clownshoes_extensions,\n             ~[doc_attr],\n-            ast::item_impl(trait_generics,\n-                           Some(trait_ref),\n-                           self_type,\n-                           methods.map(|x| *x)))\n+            ast::ItemImpl(trait_generics, Some(trait_ref),\n+                          self_type, methods.map(|x| *x)))\n     }\n \n     fn expand_struct_def(&self,\n-                         struct_def: &struct_def,\n+                         struct_def: &StructDef,\n                          type_ident: Ident,\n-                         generics: &Generics) -> @ast::item {\n+                         generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(self, type_ident, generics);\n@@ -437,9 +435,9 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn expand_enum_def(&self,\n-                       enum_def: &enum_def,\n+                       enum_def: &EnumDef,\n                        type_ident: Ident,\n-                       generics: &Generics) -> @ast::item {\n+                       generics: &Generics) -> @ast::Item {\n         let methods = self.methods.map(|method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n                 method_def.split_self_nonself_args(self, type_ident, generics);\n@@ -497,7 +495,7 @@ impl<'a> MethodDef<'a> {\n \n     fn split_self_nonself_args(&self, trait_: &TraitDef,\n                                type_ident: Ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n+        -> (ast::ExplicitSelf, ~[@Expr], ~[@Expr], ~[(Ident, P<ast::Ty>)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -514,7 +512,7 @@ impl<'a> MethodDef<'a> {\n \n                 explicit_self\n             }\n-            None => codemap::respan(trait_.span, ast::sty_static),\n+            None => codemap::respan(trait_.span, ast::SelfStatic),\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n@@ -545,9 +543,9 @@ impl<'a> MethodDef<'a> {\n     fn create_method(&self, trait_: &TraitDef,\n                      type_ident: Ident,\n                      generics: &Generics,\n-                     explicit_self: ast::explicit_self,\n+                     explicit_self: ast::ExplicitSelf,\n                      arg_types: ~[(Ident, P<ast::Ty>)],\n-                     body: @Expr) -> @ast::method {\n+                     body: @Expr) -> @ast::Method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(trait_.cx, trait_.span, type_ident, generics);\n \n@@ -568,18 +566,18 @@ impl<'a> MethodDef<'a> {\n         };\n \n         // Create the method.\n-        @ast::method {\n+        @ast::Method {\n             ident: method_ident,\n             attrs: attrs,\n             generics: fn_generics,\n             explicit_self: explicit_self,\n-            purity: ast::impure_fn,\n+            purity: ast::ImpureFn,\n             decl: fn_decl,\n             body: body_block,\n             id: ast::DUMMY_NODE_ID,\n             span: trait_.span,\n             self_id: ast::DUMMY_NODE_ID,\n-            vis: ast::inherited,\n+            vis: ast::Inherited,\n         }\n     }\n \n@@ -606,7 +604,7 @@ impl<'a> MethodDef<'a> {\n     */\n     fn expand_struct_method_body(&self,\n                                  trait_: &TraitDef,\n-                                 struct_def: &struct_def,\n+                                 struct_def: &StructDef,\n                                  type_ident: Ident,\n                                  self_args: &[@Expr],\n                                  nonself_args: &[@Expr])\n@@ -665,7 +663,7 @@ impl<'a> MethodDef<'a> {\n \n     fn expand_static_struct_method_body(&self,\n                                         trait_: &TraitDef,\n-                                        struct_def: &struct_def,\n+                                        struct_def: &StructDef,\n                                         type_ident: Ident,\n                                         self_args: &[@Expr],\n                                         nonself_args: &[@Expr])\n@@ -706,7 +704,7 @@ impl<'a> MethodDef<'a> {\n     */\n     fn expand_enum_method_body(&self,\n                                trait_: &TraitDef,\n-                               enum_def: &enum_def,\n+                               enum_def: &EnumDef,\n                                type_ident: Ident,\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n@@ -741,12 +739,12 @@ impl<'a> MethodDef<'a> {\n     */\n     fn build_enum_match(&self,\n                         trait_: &TraitDef,\n-                        enum_def: &enum_def,\n+                        enum_def: &EnumDef,\n                         type_ident: Ident,\n                         self_args: &[@Expr],\n                         nonself_args: &[@Expr],\n                         matching: Option<uint>,\n-                        matches_so_far: &mut ~[(uint, P<ast::variant>,\n+                        matches_so_far: &mut ~[(uint, P<ast::Variant>,\n                                               ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n         let cx = trait_.cx;\n@@ -891,18 +889,18 @@ impl<'a> MethodDef<'a> {\n \n     fn expand_static_enum_method_body(&self,\n                                       trait_: &TraitDef,\n-                                      enum_def: &enum_def,\n+                                      enum_def: &EnumDef,\n                                       type_ident: Ident,\n                                       self_args: &[@Expr],\n                                       nonself_args: &[@Expr])\n         -> @Expr {\n         let summary = enum_def.variants.map(|v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n-                ast::tuple_variant_kind(ref args) => {\n+                ast::TupleVariantKind(ref args) => {\n                     Unnamed(args.map(|va| trait_.set_expn_info(va.ty.span)))\n                 }\n-                ast::struct_variant_kind(struct_def) => {\n+                ast::StructVariantKind(struct_def) => {\n                     trait_.summarise_struct(struct_def)\n                 }\n             };\n@@ -937,14 +935,14 @@ impl<'a> TraitDef<'a> {\n         to_set\n     }\n \n-    fn summarise_struct(&self, struct_def: &struct_def) -> StaticFields {\n+    fn summarise_struct(&self, struct_def: &StructDef) -> StaticFields {\n         let mut named_idents = ~[];\n         let mut just_spans = ~[];\n         for field in struct_def.fields.iter(){\n             let sp = self.set_expn_info(field.span);\n             match field.node.kind {\n-                ast::named_field(ident, _) => named_idents.push((ident, sp)),\n-                ast::unnamed_field => just_spans.push(sp),\n+                ast::NamedField(ident, _) => named_idents.push((ident, sp)),\n+                ast::UnnamedField => just_spans.push(sp),\n             }\n         }\n \n@@ -971,7 +969,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_struct_pattern(&self,\n                              struct_ident: Ident,\n-                             struct_def: &struct_def,\n+                             struct_def: &StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n@@ -993,13 +991,13 @@ impl<'a> TraitDef<'a> {\n         for (i, struct_field) in struct_def.fields.iter().enumerate() {\n             let sp = self.set_expn_info(struct_field.span);\n             let opt_id = match struct_field.node.kind {\n-                ast::named_field(ident, _) if (struct_type == Unknown ||\n-                                               struct_type == Record) => {\n+                ast::NamedField(ident, _) if (struct_type == Unknown ||\n+                                              struct_type == Record) => {\n                     struct_type = Record;\n                     Some(ident)\n                 }\n-                ast::unnamed_field if (struct_type == Unknown ||\n-                                       struct_type == Tuple) => {\n+                ast::UnnamedField if (struct_type == Unknown ||\n+                                      struct_type == Tuple) => {\n                     struct_type = Tuple;\n                     None\n                 }\n@@ -1030,14 +1028,14 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_enum_variant_pattern(&self,\n-                                   variant: &ast::variant,\n+                                   variant: &ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n         -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n         let cx = self.cx;\n         let variant_ident = variant.node.name;\n         match variant.node.kind {\n-            ast::tuple_variant_kind(ref variant_args) => {\n+            ast::TupleVariantKind(ref variant_args) => {\n                 if variant_args.is_empty() {\n                     return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n                                                       ast::BindByValue(ast::MutImmutable)),\n@@ -1061,7 +1059,7 @@ impl<'a> TraitDef<'a> {\n                 (cx.pat_enum(variant.span, matching_path, subpats),\n                  ident_expr)\n             }\n-            ast::struct_variant_kind(struct_def) => {\n+            ast::StructVariantKind(struct_def) => {\n                 self.create_struct_pattern(variant_ident, struct_def,\n                                            prefix, mutbl)\n             }"}, {"sha": "2bf69e3467493077a50ff7055219979f5e767376", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr, BiAnd};\n+use ast::{MetaItem, Item, Expr, BiAnd};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -18,7 +18,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n                                   span: Span,\n                                   mitem: @MetaItem,\n-                                  in_items: ~[@item]) -> ~[@item] {\n+                                  in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "652f5ebe6c70cac181f3d19dfc3fc3b75f165a0a", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -18,7 +18,7 @@ library.\n \n */\n \n-use ast::{enum_def, Ident, item, Generics, struct_def};\n+use ast::{EnumDef, Ident, Item, Generics, StructDef};\n use ast::{MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use codemap::Span;\n@@ -47,22 +47,22 @@ pub mod generic;\n \n pub type ExpandDerivingStructDefFn<'a> = 'a |&ExtCtxt,\n                                                    Span,\n-                                                   x: &struct_def,\n+                                                   x: &StructDef,\n                                                    Ident,\n                                                    y: &Generics|\n-                                                   -> @item;\n+                                                   -> @Item;\n pub type ExpandDerivingEnumDefFn<'a> = 'a |&ExtCtxt,\n                                                  Span,\n-                                                 x: &enum_def,\n+                                                 x: &EnumDef,\n                                                  Ident,\n                                                  y: &Generics|\n-                                                 -> @item;\n+                                                 -> @Item;\n \n pub fn expand_meta_deriving(cx: &ExtCtxt,\n                             _span: Span,\n                             mitem: @MetaItem,\n-                            in_items: ~[@item])\n-                         -> ~[@item] {\n+                            in_items: ~[@Item])\n+                         -> ~[@Item] {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");"}, {"sha": "f621ad854aa24f1ef1d530d916cbf71e0f0c7eab", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use ast;\n use codemap::Span;\n use ext::base::ExtCtxt;\n@@ -18,7 +18,7 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n                                       span: Span,\n                                       mitem: @MetaItem,\n-                                      in_items: ~[@item]) -> ~[@item] {\n+                                      in_items: ~[@Item]) -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n \n@@ -85,7 +85,7 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n \n             for variant in enum_def.variants.iter() {\n                 match variant.node.kind {\n-                    ast::tuple_variant_kind(ref args) => {\n+                    ast::TupleVariantKind(ref args) => {\n                         if !args.is_empty() {\n                             cx.span_err(span, \"`FromPrimitive` cannot be derived for \\\n                                                enum variants with arguments\");\n@@ -110,7 +110,7 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n \n                         arms.push(arm);\n                     }\n-                    ast::struct_variant_kind(_) => {\n+                    ast::StructVariantKind(_) => {\n                         cx.span_err(span, \"`FromPrimitive` cannot be derived for enums \\\n                                            with struct variants\");\n                         return cx.expr_fail(span, @\"\");"}, {"sha": "f065340bdc2527ffdef386938fd0e5d9ccd0e14f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, Expr, Ident};\n+use ast::{MetaItem, Item, Expr, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n@@ -19,8 +19,8 @@ use opt_vec;\n pub fn expand_deriving_rand(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n-                            in_items: ~[@item])\n-    -> ~[@item] {\n+                            in_items: ~[@Item])\n+    -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "81453a5a10b050d4d1bf6a8322e640f511d66c1f", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -18,8 +18,8 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_to_str(cx: &ExtCtxt,\n                               span: Span,\n                               mitem: @MetaItem,\n-                              in_items: ~[@item])\n-    -> ~[@item] {\n+                              in_items: ~[@Item])\n+    -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n \n@@ -98,9 +98,9 @@ fn to_str_substructure(cx: &ExtCtxt, span: Span,\n \n         EnumMatching(_, variant, ref fields) => {\n             match variant.node.kind {\n-                ast::tuple_variant_kind(..) =>\n+                ast::TupleVariantKind(..) =>\n                     doit(\"(\", @\")\", variant.node.name, *fields),\n-                ast::struct_variant_kind(..) =>\n+                ast::StructVariantKind(..) =>\n                     doit(\"{\", @\"}\", variant.node.name, *fields),\n             }\n         }"}, {"sha": "a2e69cd377a3588cbb128f9737a93948680b1dd2", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -153,9 +153,9 @@ impl<'a> Ty<'a> {\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {\n-                    ast::ty_nil\n+                    ast::TyNil\n                 } else {\n-                    ast::ty_tup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n+                    ast::TyTup(fields.map(|f| f.to_ty(cx, span, self_ty, self_generics)))\n                 };\n \n                 cx.ty(span, ty)\n@@ -240,21 +240,21 @@ impl<'a> LifetimeBounds<'a> {\n \n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (@Expr, ast::explicit_self) {\n+    -> (@Expr, ast::ExplicitSelf) {\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::sty_value(ast::MutImmutable)))\n+            (self_path, respan(span, ast::SelfValue(ast::MutImmutable)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Send => ast::sty_uniq(ast::MutImmutable),\n-                    Managed => ast::sty_box(ast::MutImmutable),\n+                    Send => ast::SelfUniq(ast::MutImmutable),\n+                    Managed => ast::SelfBox(ast::MutImmutable),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));\n-                        ast::sty_region(lt, mutbl)\n+                        ast::SelfRegion(lt, mutbl)\n                     }\n                 });\n             let self_expr = cx.expr_deref(span, self_path);"}, {"sha": "034a7970515ddc743964f5d91f37c132f1a67137", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, item, Expr};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,8 +17,8 @@ use ext::deriving::generic::*;\n pub fn expand_deriving_zero(cx: &ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n-                            in_items: ~[@item])\n-    -> ~[@item] {\n+                            in_items: ~[@Item])\n+    -> ~[@Item] {\n     let trait_def = TraitDef {\n         cx: cx, span: span,\n "}, {"sha": "be5560adca85a8fddfd9a32e91a87350f6849624", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -22,7 +22,7 @@ use ext::build::AstBuilder;\n \n use std::os;\n \n-pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");\n \n@@ -33,7 +33,7 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     MRExpr(e)\n }\n \n-pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let exprs = get_exprs_from_tts(cx, sp, tts);\n "}, {"sha": "75c0371f62579a040cd2b5c4b124bd94c18e4ff2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ast::{P, Block, Crate, DeclLocal, ExprMac, SyntaxContext};\n-use ast::{Local, Ident, mac_invoc_tt};\n-use ast::{item_mac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n-use ast::{token_tree};\n+use ast::{Local, Ident, MacInvocTT};\n+use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{TokenTree};\n use ast;\n use ast_util::{mtwt_outer_mark, new_rename, new_mark};\n use ext::build::AstBuilder;\n@@ -43,7 +43,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                 // for the other three macro invocation chunks of code\n                 // in this file.\n                 // Token-tree macros:\n-                mac_invoc_tt(ref pth, ref tts, ctxt) => {\n+                MacInvocTT(ref pth, ref tts, ctxt) => {\n                     if (pth.segments.len() > 1u) {\n                         fld.cx.span_fatal(\n                             pth.span,\n@@ -210,7 +210,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n //\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n-pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_mod {\n+pub fn expand_mod_items(module_: &ast::Mod, fld: &mut MacroExpander) -> ast::Mod {\n     // Fold the contents first:\n     let module_ = noop_fold_mod(module_, fld);\n \n@@ -240,7 +240,7 @@ pub fn expand_mod_items(module_: &ast::_mod, fld: &mut MacroExpander) -> ast::_m\n         })\n     });\n \n-    ast::_mod {\n+    ast::Mod {\n         items: new_items,\n         ..module_\n     }\n@@ -258,11 +258,11 @@ macro_rules! with_exts_frame (\n )\n \n // When we enter a module, record it, for the sake of `module!`\n-pub fn expand_item(it: @ast::item, fld: &mut MacroExpander)\n-                   -> SmallVector<@ast::item> {\n+pub fn expand_item(it: @ast::Item, fld: &mut MacroExpander)\n+                   -> SmallVector<@ast::Item> {\n     match it.node {\n-        ast::item_mac(..) => expand_item_mac(it, fld),\n-        ast::item_mod(_) | ast::item_foreign_mod(_) => {\n+        ast::ItemMac(..) => expand_item_mac(it, fld),\n+        ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n             fld.cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n             let result = with_exts_frame!(fld.extsbox,\n@@ -282,11 +282,11 @@ pub fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: @ast::item, fld: &mut MacroExpander)\n-                       -> SmallVector<@ast::item> {\n+pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n+                       -> SmallVector<@ast::Item> {\n     let (pth, tts, ctxt) = match it.node {\n-        item_mac(codemap::Spanned {\n-            node: mac_invoc_tt(ref pth, ref tts, ctxt),\n+        ItemMac(codemap::Spanned {\n+            node: MacInvocTT(ref pth, ref tts, ctxt),\n             ..\n         }) => {\n             (pth, (*tts).clone(), ctxt)\n@@ -379,7 +379,7 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n     let (pth, tts, semi, ctxt) = match s.node {\n         StmtMac(ref mac, semi) => {\n             match mac.node {\n-                mac_invoc_tt(ref pth, ref tts, ctxt) => {\n+                MacInvocTT(ref pth, ref tts, ctxt) => {\n                     (pth, (*tts).clone(), semi, ctxt)\n                 }\n             }\n@@ -631,7 +631,7 @@ struct IdentRenamer<'a> {\n     renames: &'a mut RenameList,\n }\n \n-impl<'a> ast_fold for IdentRenamer<'a> {\n+impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n             new_rename(from, to, ctxt)\n@@ -837,15 +837,15 @@ pub fn std_macros() -> @str {\n }\n \n struct Injector {\n-    sm: @ast::item,\n+    sm: @ast::Item,\n }\n \n-impl ast_fold for Injector {\n-    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+impl Folder for Injector {\n+    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n         // Just inject the standard macros at the start of the first module\n         // in the crate: that is, at the start of the crate file itself.\n         let items = vec::append(~[ self.sm ], module.items);\n-        ast::_mod {\n+        ast::Mod {\n             items: items,\n             ..(*module).clone() // FIXME #2543: Bad copy.\n         }\n@@ -878,16 +878,16 @@ pub struct MacroExpander<'a> {\n     cx: &'a mut ExtCtxt,\n }\n \n-impl<'a> ast_fold for MacroExpander<'a> {\n+impl<'a> Folder for MacroExpander<'a> {\n     fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n         expand_expr(expr, self)\n     }\n \n-    fn fold_mod(&mut self, module: &ast::_mod) -> ast::_mod {\n+    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n         expand_mod_items(module, self)\n     }\n \n-    fn fold_item(&mut self, item: @ast::item) -> SmallVector<@ast::item> {\n+    fn fold_item(&mut self, item: @ast::Item) -> SmallVector<@ast::Item> {\n         expand_item(item, self)\n     }\n \n@@ -968,7 +968,7 @@ pub struct ContextWrapper {\n     context_function: @CtxtFn,\n }\n \n-impl ast_fold for ContextWrapper {\n+impl Folder for ContextWrapper {\n     fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n         let ast::Ident {\n             name,\n@@ -979,12 +979,12 @@ impl ast_fold for ContextWrapper {\n             ctxt: self.context_function.f(ctxt),\n         }\n     }\n-    fn fold_mac(&mut self, m: &ast::mac) -> ast::mac {\n+    fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n         let macro = match m.node {\n-            mac_invoc_tt(ref path, ref tts, ctxt) => {\n-                mac_invoc_tt(self.fold_path(path),\n-                             fold_tts(*tts, self),\n-                             self.context_function.f(ctxt))\n+            MacInvocTT(ref path, ref tts, ctxt) => {\n+                MacInvocTT(self.fold_path(path),\n+                           fold_tts(*tts, self),\n+                           self.context_function.f(ctxt))\n             }\n         };\n         Spanned {\n@@ -995,7 +995,7 @@ impl ast_fold for ContextWrapper {\n }\n \n // given a function from ctxts to ctxts, produce\n-// an ast_fold that applies that function to all ctxts:\n+// a Folder that applies that function to all ctxts:\n pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> ContextWrapper {\n     ContextWrapper {\n         context_function: cf as @CtxtFn,\n@@ -1012,7 +1012,7 @@ pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> ContextWrapper {\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts : &[token_tree], m : Mrk) -> ~[token_tree] {\n+fn mark_tts(tts : &[TokenTree], m : Mrk) -> ~[TokenTree] {\n     fold_tts(tts, &mut new_mark_folder(m))\n }\n \n@@ -1028,7 +1028,7 @@ fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr : @ast::item, m : Mrk) -> SmallVector<@ast::item> {\n+fn mark_item(expr : @ast::Item, m : Mrk) -> SmallVector<@ast::Item> {\n     new_mark_folder(m).fold_item(expr)\n }\n \n@@ -1041,8 +1041,8 @@ pub fn replace_ctxts(expr : @ast::Expr, ctxt : SyntaxContext) -> @ast::Expr {\n // take the mark from the given ctxt (that has a mark at the outside),\n // and apply it to everything in the token trees, thereby cancelling\n // that mark.\n-pub fn mtwt_cancel_outer_mark(tts: &[ast::token_tree], ctxt: ast::SyntaxContext)\n-    -> ~[ast::token_tree] {\n+pub fn mtwt_cancel_outer_mark(tts: &[ast::TokenTree], ctxt: ast::SyntaxContext)\n+    -> ~[ast::TokenTree] {\n     let outer_mark = mtwt_outer_mark(ctxt);\n     mark_tts(tts,outer_mark)\n }\n@@ -1221,14 +1221,14 @@ mod test {\n         assert_eq!(marked_once.len(),1);\n         let marked_once_ctxt =\n             match marked_once[0] {\n-                ast::tt_tok(_,token::IDENT(id,_)) => id.ctxt,\n+                ast::TTTok(_,token::IDENT(id,_)) => id.ctxt,\n                 _ => fail!(format!(\"unexpected shape for marked tts: {:?}\",marked_once[0]))\n             };\n         assert_eq!(mtwt_marksof(marked_once_ctxt,invalid_name),~[fm]);\n         let remarked = mtwt_cancel_outer_mark(marked_once,marked_once_ctxt);\n         assert_eq!(remarked.len(),1);\n         match remarked[0] {\n-            ast::tt_tok(_,token::IDENT(id,_)) =>\n+            ast::TTTok(_,token::IDENT(id,_)) =>\n             assert_eq!(mtwt_marksof(id.ctxt,invalid_name),~[]),\n             _ => fail!(format!(\"unexpected shape for marked tts: {:?}\",remarked[0]))\n         }\n@@ -1315,11 +1315,11 @@ mod test {\n     // in principle, you might want to control this boolean on a per-varref basis,\n     // but that would make things even harder to understand, and might not be\n     // necessary for thorough testing.\n-    type renaming_test = (&'static str, ~[~[uint]], bool);\n+    type RenamingTest = (&'static str, ~[~[uint]], bool);\n \n     #[test]\n     fn automatic_renaming () {\n-        let tests : ~[renaming_test] =\n+        let tests : ~[RenamingTest] =\n             ~[// b & c should get new names throughout, in the expr too:\n                 (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n                  ~[~[0,1],~[2]], false),\n@@ -1363,7 +1363,7 @@ mod test {\n     }\n \n     // run one of the renaming tests\n-    fn run_renaming_test(t : &renaming_test, test_idx: uint) {\n+    fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n         let invalid_name = token::special_idents::invalid.name;\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_managed(), conns.clone(), bic)"}, {"sha": "411bf921dd2988020a3797547669a49473110fd9", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -16,7 +16,7 @@ use ext::base;\n use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt, sp: Span,\n-                         _tts: &[ast::token_tree]) -> base::MacResult {\n+                         _tts: &[ast::TokenTree]) -> base::MacResult {\n     ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n     ecx.parse_sess.span_diagnostic.span_note(sp,\n         \"see http://static.rust-lang.org/doc/master/std/fmt/index.html \\"}, {"sha": "a4b8dd7840327877a4609bed2375bbdcf92adc41", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -48,7 +48,7 @@ struct Context<'a> {\n     // Collection of the compiled `rt::Piece` structures\n     pieces: ~[@ast::Expr],\n     name_positions: HashMap<@str, uint>,\n-    method_statics: ~[@ast::item],\n+    method_statics: ~[@ast::Item],\n \n     // Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n@@ -58,7 +58,7 @@ struct Context<'a> {\n impl<'a> Context<'a> {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other format! expressions.\n-    fn parse_args(&mut self, sp: Span, tts: &[ast::token_tree])\n+    fn parse_args(&mut self, sp: Span, tts: &[ast::TokenTree])\n                   -> (@ast::Expr, Option<@ast::Expr>) {\n         let mut p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                                  self.ecx.cfg(),\n@@ -476,7 +476,7 @@ impl<'a> Context<'a> {\n                 opt_vec::with(life),\n                 ~[]\n             ), None);\n-            let st = ast::item_static(ty, ast::MutImmutable, method);\n+            let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n             let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n                                                      self.method_statics.len()));\n             let item = self.ecx.item(sp, static_name, self.static_attrs(), st);\n@@ -490,7 +490,7 @@ impl<'a> Context<'a> {\n                                           ~[self.ecx.expr_str(sp, s.to_managed())])\n             }\n             parse::CurrentArgument => {\n-                let nil = self.ecx.expr_lit(sp, ast::lit_nil);\n+                let nil = self.ecx.expr_lit(sp, ast::LitNil);\n                 self.ecx.expr_call_global(sp, rtpath(\"CurrentArgument\"), ~[nil])\n             }\n             parse::Argument(ref arg) => {\n@@ -522,7 +522,7 @@ impl<'a> Context<'a> {\n \n                 // Translate the format\n                 let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n-                let fill = self.ecx.expr_lit(sp, ast::lit_char(fill as u32));\n+                let fill = self.ecx.expr_lit(sp, ast::LitChar(fill as u32));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n                         self.ecx.path_global(sp, parsepath(\"AlignLeft\"))\n@@ -595,12 +595,12 @@ impl<'a> Context<'a> {\n                     self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n                 ~[]\n             ), None);\n-        let ty = ast::ty_fixed_length_vec(\n+        let ty = ast::TyFixedLengthVec(\n             piece_ty,\n             self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n         );\n         let ty = self.ecx.ty(self.fmtsp, ty);\n-        let st = ast::item_static(ty, ast::MutImmutable, fmt);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n         let static_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n         let item = self.ecx.item(self.fmtsp, static_name,\n                                  self.static_attrs(), st);\n@@ -726,7 +726,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n-                   tts: &[ast::token_tree]) -> base::MacResult {\n+                   tts: &[ast::TokenTree]) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],"}, {"sha": "74032095840a960e3b51d11e42d97a31d87724ef", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -17,20 +17,20 @@ use parse::token::{get_ident_interner};\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt,\n                          sp: codemap::Span,\n-                         tt: &[ast::token_tree])\n+                         tt: &[ast::TokenTree])\n                       -> base::MacResult {\n \n     cx.print_backtrace();\n     println(\n         print::pprust::tt_to_str(\n-            &ast::tt_delim(@tt.to_owned()),\n+            &ast::TTDelim(@tt.to_owned()),\n             get_ident_interner()));\n \n     //trivial expression\n     MRExpr(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprLit(@codemap::Spanned {\n-            node: ast::lit_nil,\n+            node: ast::LitNil,\n             span: sp\n         }),\n         span: sp,"}, {"sha": "e66e394d639563e680e709c1375052ef8d323999", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -23,7 +23,7 @@ use parse;\n *\n * This is registered as a set of expression syntax extension called quote!\n * that lifts its argument token-tree to an AST representing the\n-* construction of the same token tree, with ast::tt_nonterminal nodes\n+* construction of the same token tree, with ast::TTNonterminal nodes\n * interpreted as antiquotes (splices).\n *\n */\n@@ -40,11 +40,11 @@ pub mod rt {\n     pub use codemap::{BytePos, Span, dummy_spanned};\n \n     pub trait ToTokens {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[token_tree];\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree];\n     }\n \n-    impl ToTokens for ~[token_tree] {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[token_tree] {\n+    impl ToTokens for ~[TokenTree] {\n+        fn to_tokens(&self, _cx: &ExtCtxt) -> ~[TokenTree] {\n             (*self).clone()\n         }\n     }\n@@ -56,7 +56,7 @@ pub mod rt {\n         pub fn to_source() -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n-        pub fn to_tokens(cx: &ExtCtxt) -> ~[token_tree] {\n+        pub fn to_tokens(cx: &ExtCtxt) -> ~[TokenTree] {\n             cx.parse_tts(self.to_source())\n         }\n     }\n@@ -74,13 +74,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::item {\n+    impl ToSource for @ast::Item {\n         fn to_source(&self) -> @str {\n             pprust::item_to_str(*self, get_ident_interner()).to_managed()\n         }\n     }\n \n-    impl<'a> ToSource for &'a [@ast::item] {\n+    impl<'a> ToSource for &'a [@ast::Item] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\"\\n\\n\").to_managed()\n         }\n@@ -118,78 +118,78 @@ pub mod rt {\n \n     impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_str(self.to_managed(), ast::CookedStr));\n+            let lit = dummy_spanned(ast::LitStr(self.to_managed(), ast::CookedStr));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for int {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n+            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for i8 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n+            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI8));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for i16 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n+            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI16));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n \n     impl ToSource for i32 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n+            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI32));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for i64 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n+            let lit = dummy_spanned(ast::LitInt(*self as i64, ast::TyI64));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for uint {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n+            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for u8 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n+            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU8));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for u16 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n+            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU16));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for u32 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n+            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU32));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n \n     impl ToSource for u64 {\n         fn to_source(&self) -> @str {\n-            let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n+            let lit = dummy_spanned(ast::LitUint(*self as u64, ast::TyU64));\n             pprust::lit_to_str(&lit).to_managed()\n         }\n     }\n@@ -199,7 +199,7 @@ pub mod rt {\n     macro_rules! impl_to_tokens(\n         ($t:ty) => (\n             impl ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[token_tree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n@@ -209,16 +209,16 @@ pub mod rt {\n     macro_rules! impl_to_tokens_self(\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> ~[token_tree] {\n+                fn to_tokens(&self, cx: &ExtCtxt) -> ~[TokenTree] {\n                     cx.parse_tts(self.to_source())\n                 }\n             }\n         )\n     )\n \n     impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(@ast::item)\n-    impl_to_tokens_self!(&'a [@ast::item])\n+    impl_to_tokens!(@ast::Item)\n+    impl_to_tokens_self!(&'a [@ast::Item])\n     impl_to_tokens!(ast::Ty)\n     impl_to_tokens_self!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n@@ -237,15 +237,15 @@ pub mod rt {\n     impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: @str) -> @ast::item;\n+        fn parse_item(&self, s: @str) -> @ast::Item;\n         fn parse_expr(&self, s: @str) -> @ast::Expr;\n         fn parse_stmt(&self, s: @str) -> @ast::Stmt;\n-        fn parse_tts(&self, s: @str) -> ~[ast::token_tree];\n+        fn parse_tts(&self, s: @str) -> ~[ast::TokenTree];\n     }\n \n     impl ExtParseUtils for ExtCtxt {\n \n-        fn parse_item(&self, s: @str) -> @ast::item {\n+        fn parse_item(&self, s: @str) -> @ast::Item {\n             let res = parse::parse_item_from_source_str(\n                 @\"<quote expansion>\",\n                 s,\n@@ -278,7 +278,7 @@ pub mod rt {\n                 self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: @str) -> ~[ast::token_tree] {\n+        fn parse_tts(&self, s: @str) -> ~[ast::TokenTree] {\n             parse::parse_tts_from_source_str(\n                 @\"<quote expansion>\",\n                 s,\n@@ -291,22 +291,22 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n                            sp: Span,\n-                           tts: &[ast::token_tree]) -> base::MacResult {\n+                           tts: &[ast::TokenTree]) -> base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", ~[], tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts);\n@@ -315,25 +315,25 @@ pub fn expand_quote_item(cx: &mut ExtCtxt,\n \n pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         sp: Span,\n-                        tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_refutable = cx.expr_lit(sp, ast::lit_bool(true));\n+                        tts: &[ast::TokenTree]) -> base::MacResult {\n+    let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::token_tree]) -> base::MacResult {\n-    let e_param_colons = cx.expr_lit(sp, ast::lit_bool(false));\n+                       tts: &[ast::TokenTree]) -> base::MacResult {\n+    let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n                                      ~[e_param_colons], tts);\n     base::MRExpr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::token_tree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> base::MacResult {\n     let e_attrs = cx.expr_vec_uniq(sp, ~[]);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts);\n@@ -357,7 +357,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::Expr {\n                         ~[e_str])\n }\n \n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::binop) -> @ast::Expr {\n+fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOp) -> @ast::Expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -388,25 +388,22 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n         }\n \n         LIT_CHAR(i) => {\n-            let s_ity = ~\"ty_char\";\n-            let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n-\n-            let e_char = cx.expr_lit(sp, ast::lit_char(i));\n+            let e_char = cx.expr_lit(sp, ast::LitChar(i));\n \n-            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), ~[e_char, e_ity]);\n+            return cx.expr_call_ident(sp, id_ext(\"LIT_CHAR\"), ~[e_char]);\n         }\n \n         LIT_INT(i, ity) => {\n             let s_ity = match ity {\n-                ast::ty_i => ~\"ty_i\",\n-                ast::ty_i8 => ~\"ty_i8\",\n-                ast::ty_i16 => ~\"ty_i16\",\n-                ast::ty_i32 => ~\"ty_i32\",\n-                ast::ty_i64 => ~\"ty_i64\"\n+                ast::TyI => ~\"TyI\",\n+                ast::TyI8 => ~\"TyI8\",\n+                ast::TyI16 => ~\"TyI16\",\n+                ast::TyI32 => ~\"TyI32\",\n+                ast::TyI64 => ~\"TyI64\"\n             };\n             let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n \n-            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT\"),\n@@ -415,23 +412,23 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_UINT(u, uty) => {\n             let s_uty = match uty {\n-                ast::ty_u => ~\"ty_u\",\n-                ast::ty_u8 => ~\"ty_u8\",\n-                ast::ty_u16 => ~\"ty_u16\",\n-                ast::ty_u32 => ~\"ty_u32\",\n-                ast::ty_u64 => ~\"ty_u64\"\n+                ast::TyU => ~\"TyU\",\n+                ast::TyU8 => ~\"TyU8\",\n+                ast::TyU16 => ~\"TyU16\",\n+                ast::TyU32 => ~\"TyU32\",\n+                ast::TyU64 => ~\"TyU64\"\n             };\n             let e_uty = cx.expr_ident(sp, id_ext(s_uty));\n \n-            let e_u64 = cx.expr_lit(sp, ast::lit_uint(u, ast::ty_u64));\n+            let e_u64 = cx.expr_lit(sp, ast::LitUint(u, ast::TyU64));\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_UINT\"),\n                                       ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n-            let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n+            let e_i64 = cx.expr_lit(sp, ast::LitInt(i, ast::TyI64));\n \n             return cx.expr_call_ident(sp,\n                                       id_ext(\"LIT_INT_UNSUFFIXED\"),\n@@ -440,8 +437,8 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n \n         LIT_FLOAT(fident, fty) => {\n             let s_fty = match fty {\n-                ast::ty_f32 => ~\"ty_f32\",\n-                ast::ty_f64 => ~\"ty_f64\"\n+                ast::TyF32 => ~\"TyF32\",\n+                ast::TyF64 => ~\"TyF64\"\n             };\n             let e_fty = cx.expr_ident(sp, id_ext(s_fty));\n \n@@ -528,15 +525,14 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> @ast::Expr {\n }\n \n \n-fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::token_tree)\n-    -> ~[@ast::Stmt] {\n+fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> ~[@ast::Stmt] {\n \n     match *tt {\n \n-        ast::tt_tok(sp, ref tok) => {\n+        ast::TTTok(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"sp\"));\n             let e_tok = cx.expr_call_ident(sp,\n-                                           id_ext(\"tt_tok\"),\n+                                           id_ext(\"TTTok\"),\n                                            ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n                 cx.expr_method_call(sp,\n@@ -546,10 +542,10 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::token_tree)\n             ~[cx.stmt_expr(e_push)]\n         }\n \n-        ast::tt_delim(ref tts) => mk_tts(cx, sp, **tts),\n-        ast::tt_seq(..) => fail!(\"tt_seq in quote!\"),\n+        ast::TTDelim(ref tts) => mk_tts(cx, sp, **tts),\n+        ast::TTSeq(..) => fail!(\"TTSeq in quote!\"),\n \n-        ast::tt_nonterminal(sp, ident) => {\n+        ast::TTNonterminal(sp, ident) => {\n \n             // tt.push_all_move($ident.to_tokens(ext_cx))\n \n@@ -570,7 +566,7 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::token_tree)\n     }\n }\n \n-fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> ~[@ast::Stmt] {\n     let mut ss = ~[];\n     for tt in tts.iter() {\n@@ -579,10 +575,10 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n               -> (@ast::Expr, @ast::Expr) {\n     // NB: It appears that the main parser loses its mind if we consider\n-    // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n+    // $foo as a TTNonterminal during the main parse, so we have to re-parse\n     // under quote_depth > 0. This is silly and should go away; the _guess_ is\n     // it has to do with transition away from supporting old-style macros, so\n     // try removing it when enough of them are gone.\n@@ -652,7 +648,7 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: @ast::Expr,\n                   expr: @ast::Expr) -> @ast::Expr {\n-    let uses = ~[ cx.view_use_glob(sp, ast::public,\n+    let uses = ~[ cx.view_use_glob(sp, ast::Public,\n                                    ids_ext(~[~\"syntax\",\n                                              ~\"ext\",\n                                              ~\"quote\",\n@@ -667,7 +663,7 @@ fn expand_parse_call(cx: &ExtCtxt,\n                      sp: Span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::Expr],\n-                     tts: &[ast::token_tree]) -> @ast::Expr {\n+                     tts: &[ast::TokenTree]) -> @ast::Expr {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call("}, {"sha": "3e781451b081cab8d52f73f9eec364ca11c698e7", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,7 +28,7 @@ use std::str;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -39,7 +39,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -51,7 +51,7 @@ pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -61,13 +61,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n     base::MRExpr(cx.expr_str(sp, s.to_managed()))\n }\n \n-pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(cx.expr_str(sp,\n@@ -77,7 +77,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     // The file will be added to the code map by the parser\n@@ -92,7 +92,7 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let file = res_rel_file(cx, sp, &Path::new(file));\n@@ -119,7 +119,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     }\n }\n \n-pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         -> base::MacResult\n {\n     use std::at_vec;\n@@ -133,7 +133,7 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::token_tree])\n         }\n         Ok(bytes) => {\n             let bytes = at_vec::to_managed_move(bytes);\n-            base::MRExpr(cx.expr_lit(sp, ast::lit_binary(bytes)))\n+            base::MRExpr(cx.expr_lit(sp, ast::LitBinary(bytes)))\n         }\n     }\n }"}, {"sha": "679e9a5098eb1c6d4db524b523b9f4d25a365878", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -12,20 +12,20 @@ use ast;\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::base;\n-use parse::lexer::{new_tt_reader, reader};\n+use parse::lexer::{new_tt_reader, Reader};\n use parse::parser::Parser;\n use parse::token::keywords;\n \n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n-                           tt: &[ast::token_tree])\n+                           tt: &[ast::TokenTree])\n                         -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.to_owned());\n-    let rdr = tt_rdr as @reader;\n+    let rdr = tt_rdr as @Reader;\n     let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {"}, {"sha": "22074a73a8bcd2a764e7c7b3dc40851a6907f5e7", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 88, "deletions": 109, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -11,14 +11,14 @@\n // Earley-like parser for macros.\n \n use ast;\n-use ast::{matcher, match_tok, match_seq, match_nonterminal, Ident};\n+use ast::{Matcher, MatchTok, MatchSeq, MatchNonterminal, Ident};\n use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n-use parse::attr::parser_attr;\n+use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n-use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n+use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n use std::hashmap::HashMap;\n@@ -33,7 +33,7 @@ ones. Instead of NTs, we have a special case for Kleene star. The big-O, in\n pathological cases, is worse than traditional Earley parsing, but it's an\n easier fit for Macro-by-Example-style rules, and I think the overhead is\n lower. (In order to prevent the pathological case, we'd need to lazily\n-construct the resulting `named_match`es at the very end. It'd be a pain,\n+construct the resulting `NamedMatch`es at the very end. It'd be a pain,\n and require more memory to keep around old items, but it would also save\n overhead)*/\n \n@@ -93,114 +93,94 @@ eof: [a $( a )* a b \u00b7]\n  */\n \n \n-/* to avoid costly uniqueness checks, we require that `match_seq` always has a\n+/* to avoid costly uniqueness checks, we require that `MatchSeq` always has a\n nonempty body. */\n \n-#[deriving(Clone)]\n-pub enum matcher_pos_up { /* to break a circularity */\n-    matcher_pos_up(Option<~MatcherPos>)\n-}\n-\n-pub fn is_some(mpu: &matcher_pos_up) -> bool {\n-    match *mpu {\n-      matcher_pos_up(None) => false,\n-      _ => true\n-    }\n-}\n \n #[deriving(Clone)]\n pub struct MatcherPos {\n-    elts: ~[ast::matcher], // maybe should be <'>? Need to understand regions.\n+    elts: ~[ast::Matcher], // maybe should be <'>? Need to understand regions.\n     sep: Option<Token>,\n     idx: uint,\n-    up: matcher_pos_up, // mutable for swapping only\n-    matches: ~[~[@named_match]],\n+    up: Option<~MatcherPos>,\n+    matches: ~[~[@NamedMatch]],\n     match_lo: uint, match_hi: uint,\n     sp_lo: BytePos,\n }\n \n-pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n-    match *mpu {\n-      matcher_pos_up(Some(ref mp)) => (*mp).clone(),\n-      _ => fail!()\n-    }\n-}\n-\n-pub fn count_names(ms: &[matcher]) -> uint {\n+pub fn count_names(ms: &[Matcher]) -> uint {\n     ms.iter().fold(0, |ct, m| {\n         ct + match m.node {\n-          match_tok(_) => 0u,\n-          match_seq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n-          match_nonterminal(_,_,_) => 1u\n+            MatchTok(_) => 0u,\n+            MatchSeq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n+            MatchNonterminal(_, _, _) => 1u\n         }})\n }\n \n-pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n+pub fn initial_matcher_pos(ms: ~[Matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n     for elt in ms.iter() {\n         match elt.node {\n-          match_tok(_) => (),\n-          match_seq(_,_,_,_,hi) => {\n-            match_idx_hi = hi;       // it is monotonic...\n-          }\n-          match_nonterminal(_,_,pos) => {\n-            match_idx_hi = pos+1u;  // ...so latest is highest\n-          }\n+            MatchTok(_) => (),\n+            MatchSeq(_,_,_,_,hi) => {\n+                match_idx_hi = hi;       // it is monotonic...\n+            }\n+            MatchNonterminal(_,_,pos) => {\n+                match_idx_hi = pos+1u;  // ...so latest is highest\n+            }\n         }\n     }\n     let matches = vec::from_fn(count_names(ms), |_i| ~[]);\n     ~MatcherPos {\n         elts: ms,\n         sep: sep,\n         idx: 0u,\n-        up: matcher_pos_up(None),\n+        up: None,\n         matches: matches,\n         match_lo: 0u,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n }\n \n-// named_match is a pattern-match result for a single ast::match_nonterminal:\n+// NamedMatch is a pattern-match result for a single ast::MatchNonterminal:\n // so it is associated with a single ident in a parse, and all\n-// matched_nonterminals in the named_match have the same nonterminal type\n-// (expr, item, etc). All the leaves in a single named_match correspond to a\n-// single matcher_nonterminal in the ast::matcher that produced it.\n+// MatchedNonterminal's in the NamedMatch have the same nonterminal type\n+// (expr, item, etc). All the leaves in a single NamedMatch correspond to a\n+// single matcher_nonterminal in the ast::Matcher that produced it.\n //\n // It should probably be renamed, it has more or less exact correspondence to\n-// ast::match nodes, and the in-memory structure of a particular named_match\n+// ast::match nodes, and the in-memory structure of a particular NamedMatch\n // represents the match that occurred when a particular subset of an\n-// ast::match -- those ast::matcher nodes leading to a single\n-// match_nonterminal -- was applied to a particular token tree.\n+// ast::match -- those ast::Matcher nodes leading to a single\n+// MatchNonterminal -- was applied to a particular token tree.\n //\n-// The width of each matched_seq in the named_match, and the identity of the\n-// matched_nonterminals, will depend on the token tree it was applied to: each\n-// matched_seq corresponds to a single match_seq in the originating\n-// ast::matcher. The depth of the named_match structure will therefore depend\n-// only on the nesting depth of ast::match_seqs in the originating\n-// ast::matcher it was derived from.\n-\n-pub enum named_match {\n-    matched_seq(~[@named_match], codemap::Span),\n-    matched_nonterminal(nonterminal)\n+// The width of each MatchedSeq in the NamedMatch, and the identity of the\n+// MatchedNonterminal's, will depend on the token tree it was applied to: each\n+// MatchedSeq corresponds to a single MatchSeq in the originating\n+// ast::Matcher. The depth of the NamedMatch structure will therefore depend\n+// only on the nesting depth of ast::MatchSeq's in the originating\n+// ast::Matcher it was derived from.\n+\n+pub enum NamedMatch {\n+    MatchedSeq(~[@NamedMatch], codemap::Span),\n+    MatchedNonterminal(Nonterminal)\n }\n \n-pub type earley_item = ~MatcherPos;\n-\n-pub fn nameize(p_s: @ParseSess, ms: &[matcher], res: &[@named_match])\n-            -> HashMap<Ident,@named_match> {\n-    fn n_rec(p_s: @ParseSess, m: &matcher, res: &[@named_match],\n-             ret_val: &mut HashMap<Ident, @named_match>) {\n+pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n+            -> HashMap<Ident, @NamedMatch> {\n+    fn n_rec(p_s: @ParseSess, m: &Matcher, res: &[@NamedMatch],\n+             ret_val: &mut HashMap<Ident, @NamedMatch>) {\n         match *m {\n-          codemap::Spanned {node: match_tok(_), .. } => (),\n-          codemap::Spanned {node: match_seq(ref more_ms, _, _, _, _), .. } => {\n+          codemap::Spanned {node: MatchTok(_), .. } => (),\n+          codemap::Spanned {node: MatchSeq(ref more_ms, _, _, _, _), .. } => {\n             for next_m in more_ms.iter() {\n                 n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n           codemap::Spanned {\n-                node: match_nonterminal(ref bind_name, _, idx), span: sp\n+                node: MatchNonterminal(ref bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n@@ -215,21 +195,21 @@ pub fn nameize(p_s: @ParseSess, ms: &[matcher], res: &[@named_match])\n     ret_val\n }\n \n-pub enum parse_result {\n-    success(HashMap<Ident, @named_match>),\n-    failure(codemap::Span, ~str),\n-    error(codemap::Span, ~str)\n+pub enum ParseResult {\n+    Success(HashMap<Ident, @NamedMatch>),\n+    Failure(codemap::Span, ~str),\n+    Error(codemap::Span, ~str)\n }\n \n pub fn parse_or_else(sess: @ParseSess,\n                      cfg: ast::CrateConfig,\n-                     rdr: @reader,\n-                     ms: ~[matcher])\n-                     -> HashMap<Ident, @named_match> {\n+                     rdr: @Reader,\n+                     ms: ~[Matcher])\n+                     -> HashMap<Ident, @NamedMatch> {\n     match parse(sess, cfg, rdr, ms) {\n-      success(m) => m,\n-      failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n-      error(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n+        Success(m) => m,\n+        Failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n+        Error(sp, str) => sess.span_diagnostic.span_fatal(sp, str)\n     }\n }\n \n@@ -244,9 +224,9 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n \n pub fn parse(sess: @ParseSess,\n              cfg: ast::CrateConfig,\n-             rdr: @reader,\n-             ms: &[matcher])\n-             -> parse_result {\n+             rdr: @Reader,\n+             ms: &[Matcher])\n+             -> ParseResult {\n     let mut cur_eis = ~[];\n     cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n \n@@ -267,7 +247,7 @@ pub fn parse(sess: @ParseSess,\n             /* at end of sequence */\n             if idx >= len {\n                 // can't move out of `match`es, so:\n-                if is_some(&ei.up) {\n+                if ei.up.is_some() {\n                     // hack: a matcher sequence is repeating iff it has a\n                     // parent (the top level is just a container)\n \n@@ -277,7 +257,7 @@ pub fn parse(sess: @ParseSess,\n                     if idx == len {\n                         // pop from the matcher position\n \n-                        let mut new_pos = copy_up(&ei.up);\n+                        let mut new_pos = ei.up.clone().unwrap();\n \n                         // update matches (the MBE \"parse tree\") by appending\n                         // each tree as a subtree.\n@@ -290,9 +270,8 @@ pub fn parse(sess: @ParseSess,\n                         for idx in range(ei.match_lo, ei.match_hi) {\n                             let sub = ei.matches[idx].clone();\n                             new_pos.matches[idx]\n-                                .push(@matched_seq(sub,\n-                                                   mk_sp(ei.sp_lo,\n-                                                         sp.hi)));\n+                                   .push(@MatchedSeq(sub, mk_sp(ei.sp_lo,\n+                                                                sp.hi)));\n                         }\n \n                         new_pos.idx += 1;\n@@ -325,14 +304,14 @@ pub fn parse(sess: @ParseSess,\n             } else {\n                 match ei.elts[idx].node.clone() {\n                   /* need to descend into sequence */\n-                  match_seq(ref matchers, ref sep, zero_ok,\n-                            match_idx_lo, match_idx_hi) => {\n+                  MatchSeq(ref matchers, ref sep, zero_ok,\n+                           match_idx_lo, match_idx_hi) => {\n                     if zero_ok {\n                         let mut new_ei = ei.clone();\n                         new_ei.idx += 1u;\n                         //we specifically matched zero repeats.\n                         for idx in range(match_idx_lo, match_idx_hi) {\n-                            new_ei.matches[idx].push(@matched_seq(~[], sp));\n+                            new_ei.matches[idx].push(@MatchedSeq(~[], sp));\n                         }\n \n                         cur_eis.push(new_ei);\n@@ -344,14 +323,14 @@ pub fn parse(sess: @ParseSess,\n                         elts: (*matchers).clone(),\n                         sep: (*sep).clone(),\n                         idx: 0u,\n-                        up: matcher_pos_up(Some(ei_t)),\n+                        up: Some(ei_t),\n                         matches: matches,\n                         match_lo: match_idx_lo, match_hi: match_idx_hi,\n                         sp_lo: sp.lo\n                     });\n                   }\n-                  match_nonterminal(_,_,_) => { bb_eis.push(ei) }\n-                  match_tok(ref t) => {\n+                  MatchNonterminal(_,_,_) => { bb_eis.push(ei) }\n+                  MatchTok(ref t) => {\n                     let mut ei_t = ei.clone();\n                     //if (token_name_eq(t,&tok)) {\n                     if (token::mtwt_token_eq(t,&tok)) {\n@@ -370,29 +349,29 @@ pub fn parse(sess: @ParseSess,\n                 for dv in eof_eis[0u].matches.mut_iter() {\n                     v.push(dv.pop());\n                 }\n-                return success(nameize(sess, ms, v));\n+                return Success(nameize(sess, ms, v));\n             } else if eof_eis.len() > 1u {\n-                return error(sp, ~\"Ambiguity: multiple successful parses\");\n+                return Error(sp, ~\"Ambiguity: multiple successful parses\");\n             } else {\n-                return failure(sp, ~\"Unexpected end of macro invocation\");\n+                return Failure(sp, ~\"Unexpected end of macro invocation\");\n             }\n         } else {\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n-                      match_nonterminal(ref bind,ref name,_) => {\n+                      MatchNonterminal(ref bind,ref name,_) => {\n                         format!(\"{} ('{}')\", ident_to_str(name),\n                              ident_to_str(bind))\n                       }\n                       _ => fail!()\n                     } }).connect(\" or \");\n-                return error(sp, format!(\n+                return Error(sp, format!(\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n-                return failure(sp, ~\"No rules expected the token: \"\n+                return Failure(sp, ~\"No rules expected the token: \"\n                             + to_str(get_ident_interner(), &tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n@@ -405,8 +384,8 @@ pub fn parse(sess: @ParseSess,\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n-                  match_nonterminal(_, ref name, idx) => {\n-                    ei.matches[idx].push(@matched_nonterminal(\n+                  MatchNonterminal(_, ref name, idx) => {\n+                    ei.matches[idx].push(@MatchedNonterminal(\n                         parse_nt(&mut rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n@@ -424,36 +403,36 @@ pub fn parse(sess: @ParseSess,\n     }\n }\n \n-pub fn parse_nt(p: &mut Parser, name: &str) -> nonterminal {\n+pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n     match name {\n       \"item\" => match p.parse_item(~[]) {\n-        Some(i) => token::nt_item(i),\n+        Some(i) => token::NtItem(i),\n         None => p.fatal(\"expected an item keyword\")\n       },\n-      \"block\" => token::nt_block(p.parse_block()),\n-      \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n-      \"pat\" => token::nt_pat(p.parse_pat()),\n-      \"expr\" => token::nt_expr(p.parse_expr()),\n-      \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n+      \"block\" => token::NtBlock(p.parse_block()),\n+      \"stmt\" => token::NtStmt(p.parse_stmt(~[])),\n+      \"pat\" => token::NtPat(p.parse_pat()),\n+      \"expr\" => token::NtExpr(p.parse_expr()),\n+      \"ty\" => token::NtTy(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n-        token::IDENT(sn,b) => { p.bump(); token::nt_ident(~sn,b) }\n+        token::IDENT(sn,b) => { p.bump(); token::NtIdent(~sn,b) }\n         _ => {\n             let token_str = token::to_str(get_ident_interner(), &p.token);\n             p.fatal(~\"expected ident, found \" + token_str)\n         }\n       },\n       \"path\" => {\n-        token::nt_path(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n+        token::NtPath(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n       }\n-      \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n+      \"attr\" => token::NtAttr(@p.parse_attribute(false)),\n       \"tt\" => {\n         p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n-        let res = token::nt_tt(@p.parse_token_tree());\n+        let res = token::NtTT(@p.parse_token_tree());\n         p.quote_depth -= 1u;\n         res\n       }\n-      \"matchers\" => token::nt_matchers(p.parse_matchers()),\n+      \"matchers\" => token::NtMatchers(p.parse_matchers()),\n       _ => p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)\n     }\n }"}, {"sha": "dc5eb0e953735ca7c64cfe5e79cbbd600e405c33", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n-use ast::{tt_delim};\n+use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq};\n+use ast::{TTDelim};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n use ext::base::{AnyMacro, ExtCtxt, MacResult, MRAny, MRDef, MacroDef};\n use ext::base::{NormalTT, SyntaxExpanderTTTrait};\n use ext::base;\n-use ext::tt::macro_parser::{error};\n-use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n-use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n-use parse::lexer::{new_tt_reader, reader};\n+use ext::tt::macro_parser::{Success, Error, Failure};\n+use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use ext::tt::macro_parser::{parse, parse_or_else};\n+use parse::lexer::{new_tt_reader, Reader};\n use parse::parser::Parser;\n-use parse::attr::parser_attr;\n+use parse::attr::ParserAttr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n-use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt, EOF};\n+use parse::token::{FAT_ARROW, SEMI, NtMatchers, NtTT, EOF};\n use print;\n use std::cell::RefCell;\n use util::small_vector::SmallVector;\n@@ -63,7 +63,7 @@ impl AnyMacro for ParserAnyMacro {\n         self.ensure_complete_parse(true);\n         ret\n     }\n-    fn make_items(&self) -> SmallVector<@ast::item> {\n+    fn make_items(&self) -> SmallVector<@ast::Item> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -89,15 +89,15 @@ impl AnyMacro for ParserAnyMacro {\n \n struct MacroRulesSyntaxExpanderTTFun {\n     name: Ident,\n-    lhses: @~[@named_match],\n-    rhses: @~[@named_match],\n+    lhses: @~[@NamedMatch],\n+    rhses: @~[@NamedMatch],\n }\n \n impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n     fn expand(&self,\n               cx: &mut ExtCtxt,\n               sp: Span,\n-              arg: &[ast::token_tree],\n+              arg: &[ast::TokenTree],\n               _: ast::SyntaxContext)\n               -> MacResult {\n         generic_extension(cx, sp, self.name, arg, *self.lhses, *self.rhses)\n@@ -108,16 +108,15 @@ impl SyntaxExpanderTTTrait for MacroRulesSyntaxExpanderTTFun {\n fn generic_extension(cx: &ExtCtxt,\n                      sp: Span,\n                      name: Ident,\n-                     arg: &[ast::token_tree],\n-                     lhses: &[@named_match],\n-                     rhses: &[@named_match])\n+                     arg: &[ast::TokenTree],\n+                     lhses: &[@NamedMatch],\n+                     rhses: &[@NamedMatch])\n                      -> MacResult {\n     if cx.trace_macros() {\n         println!(\"{}! \\\\{ {} \\\\}\",\n                   cx.str_of(name),\n-                  print::pprust::tt_to_str(\n-                      &ast::tt_delim(@arg.to_owned()),\n-                      get_ident_interner()));\n+                  print::pprust::tt_to_str(&TTDelim(@arg.to_owned()),\n+                                           get_ident_interner()));\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n@@ -128,17 +127,17 @@ fn generic_extension(cx: &ExtCtxt,\n \n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match *lhs {\n-          @matched_nonterminal(nt_matchers(ref mtcs)) => {\n+          @MatchedNonterminal(NtMatchers(ref mtcs)) => {\n             // `none` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned()) as @reader;\n+            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned()) as @Reader;\n             match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n-              success(named_matches) => {\n+              Success(named_matches) => {\n                 let rhs = match rhses[i] {\n                     // okay, what's your transcriber?\n-                    @matched_nonterminal(nt_tt(@ref tt)) => {\n+                    @MatchedNonterminal(NtTT(@ref tt)) => {\n                         match (*tt) {\n                             // cut off delimiters; don't parse 'em\n-                            tt_delim(ref tts) => {\n+                            TTDelim(ref tts) => {\n                                 (*tts).slice(1u,(*tts).len()-1u).to_owned()\n                             }\n                             _ => cx.span_fatal(\n@@ -150,18 +149,18 @@ fn generic_extension(cx: &ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                            rhs);\n-                let p = Parser(cx.parse_sess(), cx.cfg(), trncbr as @reader);\n+                let p = Parser(cx.parse_sess(), cx.cfg(), trncbr as @Reader);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n                 return MRAny(@ParserAnyMacro {\n                     parser: RefCell::new(p),\n                 } as @AnyMacro)\n               }\n-              failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n+              Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n+              Error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n@@ -176,11 +175,11 @@ fn generic_extension(cx: &ExtCtxt,\n pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n-                         arg: ~[ast::token_tree],\n+                         arg: ~[ast::TokenTree],\n                          _: ast::SyntaxContext)\n                          -> base::MacResult {\n     // these spans won't matter, anyways\n-    fn ms(m: matcher_) -> matcher {\n+    fn ms(m: Matcher_) -> Matcher {\n         Spanned {\n             node: m.clone(),\n             span: DUMMY_SP\n@@ -195,14 +194,14 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n     // $( $lhs:mtcs => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     let argument_gram = ~[\n-        ms(match_seq(~[\n-            ms(match_nonterminal(lhs_nm, special_idents::matchers, 0u)),\n-            ms(match_tok(FAT_ARROW)),\n-            ms(match_nonterminal(rhs_nm, special_idents::tt, 1u)),\n+        ms(MatchSeq(~[\n+            ms(MatchNonterminal(lhs_nm, special_idents::matchers, 0u)),\n+            ms(MatchTok(FAT_ARROW)),\n+            ms(MatchNonterminal(rhs_nm, special_idents::tt, 1u)),\n         ], Some(SEMI), false, 0u, 2u)),\n         //to phase into semicolon-termination instead of\n         //semicolon-separation\n-        ms(match_seq(~[ms(match_tok(SEMI))], None, true, 2u, 2u))];\n+        ms(MatchSeq(~[ms(MatchTok(SEMI))], None, true, 2u, 2u))];\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n@@ -211,18 +210,18 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n-                                     arg_reader as @reader,\n+                                     arg_reader as @Reader,\n                                      argument_gram);\n \n     // Extract the arguments:\n     let lhses = match *argument_map.get(&lhs_nm) {\n-        @matched_seq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+        @MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map.get(&rhs_nm) {\n-      @matched_seq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n-      _ => cx.span_bug(sp, \"wrong-structured rhs\")\n+        @MatchedSeq(ref s, _) => /* FIXME (#2543) */ @(*s).clone(),\n+        _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n     let exp = ~MacroRulesSyntaxExpanderTTFun {"}, {"sha": "2b90f4221a87f677a3a274424a204956e8f7786b", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -9,21 +9,21 @@\n // except according to those terms.\n \n use ast;\n-use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,Ident};\n+use ast::{TokenTree, TTDelim, TTTok, TTSeq, TTNonterminal, Ident};\n use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n-use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n-use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n+use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n+use parse::token::{EOF, INTERPOLATED, IDENT, Token, NtIdent};\n use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n use std::cell::{Cell, RefCell};\n use std::hashmap::HashMap;\n use std::option;\n \n-///an unzipping of `token_tree`s\n+///an unzipping of `TokenTree`s\n struct TtFrame {\n-    forest: @~[ast::token_tree],\n+    forest: @~[ast::TokenTree],\n     idx: Cell<uint>,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n@@ -35,7 +35,7 @@ pub struct TtReader {\n     // the unzipped tree:\n     priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n-    priv interpolations: RefCell<HashMap<Ident, @named_match>>,\n+    priv interpolations: RefCell<HashMap<Ident, @NamedMatch>>,\n     priv repeat_idx: RefCell<~[uint]>,\n     priv repeat_len: RefCell<~[uint]>,\n     /* cached: */\n@@ -44,11 +44,11 @@ pub struct TtReader {\n }\n \n /** This can do Macro-By-Example transcription. On the other hand, if\n- *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n+ *  `src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @SpanHandler,\n-                     interp: Option<HashMap<Ident,@named_match>>,\n-                     src: ~[ast::token_tree])\n+                     interp: Option<HashMap<Ident, @NamedMatch>>,\n+                     src: ~[ast::TokenTree])\n                      -> @TtReader {\n     let r = @TtReader {\n         sp_diag: sp_diag,\n@@ -99,22 +99,22 @@ pub fn dup_tt_reader(r: @TtReader) -> @TtReader {\n }\n \n \n-fn lookup_cur_matched_by_matched(r: &TtReader, start: @named_match)\n-                                 -> @named_match {\n-    fn red(ad: @named_match, idx: &uint) -> @named_match {\n+fn lookup_cur_matched_by_matched(r: &TtReader, start: @NamedMatch)\n+                                 -> @NamedMatch {\n+    fn red(ad: @NamedMatch, idx: &uint) -> @NamedMatch {\n         match *ad {\n-          matched_nonterminal(_) => {\n-            // end of the line; duplicate henceforth\n-            ad\n-          }\n-          matched_seq(ref ads, _) => ads[*idx]\n+            MatchedNonterminal(_) => {\n+                // end of the line; duplicate henceforth\n+                ad\n+            }\n+            MatchedSeq(ref ads, _) => ads[*idx]\n         }\n     }\n     let repeat_idx = r.repeat_idx.borrow();\n     repeat_idx.get().iter().fold(start, red)\n }\n \n-fn lookup_cur_matched(r: &TtReader, name: Ident) -> @named_match {\n+fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n     let matched_opt = {\n         let interpolations = r.interpolations.borrow();\n         interpolations.get().find_copy(&name)\n@@ -130,43 +130,43 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> @named_match {\n }\n \n #[deriving(Clone)]\n-enum lis {\n-    lis_unconstrained,\n-    lis_constraint(uint, Ident),\n-    lis_contradiction(~str),\n+enum LockstepIterSize {\n+    LisUnconstrained,\n+    LisConstraint(uint, Ident),\n+    LisContradiction(~str),\n }\n \n-fn lockstep_iter_size(t: &token_tree, r: &TtReader) -> lis {\n-    fn lis_merge(lhs: lis, rhs: lis) -> lis {\n-        match lhs {\n-          lis_unconstrained => rhs.clone(),\n-          lis_contradiction(_) => lhs.clone(),\n-          lis_constraint(l_len, ref l_id) => match rhs {\n-            lis_unconstrained => lhs.clone(),\n-            lis_contradiction(_) => rhs.clone(),\n-            lis_constraint(r_len, _) if l_len == r_len => lhs.clone(),\n-            lis_constraint(r_len, ref r_id) => {\n+fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n+    match lhs {\n+        LisUnconstrained => rhs.clone(),\n+        LisContradiction(_) => lhs.clone(),\n+        LisConstraint(l_len, ref l_id) => match rhs {\n+            LisUnconstrained => lhs.clone(),\n+            LisContradiction(_) => rhs.clone(),\n+            LisConstraint(r_len, _) if l_len == r_len => lhs.clone(),\n+            LisConstraint(r_len, ref r_id) => {\n                 let l_n = ident_to_str(l_id);\n                 let r_n = ident_to_str(r_id);\n-                lis_contradiction(format!(\"Inconsistent lockstep iteration: \\\n-                                           '{}' has {} items, but '{}' has {}\",\n-                                           l_n, l_len, r_n, r_len))\n+                LisContradiction(format!(\"Inconsistent lockstep iteration: \\\n+                                          '{}' has {} items, but '{}' has {}\",\n+                                          l_n, l_len, r_n, r_len))\n             }\n-          }\n         }\n     }\n+}\n+\n+fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n     match *t {\n-      tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        tts.iter().fold(lis_unconstrained, |lis, tt| {\n-            let lis2 = lockstep_iter_size(tt, r);\n-            lis_merge(lis, lis2)\n-        })\n-      }\n-      tt_tok(..) => lis_unconstrained,\n-      tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n-        matched_nonterminal(_) => lis_unconstrained,\n-        matched_seq(ref ads, _) => lis_constraint(ads.len(), name)\n-      }\n+        TTDelim(ref tts) | TTSeq(_, ref tts, _, _) => {\n+            tts.iter().fold(LisUnconstrained, |lis, tt| {\n+                lis_merge(lis, lockstep_iter_size(tt, r))\n+            })\n+        }\n+        TTTok(..) => LisUnconstrained,\n+        TTNonterminal(_, name) => match *lookup_cur_matched(r, name) {\n+            MatchedNonterminal(_) => LisUnconstrained,\n+            MatchedSeq(ref ads, _) => LisConstraint(ads.len(), name)\n+        }\n     }\n }\n \n@@ -228,11 +228,11 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n             }\n         }\n     }\n-    loop { /* because it's easiest, this handles `tt_delim` not starting\n-    with a `tt_tok`, even though it won't happen */\n+    loop { /* because it's easiest, this handles `TTDelim` not starting\n+    with a `TTTok`, even though it won't happen */\n         // XXX(pcwalton): Bad copy.\n         match r.stack.get().forest[r.stack.get().idx.get()].clone() {\n-          tt_delim(tts) => {\n+          TTDelim(tts) => {\n             r.stack.set(@TtFrame {\n                 forest: tts,\n                 idx: Cell::new(0u),\n@@ -242,28 +242,28 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n             });\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, tok) => {\n+          TTTok(sp, tok) => {\n             r.cur_span.set(sp);\n             r.cur_tok.set(tok);\n             r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n             return ret_val;\n           }\n-          tt_seq(sp, tts, sep, zerok) => {\n+          TTSeq(sp, tts, sep, zerok) => {\n             // XXX(pcwalton): Bad copy.\n-            let t = tt_seq(sp, tts, sep.clone(), zerok);\n+            let t = TTSeq(sp, tts, sep.clone(), zerok);\n             match lockstep_iter_size(&t, r) {\n-              lis_unconstrained => {\n+              LisUnconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n                       \"attempted to repeat an expression \\\n                        containing no syntax \\\n                        variables matched as repeating at this depth\");\n                   }\n-                  lis_contradiction(ref msg) => {\n+                  LisContradiction(ref msg) => {\n                       /* FIXME #2887 blame macro invoker instead*/\n                       r.sp_diag.span_fatal(sp, (*msg));\n                   }\n-                  lis_constraint(len, _) => {\n+                  LisConstraint(len, _) => {\n                     if len == 0 {\n                       if !zerok {\n                         r.sp_diag.span_fatal(sp, /* FIXME #2887 blame invoker\n@@ -293,25 +293,25 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n             }\n           }\n           // FIXME #2887: think about span stuff here\n-          tt_nonterminal(sp, ident) => {\n+          TTNonterminal(sp, ident) => {\n             match *lookup_cur_matched(r, ident) {\n               /* sidestep the interpolation tricks for ident because\n               (a) idents can be in lots of places, so it'd be a pain\n               (b) we actually can, since it's a token. */\n-              matched_nonterminal(nt_ident(~sn,b)) => {\n+              MatchedNonterminal(NtIdent(~sn,b)) => {\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(IDENT(sn,b));\n                 r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n-              matched_nonterminal(ref other_whole_nt) => {\n+              MatchedNonterminal(ref other_whole_nt) => {\n                 // XXX(pcwalton): Bad copy.\n                 r.cur_span.set(sp);\n                 r.cur_tok.set(INTERPOLATED((*other_whole_nt).clone()));\n                 r.stack.get().idx.set(r.stack.get().idx.get() + 1u);\n                 return ret_val;\n               }\n-              matched_seq(..) => {\n+              MatchedSeq(..) => {\n                 r.sp_diag.span_fatal(\n                     r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\","}, {"sha": "c73edb0bfcf5cb9574ddf14b940cc32949658884", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 153, "deletions": 163, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -16,7 +16,7 @@ use opt_vec::OptVec;\n use util::small_vector::SmallVector;\n \n // We may eventually want to be able to fold over type parameters, too.\n-pub trait ast_fold {\n+pub trait Folder {\n     fn fold_crate(&mut self, c: Crate) -> Crate {\n         noop_fold_crate(c, self)\n     }\n@@ -25,34 +25,34 @@ pub trait ast_fold {\n         meta_items.map(|x| fold_meta_item_(*x, self))\n     }\n \n-    fn fold_view_paths(&mut self, view_paths: &[@view_path]) -> ~[@view_path] {\n+    fn fold_view_paths(&mut self, view_paths: &[@ViewPath]) -> ~[@ViewPath] {\n         view_paths.map(|view_path| {\n             let inner_view_path = match view_path.node {\n-                view_path_simple(ref ident, ref path, node_id) => {\n-                    view_path_simple(ident.clone(),\n-                                     self.fold_path(path),\n-                                     self.new_id(node_id))\n+                ViewPathSimple(ref ident, ref path, node_id) => {\n+                    ViewPathSimple(ident.clone(),\n+                                   self.fold_path(path),\n+                                   self.new_id(node_id))\n                 }\n-                view_path_glob(ref path, node_id) => {\n-                    view_path_glob(self.fold_path(path), self.new_id(node_id))\n+                ViewPathGlob(ref path, node_id) => {\n+                    ViewPathGlob(self.fold_path(path), self.new_id(node_id))\n                 }\n-                view_path_list(ref path, ref path_list_idents, node_id) => {\n-                    view_path_list(self.fold_path(path),\n-                                   path_list_idents.map(|path_list_ident| {\n+                ViewPathList(ref path, ref path_list_idents, node_id) => {\n+                    ViewPathList(self.fold_path(path),\n+                                 path_list_idents.map(|path_list_ident| {\n                                     let id = self.new_id(path_list_ident.node\n                                                                         .id);\n                                     Spanned {\n-                                        node: path_list_ident_ {\n+                                        node: PathListIdent_ {\n                                             name: path_list_ident.node\n                                                                  .name\n                                                                  .clone(),\n                                             id: id,\n                                         },\n                                         span: self.new_span(\n                                             path_list_ident.span)\n-                                   }\n-                                  }),\n-                                  self.new_id(node_id))\n+                                    }\n+                                 }),\n+                                 self.new_id(node_id))\n                 }\n             };\n             @Spanned {\n@@ -62,40 +62,36 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_view_item(&mut self, vi: &view_item) -> view_item {\n+    fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n         let inner_view_item = match vi.node {\n-            view_item_extern_mod(ref ident,\n-                                 string,\n-                                 node_id) => {\n-                view_item_extern_mod(ident.clone(),\n-                                     string,\n-                                     self.new_id(node_id))\n+            ViewItemExternMod(ref ident, string, node_id) => {\n+                ViewItemExternMod(ident.clone(), string, self.new_id(node_id))\n             }\n-            view_item_use(ref view_paths) => {\n-                view_item_use(self.fold_view_paths(*view_paths))\n+            ViewItemUse(ref view_paths) => {\n+                ViewItemUse(self.fold_view_paths(*view_paths))\n             }\n         };\n-        view_item {\n+        ViewItem {\n             node: inner_view_item,\n             attrs: vi.attrs.map(|a| fold_attribute_(*a, self)),\n             vis: vi.vis,\n             span: self.new_span(vi.span),\n         }\n     }\n \n-    fn fold_foreign_item(&mut self, ni: @foreign_item) -> @foreign_item {\n+    fn fold_foreign_item(&mut self, ni: @ForeignItem) -> @ForeignItem {\n         noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: @item) -> SmallVector<@item> {\n+    fn fold_item(&mut self, i: @Item) -> SmallVector<@Item> {\n         noop_fold_item(i, self)\n     }\n \n-    fn fold_struct_field(&mut self, sf: &struct_field) -> struct_field {\n+    fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n         let fold_attribute = |x| fold_attribute_(x, self);\n \n         Spanned {\n-            node: ast::struct_field_ {\n+            node: ast::StructField_ {\n                 kind: sf.node.kind,\n                 id: self.new_id(sf.node.id),\n                 ty: self.fold_ty(sf.node.ty),\n@@ -105,19 +101,19 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_item_underscore(&mut self, i: &item_) -> item_ {\n+    fn fold_item_underscore(&mut self, i: &Item_) -> Item_ {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_fn_decl(&mut self, d: &fn_decl) -> P<fn_decl> {\n+    fn fold_fn_decl(&mut self, d: &FnDecl) -> P<FnDecl> {\n         noop_fold_fn_decl(d, self)\n     }\n \n     fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: @method) -> @method {\n+    fn fold_method(&mut self, m: @Method) -> @Method {\n         noop_fold_method(m, self)\n     }\n \n@@ -163,16 +159,16 @@ pub trait ast_fold {\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         let node = match t.node {\n-            ty_nil | ty_bot | ty_infer => t.node.clone(),\n-            ty_box(ty) => ty_box(self.fold_ty(ty)),\n-            ty_uniq(ty) => ty_uniq(self.fold_ty(ty)),\n-            ty_vec(ty) => ty_vec(self.fold_ty(ty)),\n-            ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n-            ty_rptr(ref region, ref mt) => {\n-                ty_rptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n+            TyNil | TyBot | TyInfer => t.node.clone(),\n+            TyBox(ty) => TyBox(self.fold_ty(ty)),\n+            TyUniq(ty) => TyUniq(self.fold_ty(ty)),\n+            TyVec(ty) => TyVec(self.fold_ty(ty)),\n+            TyPtr(ref mt) => TyPtr(fold_mt(mt, self)),\n+            TyRptr(ref region, ref mt) => {\n+                TyRptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n             }\n-            ty_closure(ref f) => {\n-                ty_closure(@TyClosure {\n+            TyClosure(ref f) => {\n+                TyClosure(@ClosureTy {\n                     sigil: f.sigil,\n                     purity: f.purity,\n                     region: fold_opt_lifetime(&f.region, self),\n@@ -182,24 +178,24 @@ pub trait ast_fold {\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                 })\n             }\n-            ty_bare_fn(ref f) => {\n-                ty_bare_fn(@TyBareFn {\n+            TyBareFn(ref f) => {\n+                TyBareFn(@BareFnTy {\n                     lifetimes: f.lifetimes.map(|l| fold_lifetime(l, self)),\n                     purity: f.purity,\n                     abis: f.abis,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n-            ty_tup(ref tys) => ty_tup(tys.map(|&ty| self.fold_ty(ty))),\n-            ty_path(ref path, ref bounds, id) => {\n-                ty_path(self.fold_path(path),\n-                        fold_opt_bounds(bounds, self),\n-                        self.new_id(id))\n+            TyTup(ref tys) => TyTup(tys.map(|&ty| self.fold_ty(ty))),\n+            TyPath(ref path, ref bounds, id) => {\n+                TyPath(self.fold_path(path),\n+                       fold_opt_bounds(bounds, self),\n+                       self.new_id(id))\n             }\n-            ty_fixed_length_vec(ty, e) => {\n-                ty_fixed_length_vec(self.fold_ty(ty), self.fold_expr(e))\n+            TyFixedLengthVec(ty, e) => {\n+                TyFixedLengthVec(self.fold_ty(ty), self.fold_expr(e))\n             }\n-            ty_typeof(expr) => ty_typeof(self.fold_expr(expr)),\n+            TyTypeof(expr) => TyTypeof(self.fold_expr(expr)),\n         };\n         P(Ty {\n             id: self.new_id(t.id),\n@@ -208,12 +204,12 @@ pub trait ast_fold {\n         })\n     }\n \n-    fn fold_mod(&mut self, m: &_mod) -> _mod {\n+    fn fold_mod(&mut self, m: &Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n \n-    fn fold_foreign_mod(&mut self, nm: &foreign_mod) -> foreign_mod {\n-        ast::foreign_mod {\n+    fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n+        ast::ForeignMod {\n             abis: nm.abis,\n             view_items: nm.view_items\n                           .iter()\n@@ -226,15 +222,15 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_variant(&mut self, v: &variant) -> P<variant> {\n+    fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n         let kind;\n         match v.node.kind {\n-            tuple_variant_kind(ref variant_args) => {\n-                kind = tuple_variant_kind(variant_args.map(|x|\n+            TupleVariantKind(ref variant_args) => {\n+                kind = TupleVariantKind(variant_args.map(|x|\n                     fold_variant_arg_(x, self)))\n             }\n-            struct_variant_kind(ref struct_def) => {\n-                kind = struct_variant_kind(@ast::struct_def {\n+            StructVariantKind(ref struct_def) => {\n+                kind = StructVariantKind(@ast::StructDef {\n                     fields: struct_def.fields.iter()\n                         .map(|f| self.fold_struct_field(f)).collect(),\n                     ctor_id: struct_def.ctor_id.map(|c| self.new_id(c))\n@@ -249,7 +245,7 @@ pub trait ast_fold {\n           Some(e) => Some(self.fold_expr(e)),\n           None => None\n         };\n-        let node = ast::variant_ {\n+        let node = ast::Variant_ {\n             name: v.node.name,\n             attrs: attrs,\n             kind: kind,\n@@ -289,13 +285,13 @@ pub trait ast_fold {\n         }\n     }\n \n-    fn fold_mac(&mut self, macro: &mac) -> mac {\n+    fn fold_mac(&mut self, macro: &Mac) -> Mac {\n         Spanned {\n             node: match macro.node {\n-                mac_invoc_tt(ref p, ref tts, ctxt) => {\n-                    mac_invoc_tt(self.fold_path(p),\n-                                 fold_tts(*tts, self),\n-                                 ctxt)\n+                MacInvocTT(ref p, ref tts, ctxt) => {\n+                    MacInvocTT(self.fold_path(p),\n+                               fold_tts(*tts, self),\n+                               ctxt)\n                 }\n             },\n             span: self.new_span(macro.span)\n@@ -314,29 +310,29 @@ pub trait ast_fold {\n         sp\n     }\n \n-    fn fold_explicit_self(&mut self, es: &explicit_self) -> explicit_self {\n+    fn fold_explicit_self(&mut self, es: &ExplicitSelf) -> ExplicitSelf {\n         Spanned {\n             span: self.new_span(es.span),\n             node: self.fold_explicit_self_(&es.node)\n         }\n     }\n \n-    fn fold_explicit_self_(&mut self, es: &explicit_self_) -> explicit_self_ {\n+    fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            sty_static | sty_value(_) | sty_uniq(_) | sty_box(_) => {\n+            SelfStatic | SelfValue(_) | SelfUniq(_) | SelfBox(_) => {\n                 *es\n             }\n-            sty_region(ref lifetime, m) => {\n-                sty_region(fold_opt_lifetime(lifetime, self), m)\n+            SelfRegion(ref lifetime, m) => {\n+                SelfRegion(fold_opt_lifetime(lifetime, self), m)\n             }\n         }\n     }\n }\n \n-/* some little folds that probably aren't useful to have in ast_fold itself*/\n+/* some little folds that probably aren't useful to have in Folder itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_<T: ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n+fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n     @Spanned {\n         node:\n             match mi.node {\n@@ -354,7 +350,7 @@ fn fold_meta_item_<T: ast_fold>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n }\n \n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_<T: ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n+fn fold_attribute_<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n     Spanned {\n         span: fld.new_span(at.span),\n         node: ast::Attribute_ {\n@@ -366,35 +362,35 @@ fn fold_attribute_<T: ast_fold>(at: Attribute, fld: &mut T) -> Attribute {\n }\n \n //used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_<T: ast_fold>(a: &arg, fld: &mut T) -> arg {\n-    ast::arg {\n+fn fold_arg_<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n+    Arg {\n         ty: fld.fold_ty(a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),\n     }\n }\n \n-// build a new vector of tts by appling the ast_fold's fold_ident to\n+// build a new vector of tts by appling the Folder's fold_ident to\n // all of the identifiers in the token trees.\n-pub fn fold_tts<T: ast_fold>(tts: &[token_tree], fld: &mut T) -> ~[token_tree] {\n+pub fn fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> ~[TokenTree] {\n     tts.map(|tt| {\n         match *tt {\n-            tt_tok(span, ref tok) =>\n-            tt_tok(span,maybe_fold_ident(tok,fld)),\n-            tt_delim(tts) => tt_delim(@fold_tts(*tts, fld)),\n-            tt_seq(span, pattern, ref sep, is_optional) =>\n-            tt_seq(span,\n-                   @fold_tts(*pattern, fld),\n-                   sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n-                   is_optional),\n-            tt_nonterminal(sp,ref ident) =>\n-            tt_nonterminal(sp,fld.fold_ident(*ident))\n+            TTTok(span, ref tok) =>\n+            TTTok(span,maybe_fold_ident(tok,fld)),\n+            TTDelim(tts) => TTDelim(@fold_tts(*tts, fld)),\n+            TTSeq(span, pattern, ref sep, is_optional) =>\n+            TTSeq(span,\n+                  @fold_tts(*pattern, fld),\n+                  sep.as_ref().map(|tok|maybe_fold_ident(tok,fld)),\n+                  is_optional),\n+            TTNonterminal(sp,ref ident) =>\n+            TTNonterminal(sp,fld.fold_ident(*ident))\n         }\n     })\n }\n \n // apply ident folder if it's an ident, otherwise leave it alone\n-fn maybe_fold_ident<T: ast_fold>(t: &token::Token, fld: &mut T) -> token::Token {\n+fn maybe_fold_ident<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n     match *t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n@@ -403,77 +399,76 @@ fn maybe_fold_ident<T: ast_fold>(t: &token::Token, fld: &mut T) -> token::Token\n     }\n }\n \n-pub fn noop_fold_fn_decl<T: ast_fold>(decl: &fn_decl, fld: &mut T)\n-                                      -> P<fn_decl> {\n-    P(fn_decl {\n+pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n+    P(FnDecl {\n         inputs: decl.inputs.map(|x| fold_arg_(x, fld)), // bad copy\n         output: fld.fold_ty(decl.output),\n         cf: decl.cf,\n         variadic: decl.variadic\n     })\n }\n \n-fn fold_ty_param_bound<T: ast_fold>(tpb: &TyParamBound, fld: &mut T)\n+fn fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n                                     -> TyParamBound {\n     match *tpb {\n         TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n         RegionTyParamBound => RegionTyParamBound\n     }\n }\n \n-pub fn fold_ty_param<T: ast_fold>(tp: &TyParam, fld: &mut T) -> TyParam {\n+pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: fld.new_id(tp.id),\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n     }\n }\n \n-pub fn fold_ty_params<T: ast_fold>(tps: &OptVec<TyParam>, fld: &mut T)\n+pub fn fold_ty_params<T: Folder>(tps: &OptVec<TyParam>, fld: &mut T)\n                                    -> OptVec<TyParam> {\n     tps.map(|tp| fold_ty_param(tp, fld))\n }\n \n-pub fn fold_lifetime<T: ast_fold>(l: &Lifetime, fld: &mut T) -> Lifetime {\n+pub fn fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n         id: fld.new_id(l.id),\n         span: fld.new_span(l.span),\n         ident: l.ident\n     }\n }\n \n-pub fn fold_lifetimes<T: ast_fold>(lts: &OptVec<Lifetime>, fld: &mut T)\n+pub fn fold_lifetimes<T: Folder>(lts: &OptVec<Lifetime>, fld: &mut T)\n                                    -> OptVec<Lifetime> {\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n-pub fn fold_opt_lifetime<T: ast_fold>(o_lt: &Option<Lifetime>, fld: &mut T)\n+pub fn fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n                                       -> Option<Lifetime> {\n     o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n }\n \n-pub fn fold_generics<T: ast_fold>(generics: &Generics, fld: &mut T) -> Generics {\n+pub fn fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n }\n \n-fn fold_struct_def<T: ast_fold>(struct_def: @struct_def, fld: &mut T) -> @struct_def {\n-    @ast::struct_def {\n+fn fold_struct_def<T: Folder>(struct_def: @StructDef, fld: &mut T) -> @StructDef {\n+    @ast::StructDef {\n         fields: struct_def.fields.map(|f| fold_struct_field(f, fld)),\n         ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n     }\n }\n \n-fn fold_trait_ref<T: ast_fold>(p: &trait_ref, fld: &mut T) -> trait_ref {\n-    ast::trait_ref {\n+fn fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n+    ast::TraitRef {\n         path: fld.fold_path(&p.path),\n         ref_id: fld.new_id(p.ref_id),\n     }\n }\n \n-fn fold_struct_field<T: ast_fold>(f: &struct_field, fld: &mut T) -> struct_field {\n+fn fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n     Spanned {\n-        node: ast::struct_field_ {\n+        node: ast::StructField_ {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(f.node.ty),\n@@ -483,38 +478,38 @@ fn fold_struct_field<T: ast_fold>(f: &struct_field, fld: &mut T) -> struct_field\n     }\n }\n \n-fn fold_field_<T: ast_fold>(field: Field, folder: &mut T) -> Field {\n+fn fold_field_<T: Folder>(field: Field, folder: &mut T) -> Field {\n     ast::Field {\n         ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n         expr: folder.fold_expr(field.expr),\n         span: folder.new_span(field.span),\n     }\n }\n \n-fn fold_mt<T: ast_fold>(mt: &mt, folder: &mut T) -> mt {\n-    mt {\n+fn fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n+    MutTy {\n         ty: folder.fold_ty(mt.ty),\n         mutbl: mt.mutbl,\n     }\n }\n \n-fn fold_opt_bounds<T: ast_fold>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n-                                -> Option<OptVec<TyParamBound>> {\n+fn fold_opt_bounds<T: Folder>(b: &Option<OptVec<TyParamBound>>, folder: &mut T)\n+                              -> Option<OptVec<TyParamBound>> {\n     b.as_ref().map(|bounds| {\n         bounds.map(|bound| {\n             fold_ty_param_bound(bound, folder)\n         })\n     })\n }\n \n-fn fold_variant_arg_<T: ast_fold>(va: &variant_arg, folder: &mut T) -> variant_arg {\n-    ast::variant_arg {\n+fn fold_variant_arg_<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n+    ast::VariantArg {\n         ty: folder.fold_ty(va.ty),\n         id: folder.new_id(va.id)\n     }\n }\n \n-pub fn noop_fold_block<T: ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n+pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     let view_items = b.view_items.map(|x| folder.fold_view_item(x));\n     let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(*s).move_iter()).collect();\n     P(Block {\n@@ -527,64 +522,61 @@ pub fn noop_fold_block<T: ast_fold>(b: P<Block>, folder: &mut T) -> P<Block> {\n     })\n }\n \n-pub fn noop_fold_item_underscore<T: ast_fold>(i: &item_, folder: &mut T) -> item_ {\n+pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_ {\n     match *i {\n-        item_static(t, m, e) => {\n-            item_static(folder.fold_ty(t), m, folder.fold_expr(e))\n+        ItemStatic(t, m, e) => {\n+            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        item_fn(decl, purity, abi, ref generics, body) => {\n-            item_fn(\n+        ItemFn(decl, purity, abi, ref generics, body) => {\n+            ItemFn(\n                 folder.fold_fn_decl(decl),\n                 purity,\n                 abi,\n                 fold_generics(generics, folder),\n                 folder.fold_block(body)\n             )\n         }\n-        item_mod(ref m) => item_mod(folder.fold_mod(m)),\n-        item_foreign_mod(ref nm) => {\n-            item_foreign_mod(folder.fold_foreign_mod(nm))\n+        ItemMod(ref m) => ItemMod(folder.fold_mod(m)),\n+        ItemForeignMod(ref nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemTy(t, ref generics) => {\n+            ItemTy(folder.fold_ty(t), fold_generics(generics, folder))\n         }\n-        item_ty(t, ref generics) => {\n-            item_ty(folder.fold_ty(t),\n-                    fold_generics(generics, folder))\n-        }\n-        item_enum(ref enum_definition, ref generics) => {\n-            item_enum(\n-                ast::enum_def {\n+        ItemEnum(ref enum_definition, ref generics) => {\n+            ItemEnum(\n+                ast::EnumDef {\n                     variants: enum_definition.variants.map(|&x| {\n                         folder.fold_variant(x)\n                     }),\n                 },\n                 fold_generics(generics, folder))\n         }\n-        item_struct(ref struct_def, ref generics) => {\n+        ItemStruct(ref struct_def, ref generics) => {\n             let struct_def = fold_struct_def(*struct_def, folder);\n-            item_struct(struct_def, fold_generics(generics, folder))\n+            ItemStruct(struct_def, fold_generics(generics, folder))\n         }\n-        item_impl(ref generics, ref ifce, ty, ref methods) => {\n-            item_impl(fold_generics(generics, folder),\n-                      ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n-                      folder.fold_ty(ty),\n-                      methods.map(|x| folder.fold_method(*x))\n+        ItemImpl(ref generics, ref ifce, ty, ref methods) => {\n+            ItemImpl(fold_generics(generics, folder),\n+                     ifce.as_ref().map(|p| fold_trait_ref(p, folder)),\n+                     folder.fold_ty(ty),\n+                     methods.map(|x| folder.fold_method(*x))\n             )\n         }\n-        item_trait(ref generics, ref traits, ref methods) => {\n+        ItemTrait(ref generics, ref traits, ref methods) => {\n             let methods = methods.map(|method| {\n                 match *method {\n-                    required(ref m) => required(folder.fold_type_method(m)),\n-                    provided(method) => provided(folder.fold_method(method))\n+                    Required(ref m) => Required(folder.fold_type_method(m)),\n+                    Provided(method) => Provided(folder.fold_method(method))\n                 }\n             });\n-            item_trait(fold_generics(generics, folder),\n-                       traits.map(|p| fold_trait_ref(p, folder)),\n-                       methods)\n+            ItemTrait(fold_generics(generics, folder),\n+                      traits.map(|p| fold_trait_ref(p, folder)),\n+                      methods)\n         }\n-        item_mac(ref m) => item_mac(folder.fold_mac(m)),\n+        ItemMac(ref m) => ItemMac(folder.fold_mac(m)),\n     }\n }\n \n-pub fn noop_fold_type_method<T: ast_fold>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n+pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n     TypeMethod {\n         ident: fld.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, fld)),\n@@ -597,16 +589,16 @@ pub fn noop_fold_type_method<T: ast_fold>(m: &TypeMethod, fld: &mut T) -> TypeMe\n     }\n }\n \n-pub fn noop_fold_mod<T: ast_fold>(m: &_mod, folder: &mut T) -> _mod {\n-    ast::_mod {\n+pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n+    ast::Mod {\n         view_items: m.view_items\n                      .iter()\n                      .map(|x| folder.fold_view_item(x)).collect(),\n         items: m.items.iter().flat_map(|x| folder.fold_item(*x).move_iter()).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: ast_fold>(c: Crate, folder: &mut T) -> Crate {\n+pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n     let fold_meta_item = |x| fold_meta_item_(x, folder);\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n@@ -618,11 +610,10 @@ pub fn noop_fold_crate<T: ast_fold>(c: Crate, folder: &mut T) -> Crate {\n     }\n }\n \n-pub fn noop_fold_item<T: ast_fold>(i: &item, folder: &mut T)\n-                                   -> SmallVector<@item> {\n+pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item> {\n     let fold_attribute = |x| fold_attribute_(x, folder);\n \n-    SmallVector::one(@item {\n+    SmallVector::one(@Item {\n         ident: folder.fold_ident(i.ident),\n         attrs: i.attrs.map(|e| fold_attribute(*e)),\n         id: folder.new_id(i.id),\n@@ -632,22 +623,21 @@ pub fn noop_fold_item<T: ast_fold>(i: &item, folder: &mut T)\n     })\n }\n \n-pub fn noop_fold_foreign_item<T: ast_fold>(ni: &foreign_item, folder: &mut T)\n-                                           -> @foreign_item {\n-    @foreign_item {\n+pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem, folder: &mut T) -> @ForeignItem {\n+    @ForeignItem {\n         ident: folder.fold_ident(ni.ident),\n         attrs: ni.attrs.map(|x| fold_attribute_(*x, folder)),\n         node: match ni.node {\n-            foreign_item_fn(ref fdec, ref generics) => {\n-                foreign_item_fn(P(fn_decl {\n+            ForeignItemFn(ref fdec, ref generics) => {\n+                ForeignItemFn(P(FnDecl {\n                     inputs: fdec.inputs.map(|a| fold_arg_(a, folder)),\n                     output: folder.fold_ty(fdec.output),\n                     cf: fdec.cf,\n                     variadic: fdec.variadic\n                 }), fold_generics(generics, folder))\n             }\n-            foreign_item_static(t, m) => {\n-                foreign_item_static(folder.fold_ty(t), m)\n+            ForeignItemStatic(t, m) => {\n+                ForeignItemStatic(folder.fold_ty(t), m)\n             }\n         },\n         id: folder.new_id(ni.id),\n@@ -656,8 +646,8 @@ pub fn noop_fold_foreign_item<T: ast_fold>(ni: &foreign_item, folder: &mut T)\n     }\n }\n \n-pub fn noop_fold_method<T: ast_fold>(m: &method, folder: &mut T) -> @method {\n-    @method {\n+pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> @Method {\n+    @Method {\n         ident: folder.fold_ident(m.ident),\n         attrs: m.attrs.map(|a| fold_attribute_(*a, folder)),\n         generics: fold_generics(&m.generics, folder),\n@@ -672,7 +662,7 @@ pub fn noop_fold_method<T: ast_fold>(m: &method, folder: &mut T) -> @method {\n     }\n }\n \n-pub fn noop_fold_pat<T: ast_fold>(p: @Pat, folder: &mut T) -> @Pat {\n+pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n     let node = match p.node {\n         PatWild => PatWild,\n         PatWildMulti => PatWildMulti,\n@@ -717,7 +707,7 @@ pub fn noop_fold_pat<T: ast_fold>(p: @Pat, folder: &mut T) -> @Pat {\n     }\n }\n \n-pub fn noop_fold_expr<T: ast_fold>(e: @Expr, folder: &mut T) -> @Expr {\n+pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n     let fold_field = |x| fold_field_(x, folder);\n \n     let node = match e.node {\n@@ -818,7 +808,7 @@ pub fn noop_fold_expr<T: ast_fold>(e: @Expr, folder: &mut T) -> @Expr {\n             ExprRet(e.map(|x| folder.fold_expr(x)))\n         }\n         ExprInlineAsm(ref a) => {\n-            ExprInlineAsm(inline_asm {\n+            ExprInlineAsm(InlineAsm {\n                 inputs: a.inputs.map(|&(c, input)| (c, folder.fold_expr(input))),\n                 outputs: a.outputs.map(|&(c, out)| (c, folder.fold_expr(out))),\n                 .. (*a).clone()\n@@ -840,7 +830,7 @@ pub fn noop_fold_expr<T: ast_fold>(e: @Expr, folder: &mut T) -> @Expr {\n     }\n }\n \n-pub fn noop_fold_stmt<T: ast_fold>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n+pub fn noop_fold_stmt<T: Folder>(s: &Stmt, folder: &mut T) -> SmallVector<@Stmt> {\n     let nodes = match s.node {\n         StmtDecl(d, nid) => {\n             folder.fold_decl(d).move_iter()\n@@ -871,14 +861,14 @@ mod test {\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::ps, crate: &ast::Crate) {\n+    fn fake_print_crate(s: &mut pprust::State, crate: &ast::Crate) {\n         pprust::print_mod(s, &crate.module, crate.attrs);\n     }\n \n     // change every identifier to \"zz\"\n     struct ToZzIdentFolder;\n \n-    impl ast_fold for ToZzIdentFolder {\n+    impl Folder for ToZzIdentFolder {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }"}, {"sha": "0fd4c5c193c2a9b0d915fb142a0222300a9a80c2", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -28,6 +28,8 @@ This API is completely unstable and subject to change.\n \n #[feature(macro_rules, globs, managed_boxes)];\n \n+#[deny(non_camel_case_types)];\n+\n extern mod extra;\n \n pub mod util {"}, {"sha": "e7630a668558d4c3ea190176938070ddbf837b54", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -16,7 +16,7 @@ use parse::parser::Parser;\n use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n-pub trait parser_attr {\n+pub trait ParserAttr {\n     fn parse_outer_attributes(&mut self) -> ~[ast::Attribute];\n     fn parse_attribute(&mut self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&mut self)\n@@ -26,15 +26,15 @@ pub trait parser_attr {\n     fn parse_optional_meta(&mut self) -> ~[@ast::MetaItem];\n }\n \n-impl parser_attr for Parser {\n+impl ParserAttr for Parser {\n     // Parse attributes that appear before an item\n     fn parse_outer_attributes(&mut self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match self.token {\n-              token::INTERPOLATED(token::nt_attr(..)) => {\n+              token::INTERPOLATED(token::NtAttr(..)) => {\n                 attrs.push(self.parse_attribute(false));\n               }\n               token::POUND => {\n@@ -69,7 +69,7 @@ impl parser_attr for Parser {\n         debug!(\"parse_attributes: permit_inner={:?} self.token={:?}\",\n                permit_inner, self.token);\n         let (span, value) = match self.token {\n-            INTERPOLATED(token::nt_attr(attr)) => {\n+            INTERPOLATED(token::NtAttr(attr)) => {\n                 assert!(attr.node.style == ast::AttrOuter);\n                 self.bump();\n                 (attr.span, attr.node.value)\n@@ -121,7 +121,7 @@ impl parser_attr for Parser {\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n             let attr = match self.token {\n-                token::INTERPOLATED(token::nt_attr(..)) => {\n+                token::INTERPOLATED(token::NtAttr(..)) => {\n                     self.parse_attribute(true)\n                 }\n                 token::POUND => {\n@@ -165,7 +165,7 @@ impl parser_attr for Parser {\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n-                    ast::lit_str(..) => (),\n+                    ast::LitStr(..) => {}\n                     _ => {\n                         self.span_err(\n                             lit.span,"}, {"sha": "86ab2e099d0c29b6f6cd3dd1a48c83124e08d3a1", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos};\n use diagnostic;\n-use parse::lexer::{is_whitespace, with_str_from, reader};\n+use parse::lexer::{is_whitespace, with_str_from, Reader};\n use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n@@ -23,16 +23,16 @@ use std::str;\n use std::uint;\n \n #[deriving(Clone, Eq)]\n-pub enum cmnt_style {\n-    isolated, // No code on either side of each line of the comment\n-    trailing, // Code exists to the left of the comment\n-    mixed, // Code before /* foo */ and after the comment\n-    blank_line, // Just a manual blank line \"\\n\\n\", for layout\n+pub enum CommentStyle {\n+    Isolated, // No code on either side of each line of the comment\n+    Trailing, // Code exists to the left of the comment\n+    Mixed, // Code before /* foo */ and after the comment\n+    BlankLine, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n #[deriving(Clone)]\n-pub struct cmnt {\n-    style: cmnt_style,\n+pub struct Comment {\n+    style: CommentStyle,\n     lines: ~[~str],\n     pos: BytePos\n }\n@@ -159,18 +159,18 @@ fn consume_non_eol_whitespace(rdr: @StringReader) {\n     }\n }\n \n-fn push_blank_line_comment(rdr: @StringReader, comments: &mut ~[cmnt]) {\n+fn push_blank_line_comment(rdr: @StringReader, comments: &mut ~[Comment]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n-    comments.push(cmnt {\n-        style: blank_line,\n+    comments.push(Comment {\n+        style: BlankLine,\n         lines: v,\n         pos: rdr.last_pos.get(),\n     });\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: @StringReader,\n-                                           comments: &mut ~[cmnt]) {\n+                                           comments: &mut ~[Comment]) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n         if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n             push_blank_line_comment(rdr, &mut *comments);\n@@ -181,19 +181,19 @@ fn consume_whitespace_counting_blank_lines(rdr: @StringReader,\n \n \n fn read_shebang_comment(rdr: @StringReader, code_to_the_left: bool,\n-                                            comments: &mut ~[cmnt]) {\n+                                            comments: &mut ~[Comment]) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos.get();\n     debug!(\"<<< shebang comment\");\n-    comments.push(cmnt {\n-        style: if code_to_the_left { trailing } else { isolated },\n+    comments.push(Comment {\n+        style: if code_to_the_left { Trailing } else { Isolated },\n         lines: ~[read_one_line_comment(rdr)],\n         pos: p\n     });\n }\n \n fn read_line_comments(rdr: @StringReader, code_to_the_left: bool,\n-                                          comments: &mut ~[cmnt]) {\n+                                          comments: &mut ~[Comment]) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n@@ -208,8 +208,8 @@ fn read_line_comments(rdr: @StringReader, code_to_the_left: bool,\n     }\n     debug!(\"<<< line comments\");\n     if !lines.is_empty() {\n-        comments.push(cmnt {\n-            style: if code_to_the_left { trailing } else { isolated },\n+        comments.push(Comment {\n+            style: if code_to_the_left { Trailing } else { Isolated },\n             lines: lines,\n             pos: p\n         });\n@@ -251,7 +251,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n \n fn read_block_comment(rdr: @StringReader,\n                       code_to_the_left: bool,\n-                      comments: &mut ~[cmnt]) {\n+                      comments: &mut ~[Comment]) {\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos.get();\n     let mut lines: ~[~str] = ~[];\n@@ -280,7 +280,7 @@ fn read_block_comment(rdr: @StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n-                (rdr as @reader).fatal(~\"unterminated block comment\");\n+                (rdr as @Reader).fatal(~\"unterminated block comment\");\n             }\n             if rdr.curr.get() == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n@@ -309,13 +309,13 @@ fn read_block_comment(rdr: @StringReader,\n         }\n     }\n \n-    let mut style = if code_to_the_left { trailing } else { isolated };\n+    let mut style = if code_to_the_left { Trailing } else { Isolated };\n     consume_non_eol_whitespace(rdr);\n     if !is_eof(rdr) && rdr.curr.get() != '\\n' && lines.len() == 1u {\n-        style = mixed;\n+        style = Mixed;\n     }\n     debug!(\"<<< block comment\");\n-    comments.push(cmnt {style: style, lines: lines, pos: p});\n+    comments.push(Comment {style: style, lines: lines, pos: p});\n }\n \n fn peeking_at_comment(rdr: @StringReader) -> bool {\n@@ -326,7 +326,7 @@ fn peeking_at_comment(rdr: @StringReader) -> bool {\n \n fn consume_comment(rdr: @StringReader,\n                    code_to_the_left: bool,\n-                   comments: &mut ~[cmnt]) {\n+                   comments: &mut ~[Comment]) {\n     debug!(\">>> consume comment\");\n     if rdr.curr.get() == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n@@ -339,7 +339,7 @@ fn consume_comment(rdr: @StringReader,\n }\n \n #[deriving(Clone)]\n-pub struct lit {\n+pub struct Literal {\n     lit: ~str,\n     pos: BytePos\n }\n@@ -350,14 +350,14 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                         @diagnostic::SpanHandler,\n                                     path: @str,\n                                     srdr: &mut io::Reader)\n-                                 -> (~[cmnt], ~[lit]) {\n+                                 -> (~[Comment], ~[Literal]) {\n     let src = str::from_utf8_owned(srdr.read_to_end()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);\n \n-    let mut comments: ~[cmnt] = ~[];\n-    let mut literals: ~[lit] = ~[];\n+    let mut comments: ~[Comment] = ~[];\n+    let mut literals: ~[Literal] = ~[];\n     let mut first_read: bool = true;\n     while !is_eof(rdr) {\n         loop {\n@@ -382,7 +382,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         if token::is_lit(&tok) {\n             with_str_from(rdr, bstart, |s| {\n                 debug!(\"tok lit: {}\", s);\n-                literals.push(lit {lit: s.to_owned(), pos: sp.lo});\n+                literals.push(Literal {lit: s.to_owned(), pos: sp.lo});\n             })\n         } else {\n             debug!(\"tok: {}\", token::to_str(get_ident_interner(), &tok));"}, {"sha": "9304b8422944876eab33c2c8ac2fd38451d32980", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -25,13 +25,13 @@ use std::util;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n-pub trait reader {\n+pub trait Reader {\n     fn is_eof(@self) -> bool;\n     fn next_token(@self) -> TokenAndSpan;\n     fn fatal(@self, ~str) -> !;\n     fn span_diag(@self) -> @SpanHandler;\n     fn peek(@self) -> TokenAndSpan;\n-    fn dup(@self) -> @reader;\n+    fn dup(@self) -> @Reader;\n }\n \n #[deriving(Clone, Eq)]\n@@ -104,7 +104,7 @@ fn dup_string_reader(r: @StringReader) -> @StringReader {\n     }\n }\n \n-impl reader for StringReader {\n+impl Reader for StringReader {\n     fn is_eof(@self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(@self) -> TokenAndSpan {\n@@ -129,10 +129,10 @@ impl reader for StringReader {\n             sp: self.peek_span.get(),\n         }\n     }\n-    fn dup(@self) -> @reader { dup_string_reader(self) as @reader }\n+    fn dup(@self) -> @Reader { dup_string_reader(self) as @Reader }\n }\n \n-impl reader for TtReader {\n+impl Reader for TtReader {\n     fn is_eof(@self) -> bool {\n         let cur_tok = self.cur_tok.borrow();\n         *cur_tok.get() == token::EOF\n@@ -152,7 +152,7 @@ impl reader for TtReader {\n             sp: self.cur_span.get(),\n         }\n     }\n-    fn dup(@self) -> @reader { dup_tt_reader(self) as @reader }\n+    fn dup(@self) -> @Reader { dup_tt_reader(self) as @Reader }\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`)\n@@ -486,35 +486,35 @@ fn scan_number(c: char, rdr: @StringReader) -> token::Token {\n     c = rdr.curr.get();\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n-        enum Result { Signed(ast::int_ty), Unsigned(ast::uint_ty) }\n+        enum Result { Signed(ast::IntTy), Unsigned(ast::UintTy) }\n         let signed = c == 'i';\n         let mut tp = {\n-            if signed { Signed(ast::ty_i) }\n-            else { Unsigned(ast::ty_u) }\n+            if signed { Signed(ast::TyI) }\n+            else { Unsigned(ast::TyU) }\n         };\n         bump(rdr);\n         c = rdr.curr.get();\n         if c == '8' {\n             bump(rdr);\n-            tp = if signed { Signed(ast::ty_i8) }\n-                      else { Unsigned(ast::ty_u8) };\n+            tp = if signed { Signed(ast::TyI8) }\n+                      else { Unsigned(ast::TyU8) };\n         }\n         n = nextch(rdr);\n         if c == '1' && n == '6' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { Signed(ast::ty_i16) }\n-                      else { Unsigned(ast::ty_u16) };\n+            tp = if signed { Signed(ast::TyI16) }\n+                      else { Unsigned(ast::TyU16) };\n         } else if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { Signed(ast::ty_i32) }\n-                      else { Unsigned(ast::ty_u32) };\n+            tp = if signed { Signed(ast::TyI32) }\n+                      else { Unsigned(ast::TyU32) };\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            tp = if signed { Signed(ast::ty_i64) }\n-                      else { Unsigned(ast::ty_u64) };\n+            tp = if signed { Signed(ast::TyI64) }\n+                      else { Unsigned(ast::TyU64) };\n         }\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos.get(),\n@@ -566,13 +566,11 @@ fn scan_number(c: char, rdr: @StringReader) -> token::Token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(str_to_ident(num_str),\n-                                 ast::ty_f32);\n+            return token::LIT_FLOAT(str_to_ident(num_str), ast::TyF32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(str_to_ident(num_str),\n-                                 ast::ty_f64);\n+            return token::LIT_FLOAT(str_to_ident(num_str), ast::TyF64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n             back-end.  */\n@@ -665,7 +663,7 @@ fn next_token_inner(rdr: @StringReader) -> token::Token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: @StringReader, op: token::binop) -> token::Token {\n+    fn binop(rdr: @StringReader, op: token::BinOp) -> token::Token {\n         bump(rdr);\n         if rdr.curr.get() == '=' {\n             bump(rdr);"}, {"sha": "ea069c2ffe37d61ca804475acbd7fb0beae04cd6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 46, "deletions": 47, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -15,8 +15,7 @@ use ast;\n use codemap::{Span, CodeMap, FileMap, FileSubstr};\n use codemap;\n use diagnostic::{SpanHandler, mk_span_handler, mk_handler, Emitter};\n-use parse::attr::parser_attr;\n-use parse::lexer::reader;\n+use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n use std::cell::RefCell;\n@@ -133,7 +132,7 @@ pub fn parse_item_from_source_str(\n     cfg: ast::CrateConfig,\n     attrs: ~[ast::Attribute],\n     sess: @ParseSess\n-) -> Option<@ast::item> {\n+) -> Option<@ast::Item> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n     maybe_aborted(p.parse_item(attrs),p)\n }\n@@ -169,7 +168,7 @@ pub fn parse_tts_from_source_str(\n     source: @str,\n     cfg: ast::CrateConfig,\n     sess: @ParseSess\n-) -> ~[ast::token_tree] {\n+) -> ~[ast::TokenTree] {\n     let mut p = new_parser_from_source_str(\n         sess,\n         cfg,\n@@ -255,7 +254,7 @@ pub fn filemap_to_parser(sess: @ParseSess,\n // compiler expands into it\n pub fn new_parser_from_tts(sess: @ParseSess,\n                      cfg: ast::CrateConfig,\n-                     tts: ~[ast::token_tree]) -> Parser {\n+                     tts: ~[ast::TokenTree]) -> Parser {\n     tts_to_parser(sess,tts,cfg)\n }\n \n@@ -307,21 +306,21 @@ pub fn substring_to_filemap(sess: @ParseSess, source: @str, path: @str,\n \n // given a filemap, produce a sequence of token-trees\n pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n-    -> ~[ast::token_tree] {\n+    -> ~[ast::TokenTree] {\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let mut p1 = Parser(sess, cfg, srdr as @reader);\n+    let mut p1 = Parser(sess, cfg, srdr as @lexer::Reader);\n     p1.parse_all_token_trees()\n }\n \n // given tts and cfg, produce a parser\n pub fn tts_to_parser(sess: @ParseSess,\n-                     tts: ~[ast::token_tree],\n+                     tts: ~[ast::TokenTree],\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, trdr as @reader)\n+    Parser(sess, cfg, trdr as @lexer::Reader)\n }\n \n // abort if necessary\n@@ -415,26 +414,26 @@ mod test {\n     #[test] fn string_to_tts_macro () {\n         let tts = string_to_tts(@\"macro_rules! zip (($a)=>($a))\");\n         match tts {\n-            [ast::tt_tok(_,_),\n-             ast::tt_tok(_,token::NOT),\n-             ast::tt_tok(_,_),\n-             ast::tt_delim(delim_elts)] =>\n+            [ast::TTTok(_,_),\n+             ast::TTTok(_,token::NOT),\n+             ast::TTTok(_,_),\n+             ast::TTDelim(delim_elts)] =>\n                 match *delim_elts {\n-                [ast::tt_tok(_,token::LPAREN),\n-                 ast::tt_delim(first_set),\n-                 ast::tt_tok(_,token::FAT_ARROW),\n-                 ast::tt_delim(second_set),\n-                 ast::tt_tok(_,token::RPAREN)] =>\n+                [ast::TTTok(_,token::LPAREN),\n+                 ast::TTDelim(first_set),\n+                 ast::TTTok(_,token::FAT_ARROW),\n+                 ast::TTDelim(second_set),\n+                 ast::TTTok(_,token::RPAREN)] =>\n                     match *first_set {\n-                    [ast::tt_tok(_,token::LPAREN),\n-                     ast::tt_tok(_,token::DOLLAR),\n-                     ast::tt_tok(_,_),\n-                     ast::tt_tok(_,token::RPAREN)] =>\n+                    [ast::TTTok(_,token::LPAREN),\n+                     ast::TTTok(_,token::DOLLAR),\n+                     ast::TTTok(_,_),\n+                     ast::TTTok(_,token::RPAREN)] =>\n                         match *second_set {\n-                        [ast::tt_tok(_,token::LPAREN),\n-                         ast::tt_tok(_,token::DOLLAR),\n-                         ast::tt_tok(_,_),\n-                         ast::tt_tok(_,token::RPAREN)] =>\n+                        [ast::TTTok(_,token::LPAREN),\n+                         ast::TTTok(_,token::DOLLAR),\n+                         ast::TTTok(_,_),\n+                         ast::TTTok(_,token::RPAREN)] =>\n                             assert_eq!(\"correct\",\"correct\"),\n                         _ => assert_eq!(\"wrong 4\",\"correct\")\n                     },\n@@ -461,7 +460,7 @@ mod test {\n         assert_eq!(to_json_str(@tts),\n         ~\"[\\\n     {\\\n-        \\\"variant\\\":\\\"tt_tok\\\",\\\n+        \\\"variant\\\":\\\"TTTok\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n             {\\\n@@ -474,7 +473,7 @@ mod test {\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"tt_tok\\\",\\\n+        \\\"variant\\\":\\\"TTTok\\\",\\\n         \\\"fields\\\":[\\\n             null,\\\n             {\\\n@@ -487,18 +486,18 @@ mod test {\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"tt_delim\\\",\\\n+        \\\"variant\\\":\\\"TTDelim\\\",\\\n         \\\"fields\\\":[\\\n             [\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"LPAREN\\\"\\\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         {\\\n@@ -511,14 +510,14 @@ mod test {\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"COLON\\\"\\\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         {\\\n@@ -531,7 +530,7 @@ mod test {\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"RPAREN\\\"\\\n@@ -541,18 +540,18 @@ mod test {\n         ]\\\n     },\\\n     {\\\n-        \\\"variant\\\":\\\"tt_delim\\\",\\\n+        \\\"variant\\\":\\\"TTDelim\\\",\\\n         \\\"fields\\\":[\\\n             [\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"LBRACE\\\"\\\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         {\\\n@@ -565,14 +564,14 @@ mod test {\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"SEMI\\\"\\\n                     ]\\\n                 },\\\n                 {\\\n-                    \\\"variant\\\":\\\"tt_tok\\\",\\\n+                    \\\"variant\\\":\\\"TTTok\\\",\\\n                     \\\"fields\\\":[\\\n                         null,\\\n                         \\\"RBRACE\\\"\\\n@@ -661,13 +660,13 @@ mod test {\n         // this test depends on the intern order of \"fn\" and \"int\"\n         assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:str_to_ident(\"a\"),\n+                      @ast::Item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n                             id: ast::DUMMY_NODE_ID,\n-                            node: ast::item_fn(ast::P(ast::fn_decl{\n-                                inputs: ~[ast::arg{\n+                            node: ast::ItemFn(ast::P(ast::FnDecl {\n+                                inputs: ~[ast::Arg{\n                                     ty: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                       node: ast::ty_path(ast::Path{\n+                                                       node: ast::TyPath(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n                                         segments: ~[\n@@ -704,12 +703,12 @@ mod test {\n                                     id: ast::DUMMY_NODE_ID\n                                 }],\n                                 output: ast::P(ast::Ty{id: ast::DUMMY_NODE_ID,\n-                                                       node: ast::ty_nil,\n+                                                       node: ast::TyNil,\n                                                        span:sp(15,15)}), // not sure\n-                                cf: ast::return_val,\n+                                cf: ast::Return,\n                                 variadic: false\n                             }),\n-                                    ast::impure_fn,\n+                                    ast::ImpureFn,\n                                     abi::AbiSet::Rust(),\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: opt_vec::Empty,\n@@ -744,7 +743,7 @@ mod test {\n                                         rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n                                     })),\n-                            vis: ast::inherited,\n+                            vis: ast::Inherited,\n                             span: sp(0,21)}));\n     }\n "}, {"sha": "dba4f62aa9c7e6a5858f80114c648c34330a046b", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -17,7 +17,7 @@ Obsolete syntax that becomes too hard to parse can be\n removed.\n */\n \n-use ast::{Expr, ExprLit, lit_nil};\n+use ast::{Expr, ExprLit, LitNil};\n use codemap::{Span, respan};\n use parse::parser::Parser;\n use parse::token;\n@@ -158,7 +158,7 @@ impl ParserObsoleteMethods for Parser {\n     // a placeholder expression\n     fn obsolete_expr(&mut self, sp: Span, kind: ObsoleteSyntax) -> @Expr {\n         self.obsolete(sp, kind);\n-        self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, lit_nil)))\n+        self.mk_expr(sp.lo, sp.hi, ExprLit(@respan(sp, LitNil)))\n     }\n \n     fn report(&mut self,"}, {"sha": "149b7c1cf18acee76be298d09a86041e9ce6fecd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 381, "deletions": 387, "changes": 768, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -14,14 +14,14 @@ use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{CallSugar, NoSugar, DoSugar};\n-use ast::{TyBareFn, TyClosure};\n+use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n-use ast::{provided, public, purity};\n-use ast::{_mod, BiAdd, arg, Arm, Attribute, BindByRef, BindByValue};\n+use ast::{Provided, Public, Purity};\n+use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n-use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, enum_def, explicit_self};\n+use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock};\n use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n@@ -30,45 +30,45 @@ use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc, ExprRepeat};\n use ast::{ExprRet, ExprSelf, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprVstore, ExprVstoreSlice, ExprVstoreBox};\n-use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, extern_fn, Field, fn_decl};\n+use ast::{ExprVstoreMutSlice, ExprWhile, ExprForLoop, ExternFn, Field, FnDecl};\n use ast::{ExprVstoreUniq, Onceness, Once, Many};\n-use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n-use ast::{Ident, impure_fn, inherited, item, item_, item_static};\n-use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n-use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n-use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int, lit_char};\n-use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n-use ast::{MutImmutable, MutMutable, mac_, mac_invoc_tt, matcher, match_nonterminal};\n-use ast::{match_seq, match_tok, method, mt, BiMul, Mutability};\n-use ast::{named_field, UnNeg, noreturn, UnNot, P, Pat, PatBox, PatEnum};\n+use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n+use ast::{Ident, ImpureFn, Inherited, Item, Item_, ItemStatic};\n+use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n+use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n+use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar};\n+use ast::{LitIntUnsuffixed, LitNil, LitStr, LitUint, Local};\n+use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n+use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n+use ast::{NamedField, UnNeg, NoReturn, UnNot, P, Pat, PatBox, PatEnum};\n use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n-use ast::{PatTup, PatUniq, PatWild, PatWildMulti, private};\n-use ast::{BiRem, required};\n-use ast::{ret_style, return_val, BiShl, BiShr, Stmt, StmtDecl};\n-use ast::{StmtExpr, StmtSemi, StmtMac, struct_def, struct_field};\n-use ast::{struct_variant_kind, BiSub};\n+use ast::{PatTup, PatUniq, PatWild, PatWildMulti, Private};\n+use ast::{BiRem, Required};\n+use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n+use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n-use ast::{sty_box, sty_region, sty_static, sty_uniq, sty_value};\n-use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n-use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n-use ast::{TypeField, ty_fixed_length_vec, ty_closure, ty_bare_fn, ty_typeof};\n-use ast::{ty_infer, TypeMethod};\n-use ast::{ty_nil, TyParam, TyParamBound, ty_path, ty_ptr, ty_rptr};\n-use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, UnUniq};\n-use ast::{unnamed_field, UnsafeBlock, unsafe_fn, view_item};\n-use ast::{view_item_, view_item_extern_mod, view_item_use};\n-use ast::{view_path, view_path_glob, view_path_list, view_path_simple};\n-use ast::visibility;\n+use ast::{SelfBox, SelfRegion, SelfStatic, SelfUniq, SelfValue};\n+use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n+use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n+use ast::{TypeField, TyFixedLengthVec, TyClosure, TyBareFn, TyTypeof};\n+use ast::{TyInfer, TypeMethod};\n+use ast::{TyNil, TyParam, TyParamBound, TyPath, TyPtr, TyRptr};\n+use ast::{TyTup, TyU32, TyUniq, TyVec, UnUniq};\n+use ast::{UnnamedField, UnsafeBlock, UnsafeFn, ViewItem};\n+use ast::{ViewItem_, ViewItemExternMod, ViewItemUse};\n+use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use ast::Visibility;\n use ast;\n use ast_util::{as_prec, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n-use parse::attr::parser_attr;\n+use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none};\n use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n-use parse::lexer::reader;\n+use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n@@ -85,6 +85,7 @@ use std::hashmap::HashSet;\n use std::util;\n use std::vec;\n \n+#[allow(non_camel_case_types)]\n #[deriving(Eq)]\n enum restriction {\n     UNRESTRICTED,\n@@ -93,7 +94,7 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-type item_info = (Ident, item_, Option<~[Attribute]>);\n+type ItemInfo = (Ident, Item_, Option<~[Attribute]>);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -126,13 +127,13 @@ struct PathAndBounds {\n     bounds: Option<OptVec<TyParamBound>>,\n }\n \n-pub enum item_or_view_item {\n+enum ItemOrViewItem {\n     // Indicates a failure to parse any kind of item. The attributes are\n     // returned.\n-    iovi_none(~[Attribute]),\n-    iovi_item(@item),\n-    iovi_foreign_item(@foreign_item),\n-    iovi_view_item(view_item)\n+    IoviNone(~[Attribute]),\n+    IoviItem(@Item),\n+    IoviForeignItem(@ForeignItem),\n+    IoviViewItem(ViewItem)\n }\n \n /* The expr situation is not as complex as I thought it would be.\n@@ -144,14 +145,14 @@ macro_rules! maybe_whole_expr (\n             // This horrible convolution is brought to you by\n             // @mut, have a terrible day\n             let mut maybe_path = match ($p).token {\n-                INTERPOLATED(token::nt_path(ref pt)) => Some((**pt).clone()),\n+                INTERPOLATED(token::NtPath(ref pt)) => Some((**pt).clone()),\n                 _ => None,\n             };\n             let ret = match ($p).token {\n-                INTERPOLATED(token::nt_expr(e)) => {\n+                INTERPOLATED(token::NtExpr(e)) => {\n                     Some(e)\n                 }\n-                INTERPOLATED(token::nt_path(_)) => {\n+                INTERPOLATED(token::NtPath(_)) => {\n                     let pt = maybe_path.take_unwrap();\n                     Some($p.mk_expr(($p).span.lo, ($p).span.hi, ExprPath(pt)))\n                 }\n@@ -243,7 +244,7 @@ macro_rules! maybe_whole (\n             };\n             match __found__ {\n                 Some(INTERPOLATED(token::$constructor(x))) => {\n-                    return iovi_item(x.clone())\n+                    return IoviItem(x.clone())\n                 }\n                 _ => {}\n             }\n@@ -279,14 +280,14 @@ fn maybe_append(lhs: ~[Attribute], rhs: Option<~[Attribute]>)\n \n struct ParsedItemsAndViewItems {\n     attrs_remaining: ~[Attribute],\n-    view_items: ~[view_item],\n-    items: ~[@item],\n-    foreign_items: ~[@foreign_item]\n+    view_items: ~[ViewItem],\n+    items: ~[@Item],\n+    foreign_items: ~[@ForeignItem]\n }\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: @reader)\n+pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: @Reader)\n               -> Parser {\n     let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n@@ -340,8 +341,8 @@ pub struct Parser {\n     tokens_consumed: uint,\n     restriction: restriction,\n     quote_depth: uint, // not (yet) related to the quasiquoter\n-    reader: @reader,\n-    interner: @token::ident_interner,\n+    reader: @Reader,\n+    interner: @token::IdentInterner,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n     obsolete_set: HashSet<ObsoleteSyntax>,\n@@ -486,7 +487,7 @@ impl Parser {\n                 self.bump();\n                 i\n             }\n-            token::INTERPOLATED(token::nt_ident(..)) => {\n+            token::INTERPOLATED(token::NtIdent(..)) => {\n                 self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n@@ -496,12 +497,12 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_path_list_ident(&mut self) -> ast::path_list_ident {\n+    pub fn parse_path_list_ident(&mut self) -> ast::PathListIdent {\n         let lo = self.span.lo;\n         let ident = self.parse_ident();\n         let hi = self.last_span.hi;\n-        spanned(lo, hi, ast::path_list_ident_ { name: ident,\n-                                                id: ast::DUMMY_NODE_ID })\n+        spanned(lo, hi, ast::PathListIdent_ { name: ident,\n+                                              id: ast::DUMMY_NODE_ID })\n     }\n \n     // consume token 'tok' if it exists. Returns true if the given\n@@ -850,8 +851,8 @@ impl Parser {\n         }\n     }\n \n-    // parse a ty_bare_fun type:\n-    pub fn parse_ty_bare_fn(&mut self) -> ty_ {\n+    // parse a TyBareFn type:\n+    pub fn parse_ty_bare_fn(&mut self) -> Ty_ {\n         /*\n \n         [extern \"ABI\"] [unsafe] fn <'lt> (S) -> T\n@@ -871,7 +872,7 @@ impl Parser {\n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n-        return ty_bare_fn(@TyBareFn {\n+        return TyBareFn(@BareFnTy {\n             abis: abis,\n             purity: purity,\n             lifetimes: lifetimes,\n@@ -881,24 +882,24 @@ impl Parser {\n \n     // Parses a procedure type (`proc`). The initial `proc` keyword must\n     // already have been parsed.\n-    pub fn parse_proc_type(&mut self) -> ty_ {\n+    pub fn parse_proc_type(&mut self) -> Ty_ {\n         let (decl, lifetimes) = self.parse_ty_fn_decl(false);\n-        ty_closure(@TyClosure {\n+        TyClosure(@ClosureTy {\n             sigil: OwnedSigil,\n             region: None,\n-            purity: impure_fn,\n+            purity: ImpureFn,\n             onceness: Once,\n             bounds: None,\n             decl: decl,\n             lifetimes: lifetimes,\n         })\n     }\n \n-    // parse a ty_closure type\n+    // parse a TyClosure type\n     pub fn parse_ty_closure(&mut self,\n                             opt_sigil: Option<ast::Sigil>,\n                             mut region: Option<ast::Lifetime>)\n-                            -> ty_ {\n+                            -> Ty_ {\n         /*\n \n         (&|~|@) ['r] [unsafe] [once] fn [:Bounds] <'lt> (S) -> T\n@@ -963,7 +964,7 @@ impl Parser {\n                 let bounds = self.parse_optional_ty_param_bounds();\n \n                 let (return_style, output) = self.parse_ret_ty();\n-                let decl = P(ast::fn_decl {\n+                let decl = P(FnDecl {\n                     inputs: inputs,\n                     output: output,\n                     cf: return_style,\n@@ -974,7 +975,7 @@ impl Parser {\n             }\n         };\n \n-        return ty_closure(@TyClosure {\n+        return TyClosure(@ClosureTy {\n             sigil: sigil,\n             region: region,\n             purity: purity,\n@@ -993,17 +994,17 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_unsafety(&mut self) -> purity {\n+    pub fn parse_unsafety(&mut self) -> Purity {\n         if self.eat_keyword(keywords::Unsafe) {\n-            return unsafe_fn;\n+            return UnsafeFn;\n         } else {\n-            return impure_fn;\n+            return ImpureFn;\n         }\n     }\n \n     // parse a function type (following the 'fn')\n     pub fn parse_ty_fn_decl(&mut self, allow_variadic: bool)\n-                            -> (P<fn_decl>, OptVec<ast::Lifetime>) {\n+                            -> (P<FnDecl>, OptVec<ast::Lifetime>) {\n         /*\n \n         (fn) <'lt> (S) -> T\n@@ -1024,7 +1025,7 @@ impl Parser {\n \n         let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n-        let decl = P(ast::fn_decl {\n+        let decl = P(FnDecl {\n             inputs: inputs,\n             output: ret_ty,\n             cf: ret_style,\n@@ -1034,7 +1035,7 @@ impl Parser {\n     }\n \n     // parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&mut self) -> ~[trait_method] {\n+    pub fn parse_trait_methods(&mut self) -> ~[TraitMethod] {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n@@ -1065,10 +1066,10 @@ impl Parser {\n                 debug!(\"parse_trait_methods(): parsing required method\");\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n-                if vis != ast::inherited {\n+                if vis != ast::Inherited {\n                     p.obsolete(vis_span, ObsoleteTraitFuncVisibility);\n                 }\n-                required(TypeMethod {\n+                Required(TypeMethod {\n                     ident: ident,\n                     attrs: attrs,\n                     purity: pur,\n@@ -1084,7 +1085,7 @@ impl Parser {\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block();\n                 let attrs = vec::append(attrs, inner_attrs);\n-                provided(@ast::method {\n+                Provided(@ast::Method {\n                     ident: ident,\n                     attrs: attrs,\n                     generics: generics,\n@@ -1109,10 +1110,10 @@ impl Parser {\n     }\n \n     // parse a possibly mutable type\n-    pub fn parse_mt(&mut self) -> mt {\n+    pub fn parse_mt(&mut self) -> MutTy {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n-        mt { ty: t, mutbl: mutbl }\n+        MutTy { ty: t, mutbl: mutbl }\n     }\n \n     // parse [mut/const/imm] ID : TY\n@@ -1126,34 +1127,34 @@ impl Parser {\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n-            mt: ast::mt { ty: ty, mutbl: mutbl },\n+            mt: MutTy { ty: ty, mutbl: mutbl },\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&mut self) -> (ret_style, P<Ty>) {\n+    pub fn parse_ret_ty(&mut self) -> (RetStyle, P<Ty>) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n                 (\n-                    noreturn,\n+                    NoReturn,\n                     P(Ty {\n                         id: ast::DUMMY_NODE_ID,\n-                        node: ty_bot,\n+                        node: TyBot,\n                         span: mk_sp(lo, self.last_span.hi)\n                     })\n                 )\n             } else {\n-                (return_val, self.parse_ty(false))\n+                (Return, self.parse_ty(false))\n             }\n         } else {\n             let pos = self.span.lo;\n             (\n-                return_val,\n+                Return,\n                 P(Ty {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: ty_nil,\n+                    node: TyNil,\n                     span: mk_sp(pos, pos),\n                 })\n             )\n@@ -1164,15 +1165,15 @@ impl Parser {\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n     pub fn parse_ty(&mut self, _: bool) -> P<Ty> {\n-        maybe_whole!(no_clone self, nt_ty);\n+        maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n \n         let t = if self.token == token::LPAREN {\n             self.bump();\n             if self.token == token::RPAREN {\n                 self.bump();\n-                ty_nil\n+                TyNil\n             } else {\n                 // (t) is a parenthesized ty\n                 // (t,) is the type of a tuple with only one field,\n@@ -1194,7 +1195,7 @@ impl Parser {\n                     return ts[0]\n                 }\n \n-                let t = ty_tup(ts);\n+                let t = TyTup(ts);\n                 self.expect(&token::RPAREN);\n                 t\n             }\n@@ -1209,7 +1210,7 @@ impl Parser {\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n-            ty_ptr(self.parse_mt())\n+            TyPtr(self.parse_mt())\n         } else if self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n@@ -1218,8 +1219,8 @@ impl Parser {\n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n             let t = match self.maybe_parse_fixed_vstore() {\n-                None => ty_vec(t),\n-                Some(suffix) => ty_fixed_length_vec(t, suffix)\n+                None => TyVec(t),\n+                Some(suffix) => TyFixedLengthVec(t, suffix)\n             };\n             self.expect(&token::RBRACKET);\n             t\n@@ -1251,7 +1252,7 @@ impl Parser {\n             self.expect(&token::LPAREN);\n             let e = self.parse_expr();\n             self.expect(&token::RPAREN);\n-            ty_typeof(e)\n+            TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type()\n         } else if self.token == token::MOD_SEP\n@@ -1261,7 +1262,7 @@ impl Parser {\n                 path,\n                 bounds\n             } = self.parse_path(LifetimeAndTypesAndBounds);\n-            ty_path(path, bounds, ast::DUMMY_NODE_ID)\n+            TyPath(path, bounds, ast::DUMMY_NODE_ID)\n         } else {\n             let msg = format!(\"expected type, found token {:?}\", self.token);\n             self.fatal(msg);\n@@ -1274,7 +1275,7 @@ impl Parser {\n     // parse the type following a @ or a ~\n     pub fn parse_box_or_uniq_pointee(&mut self,\n                                      sigil: ast::Sigil)\n-                                     -> ty_ {\n+                                     -> Ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n         match self.token {\n             token::LIFETIME(..) => {\n@@ -1297,13 +1298,13 @@ impl Parser {\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         if sigil == OwnedSigil {\n-            ty_uniq(self.parse_ty(false))\n+            TyUniq(self.parse_ty(false))\n         } else {\n-            ty_box(self.parse_ty(false))\n+            TyBox(self.parse_ty(false))\n         }\n     }\n \n-    pub fn parse_borrowed_pointee(&mut self) -> ty_ {\n+    pub fn parse_borrowed_pointee(&mut self) -> Ty_ {\n         // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n         let opt_lifetime = self.parse_opt_lifetime();\n \n@@ -1313,7 +1314,7 @@ impl Parser {\n         }\n \n         let mt = self.parse_mt();\n-        return ty_rptr(opt_lifetime, mt);\n+        return TyRptr(opt_lifetime, mt);\n     }\n \n     pub fn is_named_argument(&mut self) -> bool {\n@@ -1337,7 +1338,7 @@ impl Parser {\n \n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n-    pub fn parse_arg_general(&mut self, require_name: bool) -> arg {\n+    pub fn parse_arg_general(&mut self, require_name: bool) -> Arg {\n         let pat = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n@@ -1354,31 +1355,31 @@ impl Parser {\n \n         let t = self.parse_ty(false);\n \n-        ast::arg {\n+        Arg {\n             ty: t,\n             pat: pat,\n             id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n     // parse a single function argument\n-    pub fn parse_arg(&mut self) -> arg {\n+    pub fn parse_arg(&mut self) -> Arg {\n         self.parse_arg_general(true)\n     }\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n-    pub fn parse_fn_block_arg(&mut self) -> arg {\n+    pub fn parse_fn_block_arg(&mut self) -> Arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ty_infer,\n+                node: TyInfer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n             })\n         };\n-        ast::arg {\n+        Arg {\n             ty: t,\n             pat: pat,\n             id: ast::DUMMY_NODE_ID\n@@ -1397,29 +1398,29 @@ impl Parser {\n     }\n \n     // matches token_lit = LIT_INT | ...\n-    pub fn lit_from_token(&mut self, tok: &token::Token) -> lit_ {\n+    pub fn lit_from_token(&mut self, tok: &token::Token) -> Lit_ {\n         match *tok {\n-            token::LIT_CHAR(i) => lit_char(i),\n-            token::LIT_INT(i, it) => lit_int(i, it),\n-            token::LIT_UINT(u, ut) => lit_uint(u, ut),\n-            token::LIT_INT_UNSUFFIXED(i) => lit_int_unsuffixed(i),\n-            token::LIT_FLOAT(s, ft) => lit_float(self.id_to_str(s), ft),\n+            token::LIT_CHAR(i) => LitChar(i),\n+            token::LIT_INT(i, it) => LitInt(i, it),\n+            token::LIT_UINT(u, ut) => LitUint(u, ut),\n+            token::LIT_INT_UNSUFFIXED(i) => LitIntUnsuffixed(i),\n+            token::LIT_FLOAT(s, ft) => LitFloat(self.id_to_str(s), ft),\n             token::LIT_FLOAT_UNSUFFIXED(s) =>\n-                lit_float_unsuffixed(self.id_to_str(s)),\n-            token::LIT_STR(s) => lit_str(self.id_to_str(s), ast::CookedStr),\n-            token::LIT_STR_RAW(s, n) => lit_str(self.id_to_str(s), ast::RawStr(n)),\n-            token::LPAREN => { self.expect(&token::RPAREN); lit_nil },\n+                LitFloatUnsuffixed(self.id_to_str(s)),\n+            token::LIT_STR(s) => LitStr(self.id_to_str(s), ast::CookedStr),\n+            token::LIT_STR_RAW(s, n) => LitStr(self.id_to_str(s), ast::RawStr(n)),\n+            token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }\n     }\n \n     // matches lit = true | false | token_lit\n-    pub fn parse_lit(&mut self) -> lit {\n+    pub fn parse_lit(&mut self) -> Lit {\n         let lo = self.span.lo;\n         let lit = if self.eat_keyword(keywords::True) {\n-            lit_bool(true)\n+            LitBool(true)\n         } else if self.eat_keyword(keywords::False) {\n-            lit_bool(false)\n+            LitBool(false)\n         } else {\n             let token = self.bump_and_get();\n             let lit = self.lit_from_token(&token);\n@@ -1454,11 +1455,11 @@ impl Parser {\n     pub fn parse_path(&mut self, mode: PathParsingMode) -> PathAndBounds {\n         // Check for a whole path...\n         let found = match self.token {\n-            INTERPOLATED(token::nt_path(_)) => Some(self.bump_and_get()),\n+            INTERPOLATED(token::NtPath(_)) => Some(self.bump_and_get()),\n             _ => None,\n         };\n         match found {\n-            Some(INTERPOLATED(token::nt_path(~path))) => {\n+            Some(INTERPOLATED(token::NtPath(~path))) => {\n                 return PathAndBounds {\n                     path: path,\n                     bounds: None,\n@@ -1709,7 +1710,7 @@ impl Parser {\n         ExprAssignOp(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: mac_) -> @Expr {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> @Expr {\n         @Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n@@ -1720,7 +1721,7 @@ impl Parser {\n     pub fn mk_lit_u32(&mut self, i: u32) -> @Expr {\n         let span = &self.span;\n         let lv_lit = @codemap::Spanned {\n-            node: lit_uint(i as u64, ty_u32),\n+            node: LitUint(i as u64, TyU32),\n             span: *span\n         };\n \n@@ -1750,7 +1751,7 @@ impl Parser {\n             if self.token == token::RPAREN {\n                 hi = self.span.hi;\n                 self.bump();\n-                let lit = @spanned(lo, hi, lit_nil);\n+                let lit = @spanned(lo, hi, LitNil);\n                 return self.mk_expr(lo, hi, ExprLit(lit));\n             }\n             let mut es = ~[self.parse_expr()];\n@@ -1914,7 +1915,7 @@ impl Parser {\n                                                 |p| p.parse_token_tree());\n                 let hi = self.span.hi;\n \n-                return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT));\n+                return self.mk_mac_expr(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT));\n             } else if self.token == token::LBRACE {\n                 // This might be a struct literal.\n                 if self.looking_at_struct_literal() {\n@@ -2073,21 +2074,21 @@ impl Parser {\n     }\n \n     // parse a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> token_tree {\n+    pub fn parse_token_tree(&mut self) -> TokenTree {\n         // FIXME #6994: currently, this is too eager. It\n-        // parses token trees but also identifies tt_seq's\n-        // and tt_nonterminals; it's too early to know yet\n+        // parses token trees but also identifies TTSeq's\n+        // and TTNonterminal's; it's too early to know yet\n         // whether something will be a nonterminal or a seq\n         // yet.\n-        maybe_whole!(deref self, nt_tt);\n+        maybe_whole!(deref self, NtTT);\n \n         // this is the fall-through for the 'match' below.\n         // invariants: the current token is not a left-delimiter,\n         // not an EOF, and not the desired right-delimiter (if\n         // it were, parse_seq_to_before_end would have prevented\n         // reaching this point.\n-        fn parse_non_delim_tt_tok(p: &mut Parser) -> token_tree {\n-            maybe_whole!(deref p, nt_tt);\n+        fn parse_non_delim_tt_tok(p: &mut Parser) -> TokenTree {\n+            maybe_whole!(deref p, NtTT);\n             match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET => {\n                   // This is a conservative error: only report the last unclosed delimiter. The\n@@ -2117,14 +2118,9 @@ impl Parser {\n                     let seq = match seq {\n                         Spanned { node, .. } => node,\n                     };\n-                    tt_seq(\n-                        mk_sp(sp.lo, p.span.hi),\n-                        @seq,\n-                        s,\n-                        z\n-                    )\n+                    TTSeq(mk_sp(sp.lo, p.span.hi), @seq, s, z)\n                 } else {\n-                    tt_nonterminal(sp, p.parse_ident())\n+                    TTNonterminal(sp, p.parse_ident())\n                 }\n               }\n               _ => {\n@@ -2133,9 +2129,9 @@ impl Parser {\n             }\n         }\n \n-        // turn the next token into a tt_tok:\n-        fn parse_any_tt_tok(p: &mut Parser) -> token_tree{\n-            tt_tok(p.span, p.bump_and_get())\n+        // turn the next token into a TTTok:\n+        fn parse_any_tt_tok(p: &mut Parser) -> TokenTree {\n+            TTTok(p.span, p.bump_and_get())\n         }\n \n         match self.token {\n@@ -2165,26 +2161,26 @@ impl Parser {\n                 result.push(parse_any_tt_tok(self));\n                 self.open_braces.pop();\n \n-                tt_delim(@result)\n+                TTDelim(@result)\n             }\n             _ => parse_non_delim_tt_tok(self)\n         }\n     }\n \n-    // parse a stream of tokens into a list of token_trees,\n+    // parse a stream of tokens into a list of TokenTree's,\n     // up to EOF.\n-    pub fn parse_all_token_trees(&mut self) -> ~[token_tree] {\n+    pub fn parse_all_token_trees(&mut self) -> ~[TokenTree] {\n         let mut tts = ~[];\n         while self.token != token::EOF {\n             tts.push(self.parse_token_tree());\n         }\n         tts\n     }\n \n-    pub fn parse_matchers(&mut self) -> ~[matcher] {\n-        // unification of matchers and token_trees would vastly improve\n-        // the interpolation of matchers\n-        maybe_whole!(self, nt_matchers);\n+    pub fn parse_matchers(&mut self) -> ~[Matcher] {\n+        // unification of Matcher's and TokenTree's would vastly improve\n+        // the interpolation of Matcher's\n+        maybe_whole!(self, NtMatchers);\n         let name_idx = @Cell::new(0u);\n         match self.token {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n@@ -2196,13 +2192,13 @@ impl Parser {\n         }\n     }\n \n-    // This goofy function is necessary to correctly match parens in matchers.\n-    // Otherwise, `$( ( )` would be a valid matcher, and `$( () )` would be\n+    // This goofy function is necessary to correctly match parens in Matcher's.\n+    // Otherwise, `$( ( )` would be a valid Matcher, and `$( () )` would be\n     // invalid. It's similar to common::parse_seq.\n     pub fn parse_matcher_subseq_upto(&mut self,\n                                      name_idx: @Cell<uint>,\n                                      ket: &token::Token)\n-                                     -> ~[matcher] {\n+                                     -> ~[Matcher] {\n         let mut ret_val = ~[];\n         let mut lparens = 0u;\n \n@@ -2217,7 +2213,7 @@ impl Parser {\n         return ret_val;\n     }\n \n-    pub fn parse_matcher(&mut self, name_idx: @Cell<uint>) -> matcher {\n+    pub fn parse_matcher(&mut self, name_idx: @Cell<uint>) -> Matcher {\n         let lo = self.span.lo;\n \n         let m = if self.token == token::DOLLAR {\n@@ -2231,17 +2227,17 @@ impl Parser {\n                     self.fatal(\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n-                match_seq(ms, sep, zerok, name_idx_lo, name_idx.get())\n+                MatchSeq(ms, sep, zerok, name_idx_lo, name_idx.get())\n             } else {\n                 let bound_to = self.parse_ident();\n                 self.expect(&token::COLON);\n                 let nt_name = self.parse_ident();\n-                let m = match_nonterminal(bound_to, nt_name, name_idx.get());\n+                let m = MatchNonterminal(bound_to, nt_name, name_idx.get());\n                 name_idx.set(name_idx.get() + 1u);\n                 m\n             }\n         } else {\n-            match_tok(self.bump_and_get())\n+            MatchTok(self.bump_and_get())\n         };\n \n         return spanned(lo, self.span.hi, m);\n@@ -2283,7 +2279,7 @@ impl Parser {\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n                   ExprVec(..) | ExprLit(@codemap::Spanned {\n-                    node: lit_str(..), span: _\n+                    node: LitStr(..), span: _\n                   })\n                   if m == MutImmutable => {\n                     ExprVstore(e, ExprVstoreSlice)\n@@ -2304,7 +2300,7 @@ impl Parser {\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n               ExprVec(..) |\n-              ExprLit(@codemap::Spanned { node: lit_str(..), span: _}) |\n+              ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n               ExprRepeat(..) => ExprVstore(e, ExprVstoreBox),\n               _ => self.mk_unary(UnBox, e)\n             };\n@@ -2317,7 +2313,7 @@ impl Parser {\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n               ExprVec(..) |\n-              ExprLit(@codemap::Spanned { node: lit_str(..), span: _}) |\n+              ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n               ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n               _ => self.mk_unary(UnUniq, e)\n             };\n@@ -2331,7 +2327,7 @@ impl Parser {\n             ex = match subexpression.node {\n                 ExprVec(..) |\n                 ExprLit(@codemap::Spanned {\n-                    node: lit_str(..),\n+                    node: LitStr(..),\n                     span: _\n                 }) |\n                 ExprRepeat(..) => ExprVstore(subexpression, ExprVstoreUniq),\n@@ -2459,22 +2455,22 @@ impl Parser {\n         self.parse_lambda_expr_(\n             |p| {\n                 match p.token {\n-                  token::BINOP(token::OR) | token::OROR => {\n-                    p.parse_fn_block_decl()\n-                  }\n-                  _ => {\n-                    // No argument list - `do foo {`\n-                      P(ast::fn_decl {\n-                          inputs: ~[],\n-                          output: P(Ty {\n-                              id: ast::DUMMY_NODE_ID,\n-                              node: ty_infer,\n-                              span: p.span\n-                          }),\n-                          cf: return_val,\n-                          variadic: false\n-                      })\n-                  }\n+                    token::BINOP(token::OR) | token::OROR => {\n+                        p.parse_fn_block_decl()\n+                    }\n+                    _ => {\n+                        // No argument list - `do foo {`\n+                        P(FnDecl {\n+                            inputs: ~[],\n+                            output: P(Ty {\n+                                id: ast::DUMMY_NODE_ID,\n+                                node: TyInfer,\n+                                span: p.span\n+                            }),\n+                            cf: Return,\n+                            variadic: false\n+                        })\n+                    }\n                 }\n             },\n             |p| {\n@@ -2493,7 +2489,7 @@ impl Parser {\n     // this is used both in parsing a lambda expr\n     // and in parsing a block expr as e.g. in for...\n     pub fn parse_lambda_expr_(&mut self,\n-                              parse_decl: |&mut Parser| -> P<fn_decl>,\n+                              parse_decl: |&mut Parser| -> P<FnDecl>,\n                               parse_body: |&mut Parser| -> @Expr)\n                               -> @Expr {\n         let lo = self.last_span.lo;\n@@ -2857,7 +2853,7 @@ impl Parser {\n \n     // parse a pattern.\n     pub fn parse_pat(&mut self) -> @Pat {\n-        maybe_whole!(self, nt_pat);\n+        maybe_whole!(self, NtPat);\n \n         let lo = self.span.lo;\n         let mut hi;\n@@ -2883,7 +2879,7 @@ impl Parser {\n             pat = match sub.node {\n               PatLit(e@@Expr {\n                 node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(..),\n+                    node: LitStr(..),\n                     span: _}), ..\n               }) => {\n                 let vst = @Expr {\n@@ -2911,7 +2907,7 @@ impl Parser {\n             pat = match sub.node {\n               PatLit(e@@Expr {\n                 node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(..),\n+                    node: LitStr(..),\n                     span: _}), ..\n               }) => {\n                 let vst = @Expr {\n@@ -2939,7 +2935,7 @@ impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   PatLit(e@@Expr {\n-                      node: ExprLit(@codemap::Spanned{ node: lit_str(..), .. }),\n+                      node: ExprLit(@codemap::Spanned{ node: LitStr(..), .. }),\n                       ..\n                   }) => {\n                       let vst = @Expr {\n@@ -2965,7 +2961,7 @@ impl Parser {\n                 hi = self.span.hi;\n                 self.bump();\n                 let lit = @codemap::Spanned {\n-                    node: lit_nil,\n+                    node: LitNil,\n                     span: mk_sp(lo, hi)};\n                 let expr = self.mk_expr(lo, hi, ExprLit(lit));\n                 pat = PatLit(expr);\n@@ -3170,7 +3166,7 @@ impl Parser {\n \n         let mut ty = P(Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: ty_infer,\n+            node: TyInfer,\n             span: mk_sp(lo, lo),\n         });\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n@@ -3196,18 +3192,17 @@ impl Parser {\n     }\n \n     // parse a structure field\n-    fn parse_name_and_ty(&mut self,\n-                         pr: visibility,\n-                         attrs: ~[Attribute]) -> struct_field {\n+    fn parse_name_and_ty(&mut self, pr: Visibility,\n+                         attrs: ~[Attribute]) -> StructField {\n         let lo = self.span.lo;\n         if !is_plain_ident(&self.token) {\n             self.fatal(\"expected ident\");\n         }\n         let name = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n-        spanned(lo, self.last_span.hi, ast::struct_field_ {\n-            kind: named_field(name, pr),\n+        spanned(lo, self.last_span.hi, ast::StructField_ {\n+            kind: NamedField(name, pr),\n             id: ast::DUMMY_NODE_ID,\n             ty: ty,\n             attrs: attrs,\n@@ -3217,7 +3212,7 @@ impl Parser {\n     // parse a statement. may include decl.\n     // precondition: any attributes are parsed already\n     pub fn parse_stmt(&mut self, item_attrs: ~[Attribute]) -> @Stmt {\n-        maybe_whole!(self, nt_stmt);\n+        maybe_whole!(self, NtStmt);\n \n         fn check_expected_item(p: &mut Parser, found_attrs: bool) {\n             // If we have attributes then we should have an item\n@@ -3271,34 +3266,34 @@ impl Parser {\n \n             if id == token::special_idents::invalid {\n                 return @spanned(lo, hi, StmtMac(\n-                    spanned(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT)), false));\n+                    spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false));\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 return @spanned(lo, hi, StmtDecl(\n                     @spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            item_mac(spanned(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT))),\n-                            inherited, ~[/*no attrs*/]))),\n+                            ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n+                            Inherited, ~[/*no attrs*/]))),\n                     ast::DUMMY_NODE_ID));\n             }\n \n         } else {\n             let found_attrs = !item_attrs.is_empty();\n             match self.parse_item_or_view_item(item_attrs, false) {\n-                iovi_item(i) => {\n+                IoviItem(i) => {\n                     let hi = i.span.hi;\n                     let decl = @spanned(lo, hi, DeclItem(i));\n                     return @spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n                 }\n-                iovi_view_item(vi) => {\n+                IoviViewItem(vi) => {\n                     self.span_fatal(vi.span,\n                                     \"view items must be declared at the top of the block\");\n                 }\n-                iovi_foreign_item(_) => {\n+                IoviForeignItem(_) => {\n                     self.fatal(\"foreign items are not allowed here\");\n                 }\n-                iovi_none(_) => { /* fallthrough */ }\n+                IoviNone(_) => { /* fallthrough */ }\n             }\n \n             check_expected_item(self, found_attrs);\n@@ -3317,7 +3312,7 @@ impl Parser {\n \n     // parse a block. No inner attrs are allowed.\n     pub fn parse_block(&mut self) -> P<Block> {\n-        maybe_whole!(no_clone self, nt_block);\n+        maybe_whole!(no_clone self, NtBlock);\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n@@ -3332,7 +3327,7 @@ impl Parser {\n     fn parse_inner_attrs_and_block(&mut self)\n         -> (~[Attribute], P<Block>) {\n \n-        maybe_whole!(pair_empty self, nt_block);\n+        maybe_whole!(pair_empty self, NtBlock);\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n@@ -3548,9 +3543,9 @@ impl Parser {\n     }\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n-                     -> (~[arg], bool) {\n+                     -> (~[Arg], bool) {\n         let sp = self.span;\n-        let mut args: ~[Option<arg>] =\n+        let mut args: ~[Option<Arg>] =\n             self.parse_unspanned_seq(\n                 &token::LPAREN,\n                 &token::RPAREN,\n@@ -3595,12 +3590,12 @@ impl Parser {\n     }\n \n     // parse the argument list and result type of a function declaration\n-    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> P<fn_decl> {\n+    pub fn parse_fn_decl(&mut self, allow_variadic: bool) -> P<FnDecl> {\n \n         let (args, variadic) = self.parse_fn_args(true, allow_variadic);\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n-        P(ast::fn_decl {\n+        P(FnDecl {\n             inputs: args,\n             output: ret_ty,\n             cf: ret_style,\n@@ -3625,12 +3620,12 @@ impl Parser {\n \n     // parse the argument list and result type of a function\n     // that may have a self type.\n-    fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> arg)\n-                               -> (explicit_self, P<fn_decl>) {\n+    fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> Arg)\n+                               -> (ExplicitSelf, P<FnDecl>) {\n         fn maybe_parse_explicit_self(cnstr: |v: Mutability| ->\n-                                        ast::explicit_self_,\n+                                        ast::ExplicitSelf_,\n                                      p: &mut Parser)\n-                                     -> ast::explicit_self_ {\n+                                     -> ast::ExplicitSelf_ {\n             // We need to make sure it isn't a type\n             if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) ||\n                 ((p.look_ahead(1, |t| token::is_keyword(keywords::Const, t)) ||\n@@ -3642,12 +3637,12 @@ impl Parser {\n                 p.expect_self_ident();\n                 cnstr(mutability)\n             } else {\n-                sty_static\n+                SelfStatic\n             }\n         }\n \n         fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n-                                              -> ast::explicit_self_ {\n+                                              -> ast::ExplicitSelf_ {\n             // The following things are possible to see here:\n             //\n             //     fn(&mut self)\n@@ -3660,23 +3655,23 @@ impl Parser {\n             if this.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n                 this.bump();\n                 this.expect_self_ident();\n-                sty_region(None, MutImmutable)\n+                SelfRegion(None, MutImmutable)\n             } else if this.look_ahead(1, |t| Parser::token_is_mutability(t)) &&\n                     this.look_ahead(2,\n                                     |t| token::is_keyword(keywords::Self,\n                                                           t)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n-                sty_region(None, mutability)\n+                SelfRegion(None, mutability)\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                        this.look_ahead(2,\n                                        |t| token::is_keyword(keywords::Self,\n                                                              t)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 this.expect_self_ident();\n-                sty_region(Some(lifetime), MutImmutable)\n+                SelfRegion(Some(lifetime), MutImmutable)\n             } else if this.look_ahead(1, |t| Parser::token_is_lifetime(t)) &&\n                       this.look_ahead(2, |t| {\n                           Parser::token_is_mutability(t)\n@@ -3687,9 +3682,9 @@ impl Parser {\n                 let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n                 this.expect_self_ident();\n-                sty_region(Some(lifetime), mutability)\n+                SelfRegion(Some(lifetime), mutability)\n             } else {\n-                sty_static\n+                SelfStatic\n             }\n         }\n \n@@ -3703,20 +3698,20 @@ impl Parser {\n             maybe_parse_borrowed_explicit_self(self)\n           }\n           token::AT => {\n-            maybe_parse_explicit_self(sty_box, self)\n+            maybe_parse_explicit_self(SelfBox, self)\n           }\n           token::TILDE => {\n             maybe_parse_explicit_self(|mutability| {\n                 if mutability != MutImmutable {\n                     self.span_err(self.last_span,\n                                   \"mutability declaration not allowed here\");\n                 }\n-                sty_uniq(MutImmutable)\n+                SelfUniq(MutImmutable)\n             }, self)\n           }\n           token::IDENT(..) if self.is_self_ident() => {\n             self.bump();\n-            sty_value(MutImmutable)\n+            SelfValue(MutImmutable)\n           }\n           token::BINOP(token::STAR) => {\n             // Possibly \"*self\" or \"*mut self\" -- not supported. Try to avoid\n@@ -3729,30 +3724,30 @@ impl Parser {\n                 self.span_err(self.span, \"cannot pass self by unsafe pointer\");\n                 self.bump();\n             }\n-            sty_value(mutability)\n+            SelfValue(mutability)\n           }\n           _ if Parser::token_is_mutability(&self.token) &&\n                self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n             self.expect_self_ident();\n-            sty_value(mutability)\n+            SelfValue(mutability)\n           }\n           _ if Parser::token_is_mutability(&self.token) &&\n                self.look_ahead(1, |t| *t == token::TILDE) &&\n                self.look_ahead(2, |t| token::is_keyword(keywords::Self, t)) => {\n             let mutability = self.parse_mutability();\n             self.bump();\n             self.expect_self_ident();\n-            sty_uniq(mutability)\n+            SelfUniq(mutability)\n           }\n           _ => {\n-            sty_static\n+            SelfStatic\n           }\n         };\n \n         // If we parsed a self type, expect a comma before the argument list.\n         let fn_inputs;\n-        if explicit_self != sty_static {\n+        if explicit_self != SelfStatic {\n             match self.token {\n                 token::COMMA => {\n                     self.bump();\n@@ -3785,7 +3780,7 @@ impl Parser {\n \n         let (ret_style, ret_ty) = self.parse_ret_ty();\n \n-        let fn_decl = P(ast::fn_decl {\n+        let fn_decl = P(FnDecl {\n             inputs: fn_inputs,\n             output: ret_ty,\n             cf: ret_style,\n@@ -3796,7 +3791,7 @@ impl Parser {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> P<fn_decl> {\n+    fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n         let inputs_captures = {\n             if self.eat(&token::OROR) {\n                 ~[]\n@@ -3814,21 +3809,21 @@ impl Parser {\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ty_infer,\n+                node: TyInfer,\n                 span: self.span,\n             })\n         };\n \n-        P(ast::fn_decl {\n+        P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n-            cf: return_val,\n+            cf: Return,\n             variadic: false\n         })\n     }\n \n     // Parses the `(arg, arg) -> return_type` header on a procedure.\n-    fn parse_proc_decl(&mut self) -> P<fn_decl> {\n+    fn parse_proc_decl(&mut self) -> P<FnDecl> {\n         let inputs =\n             self.parse_unspanned_seq(&token::LPAREN,\n                                      &token::RPAREN,\n@@ -3840,15 +3835,15 @@ impl Parser {\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: ty_infer,\n+                node: TyInfer,\n                 span: self.span,\n             })\n         };\n \n-        P(ast::fn_decl {\n+        P(FnDecl {\n             inputs: inputs,\n             output: output,\n-            cf: return_val,\n+            cf: Return,\n             variadic: false\n         })\n     }\n@@ -3861,28 +3856,28 @@ impl Parser {\n     }\n \n     fn mk_item(&mut self, lo: BytePos, hi: BytePos, ident: Ident,\n-               node: item_, vis: visibility,\n-               attrs: ~[Attribute]) -> @item {\n-        @ast::item { ident: ident,\n-                     attrs: attrs,\n-                     id: ast::DUMMY_NODE_ID,\n-                     node: node,\n-                     vis: vis,\n-                     span: mk_sp(lo, hi) }\n+               node: Item_, vis: Visibility,\n+               attrs: ~[Attribute]) -> @Item {\n+        @Item {\n+            ident: ident,\n+            attrs: attrs,\n+            id: ast::DUMMY_NODE_ID,\n+            node: node,\n+            vis: vis,\n+            span: mk_sp(lo, hi)\n+        }\n     }\n \n     // parse an item-position function declaration.\n-    fn parse_item_fn(&mut self, purity: purity, abis: AbiSet) -> item_info {\n+    fn parse_item_fn(&mut self, purity: Purity, abis: AbiSet) -> ItemInfo {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        (ident,\n-         item_fn(decl, purity, abis, generics, body),\n-         Some(inner_attrs))\n+        (ident, ItemFn(decl, purity, abis, generics, body), Some(inner_attrs))\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n-    fn parse_method(&mut self, already_parsed_attrs: Option<~[Attribute]>) -> @method {\n+    fn parse_method(&mut self, already_parsed_attrs: Option<~[Attribute]>) -> @Method {\n         let next_attrs = self.parse_outer_attributes();\n         let attrs = match already_parsed_attrs {\n             Some(mut a) => { a.push_all_move(next_attrs); a }\n@@ -3902,7 +3897,7 @@ impl Parser {\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         let hi = body.span.hi;\n         let attrs = vec::append(attrs, inner_attrs);\n-        @ast::method {\n+        @ast::Method {\n             ident: ident,\n             attrs: attrs,\n             generics: generics,\n@@ -3918,7 +3913,7 @@ impl Parser {\n     }\n \n     // parse trait Foo { ... }\n-    fn parse_item_trait(&mut self) -> item_info {\n+    fn parse_item_trait(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n \n@@ -3932,13 +3927,13 @@ impl Parser {\n         }\n \n         let meths = self.parse_trait_methods();\n-        (ident, item_trait(tps, traits, meths), None)\n+        (ident, ItemTrait(tps, traits, meths), None)\n     }\n \n     // Parses two variants (with the region/type params always optional):\n     //    impl<T> Foo { ... }\n     //    impl<T> ToStr for ~[T] { ... }\n-    fn parse_item_impl(&mut self) -> item_info {\n+    fn parse_item_impl(&mut self) -> ItemInfo {\n         // First, parse type parameters if necessary.\n         let generics = self.parse_generics();\n \n@@ -3957,13 +3952,13 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(ref path, None, node_id) => {\n-                    Some(trait_ref {\n+                TyPath(ref path, None, node_id) => {\n+                    Some(TraitRef {\n                         path: /* bad */ (*path).clone(),\n                         ref_id: node_id\n                     })\n                 }\n-                ty_path(..) => {\n+                TyPath(..) => {\n                     self.span_err(ty.span,\n                                   \"bounded traits are only valid in type position\");\n                     None\n@@ -3995,19 +3990,19 @@ impl Parser {\n             Some(inner_attrs)\n         };\n \n-        (ident, item_impl(generics, opt_trait, ty, meths), inner_attrs)\n+        (ident, ItemImpl(generics, opt_trait, ty, meths), inner_attrs)\n     }\n \n     // parse a::B<~str,int>\n-    fn parse_trait_ref(&mut self) -> trait_ref {\n-        ast::trait_ref {\n+    fn parse_trait_ref(&mut self) -> TraitRef {\n+        ast::TraitRef {\n             path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n             ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n     // parse B + C<~str,int> + D\n-    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> ~[trait_ref] {\n+    fn parse_trait_ref_list(&mut self, ket: &token::Token) -> ~[TraitRef] {\n         self.parse_seq_to_before_end(\n             ket,\n             seq_sep_trailing_disallowed(token::BINOP(token::PLUS)),\n@@ -4016,11 +4011,11 @@ impl Parser {\n     }\n \n     // parse struct Foo { ... }\n-    fn parse_item_struct(&mut self) -> item_info {\n+    fn parse_item_struct(&mut self) -> ItemInfo {\n         let class_name = self.parse_ident();\n         let generics = self.parse_generics();\n \n-        let mut fields: ~[struct_field];\n+        let mut fields: ~[StructField];\n         let is_tuple_like;\n \n         if self.eat(&token::LBRACE) {\n@@ -4045,8 +4040,8 @@ impl Parser {\n                 |p| {\n                 let attrs = p.parse_outer_attributes();\n                 let lo = p.span.lo;\n-                let struct_field_ = ast::struct_field_ {\n-                    kind: unnamed_field,\n+                let struct_field_ = ast::StructField_ {\n+                    kind: UnnamedField,\n                     id: ast::DUMMY_NODE_ID,\n                     ty: p.parse_ty(false),\n                     attrs: attrs,\n@@ -4068,7 +4063,7 @@ impl Parser {\n         let _ = ast::DUMMY_NODE_ID;  // XXX: Workaround for crazy bug.\n         let new_id = ast::DUMMY_NODE_ID;\n         (class_name,\n-         item_struct(@ast::struct_def {\n+         ItemStruct(@ast::StructDef {\n              fields: fields,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None }\n          }, generics),\n@@ -4077,9 +4072,9 @@ impl Parser {\n \n     // parse a structure field declaration\n     pub fn parse_single_struct_field(&mut self,\n-                                     vis: visibility,\n+                                     vis: Visibility,\n                                      attrs: ~[Attribute])\n-                                     -> struct_field {\n+                                     -> StructField {\n         let a_var = self.parse_name_and_ty(vis, attrs);\n         match self.token {\n             token::COMMA => {\n@@ -4097,34 +4092,34 @@ impl Parser {\n     }\n \n     // parse an element of a struct definition\n-    fn parse_struct_decl_field(&mut self) -> struct_field {\n+    fn parse_struct_decl_field(&mut self) -> StructField {\n \n         let attrs = self.parse_outer_attributes();\n \n         if self.eat_keyword(keywords::Priv) {\n-            return self.parse_single_struct_field(private, attrs);\n+            return self.parse_single_struct_field(Private, attrs);\n         }\n \n         if self.eat_keyword(keywords::Pub) {\n-           return self.parse_single_struct_field(public, attrs);\n+           return self.parse_single_struct_field(Public, attrs);\n         }\n \n-        return self.parse_single_struct_field(inherited, attrs);\n+        return self.parse_single_struct_field(Inherited, attrs);\n     }\n \n     // parse visiility: PUB, PRIV, or nothing\n-    fn parse_visibility(&mut self) -> visibility {\n-        if self.eat_keyword(keywords::Pub) { public }\n-        else if self.eat_keyword(keywords::Priv) { private }\n-        else { inherited }\n+    fn parse_visibility(&mut self) -> Visibility {\n+        if self.eat_keyword(keywords::Pub) { Public }\n+        else if self.eat_keyword(keywords::Priv) { Private }\n+        else { Inherited }\n     }\n \n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&mut self,\n                        term: token::Token,\n                        first_item_attrs: ~[Attribute])\n-                       -> _mod {\n+                       -> Mod {\n         // parse all of the items up to closing or an attribute.\n         // view items are legal here.\n         let ParsedItemsAndViewItems {\n@@ -4133,7 +4128,7 @@ impl Parser {\n             items: starting_items,\n             ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n-        let mut items: ~[@item] = starting_items;\n+        let mut items: ~[@Item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n         // don't think this other loop is even necessary....\n@@ -4149,8 +4144,8 @@ impl Parser {\n                    attrs);\n             match self.parse_item_or_view_item(attrs,\n                                                true /* macros allowed */) {\n-              iovi_item(item) => items.push(item),\n-              iovi_view_item(view_item) => {\n+              IoviItem(item) => items.push(item),\n+              IoviViewItem(view_item) => {\n                 self.span_fatal(view_item.span,\n                                 \"view items must be declared at the top of \\\n                                  the module\");\n@@ -4168,22 +4163,22 @@ impl Parser {\n             self.span_err(self.last_span, \"expected item after attributes\");\n         }\n \n-        ast::_mod { view_items: view_items, items: items }\n+        ast::Mod { view_items: view_items, items: items }\n     }\n \n-    fn parse_item_const(&mut self) -> item_info {\n+    fn parse_item_const(&mut self) -> ItemInfo {\n         let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(e, token::SEMI);\n-        (id, item_static(ty, m, e), None)\n+        (id, ItemStatic(ty, m, e), None)\n     }\n \n     // parse a `mod <foo> { ... }` or `mod <foo>;` item\n-    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> item_info {\n+    fn parse_item_mod(&mut self, outer_attrs: &[Attribute]) -> ItemInfo {\n         let id_span = self.span;\n         let id = self.parse_ident();\n         if self.token == token::SEMI {\n@@ -4198,7 +4193,7 @@ impl Parser {\n             let m = self.parse_mod_items(token::RBRACE, next);\n             self.expect(&token::RBRACE);\n             self.pop_mod_path();\n-            (id, item_mod(m), Some(inner))\n+            (id, ItemMod(m), Some(inner))\n         }\n     }\n \n@@ -4221,7 +4216,7 @@ impl Parser {\n                     id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n-                    -> (ast::item_, ~[ast::Attribute]) {\n+                    -> (ast::Item_, ~[ast::Attribute]) {\n         let mut prefix = Path::new(self.sess.cm.span_to_filename(self.span));\n         prefix.pop();\n         let mod_path = Path::new(\".\").join_many(self.mod_path_stack);\n@@ -4260,7 +4255,7 @@ impl Parser {\n     fn eval_src_mod_from_path(&mut self,\n                               path: Path,\n                               outer_attrs: ~[ast::Attribute],\n-                              id_sp: Span) -> (ast::item_, ~[ast::Attribute]) {\n+                              id_sp: Span) -> (ast::Item_, ~[ast::Attribute]) {\n         {\n             let mut included_mod_stack = self.sess\n                                              .included_mod_stack\n@@ -4299,35 +4294,35 @@ impl Parser {\n                                              .borrow_mut();\n             included_mod_stack.get().pop();\n         }\n-        return (ast::item_mod(m0), mod_attrs);\n+        return (ast::ItemMod(m0), mod_attrs);\n     }\n \n     // parse a function declaration from a foreign module\n-    fn parse_item_foreign_fn(&mut self, vis: ast::visibility,\n-                             attrs: ~[Attribute]) -> @foreign_item {\n+    fn parse_item_foreign_fn(&mut self, vis: ast::Visibility,\n+                             attrs: ~[Attribute]) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         // Parse obsolete purity.\n         let purity = self.parse_fn_purity();\n-        if purity != impure_fn {\n+        if purity != ImpureFn {\n             self.obsolete(self.last_span, ObsoleteUnsafeExternFn);\n         }\n \n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::foreign_item { ident: ident,\n-                             attrs: attrs,\n-                             node: foreign_item_fn(decl, generics),\n-                             id: ast::DUMMY_NODE_ID,\n-                             span: mk_sp(lo, hi),\n-                             vis: vis }\n+        @ast::ForeignItem { ident: ident,\n+                            attrs: attrs,\n+                            node: ForeignItemFn(decl, generics),\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: mk_sp(lo, hi),\n+                            vis: vis }\n     }\n \n     // parse a static item from a foreign module\n-    fn parse_item_foreign_static(&mut self, vis: ast::visibility,\n-                                 attrs: ~[Attribute]) -> @foreign_item {\n+    fn parse_item_foreign_static(&mut self, vis: ast::Visibility,\n+                                 attrs: ~[Attribute]) -> @ForeignItem {\n         let lo = self.span.lo;\n \n         self.expect_keyword(keywords::Static);\n@@ -4338,20 +4333,20 @@ impl Parser {\n         let ty = self.parse_ty(false);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n-        @ast::foreign_item { ident: ident,\n-                             attrs: attrs,\n-                             node: foreign_item_static(ty, mutbl),\n-                             id: ast::DUMMY_NODE_ID,\n-                             span: mk_sp(lo, hi),\n-                             vis: vis }\n+        @ast::ForeignItem { ident: ident,\n+                            attrs: attrs,\n+                            node: ForeignItemStatic(ty, mutbl),\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: mk_sp(lo, hi),\n+                            vis: vis }\n     }\n \n     // parse safe/unsafe and fn\n-    fn parse_fn_purity(&mut self) -> purity {\n-        if self.eat_keyword(keywords::Fn) { impure_fn }\n+    fn parse_fn_purity(&mut self) -> Purity {\n+        if self.eat_keyword(keywords::Fn) { ImpureFn }\n         else if self.eat_keyword(keywords::Unsafe) {\n             self.expect_keyword(keywords::Fn);\n-            unsafe_fn\n+            UnsafeFn\n         }\n         else { self.unexpected(); }\n     }\n@@ -4362,7 +4357,7 @@ impl Parser {\n     fn parse_foreign_mod_items(&mut self,\n                                abis: AbiSet,\n                                first_item_attrs: ~[Attribute])\n-                               -> foreign_mod {\n+                               -> ForeignMod {\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -4374,7 +4369,7 @@ impl Parser {\n                           \"expected item after attributes\");\n         }\n         assert!(self.token == token::RBRACE);\n-        ast::foreign_mod {\n+        ast::ForeignMod {\n             abis: abis,\n             view_items: view_items,\n             items: foreign_items\n@@ -4385,10 +4380,10 @@ impl Parser {\n     fn parse_item_foreign_mod(&mut self,\n                               lo: BytePos,\n                               opt_abis: Option<AbiSet>,\n-                              visibility: visibility,\n+                              visibility: Visibility,\n                               attrs: ~[Attribute],\n                               items_allowed: bool)\n-                              -> item_or_view_item {\n+                              -> ItemOrViewItem {\n         let mut must_be_named_mod = false;\n         if self.is_keyword(keywords::Mod) {\n             must_be_named_mod = true;\n@@ -4440,10 +4435,10 @@ impl Parser {\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n-                                    item_foreign_mod(m),\n+                                    ItemForeignMod(m),\n                                     visibility,\n                                     maybe_append(attrs, Some(inner)));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n \n         if opt_abis.is_some() {\n@@ -4460,41 +4455,41 @@ impl Parser {\n         }\n         // extern mod foo;\n         self.expect(&token::SEMI);\n-        iovi_view_item(ast::view_item {\n-            node: view_item_extern_mod(ident, maybe_path, ast::DUMMY_NODE_ID),\n+        IoviViewItem(ast::ViewItem {\n+            node: ViewItemExternMod(ident, maybe_path, ast::DUMMY_NODE_ID),\n             attrs: attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n         })\n     }\n \n     // parse type Foo = Bar;\n-    fn parse_item_type(&mut self) -> item_info {\n+    fn parse_item_type(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n         let ty = self.parse_ty(false);\n         self.expect(&token::SEMI);\n-        (ident, item_ty(ty, tps), None)\n+        (ident, ItemTy(ty, tps), None)\n     }\n \n     // parse a structure-like enum variant definition\n     // this should probably be renamed or refactored...\n-    fn parse_struct_def(&mut self) -> @struct_def {\n-        let mut fields: ~[struct_field] = ~[];\n+    fn parse_struct_def(&mut self) -> @StructDef {\n+        let mut fields: ~[StructField] = ~[];\n         while self.token != token::RBRACE {\n             fields.push(self.parse_struct_decl_field());\n         }\n         self.bump();\n \n-        return @ast::struct_def {\n+        return @ast::StructDef {\n             fields: fields,\n             ctor_id: None\n         };\n     }\n \n     // parse the part of an \"enum\" decl following the '{'\n-    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> enum_def {\n+    fn parse_enum_def(&mut self, _generics: &ast::Generics) -> EnumDef {\n         let mut variants = ~[];\n         let mut all_nullary = true;\n         let mut have_disr = false;\n@@ -4512,7 +4507,7 @@ impl Parser {\n             if self.eat(&token::LBRACE) {\n                 // Parse a struct variant.\n                 all_nullary = false;\n-                kind = struct_variant_kind(self.parse_struct_def());\n+                kind = StructVariantKind(self.parse_struct_def());\n             } else if self.token == token::LPAREN {\n                 all_nullary = false;\n                 let arg_tys = self.parse_unspanned_seq(\n@@ -4522,21 +4517,21 @@ impl Parser {\n                     |p| p.parse_ty(false)\n                 );\n                 for ty in arg_tys.move_iter() {\n-                    args.push(ast::variant_arg {\n+                    args.push(ast::VariantArg {\n                         ty: ty,\n                         id: ast::DUMMY_NODE_ID,\n                     });\n                 }\n-                kind = tuple_variant_kind(args);\n+                kind = TupleVariantKind(args);\n             } else if self.eat(&token::EQ) {\n                 have_disr = true;\n                 disr_expr = Some(self.parse_expr());\n-                kind = tuple_variant_kind(args);\n+                kind = TupleVariantKind(args);\n             } else {\n-                kind = tuple_variant_kind(~[]);\n+                kind = TupleVariantKind(~[]);\n             }\n \n-            let vr = ast::variant_ {\n+            let vr = ast::Variant_ {\n                 name: ident,\n                 attrs: variant_attrs,\n                 kind: kind,\n@@ -4554,17 +4549,17 @@ impl Parser {\n                         enum\");\n         }\n \n-        ast::enum_def { variants: variants }\n+        ast::EnumDef { variants: variants }\n     }\n \n     // parse an \"enum\" declaration\n-    fn parse_item_enum(&mut self) -> item_info {\n+    fn parse_item_enum(&mut self) -> ItemInfo {\n         let id = self.parse_ident();\n         let generics = self.parse_generics();\n         self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(&generics);\n-        (id, item_enum(enum_definition, generics), None)\n+        (id, ItemEnum(enum_definition, generics), None)\n     }\n \n     fn fn_expr_lookahead(tok: &token::Token) -> bool {\n@@ -4621,20 +4616,21 @@ impl Parser {\n     }\n \n     // parse one of the items or view items allowed by the\n-    // flags; on failure, return iovi_none.\n+    // flags; on failure, return IoviNone.\n     // NB: this function no longer parses the items inside an\n     // extern mod.\n     fn parse_item_or_view_item(&mut self,\n                                attrs: ~[Attribute],\n                                macros_allowed: bool)\n-                               -> item_or_view_item {\n+                               -> ItemOrViewItem {\n         match self.token {\n-            INTERPOLATED(token::nt_item(item)) => {\n+            INTERPOLATED(token::NtItem(item)) => {\n                 self.bump();\n                 let new_attrs = vec::append(attrs, item.attrs);\n-                return iovi_item(@ast::item {\n-                        attrs: new_attrs,\n-                        ..(*item).clone()});\n+                return IoviItem(@Item {\n+                    attrs: new_attrs,\n+                    ..(*item).clone()\n+                });\n             }\n             _ => {}\n         }\n@@ -4645,10 +4641,10 @@ impl Parser {\n \n         // must be a view item:\n         if self.eat_keyword(keywords::Use) {\n-            // USE ITEM (iovi_view_item)\n+            // USE ITEM (IoviViewItem)\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n-            return iovi_view_item(ast::view_item {\n+            return IoviViewItem(ast::ViewItem {\n                 node: view_item,\n                 attrs: attrs,\n                 vis: visibility,\n@@ -4663,16 +4659,16 @@ impl Parser {\n                 // EXTERN FUNCTION ITEM\n                 let abis = opt_abis.unwrap_or(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(extern_fn, abis);\n+                    self.parse_item_fn(ExternFn, abis);\n                 let item = self.mk_item(lo,\n                                         self.last_span.hi,\n                                         ident,\n                                         item_,\n                                         visibility,\n                                         maybe_append(attrs, extra_attrs));\n-                return iovi_item(item);\n+                return IoviItem(item);\n             } else  {\n-                // EXTERN MODULE ITEM (iovi_view_item)\n+                // EXTERN MODULE ITEM (IoviViewItem)\n                 return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n                                                    true);\n             }\n@@ -4688,36 +4684,36 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.is_keyword(keywords::Fn) &&\n                 self.look_ahead(1, |f| !Parser::fn_expr_lookahead(f)) {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(impure_fn, AbiSet::Rust());\n+                self.parse_item_fn(ImpureFn, AbiSet::Rust());\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.is_keyword(keywords::Unsafe)\n             && self.look_ahead(1u, |t| *t != token::LBRACE) {\n             // UNSAFE FUNCTION ITEM\n             self.bump();\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(unsafe_fn, AbiSet::Rust());\n+                self.parse_item_fn(UnsafeFn, AbiSet::Rust());\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n@@ -4728,7 +4724,7 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Type) {\n             // TYPE ITEM\n@@ -4739,7 +4735,7 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Enum) {\n             // ENUM ITEM\n@@ -4750,7 +4746,7 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Trait) {\n             // TRAIT ITEM\n@@ -4761,7 +4757,7 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Impl) {\n             // IMPL ITEM\n@@ -4772,7 +4768,7 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n@@ -4783,30 +4779,30 @@ impl Parser {\n                                     item_,\n                                     visibility,\n                                     maybe_append(attrs, extra_attrs));\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n \n-    // parse a foreign item; on failure, return iovi_none.\n+    // parse a foreign item; on failure, return IoviNone.\n     fn parse_foreign_item(&mut self,\n                           attrs: ~[Attribute],\n                           macros_allowed: bool)\n-                          -> item_or_view_item {\n-        maybe_whole!(iovi self, nt_item);\n+                          -> ItemOrViewItem {\n+        maybe_whole!(iovi self, NtItem);\n         let lo = self.span.lo;\n \n         let visibility = self.parse_visibility();\n \n         if self.is_keyword(keywords::Static) {\n             // FOREIGN STATIC ITEM\n             let item = self.parse_item_foreign_static(visibility, attrs);\n-            return iovi_foreign_item(item);\n+            return IoviForeignItem(item);\n         }\n         if self.is_keyword(keywords::Fn) || self.is_keyword(keywords::Unsafe) {\n             // FOREIGN FUNCTION ITEM\n             let item = self.parse_item_foreign_fn(visibility, attrs);\n-            return iovi_foreign_item(item);\n+            return IoviForeignItem(item);\n         }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n     }\n@@ -4816,9 +4812,9 @@ impl Parser {\n         &mut self,\n         attrs: ~[Attribute],\n         macros_allowed: bool,\n-        lo : BytePos,\n-        visibility : visibility\n-    ) -> item_or_view_item {\n+        lo: BytePos,\n+        visibility: Visibility\n+    ) -> ItemOrViewItem {\n         if macros_allowed && !token::is_any_keyword(&self.token)\n                 && self.look_ahead(1, |t| *t == token::NOT)\n                 && (self.look_ahead(2, |t| is_plain_ident(t))\n@@ -4850,48 +4846,48 @@ impl Parser {\n                 _ => self.fatal(\"expected open delimiter\")\n             };\n             // single-variant-enum... :\n-            let m = ast::mac_invoc_tt(pth, tts, EMPTY_CTXT);\n-            let m: ast::mac = codemap::Spanned { node: m,\n+            let m = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+            let m: ast::Mac = codemap::Spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n-            let item_ = item_mac(m);\n+            let item_ = ItemMac(m);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     id,\n                                     item_,\n                                     visibility,\n                                     attrs);\n-            return iovi_item(item);\n+            return IoviItem(item);\n         }\n \n         // FAILURE TO PARSE ITEM\n-        if visibility != inherited {\n+        if visibility != Inherited {\n             let mut s = ~\"unmatched visibility `\";\n-            if visibility == public {\n+            if visibility == Public {\n                 s.push_str(\"pub\")\n             } else {\n                 s.push_str(\"priv\")\n             }\n             s.push_char('`');\n             self.span_fatal(self.last_span, s);\n         }\n-        return iovi_none(attrs);\n+        return IoviNone(attrs);\n     }\n \n-    pub fn parse_item(&mut self, attrs: ~[Attribute]) -> Option<@ast::item> {\n+    pub fn parse_item(&mut self, attrs: ~[Attribute]) -> Option<@Item> {\n         match self.parse_item_or_view_item(attrs, true) {\n-            iovi_none(_) => None,\n-            iovi_view_item(_) =>\n+            IoviNone(_) => None,\n+            IoviViewItem(_) =>\n                 self.fatal(\"view items are not allowed here\"),\n-            iovi_foreign_item(_) =>\n+            IoviForeignItem(_) =>\n                 self.fatal(\"foreign items are not allowed here\"),\n-            iovi_item(item) => Some(item)\n+            IoviItem(item) => Some(item)\n         }\n     }\n \n     // parse, e.g., \"use a::b::{z,y}\"\n-    fn parse_use(&mut self) -> view_item_ {\n-        return view_item_use(self.parse_view_paths());\n+    fn parse_use(&mut self) -> ViewItem_ {\n+        return ViewItemUse(self.parse_view_paths());\n     }\n \n \n@@ -4900,7 +4896,7 @@ impl Parser {\n     // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n     // | MOD? non_global_path MOD_SEP STAR\n     // | MOD? non_global_path\n-    fn parse_view_path(&mut self) -> @view_path {\n+    fn parse_view_path(&mut self) -> @ViewPath {\n         let lo = self.span.lo;\n \n         if self.token == token::LBRACE {\n@@ -4915,12 +4911,12 @@ impl Parser {\n                 segments: ~[]\n             };\n             return @spanned(lo, self.span.hi,\n-                            view_path_list(path, idents, ast::DUMMY_NODE_ID));\n+                            ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n         }\n \n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!(\"parsed view_path: {}\", self.id_to_str(first_ident));\n+        debug!(\"parsed view path: {}\", self.id_to_str(first_ident));\n         match self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -4944,9 +4940,8 @@ impl Parser {\n                 }).collect()\n             };\n             return @spanned(lo, self.span.hi,\n-                            view_path_simple(first_ident,\n-                                             path,\n-                                             ast::DUMMY_NODE_ID));\n+                            ViewPathSimple(first_ident, path,\n+                                           ast::DUMMY_NODE_ID));\n           }\n \n           token::MOD_SEP => {\n@@ -4980,7 +4975,7 @@ impl Parser {\n                         }).collect()\n                     };\n                     return @spanned(lo, self.span.hi,\n-                                 view_path_list(path, idents, ast::DUMMY_NODE_ID));\n+                                    ViewPathList(path, idents, ast::DUMMY_NODE_ID));\n                   }\n \n                   // foo::bar::*\n@@ -4998,7 +4993,7 @@ impl Parser {\n                         }).collect()\n                     };\n                     return @spanned(lo, self.span.hi,\n-                                    view_path_glob(path, ast::DUMMY_NODE_ID));\n+                                    ViewPathGlob(path, ast::DUMMY_NODE_ID));\n                   }\n \n                   _ => break\n@@ -5021,11 +5016,11 @@ impl Parser {\n         };\n         return @spanned(lo,\n                         self.last_span.hi,\n-                        view_path_simple(last, path, ast::DUMMY_NODE_ID));\n+                        ViewPathSimple(last, path, ast::DUMMY_NODE_ID));\n     }\n \n     // matches view_paths = view_path | view_path , view_paths\n-    fn parse_view_paths(&mut self) -> ~[@view_path] {\n+    fn parse_view_paths(&mut self) -> ~[@ViewPath] {\n         let mut vp = ~[self.parse_view_path()];\n         while self.token == token::COMMA {\n             self.bump();\n@@ -5047,7 +5042,7 @@ impl Parser {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n-        let mut view_items : ~[ast::view_item] = ~[];\n+        let mut view_items : ~[ast::ViewItem] = ~[];\n         let mut items = ~[];\n \n         // I think this code would probably read better as a single\n@@ -5056,35 +5051,34 @@ impl Parser {\n         // of macros, I'd like to delay that entire check until later.\n         loop {\n             match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                iovi_none(attrs) => {\n+                IoviNone(attrs) => {\n                     return ParsedItemsAndViewItems {\n                         attrs_remaining: attrs,\n                         view_items: view_items,\n                         items: items,\n                         foreign_items: ~[]\n                     }\n                 }\n-                iovi_view_item(view_item) => {\n+                IoviViewItem(view_item) => {\n                     match view_item.node {\n-                        view_item_use(..) => {\n+                        ViewItemUse(..) => {\n                             // `extern mod` must precede `use`.\n                             extern_mod_allowed = false;\n                         }\n-                        view_item_extern_mod(..)\n-                        if !extern_mod_allowed => {\n+                        ViewItemExternMod(..) if !extern_mod_allowed => {\n                             self.span_err(view_item.span,\n                                           \"\\\"extern mod\\\" declarations are not allowed here\");\n                         }\n-                        view_item_extern_mod(..) => {}\n+                        ViewItemExternMod(..) => {}\n                     }\n                     view_items.push(view_item);\n                 }\n-                iovi_item(item) => {\n+                IoviItem(item) => {\n                     items.push(item);\n                     attrs = self.parse_outer_attributes();\n                     break;\n                 }\n-                iovi_foreign_item(_) => {\n+                IoviForeignItem(_) => {\n                     fail!();\n                 }\n             }\n@@ -5094,20 +5088,20 @@ impl Parser {\n         // Next, parse items.\n         loop {\n             match self.parse_item_or_view_item(attrs, macros_allowed) {\n-                iovi_none(returned_attrs) => {\n+                IoviNone(returned_attrs) => {\n                     attrs = returned_attrs;\n                     break\n                 }\n-                iovi_view_item(view_item) => {\n+                IoviViewItem(view_item) => {\n                     attrs = self.parse_outer_attributes();\n                     self.span_err(view_item.span,\n                                   \"`use` and `extern mod` declarations must precede items\");\n                 }\n-                iovi_item(item) => {\n+                IoviItem(item) => {\n                     attrs = self.parse_outer_attributes();\n                     items.push(item)\n                 }\n-                iovi_foreign_item(_) => {\n+                IoviForeignItem(_) => {\n                     fail!();\n                 }\n             }\n@@ -5131,23 +5125,23 @@ impl Parser {\n         let mut foreign_items = ~[];\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {\n-                iovi_none(returned_attrs) => {\n+                IoviNone(returned_attrs) => {\n                     if self.token == token::RBRACE {\n                         attrs = returned_attrs;\n                         break\n                     }\n                     self.unexpected();\n                 },\n-                iovi_view_item(view_item) => {\n+                IoviViewItem(view_item) => {\n                     // I think this can't occur:\n                     self.span_err(view_item.span,\n                                   \"`use` and `extern mod` declarations must precede items\");\n                 }\n-                iovi_item(item) => {\n+                IoviItem(item) => {\n                     // FIXME #5668: this will occur for a macro invocation:\n                     self.span_fatal(item.span, \"macros cannot expand to foreign items\");\n                 }\n-                iovi_foreign_item(foreign_item) => {\n+                IoviForeignItem(foreign_item) => {\n                     foreign_items.push(foreign_item);\n                 }\n             }"}, {"sha": "42313e642838b83338a5d0ffb6fa53977dd1ff20", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d", "patch": "@@ -19,8 +19,9 @@ use std::cast;\n use std::char;\n use std::local_data;\n \n+#[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n-pub enum binop {\n+pub enum BinOp {\n     PLUS,\n     MINUS,\n     STAR,\n@@ -33,6 +34,7 @@ pub enum binop {\n     SHR,\n }\n \n+#[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -47,8 +49,8 @@ pub enum Token {\n     OROR,\n     NOT,\n     TILDE,\n-    BINOP(binop),\n-    BINOPEQ(binop),\n+    BINOP(BinOp),\n+    BINOPEQ(BinOp),\n \n     /* Structural symbols */\n     AT,\n@@ -74,10 +76,10 @@ pub enum Token {\n \n     /* Literals */\n     LIT_CHAR(u32),\n-    LIT_INT(i64, ast::int_ty),\n-    LIT_UINT(u64, ast::uint_ty),\n+    LIT_INT(i64, ast::IntTy),\n+    LIT_UINT(u64, ast::UintTy),\n     LIT_INT_UNSUFFIXED(i64),\n-    LIT_FLOAT(ast::Ident, ast::float_ty),\n+    LIT_FLOAT(ast::Ident, ast::FloatTy),\n     LIT_FLOAT_UNSUFFIXED(ast::Ident),\n     LIT_STR(ast::Ident),\n     LIT_STR_RAW(ast::Ident, uint), /* raw str delimited by n hash symbols */\n@@ -91,29 +93,29 @@ pub enum Token {\n     LIFETIME(ast::Ident),\n \n     /* For interpolation */\n-    INTERPOLATED(nonterminal),\n+    INTERPOLATED(Nonterminal),\n \n     DOC_COMMENT(ast::Ident),\n     EOF,\n }\n \n #[deriving(Clone, Encodable, Decodable, Eq, IterBytes)]\n /// For interpolation during macro expansion.\n-pub enum nonterminal {\n-    nt_item(@ast::item),\n-    nt_block(P<ast::Block>),\n-    nt_stmt(@ast::Stmt),\n-    nt_pat( @ast::Pat),\n-    nt_expr(@ast::Expr),\n-    nt_ty(  P<ast::Ty>),\n-    nt_ident(~ast::Ident, bool),\n-    nt_attr(@ast::Attribute),   // #[foo]\n-    nt_path(~ast::Path),\n-    nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n-    nt_matchers(~[ast::matcher])\n-}\n-\n-pub fn binop_to_str(o: binop) -> ~str {\n+pub enum Nonterminal {\n+    NtItem(@ast::Item),\n+    NtBlock(P<ast::Block>),\n+    NtStmt(@ast::Stmt),\n+    NtPat( @ast::Pat),\n+    NtExpr(@ast::Expr),\n+    NtTy(  P<ast::Ty>),\n+    NtIdent(~ast::Ident, bool),\n+    NtAttr(@ast::Attribute), // #[foo]\n+    NtPath(~ast::Path),\n+    NtTT(  @ast::TokenTree), // needs @ed to break a circularity\n+    NtMatchers(~[ast::Matcher])\n+}\n+\n+pub fn binop_to_str(o: BinOp) -> ~str {\n     match o {\n       PLUS => ~\"+\",\n       MINUS => ~\"-\",\n@@ -128,7 +130,7 @@ pub fn binop_to_str(o: binop) -> ~str {\n     }\n }\n \n-pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n+pub fn to_str(input: @IdentInterner, t: &Token) -> ~str {\n     match *t {\n       EQ => ~\"=\",\n       LT => ~\"<\",\n@@ -212,22 +214,22 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n-            &nt_expr(e) => ::print::pprust::expr_to_str(e, input),\n-            &nt_attr(e) => ::print::pprust::attribute_to_str(e, input),\n+            &NtExpr(e) => ::print::pprust::expr_to_str(e, input),\n+            &NtAttr(e) => ::print::pprust::attribute_to_str(e, input),\n             _ => {\n                 ~\"an interpolated \" +\n                     match (*nt) {\n-                      nt_item(..) => ~\"item\",\n-                      nt_block(..) => ~\"block\",\n-                      nt_stmt(..) => ~\"statement\",\n-                      nt_pat(..) => ~\"pattern\",\n-                      nt_attr(..) => fail!(\"should have been handled\"),\n-                      nt_expr(..) => fail!(\"should have been handled above\"),\n-                      nt_ty(..) => ~\"type\",\n-                      nt_ident(..) => ~\"identifier\",\n-                      nt_path(..) => ~\"path\",\n-                      nt_tt(..) => ~\"tt\",\n-                      nt_matchers(..) => ~\"matcher sequence\"\n+                        NtItem(..) => ~\"item\",\n+                        NtBlock(..) => ~\"block\",\n+                        NtStmt(..) => ~\"statement\",\n+                        NtPat(..) => ~\"pattern\",\n+                        NtAttr(..) => fail!(\"should have been handled\"),\n+                        NtExpr(..) => fail!(\"should have been handled above\"),\n+                        NtTy(..) => ~\"type\",\n+                        NtIdent(..) => ~\"identifier\",\n+                        NtPath(..) => ~\"path\",\n+                        NtTT(..) => ~\"tt\",\n+                        NtMatchers(..) => ~\"matcher sequence\"\n                     }\n             }\n         }\n@@ -260,10 +262,10 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       BINOP(OR) => true, // in lambda syntax\n       OROR => true, // in lambda syntax\n       MOD_SEP => true,\n-      INTERPOLATED(nt_expr(..))\n-      | INTERPOLATED(nt_ident(..))\n-      | INTERPOLATED(nt_block(..))\n-      | INTERPOLATED(nt_path(..)) => true,\n+      INTERPOLATED(NtExpr(..))\n+      | INTERPOLATED(NtIdent(..))\n+      | INTERPOLATED(NtBlock(..))\n+      | INTERPOLATED(NtPath(..)) => true,\n       _ => false\n     }\n }\n@@ -303,7 +305,7 @@ pub fn is_ident(t: &Token) -> bool {\n \n pub fn is_ident_or_path(t: &Token) -> bool {\n     match *t {\n-      IDENT(_, _) | INTERPOLATED(nt_path(..)) => true,\n+      IDENT(_, _) | INTERPOLATED(NtPath(..)) => true,\n       _ => false\n     }\n }\n@@ -381,7 +383,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         }\n     }\n \n-    fn mk_fresh_ident_interner() -> @ident_interner {\n+    fn mk_fresh_ident_interner() -> @IdentInterner {\n         // The indices here must correspond to the numbers in\n         // special_idents, in Keyword to_ident(), and in static\n         // constants below.\n@@ -508,12 +510,12 @@ pub fn token_to_binop(tok: &Token) -> Option<ast::BinOp> {\n }\n \n // looks like we can get rid of this completely...\n-pub type ident_interner = StrInterner;\n+pub type IdentInterner = StrInterner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n-pub fn get_ident_interner() -> @ident_interner {\n-    local_data_key!(key: @@::parse::token::ident_interner)\n+pub fn get_ident_interner() -> @IdentInterner {\n+    local_data_key!(key: @@::parse::token::IdentInterner)\n     match local_data::get(key, |k| k.map(|k| *k)) {\n         Some(interner) => *interner,\n         None => {\n@@ -526,7 +528,7 @@ pub fn get_ident_interner() -> @ident_interner {\n \n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n-pub fn mk_fake_ident_interner() -> @ident_interner {\n+pub fn mk_fake_ident_interner() -> @IdentInterner {\n     @interner::StrInterner::new()\n }\n "}, {"sha": "c421c2f4d7afdaffc7001919af136ad652bc085e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d"}, {"sha": "1e2e5dbc010d0ab9bc6503be74151902d84ae0a1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 412, "deletions": 420, "changes": 832, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d"}, {"sha": "5153ddf1c7d171b22e887efe6eec7591ebc42787", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d"}, {"sha": "8e678a9bb7371a4a994688fbc7c913ab0c871d2e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 80, "deletions": 84, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63403c1c500cc47f876bfc527cc8327464de3d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9d63403c1c500cc47f876bfc527cc8327464de3d"}]}