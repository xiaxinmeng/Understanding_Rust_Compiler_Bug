{"sha": "5f564fbbe46ee609e841062dad1817f17f90943c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNTY0ZmJiZTQ2ZWU2MDllODQxMDYyZGFkMTgxN2YxN2Y5MDk0M2M=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-09-06T18:51:58Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-09-14T09:32:52Z"}, "message": "split ty.rs into smaller parts", "tree": {"sha": "0b2096ce8b15639fc10de3f6747784114403fe97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b2096ce8b15639fc10de3f6747784114403fe97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f564fbbe46ee609e841062dad1817f17f90943c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f564fbbe46ee609e841062dad1817f17f90943c", "html_url": "https://github.com/rust-lang/rust/commit/5f564fbbe46ee609e841062dad1817f17f90943c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f564fbbe46ee609e841062dad1817f17f90943c/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caa10c3bde60ce0d9b5401771c443bff51d2a8e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/caa10c3bde60ce0d9b5401771c443bff51d2a8e2", "html_url": "https://github.com/rust-lang/rust/commit/caa10c3bde60ce0d9b5401771c443bff51d2a8e2"}], "stats": {"total": 8510, "additions": 4355, "deletions": 4155}, "files": [{"sha": "2447a8cee7bbb9d56bf9c0e1d2f8969a350e04f1", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -43,7 +43,8 @@ use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::{self, Ty, TypeError};\n+use middle::ty::{self, Ty};\n+use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -362,12 +363,12 @@ impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n pub trait RelateResultCompare<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::TypeError<'tcx>;\n+        F: FnOnce() -> TypeError<'tcx>;\n }\n \n impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n     fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n-        F: FnOnce() -> ty::TypeError<'tcx>,\n+        F: FnOnce() -> TypeError<'tcx>,\n     {\n         self.clone().and_then(|s| {\n             if s == t {\n@@ -380,15 +381,15 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n }\n \n fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n-                               -> ty::TypeError<'tcx>\n+                               -> TypeError<'tcx>\n {\n     let (a, b) = v;\n     TypeError::IntMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }\n \n fn float_unification_error<'tcx>(a_is_expected: bool,\n                                  v: (hir::FloatTy, hir::FloatTy))\n-                                 -> ty::TypeError<'tcx>\n+                                 -> TypeError<'tcx>\n {\n     let (a, b) = v;\n     TypeError::FloatMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))"}, {"sha": "f0fa7d7cdf851b0f5a12bfbeb6a5423e5fc3de9e", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -82,8 +82,9 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::region;\n use middle::subst;\n-use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n+use middle::ty::{self, Ty, HasTypeFlags};\n use middle::ty::{Region, ReFree};\n+use middle::ty::error::TypeError;\n \n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n@@ -225,19 +226,19 @@ pub trait ErrorReporting<'tcx> {\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n                       -> Vec<RegionResolutionError<'tcx>>;\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>);\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>);\n \n-    fn check_and_note_conflicting_crates(&self, terr: &ty::TypeError<'tcx>, sp: Span);\n+    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span);\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::TypeError<'tcx>);\n+                                     terr: &TypeError<'tcx>);\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::ExpectedFound<T>)\n+        exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<String>;\n \n     fn report_concrete_failure(&self,\n@@ -266,7 +267,7 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n+                               trace_origin: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, same_regions: &[SameRegions]);\n@@ -473,7 +474,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &ty::TypeError<'tcx>) {\n+    fn report_type_error(&self, trace: TypeTrace<'tcx>, terr: &TypeError<'tcx>) {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -497,7 +498,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     /// Adds a note if the types come from similarly named crates\n-    fn check_and_note_conflicting_crates(&self, terr: &ty::TypeError<'tcx>, sp: Span) {\n+    fn check_and_note_conflicting_crates(&self, terr: &TypeError<'tcx>, sp: Span) {\n         let report_path_match = |did1: DefId, did2: DefId| {\n             // Only external crates, if either is from a local\n             // module we could have false positives\n@@ -520,7 +521,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         };\n         match *terr {\n-            ty::TypeError::Sorts(ref exp_found) => {\n+            TypeError::Sorts(ref exp_found) => {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 match (&exp_found.expected.sty, &exp_found.found.sty) {\n@@ -533,7 +534,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     _ => ()\n                 }\n             },\n-            ty::TypeError::Traits(ref exp_found) => {\n+            TypeError::Traits(ref exp_found) => {\n                 self.tcx.sess.note(\"errrr0\");\n                 report_path_match(exp_found.expected, exp_found.found);\n             },\n@@ -543,7 +544,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &ty::TypeError<'tcx>) {\n+                                     terr: &TypeError<'tcx>) {\n         let span = trace.origin.span();\n         self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(terr, span);\n@@ -561,7 +562,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + HasTypeFlags>(\n         &self,\n-        exp_found: &ty::ExpectedFound<T>)\n+        exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<String>\n     {\n         let expected = exp_found.expected.resolve(self);\n@@ -975,7 +976,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_processed_errors(&self,\n                                var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, ty::TypeError<'tcx>)],\n+                               trace_origins: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n                                same_regions: &[SameRegions]) {\n         for vo in var_origins {\n             self.report_inference_failure(vo.clone());"}, {"sha": "b0fce71d3f06143523856dacc51e85acd62164e0", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -14,7 +14,8 @@\n use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::CombineFields;\n \n-use middle::ty::{self, TypeError, Binder};\n+use middle::ty::{self, Binder};\n+use middle::ty::error::TypeError;\n use middle::ty::fold::TypeFoldable;\n use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n@@ -358,7 +359,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    ty::fold::fold_regions(tcx, unbound_value, &mut false, |region, current_depth| {\n+    tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -438,7 +439,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n \n         let mut escaping_region_vars = FnvHashSet();\n         for ty in &escaping_types {\n-            ty::fold::collect_regions(self.tcx, ty, &mut escaping_region_vars);\n+            self.tcx.collect_regions(ty, &mut escaping_region_vars);\n         }\n \n         region_vars.retain(|&region_vid| {\n@@ -468,7 +469,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * details.\n      */\n \n-    let (result, map) = ty::fold::replace_late_bound_regions(infcx.tcx, binder, |br| {\n+    let (result, map) = infcx.tcx.replace_late_bound_regions(binder, |br| {\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n \n@@ -590,7 +591,7 @@ pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     // binder is that we encountered in `value`. The caller is\n     // responsible for ensuring that (a) `value` contains at least one\n     // binder and (b) that binder is the one we want to use.\n-    let result = ty::fold::fold_regions(infcx.tcx, &value, &mut false, |r, current_depth| {\n+    let result = infcx.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n         match inv_skol_map.get(&r) {\n             None => r,\n             Some(br) => {"}, {"sha": "b9e9ee5e2449732dc7c469459ecbcef6d52c93b2", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -30,8 +30,9 @@ use middle::subst::Substs;\n use middle::subst::Subst;\n use middle::traits::{self, FulfillmentContext, Normalized,\n                      SelectionContext, ObligationCause};\n-use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n-use middle::ty::{self, Ty, TypeError, HasTypeFlags};\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n+use middle::ty::{self, Ty, HasTypeFlags};\n+use middle::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -171,9 +172,9 @@ impl fmt::Display for TypeOrigin {\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n-    Types(ty::ExpectedFound<Ty<'tcx>>),\n-    TraitRefs(ty::ExpectedFound<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ty::ExpectedFound<ty::PolyTraitRef<'tcx>>),\n+    Types(ExpectedFound<Ty<'tcx>>),\n+    TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n+    PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -479,12 +480,12 @@ pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n                      b: T)\n-                     -> ty::ExpectedFound<T>\n+                     -> ExpectedFound<T>\n {\n     if a_is_expected {\n-        ty::ExpectedFound {expected: a, found: b}\n+        ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::ExpectedFound {expected: b, found: a}\n+        ExpectedFound {expected: b, found: a}\n     }\n }\n \n@@ -656,7 +657,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n-        use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::TyInfer(ty::IntVar(vid)) => {\n                 if self.int_unification_table.borrow_mut().has_value(vid) {\n@@ -1312,7 +1314,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                      sp: Span,\n                                      mk_msg: M,\n                                      actual_ty: String,\n-                                     err: Option<&ty::TypeError<'tcx>>) where\n+                                     err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n@@ -1323,7 +1325,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                    mk_msg: M,\n                                                    expected_ty: Option<Ty<'tcx>>,\n                                                    actual_ty: String,\n-                                                   err: Option<&ty::TypeError<'tcx>>) where\n+                                                   err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n@@ -1349,7 +1351,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::TypeError<'tcx>>) where\n+                                 err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n@@ -1368,10 +1370,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                    span: Span,\n                                    expected: Ty<'tcx>,\n                                    actual: Ty<'tcx>,\n-                                   err: &ty::TypeError<'tcx>) {\n+                                   err: &TypeError<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: expected,\n                 found: actual\n             })\n@@ -1385,14 +1387,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                             actual: type_variable::Default<'tcx>) {\n         let trace = TypeTrace {\n             origin: Misc(span),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: expected.ty,\n                 found: actual.ty\n             })\n         };\n \n         self.report_and_explain_type_error(trace,\n-            &TypeError::TyParamDefaultMismatch(ty::ExpectedFound {\n+            &TypeError::TyParamDefaultMismatch(ExpectedFound {\n                 expected: expected,\n                 found: actual\n         }));\n@@ -1406,8 +1408,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n-        ty::fold::replace_late_bound_regions(\n-            self.tcx,\n+        self.tcx.replace_late_bound_regions(\n             value,\n             |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n@@ -1555,7 +1556,7 @@ impl<'tcx> TypeTrace<'tcx> {\n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n-            values: Types(ty::ExpectedFound {\n+            values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n             })"}, {"sha": "1fc5294877065efc2bffd945ff534fb2941ee3e7", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -23,10 +23,11 @@ use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n use middle::free_region::FreeRegionMap;\n use middle::region;\n-use middle::ty::{self, Ty, TypeError};\n+use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n+use middle::ty::error::TypeError;\n use middle::ty::relate::RelateResult;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n@@ -157,7 +158,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n     ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, ty::TypeError<'tcx>)>,\n+                    Vec<(TypeTrace<'tcx>, TypeError<'tcx>)>,\n                     Vec<SameRegions>),\n }\n "}, {"sha": "a79837e7fb14f88bf61de5b5394bb27bb9ed3819", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -168,7 +168,7 @@ pub enum SelectionError<'tcx> {\n     Unimplemented,\n     OutputTypeParameterMismatch(ty::PolyTraitRef<'tcx>,\n                                 ty::PolyTraitRef<'tcx>,\n-                                ty::TypeError<'tcx>),\n+                                ty::error::TypeError<'tcx>),\n     TraitNotObjectSafe(DefId),\n }\n "}, {"sha": "f13b81ccdb22fd6ad3463520f10f614800478798", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -51,7 +51,7 @@ pub enum ProjectionTyError<'tcx> {\n \n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n-    pub err: ty::TypeError<'tcx>\n+    pub err: ty::error::TypeError<'tcx>\n }\n \n #[derive(PartialEq, Eq, Debug)]"}, {"sha": "5a3ad9095ad2c1b945b5f9af25ca7a85e93fee60", "filename": "src/librustc/middle/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2F_match.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use middle::ty::{self, Ty};\n+use middle::ty::error::TypeError;\n use middle::ty::relate::{self, Relate, TypeRelation, RelateResult};\n \n /// A type \"A\" *matches* \"B\" if the fresh types in B could be\n@@ -73,7 +74,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n             (&ty::TyInfer(_), _) |\n             (_, &ty::TyInfer(_)) => {\n-                Err(ty::TypeError::Sorts(relate::expected_found(self, &a, &b)))\n+                Err(TypeError::Sorts(relate::expected_found(self, &a, &b)))\n             }\n \n             (&ty::TyError, _) | (_, &ty::TyError) => {"}, {"sha": "bcce9e8ea54761d2f73b37728a349a2372698174", "filename": "src/librustc/middle/ty/contents.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontents.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,269 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def_id::{DefId};\n+use middle::ty::{self, Ty};\n+use util::common::{memoized};\n+use util::nodemap::FnvHashMap;\n+\n+use std::fmt;\n+use std::ops;\n+\n+use rustc_front::hir;\n+\n+/// Type contents is how the type checker reasons about kinds.\n+/// They track what kinds of things are found within a type.  You can\n+/// think of them as kind of an \"anti-kind\".  They track the kinds of values\n+/// and thinks that are contained in types.  Having a larger contents for\n+/// a type tends to rule that type *out* from various kinds.  For example,\n+/// a type that contains a reference is not sendable.\n+///\n+/// The reason we compute type contents and not kinds is that it is\n+/// easier for me (nmatsakis) to think about what is contained within\n+/// a type than to think about what is *not* contained within a type.\n+#[derive(Clone, Copy)]\n+pub struct TypeContents {\n+    pub bits: u64\n+}\n+\n+macro_rules! def_type_content_sets {\n+    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n+        #[allow(non_snake_case)]\n+        mod $mname {\n+            use super::TypeContents;\n+            $(\n+                #[allow(non_upper_case_globals)]\n+                pub const $name: TypeContents = TypeContents { bits: $bits };\n+             )+\n+        }\n+    }\n+}\n+\n+def_type_content_sets! {\n+    mod TC {\n+        None                                = 0b0000_0000__0000_0000__0000,\n+\n+        // Things that are interior to the value (first nibble):\n+        InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n+        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n+        // InteriorAll                         = 0b00000000__00000000__1111,\n+\n+        // Things that are owned by the value (second and third nibbles):\n+        OwnsOwned                           = 0b0000_0000__0000_0001__0000,\n+        OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n+        OwnsAll                             = 0b0000_0000__1111_1111__0000,\n+\n+        // Things that mean drop glue is necessary\n+        NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n+\n+        // All bits\n+        All                                 = 0b1111_1111__1111_1111__1111\n+    }\n+}\n+\n+impl TypeContents {\n+    pub fn when(&self, cond: bool) -> TypeContents {\n+        if cond {*self} else {TC::None}\n+    }\n+\n+    pub fn intersects(&self, tc: TypeContents) -> bool {\n+        (self.bits & tc.bits) != 0\n+    }\n+\n+    pub fn owns_owned(&self) -> bool {\n+        self.intersects(TC::OwnsOwned)\n+    }\n+\n+    pub fn interior_param(&self) -> bool {\n+        self.intersects(TC::InteriorParam)\n+    }\n+\n+    pub fn interior_unsafe(&self) -> bool {\n+        self.intersects(TC::InteriorUnsafe)\n+    }\n+\n+    pub fn needs_drop(&self, _: &ty::ctxt) -> bool {\n+        self.intersects(TC::NeedsDrop)\n+    }\n+\n+    /// Includes only those bits that still apply when indirected through a `Box` pointer\n+    pub fn owned_pointer(&self) -> TypeContents {\n+        TC::OwnsOwned | (*self & TC::OwnsAll)\n+    }\n+\n+    pub fn union<T, F>(v: &[T], mut f: F) -> TypeContents where\n+        F: FnMut(&T) -> TypeContents,\n+    {\n+        v.iter().fold(TC::None, |tc, ty| tc | f(ty))\n+    }\n+\n+    pub fn has_dtor(&self) -> bool {\n+        self.intersects(TC::OwnsDtor)\n+    }\n+}\n+\n+impl ops::BitOr for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn bitor(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits | other.bits}\n+    }\n+}\n+\n+impl ops::BitAnd for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn bitand(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & other.bits}\n+    }\n+}\n+\n+impl ops::Sub for TypeContents {\n+    type Output = TypeContents;\n+\n+    fn sub(self, other: TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & !other.bits}\n+    }\n+}\n+\n+impl fmt::Debug for TypeContents {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TypeContents({:b})\", self.bits)\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    pub fn type_contents(&'tcx self, cx: &ty::ctxt<'tcx>) -> TypeContents {\n+        return memoized(&cx.tc_cache, self, |ty| {\n+            tc_ty(cx, ty, &mut FnvHashMap())\n+        });\n+\n+        fn tc_ty<'tcx>(cx: &ty::ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+        {\n+            // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n+            // private cache for this walk.  This is needed in the case of cyclic\n+            // types like:\n+            //\n+            //     struct List { next: Box<Option<List>>, ... }\n+            //\n+            // When computing the type contents of such a type, we wind up deeply\n+            // recursing as we go.  So when we encounter the recursive reference\n+            // to List, we temporarily use TC::None as its contents.  Later we'll\n+            // patch up the cache with the correct value, once we've computed it\n+            // (this is basically a co-inductive process, if that helps).  So in\n+            // the end we'll compute TC::OwnsOwned, in this case.\n+            //\n+            // The problem is, as we are doing the computation, we will also\n+            // compute an *intermediate* contents for, e.g., Option<List> of\n+            // TC::None.  This is ok during the computation of List itself, but if\n+            // we stored this intermediate value into cx.tc_cache, then later\n+            // requests for the contents of Option<List> would also yield TC::None\n+            // which is incorrect.  This value was computed based on the crutch\n+            // value for the type contents of list.  The correct value is\n+            // TC::OwnsOwned.  This manifested as issue #4821.\n+            match cache.get(&ty) {\n+                Some(tc) => { return *tc; }\n+                None => {}\n+            }\n+            match cx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n+                Some(tc) => { return *tc; }\n+                None => {}\n+            }\n+            cache.insert(ty, TC::None);\n+\n+            let result = match ty.sty {\n+                // usize and isize are ffi-unsafe\n+                ty::TyUint(hir::TyUs) | ty::TyInt(hir::TyIs) => {\n+                    TC::None\n+                }\n+\n+                // Scalar and unique types are sendable, and durable\n+                ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+                ty::TyBareFn(..) | ty::TyChar => {\n+                    TC::None\n+                }\n+\n+                ty::TyBox(typ) => {\n+                    tc_ty(cx, typ, cache).owned_pointer()\n+                }\n+\n+                ty::TyTrait(_) => {\n+                    TC::All - TC::InteriorParam\n+                }\n+\n+                ty::TyRawPtr(_) => {\n+                    TC::None\n+                }\n+\n+                ty::TyRef(_, _) => {\n+                    TC::None\n+                }\n+\n+                ty::TyArray(ty, _) => {\n+                    tc_ty(cx, ty, cache)\n+                }\n+\n+                ty::TySlice(ty) => {\n+                    tc_ty(cx, ty, cache)\n+                }\n+                ty::TyStr => TC::None,\n+\n+                ty::TyClosure(_, ref substs) => {\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n+                }\n+\n+                ty::TyTuple(ref tys) => {\n+                    TypeContents::union(&tys[..],\n+                                        |ty| tc_ty(cx, *ty, cache))\n+                }\n+\n+                ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                    let mut res =\n+                        TypeContents::union(&def.variants, |v| {\n+                            TypeContents::union(&v.fields, |f| {\n+                                tc_ty(cx, f.ty(cx, substs), cache)\n+                            })\n+                        });\n+\n+                    if def.has_dtor() {\n+                        res = res | TC::OwnsDtor;\n+                    }\n+\n+                    apply_lang_items(cx, def.did, res)\n+                }\n+\n+                ty::TyProjection(..) |\n+                ty::TyParam(_) => {\n+                    TC::All\n+                }\n+\n+                ty::TyInfer(_) |\n+                ty::TyError => {\n+                    cx.sess.bug(\"asked to compute contents of error type\");\n+                }\n+            };\n+\n+            cache.insert(ty, result);\n+            result\n+        }\n+\n+        fn apply_lang_items(cx: &ty::ctxt, did: DefId, tc: TypeContents)\n+                            -> TypeContents {\n+            if Some(did) == cx.lang_items.unsafe_cell_type() {\n+                tc | TC::InteriorUnsafe\n+            } else {\n+                tc\n+            }\n+        }\n+    }\n+}"}, {"sha": "4d57e0980ef542446f1186d23e2c2293e2e327c8", "filename": "src/librustc/middle/ty/context.rs", "status": "added", "additions": 964, "deletions": 0, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,964 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! type context book-keeping\n+\n+// FIXME: (@jroesch) @eddyb should remove this when he renames ctxt\n+#![allow(non_camel_case_types)]\n+\n+use front::map as ast_map;\n+use session::Session;\n+use lint;\n+use middle;\n+use middle::def::DefMap;\n+use middle::def_id::DefId;\n+use middle::free_region::FreeRegionMap;\n+use middle::region::RegionMaps;\n+use middle::resolve_lifetime;\n+use middle::stability;\n+use middle::subst::{self, Subst, Substs};\n+use middle::traits;\n+use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n+use middle::ty::{TyS, TypeVariants};\n+use middle::ty::{AdtDef, ClosureSubsts, ExistentialBounds, Region};\n+use middle::ty::{FreevarMap, GenericPredicates};\n+use middle::ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n+use middle::ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n+use middle::ty::TypeVariants::*;\n+use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n+use util::nodemap::FnvHashMap;\n+\n+use arena::TypedArena;\n+use std::borrow::Borrow;\n+use std::cell::{Cell, RefCell, Ref};\n+use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast::{Name, NodeId};\n+use syntax::parse::token::special_idents;\n+\n+use rustc_front::hir;\n+use rustc_front::attr;\n+\n+/// Internal storage\n+pub struct CtxtArenas<'tcx> {\n+    // internings\n+    type_: TypedArena<TyS<'tcx>>,\n+    substs: TypedArena<Substs<'tcx>>,\n+    bare_fn: TypedArena<BareFnTy<'tcx>>,\n+    region: TypedArena<Region>,\n+    stability: TypedArena<attr::Stability>,\n+\n+    // references\n+    trait_defs: TypedArena<ty::TraitDef<'tcx>>,\n+    adt_defs: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+}\n+\n+impl<'tcx> CtxtArenas<'tcx> {\n+    pub fn new() -> CtxtArenas<'tcx> {\n+        CtxtArenas {\n+            type_: TypedArena::new(),\n+            substs: TypedArena::new(),\n+            bare_fn: TypedArena::new(),\n+            region: TypedArena::new(),\n+            stability: TypedArena::new(),\n+\n+            trait_defs: TypedArena::new(),\n+            adt_defs: TypedArena::new()\n+        }\n+    }\n+}\n+\n+pub struct CommonTypes<'tcx> {\n+    pub bool: Ty<'tcx>,\n+    pub char: Ty<'tcx>,\n+    pub isize: Ty<'tcx>,\n+    pub i8: Ty<'tcx>,\n+    pub i16: Ty<'tcx>,\n+    pub i32: Ty<'tcx>,\n+    pub i64: Ty<'tcx>,\n+    pub usize: Ty<'tcx>,\n+    pub u8: Ty<'tcx>,\n+    pub u16: Ty<'tcx>,\n+    pub u32: Ty<'tcx>,\n+    pub u64: Ty<'tcx>,\n+    pub f32: Ty<'tcx>,\n+    pub f64: Ty<'tcx>,\n+    pub err: Ty<'tcx>,\n+}\n+\n+pub struct Tables<'tcx> {\n+    /// Stores the types for various nodes in the AST.  Note that this table\n+    /// is not guaranteed to be populated until after typeck.  See\n+    /// typeck::check::fn_ctxt for details.\n+    pub node_types: NodeMap<Ty<'tcx>>,\n+\n+    /// Stores the type parameters which were substituted to obtain the type\n+    /// of this node.  This only applies to nodes that refer to entities\n+    /// parameterized by type parameters, such as generic fns, types, or\n+    /// other items.\n+    pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n+\n+    pub adjustments: NodeMap<ty::AutoAdjustment<'tcx>>,\n+\n+    pub method_map: ty::MethodMap<'tcx>,\n+\n+    /// Borrows\n+    pub upvar_capture_map: ty::UpvarCaptureMap,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_tys: DefIdMap<ty::ClosureTy<'tcx>>,\n+\n+    /// Records the type of each closure. The def ID is the ID of the\n+    /// expression defining the closure.\n+    pub closure_kinds: DefIdMap<ty::ClosureKind>,\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn empty() -> Tables<'tcx> {\n+        Tables {\n+            node_types: FnvHashMap(),\n+            item_substs: NodeMap(),\n+            adjustments: NodeMap(),\n+            method_map: FnvHashMap(),\n+            upvar_capture_map: FnvHashMap(),\n+            closure_tys: DefIdMap(),\n+            closure_kinds: DefIdMap(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> CommonTypes<'tcx> {\n+    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n+           interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>)\n+           -> CommonTypes<'tcx>\n+    {\n+        let mk = |sty| ctxt::intern_ty(arena, interner, sty);\n+        CommonTypes {\n+            bool: mk(TyBool),\n+            char: mk(TyChar),\n+            err: mk(TyError),\n+            isize: mk(TyInt(hir::TyIs)),\n+            i8: mk(TyInt(hir::TyI8)),\n+            i16: mk(TyInt(hir::TyI16)),\n+            i32: mk(TyInt(hir::TyI32)),\n+            i64: mk(TyInt(hir::TyI64)),\n+            usize: mk(TyUint(hir::TyUs)),\n+            u8: mk(TyUint(hir::TyU8)),\n+            u16: mk(TyUint(hir::TyU16)),\n+            u32: mk(TyUint(hir::TyU32)),\n+            u64: mk(TyUint(hir::TyU64)),\n+            f32: mk(TyFloat(hir::TyF32)),\n+            f64: mk(TyFloat(hir::TyF64)),\n+        }\n+    }\n+}\n+\n+/// The data structure to keep track of all the information that typechecker\n+/// generates so that so that it can be reused and doesn't have to be redone\n+/// later on.\n+pub struct ctxt<'tcx> {\n+    /// The arenas that types etc are allocated from.\n+    arenas: &'tcx CtxtArenas<'tcx>,\n+\n+    /// Specifically use a speedy hash algorithm for this hash map, it's used\n+    /// quite often.\n+    // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n+    // queried from a HashSet.\n+    interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+\n+    // FIXME as above, use a hashset if equivalent elements can be queried.\n+    substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n+    bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n+    region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n+    stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n+\n+    /// Common types, pre-interned for your convenience.\n+    pub types: CommonTypes<'tcx>,\n+\n+    pub sess: Session,\n+    pub def_map: DefMap,\n+\n+    pub named_region_map: resolve_lifetime::NamedRegionMap,\n+\n+    pub region_maps: RegionMaps,\n+\n+    // For each fn declared in the local crate, type check stores the\n+    // free-region relationships that were deduced from its where\n+    // clauses and parameter types. These are then read-again by\n+    // borrowck. (They are not used during trans, and hence are not\n+    // serialized or needed for cross-crate fns.)\n+    free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n+    // FIXME: jroesch make this a refcell\n+\n+    pub tables: RefCell<Tables<'tcx>>,\n+\n+    /// Maps from a trait item to the trait item \"descriptor\"\n+    pub impl_or_trait_items: RefCell<DefIdMap<ty::ImplOrTraitItem<'tcx>>>,\n+\n+    /// Maps from a trait def-id to a list of the def-ids of its trait items\n+    pub trait_item_def_ids: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItemId>>>>,\n+\n+    /// A cache for the trait_items() routine\n+    pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ty::ImplOrTraitItem<'tcx>>>>>,\n+\n+    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n+    pub trait_defs: RefCell<DefIdMap<&'tcx ty::TraitDef<'tcx>>>,\n+    pub adt_defs: RefCell<DefIdMap<ty::AdtDefMaster<'tcx>>>,\n+\n+    /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n+    /// associated predicates.\n+    pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n+    pub map: ast_map::Map<'tcx>,\n+    pub freevars: RefCell<FreevarMap>,\n+    pub tcache: RefCell<DefIdMap<ty::TypeScheme<'tcx>>>,\n+    pub rcache: RefCell<FnvHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n+    pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n+    pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n+    pub normalized_cache: RefCell<FnvHashMap<Ty<'tcx>, Ty<'tcx>>>,\n+    pub lang_items: middle::lang_items::LanguageItems,\n+    /// A mapping of fake provided method def_ids to the default implementation\n+    pub provided_method_sources: RefCell<DefIdMap<DefId>>,\n+\n+    /// Maps from def-id of a type or region parameter to its\n+    /// (inferred) variance.\n+    pub item_variance_map: RefCell<DefIdMap<Rc<ty::ItemVariances>>>,\n+\n+    /// True if the variance has been computed yet; false otherwise.\n+    pub variance_computed: Cell<bool>,\n+\n+    /// A method will be in this list if and only if it is a destructor.\n+    pub destructors: RefCell<DefIdSet>,\n+\n+    /// Maps a DefId of a type to a list of its inherent impls.\n+    /// Contains implementations of methods that are inherent to a type.\n+    /// Methods in these implementations don't need to be exported.\n+    pub inherent_impls: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n+\n+    /// Maps a DefId of an impl to a list of its items.\n+    /// Note that this contains all of the impls that we know about,\n+    /// including ones in other crates. It's not clear that this is the best\n+    /// way to do it.\n+    pub impl_items: RefCell<DefIdMap<Vec<ty::ImplOrTraitItemId>>>,\n+\n+    /// Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n+    /// present in this set can be warned about.\n+    pub used_unsafe: RefCell<NodeSet>,\n+\n+    /// Set of nodes which mark locals as mutable which end up getting used at\n+    /// some point. Local variable definitions not in this set can be warned\n+    /// about.\n+    pub used_mut_nodes: RefCell<NodeSet>,\n+\n+    /// The set of external nominal types whose implementations have been read.\n+    /// This is used for lazy resolution of methods.\n+    pub populated_external_types: RefCell<DefIdSet>,\n+    /// The set of external primitive types whose implementations have been read.\n+    /// FIXME(arielb1): why is this separate from populated_external_types?\n+    pub populated_external_primitive_impls: RefCell<DefIdSet>,\n+\n+    /// These caches are used by const_eval when decoding external constants.\n+    pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_variants: RefCell<DefIdMap<NodeId>>,\n+    pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n+\n+    pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),\n+                                              lint::LevelSource>>,\n+\n+    /// The types that must be asserted to be the same size for `transmute`\n+    /// to be valid. We gather up these restrictions in the intrinsicck pass\n+    /// and check them in trans.\n+    pub transmute_restrictions: RefCell<Vec<ty::TransmuteRestriction<'tcx>>>,\n+\n+    /// Maps any item's def-id to its stability index.\n+    pub stability: RefCell<stability::Index<'tcx>>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that do not have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// A set of predicates that have been fulfilled *somewhere*.\n+    /// This is used to avoid duplicate work. Predicates are only\n+    /// added to this set when they mention only \"global\" names\n+    /// (i.e., no type or lifetime parameters).\n+    pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n+\n+    /// Caches the representation hints for struct definitions.\n+    pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n+\n+    /// Maps Expr NodeId's to their constant qualification.\n+    pub const_qualif_map: RefCell<NodeMap<middle::check_const::ConstQualif>>,\n+\n+    /// Caches CoerceUnsized kinds for impls on custom types.\n+    pub custom_coerce_unsized_kinds: RefCell<DefIdMap<ty::CustomCoerceUnsized>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: RefCell<NodeMap<ty::cast::CastKind>>,\n+\n+    /// Maps Fn items to a collection of fragment infos.\n+    ///\n+    /// The main goal is to identify data (each of which may be moved\n+    /// or assigned) whose subparts are not moved nor assigned\n+    /// (i.e. their state is *unfragmented*) and corresponding ast\n+    /// nodes where the path to that data is moved or assigned.\n+    ///\n+    /// In the long term, unfragmented values will have their\n+    /// destructor entirely driven by a single stack-local drop-flag,\n+    /// and their parents, the collections of the unfragmented values\n+    /// (or more simply, \"fragmented values\"), are mapped to the\n+    /// corresponding collections of stack-local drop-flags.\n+    ///\n+    /// (However, in the short term that is not the case; e.g. some\n+    /// unfragmented paths still need to be zeroed, namely when they\n+    /// reference parent data from an outer scope that was not\n+    /// entirely moved, and therefore that needs to be zeroed so that\n+    /// we do not get double-drop when we hit the end of the parent\n+    /// scope.)\n+    ///\n+    /// Also: currently the table solely holds keys for node-ids of\n+    /// unfragmented values (see `FragmentInfo` enum definition), but\n+    /// longer-term we will need to also store mappings from\n+    /// fragmented data to the set of unfragmented pieces that\n+    /// constitute it.\n+    pub fragment_infos: RefCell<DefIdMap<Vec<ty::FragmentInfo>>>,\n+}\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n+        *self.tables.borrow().closure_kinds.get(&def_id).unwrap()\n+    }\n+\n+    pub fn closure_type(&self,\n+                        def_id: DefId,\n+                        substs: &ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n+    {\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n+    }\n+\n+    pub fn type_parameter_def(&self,\n+                              node_id: NodeId)\n+                              -> ty::TypeParameterDef<'tcx>\n+    {\n+        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n+    }\n+\n+    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+        fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n+            &tables.node_types\n+        }\n+\n+        Ref::map(self.tables.borrow(), projection)\n+    }\n+\n+    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+        self.tables.borrow_mut().node_types.insert(id, ty);\n+    }\n+\n+    pub fn intern_trait_def(&self, def: ty::TraitDef<'tcx>)\n+                            -> &'tcx ty::TraitDef<'tcx> {\n+        let did = def.trait_ref.def_id;\n+        let interned = self.arenas.trait_defs.alloc(def);\n+        self.trait_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n+    pub fn alloc_trait_def(&self, def: ty::TraitDef<'tcx>)\n+                           -> &'tcx ty::TraitDef<'tcx> {\n+        self.arenas.trait_defs.alloc(def)\n+    }\n+\n+    pub fn intern_adt_def(&self,\n+                          did: DefId,\n+                          kind: ty::AdtKind,\n+                          variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n+                          -> ty::AdtDefMaster<'tcx> {\n+        let def = ty::AdtDefData::new(self, did, kind, variants);\n+        let interned = self.arenas.adt_defs.alloc(def);\n+        // this will need a transmute when reverse-variance is removed\n+        self.adt_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n+    pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n+        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+            return st;\n+        }\n+\n+        let interned = self.arenas.stability.alloc(stab);\n+        self.stability_interner.borrow_mut().insert(interned, interned);\n+        interned\n+    }\n+\n+    pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n+        self.free_region_maps.borrow_mut()\n+                             .insert(id, map);\n+    }\n+\n+    pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n+        self.free_region_maps.borrow()[&id].clone()\n+    }\n+\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self)\n+    }\n+\n+    /// Create a type context and call the closure with a `&ty::ctxt` reference\n+    /// to the context. The closure enforces that the type context and any interned\n+    /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n+    /// reference to the context, to allow formatting values that need it.\n+    pub fn create_and_enter<F, R>(s: Session,\n+                                 arenas: &'tcx CtxtArenas<'tcx>,\n+                                 def_map: DefMap,\n+                                 named_region_map: resolve_lifetime::NamedRegionMap,\n+                                 map: ast_map::Map<'tcx>,\n+                                 freevars: RefCell<FreevarMap>,\n+                                 region_maps: RegionMaps,\n+                                 lang_items: middle::lang_items::LanguageItems,\n+                                 stability: stability::Index<'tcx>,\n+                                 f: F) -> (Session, R)\n+                                 where F: FnOnce(&ctxt<'tcx>) -> R\n+    {\n+        let interner = RefCell::new(FnvHashMap());\n+        let common_types = CommonTypes::new(&arenas.type_, &interner);\n+\n+        tls::enter(ctxt {\n+            arenas: arenas,\n+            interner: interner,\n+            substs_interner: RefCell::new(FnvHashMap()),\n+            bare_fn_interner: RefCell::new(FnvHashMap()),\n+            region_interner: RefCell::new(FnvHashMap()),\n+            stability_interner: RefCell::new(FnvHashMap()),\n+            types: common_types,\n+            named_region_map: named_region_map,\n+            region_maps: region_maps,\n+            free_region_maps: RefCell::new(FnvHashMap()),\n+            item_variance_map: RefCell::new(DefIdMap()),\n+            variance_computed: Cell::new(false),\n+            sess: s,\n+            def_map: def_map,\n+            tables: RefCell::new(Tables::empty()),\n+            impl_trait_refs: RefCell::new(DefIdMap()),\n+            trait_defs: RefCell::new(DefIdMap()),\n+            adt_defs: RefCell::new(DefIdMap()),\n+            predicates: RefCell::new(DefIdMap()),\n+            super_predicates: RefCell::new(DefIdMap()),\n+            fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n+            map: map,\n+            freevars: freevars,\n+            tcache: RefCell::new(DefIdMap()),\n+            rcache: RefCell::new(FnvHashMap()),\n+            tc_cache: RefCell::new(FnvHashMap()),\n+            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n+            impl_or_trait_items: RefCell::new(DefIdMap()),\n+            trait_item_def_ids: RefCell::new(DefIdMap()),\n+            trait_items_cache: RefCell::new(DefIdMap()),\n+            ty_param_defs: RefCell::new(NodeMap()),\n+            normalized_cache: RefCell::new(FnvHashMap()),\n+            lang_items: lang_items,\n+            provided_method_sources: RefCell::new(DefIdMap()),\n+            destructors: RefCell::new(DefIdSet()),\n+            inherent_impls: RefCell::new(DefIdMap()),\n+            impl_items: RefCell::new(DefIdMap()),\n+            used_unsafe: RefCell::new(NodeSet()),\n+            used_mut_nodes: RefCell::new(NodeSet()),\n+            populated_external_types: RefCell::new(DefIdSet()),\n+            populated_external_primitive_impls: RefCell::new(DefIdSet()),\n+            extern_const_statics: RefCell::new(DefIdMap()),\n+            extern_const_variants: RefCell::new(DefIdMap()),\n+            extern_const_fns: RefCell::new(DefIdMap()),\n+            node_lint_levels: RefCell::new(FnvHashMap()),\n+            transmute_restrictions: RefCell::new(Vec::new()),\n+            stability: RefCell::new(stability),\n+            selection_cache: traits::SelectionCache::new(),\n+            repr_hint_cache: RefCell::new(DefIdMap()),\n+            const_qualif_map: RefCell::new(NodeMap()),\n+            custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+            cast_kinds: RefCell::new(NodeMap()),\n+            fragment_infos: RefCell::new(DefIdMap()),\n+       }, f)\n+    }\n+}\n+\n+/// A trait implemented for all X<'a> types which can be safely and\n+/// efficiently converted to X<'tcx> as long as they are part of the\n+/// provided ty::ctxt<'tcx>.\n+/// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n+/// by looking them up in their respective interners.\n+/// None is returned if the value or one of the components is not part\n+/// of the provided context.\n+/// For Ty, None can be returned if either the type interner doesn't\n+/// contain the TypeVariants key or if the address of the interned\n+/// pointer differs. The latter case is possible if a primitive type,\n+/// e.g. `()` or `u8`, was interned in a different context.\n+pub trait Lift<'tcx> {\n+    type Lifted;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Self::Lifted>;\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n+    type Lifted = Ty<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<Ty<'tcx>> {\n+        if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n+            if *self as *const _ == ty as *const _ {\n+                return Some(ty);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n+    type Lifted = &'tcx Substs<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ctxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n+            if *self as *const _ == substs as *const _ {\n+                return Some(substs);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+\n+pub mod tls {\n+    use middle::ty;\n+    use session::Session;\n+\n+    use std::fmt;\n+    use syntax::codemap;\n+\n+    /// Marker type used for the scoped TLS slot.\n+    /// The type context cannot be used directly because the scoped TLS\n+    /// in libstd doesn't allow types generic over lifetimes.\n+    struct ThreadLocalTyCx;\n+\n+    scoped_thread_local!(static TLS_TCX: ThreadLocalTyCx);\n+\n+    fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n+        with(|tcx| {\n+            write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n+        })\n+    }\n+\n+    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n+                                                           -> (Session, R) {\n+        let result = codemap::SPAN_DEBUG.with(|span_dbg| {\n+            let original_span_debug = span_dbg.get();\n+            span_dbg.set(span_debug);\n+            let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n+            let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n+            span_dbg.set(original_span_debug);\n+            result\n+        });\n+        (tcx.sess, result)\n+    }\n+\n+    pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {\n+        TLS_TCX.with(|tcx| f(unsafe { &*(tcx as *const _ as *const ty::ctxt) }))\n+    }\n+\n+    pub fn with_opt<F: FnOnce(Option<&ty::ctxt>) -> R, R>(f: F) -> R {\n+        if TLS_TCX.is_set() {\n+            with(|v| f(Some(v)))\n+        } else {\n+            f(None)\n+        }\n+    }\n+}\n+\n+macro_rules! sty_debug_print {\n+    ($ctxt: expr, $($variant: ident),*) => {{\n+        // curious inner module to allow variant names to be used as\n+        // variable names.\n+        #[allow(non_snake_case)]\n+        mod inner {\n+            use middle::ty;\n+            #[derive(Copy, Clone)]\n+            struct DebugStat {\n+                total: usize,\n+                region_infer: usize,\n+                ty_infer: usize,\n+                both_infer: usize,\n+            }\n+\n+            pub fn go(tcx: &ty::ctxt) {\n+                let mut total = DebugStat {\n+                    total: 0,\n+                    region_infer: 0, ty_infer: 0, both_infer: 0,\n+                };\n+                $(let mut $variant = total;)*\n+\n+\n+                for (_, t) in tcx.interner.borrow().iter() {\n+                    let variant = match t.sty {\n+                        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n+                            ty::TyFloat(..) | ty::TyStr => continue,\n+                        ty::TyError => /* unimportant */ continue,\n+                        $(ty::$variant(..) => &mut $variant,)*\n+                    };\n+                    let region = t.flags.get().intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags.get().intersects(ty::TypeFlags::HAS_TY_INFER);\n+\n+                    variant.total += 1;\n+                    total.total += 1;\n+                    if region { total.region_infer += 1; variant.region_infer += 1 }\n+                    if ty { total.ty_infer += 1; variant.ty_infer += 1 }\n+                    if region && ty { total.both_infer += 1; variant.both_infer += 1 }\n+                }\n+                println!(\"Ty interner             total           ty region  both\");\n+                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                           stringify!($variant),\n+                           uses = $variant.total,\n+                           usespc = $variant.total as f64 * 100.0 / total.total as f64,\n+                           ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n+                           region = $variant.region_infer as f64 * 100.0  / total.total as f64,\n+                           both = $variant.both_infer as f64 * 100.0  / total.total as f64);\n+                  )*\n+                println!(\"                  total {uses:6}        \\\n+{ty:4.1}% {region:5.1}% {both:4.1}%\",\n+                         uses = total.total,\n+                         ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n+                         region = total.region_infer as f64 * 100.0  / total.total as f64,\n+                         both = total.both_infer as f64 * 100.0  / total.total as f64)\n+            }\n+        }\n+\n+        inner::go($ctxt)\n+    }}\n+}\n+\n+impl<'tcx> ctxt<'tcx> {\n+    pub fn print_debug_stats(&self) {\n+        sty_debug_print!(\n+            self,\n+            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyBareFn, TyTrait,\n+            TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n+\n+        println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n+        println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n+        println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n+        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n+    }\n+}\n+\n+\n+/// An entry in the type interner.\n+pub struct InternedTy<'tcx> {\n+    ty: Ty<'tcx>\n+}\n+\n+// NB: An InternedTy compares and hashes as a sty.\n+impl<'tcx> PartialEq for InternedTy<'tcx> {\n+    fn eq(&self, other: &InternedTy<'tcx>) -> bool {\n+        self.ty.sty == other.ty.sty\n+    }\n+}\n+\n+impl<'tcx> Eq for InternedTy<'tcx> {}\n+\n+impl<'tcx> Hash for InternedTy<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.ty.sty.hash(s)\n+    }\n+}\n+\n+impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n+    fn borrow<'a>(&'a self) -> &'a TypeVariants<'tcx> {\n+        &self.ty.sty\n+    }\n+}\n+\n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.is_empty() ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n+\n+impl<'tcx> ctxt<'tcx> {\n+    // Type constructors\n+    pub fn mk_substs(&self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n+        if let Some(substs) = self.substs_interner.borrow().get(&substs) {\n+            return *substs;\n+        }\n+\n+        let substs = self.arenas.substs.alloc(substs);\n+        self.substs_interner.borrow_mut().insert(substs, substs);\n+        substs\n+    }\n+\n+    /// Create an unsafe fn ty based on a safe fn ty.\n+    pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n+        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n+        let unsafe_fn_ty_a = self.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: bare_fn.abi,\n+            sig: bare_fn.sig.clone()\n+        });\n+        self.mk_fn(None, unsafe_fn_ty_a)\n+    }\n+\n+    pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n+        if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n+            return *bare_fn;\n+        }\n+\n+        let bare_fn = self.arenas.bare_fn.alloc(bare_fn);\n+        self.bare_fn_interner.borrow_mut().insert(bare_fn, bare_fn);\n+        bare_fn\n+    }\n+\n+    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n+        if let Some(region) = self.region_interner.borrow().get(&region) {\n+            return *region;\n+        }\n+\n+        let region = self.arenas.region.alloc(region);\n+        self.region_interner.borrow_mut().insert(region, region);\n+        region\n+    }\n+\n+    fn intern_ty(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n+                 interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+                 st: TypeVariants<'tcx>)\n+                 -> Ty<'tcx> {\n+        let ty: Ty /* don't be &mut TyS */ = {\n+            let mut interner = interner.borrow_mut();\n+            match interner.get(&st) {\n+                Some(ty) => return *ty,\n+                _ => ()\n+            }\n+\n+            let flags = super::flags::FlagComputation::for_sty(&st);\n+\n+            let ty = match () {\n+                () => type_arena.alloc(TyS { sty: st,\n+                                             flags: Cell::new(flags.flags),\n+                                             region_depth: flags.depth, }),\n+            };\n+\n+            interner.insert(InternedTy { ty: ty }, ty);\n+            ty\n+        };\n+\n+        debug!(\"Interned type: {:?} Pointer: {:?}\",\n+            ty, ty as *const TyS);\n+        ty\n+    }\n+\n+    // Interns a type/name combination, stores the resulting box in cx.interner,\n+    // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n+    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        ctxt::intern_ty(&self.arenas.type_, &self.interner, st)\n+    }\n+\n+    pub fn mk_mach_int(&self, tm: hir::IntTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyIs   => self.types.isize,\n+            hir::TyI8   => self.types.i8,\n+            hir::TyI16  => self.types.i16,\n+            hir::TyI32  => self.types.i32,\n+            hir::TyI64  => self.types.i64,\n+        }\n+    }\n+\n+    pub fn mk_mach_uint(&self, tm: hir::UintTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyUs   => self.types.usize,\n+            hir::TyU8   => self.types.u8,\n+            hir::TyU16  => self.types.u16,\n+            hir::TyU32  => self.types.u32,\n+            hir::TyU64  => self.types.u64,\n+        }\n+    }\n+\n+    pub fn mk_mach_float(&self, tm: hir::FloatTy) -> Ty<'tcx> {\n+        match tm {\n+            hir::TyF32  => self.types.f32,\n+            hir::TyF64  => self.types.f64,\n+        }\n+    }\n+\n+    pub fn mk_str(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyStr)\n+    }\n+\n+    pub fn mk_static_str(&self) -> Ty<'tcx> {\n+        self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n+    }\n+\n+    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyEnum(def, substs))\n+    }\n+\n+    pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBox(ty))\n+    }\n+\n+    pub fn mk_ptr(&self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRawPtr(tm))\n+    }\n+\n+    pub fn mk_ref(&self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyRef(r, tm))\n+    }\n+\n+    pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+    }\n+\n+    pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+    }\n+\n+    pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+    }\n+\n+    pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+    }\n+\n+    pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n+        self.mk_imm_ptr(self.mk_nil())\n+    }\n+\n+    pub fn mk_array(&self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+        self.mk_ty(TyArray(ty, n))\n+    }\n+\n+    pub fn mk_slice(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TySlice(ty))\n+    }\n+\n+    pub fn mk_tup(&self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n+        self.mk_ty(TyTuple(ts))\n+    }\n+\n+    pub fn mk_nil(&self) -> Ty<'tcx> {\n+        self.mk_tup(Vec::new())\n+    }\n+\n+    pub fn mk_bool(&self) -> Ty<'tcx> {\n+        self.mk_ty(TyBool)\n+    }\n+\n+    pub fn mk_fn(&self,\n+                 opt_def_id: Option<DefId>,\n+                 fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyBareFn(opt_def_id, fty))\n+    }\n+\n+    pub fn mk_ctor_fn(&self,\n+                      def_id: DefId,\n+                      input_tys: &[Ty<'tcx>],\n+                      output: Ty<'tcx>) -> Ty<'tcx> {\n+        let input_args = input_tys.iter().cloned().collect();\n+        self.mk_fn(Some(def_id), self.mk_bare_fn(BareFnTy {\n+            unsafety: hir::Unsafety::Normal,\n+            abi: abi::Rust,\n+            sig: ty::Binder(ty::FnSig {\n+                inputs: input_args,\n+                output: ty::FnConverging(output),\n+                variadic: false\n+            })\n+        }))\n+    }\n+\n+    pub fn mk_trait(&self,\n+                    principal: ty::PolyTraitRef<'tcx>,\n+                    bounds: ExistentialBounds<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        assert!(bound_list_is_sorted(&bounds.projection_bounds));\n+\n+        let inner = box TraitTy {\n+            principal: principal,\n+            bounds: bounds\n+        };\n+        self.mk_ty(TyTrait(inner))\n+    }\n+\n+    pub fn mk_projection(&self,\n+                         trait_ref: TraitRef<'tcx>,\n+                         item_name: Name)\n+                         -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+        self.mk_ty(TyProjection(inner))\n+    }\n+\n+    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyStruct(def, substs))\n+    }\n+\n+    pub fn mk_closure(&self,\n+                      closure_id: DefId,\n+                      substs: &'tcx Substs<'tcx>,\n+                      tys: Vec<Ty<'tcx>>)\n+                      -> Ty<'tcx> {\n+        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: tys\n+        }))\n+    }\n+\n+    pub fn mk_closure_from_closure_substs(&self,\n+                                          closure_id: DefId,\n+                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          -> Ty<'tcx> {\n+        self.mk_ty(TyClosure(closure_id, closure_substs))\n+    }\n+\n+    pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n+        self.mk_infer(TyVar(v))\n+    }\n+\n+    pub fn mk_int_var(&self, v: IntVid) -> Ty<'tcx> {\n+        self.mk_infer(IntVar(v))\n+    }\n+\n+    pub fn mk_float_var(&self, v: FloatVid) -> Ty<'tcx> {\n+        self.mk_infer(FloatVar(v))\n+    }\n+\n+    pub fn mk_infer(&self, it: InferTy) -> Ty<'tcx> {\n+        self.mk_ty(TyInfer(it))\n+    }\n+\n+    pub fn mk_param(&self,\n+                    space: subst::ParamSpace,\n+                    index: u32,\n+                    name: Name) -> Ty<'tcx> {\n+        self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n+    }\n+\n+    pub fn mk_self_type(&self) -> Ty<'tcx> {\n+        self.mk_param(subst::SelfSpace, 0, special_idents::type_self.name)\n+    }\n+\n+    pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+        self.mk_param(def.space, def.index, def.name)\n+    }\n+}"}, {"sha": "72c4366c5bcd5a8f189a1fef6080eed41527de69", "filename": "src/librustc/middle/ty/error.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ferror.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,342 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::def_id::DefId;\n+use middle::subst;\n+use middle::infer::type_variable;\n+use middle::ty::{self, BoundRegion, Region, Ty};\n+\n+use std::fmt;\n+use syntax::abi;\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+\n+use rustc_front::hir;\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct ExpectedFound<T> {\n+    pub expected: T,\n+    pub found: T\n+}\n+\n+// Data structures used in type unification\n+#[derive(Clone, Debug)]\n+pub enum TypeError<'tcx> {\n+    Mismatch,\n+    UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n+    AbiMismatch(ExpectedFound<abi::Abi>),\n+    Mutability,\n+    BoxMutability,\n+    PtrMutability,\n+    RefMutability,\n+    VecMutability,\n+    TupleSize(ExpectedFound<usize>),\n+    FixedArraySize(ExpectedFound<usize>),\n+    TyParamSize(ExpectedFound<usize>),\n+    ArgCount,\n+    RegionsDoesNotOutlive(Region, Region),\n+    RegionsNotSame(Region, Region),\n+    RegionsNoOverlap(Region, Region),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region),\n+    RegionsOverlyPolymorphic(BoundRegion, Region),\n+    Sorts(ExpectedFound<Ty<'tcx>>),\n+    IntegerAsChar,\n+    IntMismatch(ExpectedFound<ty::IntVarValue>),\n+    FloatMismatch(ExpectedFound<hir::FloatTy>),\n+    Traits(ExpectedFound<DefId>),\n+    BuiltinBoundsMismatch(ExpectedFound<ty::BuiltinBounds>),\n+    VariadicMismatch(ExpectedFound<bool>),\n+    CyclicTy,\n+    ConvergenceMismatch(ExpectedFound<bool>),\n+    ProjectionNameMismatched(ExpectedFound<Name>),\n+    ProjectionBoundsLength(ExpectedFound<usize>),\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n+pub enum UnconstrainedNumeric {\n+    UnconstrainedFloat,\n+    UnconstrainedInt,\n+    Neither,\n+}\n+\n+/// Explains the source of a type err in a short, human readable way. This is meant to be placed\n+/// in parentheses after some larger message. You should also invoke `note_and_explain_type_err()`\n+/// afterwards to present additional details, particularly when it comes to lifetime-related\n+/// errors.\n+impl<'tcx> fmt::Display for TypeError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::TypeError::*;\n+        fn report_maybe_different(f: &mut fmt::Formatter,\n+                                  expected: String, found: String) -> fmt::Result {\n+            // A naive approach to making sure that we're not reporting silly errors such as:\n+            // (expected closure, found closure).\n+            if expected == found {\n+                write!(f, \"expected {}, found a different {}\", expected, found)\n+            } else {\n+                write!(f, \"expected {}, found {}\", expected, found)\n+            }\n+        }\n+\n+        match *self {\n+            CyclicTy => write!(f, \"cyclic type of infinite size\"),\n+            Mismatch => write!(f, \"types differ\"),\n+            UnsafetyMismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            AbiMismatch(values) => {\n+                write!(f, \"expected {} fn, found {} fn\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            Mutability => write!(f, \"values differ in mutability\"),\n+            BoxMutability => {\n+                write!(f, \"boxed values differ in mutability\")\n+            }\n+            VecMutability => write!(f, \"vectors differ in mutability\"),\n+            PtrMutability => write!(f, \"pointers differ in mutability\"),\n+            RefMutability => write!(f, \"references differ in mutability\"),\n+            TyParamSize(values) => {\n+                write!(f, \"expected a type with {} type params, \\\n+                           found one with {} type params\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            FixedArraySize(values) => {\n+                write!(f, \"expected an array with a fixed size of {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            TupleSize(values) => {\n+                write!(f, \"expected a tuple with {} elements, \\\n+                           found one with {} elements\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            ArgCount => {\n+                write!(f, \"incorrect number of function parameters\")\n+            }\n+            RegionsDoesNotOutlive(..) => {\n+                write!(f, \"lifetime mismatch\")\n+            }\n+            RegionsNotSame(..) => {\n+                write!(f, \"lifetimes are not the same\")\n+            }\n+            RegionsNoOverlap(..) => {\n+                write!(f, \"lifetimes do not intersect\")\n+            }\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n+                write!(f, \"expected bound lifetime parameter {}, \\\n+                           found concrete lifetime\", br)\n+            }\n+            RegionsOverlyPolymorphic(br, _) => {\n+                write!(f, \"expected concrete lifetime, \\\n+                           found bound lifetime parameter {}\", br)\n+            }\n+            Sorts(values) => ty::tls::with(|tcx| {\n+                report_maybe_different(f, values.expected.sort_string(tcx),\n+                                       values.found.sort_string(tcx))\n+            }),\n+            Traits(values) => ty::tls::with(|tcx| {\n+                report_maybe_different(f,\n+                                       format!(\"trait `{}`\",\n+                                               tcx.item_path_str(values.expected)),\n+                                       format!(\"trait `{}`\",\n+                                               tcx.item_path_str(values.found)))\n+            }),\n+            BuiltinBoundsMismatch(values) => {\n+                if values.expected.is_empty() {\n+                    write!(f, \"expected no bounds, found `{}`\",\n+                           values.found)\n+                } else if values.found.is_empty() {\n+                    write!(f, \"expected bounds `{}`, found no bounds\",\n+                           values.expected)\n+                } else {\n+                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n+                           values.expected,\n+                           values.found)\n+                }\n+            }\n+            IntegerAsChar => {\n+                write!(f, \"expected an integral type, found `char`\")\n+            }\n+            IntMismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            FloatMismatch(ref values) => {\n+                write!(f, \"expected `{:?}`, found `{:?}`\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            VariadicMismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"variadic\" } else { \"non-variadic\" },\n+                       if values.found { \"variadic\" } else { \"non-variadic\" })\n+            }\n+            ConvergenceMismatch(ref values) => {\n+                write!(f, \"expected {} fn, found {} function\",\n+                       if values.expected { \"converging\" } else { \"diverging\" },\n+                       if values.found { \"converging\" } else { \"diverging\" })\n+            }\n+            ProjectionNameMismatched(ref values) => {\n+                write!(f, \"expected {}, found {}\",\n+                       values.expected,\n+                       values.found)\n+            }\n+            ProjectionBoundsLength(ref values) => {\n+                write!(f, \"expected {} associated type bindings, found {}\",\n+                       values.expected,\n+                       values.found)\n+            },\n+            TyParamDefaultMismatch(ref values) => {\n+                write!(f, \"conflicting type parameter defaults `{}` and `{}`\",\n+                       values.expected.ty,\n+                       values.found.ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> ty::TyS<'tcx> {\n+    fn sort_string(&self, cx: &ty::ctxt) -> String {\n+        match self.sty {\n+            ty::TyBool | ty::TyChar | ty::TyInt(_) |\n+            ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n+            ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n+\n+            ty::TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n+            ty::TyBox(_) => \"box\".to_string(),\n+            ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n+            ty::TySlice(_) => \"slice\".to_string(),\n+            ty::TyRawPtr(_) => \"*-ptr\".to_string(),\n+            ty::TyRef(_, _) => \"&-ptr\".to_string(),\n+            ty::TyBareFn(Some(_), _) => format!(\"fn item\"),\n+            ty::TyBareFn(None, _) => \"fn pointer\".to_string(),\n+            ty::TyTrait(ref inner) => {\n+                format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n+            }\n+            ty::TyStruct(def, _) => {\n+                format!(\"struct `{}`\", cx.item_path_str(def.did))\n+            }\n+            ty::TyClosure(..) => \"closure\".to_string(),\n+            ty::TyTuple(_) => \"tuple\".to_string(),\n+            ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),\n+            ty::TyInfer(ty::IntVar(_)) => \"integral variable\".to_string(),\n+            ty::TyInfer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n+            ty::TyInfer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n+            ty::TyInfer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+            ty::TyInfer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::TyProjection(_) => \"associated type\".to_string(),\n+            ty::TyParam(ref p) => {\n+                if p.space == subst::SelfSpace {\n+                    \"Self\".to_string()\n+                } else {\n+                    \"type parameter\".to_string()\n+                }\n+            }\n+            ty::TyError => \"type error\".to_string(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn note_and_explain_type_err(&self, err: &TypeError<'tcx>, sp: Span) {\n+        use self::TypeError::*;\n+\n+        match err.clone() {\n+            RegionsDoesNotOutlive(subregion, superregion) => {\n+                self.note_and_explain_region(\"\", subregion, \"...\");\n+                self.note_and_explain_region(\"...does not necessarily outlive \",\n+                                           superregion, \"\");\n+            }\n+            RegionsNotSame(region1, region2) => {\n+                self.note_and_explain_region(\"\", region1, \"...\");\n+                self.note_and_explain_region(\"...is not the same lifetime as \",\n+                                           region2, \"\");\n+            }\n+            RegionsNoOverlap(region1, region2) => {\n+                self.note_and_explain_region(\"\", region1, \"...\");\n+                self.note_and_explain_region(\"...does not overlap \",\n+                                           region2, \"\");\n+            }\n+            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n+                self.note_and_explain_region(\"concrete lifetime that was found is \",\n+                                           conc_region, \"\");\n+            }\n+            RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n+                // don't bother to print out the message below for\n+                // inference variables, it's not very illuminating.\n+            }\n+            RegionsOverlyPolymorphic(_, conc_region) => {\n+                self.note_and_explain_region(\"expected concrete lifetime is \",\n+                                           conc_region, \"\");\n+            }\n+            Sorts(values) => {\n+                let expected_str = values.expected.sort_string(self);\n+                let found_str = values.found.sort_string(self);\n+                if expected_str == found_str && expected_str == \"closure\" {\n+                    self.sess.span_note(sp,\n+                        &format!(\"no two closures, even if identical, have the same type\"));\n+                    self.sess.span_help(sp,\n+                        &format!(\"consider boxing your closure and/or \\\n+                                  using it as a trait object\"));\n+                }\n+            },\n+            TyParamDefaultMismatch(values) => {\n+                let expected = values.expected;\n+                let found = values.found;\n+                self.sess.span_note(sp,\n+                                    &format!(\"conflicting type parameter defaults `{}` and `{}`\",\n+                                             expected.ty,\n+                                             found.ty));\n+\n+                match (expected.def_id.is_local(),\n+                       self.map.opt_span(expected.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        self.sess.note(\n+                            &format!(\"a default is defined on `{}`\",\n+                                     self.item_path_str(expected.def_id)));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    expected.origin_span,\n+                    &format!(\"...that was applied to an unconstrained type variable here\"));\n+\n+                match (found.def_id.is_local(),\n+                       self.map.opt_span(found.def_id.node)) {\n+                    (true, Some(span)) => {\n+                        self.sess.span_note(span,\n+                                            &format!(\"a second default was defined here...\"));\n+                    }\n+                    (_, _) => {\n+                        self.sess.note(\n+                            &format!(\"a second default is defined on `{}`\",\n+                                     self.item_path_str(found.def_id)));\n+                    }\n+                }\n+\n+                self.sess.span_note(\n+                    found.origin_span,\n+                    &format!(\"...that also applies to the same type variable here\"));\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "94a50e3cac7f75e107ca416c40aab08fa71db2ba", "filename": "src/librustc/middle/ty/flags.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fflags.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst;\n+use middle::ty::{self, HasTypeFlags, Ty, TypeFlags};\n+\n+pub struct FlagComputation {\n+    pub flags: TypeFlags,\n+\n+    // maximum depth of any bound region that we have seen thus far\n+    pub depth: u32,\n+}\n+\n+impl FlagComputation {\n+    fn new() -> FlagComputation {\n+        FlagComputation { flags: TypeFlags::empty(), depth: 0 }\n+    }\n+\n+    pub fn for_sty(st: &ty::TypeVariants) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_sty(st);\n+        result\n+    }\n+\n+    fn add_flags(&mut self, flags: TypeFlags) {\n+        self.flags = self.flags | (flags & TypeFlags::NOMINAL_FLAGS);\n+    }\n+\n+    fn add_depth(&mut self, depth: u32) {\n+        if depth > self.depth {\n+            self.depth = depth;\n+        }\n+    }\n+\n+    /// Adds the flags/depth from a set of types that appear within the current type, but within a\n+    /// region binder.\n+    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+        self.add_flags(computation.flags);\n+\n+        // The types that contributed to `computation` occurred within\n+        // a region binder, so subtract one from the region depth\n+        // within when adding the depth to `self`.\n+        let depth = computation.depth;\n+        if depth > 0 {\n+            self.add_depth(depth - 1);\n+        }\n+    }\n+\n+    fn add_sty(&mut self, st: &ty::TypeVariants) {\n+        match st {\n+            &ty::TyBool |\n+            &ty::TyChar |\n+            &ty::TyInt(_) |\n+            &ty::TyFloat(_) |\n+            &ty::TyUint(_) |\n+            &ty::TyStr => {\n+            }\n+\n+            // You might think that we could just return TyError for\n+            // any type containing TyError as a component, and get\n+            // rid of the TypeFlags::HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // the exception of function types that return bot).\n+            // But doing so caused sporadic memory corruption, and\n+            // neither I (tjc) nor nmatsakis could figure out why,\n+            // so we're doing it this way.\n+            &ty::TyError => {\n+                self.add_flags(TypeFlags::HAS_TY_ERR)\n+            }\n+\n+            &ty::TyParam(ref p) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                if p.space == subst::SelfSpace {\n+                    self.add_flags(TypeFlags::HAS_SELF);\n+                } else {\n+                    self.add_flags(TypeFlags::HAS_PARAMS);\n+                }\n+            }\n+\n+            &ty::TyClosure(_, ref substs) => {\n+                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+                self.add_substs(&substs.func_substs);\n+                self.add_tys(&substs.upvar_tys);\n+            }\n+\n+            &ty::TyInfer(_) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n+                self.add_flags(TypeFlags::HAS_TY_INFER)\n+            }\n+\n+            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n+                self.add_substs(substs);\n+            }\n+\n+            &ty::TyProjection(ref data) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_projection_ty(data);\n+            }\n+\n+            &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(principal.0.substs);\n+                for projection_bound in &bounds.projection_bounds {\n+                    let mut proj_computation = FlagComputation::new();\n+                    proj_computation.add_projection_predicate(&projection_bound.0);\n+                    self.add_bound_computation(&proj_computation);\n+                }\n+                self.add_bound_computation(&computation);\n+\n+                self.add_bounds(bounds);\n+            }\n+\n+            &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n+                self.add_ty(tt)\n+            }\n+\n+            &ty::TyRawPtr(ref m) => {\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty::TyRef(r, ref m) => {\n+                self.add_region(*r);\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty::TyTuple(ref ts) => {\n+                self.add_tys(&ts[..]);\n+            }\n+\n+            &ty::TyBareFn(_, ref f) => {\n+                self.add_fn_sig(&f.sig);\n+            }\n+        }\n+    }\n+\n+    fn add_ty(&mut self, ty: Ty) {\n+        self.add_flags(ty.flags.get());\n+        self.add_depth(ty.region_depth);\n+    }\n+\n+    fn add_tys(&mut self, tys: &[Ty]) {\n+        for &ty in tys {\n+            self.add_ty(ty);\n+        }\n+    }\n+\n+    fn add_fn_sig(&mut self, fn_sig: &ty::PolyFnSig) {\n+        let mut computation = FlagComputation::new();\n+\n+        computation.add_tys(&fn_sig.0.inputs);\n+\n+        if let ty::FnConverging(output) = fn_sig.0.output {\n+            computation.add_ty(output);\n+        }\n+\n+        self.add_bound_computation(&computation);\n+    }\n+\n+    fn add_region(&mut self, r: ty::Region) {\n+        match r {\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n+            ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n+            ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n+            ty::ReStatic => {}\n+            _ => { self.add_flags(TypeFlags::HAS_FREE_REGIONS); }\n+        }\n+\n+        if !r.is_global() {\n+            self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+        }\n+    }\n+\n+    fn add_projection_predicate(&mut self, projection_predicate: &ty::ProjectionPredicate) {\n+        self.add_projection_ty(&projection_predicate.projection_ty);\n+        self.add_ty(projection_predicate.ty);\n+    }\n+\n+    fn add_projection_ty(&mut self, projection_ty: &ty::ProjectionTy) {\n+        self.add_substs(projection_ty.trait_ref.substs);\n+    }\n+\n+    fn add_substs(&mut self, substs: &subst::Substs) {\n+        self.add_tys(substs.types.as_slice());\n+        match substs.regions {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n+                for &r in regions {\n+                    self.add_region(r);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_bounds(&mut self, bounds: &ty::ExistentialBounds) {\n+        self.add_region(bounds.region_bound);\n+    }\n+}"}, {"sha": "9de58369a63f8c68cff6276b6cb7f91261b1bd0b", "filename": "src/librustc/middle/ty/fold.rs", "status": "modified", "additions": 124, "deletions": 461, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ffold.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -34,16 +34,11 @@\n //! If you ever *do* need an override that doesn't exist, it's not hard\n //! to convert the degenerate pattern into the proper thing.\n \n+use middle::region;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n-use middle::ty::{self, Ty, HasTypeFlags, RegionEscape};\n-use middle::traits;\n+use middle::ty::{self, Binder, Ty, HasTypeFlags, RegionEscape};\n \n use std::fmt;\n-use std::rc::Rc;\n-use syntax::abi;\n-use rustc_front::hir;\n-use syntax::owned_slice::OwnedSlice;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -74,7 +69,7 @@ pub trait TypeFolder<'tcx> : Sized {\n     /// track the Debruijn index nesting level.\n     fn exit_region_binder(&mut self) { }\n \n-    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n     {\n         // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n@@ -142,428 +137,18 @@ pub trait TypeFolder<'tcx> : Sized {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n-//\n-// Ideally, each type should invoke `folder.fold_foo(self)` and\n-// nothing else. In some cases, though, we haven't gotten around to\n-// adding methods on the `folder` yet, and thus the folding is\n-// hard-coded here. This is less-flexible, because folders cannot\n-// override the behavior, but there are a lot of random types and one\n-// can easily refactor the folding into the TypeFolder trait as\n-// needed.\n-\n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n-        $(\n-            impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n-                    *self\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CopyImpls! { (), hir::Unsafety, abi::Abi }\n-\n-impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n-        (self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n-        Rc::new((**self).fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n-        let content: T = (**self).fold_with(folder);\n-        box content\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n-        folder.fold_binder(self)\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n-\n-        // Things in the Fn space take place under an additional level\n-        // of region binding relative to the other spaces. This is\n-        // because those entries are attached to a method, and methods\n-        // always introduce a level of region binding.\n-\n-        let result = self.map_enumerated(|(space, index, elem)| {\n-            if space == subst::FnSpace && index == 0 {\n-                // enter new level when/if we reach the first thing in fn space\n-                folder.enter_region_binder();\n-            }\n-            elem.fold_with(folder)\n-        });\n-        if result.len(subst::FnSpace) > 0 {\n-            // if there was anything in fn space, exit the region binding level\n-            folder.exit_region_binder();\n-        }\n-        result\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n-        folder.fold_ty(*self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n-        folder.fold_bare_fn_ty(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n-        folder.fold_closure_ty(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeAndMut<'tcx> {\n-        folder.fold_mt(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n-        folder.fold_output(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n-        folder.fold_fn_sig(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n-        folder.fold_trait_ref(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n-        folder.fold_region(*self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n-        folder.fold_substs(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n-        let func_substs = self.func_substs.fold_with(folder);\n-        ty::ClosureSubsts {\n-            func_substs: folder.tcx().mk_substs(func_substs),\n-            upvar_tys: self.upvar_tys.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n-        ty::ItemSubsts {\n-            substs: self.substs.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n-        folder.fold_autoref(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n-        *self\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n-        folder.fold_existential_bounds(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n-        ty::TypeParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            space: self.space,\n-            index: self.index,\n-            default: self.default.fold_with(folder),\n-            default_def_id: self.default_def_id,\n-            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ObjectLifetimeDefault {\n-        match *self {\n-            ty::ObjectLifetimeDefault::Ambiguous =>\n-                ty::ObjectLifetimeDefault::Ambiguous,\n-\n-            ty::ObjectLifetimeDefault::BaseDefault =>\n-                ty::ObjectLifetimeDefault::BaseDefault,\n-\n-            ty::ObjectLifetimeDefault::Specific(r) =>\n-                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n-        ty::RegionParameterDef {\n-            name: self.name,\n-            def_id: self.def_id,\n-            space: self.space,\n-            index: self.index,\n-            bounds: self.bounds.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n-        ty::Generics {\n-            types: self.types.fold_with(folder),\n-            regions: self.regions.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n-        ty::GenericPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Predicate<'tcx> {\n-        match *self {\n-            ty::Predicate::Trait(ref a) =>\n-                ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Equate(ref binder) =>\n-                ty::Predicate::Equate(binder.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref binder) =>\n-                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref binder) =>\n-                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n-            ty::Predicate::Projection(ref binder) =>\n-                ty::Predicate::Projection(binder.fold_with(folder)),\n-            ty::Predicate::WellFormed(data) =>\n-                ty::Predicate::WellFormed(data.fold_with(folder)),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::Predicate::ObjectSafe(trait_def_id),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n-        ty::ProjectionPredicate {\n-            projection_ty: self.projection_ty.fold_with(folder),\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n-        ty::ProjectionTy {\n-            trait_ref: self.trait_ref.fold_with(folder),\n-            item_name: self.item_name,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n-        ty::InstantiatedPredicates {\n-            predicates: self.predicates.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n-    where O : TypeFoldable<'tcx>\n-{\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n-        traits::VtableImplData {\n-            impl_def_id: self.impl_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n-        traits::VtableClosureData {\n-            closure_def_id: self.closure_def_id,\n-            substs: self.substs.fold_with(folder),\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n-        traits::VtableDefaultImplData {\n-            trait_def_id: self.trait_def_id,\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n-        traits::VtableBuiltinData {\n-            nested: self.nested.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n-        match *self {\n-            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n-            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n-            traits::VtableClosure(ref d) => {\n-                traits::VtableClosure(d.fold_with(folder))\n-            }\n-            traits::VtableFnPointer(ref d) => {\n-                traits::VtableFnPointer(d.fold_with(folder))\n-            }\n-            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n-            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n-            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n-        traits::VtableObjectData {\n-            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n-        ty::EquatePredicate(self.0.fold_with(folder),\n-                            self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n-        ty::TraitPredicate {\n-            trait_ref: self.trait_ref.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n-    where T : TypeFoldable<'tcx>,\n-          U : TypeFoldable<'tcx>,\n-{\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n-        ty::OutlivesPredicate(self.0.fold_with(folder),\n-                              self.1.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n-        ty::ClosureUpvar {\n-            def: self.def,\n-            span: self.span,\n-            ty: self.ty.fold_with(folder),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParameterEnvironment<'a, 'tcx> {\n-        ty::ParameterEnvironment {\n-            tcx: self.tcx,\n-            free_substs: self.free_substs.fold_with(folder),\n-            implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n-            caller_bounds: self.caller_bounds.fold_with(folder),\n-            selection_cache: traits::SelectionCache::new(),\n-            free_id: self.free_id,\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n \n pub fn super_fold_binder<'tcx, T, U>(this: &mut T,\n-                                     binder: &ty::Binder<U>)\n-                                     -> ty::Binder<U>\n+                                     binder: &Binder<U>)\n+                                     -> Binder<U>\n     where T : TypeFolder<'tcx>, U : TypeFoldable<'tcx>\n {\n     this.enter_region_binder();\n-    let result = ty::Binder(binder.0.fold_with(this));\n+    let result = Binder(binder.0.fold_with(this));\n     this.exit_region_binder();\n     result\n }\n@@ -754,6 +339,36 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n+impl<'tcx> ty::ctxt<'tcx> {\n+    /// Collects the free and escaping regions in `value` into `region_set`. Returns\n+    /// whether any late-bound regions were skipped\n+    pub fn collect_regions<T>(&self,\n+        value: &T,\n+        region_set: &mut FnvHashSet<ty::Region>)\n+        -> bool\n+        where T : TypeFoldable<'tcx>\n+    {\n+        let mut have_bound_regions = false;\n+        self.fold_regions(value, &mut have_bound_regions,\n+                          |r, d| { region_set.insert(r.from_depth(d)); r });\n+        have_bound_regions\n+    }\n+\n+    /// Folds the escaping and free regions in `value` using `f`, and\n+    /// sets `skipped_regions` to true if any late-bound region was found\n+    /// and skipped.\n+    pub fn fold_regions<T,F>(&self,\n+        value: &T,\n+        skipped_regions: &mut bool,\n+        mut f: F)\n+        -> T\n+        where F : FnMut(ty::Region, u32) -> ty::Region,\n+              T : TypeFoldable<'tcx>,\n+    {\n+        value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n+    }\n+}\n+\n /// Folds over the substructure of a type, visiting its component\n /// types and all regions that occur *free* within it.\n ///\n@@ -785,33 +400,6 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-/// Collects the free and escaping regions in `value` into `region_set`. Returns\n-/// whether any late-bound regions were skipped\n-pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n-                               value: &T,\n-                               region_set: &mut FnvHashSet<ty::Region>) -> bool\n-    where T : TypeFoldable<'tcx>\n-{\n-    let mut have_bound_regions = false;\n-    fold_regions(tcx, value, &mut have_bound_regions,\n-                 |r, d| { region_set.insert(r.from_depth(d)); r });\n-    have_bound_regions\n-}\n-\n-/// Folds the escaping and free regions in `value` using `f`, and\n-/// sets `skipped_regions` to true if any late-bound region was found\n-/// and skipped.\n-pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n-                              value: &T,\n-                              skipped_regions: &mut bool,\n-                              mut f: F)\n-                              -> T\n-    where F : FnMut(ty::Region, u32) -> ty::Region,\n-          T : TypeFoldable<'tcx>,\n-{\n-    value.fold_with(&mut RegionFolder::new(tcx, skipped_regions, &mut f))\n-}\n-\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n@@ -853,6 +441,94 @@ struct RegionReplacer<'a, 'tcx: 'a> {\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn replace_late_bound_regions<T,F>(&self,\n+        value: &Binder<T>,\n+        mut f: F)\n+        -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n+        where F : FnMut(ty::BoundRegion) -> ty::Region,\n+              T : TypeFoldable<'tcx>,\n+    {\n+        debug!(\"replace_late_bound_regions({:?})\", value);\n+        let mut replacer = RegionReplacer::new(self, &mut f);\n+        let result = value.skip_binder().fold_with(&mut replacer);\n+        (result, replacer.map)\n+    }\n+\n+\n+    /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n+    /// `scope_id`.\n+    pub fn liberate_late_bound_regions<T>(&self,\n+        all_outlive_scope: region::CodeExtent,\n+        value: &Binder<T>)\n+        -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.replace_late_bound_regions(value, |br| {\n+            ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})\n+        }).0\n+    }\n+\n+    /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+    /// becomes `for<'a,'b> Foo`.\n+    pub fn flatten_late_bound_regions<T>(&self, bound2_value: &Binder<Binder<T>>)\n+                                         -> Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        let bound0_value = bound2_value.skip_binder().skip_binder();\n+        let value = self.fold_regions(bound0_value, &mut false,\n+                                      |region, current_depth| {\n+            match region {\n+                ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n+                    // should be true if no escaping regions from bound2_value\n+                    assert!(debruijn.depth - current_depth <= 1);\n+                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br)\n+                }\n+                _ => {\n+                    region\n+                }\n+            }\n+        });\n+        Binder(value)\n+    }\n+\n+    pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n+        where T : TypeFoldable<'tcx> + RegionEscape\n+    {\n+        if value.0.has_escaping_regions() {\n+            None\n+        } else {\n+            Some(value.0.clone())\n+        }\n+    }\n+\n+    /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n+    /// method lookup and a few other places where precise region relationships are not required.\n+    pub fn erase_late_bound_regions<T>(&self, value: &Binder<T>) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        self.replace_late_bound_regions(value, |_| ty::ReStatic).0\n+    }\n+\n+    /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n+    /// assigned starting at 1 and increasing monotonically in the order traversed\n+    /// by the fold operation.\n+    ///\n+    /// The chief purpose of this function is to canonicalize regions so that two\n+    /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n+    /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+    /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n+    pub fn anonymize_late_bound_regions<T>(&self, sig: &Binder<T>) -> Binder<T>\n+        where T : TypeFoldable<'tcx>,\n+    {\n+        let mut counter = 0;\n+        Binder(self.replace_late_bound_regions(sig, |_| {\n+            counter += 1;\n+            ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter))\n+        }).0)\n+    }\n+}\n+\n impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n@@ -866,19 +542,6 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     }\n }\n \n-pub fn replace_late_bound_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n-                                            value: &ty::Binder<T>,\n-                                            mut f: F)\n-                                            -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n-    where F : FnMut(ty::BoundRegion) -> ty::Region,\n-          T : TypeFoldable<'tcx>,\n-{\n-    debug!(\"replace_late_bound_regions({:?})\", value);\n-    let mut replacer = RegionReplacer::new(tcx, &mut f);\n-    let result = value.skip_binder().fold_with(&mut replacer);\n-    (result, replacer.map)\n-}\n-\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }"}, {"sha": "73d567d0acf40aeb846b8a236456e1147b0bb128", "filename": "src/librustc/middle/ty/ivar.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fivar.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{Ty, TyS};\n+\n+use rustc_data_structures::ivar;\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+use core::nonzero::NonZero;\n+\n+/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n+/// on the lifetime of the IVar. This is required because of variance\n+/// problems: the IVar needs to be variant with respect to 'tcx (so\n+/// it can be referred to from Ty) but can only be modified if its\n+/// lifetime is exactly 'tcx.\n+///\n+/// Safety invariants:\n+///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n+///     (B) no aliases to this value with a 'tcx longer than this\n+///         value's 'lt exist\n+///\n+/// NonZero is used rather than Unique because Unique isn't Copy.\n+pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n+                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n+\n+impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        // Invariant (A) satisfied because the IVar is unfulfilled\n+        // Invariant (B) because 'lt : 'tcx\n+        TyIVar(ivar::Ivar::new(), PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> Option<Ty<'tcx>> {\n+        match self.0.get() {\n+            None => None,\n+            // valid because of invariant (A)\n+            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n+        }\n+    }\n+    #[inline]\n+    pub fn unwrap(&self) -> Ty<'tcx> {\n+        self.get().unwrap()\n+    }\n+\n+    pub fn fulfill(&self, value: Ty<'lt>) {\n+        // Invariant (A) is fulfilled, because by (B), every alias\n+        // of this has a 'tcx longer than 'lt.\n+        let value: *const TyS<'lt> = value;\n+        // FIXME(27214): unneeded [as *const ()]\n+        let value = value as *const () as *const TyS<'static>;\n+        self.0.fulfill(unsafe { NonZero::new(value) })\n+    }\n+}\n+\n+impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            Some(val) => write!(f, \"TyIVar({:?})\", val),\n+            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n+        }\n+    }\n+}"}, {"sha": "ab1160d7deb02292d1a7c4bc57713c29e21feea7", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 125, "deletions": 3623, "changes": 3748, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c"}, {"sha": "ff0a9789cf1f8cad49abd0d1654c9a1a7ec40b82", "filename": "src/librustc/middle/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Frelate.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -15,13 +15,14 @@\n \n use middle::def_id::DefId;\n use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n-use middle::ty::{self, HasTypeFlags, Ty, TypeError};\n+use middle::ty::{self, HasTypeFlags, Ty};\n+use middle::ty::error::{ExpectedFound, TypeError};\n use middle::ty::fold::TypeFoldable;\n use std::rc::Rc;\n use syntax::abi;\n use rustc_front::hir as ast;\n \n-pub type RelateResult<'tcx, T> = Result<T, ty::TypeError<'tcx>>;\n+pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n #[derive(Clone, Debug)]\n pub enum Cause {\n@@ -662,7 +663,7 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n                                       a: &T,\n                                       b: &T)\n-                                      -> ty::ExpectedFound<T>\n+                                      -> ExpectedFound<T>\n     where R: TypeRelation<'a,'tcx>, T: Clone\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n@@ -671,14 +672,14 @@ pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n pub fn expected_found_bool<T>(a_is_expected: bool,\n                               a: &T,\n                               b: &T)\n-                              -> ty::ExpectedFound<T>\n+                              -> ExpectedFound<T>\n     where T: Clone\n {\n     let a = a.clone();\n     let b = b.clone();\n     if a_is_expected {\n-        ty::ExpectedFound {expected: a, found: b}\n+        ExpectedFound {expected: a, found: b}\n     } else {\n-        ty::ExpectedFound {expected: b, found: a}\n+        ExpectedFound {expected: b, found: a}\n     }\n }"}, {"sha": "55d064844b13d381c79e430d13cf239d5e6aad15", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "added", "additions": 895, "deletions": 0, "changes": 895, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,895 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst::{self, VecPerParamSpace};\n+use middle::traits;\n+use middle::ty::{self, TraitRef, Ty, TypeAndMut};\n+use middle::ty::{HasTypeFlags, Lift, TypeFlags, RegionEscape};\n+use middle::ty::fold::{TypeFoldable, TypeFolder};\n+\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::owned_slice::OwnedSlice;\n+\n+use rustc_front::hir;\n+\n+// FIXME(#20298) -- all of these traits basically walk various\n+// structures to test whether types/regions are reachable with various\n+// properties. It should be possible to express them in terms of one\n+// common \"walker\" trait or something.\n+\n+impl<'tcx> RegionEscape for Ty<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_depth > depth\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TraitTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.principal.has_regions_escaping_depth(depth) ||\n+            self.bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ExistentialBounds<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.region_bound.has_regions_escaping_depth(depth) ||\n+            self.projection_bounds.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::Substs<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.types.has_regions_escaping_depth(depth) ||\n+            self.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ClosureSubsts<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.func_substs.has_regions_escaping_depth(depth) ||\n+            self.upvar_tys.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<T:RegionEscape> RegionEscape for Vec<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::FnSig<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.inputs.has_regions_escaping_depth(depth) ||\n+            self.output.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.iter_enumerated().any(|(space, _, t)| {\n+            if space == subst::FnSpace {\n+                t.has_regions_escaping_depth(depth+1)\n+            } else {\n+                t.has_regions_escaping_depth(depth)\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TypeScheme<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl RegionEscape for ty::Region {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.escapes_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::GenericPredicates<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicates.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::Predicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::Equate(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::RegionOutlives(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::TypeOutlives(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::Projection(ref data) => data.has_regions_escaping_depth(depth),\n+            ty::Predicate::WellFormed(ty) => ty.has_regions_escaping_depth(depth),\n+            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx,P:RegionEscape> RegionEscape for traits::Obligation<'tcx,P> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.predicate.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for TraitRef<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) ||\n+            self.substs.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for subst::RegionSubsts {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => {\n+                r.iter().any(|t| t.has_regions_escaping_depth(depth))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for ty::Binder<T> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth + 1)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::FnOutput<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::FnConverging(t) => t.has_regions_escaping_depth(depth),\n+            ty::FnDiverging => false\n+        }\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::EquatePredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::TraitPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<T:RegionEscape,U:RegionEscape> RegionEscape for ty::OutlivesPredicate<T,U> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ProjectionPredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.projection_ty.has_regions_escaping_depth(depth) ||\n+            self.ty.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for ty::ProjectionTy<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.trait_ref.has_regions_escaping_depth(depth)\n+    }\n+}\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for Vec<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self[..].has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for [T] {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n+    }\n+}\n+\n+impl<'tcx,T:HasTypeFlags> HasTypeFlags for VecPerParamSpace<T> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|p| p.has_type_flags(flags))\n+    }\n+}\n+\n+impl HasTypeFlags for abi::Abi {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl HasTypeFlags for hir::Unsafety {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl HasTypeFlags for ty::BuiltinBounds {\n+    fn has_type_flags(&self, _flags: TypeFlags) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureUpvar<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ExistentialBounds<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.projection_bounds.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::InstantiatedPredicates<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.predicates.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::Predicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::Equate(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::RegionOutlives(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::TypeOutlives(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::Projection(ref data) => data.has_type_flags(flags),\n+            ty::Predicate::WellFormed(data) => data.has_type_flags(flags),\n+            ty::Predicate::ObjectSafe(_trait_def_id) => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::TraitPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::EquatePredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n+    }\n+}\n+\n+impl HasTypeFlags for ty::Region {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        if flags.intersects(TypeFlags::HAS_LOCAL_NAMES) {\n+            // does this represent a region that cannot be named in a global\n+            // way? used in fulfillment caching.\n+            match *self {\n+                ty::ReStatic | ty::ReEmpty => {}\n+                _ => return true\n+            }\n+        }\n+        if flags.intersects(TypeFlags::HAS_RE_INFER) {\n+            match *self {\n+                ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n+                _ => {}\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl<T:HasTypeFlags,U:HasTypeFlags> HasTypeFlags for ty::OutlivesPredicate<T,U> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags) || self.1.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ProjectionPredicate<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.projection_ty.has_type_flags(flags) || self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ProjectionTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.trait_ref.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for Ty<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.flags.get().intersects(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for TypeAndMut<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.ty.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for TraitRef<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.substs.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for subst::Substs<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.types.has_type_flags(flags) || match self.regions {\n+            subst::ErasedRegions => false,\n+            subst::NonerasedRegions(ref r) => r.has_type_flags(flags)\n+        }\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Option<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Rc<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx,T> HasTypeFlags for Box<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        (**self).has_type_flags(flags)\n+    }\n+}\n+\n+impl<T> HasTypeFlags for ty::Binder<T>\n+    where T : HasTypeFlags\n+{\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.0.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::FnOutput<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        match *self {\n+            ty::FnConverging(t) => t.has_type_flags(flags),\n+            ty::FnDiverging => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::FnSig<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.inputs.iter().any(|t| t.has_type_flags(flags)) ||\n+            self.output.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::BareFnTy<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.sig.has_type_flags(flags)\n+    }\n+}\n+\n+impl<'tcx> HasTypeFlags for ty::ClosureSubsts<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.func_substs.has_type_flags(flags) ||\n+            self.upvar_tys.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n+    type Lifted = (A::Lifted, B::Lifted);\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        let mut result = Vec::with_capacity(self.len());\n+        for x in self {\n+            if let Some(value) = tcx.lift(x) {\n+                result.push(value);\n+            } else {\n+                return None;\n+            }\n+        }\n+        Some(result)\n+    }\n+}\n+\n+impl<'tcx> Lift<'tcx> for ty::Region {\n+    type Lifted = Self;\n+    fn lift_to_tcx(&self, _: &ty::ctxt<'tcx>) -> Option<ty::Region> {\n+        Some(*self)\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n+    type Lifted = TraitRef<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+        tcx.lift(&self.substs).map(|substs| TraitRef {\n+            def_id: self.def_id,\n+            substs: substs\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n+    type Lifted = ty::TraitPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n+            trait_ref: trait_ref\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n+    type Lifted = ty::EquatePredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n+    }\n+}\n+\n+impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n+    type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n+    type Lifted = ty::ProjectionPredicate<'tcx>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+            ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: self.projection_ty.item_name\n+                },\n+                ty: ty\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n+    type Lifted = ty::Binder<T::Lifted>;\n+    fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.0).map(|x| ty::Binder(x))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+//\n+// Ideally, each type should invoke `folder.fold_foo(self)` and\n+// nothing else. In some cases, though, we haven't gotten around to\n+// adding methods on the `folder` yet, and thus the folding is\n+// hard-coded here. This is less-flexible, because folders cannot\n+// override the behavior, but there are a lot of random types and one\n+// can easily refactor the folding into the TypeFolder trait as\n+// needed.\n+\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+CopyImpls! { (), hir::Unsafety, abi::Abi }\n+\n+impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n+        self.as_ref().map(|t| t.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+        Rc::new((**self).fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Box<T> {\n+        let content: T = (**self).fold_with(folder);\n+        box content\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Vec<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        folder.fold_binder(self)\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for OwnedSlice<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n+}\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n+\n+        // Things in the Fn space take place under an additional level\n+        // of region binding relative to the other spaces. This is\n+        // because those entries are attached to a method, and methods\n+        // always introduce a level of region binding.\n+\n+        let result = self.map_enumerated(|(space, index, elem)| {\n+            if space == subst::FnSpace && index == 0 {\n+                // enter new level when/if we reach the first thing in fn space\n+                folder.enter_region_binder();\n+            }\n+            elem.fold_with(folder)\n+        });\n+        if result.len(subst::FnSpace) > 0 {\n+            // if there was anything in fn space, exit the region binding level\n+            folder.exit_region_binder();\n+        }\n+        result\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n+        folder.fold_ty(*self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::BareFnTy<'tcx> {\n+        folder.fold_bare_fn_ty(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureTy<'tcx> {\n+        folder.fold_closure_ty(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeAndMut<'tcx> {\n+        folder.fold_mt(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnOutput<'tcx> {\n+        folder.fold_output(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n+        folder.fold_fn_sig(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n+        folder.fold_trait_ref(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n+        folder.fold_region(*self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> subst::Substs<'tcx> {\n+        folder.fold_substs(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n+        let func_substs = self.func_substs.fold_with(folder);\n+        ty::ClosureSubsts {\n+            func_substs: folder.tcx().mk_substs(func_substs),\n+            upvar_tys: self.upvar_tys.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n+        ty::ItemSubsts {\n+            substs: self.substs.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::AutoRef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::AutoRef<'tcx> {\n+        folder.fold_autoref(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n+        *self\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ExistentialBounds<'tcx> {\n+        folder.fold_existential_bounds(self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TypeParameterDef<'tcx> {\n+        ty::TypeParameterDef {\n+            name: self.name,\n+            def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n+            default: self.default.fold_with(folder),\n+            default_def_id: self.default_def_id,\n+            object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ObjectLifetimeDefault {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Ambiguous =>\n+                ty::ObjectLifetimeDefault::Ambiguous,\n+\n+            ty::ObjectLifetimeDefault::BaseDefault =>\n+                ty::ObjectLifetimeDefault::BaseDefault,\n+\n+            ty::ObjectLifetimeDefault::Specific(r) =>\n+                ty::ObjectLifetimeDefault::Specific(r.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::RegionParameterDef {\n+        ty::RegionParameterDef {\n+            name: self.name,\n+            def_id: self.def_id,\n+            space: self.space,\n+            index: self.index,\n+            bounds: self.bounds.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Generics<'tcx> {\n+        ty::Generics {\n+            types: self.types.fold_with(folder),\n+            regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n+        ty::GenericPredicates {\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Predicate<'tcx> {\n+        match *self {\n+            ty::Predicate::Trait(ref a) =>\n+                ty::Predicate::Trait(a.fold_with(folder)),\n+            ty::Predicate::Equate(ref binder) =>\n+                ty::Predicate::Equate(binder.fold_with(folder)),\n+            ty::Predicate::RegionOutlives(ref binder) =>\n+                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n+            ty::Predicate::TypeOutlives(ref binder) =>\n+                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n+            ty::Predicate::Projection(ref binder) =>\n+                ty::Predicate::Projection(binder.fold_with(folder)),\n+            ty::Predicate::WellFormed(data) =>\n+                ty::Predicate::WellFormed(data.fold_with(folder)),\n+            ty::Predicate::ObjectSafe(trait_def_id) =>\n+                ty::Predicate::ObjectSafe(trait_def_id),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: self.projection_ty.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ProjectionTy<'tcx> {\n+        ty::ProjectionTy {\n+            trait_ref: self.trait_ref.fold_with(folder),\n+            item_name: self.item_name,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n+        ty::InstantiatedPredicates {\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n+    where O : TypeFoldable<'tcx>\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation<'tcx, O> {\n+        traits::Obligation {\n+            cause: self.cause.clone(),\n+            recursion_depth: self.recursion_depth,\n+            predicate: self.predicate.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<'tcx, N> {\n+        traits::VtableImplData {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n+        traits::VtableClosureData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n+        traits::VtableDefaultImplData {\n+            trait_def_id: self.trait_def_id,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n+        traits::VtableBuiltinData {\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n+        match *self {\n+            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n+            traits::VtableClosure(ref d) => {\n+                traits::VtableClosure(d.fold_with(folder))\n+            }\n+            traits::VtableFnPointer(ref d) => {\n+                traits::VtableFnPointer(d.fold_with(folder))\n+            }\n+            traits::VtableParam(ref n) => traits::VtableParam(n.fold_with(folder)),\n+            traits::VtableBuiltin(ref d) => traits::VtableBuiltin(d.fold_with(folder)),\n+            traits::VtableObject(ref d) => traits::VtableObject(d.fold_with(folder)),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n+        traits::VtableObjectData {\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n+            vtable_base: self.vtable_base\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n+        ty::EquatePredicate(self.0.fold_with(folder),\n+                            self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitPredicate<'tcx> {\n+        ty::TraitPredicate {\n+            trait_ref: self.trait_ref.fold_with(folder)\n+        }\n+    }\n+}\n+\n+impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : TypeFoldable<'tcx>,\n+          U : TypeFoldable<'tcx>,\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n+        ty::OutlivesPredicate(self.0.fold_with(folder),\n+                              self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureUpvar<'tcx> {\n+        ty::ClosureUpvar {\n+            def: self.def,\n+            span: self.span,\n+            ty: self.ty.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ParameterEnvironment<'a, 'tcx> {\n+        ty::ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.fold_with(folder),\n+            implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n+            caller_bounds: self.caller_bounds.fold_with(folder),\n+            selection_cache: traits::SelectionCache::new(),\n+            free_id: self.free_id,\n+        }\n+    }\n+}"}, {"sha": "a04cc89ee18a0940106f6b965510ade70bd59035", "filename": "src/librustc/middle/ty/sty.rs", "status": "added", "additions": 1129, "deletions": 0, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -0,0 +1,1129 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains TypeVariants and its major components\n+\n+use middle::def_id::DefId;\n+use middle::region;\n+use middle::subst::{self, Substs};\n+use middle::traits;\n+use middle::ty::{self, AdtDef, TypeFlags, Ty, TyS};\n+use middle::ty::{RegionEscape, ToPredicate};\n+use util::common::ErrorReported;\n+\n+use collections::enum_set::{self, EnumSet, CLike};\n+use std::fmt;\n+use std::ops;\n+use std::mem;\n+use syntax::abi;\n+use syntax::ast::{Name, NodeId};\n+\n+use rustc_front::hir;\n+\n+use self::FnOutput::*;\n+use self::InferTy::*;\n+use self::TypeVariants::*;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeAndMut<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub mutbl: hir::Mutability,\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable, Copy)]\n+/// A \"free\" region `fr` can be interpreted as \"some region\n+/// at least as big as the scope `fr.scope`\".\n+pub struct FreeRegion {\n+    pub scope: region::CodeExtent,\n+    pub bound_region: BoundRegion\n+}\n+\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n+         RustcEncodable, RustcDecodable, Copy)]\n+pub enum BoundRegion {\n+    /// An anonymous region parameter for a given fn (&T)\n+    BrAnon(u32),\n+\n+    /// Named region parameters for functions (a in &'a T)\n+    ///\n+    /// The def-id is needed to distinguish free regions in\n+    /// the event of shadowing.\n+    BrNamed(DefId, Name),\n+\n+    /// Fresh bound identifiers created during GLB computations.\n+    BrFresh(u32),\n+\n+    // Anonymous region for the implicit env pointer parameter\n+    // to a closure\n+    BrEnv\n+}\n+\n+// NB: If you change this, you'll probably want to change the corresponding\n+// AST structure in libsyntax/ast.rs as well.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeVariants<'tcx> {\n+    /// The primitive boolean type. Written as `bool`.\n+    TyBool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point).  Written as `char`.\n+    TyChar,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    TyInt(hir::IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    TyUint(hir::UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    TyFloat(hir::FloatTy),\n+\n+    /// An enumerated type, defined with `enum`.\n+    ///\n+    /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n+    /// That is, even after substitution it is possible that there are type\n+    /// variables. This happens when the `TyEnum` corresponds to an enum\n+    /// definition and not a concrete use of it. To get the correct `TyEnum`\n+    /// from the tcx, use the `NodeId` from the `hir::Ty` and look it up in\n+    /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n+    /// well.\n+    TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+\n+    /// A structure type, defined with `struct`.\n+    ///\n+    /// See warning about substitutions for enumerated types.\n+    TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+\n+    /// `Box<T>`; this is nominally a struct in the documentation, but is\n+    /// special-cased internally. For example, it is possible to implicitly\n+    /// move the contents of a box out of that box, and methods of any type\n+    /// can have type `Box<Self>`.\n+    TyBox(Ty<'tcx>),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    TyStr,\n+\n+    /// An array with the given length. Written as `[T; n]`.\n+    TyArray(Ty<'tcx>, usize),\n+\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    TySlice(Ty<'tcx>),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    TyRawPtr(TypeAndMut<'tcx>),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&a mut T` or `&'a T`.\n+    TyRef(&'tcx Region, TypeAndMut<'tcx>),\n+\n+    /// If the def-id is Some(_), then this is the type of a specific\n+    /// fn item. Otherwise, if None(_), it a fn pointer type.\n+    ///\n+    /// FIXME: Conflating function pointers and the type of a\n+    /// function is probably a terrible idea; a function pointer is a\n+    /// value with a specific type, but a function can be polymorphic\n+    /// or dynamically dispatched.\n+    TyBareFn(Option<DefId>, &'tcx BareFnTy<'tcx>),\n+\n+    /// A trait, defined with `trait`.\n+    TyTrait(Box<TraitTy<'tcx>>),\n+\n+    /// The anonymous type of a closure. Used to represent the type of\n+    /// `|a| a`.\n+    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    TyTuple(Vec<Ty<'tcx>>),\n+\n+    /// The projection of an associated type.  For example,\n+    /// `<T as Trait<..>>::N`.\n+    TyProjection(ProjectionTy<'tcx>),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    TyParam(ParamTy),\n+\n+    /// A type variable used during type-checking.\n+    TyInfer(InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    TyError,\n+}\n+\n+/// A closure can be modeled as a struct that looks like:\n+///\n+///     struct Closure<'l0...'li, T0...Tj, U0...Uk> {\n+///         upvar0: U0,\n+///         ...\n+///         upvark: Uk\n+///     }\n+///\n+/// where 'l0...'li and T0...Tj are the lifetime and type parameters\n+/// in scope on the function that defined the closure, and U0...Uk are\n+/// type parameters representing the types of its upvars (borrowed, if\n+/// appropriate).\n+///\n+/// So, for example, given this function:\n+///\n+///     fn foo<'a, T>(data: &'a mut T) {\n+///          do(|| data.count += 1)\n+///     }\n+///\n+/// the type of the closure would be something like:\n+///\n+///     struct Closure<'a, T, U0> {\n+///         data: U0\n+///     }\n+///\n+/// Note that the type of the upvar is not specified in the struct.\n+/// You may wonder how the impl would then be able to use the upvar,\n+/// if it doesn't know it's type? The answer is that the impl is\n+/// (conceptually) not fully generic over Closure but rather tied to\n+/// instances with the expected upvar types:\n+///\n+///     impl<'b, 'a, T> FnMut() for Closure<'a, T, &'b mut &'a mut T> {\n+///         ...\n+///     }\n+///\n+/// You can see that the *impl* fully specified the type of the upvar\n+/// and thus knows full well that `data` has type `&'b mut &'a mut T`.\n+/// (Here, I am assuming that `data` is mut-borrowed.)\n+///\n+/// Now, the last question you may ask is: Why include the upvar types\n+/// as extra type parameters? The reason for this design is that the\n+/// upvar types can reference lifetimes that are internal to the\n+/// creating function. In my example above, for example, the lifetime\n+/// `'b` represents the extent of the closure itself; this is some\n+/// subset of `foo`, probably just the extent of the call to the to\n+/// `do()`. If we just had the lifetime/type parameters from the\n+/// enclosing function, we couldn't name this lifetime `'b`. Note that\n+/// there can also be lifetimes in the types of the upvars themselves,\n+/// if one of them happens to be a reference to something that the\n+/// creating fn owns.\n+///\n+/// OK, you say, so why not create a more minimal set of parameters\n+/// that just includes the extra lifetime parameters? The answer is\n+/// primarily that it would be hard --- we don't know at the time when\n+/// we create the closure type what the full types of the upvars are,\n+/// nor do we know which are borrowed and which are not. In this\n+/// design, we can just supply a fresh type parameter and figure that\n+/// out later.\n+///\n+/// All right, you say, but why include the type parameters from the\n+/// original function then? The answer is that trans may need them\n+/// when monomorphizing, and they may not appear in the upvars.  A\n+/// closure could capture no variables but still make use of some\n+/// in-scope type parameter with a bound (e.g., if our example above\n+/// had an extra `U: Default`, and the closure called `U::default()`).\n+///\n+/// There is another reason. This design (implicitly) prohibits\n+/// closures from capturing themselves (except via a trait\n+/// object). This simplifies closure inference considerably, since it\n+/// means that when we infer the kind of a closure or its upvars, we\n+/// don't have to handle cycles where the decisions we make for\n+/// closure C wind up influencing the decisions we ought to make for\n+/// closure C (which would then require fixed point iteration to\n+/// handle). Plus it fixes an ICE. :P\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ClosureSubsts<'tcx> {\n+    /// Lifetime and type parameters from the enclosing function.\n+    /// These are separated out because trans wants to pass them around\n+    /// when monomorphizing.\n+    pub func_substs: &'tcx Substs<'tcx>,\n+\n+    /// The types of the upvars. The list parallels the freevars and\n+    /// `upvar_borrows` lists. These are kept distinct so that we can\n+    /// easily index into them.\n+    pub upvar_tys: Vec<Ty<'tcx>>\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct TraitTy<'tcx> {\n+    pub principal: ty::PolyTraitRef<'tcx>,\n+    pub bounds: ExistentialBounds<'tcx>,\n+}\n+\n+impl<'tcx> TraitTy<'tcx> {\n+    pub fn principal_def_id(&self) -> DefId {\n+        self.principal.0.def_id\n+    }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn principal_trait_ref_with_self_ty(&self,\n+                                            tcx: &ty::ctxt<'tcx>,\n+                                            self_ty: Ty<'tcx>)\n+                                            -> ty::PolyTraitRef<'tcx>\n+    {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::Binder(TraitRef {\n+            def_id: self.principal.0.def_id,\n+            substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n+        })\n+    }\n+\n+    pub fn projection_bounds_with_self_ty(&self,\n+                                          tcx: &ty::ctxt<'tcx>,\n+                                          self_ty: Ty<'tcx>)\n+                                          -> Vec<ty::PolyProjectionPredicate<'tcx>>\n+    {\n+        // otherwise the escaping regions would be captured by the binders\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        self.bounds.projection_bounds.iter()\n+            .map(|in_poly_projection_predicate| {\n+                let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n+                let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n+                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n+                                              substs);\n+                let projection_ty = ty::ProjectionTy {\n+                    trait_ref: trait_ref,\n+                    item_name: in_projection_ty.item_name\n+                };\n+                ty::Binder(ty::ProjectionPredicate {\n+                    projection_ty: projection_ty,\n+                    ty: in_poly_projection_predicate.0.ty\n+                })\n+            })\n+            .collect()\n+    }\n+}\n+\n+/// A complete reference to a trait. These take numerous guises in syntax,\n+/// but perhaps the most recognizable form is in a where clause:\n+///\n+///     T : Foo<U>\n+///\n+/// This would be represented by a trait-reference where the def-id is the\n+/// def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n+/// `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+///\n+/// Trait references also appear in object types like `Foo<U>`, but in\n+/// that case the `Self` parameter is absent from the substitutions.\n+///\n+/// Note that a `TraitRef` introduces a level of region binding, to\n+/// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n+/// U>` or higher-ranked object types.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct TraitRef<'tcx> {\n+    pub def_id: DefId,\n+    pub substs: &'tcx Substs<'tcx>,\n+}\n+\n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+\n+impl<'tcx> PolyTraitRef<'tcx> {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.0.self_ty()\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.0.def_id\n+    }\n+\n+    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.substs\n+    }\n+\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n+        self.0.input_types()\n+    }\n+\n+    pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n+        // Note that we preserve binding levels\n+        Binder(ty::TraitPredicate { trait_ref: self.0.clone() })\n+    }\n+}\n+\n+/// Binder is a binder for higher-ranked lifetimes. It is part of the\n+/// compiler's representation for things like `for<'a> Fn(&'a isize)`\n+/// (which would be represented by the type `PolyTraitRef ==\n+/// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n+/// erase, or otherwise \"discharge\" these bound regions, we change the\n+/// type from `Binder<T>` to just `T` (see\n+/// e.g. `liberate_late_bound_regions`).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct Binder<T>(pub T);\n+\n+impl<T> Binder<T> {\n+    /// Skips the binder and returns the \"bound\" value. This is a\n+    /// risky thing to do because it's easy to get confused about\n+    /// debruijn indices and the like. It is usually better to\n+    /// discharge the binder using `no_late_bound_regions` or\n+    /// `replace_late_bound_regions` or something like\n+    /// that. `skip_binder` is only valid when you are either\n+    /// extracting data that has nothing to do with bound regions, you\n+    /// are doing some sort of test that does not involve bound\n+    /// regions, or you are being very careful about your depth\n+    /// accounting.\n+    ///\n+    /// Some examples where `skip_binder` is reasonable:\n+    /// - extracting the def-id from a PolyTraitRef;\n+    /// - comparing the self type of a PolyTraitRef to see if it is equal to\n+    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    pub fn skip_binder(&self) -> &T {\n+        &self.0\n+    }\n+\n+    pub fn as_ref(&self) -> Binder<&T> {\n+        ty::Binder(&self.0)\n+    }\n+\n+    pub fn map_bound_ref<F,U>(&self, f: F) -> Binder<U>\n+        where F: FnOnce(&T) -> U\n+    {\n+        self.as_ref().map_bound(f)\n+    }\n+\n+    pub fn map_bound<F,U>(self, f: F) -> Binder<U>\n+        where F: FnOnce(T) -> U\n+    {\n+        ty::Binder(f(self.0))\n+    }\n+}\n+\n+impl fmt::Debug for TypeFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.bits)\n+    }\n+}\n+\n+/// Represents the projection of an associated type. In explicit UFCS\n+/// form this would be written `<T as Trait<..>>::N`.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ProjectionTy<'tcx> {\n+    /// The trait reference `T as Trait<..>`.\n+    pub trait_ref: ty::TraitRef<'tcx>,\n+\n+    /// The name `N` of the associated type.\n+    pub item_name: Name,\n+}\n+\n+impl<'tcx> ProjectionTy<'tcx> {\n+    pub fn sort_key(&self) -> (DefId, Name) {\n+        (self.trait_ref.def_id, self.item_name)\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct BareFnTy<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct ClosureTy<'tcx> {\n+    pub unsafety: hir::Unsafety,\n+    pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum FnOutput<'tcx> {\n+    FnConverging(Ty<'tcx>),\n+    FnDiverging\n+}\n+\n+impl<'tcx> FnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        *self == FnDiverging\n+    }\n+\n+    pub fn unwrap(self) -> Ty<'tcx> {\n+        match self {\n+            ty::FnConverging(t) => t,\n+            ty::FnDiverging => unreachable!()\n+        }\n+    }\n+\n+    pub fn unwrap_or(self, def: Ty<'tcx>) -> Ty<'tcx> {\n+        match self {\n+            ty::FnConverging(t) => t,\n+            ty::FnDiverging => def\n+        }\n+    }\n+}\n+\n+pub type PolyFnOutput<'tcx> = Binder<FnOutput<'tcx>>;\n+\n+impl<'tcx> PolyFnOutput<'tcx> {\n+    pub fn diverges(&self) -> bool {\n+        self.0.diverges()\n+    }\n+}\n+\n+/// Signature of a function type, which I have arbitrarily\n+/// decided to use to refer to the input/output types.\n+///\n+/// - `inputs` is the list of arguments and their modes.\n+/// - `output` is the return type.\n+/// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct FnSig<'tcx> {\n+    pub inputs: Vec<Ty<'tcx>>,\n+    pub output: FnOutput<'tcx>,\n+    pub variadic: bool\n+}\n+\n+pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+\n+impl<'tcx> PolyFnSig<'tcx> {\n+    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n+    }\n+    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n+    }\n+    pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n+    }\n+    pub fn variadic(&self) -> bool {\n+        self.skip_binder().variadic\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ParamTy {\n+    pub space: subst::ParamSpace,\n+    pub idx: u32,\n+    pub name: Name,\n+}\n+\n+/// A [De Bruijn index][dbi] is a standard means of representing\n+/// regions (and perhaps later types) in a higher-ranked setting. In\n+/// particular, imagine a type like this:\n+///\n+///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n+///     ^          ^            |        |         |\n+///     |          |            |        |         |\n+///     |          +------------+ 1      |         |\n+///     |                                |         |\n+///     +--------------------------------+ 2       |\n+///     |                                          |\n+///     +------------------------------------------+ 1\n+///\n+/// In this type, there are two binders (the outer fn and the inner\n+/// fn). We need to be able to determine, for any given region, which\n+/// fn type it is bound by, the inner or the outer one. There are\n+/// various ways you can do this, but a De Bruijn index is one of the\n+/// more convenient and has some nice properties. The basic idea is to\n+/// count the number of binders, inside out. Some examples should help\n+/// clarify what I mean.\n+///\n+/// Let's start with the reference type `&'b isize` that is the first\n+/// argument to the inner function. This region `'b` is assigned a De\n+/// Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n+/// fn). The region `'a` that appears in the second argument type (`&'a\n+/// isize`) would then be assigned a De Bruijn index of 2, meaning \"the\n+/// second-innermost binder\". (These indices are written on the arrays\n+/// in the diagram).\n+///\n+/// What is interesting is that De Bruijn index attached to a particular\n+/// variable will vary depending on where it appears. For example,\n+/// the final type `&'a char` also refers to the region `'a` declared on\n+/// the outermost fn. But this time, this reference is not nested within\n+/// any other binders (i.e., it is not an argument to the inner fn, but\n+/// rather the outer one). Therefore, in this case, it is assigned a\n+/// De Bruijn index of 1, because the innermost binder in that location\n+/// is the outer fn.\n+///\n+/// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub struct DebruijnIndex {\n+    // We maintain the invariant that this is never 0. So 1 indicates\n+    // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n+    pub depth: u32,\n+}\n+\n+/// Representation of regions.\n+///\n+/// Unlike types, most region variants are \"fictitious\", not concrete,\n+/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n+/// ones representing concrete regions.\n+///\n+/// ## Bound Regions\n+///\n+/// These are regions that are stored behind a binder and must be substituted\n+/// with some concrete region before being used. There are 2 kind of\n+/// bound regions: early-bound, which are bound in a TypeScheme/TraitDef,\n+/// and are substituted by a Substs,  and late-bound, which are part of\n+/// higher-ranked types (e.g. `for<'a> fn(&'a ())`) and are substituted by\n+/// the likes of `liberate_late_bound_regions`. The distinction exists\n+/// because higher-ranked lifetimes aren't supported in all places. See [1][2].\n+///\n+/// Unlike TyParam-s, bound regions are not supposed to exist \"in the wild\"\n+/// outside their binder, e.g. in types passed to type inference, and\n+/// should first be substituted (by skolemized regions, free regions,\n+/// or region variables).\n+///\n+/// ## Skolemized and Free Regions\n+///\n+/// One often wants to work with bound regions without knowing their precise\n+/// identity. For example, when checking a function, the lifetime of a borrow\n+/// can end up being assigned to some region parameter. In these cases,\n+/// it must be ensured that bounds on the region can't be accidentally\n+/// assumed without being checked.\n+///\n+/// The process of doing that is called \"skolemization\". The bound regions\n+/// are replaced by skolemized markers, which don't satisfy any relation\n+/// not explicity provided.\n+///\n+/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n+/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// to be used. These also support explicit bounds: both the internally-stored\n+/// *scope*, which the region is assumed to outlive, as well as other\n+/// relations stored in the `FreeRegionMap`. Note that these relations\n+/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// `resolve_regions_and_report_errors`.\n+///\n+/// When working with higher-ranked types, some region relations aren't\n+/// yet known, so you can't just call `resolve_regions_and_report_errors`.\n+/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// there's also the risk that some inference variable laying around will\n+/// get unified with your skolemized region: if you want to check whether\n+/// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n+/// with a skolemized region `'%a`, the variable `'_` would just be\n+/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// the inference variable is supposed to satisfy the relation\n+/// *for every value of the skolemized region*. To ensure that doesn't\n+/// happen, you can use `leak_check`. This is more clearly explained\n+/// by infer/higher_ranked/README.md.\n+///\n+/// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n+/// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+#[derive(Clone, PartialEq, Eq, Hash, Copy)]\n+pub enum Region {\n+    // Region bound in a type or fn declaration which will be\n+    // substituted 'early' -- that is, at the same time when type\n+    // parameters are substituted.\n+    ReEarlyBound(EarlyBoundRegion),\n+\n+    // Region bound in a function scope, which will be substituted when the\n+    // function is called.\n+    ReLateBound(DebruijnIndex, BoundRegion),\n+\n+    /// When checking a function body, the types of all arguments and so forth\n+    /// that refer to bound region parameters are modified to refer to free\n+    /// region parameters.\n+    ReFree(FreeRegion),\n+\n+    /// A concrete region naming some statically determined extent\n+    /// (e.g. an expression or sequence of statements) within the\n+    /// current function.\n+    ReScope(region::CodeExtent),\n+\n+    /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n+    ReStatic,\n+\n+    /// A region variable.  Should not exist after typeck.\n+    ReVar(RegionVid),\n+\n+    /// A skolemized region - basically the higher-ranked version of ReFree.\n+    /// Should not exist after typeck.\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n+\n+    /// Empty lifetime is for data that is never accessed.\n+    /// Bottom in the region lattice. We treat ReEmpty somewhat\n+    /// specially; at least right now, we do not generate instances of\n+    /// it during the GLB computations, but rather\n+    /// generate an error instead. This is to improve error messages.\n+    /// The only way to get an instance of ReEmpty is to have a region\n+    /// variable with no constraints.\n+    ReEmpty,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub struct EarlyBoundRegion {\n+    pub param_id: NodeId,\n+    pub space: subst::ParamSpace,\n+    pub index: u32,\n+    pub name: Name,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct TyVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct IntVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FloatVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub struct RegionVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum InferTy {\n+    TyVar(TyVid),\n+    IntVar(IntVid),\n+    FloatVar(FloatVid),\n+\n+    /// A `FreshTy` is one that is generated as a replacement for an\n+    /// unbound type variable. This is convenient for caching etc. See\n+    /// `middle::infer::freshen` for more details.\n+    FreshTy(u32),\n+    FreshIntTy(u32),\n+    FreshFloatTy(u32)\n+}\n+\n+/// Bounds suitable for an existentially quantified type parameter\n+/// such as those that appear in object types or closure types.\n+#[derive(PartialEq, Eq, Hash, Clone)]\n+pub struct ExistentialBounds<'tcx> {\n+    pub region_bound: ty::Region,\n+    pub builtin_bounds: BuiltinBounds,\n+    pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n+}\n+\n+impl<'tcx> ExistentialBounds<'tcx> {\n+    pub fn new(region_bound: ty::Region,\n+               builtin_bounds: BuiltinBounds,\n+               projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>)\n+               -> Self {\n+        let mut projection_bounds = projection_bounds;\n+        projection_bounds.sort_by(|a, b| a.sort_key().cmp(&b.sort_key()));\n+        ExistentialBounds {\n+            region_bound: region_bound,\n+            builtin_bounds: builtin_bounds,\n+            projection_bounds: projection_bounds\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n+\n+impl BuiltinBounds {\n+    pub fn empty() -> BuiltinBounds {\n+        BuiltinBounds(EnumSet::new())\n+    }\n+\n+    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n+        self.into_iter()\n+    }\n+\n+    pub fn to_predicates<'tcx>(&self,\n+                               tcx: &ty::ctxt<'tcx>,\n+                               self_ty: Ty<'tcx>) -> Vec<ty::Predicate<'tcx>> {\n+        self.iter().filter_map(|builtin_bound|\n+            match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, self_ty) {\n+                Ok(trait_ref) => Some(trait_ref.to_predicate()),\n+                Err(ErrorReported) => { None }\n+            }\n+        ).collect()\n+    }\n+}\n+\n+impl ops::Deref for BuiltinBounds {\n+    type Target = EnumSet<BuiltinBound>;\n+    fn deref(&self) -> &Self::Target { &self.0 }\n+}\n+\n+impl ops::DerefMut for BuiltinBounds {\n+    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n+}\n+\n+impl<'a> IntoIterator for &'a BuiltinBounds {\n+    type Item = BuiltinBound;\n+    type IntoIter = enum_set::Iter<BuiltinBound>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        (**self).into_iter()\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n+           Debug, Copy)]\n+#[repr(usize)]\n+pub enum BuiltinBound {\n+    Send,\n+    Sized,\n+    Copy,\n+    Sync,\n+}\n+\n+impl CLike for BuiltinBound {\n+    fn to_usize(&self) -> usize {\n+        *self as usize\n+    }\n+    fn from_usize(v: usize) -> BuiltinBound {\n+        unsafe { mem::transmute(v) }\n+    }\n+}\n+\n+impl<'tcx> ty::ctxt<'tcx> {\n+    pub fn try_add_builtin_trait(&self,\n+                                 trait_def_id: DefId,\n+                                 builtin_bounds: &mut EnumSet<BuiltinBound>)\n+                                 -> bool\n+    {\n+        //! Checks whether `trait_ref` refers to one of the builtin\n+        //! traits, like `Send`, and adds the corresponding\n+        //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n+        //! is a builtin trait.\n+\n+        match self.lang_items.to_builtin_kind(trait_def_id) {\n+            Some(bound) => { builtin_bounds.insert(bound); true }\n+            None => false\n+        }\n+    }\n+}\n+\n+impl DebruijnIndex {\n+    pub fn new(depth: u32) -> DebruijnIndex {\n+        assert!(depth > 0);\n+        DebruijnIndex { depth: depth }\n+    }\n+\n+    pub fn shifted(&self, amount: u32) -> DebruijnIndex {\n+        DebruijnIndex { depth: self.depth + amount }\n+    }\n+}\n+\n+// Region utilities\n+impl Region {\n+    pub fn is_bound(&self) -> bool {\n+        match *self {\n+            ty::ReEarlyBound(..) => true,\n+            ty::ReLateBound(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn needs_infer(&self) -> bool {\n+        match *self {\n+            ty::ReVar(..) | ty::ReSkolemized(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn escapes_depth(&self, depth: u32) -> bool {\n+        match *self {\n+            ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns the depth of `self` from the (1-based) binding level `depth`\n+    pub fn from_depth(&self, depth: u32) -> Region {\n+        match *self {\n+            ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n+                depth: debruijn.depth - (depth - 1)\n+            }, r),\n+            r => r\n+        }\n+    }\n+}\n+\n+// Type utilities\n+impl<'tcx> TyS<'tcx> {\n+    pub fn is_nil(&self) -> bool {\n+        match self.sty {\n+            TyTuple(ref tys) => tys.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_empty(&self, _cx: &ty::ctxt) -> bool {\n+        // FIXME(#24885): be smarter here\n+        match self.sty {\n+            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_ty_var(&self) -> bool {\n+        match self.sty {\n+            TyInfer(TyVar(_)) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bool(&self) -> bool { self.sty == TyBool }\n+\n+    pub fn is_self(&self) -> bool {\n+        match self.sty {\n+            TyParam(ref p) => p.space == subst::SelfSpace,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_slice(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(mt) | TyRef(_, mt) => match mt.ty.sty {\n+                TySlice(_) | TyStr => true,\n+                _ => false,\n+            },\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_structural(&self) -> bool {\n+        match self.sty {\n+            TyStruct(..) | TyTuple(_) | TyEnum(..) |\n+            TyArray(..) | TyClosure(..) => true,\n+            _ => self.is_slice() | self.is_trait()\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_simd(&self) -> bool {\n+        match self.sty {\n+            TyStruct(def, _) => def.is_simd(),\n+            _ => false\n+        }\n+    }\n+\n+    pub fn sequence_element_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => ty,\n+            TyStr => cx.mk_mach_uint(hir::TyU8),\n+            _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                      self)),\n+        }\n+    }\n+\n+    pub fn simd_type(&self, cx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n+        match self.sty {\n+            TyStruct(def, substs) => {\n+                def.struct_variant().fields[0].ty(cx, substs)\n+            }\n+            _ => panic!(\"simd_type called on invalid type\")\n+        }\n+    }\n+\n+    pub fn simd_size(&self, _cx: &ty::ctxt) -> usize {\n+        match self.sty {\n+            TyStruct(def, _) => def.struct_variant().fields.len(),\n+            _ => panic!(\"simd_size called on invalid type\")\n+        }\n+    }\n+\n+    pub fn is_region_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRef(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_unsafe_ptr(&self) -> bool {\n+        match self.sty {\n+            TyRawPtr(_) => return true,\n+            _ => return false\n+        }\n+    }\n+\n+    pub fn is_unique(&self) -> bool {\n+        match self.sty {\n+            TyBox(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /*\n+     A scalar type is one that denotes an atomic datum, with no sub-components.\n+     (A TyRawPtr is scalar because it represents a non-managed pointer, so its\n+     contents are abstract to rustc.)\n+    */\n+    pub fn is_scalar(&self) -> bool {\n+        match self.sty {\n+            TyBool | TyChar | TyInt(_) | TyFloat(_) | TyUint(_) |\n+            TyInfer(IntVar(_)) | TyInfer(FloatVar(_)) |\n+            TyBareFn(..) | TyRawPtr(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Returns true if this type is a floating point type and false otherwise.\n+    pub fn is_floating_point(&self) -> bool {\n+        match self.sty {\n+            TyFloat(_) |\n+            TyInfer(FloatVar(_)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_trait(&self) -> bool {\n+        match self.sty {\n+            TyTrait(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_integral(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyInt(_) | TyUint(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_fresh(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FreshTy(_)) => true,\n+            TyInfer(FreshIntTy(_)) => true,\n+            TyInfer(FreshFloatTy(_)) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_uint(&self) -> bool {\n+        match self.sty {\n+            TyInfer(IntVar(_)) | TyUint(hir::TyUs) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_char(&self) -> bool {\n+        match self.sty {\n+            TyChar => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bare_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_bare_fn_item(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(Some(_), _) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_fp(&self) -> bool {\n+        match self.sty {\n+            TyInfer(FloatVar(_)) | TyFloat(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_numeric(&self) -> bool {\n+        self.is_integral() || self.is_fp()\n+    }\n+\n+    pub fn is_signed(&self) -> bool {\n+        match self.sty {\n+            TyInt(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_machine(&self) -> bool {\n+        match self.sty {\n+            TyInt(hir::TyIs) | TyUint(hir::TyUs) => false,\n+            TyInt(..) | TyUint(..) | TyFloat(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    // Returns the type and mutability of *ty.\n+    //\n+    // The parameter `explicit` indicates if this is an *explicit* dereference.\n+    // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n+    pub fn builtin_deref(&self, explicit: bool, pref: ty::LvaluePreference)\n+        -> Option<TypeAndMut<'tcx>>\n+    {\n+        match self.sty {\n+            TyBox(ty) => {\n+                Some(TypeAndMut {\n+                    ty: ty,\n+                    mutbl: if pref == ty::PreferMutLvalue {\n+                        hir::MutMutable\n+                    } else {\n+                        hir::MutImmutable\n+                    },\n+                })\n+            },\n+            TyRef(_, mt) => Some(mt),\n+            TyRawPtr(mt) if explicit => Some(mt),\n+            _ => None\n+        }\n+    }\n+\n+    // Returns the type of ty[i]\n+    pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n+        match self.sty {\n+            TyArray(ty, _) | TySlice(ty) => Some(ty),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn fn_sig(&self) -> &'tcx PolyFnSig<'tcx> {\n+        match self.sty {\n+            TyBareFn(_, ref f) => &f.sig,\n+            _ => panic!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n+        }\n+    }\n+\n+    /// Returns the ABI of the given function.\n+    pub fn fn_abi(&self) -> abi::Abi {\n+        match self.sty {\n+            TyBareFn(_, ref f) => f.abi,\n+            _ => panic!(\"Ty::fn_abi() called on non-fn type\"),\n+        }\n+    }\n+\n+    // Type accessors for substructures of types\n+    pub fn fn_args(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+        self.fn_sig().inputs()\n+    }\n+\n+    pub fn fn_ret(&self) -> Binder<FnOutput<'tcx>> {\n+        self.fn_sig().output()\n+    }\n+\n+    pub fn is_fn(&self) -> bool {\n+        match self.sty {\n+            TyBareFn(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn ty_to_def_id(&self) -> Option<DefId> {\n+        match self.sty {\n+            TyTrait(ref tt) => Some(tt.principal_def_id()),\n+            TyStruct(def, _) |\n+            TyEnum(def, _) => Some(def.did),\n+            TyClosure(id, _) => Some(id),\n+            _ => None\n+        }\n+    }\n+\n+    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+        match self.sty {\n+            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            _ => None\n+        }\n+    }\n+}"}, {"sha": "99e41bd22b8bb9b250ed054dde519e6941dc509f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 152, "deletions": 3, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -21,7 +21,7 @@ use middle::ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use middle::ty::TyClosure;\n use middle::ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use middle::ty::{self, TypeAndMut, Ty, HasTypeFlags};\n-use middle::ty::fold::{self, TypeFoldable};\n+use middle::ty::fold::TypeFoldable;\n \n use std::fmt;\n use syntax::abi;\n@@ -219,7 +219,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n         }\n     };\n \n-    let new_value = fold::replace_late_bound_regions(tcx, &value, |br| {\n+    let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n         ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n             ty::BrNamed(_, name) => {\n@@ -255,7 +255,7 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn fold_with<F: fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n+    fn fold_with<F:ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F)\n                                               -> TraitAndProjections<'tcx> {\n         TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n@@ -388,6 +388,53 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::AutoAdjustment<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::AdjustReifyFnPointer => {\n+                write!(f, \"AdjustReifyFnPointer\")\n+            }\n+            ty::AdjustUnsafeFnPointer => {\n+                write!(f, \"AdjustUnsafeFnPointer\")\n+            }\n+            ty::AdjustDerefRef(ref data) => {\n+                write!(f, \"{:?}\", data)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::AutoDerefRef<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n+               self.autoderefs, self.unsize, self.autoref)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::TraitTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"TraitTy({:?},{:?})\",\n+               self.principal,\n+               self.bounds)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n+            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n+            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+            }\n+        }\n+    }\n+}\n+\n impl fmt::Display for ty::BoundRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -452,6 +499,45 @@ impl fmt::Debug for ty::Region {\n     }\n }\n \n+impl<'tcx> fmt::Debug for ty::ClosureTy<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureTy({},{:?},{})\",\n+               self.unsafety,\n+               self.sig,\n+               self.abi)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n+    }\n+}\n+\n+impl<'a, 'tcx> fmt::Debug for ty::ParameterEnvironment<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ParameterEnvironment(\\\n+            free_substs={:?}, \\\n+            implicit_region_bound={:?}, \\\n+            caller_bounds={:?})\",\n+            self.free_substs,\n+            self.implicit_region_bound,\n+            self.caller_bounds)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n+            ty::ObjectLifetimeDefault::BaseDefault => write!(f, \"BaseDefault\"),\n+            ty::ObjectLifetimeDefault::Specific(ref r) => write!(f, \"{:?}\", r),\n+        }\n+    }\n+}\n+\n impl fmt::Display for ty::Region {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n@@ -486,6 +572,17 @@ impl fmt::Debug for ty::FreeRegion {\n     }\n }\n \n+impl fmt::Debug for ty::Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            ty::Covariant => \"+\",\n+            ty::Contravariant => \"-\",\n+            ty::Invariant => \"o\",\n+            ty::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n impl fmt::Debug for ty::ItemVariances {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n@@ -570,6 +667,58 @@ impl fmt::Display for ty::BuiltinBounds {\n     }\n }\n \n+impl fmt::Debug for ty::TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for ty::RegionVid {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"'_#{}r\", self.index)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n+    }\n+}\n+\n+impl fmt::Debug for ty::InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::TyVar(ref v) => v.fmt(f),\n+            ty::IntVar(ref v) => v.fmt(f),\n+            ty::FloatVar(ref v) => v.fmt(f),\n+            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ty::IntType(ref v) => v.fmt(f),\n+            ty::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n // The generic impl doesn't work yet because projections are not\n // normalized under HRTB.\n /*impl<T> fmt::Display for ty::Binder<T>"}, {"sha": "a9322bf2197b0b1c58f671e27668e5f0c0129783", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -534,9 +534,7 @@ fn find_implied_output_region<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats) {\n         let mut regions = FnvHashSet();\n-        let have_bound_regions = ty::fold::collect_regions(tcx,\n-                                                           input_type,\n-                                                           &mut regions);\n+        let have_bound_regions = tcx.collect_regions(input_type, &mut regions);\n \n         debug!(\"find_implied_output_regions: collected {:?} from {:?} \\\n                 have_bound_regions={:?}\", &regions, input_type, have_bound_regions);"}, {"sha": "cde188fa41e48f353d877bf383516227afc0adb9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -66,7 +66,8 @@ use middle::infer::{self, Coercion};\n use middle::traits::{self, ObligationCause};\n use middle::traits::{predicate_for_trait_def, report_selection_error};\n use middle::ty::{AutoDerefRef, AdjustDerefRef};\n-use middle::ty::{self, LvaluePreference, TypeAndMut, Ty, TypeError};\n+use middle::ty::{self, LvaluePreference, TypeAndMut, Ty};\n+use middle::ty::error::TypeError;\n use middle::ty::relate::RelateResult;\n use util::common::indent;\n "}, {"sha": "fe822138c9b5be3eb958110350190b26affd44fe", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -32,7 +32,7 @@ pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                     ty_a: Ty<'tcx>,\n                                     ty_b: Ty<'tcx>,\n                                     handle_err: F) where\n-    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::TypeError<'tcx>),\n+    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::error::TypeError<'tcx>),\n {\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),"}, {"sha": "3160ed3502578f10e870e594f143ce268a5a8af4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -97,6 +97,7 @@ use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use middle::ty::{self, HasTypeFlags, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::{MethodCall, MethodCallee};\n+use middle::ty::error::TypeError;\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n@@ -1627,7 +1628,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     origin: infer::TypeOrigin,\n                     sub: Ty<'tcx>,\n                     sup: Ty<'tcx>)\n-                    -> Result<(), ty::TypeError<'tcx>> {\n+                    -> Result<(), TypeError<'tcx>> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1636,7 +1637,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    origin: infer::TypeOrigin,\n                    sub: Ty<'tcx>,\n                    sup: Ty<'tcx>)\n-                   -> Result<(), ty::TypeError<'tcx>> {\n+                   -> Result<(), TypeError<'tcx>> {\n         infer::mk_eqty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n@@ -1651,7 +1652,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                  sp: Span,\n                                  mk_msg: M,\n                                  actual_ty: Ty<'tcx>,\n-                                 err: Option<&ty::TypeError<'tcx>>) where\n+                                 err: Option<&TypeError<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n@@ -1661,7 +1662,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                    sp: Span,\n                                    e: Ty<'tcx>,\n                                    a: Ty<'tcx>,\n-                                   err: &ty::TypeError<'tcx>) {\n+                                   err: &TypeError<'tcx>) {\n         self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n \n@@ -1766,7 +1767,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Apply \"fallbacks\" to some types\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     fn default_type_parameters(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n         for ty in &self.infcx().unsolved_variables() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n@@ -1801,9 +1803,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn new_select_all_obligations_and_apply_defaults(&self) {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n-            // For the time being this errs on the side of being memory wasteful but provides better\n+        // For the time being this errs on the side of being memory wasteful but provides better\n         // error reporting.\n         // let type_variables = self.infcx().type_variables.clone();\n \n@@ -1973,7 +1976,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 default_map: &FnvHashMap<&Ty<'tcx>, type_variable::Default<'tcx>>,\n                                 conflict: Ty<'tcx>)\n                                 -> Option<type_variable::Default<'tcx>> {\n-        use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n+        use middle::ty::error::UnconstrainedNumeric::Neither;\n+        use middle::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n \n         // Ensure that we apply the conflicting default first\n         let mut unbound_tyvars = Vec::with_capacity(unbound_vars.len() + 1);"}, {"sha": "8048c302f2c78ff17abfec3fd2a06c093c44b518", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -446,7 +446,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n                 if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n                     infcx.report_mismatched_types(span, mk_ptr(mt_b.ty),\n-                                                  target, &ty::TypeError::Mutability);\n+                                                  target, &ty::error::TypeError::Mutability);\n                 }\n                 (mt_a.ty, mt_b.ty, unsize_trait, None)\n             };"}, {"sha": "0f71c4d8ceb5608df065c4f3f95f533bceea9c4a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f564fbbe46ee609e841062dad1817f17f90943c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5f564fbbe46ee609e841062dad1817f17f90943c", "patch": "@@ -2374,7 +2374,7 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n          * before we really have a `ParameterEnvironment` to check.\n          */\n \n-        ty::fold::fold_regions(tcx, value, &mut false, |region, _| {\n+        tcx.fold_regions(value, &mut false, |region, _| {\n             match region {\n                 ty::ReEarlyBound(data) => {\n                     let def_id = DefId::local(data.param_id);"}]}