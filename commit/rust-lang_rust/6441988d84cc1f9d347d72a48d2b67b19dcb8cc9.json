{"sha": "6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NDE5ODhkODRjYzFmOWQzNDdkNzJhNDhkMmI2N2IxOWRjYjhjYzk=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-02-29T17:28:26Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-03-07T12:08:35Z"}, "message": "vscode: redesign inlay hints to be capable of handling multiple editors", "tree": {"sha": "ca960be502b6ac23a11a2a547cf2f1896d297f5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca960be502b6ac23a11a2a547cf2f1896d297f5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "html_url": "https://github.com/rust-lang/rust/commit/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9/comments", "author": null, "committer": null, "parents": [{"sha": "0e6d066a2940c65af9171dff52304590cac4b95e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6d066a2940c65af9171dff52304590cac4b95e", "html_url": "https://github.com/rust-lang/rust/commit/0e6d066a2940c65af9171dff52304590cac4b95e"}], "stats": {"total": 379, "additions": 273, "deletions": 106}, "files": [{"sha": "bbe8f67ef58a76372f71dba5e0dff276e1fb46bf", "filename": "editors/code/src/inlay_hints.ts", "status": "modified", "additions": 271, "deletions": 104, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9/editors%2Fcode%2Fsrc%2Finlay_hints.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Finlay_hints.ts?ref=6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "patch": "@@ -1,156 +1,323 @@\n+import * as lc from \"vscode-languageclient\";\n import * as vscode from 'vscode';\n import * as ra from './rust-analyzer-api';\n \n import { Ctx } from './ctx';\n-import { log, sendRequestWithRetry, isRustDocument } from './util';\n+import { sendRequestWithRetry, assert } from './util';\n \n export function activateInlayHints(ctx: Ctx) {\n-    const hintsUpdater = new HintsUpdater(ctx);\n+    const hintsUpdater = new HintsUpdater(ctx.client);\n+\n     vscode.window.onDidChangeVisibleTextEditors(\n-        async _ => hintsUpdater.refresh(),\n+        visibleEditors => hintsUpdater.refreshVisibleRustEditors(\n+            visibleEditors.filter(isRustTextEditor)\n+        ),\n         null,\n         ctx.subscriptions\n     );\n \n     vscode.workspace.onDidChangeTextDocument(\n-        async event => {\n-            if (event.contentChanges.length === 0) return;\n-            if (!isRustDocument(event.document)) return;\n-            await hintsUpdater.refresh();\n+        ({ contentChanges, document }) => {\n+            if (contentChanges.length === 0) return;\n+            if (!isRustTextDocument(document)) return;\n+\n+            hintsUpdater.refreshRustDocument(document);\n         },\n         null,\n         ctx.subscriptions\n     );\n \n     vscode.workspace.onDidChangeConfiguration(\n-        async _ => hintsUpdater.setEnabled(ctx.config.displayInlayHints),\n+        async _ => {\n+            // FIXME: ctx.config may have not been refreshed at this point of time, i.e.\n+            // it's on onDidChangeConfiguration() handler may've not executed yet\n+            // (order of invokation is unspecified)\n+            // To fix this we should expose an event emitter from our `Config` itself.\n+            await hintsUpdater.setEnabled(ctx.config.displayInlayHints);\n+        },\n         null,\n         ctx.subscriptions\n     );\n \n     ctx.pushCleanup({\n         dispose() {\n-            hintsUpdater.clear();\n+            hintsUpdater.clearHints();\n         }\n     });\n \n-    // XXX: we don't await this, thus Promise rejections won't be handled, but\n-    // this should never throw in fact...\n-    void hintsUpdater.setEnabled(ctx.config.displayInlayHints);\n+    hintsUpdater.setEnabled(ctx.config.displayInlayHints);\n }\n \n-const typeHintDecorationType = vscode.window.createTextEditorDecorationType({\n-    after: {\n-        color: new vscode.ThemeColor('rust_analyzer.inlayHint'),\n-        fontStyle: \"normal\",\n-    },\n-});\n \n-const parameterHintDecorationType = vscode.window.createTextEditorDecorationType({\n-    before: {\n-        color: new vscode.ThemeColor('rust_analyzer.inlayHint'),\n-        fontStyle: \"normal\",\n-    },\n-});\n+const typeHints = {\n+    decorationType: vscode.window.createTextEditorDecorationType({\n+        after: {\n+            color: new vscode.ThemeColor('rust_analyzer.inlayHint'),\n+            fontStyle: \"normal\",\n+        }\n+    }),\n \n-class HintsUpdater {\n-    private pending = new Map<string, vscode.CancellationTokenSource>();\n-    private ctx: Ctx;\n-    private enabled: boolean;\n+    toDecoration(hint: ra.InlayHint.TypeHint, conv: lc.Protocol2CodeConverter): vscode.DecorationOptions {\n+        return {\n+            range: conv.asRange(hint.range),\n+            renderOptions: { after: { contentText: `: ${hint.label}` } }\n+        };\n+    }\n+};\n+\n+const paramHints = {\n+    decorationType: vscode.window.createTextEditorDecorationType({\n+        before: {\n+            color: new vscode.ThemeColor('rust_analyzer.inlayHint'),\n+            fontStyle: \"normal\",\n+        }\n+    }),\n \n-    constructor(ctx: Ctx) {\n-        this.ctx = ctx;\n-        this.enabled = false;\n+    toDecoration(hint: ra.InlayHint.ParamHint, conv: lc.Protocol2CodeConverter): vscode.DecorationOptions {\n+        return {\n+            range: conv.asRange(hint.range),\n+            renderOptions: { before: { contentText: `${hint.label}: ` } }\n+        };\n     }\n+};\n+\n+class HintsUpdater {\n+    private sourceFiles = new RustSourceFiles();\n+    private enabled = false;\n \n-    async setEnabled(enabled: boolean): Promise<void> {\n-        log.debug({ enabled, prev: this.enabled });\n+    constructor(readonly client: lc.LanguageClient) { }\n \n+    setEnabled(enabled: boolean) {\n         if (this.enabled === enabled) return;\n         this.enabled = enabled;\n \n         if (this.enabled) {\n-            return await this.refresh();\n+            this.refreshVisibleRustEditors(vscode.window.visibleTextEditors.filter(isRustTextEditor));\n         } else {\n-            return this.clear();\n+            this.clearHints();\n         }\n     }\n \n-    clear() {\n-        this.ctx.visibleRustEditors.forEach(it => {\n-            this.setTypeDecorations(it, []);\n-            this.setParameterDecorations(it, []);\n-        });\n+    clearHints() {\n+        for (const file of this.sourceFiles) {\n+            file.inlaysRequest?.cancel();\n+            this.renderHints(file, []);\n+        }\n+    }\n+\n+    private renderHints(file: RustSourceFile, hints: ra.InlayHint[]) {\n+        file.renderHints(hints, this.client.protocol2CodeConverter);\n     }\n \n-    async refresh() {\n+    refreshRustDocument(document: RustTextDocument) {\n         if (!this.enabled) return;\n-        await Promise.all(this.ctx.visibleRustEditors.map(it => this.refreshEditor(it)));\n-    }\n-\n-    private async refreshEditor(editor: vscode.TextEditor): Promise<void> {\n-        const newHints = await this.queryHints(editor.document.uri.toString());\n-        if (newHints == null) return;\n-\n-        const newTypeDecorations = newHints\n-            .filter(hint => hint.kind === ra.InlayKind.TypeHint)\n-            .map(hint => ({\n-                range: this.ctx.client.protocol2CodeConverter.asRange(hint.range),\n-                renderOptions: {\n-                    after: {\n-                        contentText: `: ${hint.label}`,\n-                    },\n-                },\n-            }));\n-        this.setTypeDecorations(editor, newTypeDecorations);\n-\n-        const newParameterDecorations = newHints\n-            .filter(hint => hint.kind === ra.InlayKind.ParameterHint)\n-            .map(hint => ({\n-                range: this.ctx.client.protocol2CodeConverter.asRange(hint.range),\n-                renderOptions: {\n-                    before: {\n-                        contentText: `${hint.label}: `,\n-                    },\n-                },\n-            }));\n-        this.setParameterDecorations(editor, newParameterDecorations);\n-    }\n-\n-    private setTypeDecorations(\n-        editor: vscode.TextEditor,\n-        decorations: vscode.DecorationOptions[],\n-    ) {\n-        editor.setDecorations(\n-            typeHintDecorationType,\n-            this.enabled ? decorations : [],\n-        );\n-    }\n-\n-    private setParameterDecorations(\n-        editor: vscode.TextEditor,\n-        decorations: vscode.DecorationOptions[],\n-    ) {\n-        editor.setDecorations(\n-            parameterHintDecorationType,\n-            this.enabled ? decorations : [],\n-        );\n-    }\n-\n-    private async queryHints(documentUri: string): Promise<ra.InlayHint[] | null> {\n-        this.pending.get(documentUri)?.cancel();\n \n-        const tokenSource = new vscode.CancellationTokenSource();\n-        this.pending.set(documentUri, tokenSource);\n+        const file = this.sourceFiles.getSourceFile(document.uri.toString());\n+\n+        assert(!!file, \"Document must be opened in some text editor!\");\n+\n+        void file.fetchAndRenderHints(this.client);\n+    }\n+\n+    refreshVisibleRustEditors(visibleEditors: RustTextEditor[]) {\n+        if (!this.enabled) return;\n+\n+        const visibleSourceFiles = this.sourceFiles.drainEditors(visibleEditors);\n \n-        const request = { textDocument: { uri: documentUri } };\n+        // Cancel requests for source files whose editors were disposed (leftovers after drain).\n+        for (const { inlaysRequest } of this.sourceFiles) inlaysRequest?.cancel();\n \n-        return sendRequestWithRetry(this.ctx.client, ra.inlayHints, request, tokenSource.token)\n-            .catch(_ => null)\n-            .finally(() => {\n-                if (!tokenSource.token.isCancellationRequested) {\n-                    this.pending.delete(documentUri);\n+        this.sourceFiles = visibleSourceFiles;\n+\n+        for (const file of this.sourceFiles) {\n+            if (!file.rerenderHints()) {\n+                void file.fetchAndRenderHints(this.client);\n+            }\n+        }\n+    }\n+}\n+\n+\n+/**\n+ * This class encapsulates a map of file uris to respective inlay hints\n+ * request cancellation token source (cts) and an array of editors.\n+ * E.g.\n+ * ```\n+ * {\n+ *    file1.rs -> (cts, (typeDecor, paramDecor), [editor1, editor2])\n+ *                  ^-- there is a cts to cancel the in-flight request\n+ *    file2.rs -> (cts, null, [editor3])\n+ *                       ^-- no decorations are applied to this source file yet\n+ *    file3.rs -> (null, (typeDecor, paramDecor), [editor4])\n+ * }                ^-- there is no inflight request\n+ * ```\n+ *\n+ * Invariants: each stored source file has at least 1 editor.\n+ */\n+class RustSourceFiles {\n+    private files = new Map<string, RustSourceFile>();\n+\n+    /**\n+     * Removes `editors` from `this` source files and puts them into a returned\n+     * source files object. cts and decorations are moved to the returned source files.\n+     */\n+    drainEditors(editors: RustTextEditor[]): RustSourceFiles {\n+        const result = new RustSourceFiles;\n+\n+        for (const editor of editors) {\n+            const oldFile = this.removeEditor(editor);\n+            const newFile = result.addEditor(editor);\n+\n+            if (oldFile) newFile.stealCacheFrom(oldFile);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Remove the editor and if it was the only editor for a source file,\n+     * the source file is removed altogether.\n+     *\n+     * @returns A reference to the source file for this editor or\n+     *          null if no such source file was not found.\n+     */\n+    private removeEditor(editor: RustTextEditor): null | RustSourceFile {\n+        const uri = editor.document.uri.toString();\n+\n+        const file = this.files.get(uri);\n+        if (!file) return null;\n+\n+        const editorIndex = file.editors.findIndex(suspect => areEditorsEqual(suspect, editor));\n+\n+        if (editorIndex >= 0) {\n+            file.editors.splice(editorIndex, 1);\n+\n+            if (file.editors.length === 0) this.files.delete(uri);\n+        }\n+\n+        return file;\n+    }\n+\n+    /**\n+     * @returns A reference to an existing source file or newly created one for the editor.\n+     */\n+    private addEditor(editor: RustTextEditor): RustSourceFile {\n+        const uri = editor.document.uri.toString();\n+        const file = this.files.get(uri);\n+\n+        if (!file) {\n+            const newFile = new RustSourceFile([editor]);\n+            this.files.set(uri, newFile);\n+            return newFile;\n+        }\n+\n+        if (!file.editors.find(suspect => areEditorsEqual(suspect, editor))) {\n+            file.editors.push(editor);\n+        }\n+        return file;\n+    }\n+\n+    getSourceFile(uri: string): undefined | RustSourceFile {\n+        return this.files.get(uri);\n+    }\n+\n+    [Symbol.iterator](): IterableIterator<RustSourceFile> {\n+        return this.files.values();\n+    }\n+}\n+class RustSourceFile {\n+    constructor(\n+        /**\n+         * Editors for this source file (one text document may be opened in multiple editors).\n+         * We keep this just an array, because most of the time we have 1 editor for 1 source file.\n+         */\n+        readonly editors: RustTextEditor[],\n+        /**\n+         * Source of the token to cancel in-flight inlay hints request if any.\n+         */\n+        public inlaysRequest: null | vscode.CancellationTokenSource = null,\n+\n+        public decorations: null | {\n+            type: vscode.DecorationOptions[];\n+            param: vscode.DecorationOptions[];\n+        } = null\n+    ) { }\n+\n+    stealCacheFrom(other: RustSourceFile) {\n+        if (other.inlaysRequest) this.inlaysRequest = other.inlaysRequest;\n+        if (other.decorations) this.decorations = other.decorations;\n+\n+        other.inlaysRequest = null;\n+        other.decorations = null;\n+    }\n+\n+    rerenderHints(): boolean {\n+        if (!this.decorations) return false;\n+\n+        for (const editor of this.editors) {\n+            editor.setDecorations(typeHints.decorationType, this.decorations.type);\n+            editor.setDecorations(paramHints.decorationType, this.decorations.param);\n+        }\n+        return true;\n+    }\n+\n+    renderHints(hints: ra.InlayHint[], conv: lc.Protocol2CodeConverter) {\n+        this.decorations = { type: [], param: [] };\n+\n+        for (const hint of hints) {\n+            switch (hint.kind) {\n+                case ra.InlayHint.Kind.TypeHint: {\n+                    this.decorations.type.push(typeHints.toDecoration(hint, conv));\n+                    continue;\n+                }\n+                case ra.InlayHint.Kind.ParamHint: {\n+                    this.decorations.param.push(paramHints.toDecoration(hint, conv));\n+                    continue;\n                 }\n-            });\n+            }\n+        }\n+        this.rerenderHints();\n+    }\n+\n+    async fetchAndRenderHints(client: lc.LanguageClient): Promise<void> {\n+        this.inlaysRequest?.cancel();\n+\n+        const tokenSource = new vscode.CancellationTokenSource();\n+        this.inlaysRequest = tokenSource;\n+\n+        const request = { textDocument: { uri: this.editors[0].document.uri.toString() } };\n+\n+        try {\n+            const hints = await sendRequestWithRetry(client, ra.inlayHints, request, tokenSource.token);\n+            this.renderHints(hints, client.protocol2CodeConverter);\n+        } catch {\n+            /* ignore */\n+        } finally {\n+            if (this.inlaysRequest === tokenSource) {\n+                this.inlaysRequest = null;\n+            }\n+        }\n     }\n }\n+\n+type RustTextDocument = vscode.TextDocument & { languageId: \"rust\" };\n+type RustTextEditor = vscode.TextEditor & { document: RustTextDocument; id: string };\n+\n+function areEditorsEqual(a: RustTextEditor, b: RustTextEditor): boolean {\n+    return a.id === b.id;\n+}\n+\n+function isRustTextEditor(suspect: vscode.TextEditor & { id?: unknown }): suspect is RustTextEditor {\n+    // Dirty hack, we need to access private vscode editor id,\n+    // see https://github.com/microsoft/vscode/issues/91788\n+    assert(\n+        typeof suspect.id === \"string\",\n+        \"Private text editor id is no longer available, please update the workaround!\"\n+    );\n+\n+    return isRustTextDocument(suspect.document);\n+}\n+\n+function isRustTextDocument(suspect: vscode.TextDocument): suspect is RustTextDocument {\n+    return suspect.languageId === \"rust\";\n+}"}, {"sha": "bd6e3ada083cb56b7f6ba40db17fd8369694ed25", "filename": "editors/code/src/rust-analyzer-api.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts", "raw_url": "https://github.com/rust-lang/rust/raw/6441988d84cc1f9d347d72a48d2b67b19dcb8cc9/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Frust-analyzer-api.ts?ref=6441988d84cc1f9d347d72a48d2b67b19dcb8cc9", "patch": "@@ -98,8 +98,8 @@ export namespace InlayHint {\n         range: lc.Range;\n         label: string;\n     }\n-    export type TypeHint = Common & { kind: Kind.TypeHint; }\n-    export type ParamHint = Common & { kind: Kind.ParamHint; }\n+    export type TypeHint = Common & { kind: Kind.TypeHint };\n+    export type ParamHint = Common & { kind: Kind.ParamHint };\n }\n export interface InlayHintsParams {\n     textDocument: lc.TextDocumentIdentifier;"}]}