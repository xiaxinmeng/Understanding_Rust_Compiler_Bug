{"sha": "6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "node_id": "C_kwDOAAsO6NoAKDZjODI2NWRjNTZkMjIxZGNlN2YzNTM1ZWNmOGNkZWU2YjlkMmQ2MTg", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-02T07:31:56Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-05-10T10:07:35Z"}, "message": "only_local: always check for misuse", "tree": {"sha": "7200aad6861c9464113121f124b093c69038c2cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7200aad6861c9464113121f124b093c69038c2cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "html_url": "https://github.com/rust-lang/rust/commit/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc128b67647533258e0bc52cc935438e6480732d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc128b67647533258e0bc52cc935438e6480732d", "html_url": "https://github.com/rust-lang/rust/commit/fc128b67647533258e0bc52cc935438e6480732d"}], "stats": {"total": 721, "additions": 341, "deletions": 380}, "files": [{"sha": "3d4bd222715c3950a54ca4a4f4bdef75ff22279b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 141, "deletions": 138, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -868,177 +868,180 @@ impl IntType {\n /// structure layout, `packed` to remove padding, and `transparent` to delegate representation\n /// concerns to the only non-ZST field.\n pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n-    use ReprAttr::*;\n+    if attr.has_name(sym::repr) { parse_repr_attr(sess, attr) } else { Vec::new() }\n+}\n \n+pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n+    assert!(attr.has_name(sym::repr), \"expected `#[repr(..)]`, found: {:?}\", attr);\n+    use ReprAttr::*;\n     let mut acc = Vec::new();\n     let diagnostic = &sess.parse_sess.span_diagnostic;\n-    if attr.has_name(sym::repr) {\n-        if let Some(items) = attr.meta_item_list() {\n-            for item in items {\n-                let mut recognised = false;\n-                if item.is_word() {\n-                    let hint = match item.name_or_empty() {\n-                        sym::C => Some(ReprC),\n-                        sym::packed => Some(ReprPacked(1)),\n-                        sym::simd => Some(ReprSimd),\n-                        sym::transparent => Some(ReprTransparent),\n-                        sym::no_niche => Some(ReprNoNiche),\n-                        sym::align => {\n-                            let mut err = struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0589,\n-                                \"invalid `repr(align)` attribute: `align` needs an argument\"\n-                            );\n-                            err.span_suggestion(\n-                                item.span(),\n-                                \"supply an argument here\",\n-                                \"align(...)\".to_string(),\n-                                Applicability::HasPlaceholders,\n-                            );\n-                            err.emit();\n-                            recognised = true;\n-                            None\n-                        }\n-                        name => int_type_of_word(name).map(ReprInt),\n-                    };\n \n-                    if let Some(h) = hint {\n+    if let Some(items) = attr.meta_item_list() {\n+        for item in items {\n+            let mut recognised = false;\n+            if item.is_word() {\n+                let hint = match item.name_or_empty() {\n+                    sym::C => Some(ReprC),\n+                    sym::packed => Some(ReprPacked(1)),\n+                    sym::simd => Some(ReprSimd),\n+                    sym::transparent => Some(ReprTransparent),\n+                    sym::no_niche => Some(ReprNoNiche),\n+                    sym::align => {\n+                        let mut err = struct_span_err!(\n+                            diagnostic,\n+                            item.span(),\n+                            E0589,\n+                            \"invalid `repr(align)` attribute: `align` needs an argument\"\n+                        );\n+                        err.span_suggestion(\n+                            item.span(),\n+                            \"supply an argument here\",\n+                            \"align(...)\".to_string(),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                        err.emit();\n                         recognised = true;\n-                        acc.push(h);\n+                        None\n                     }\n-                } else if let Some((name, value)) = item.name_value_literal() {\n-                    let mut literal_error = None;\n-                    if name == sym::align {\n-                        recognised = true;\n-                        match parse_alignment(&value.kind) {\n-                            Ok(literal) => acc.push(ReprAlign(literal)),\n-                            Err(message) => literal_error = Some(message),\n-                        };\n-                    } else if name == sym::packed {\n-                        recognised = true;\n-                        match parse_alignment(&value.kind) {\n-                            Ok(literal) => acc.push(ReprPacked(literal)),\n-                            Err(message) => literal_error = Some(message),\n-                        };\n-                    } else if matches!(name, sym::C | sym::simd | sym::transparent | sym::no_niche)\n-                        || int_type_of_word(name).is_some()\n-                    {\n-                        recognised = true;\n-                        struct_span_err!(\n+                    name => int_type_of_word(name).map(ReprInt),\n+                };\n+\n+                if let Some(h) = hint {\n+                    recognised = true;\n+                    acc.push(h);\n+                }\n+            } else if let Some((name, value)) = item.name_value_literal() {\n+                let mut literal_error = None;\n+                if name == sym::align {\n+                    recognised = true;\n+                    match parse_alignment(&value.kind) {\n+                        Ok(literal) => acc.push(ReprAlign(literal)),\n+                        Err(message) => literal_error = Some(message),\n+                    };\n+                } else if name == sym::packed {\n+                    recognised = true;\n+                    match parse_alignment(&value.kind) {\n+                        Ok(literal) => acc.push(ReprPacked(literal)),\n+                        Err(message) => literal_error = Some(message),\n+                    };\n+                } else if matches!(name, sym::C | sym::simd | sym::transparent | sym::no_niche)\n+                    || int_type_of_word(name).is_some()\n+                {\n+                    recognised = true;\n+                    struct_span_err!(\n                                 diagnostic,\n                                 item.span(),\n                                 E0552,\n                                 \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n                                 name.to_ident_string(),\n                             ).emit();\n-                    }\n-                    if let Some(literal_error) = literal_error {\n-                        struct_span_err!(\n+                }\n+                if let Some(literal_error) = literal_error {\n+                    struct_span_err!(\n+                        diagnostic,\n+                        item.span(),\n+                        E0589,\n+                        \"invalid `repr({})` attribute: {}\",\n+                        name.to_ident_string(),\n+                        literal_error\n+                    )\n+                    .emit();\n+                }\n+            } else if let Some(meta_item) = item.meta_item() {\n+                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n+                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                        let name = meta_item.name_or_empty().to_ident_string();\n+                        recognised = true;\n+                        let mut err = struct_span_err!(\n                             diagnostic,\n                             item.span(),\n-                            E0589,\n-                            \"invalid `repr({})` attribute: {}\",\n-                            name.to_ident_string(),\n-                            literal_error\n-                        )\n-                        .emit();\n-                    }\n-                } else if let Some(meta_item) = item.meta_item() {\n-                    if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                            let name = meta_item.name_or_empty().to_ident_string();\n-                            recognised = true;\n-                            let mut err = struct_span_err!(\n-                                diagnostic,\n-                                item.span(),\n-                                E0693,\n-                                \"incorrect `repr({})` attribute format\",\n-                                name,\n-                            );\n-                            match value.kind {\n-                                ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                    err.span_suggestion(\n-                                        item.span(),\n-                                        \"use parentheses instead\",\n-                                        format!(\"{}({})\", name, int),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                ast::LitKind::Str(s, _) => {\n-                                    err.span_suggestion(\n-                                        item.span(),\n-                                        \"use parentheses instead\",\n-                                        format!(\"{}({})\", name, s),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                _ => {}\n+                            E0693,\n+                            \"incorrect `repr({})` attribute format\",\n+                            name,\n+                        );\n+                        match value.kind {\n+                            ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                err.span_suggestion(\n+                                    item.span(),\n+                                    \"use parentheses instead\",\n+                                    format!(\"{}({})\", name, int),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n-                            err.emit();\n-                        } else {\n-                            if matches!(\n-                                meta_item.name_or_empty(),\n-                                sym::C | sym::simd | sym::transparent | sym::no_niche\n-                            ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                            {\n-                                recognised = true;\n-                                struct_span_err!(\n-                                    diagnostic,\n-                                    meta_item.span,\n-                                    E0552,\n-                                    \"invalid representation hint: `{}` does not take a value\",\n-                                    meta_item.name_or_empty().to_ident_string(),\n-                                )\n-                                .emit();\n+                            ast::LitKind::Str(s, _) => {\n+                                err.span_suggestion(\n+                                    item.span(),\n+                                    \"use parentheses instead\",\n+                                    format!(\"{}({})\", name, s),\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n+                            _ => {}\n                         }\n-                    } else if let MetaItemKind::List(_) = meta_item.kind {\n-                        if meta_item.has_name(sym::align) {\n+                        err.emit();\n+                    } else {\n+                        if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent | sym::no_niche\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n                             recognised = true;\n                             struct_span_err!(\n                                 diagnostic,\n                                 meta_item.span,\n-                                E0693,\n-                                \"incorrect `repr(align)` attribute format: \\\n-                                 `align` takes exactly one argument in parentheses\"\n+                                E0552,\n+                                \"invalid representation hint: `{}` does not take a value\",\n+                                meta_item.name_or_empty().to_ident_string(),\n                             )\n                             .emit();\n-                        } else if meta_item.has_name(sym::packed) {\n-                            recognised = true;\n-                            struct_span_err!(\n-                                diagnostic,\n-                                meta_item.span,\n-                                E0552,\n-                                \"incorrect `repr(packed)` attribute format: \\\n+                        }\n+                    }\n+                } else if let MetaItemKind::List(_) = meta_item.kind {\n+                    if meta_item.has_name(sym::align) {\n+                        recognised = true;\n+                        struct_span_err!(\n+                            diagnostic,\n+                            meta_item.span,\n+                            E0693,\n+                            \"incorrect `repr(align)` attribute format: \\\n+                                 `align` takes exactly one argument in parentheses\"\n+                        )\n+                        .emit();\n+                    } else if meta_item.has_name(sym::packed) {\n+                        recognised = true;\n+                        struct_span_err!(\n+                            diagnostic,\n+                            meta_item.span,\n+                            E0552,\n+                            \"incorrect `repr(packed)` attribute format: \\\n                                  `packed` takes exactly one parenthesized argument, \\\n                                  or no parentheses at all\"\n-                            )\n-                            .emit();\n-                        } else if matches!(\n-                            meta_item.name_or_empty(),\n-                            sym::C | sym::simd | sym::transparent | sym::no_niche\n-                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                        {\n-                            recognised = true;\n-                            struct_span_err!(\n+                        )\n+                        .emit();\n+                    } else if matches!(\n+                        meta_item.name_or_empty(),\n+                        sym::C | sym::simd | sym::transparent | sym::no_niche\n+                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                    {\n+                        recognised = true;\n+                        struct_span_err!(\n                                 diagnostic,\n                                 meta_item.span,\n                                 E0552,\n                                 \"invalid representation hint: `{}` does not take a parenthesized argument list\",\n                                 meta_item.name_or_empty().to_ident_string(),\n                             ).emit();\n-                        }\n                     }\n                 }\n-                if !recognised {\n-                    // Not a word we recognize. This will be caught and reported by\n-                    // the `check_mod_attrs` pass, but this pass doesn't always run\n-                    // (e.g. if we only pretty-print the source), so we have to gate\n-                    // the `delay_span_bug` call as follows:\n-                    if sess.opts.pretty.map_or(true, |pp| pp.needs_analysis()) {\n-                        diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n-                    }\n+            }\n+            if !recognised {\n+                // Not a word we recognize. This will be caught and reported by\n+                // the `check_mod_attrs` pass, but this pass doesn't always run\n+                // (e.g. if we only pretty-print the source), so we have to gate\n+                // the `delay_span_bug` call as follows:\n+                if sess.opts.pretty.map_or(true, |pp| pp.needs_analysis()) {\n+                    diagnostic.delay_span_bug(item.span(), \"unrecognized representation hint\");\n                 }\n             }\n         }"}, {"sha": "9394d60134f8c0e9ba0b942b0b3abbc40da657fd", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::OptLevel;\n+use rustc_span::symbol::sym;\n use rustc_target::spec::abi::Abi;\n use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtector};\n use smallvec::SmallVec;\n@@ -329,9 +330,7 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     ) {\n         let span = cx\n             .tcx\n-            .get_attrs(instance.def_id())\n-            .iter()\n-            .find(|a| a.has_name(rustc_span::sym::target_feature))\n+            .get_attr(instance.def_id(), sym::target_feature)\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n         let msg = format!(\n             \"the target features {} must all be either enabled or disabled together\","}, {"sha": "8d3bbefb371865812b4397a31e96c0b6fbf88e32", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -312,11 +312,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n \n             Status::Unstable(gate) if self.tcx.features().enabled(gate) => {\n                 let unstable_in_stable = self.ccx.is_const_stable_const_fn()\n-                    && !super::rustc_allow_const_fn_unstable(\n-                        self.tcx,\n-                        self.def_id().to_def_id(),\n-                        gate,\n-                    );\n+                    && !super::rustc_allow_const_fn_unstable(self.tcx, self.def_id(), gate);\n                 if unstable_in_stable {\n                     emit_unstable_in_stable_error(self.ccx, span, gate);\n                 }\n@@ -713,7 +709,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         match &terminator.kind {\n             TerminatorKind::Call { func, args, fn_span, from_hir_call, .. } => {\n                 let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n-                let caller = self.def_id().to_def_id();\n+                let caller = self.def_id();\n \n                 let fn_ty = func.ty(body, tcx);\n \n@@ -797,7 +793,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             // trait.\n                             let callee_trait = tcx.trait_of_item(callee);\n                             if callee_trait.is_some()\n-                                && tcx.has_attr(caller, sym::default_method_body_is_const)\n+                                && tcx.has_attr(caller.to_def_id(), sym::default_method_body_is_const)\n                                 && callee_trait == tcx.trait_of_item(caller)\n                                 // Can only call methods when it's `<Self as TheTrait>::f`.\n                                 && tcx.types.self_param == substs.type_at(0)"}, {"sha": "23e2afae79183bd1d15b0e9f84ff09f1510d6ded", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -66,8 +66,12 @@ impl<'mir, 'tcx> ConstCx<'mir, 'tcx> {\n     }\n }\n \n-pub fn rustc_allow_const_fn_unstable(tcx: TyCtxt<'_>, def_id: DefId, feature_gate: Symbol) -> bool {\n-    let attrs = tcx.get_attrs(def_id);\n+pub fn rustc_allow_const_fn_unstable(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    feature_gate: Symbol,\n+) -> bool {\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n     attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n "}, {"sha": "122471b208d8001aa12ea92f02dd5502ca3e5099", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1,5 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n+use hir::def_id::LocalDefId;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -95,7 +96,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n /// A function call where the callee is not marked as `const`.\n #[derive(Debug, Clone, Copy)]\n pub struct FnCallNonConst<'tcx> {\n-    pub caller: DefId,\n+    pub caller: LocalDefId,\n     pub callee: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub span: Span,\n@@ -117,13 +118,8 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n             match self_ty.kind() {\n                 Param(param_ty) => {\n                     debug!(?param_ty);\n-                    if let Some(generics) = caller\n-                        .as_local()\n-                        .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                        .map(|id| tcx.hir().get(id))\n-                        .as_ref()\n-                        .and_then(|node| node.generics())\n-                    {\n+                    let caller_hir_id = tcx.hir().local_def_id_to_hir_id(caller);\n+                    if let Some(generics) = tcx.hir().get(caller_hir_id).generics() {\n                         let constraint = with_no_trimmed_paths!(format!(\n                             \"~const {}\",\n                             trait_ref.print_only_trait_path()"}, {"sha": "f512594977c8df78d03bb7fd01b00bc61814b8ce", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -377,7 +377,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(panic_handler, Normal, template!(Word), WarnFollowing), // RFC 2070\n \n     // Code generation:\n-    ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing, @only_local: true),\n+    ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing),\n     ungated!(cold, Normal, template!(Word), WarnFollowing),\n     ungated!(no_builtins, CrateLevel, template!(Word), WarnFollowing),\n     ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#), DuplicatesOk),"}, {"sha": "424164d8760c4e8176a351416ca8ec105f1ffca3", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -183,10 +183,7 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl<'tcx> DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: LocalDefId, attr: &Attribute) -> Option<Assertion> {\n-        if !attr.has_name(sym::rustc_clean) {\n-            // skip: not rustc_clean/dirty\n-            return None;\n-        }\n+        assert!(attr.has_name(sym::rustc_clean));\n         if !check_config(self.tcx, attr) {\n             // skip: not the correct `cfg=`\n             return None;\n@@ -384,7 +381,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     fn check_item(&mut self, item_id: LocalDefId) {\n         let item_span = self.tcx.def_span(item_id.to_def_id());\n         let def_path_hash = self.tcx.def_path_hash(item_id.to_def_id());\n-        for attr in self.tcx.get_attrs(item_id.to_def_id()).iter() {\n+        for attr in self.tcx.get_attrs(item_id.to_def_id(), sym::rustc_clean) {\n             let Some(assertion) = self.assertion_maybe(item_id, attr) else {\n                 continue;\n             };"}, {"sha": "136f0443fa0a36e4285366095e2c788af36a800d", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -258,10 +258,7 @@ impl<'tcx> Queries<'tcx> {\n     /// an error.\n     fn check_for_rustc_errors_attr(tcx: TyCtxt<'_>) {\n         let Some((def_id, _)) = tcx.entry_fn(()) else { return };\n-\n-        let attrs = &*tcx.get_attrs(def_id);\n-        let attrs = attrs.iter().filter(|attr| attr.has_name(sym::rustc_error));\n-        for attr in attrs {\n+        for attr in tcx.get_attrs(def_id, sym::rustc_error) {\n             match attr.meta_item_list() {\n                 // Check if there is a `#[rustc_error(delay_span_bug_from_inside_query)]`.\n                 Some(list)"}, {"sha": "3fbe40a4253a295b2c5aae05c4eb2a60e92afca2", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -551,7 +551,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let attrs = cx.tcx.get_attrs(def_id.to_def_id());\n+        let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n             cx.struct_span_lint(\n@@ -2737,11 +2737,7 @@ impl ClashingExternDeclarations {\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attrs(fi.def_id.to_def_id())\n-                        .iter()\n-                        .find(|at| at.has_name(sym::link_name))\n-                        .unwrap()\n-                        .span,\n+                    tcx.get_attr(fi.def_id.to_def_id(), sym::link_name).unwrap().span,\n                 )\n             })\n         {"}, {"sha": "62d427fcd0238bcb3b3cbe6c5bfad67ea39f80d7", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -668,7 +668,7 @@ enum FfiResult<'tcx> {\n }\n \n crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n-    tcx.get_attrs(def.did()).iter().any(|a| a.has_name(sym::rustc_nonnull_optimization_guaranteed))\n+    tcx.has_attr(def.did(), sym::rustc_nonnull_optimization_guaranteed)\n }\n \n /// `repr(transparent)` structs can have a single non-ZST field, this function returns that"}, {"sha": "8cae95f46dc377acb809c1bfc63eced274990b57", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -303,26 +303,25 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_pre_path: &str,\n             descr_post_path: &str,\n         ) -> bool {\n-            for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.has_name(sym::must_use) {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        let msg = format!(\n-                            \"unused {}`{}`{} that must be used\",\n-                            descr_pre_path,\n-                            cx.tcx.def_path_str(def_id),\n-                            descr_post_path\n-                        );\n-                        let mut err = lint.build(&msg);\n-                        // check for #[must_use = \"...\"]\n-                        if let Some(note) = attr.value_str() {\n-                            err.note(note.as_str());\n-                        }\n-                        err.emit();\n-                    });\n-                    return true;\n-                }\n+            if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n+                cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                    let msg = format!(\n+                        \"unused {}`{}`{} that must be used\",\n+                        descr_pre_path,\n+                        cx.tcx.def_path_str(def_id),\n+                        descr_post_path\n+                    );\n+                    let mut err = lint.build(&msg);\n+                    // check for #[must_use = \"...\"]\n+                    if let Some(note) = attr.value_str() {\n+                        err.note(note.as_str());\n+                    }\n+                    err.emit();\n+                });\n+                true\n+            } else {\n+                false\n             }\n-            false\n         }\n     }\n }"}, {"sha": "1de7dae3c25cba332737f3298c499dc4ec78f281", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -985,15 +985,17 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_attrs(&mut self, def_id: DefId) {\n+    fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let mut attrs = self\n             .tcx\n-            .get_attrs(def_id)\n+            .hir()\n+            .attrs(self.tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n             .filter(|attr| !rustc_feature::is_builtin_only_local(attr.name_or_empty()));\n-        record!(self.tables.attributes[def_id] <- attrs.clone());\n+\n+        record!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         if attrs.any(|attr| attr.may_have_doc_links()) {\n-            self.tables.may_have_doc_links.set(def_id.index, ());\n+            self.tables.may_have_doc_links.set(def_id.local_def_index, ());\n         }\n     }\n \n@@ -1009,7 +1011,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set(def_id.index, def_kind);\n             record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n-            self.encode_attrs(def_id);\n+            self.encode_attrs(local_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if def_kind.has_codegen_attrs() {\n                 record!(self.tables.codegen_fn_attrs[def_id] <- self.tcx.codegen_fn_attrs(def_id));\n@@ -1674,7 +1676,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n-            self.encode_attrs(LOCAL_CRATE.as_def_id());\n+            self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n             if let Some(stability) = stability {\n                 record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n@@ -1715,7 +1717,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let def_id = id.to_def_id();\n                 self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n-                self.encode_attrs(def_id);\n+                self.encode_attrs(id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n                 record!(self.tables.def_span[def_id] <- span);"}, {"sha": "bf7cb610a9097fa3186ca16bd4c40162800ec2c9", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -230,8 +230,7 @@ impl AdtDefData {\n             flags |= AdtFlags::HAS_CTOR;\n         }\n \n-        let attrs = tcx.get_attrs(did);\n-        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n+        if tcx.has_attr(did, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {"}, {"sha": "36f1045efef013fc541432da77d8fcc49c8c9939", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1148,9 +1148,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `rustc_layout_scalar_valid_range` attribute.\n     // FIXME(eddyb) this is an awkward spot for this method, maybe move it?\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n-        let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let Some(attr) = attrs.iter().find(|a| a.has_name(name)) else {\n+            let Some(attr) = self.get_attr(def_id, name) else {\n                 return Bound::Unbounded;\n             };\n             debug!(\"layout_scalar_valid_range: attr={:?}\", attr);"}, {"sha": "a0fe632f11a07f21b3cf37f5649226c318d399bf", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -568,11 +568,8 @@ impl<T> Trait<T> for X {\n                 }\n             }\n             TargetFeatureCast(def_id) => {\n-                let attrs = self.get_attrs(*def_id);\n-                let target_spans = attrs\n-                    .iter()\n-                    .filter(|attr| attr.has_name(sym::target_feature))\n-                    .map(|attr| attr.span);\n+                let target_spans =\n+                    self.get_attrs(*def_id, sym::target_feature).map(|attr| attr.span);\n                 diag.note(\n                     \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n                 );"}, {"sha": "2180078133301dcf671973172ede6bb826291799", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -8,6 +8,7 @@ use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n use rustc_middle::ty::normalize_erasing_regions::NormalizationError;\n+use rustc_span::Symbol;\n \n use std::fmt;\n \n@@ -185,8 +186,8 @@ impl<'tcx> InstanceDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn attrs(&self, tcx: TyCtxt<'tcx>) -> ty::Attributes<'tcx> {\n-        tcx.get_attrs(self.def_id())\n+    pub fn get_attrs(&self, tcx: TyCtxt<'tcx>, attr: Symbol) -> ty::Attributes<'tcx> {\n+        tcx.get_attrs(self.def_id(), attr)\n     }\n \n     /// Returns `true` if the LLVM version of this instance is unconditionally"}, {"sha": "49b2f3480b719a173dcb561bf417cf644e7359ba", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -14,12 +14,6 @@ pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n-pub use adt::*;\n-pub use assoc::*;\n-pub use generics::*;\n-use rustc_data_structures::fingerprint::Fingerprint;\n-pub use vtable::*;\n-\n use crate::metadata::ModChild;\n use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n@@ -28,8 +22,12 @@ use crate::ty;\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::Discr;\n+pub use adt::*;\n+pub use assoc::*;\n+pub use generics::*;\n use rustc_ast as ast;\n use rustc_attr as attr;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -44,6 +42,7 @@ use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n+pub use vtable::*;\n \n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -1818,8 +1817,8 @@ impl ReprOptions {\n             field_shuffle_seed ^= user_seed;\n         }\n \n-        for attr in tcx.get_attrs(did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n+        for attr in tcx.get_attrs(did, sym::repr) {\n+            for r in attr::parse_repr_attr(&tcx.sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n@@ -1941,8 +1940,7 @@ impl<'tcx> FieldDef {\n     }\n }\n \n-pub type Attributes<'tcx> = &'tcx [ast::Attribute];\n-\n+pub type Attributes<'tcx> = impl Iterator<Item = &'tcx ast::Attribute>;\n #[derive(Debug, PartialEq, Eq)]\n pub enum ImplOverlapKind {\n     /// These impls are always allowed to overlap.\n@@ -2186,25 +2184,38 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Gets the attributes of a definition.\n-    ///\n-    /// Note that attributes which are only relevant for the current\n-    /// crate are not stored in the crate metadata and therefore cannot\n-    /// be accessed outside of that crate.\n-    pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n+    // TODO: Remove this function.\n+    pub fn get_attrs_unchecked(self, did: DefId) -> &'tcx [ast::Attribute] {\n         if let Some(did) = did.as_local() {\n             self.hir().attrs(self.hir().local_def_id_to_hir_id(did))\n         } else {\n             self.item_attrs(did)\n         }\n     }\n \n+    /// Gets all attributes with the given name.\n+    pub fn get_attrs(self, did: DefId, attr: Symbol) -> ty::Attributes<'tcx> {\n+        let filter_fn = move |a: &&ast::Attribute| a.has_name(attr);\n+        if let Some(did) = did.as_local() {\n+            self.hir().attrs(self.hir().local_def_id_to_hir_id(did)).iter().filter(filter_fn)\n+        } else if cfg!(debug_assertions) && rustc_feature::is_builtin_only_local(attr) {\n+            bug!(\"tried to access the `only_local` attribute `{}` from an extern crate\", attr);\n+        } else {\n+            self.item_attrs(did).iter().filter(filter_fn)\n+        }\n+    }\n+\n+    pub fn get_attr(self, did: DefId, attr: Symbol) -> Option<&'tcx ast::Attribute> {\n+        self.get_attrs(did, attr).next()\n+    }\n+\n     /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n         if cfg!(debug_assertions) && !did.is_local() && rustc_feature::is_builtin_only_local(attr) {\n             bug!(\"tried to access the `only_local` attribute `{}` from an extern crate\", attr);\n+        } else {\n+            self.get_attrs(did, attr).next().is_some()\n         }\n-        self.sess.contains_name(&self.get_attrs(did), attr)\n     }\n \n     /// Returns `true` if this is an `auto trait`."}, {"sha": "b5f8726cdc5b1ba62a4bee70590a0f5db43bc3f2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1163,9 +1163,8 @@ pub fn normalize_opaque_types<'tcx>(\n \n /// Determines whether an item is annotated with `doc(hidden)`.\n pub fn is_doc_hidden(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    tcx.get_attrs(def_id)\n-        .iter()\n-        .filter_map(|attr| if attr.has_name(sym::doc) { attr.meta_item_list() } else { None })\n+    tcx.get_attrs(def_id, sym::doc)\n+        .filter_map(|attr| attr.meta_item_list())\n         .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n }\n "}, {"sha": "c63c511e09cb42520791349a8b82ac6589970b13", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -679,7 +679,6 @@ where\n     } else {\n         None\n     };\n-    debug!(\"fn_id {:?} has attrs {:?}\", fn_def, tcx.get_attrs(fn_def.did.to_def_id()));\n \n     let mut body = builder.finish();\n     body.spread_arg = spread_arg;"}, {"sha": "50efb4c1dc42a4a9750bc3bccc468530cb3c1f70", "filename": "compiler/rustc_mir_dataflow/src/framework/engine.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fengine.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -333,14 +333,11 @@ struct RustcMirAttrs {\n \n impl RustcMirAttrs {\n     fn parse(tcx: TyCtxt<'_>, def_id: DefId) -> Result<Self, ()> {\n-        let attrs = tcx.get_attrs(def_id);\n-\n         let mut result = Ok(());\n         let mut ret = RustcMirAttrs::default();\n \n-        let rustc_mir_attrs = attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::rustc_mir))\n+        let rustc_mir_attrs = tcx\n+            .get_attrs(def_id, sym::rustc_mir)\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {"}, {"sha": "c1124a533bf2ba277c9d90689756e2cbb9243f2c", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -14,9 +14,9 @@ extern crate tracing;\n #[macro_use]\n extern crate rustc_middle;\n \n-use rustc_ast::{self as ast, MetaItem};\n-use rustc_middle::ty;\n-use rustc_session::Session;\n+use rustc_ast::MetaItem;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n \n pub use self::drop_flag_effects::{\n@@ -49,19 +49,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub fn has_rustc_mir_with(\n-    _sess: &Session,\n-    attrs: &[ast::Attribute],\n-    name: Symbol,\n-) -> Option<MetaItem> {\n-    for attr in attrs {\n-        if attr.has_name(sym::rustc_mir) {\n-            let items = attr.meta_item_list();\n-            for item in items.iter().flat_map(|l| l.iter()) {\n-                match item.meta_item() {\n-                    Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n-                    _ => continue,\n-                }\n+pub fn has_rustc_mir_with(tcx: TyCtxt<'_>, def_id: DefId, name: Symbol) -> Option<MetaItem> {\n+    for attr in tcx.get_attrs(def_id, sym::rustc_mir) {\n+        let items = attr.meta_item_list();\n+        for item in items.iter().flat_map(|l| l.iter()) {\n+            match item.meta_item() {\n+                Some(mi) if mi.has_name(name) => return Some(mi.clone()),\n+                _ => continue,\n             }\n         }\n     }"}, {"sha": "cc9ee1016c6dbbc4f52da8abb95da1fe95807883", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n@@ -31,43 +30,41 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n             debug!(\"running rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n         }\n \n-        let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data, param_env };\n-        let sess = &tcx.sess;\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_init).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_maybe_init).is_some() {\n             let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_uninit).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_maybe_uninit).is_some() {\n             let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_uninits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_definite_init).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_definite_init).is_some() {\n             let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body)\n                 .iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness = MaybeLiveLocals.into_engine(tcx, body).iterate_to_fixpoint();\n \n-            sanity_check_via_rustc_peek(tcx, body, &attributes, &flow_liveness);\n+            sanity_check_via_rustc_peek(tcx, body, &flow_liveness);\n         }\n \n-        if has_rustc_mir_with(sess, &attributes, sym::stop_after_dataflow).is_some() {\n+        if has_rustc_mir_with(tcx, def_id, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }\n@@ -92,7 +89,6 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n pub fn sanity_check_via_rustc_peek<'tcx, A>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    _attributes: &[ast::Attribute],\n     results: &Results<'tcx, A>,\n ) where\n     A: RustcPeekAt<'tcx>,"}, {"sha": "3cfd935d8b0ae1d41743eadccb7027c9abafbd1a", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -197,7 +197,7 @@ fn emit_unused_generic_params_error<'tcx>(\n     unused_parameters: &FiniteBitSet<u32>,\n ) {\n     let base_def_id = tcx.typeck_root_def_id(def_id);\n-    if !tcx.get_attrs(base_def_id).iter().any(|a| a.has_name(sym::rustc_polymorphize_error)) {\n+    if !tcx.has_attr(base_def_id, sym::rustc_polymorphize_error) {\n         return;\n     }\n "}, {"sha": "15e24299075b96f7557573c0cf18c113b5f6a4e7", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // If `def_id` is `None`, we don't need to consider stability attributes.\n             let def_id = match def_id {\n-                Some(x) => x.to_def_id(),\n+                Some(x) => x,\n                 None => return true,\n             };\n \n@@ -182,14 +182,16 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // If this crate is not using stability attributes, or this function is not claiming to be a\n             // stable `const fn`, that is all that is required.\n-            if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+            if !tcx.features().staged_api\n+                || tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable)\n+            {\n                 return true;\n             }\n \n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n             // opt-in via `rustc_allow_const_fn_unstable`.\n-            attr::rustc_allow_const_fn_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-                .any(|name| name == feature_gate)\n+            let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n+            attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n         };\n \n         match required_gates {"}, {"sha": "728aaab6137ab6047784ea04e192119623e88ee3", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -27,10 +27,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Enum(..)\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n-                for attr in self.tcx.get_attrs(item.def_id.to_def_id()).iter() {\n-                    if attr.has_name(sym::rustc_layout) {\n-                        self.dump_layout_of(item.def_id, item, attr);\n-                    }\n+                for attr in self.tcx.get_attrs(item.def_id.to_def_id(), sym::rustc_layout) {\n+                    self.dump_layout_of(item.def_id, item, attr);\n                 }\n             }\n             _ => {}"}, {"sha": "e1bc248971ae25ff1b7245553a77341315607dcb", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     ) where\n         F: FnOnce(&mut Self),\n     {\n-        let attrs = self.tcx.get_attrs(def_id.to_def_id());\n+        let attrs = self.tcx.hir().attrs(self.tcx.hir().local_def_id_to_hir_id(def_id));\n         debug!(\"annotate(id = {:?}, attrs = {:?})\", def_id, attrs);\n \n         let depr = attr::find_deprecation(&self.tcx.sess, attrs);"}, {"sha": "ae4455531ab5bf226b6225619fda0193364cb9fd", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -2002,12 +2002,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         let parent_def_id = self.tcx.parent(def_id);\n                         if let Some(def_id) = parent_def_id.as_local() {\n                             // lifetimes in `derive` expansions don't count (Issue #53738)\n-                            if self\n-                                .tcx\n-                                .get_attrs(def_id.to_def_id())\n-                                .iter()\n-                                .any(|attr| attr.has_name(sym::automatically_derived))\n-                            {\n+                            if self.tcx.has_attr(def_id.to_def_id(), sym::automatically_derived) {\n                                 continue;\n                             }\n "}, {"sha": "7249ce04c155ecac4c357fbd7af61220c096e75a", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -49,27 +49,26 @@ struct SymbolNamesTest<'tcx> {\n impl SymbolNamesTest<'_> {\n     fn process_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n-            if attr.has_name(SYMBOL_NAME) {\n-                let def_id = def_id.to_def_id();\n-                let instance = Instance::new(\n-                    def_id,\n-                    tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n-                );\n-                let mangled = tcx.symbol_name(instance);\n-                tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n-                if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n-                    tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n-                    tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n-                }\n-            } else if attr.has_name(DEF_PATH) {\n-                let path = with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id()));\n-                tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n+        // The formatting of `tag({})` is chosen so that tests can elect\n+        // to test the entirety of the string, if they choose, or else just\n+        // some subset.\n+        for attr in tcx.get_attrs(def_id.to_def_id(), SYMBOL_NAME) {\n+            let def_id = def_id.to_def_id();\n+            let instance = Instance::new(\n+                def_id,\n+                tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def_id)),\n+            );\n+            let mangled = tcx.symbol_name(instance);\n+            tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n+            if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n+                tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n+                tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n             }\n+        }\n \n-            // (*) The formatting of `tag({})` is chosen so that tests can elect\n-            // to test the entirety of the string, if they choose, or else just\n-            // some subset.\n+        for attr in tcx.get_attrs(def_id.to_def_id(), DEF_PATH) {\n+            let path = with_no_trimmed_paths!(tcx.def_path_str(def_id.to_def_id()));\n+            tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n         }\n     }\n }"}, {"sha": "7d4181981953627e016b2cec5c236b2c866fc955", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -175,9 +175,7 @@ impl<'tcx> OnUnimplementedDirective {\n     }\n \n     pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let attrs = tcx.get_attrs(item_def_id);\n-\n-        let Some(attr) = tcx.sess.find_by_name(&attrs, sym::rustc_on_unimplemented) else {\n+        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n             return Ok(None);\n         };\n "}, {"sha": "3d6bcc93c978c5bd357599c152f241e0a03b88a1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1156,9 +1156,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if let ImplCandidate(def_id) = candidate {\n             if let ty::ImplPolarity::Reservation = tcx.impl_polarity(def_id) {\n                 if let Some(intercrate_ambiguity_clauses) = &mut self.intercrate_ambiguity_causes {\n-                    let attrs = tcx.get_attrs(def_id);\n-                    let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n-                    let value = attr.and_then(|a| a.value_str());\n+                    let value = tcx\n+                        .get_attr(def_id, sym::rustc_reservation_impl)\n+                        .and_then(|a| a.value_str());\n                     if let Some(value) = value {\n                         debug!(\n                             \"filter_reservation_impls: \\"}, {"sha": "35cc2da15bd69daab0cda75b343e3fe98ac184da", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1056,9 +1056,7 @@ fn check_impl_items_against_trait<'tcx>(\n         if let Some(missing_items) = must_implement_one_of {\n             let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n             let attr_span = tcx\n-                .get_attrs(impl_trait_ref.def_id)\n-                .iter()\n-                .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+                .get_attr(impl_trait_ref.def_id, sym::rustc_must_implement_one_of)\n                 .map(|attr| attr.span);\n \n             missing_items_must_implement_one_of_err(tcx, impl_span, missing_items, attr_span);\n@@ -1158,20 +1156,20 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: ty::AdtDef<'_>) {\n     let repr = def.repr();\n     if repr.packed() {\n-        for attr in tcx.get_attrs(def.did()).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n+        for attr in tcx.get_attrs(def.did(), sym::repr) {\n+            for r in attr::parse_repr_attr(&tcx.sess, attr) {\n                 if let attr::ReprPacked(pack) = r\n-                    && let Some(repr_pack) = repr.pack\n-                    && pack as u64 != repr_pack.bytes()\n-                {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                sp,\n-                                E0634,\n-                                \"type has conflicting packed representation hints\"\n-                            )\n-                            .emit();\n-                }\n+                && let Some(repr_pack) = repr.pack\n+                && pack as u64 != repr_pack.bytes()\n+            {\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            sp,\n+                            E0634,\n+                            \"type has conflicting packed representation hints\"\n+                        )\n+                        .emit();\n+            }\n             }\n         }\n         if repr.align.is_some() {\n@@ -1321,8 +1319,7 @@ fn check_enum<'tcx>(\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() {\n-        let attributes = tcx.get_attrs(def_id.to_def_id());\n-        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n+        if let Some(attr) = tcx.get_attr(def_id.to_def_id(), sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "ae4cebe866bdbf5f7e4a5395c2739ddbd018ad5e", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -407,8 +407,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.has_only_self_parameter(m)\n                 && self\n                     .tcx\n-                    .get_attrs(m.def_id)\n-                    .iter()\n                     // This special internal attribute is used to permit\n                     // \"identity-like\" conversion methods to be suggested here.\n                     //\n@@ -419,7 +417,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     //\n                     // FIXME? Other potential candidate methods: `as_ref` and\n                     // `as_mut`?\n-                    .any(|a| a.has_name(sym::rustc_conversion_suggestion))\n+                    .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n         });\n \n         methods"}, {"sha": "be389f0e3f515973329db6d82036ac69f917c478", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -609,44 +609,43 @@ fn check_must_not_suspend_def(\n     hir_id: HirId,\n     data: SuspendCheckData<'_, '_>,\n ) -> bool {\n-    for attr in tcx.get_attrs(def_id).iter() {\n-        if attr.has_name(sym::must_not_suspend) {\n-            tcx.struct_span_lint_hir(\n-                rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n-                hir_id,\n-                data.source_span,\n-                |lint| {\n-                    let msg = format!(\n-                        \"{}`{}`{} held across a suspend point, but should not be\",\n-                        data.descr_pre,\n-                        tcx.def_path_str(def_id),\n-                        data.descr_post,\n-                    );\n-                    let mut err = lint.build(&msg);\n+    if let Some(attr) = tcx.get_attr(def_id, sym::must_not_suspend) {\n+        tcx.struct_span_lint_hir(\n+            rustc_session::lint::builtin::MUST_NOT_SUSPEND,\n+            hir_id,\n+            data.source_span,\n+            |lint| {\n+                let msg = format!(\n+                    \"{}`{}`{} held across a suspend point, but should not be\",\n+                    data.descr_pre,\n+                    tcx.def_path_str(def_id),\n+                    data.descr_post,\n+                );\n+                let mut err = lint.build(&msg);\n \n-                    // add span pointing to the offending yield/await\n-                    err.span_label(data.yield_span, \"the value is held across this suspend point\");\n+                // add span pointing to the offending yield/await\n+                err.span_label(data.yield_span, \"the value is held across this suspend point\");\n \n-                    // Add optional reason note\n-                    if let Some(note) = attr.value_str() {\n-                        // FIXME(guswynn): consider formatting this better\n-                        err.span_note(data.source_span, note.as_str());\n-                    }\n+                // Add optional reason note\n+                if let Some(note) = attr.value_str() {\n+                    // FIXME(guswynn): consider formatting this better\n+                    err.span_note(data.source_span, note.as_str());\n+                }\n \n-                    // Add some quick suggestions on what to do\n-                    // FIXME: can `drop` work as a suggestion here as well?\n-                    err.span_help(\n-                        data.source_span,\n-                        \"consider using a block (`{ ... }`) \\\n-                        to shrink the value's scope, ending before the suspend point\",\n-                    );\n+                // Add some quick suggestions on what to do\n+                // FIXME: can `drop` work as a suggestion here as well?\n+                err.span_help(\n+                    data.source_span,\n+                    \"consider using a block (`{ ... }`) \\\n+                    to shrink the value's scope, ending before the suspend point\",\n+                );\n \n-                    err.emit();\n-                },\n-            );\n+                err.emit();\n+            },\n+        );\n \n-            return true;\n-        }\n+        true\n+    } else {\n+        false\n     }\n-    false\n }"}, {"sha": "00f0d1e6f02a9744bd014ce2ab7e243789138e41", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -128,7 +128,8 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                 tcx.struct_span_lint_hir(lint, id, span, |lint| {\n                     // Removal suggestion span needs to include attributes (Issue #54400)\n                     let span_with_attrs = tcx\n-                        .get_attrs(extern_crate.def_id)\n+                        .hir()\n+                        .attrs(id)\n                         .iter()\n                         .map(|attr| attr.span)\n                         .fold(span, |acc, attr_span| acc.to(attr_span));\n@@ -166,13 +167,13 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             continue;\n         }\n \n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         // If the extern crate has any attributes, they may have funky\n         // semantics we can't faithfully represent using `use` (most\n         // notably `#[macro_use]`). Ignore it.\n-        if !tcx.get_attrs(extern_crate.def_id).is_empty() {\n+        if !tcx.hir().attrs(id).is_empty() {\n             continue;\n         }\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n             // Otherwise, we can convert it into a `use` of some kind.\n             let base_replacement = match extern_crate.orig_name {"}, {"sha": "cda817dee1e1e715514650dffaa1798c6d760623", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -1200,9 +1200,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n         ty::trait_def::TraitSpecializationKind::None\n     };\n     let must_implement_one_of = tcx\n-        .get_attrs(def_id)\n-        .iter()\n-        .find(|attr| attr.has_name(sym::rustc_must_implement_one_of))\n+        .get_attr(def_id, sym::rustc_must_implement_one_of)\n         // Check that there are at least 2 arguments of `#[rustc_must_implement_one_of]`\n         // and that they are all identifiers\n         .and_then(|attr| match attr.meta_item_list() {"}, {"sha": "67c6e791bfe584bd4902f98e6926b5065bfaf6aa", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c8265dc56d221dce7f3535ecf8cdee6b9d2d618/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=6c8265dc56d221dce7f3535ecf8cdee6b9d2d618", "patch": "@@ -298,17 +298,12 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         error = true;\n     }\n \n-    for attr in tcx.get_attrs(main_def_id) {\n-        if attr.has_name(sym::track_caller) {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr.span,\n-                    \"`main` function is not allowed to be `#[track_caller]`\",\n-                )\n-                .span_label(main_span, \"`main` function is not allowed to be `#[track_caller]`\")\n-                .emit();\n-            error = true;\n-        }\n+    for attr in tcx.get_attrs(main_def_id, sym::track_caller) {\n+        tcx.sess\n+            .struct_span_err(attr.span, \"`main` function is not allowed to be `#[track_caller]`\")\n+            .span_label(main_span, \"`main` function is not allowed to be `#[track_caller]`\")\n+            .emit();\n+        error = true;\n     }\n \n     if error {"}]}