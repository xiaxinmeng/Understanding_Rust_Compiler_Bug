{"sha": "fa8598cb5066b3463d53682170cc695af2c1b380", "node_id": "C_kwDOAAsO6NoAKGZhODU5OGNiNTA2NmIzNDYzZDUzNjgyMTcwY2M2OTVhZjJjMWIzODA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-17T10:37:29Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-17T10:37:29Z"}, "message": "Merge DominatorTree and Dominators.", "tree": {"sha": "8cab9177318cdecf643c5a68869746b9bbd9a034", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cab9177318cdecf643c5a68869746b9bbd9a034"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa8598cb5066b3463d53682170cc695af2c1b380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8598cb5066b3463d53682170cc695af2c1b380", "html_url": "https://github.com/rust-lang/rust/commit/fa8598cb5066b3463d53682170cc695af2c1b380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa8598cb5066b3463d53682170cc695af2c1b380/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bbdb64016a0a7e1713d7c35b40ed931a47e4d8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bbdb64016a0a7e1713d7c35b40ed931a47e4d8c", "html_url": "https://github.com/rust-lang/rust/commit/4bbdb64016a0a7e1713d7c35b40ed931a47e4d8c"}], "stats": {"total": 101, "additions": 40, "deletions": 61}, "files": [{"sha": "fae3589e6f1ee2877768a43b4d82268ff6c24602", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -155,7 +155,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if self.unwind_edge_count <= 1 {\n             return;\n         }\n-        let dom_tree = self.body.basic_blocks.dominator_tree();\n+        let dom_tree = self.body.basic_blocks.dominators();\n         let mut post_contract_node = FxHashMap::default();\n         // Reusing the allocation across invocations of the closure\n         let mut dom_path = vec![];"}, {"sha": "4868f49d8d5a1b03e592235b68c9342cbad49f7b", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -26,7 +26,7 @@ rustc_index::newtype_index! {\n     struct PreorderIndex {}\n }\n \n-pub fn dominator_tree<G: ControlFlowGraph>(graph: G) -> DominatorTree<G::Node> {\n+pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     // compute the post order index (rank) for each node\n     let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n \n@@ -244,7 +244,10 @@ pub fn dominator_tree<G: ControlFlowGraph>(graph: G) -> DominatorTree<G::Node> {\n \n     let start_node = graph.start_node();\n     immediate_dominators[start_node] = None;\n-    DominatorTree { start_node, post_order_rank, immediate_dominators }\n+\n+    let time = compute_access_time(start_node, &immediate_dominators);\n+\n+    Dominators { start_node, post_order_rank, immediate_dominators, time }\n }\n \n /// Evaluate the link-eval virtual forest, providing the currently minimum semi\n@@ -309,16 +312,17 @@ fn compress(\n \n /// Tracks the list of dominators for each node.\n #[derive(Clone, Debug)]\n-pub struct DominatorTree<N: Idx> {\n+pub struct Dominators<N: Idx> {\n     start_node: N,\n     post_order_rank: IndexVec<N, usize>,\n     // Even though we track only the immediate dominator of each node, it's\n     // possible to get its full list of dominators by looking up the dominator\n     // of each dominator. (See the `impl Iterator for Iter` definition).\n     immediate_dominators: IndexVec<N, Option<N>>,\n+    time: IndexVec<N, Time>,\n }\n \n-impl<Node: Idx> DominatorTree<Node> {\n+impl<Node: Idx> Dominators<Node> {\n     /// Returns true if node is reachable from the start node.\n     pub fn is_reachable(&self, node: Node) -> bool {\n         node == self.start_node || self.immediate_dominators[node].is_some()\n@@ -343,10 +347,22 @@ impl<Node: Idx> DominatorTree<Node> {\n     pub fn rank_partial_cmp(&self, lhs: Node, rhs: Node) -> Option<Ordering> {\n         self.post_order_rank[rhs].partial_cmp(&self.post_order_rank[lhs])\n     }\n+\n+    /// Returns true if `a` dominates `b`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `b` is unreachable.\n+    pub fn dominates(&self, a: Node, b: Node) -> bool {\n+        let a = self.time[a];\n+        let b = self.time[b];\n+        assert!(b.start != 0, \"node {b:?} is not reachable\");\n+        a.start <= b.start && b.finish <= a.finish\n+    }\n }\n \n pub struct Iter<'dom, Node: Idx> {\n-    dom_tree: &'dom DominatorTree<Node>,\n+    dom_tree: &'dom Dominators<Node>,\n     node: Option<Node>,\n }\n \n@@ -363,11 +379,6 @@ impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct Dominators<Node: Idx> {\n-    time: IndexVec<Node, Time>,\n-}\n-\n /// Describes the number of vertices discovered at the time when processing of a particular vertex\n /// started and when it finished. Both values are zero for unreachable vertices.\n #[derive(Copy, Clone, Default, Debug)]\n@@ -376,27 +387,10 @@ struct Time {\n     finish: u32,\n }\n \n-impl<Node: Idx> Dominators<Node> {\n-    pub fn dummy() -> Self {\n-        Self { time: Default::default() }\n-    }\n-\n-    /// Returns true if `a` dominates `b`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `b` is unreachable.\n-    pub fn dominates(&self, a: Node, b: Node) -> bool {\n-        let a = self.time[a];\n-        let b = self.time[b];\n-        assert!(b.start != 0, \"node {b:?} is not reachable\");\n-        a.start <= b.start && b.finish <= a.finish\n-    }\n-}\n-\n-pub fn dominators<N: Idx>(tree: &DominatorTree<N>) -> Dominators<N> {\n-    let DominatorTree { start_node, ref immediate_dominators, post_order_rank: _ } = *tree;\n-\n+fn compute_access_time<N: Idx>(\n+    start_node: N,\n+    immediate_dominators: &IndexSlice<N, Option<N>>,\n+) -> IndexVec<N, Time> {\n     // Transpose the dominator tree edges, so that child nodes of vertex v are stored in\n     // node[edges[v].start..edges[v].end].\n     let mut edges: IndexVec<N, std::ops::Range<u32>> =\n@@ -446,5 +440,5 @@ pub fn dominators<N: Idx>(tree: &DominatorTree<N>) -> Dominators<N> {\n         }\n     }\n \n-    Dominators { time }\n+    time\n }"}, {"sha": "31531fe3e2aec1f84ac289e34b70e9d52ad3d09a", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -6,7 +6,7 @@ use super::super::tests::TestGraph;\n fn diamond() {\n     let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n \n-    let tree = dominator_tree(&graph);\n+    let tree = dominators(&graph);\n     let immediate_dominators = &tree.immediate_dominators;\n     assert_eq!(immediate_dominators[0], None);\n     assert_eq!(immediate_dominators[1], Some(0));\n@@ -22,7 +22,7 @@ fn paper() {\n         &[(6, 5), (6, 4), (5, 1), (4, 2), (4, 3), (1, 2), (2, 3), (3, 2), (2, 1)],\n     );\n \n-    let dom_tree = dominator_tree(&graph);\n+    let dom_tree = dominators(&graph);\n     let immediate_dominators = &dom_tree.immediate_dominators;\n     assert_eq!(immediate_dominators[0], None); // <-- note that 0 is not in graph\n     assert_eq!(immediate_dominators[1], Some(6));\n@@ -41,13 +41,13 @@ fn paper_slt() {\n         &[(1, 2), (1, 3), (2, 3), (2, 7), (3, 4), (3, 6), (4, 5), (5, 4), (6, 7), (7, 8), (8, 5)],\n     );\n \n-    dominator_tree(&graph);\n+    dominators(&graph);\n }\n \n #[test]\n fn immediate_dominator() {\n     let graph = TestGraph::new(1, &[(1, 2), (2, 3)]);\n-    let tree = dominator_tree(&graph);\n+    let tree = dominators(&graph);\n     assert_eq!(tree.immediate_dominator(0), None);\n     assert_eq!(tree.immediate_dominator(1), None);\n     assert_eq!(tree.immediate_dominator(2), Some(1));"}, {"sha": "9d70dbfa0722120bc7f01738abd2ecc5e82242ab", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -3,7 +3,6 @@ use crate::mir::{BasicBlock, BasicBlockData, Successors, Terminator, TerminatorK\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n-use rustc_data_structures::graph::dominators::{dominator_tree, DominatorTree};\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n@@ -28,7 +27,6 @@ struct Cache {\n     switch_sources: OnceCell<SwitchSources>,\n     is_cyclic: OnceCell<bool>,\n     postorder: OnceCell<Vec<BasicBlock>>,\n-    dominator_tree: OnceCell<DominatorTree<BasicBlock>>,\n     dominators: OnceCell<Dominators<BasicBlock>>,\n }\n \n@@ -44,12 +42,8 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n-    pub fn dominator_tree(&self) -> &DominatorTree<BasicBlock> {\n-        self.cache.dominator_tree.get_or_init(|| dominator_tree(&self))\n-    }\n-\n     pub fn dominators(&self) -> &Dominators<BasicBlock> {\n-        self.cache.dominators.get_or_init(|| dominators(self.dominator_tree()))\n+        self.cache.dominators.get_or_init(|| dominators(self))\n     }\n \n     /// Returns predecessors for each basic block."}, {"sha": "ea1223fbca6429578865bcda48d9c04e6634f9df", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -2,7 +2,7 @@ use super::Error;\n \n use itertools::Itertools;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::dominators::{self, DominatorTree, Dominators};\n+use rustc_data_structures::graph::dominators::{self, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors, WithNumNodes, WithStartNode};\n use rustc_index::bit_set::BitSet;\n use rustc_index::{IndexSlice, IndexVec};\n@@ -25,7 +25,6 @@ pub(super) struct CoverageGraph {\n     bb_to_bcb: IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n     pub successors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n     pub predecessors: IndexVec<BasicCoverageBlock, Vec<BasicCoverageBlock>>,\n-    dominator_tree: Option<DominatorTree<BasicCoverageBlock>>,\n     dominators: Option<Dominators<BasicCoverageBlock>>,\n }\n \n@@ -68,17 +67,9 @@ impl CoverageGraph {\n             }\n         }\n \n-        let mut basic_coverage_blocks = Self {\n-            bcbs,\n-            bb_to_bcb,\n-            successors,\n-            predecessors,\n-            dominator_tree: None,\n-            dominators: None,\n-        };\n-        let dominator_tree = dominators::dominator_tree(&basic_coverage_blocks);\n-        let dominators = dominators::dominators(&dominator_tree);\n-        basic_coverage_blocks.dominator_tree = Some(dominator_tree);\n+        let mut basic_coverage_blocks =\n+            Self { bcbs, bb_to_bcb, successors, predecessors, dominators: None };\n+        let dominators = dominators::dominators(&basic_coverage_blocks);\n         basic_coverage_blocks.dominators = Some(dominators);\n         basic_coverage_blocks\n     }\n@@ -227,7 +218,7 @@ impl CoverageGraph {\n         a: BasicCoverageBlock,\n         b: BasicCoverageBlock,\n     ) -> Option<Ordering> {\n-        self.dominator_tree.as_ref().unwrap().rank_partial_cmp(a, b)\n+        self.dominators.as_ref().unwrap().rank_partial_cmp(a, b)\n     }\n }\n "}, {"sha": "1b3ac78fbc664feca889e12b9527507ba7634b9b", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8598cb5066b3463d53682170cc695af2c1b380/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=fa8598cb5066b3463d53682170cc695af2c1b380", "patch": "@@ -2,7 +2,7 @@\n //! (thus indicating there is a loop in the CFG), or whose terminator is a function call.\n use crate::MirPass;\n \n-use rustc_data_structures::graph::dominators::DominatorTree;\n+use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::{\n     BasicBlock, BasicBlockData, Body, Statement, StatementKind, TerminatorKind,\n };\n@@ -13,7 +13,7 @@ pub struct CtfeLimit;\n impl<'tcx> MirPass<'tcx> for CtfeLimit {\n     #[instrument(skip(self, _tcx, body))]\n     fn run_pass(&self, _tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let doms = body.basic_blocks.dominator_tree();\n+        let doms = body.basic_blocks.dominators();\n         let indices: Vec<BasicBlock> = body\n             .basic_blocks\n             .iter_enumerated()\n@@ -39,7 +39,7 @@ impl<'tcx> MirPass<'tcx> for CtfeLimit {\n }\n \n fn has_back_edge(\n-    doms: &DominatorTree<BasicBlock>,\n+    doms: &Dominators<BasicBlock>,\n     node: BasicBlock,\n     node_data: &BasicBlockData<'_>,\n ) -> bool {"}]}