{"sha": "dd1832c01661e19b8fc4da1111c0263468144ef2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTgzMmMwMTY2MWUxOWI4ZmM0ZGExMTExYzAyNjM0NjgxNDRlZjI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-12T18:35:38Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-12T18:35:38Z"}, "message": "Indent block expressions on enter", "tree": {"sha": "2e800b88fe2e25ec7e52ba9ad4cc44d96c5dd8de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e800b88fe2e25ec7e52ba9ad4cc44d96c5dd8de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd1832c01661e19b8fc4da1111c0263468144ef2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1832c01661e19b8fc4da1111c0263468144ef2", "html_url": "https://github.com/rust-lang/rust/commit/dd1832c01661e19b8fc4da1111c0263468144ef2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd1832c01661e19b8fc4da1111c0263468144ef2/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f25676f0cb8e89d621d9da5951a54ef814dbd0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f25676f0cb8e89d621d9da5951a54ef814dbd0f", "html_url": "https://github.com/rust-lang/rust/commit/9f25676f0cb8e89d621d9da5951a54ef814dbd0f"}], "stats": {"total": 224, "additions": 212, "deletions": 12}, "files": [{"sha": "9a0696c6c53d9b9e5ed926ef864554b1f18735e4", "filename": "crates/ide/src/typing/on_enter.rs", "status": "modified", "additions": 212, "deletions": 12, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/dd1832c01661e19b8fc4da1111c0263468144ef2/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1832c01661e19b8fc4da1111c0263468144ef2/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=dd1832c01661e19b8fc4da1111c0263468144ef2", "patch": "@@ -1,13 +1,20 @@\n //! Handles the `Enter` key press. At the momently, this only continues\n //! comments, but should handle indent some time in the future as well.\n \n-use ide_db::base_db::{FilePosition, SourceDatabase};\n+use std::sync::Arc;\n+\n use ide_db::RootDatabase;\n+use ide_db::{\n+    base_db::{FilePosition, SourceDatabase},\n+    line_index::LineIndex,\n+    LineIndexDatabase,\n+};\n use syntax::{\n-    ast::{self, AstToken},\n+    algo::find_node_at_offset,\n+    ast::{self, edit::IndentLevel, AstToken},\n     AstNode, SmolStr, SourceFile,\n     SyntaxKind::*,\n-    SyntaxToken, TextRange, TextSize, TokenAtOffset,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset,\n };\n \n use text_edit::TextEdit;\n@@ -19,6 +26,7 @@ use text_edit::TextEdit;\n // - kbd:[Enter] inside triple-slash comments automatically inserts `///`\n // - kbd:[Enter] in the middle or after a trailing space in `//` inserts `//`\n // - kbd:[Enter] inside `//!` doc comments automatically inserts `//!`\n+// - kbd:[Enter] after `{` indents contents and closing `}` of single-line block\n //\n // This action needs to be assigned to shortcut explicitly.\n //\n@@ -38,25 +46,42 @@ use text_edit::TextEdit;\n pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<TextEdit> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n-    let comment = file\n-        .syntax()\n-        .token_at_offset(position.offset)\n-        .left_biased()\n-        .and_then(ast::Comment::cast)?;\n+    let token = file.syntax().token_at_offset(position.offset).left_biased()?;\n+\n+    if let Some(comment) = ast::Comment::cast(token.clone()) {\n+        return on_enter_in_comment(&comment, &file, position.offset);\n+    }\n+\n+    if token.kind() == L_CURLY {\n+        // Typing enter after the `{` of a block expression, where the `}` is on the same line\n+        if let Some(edit) = find_node_at_offset(file.syntax(), position.offset - TextSize::of('{'))\n+            .and_then(|block| on_enter_in_block(db, block, position))\n+        {\n+            return Some(edit);\n+        }\n+    }\n \n+    None\n+}\n+\n+fn on_enter_in_comment(\n+    comment: &ast::Comment,\n+    file: &ast::SourceFile,\n+    offset: TextSize,\n+) -> Option<TextEdit> {\n     if comment.kind().shape.is_block() {\n         return None;\n     }\n \n     let prefix = comment.prefix();\n     let comment_range = comment.syntax().text_range();\n-    if position.offset < comment_range.start() + TextSize::of(prefix) {\n+    if offset < comment_range.start() + TextSize::of(prefix) {\n         return None;\n     }\n \n     let mut remove_trailing_whitespace = false;\n     // Continuing single-line non-doc comments (like this one :) ) is annoying\n-    if prefix == \"//\" && comment_range.end() == position.offset {\n+    if prefix == \"//\" && comment_range.end() == offset {\n         if comment.text().ends_with(' ') {\n             cov_mark::hit!(continues_end_of_line_comment_with_space);\n             remove_trailing_whitespace = true;\n@@ -70,14 +95,50 @@ pub(crate) fn on_enter(db: &RootDatabase, position: FilePosition) -> Option<Text\n     let delete = if remove_trailing_whitespace {\n         let trimmed_len = comment.text().trim_end().len() as u32;\n         let trailing_whitespace_len = comment.text().len() as u32 - trimmed_len;\n-        TextRange::new(position.offset - TextSize::from(trailing_whitespace_len), position.offset)\n+        TextRange::new(offset - TextSize::from(trailing_whitespace_len), offset)\n     } else {\n-        TextRange::empty(position.offset)\n+        TextRange::empty(offset)\n     };\n     let edit = TextEdit::replace(delete, inserted);\n     Some(edit)\n }\n \n+fn on_enter_in_block(\n+    db: &RootDatabase,\n+    block: ast::BlockExpr,\n+    position: FilePosition,\n+) -> Option<TextEdit> {\n+    let contents = block_contents(&block)?;\n+\n+    let line_index: Arc<LineIndex> = db.line_index(position.file_id);\n+    let (open, close) = (block.l_curly_token()?, block.r_curly_token()?);\n+    let start = line_index.line_col(open.text_range().start()).line;\n+    let end = line_index.line_col(close.text_range().end()).line;\n+    if start != end {\n+        return None;\n+    }\n+\n+    let indent = IndentLevel::from_node(block.syntax());\n+    let mut edit = TextEdit::insert(position.offset, format!(\"\\n{}$0\", indent + 1));\n+    edit.union(TextEdit::insert(contents.text_range().end(), format!(\"\\n{}\", indent))).ok()?;\n+    Some(edit)\n+}\n+\n+fn block_contents(block: &ast::BlockExpr) -> Option<SyntaxNode> {\n+    let mut node = block.tail_expr().map(|e| e.syntax().clone());\n+\n+    for stmt in block.statements() {\n+        if node.is_some() {\n+            // More than 1 node in the block\n+            return None;\n+        }\n+\n+        node = Some(stmt.syntax().clone());\n+    }\n+\n+    node\n+}\n+\n fn followed_by_comment(comment: &ast::Comment) -> bool {\n     let ws = match comment.syntax().next_token().and_then(ast::Whitespace::cast) {\n         Some(it) => it,\n@@ -296,4 +357,143 @@ fn main() {\n \",\n         );\n     }\n+\n+    #[test]\n+    fn indents_fn_body_block() {\n+        do_check(\n+            r#\"\n+fn f() {$0()}\n+        \"#,\n+            r#\"\n+fn f() {\n+    $0()\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn indents_block_expr() {\n+        do_check(\n+            r#\"\n+fn f() {\n+    let x = {$0()};\n+}\n+        \"#,\n+            r#\"\n+fn f() {\n+    let x = {\n+        $0()\n+    };\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn indents_match_arm() {\n+        do_check(\n+            r#\"\n+fn f() {\n+    match 6 {\n+        1 => {$0f()},\n+        _ => (),\n+    }\n+}\n+        \"#,\n+            r#\"\n+fn f() {\n+    match 6 {\n+        1 => {\n+            $0f()\n+        },\n+        _ => (),\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn indents_block_with_statement() {\n+        do_check(\n+            r#\"\n+fn f() {$0a = b}\n+        \"#,\n+            r#\"\n+fn f() {\n+    $0a = b\n+}\n+        \"#,\n+        );\n+        do_check(\n+            r#\"\n+fn f() {$0fn f() {}}\n+        \"#,\n+            r#\"\n+fn f() {\n+    $0fn f() {}\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn indents_nested_blocks() {\n+        do_check(\n+            r#\"\n+fn f() {$0{}}\n+        \"#,\n+            r#\"\n+fn f() {\n+    $0{}\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_indent_empty_block() {\n+        do_check_noop(\n+            r#\"\n+fn f() {$0}\n+        \"#,\n+        );\n+        do_check_noop(\n+            r#\"\n+fn f() {{$0}}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_indent_block_with_too_much_content() {\n+        do_check_noop(\n+            r#\"\n+fn f() {$0 a = b; ()}\n+        \"#,\n+        );\n+        do_check_noop(\n+            r#\"\n+fn f() {$0 a = b; a = b; }\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_indent_multiline_block() {\n+        do_check_noop(\n+            r#\"\n+fn f() {$0\n+}\n+        \"#,\n+        );\n+        do_check_noop(\n+            r#\"\n+fn f() {$0\n+\n+}\n+        \"#,\n+        );\n+    }\n }"}]}