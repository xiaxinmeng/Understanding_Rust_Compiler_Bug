{"sha": "212b6c25507b963b60a646a2ff3df7496bd30acf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMmI2YzI1NTA3Yjk2M2I2MGE2NDZhMmZmM2RmNzQ5NmJkMzBhY2Y=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-05T05:15:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T16:08:32Z"}, "message": "Refactor out `ast::ItemKind::MacroDef`.", "tree": {"sha": "8fd7c3e2317c5b9c92e17aaec9b4c48a72f75ac7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8fd7c3e2317c5b9c92e17aaec9b4c48a72f75ac7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212b6c25507b963b60a646a2ff3df7496bd30acf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212b6c25507b963b60a646a2ff3df7496bd30acf", "html_url": "https://github.com/rust-lang/rust/commit/212b6c25507b963b60a646a2ff3df7496bd30acf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212b6c25507b963b60a646a2ff3df7496bd30acf/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f573db4f80c75f156df8a743f456bf087ec81dc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f573db4f80c75f156df8a743f456bf087ec81dc2", "html_url": "https://github.com/rust-lang/rust/commit/f573db4f80c75f156df8a743f456bf087ec81dc2"}], "stats": {"total": 368, "additions": 172, "deletions": 196}, "files": [{"sha": "f9f63ccbfde7e8d9eb6109e516fa9b2e031af9c8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -79,6 +79,7 @@ pub struct LoweringContext<'a> {\n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: BTreeMap<hir::BodyId, hir::Body>,\n+    exported_macros: Vec<hir::MacroDef>,\n \n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n@@ -121,6 +122,7 @@ pub fn lower_crate(sess: &Session,\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n+        exported_macros: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -170,9 +172,10 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &'lcx Item) {\n-                let hir_item = self.lctx.lower_item(item);\n-                self.lctx.items.insert(item.id, hir_item);\n-                visit::walk_item(self, item);\n+                if let Some(hir_item) = self.lctx.lower_item(item) {\n+                    self.lctx.items.insert(item.id, hir_item);\n+                    visit::walk_item(self, item);\n+                }\n             }\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n@@ -195,14 +198,13 @@ impl<'a> LoweringContext<'a> {\n \n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n-        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n         let body_ids = body_ids(&self.bodies);\n \n         hir::Crate {\n             module: module,\n             attrs: attrs,\n             span: c.span,\n-            exported_macros: exported_macros,\n+            exported_macros: hir::HirVec::from(self.exported_macros),\n             items: self.items,\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n@@ -1134,7 +1136,7 @@ impl<'a> LoweringContext<'a> {\n                                bounds,\n                                items)\n             }\n-            ItemKind::Mac(_) => panic!(\"Shouldn't still be around\"),\n+            ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n         }\n     }\n \n@@ -1256,42 +1258,45 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_macro_def(&mut self, m: &MacroDef) -> hir::MacroDef {\n-        hir::MacroDef {\n-            name: m.ident.name,\n-            attrs: self.lower_attrs(&m.attrs),\n-            id: m.id,\n-            span: m.span,\n-            body: m.body.clone().into(),\n-        }\n-    }\n-\n     fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n-        if let ItemKind::Use(ref view_path) = i.node {\n-            if let ViewPathList(_, ref imports) = view_path.node {\n-                return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n-                    .map(|id| hir::ItemId { id: id }).collect();\n+        match i.node {\n+            ItemKind::Use(ref view_path) => {\n+                if let ViewPathList(_, ref imports) = view_path.node {\n+                    return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n+                        .map(|id| hir::ItemId { id: id }).collect();\n+                }\n             }\n+            ItemKind::MacroDef(..) => return SmallVector::new(),\n+            _ => {}\n         }\n         SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> hir::Item {\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut name = i.ident.name;\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n+        if let ItemKind::MacroDef(ref tts, _) = i.node {\n+            if i.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+                self.exported_macros.push(hir::MacroDef {\n+                    name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),\n+                });\n+            }\n+            return None;\n+        }\n+\n         let node = self.with_parent_def(i.id, |this| {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n-        hir::Item {\n+        Some(hir::Item {\n             id: i.id,\n             name: name,\n             attrs: attrs,\n             node: node,\n             vis: vis,\n             span: i.span,\n-        }\n+        })\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {"}, {"sha": "f15e063e81e337ce6e53e9df924fc67a234ebf4e", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -108,7 +108,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n@@ -269,10 +269,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'a MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n-    }\n-\n     fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),"}, {"sha": "e9fb4632fa178c4cb6029adb0faae13aecd2d718", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -136,7 +136,7 @@ pub struct NativeLibrary {\n }\n \n pub enum LoadedMacro {\n-    MacroRules(ast::MacroDef),\n+    MacroDef(ast::Item),\n     ProcMacro(Rc<SyntaxExtension>),\n }\n "}, {"sha": "e458d45bbd6e8cdd6a4ca1b19f356756b38afe80", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -43,7 +43,6 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n-use std::mem;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n@@ -705,8 +704,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         krate\n     });\n \n-    krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());\n-\n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n                                          &mut resolver,"}, {"sha": "cfe67726ab2285af3b4cfd48ccfc5f92c38619bd", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -34,6 +34,7 @@ use std::rc::Rc;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::hygiene::Mark;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{mk_sp, Span};\n@@ -414,12 +415,13 @@ impl CrateStore for cstore::CStore {\n         sess.imported_macro_spans.borrow_mut()\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n-        LoadedMacro::MacroRules(ast::MacroDef {\n+        LoadedMacro::MacroDef(ast::Item {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs,\n-            body: body.into(),\n+            node: ast::ItemKind::MacroDef(body.into(), Mark::fresh()),\n+            vis: ast::Visibility::Inherited,\n         })\n     }\n "}, {"sha": "749146fe49672a766c755e2fd02b180fbadf57cc", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -375,9 +375,4 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::None, attr);\n     }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'v ast::MacroDef) {\n-        self.record(\"MacroDef\", Id::None, macro_def);\n-        ast_visit::walk_macro_def(self, macro_def)\n-    }\n }"}, {"sha": "8b20c31be03b7dac692eaa2c54f5ec73f32d2c57", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -37,7 +37,6 @@ use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n-use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token;\n@@ -373,7 +372,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n-            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n+            ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n         }\n     }\n \n@@ -502,22 +501,21 @@ impl<'a> Resolver<'a> {\n             return ext.clone();\n         }\n \n-        let mut macro_rules = match self.session.cstore.load_macro(def_id, &self.session) {\n-            LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+        let macro_def = match self.session.cstore.load_macro(def_id, &self.session) {\n+            LoadedMacro::MacroDef(macro_def) => macro_def,\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let mark = Mark::fresh();\n         let invocation = self.arenas.alloc_invocation_data(InvocationData {\n             module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n-            def_index: CRATE_DEF_INDEX,\n-            const_expr: false,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n+            // FIXME(jseyfried) the following are irrelevant\n+            def_index: CRATE_DEF_INDEX, const_expr: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty), expansion: Cell::new(LegacyScope::Empty),\n         });\n-        self.invocations.insert(mark, invocation);\n-        macro_rules.body = mark_tts(macro_rules.stream(), mark).into();\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_rules));\n+        if let ast::ItemKind::MacroDef(_, mark) = macro_def.node {\n+            self.invocations.insert(mark, invocation);\n+        }\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext\n     }\n@@ -707,12 +705,12 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(ref mac) => {\n-                if mac.node.path.segments.is_empty() {\n-                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n-                } else {\n-                    self.resolver.define_macro(item, &mut self.legacy_scope);\n-                }\n+            ItemKind::MacroDef(..) => {\n+                self.resolver.define_macro(item, &mut self.legacy_scope);\n+                return\n+            }\n+            ItemKind::Mac(..) => {\n+                self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),"}, {"sha": "9ea129c2efbf695f5c9c8a6fb61896afe15af6f7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -1092,10 +1092,6 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n-    // Maps the node id of a statement to the expansions of the `macro_rules!`s\n-    // immediately above the statement (if appropriate).\n-    macros_at_scope: FxHashMap<NodeId, Vec<Mark>>,\n-\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n@@ -1171,7 +1167,6 @@ pub struct Resolver<'a> {\n     dummy_binding: &'a NameBinding<'a>,\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n-    pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n     builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n@@ -1309,7 +1304,6 @@ impl<'a> Resolver<'a> {\n             session: session,\n \n             definitions: definitions,\n-            macros_at_scope: FxHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1365,7 +1359,6 @@ impl<'a> Resolver<'a> {\n             // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n             use_extern_macros: features.use_extern_macros || features.proc_macro,\n \n-            exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),\n             builtin_macros: FxHashMap(),\n@@ -1696,7 +1689,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            ItemKind::ExternCrate(_) => {\n+            ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) => {\n                 // do nothing, these are just around to be encoded\n             }\n \n@@ -2031,9 +2024,9 @@ impl<'a> Resolver<'a> {\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n-            if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n-                num_macro_definition_ribs += marks.len() as u32;\n-                for mark in marks {\n+            if let ast::StmtKind::Item(ref item) = stmt.node {\n+                if let ast::ItemKind::MacroDef(_, mark) = item.node {\n+                    num_macro_definition_ribs += 1;\n                     self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n                     self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n                 }"}, {"sha": "fc6b1baca160b7f0fbc0c5161ad1d2d0b7803d8a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -25,15 +25,14 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n use syntax::ext::base::MacroKind;\n-use syntax::ext::expand::{Expansion, mark_tts};\n+use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Clone)]\n@@ -151,7 +150,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::new(self.macro_map.len()),\n@@ -167,10 +166,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.builtin_macros.insert(ident.name, binding);\n     }\n \n-    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n-        self.macros_at_scope.insert(id, macros);\n-    }\n-\n     fn resolve_imports(&mut self) {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n@@ -544,45 +539,33 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n-        let tts = match item.node {\n-            ast::ItemKind::Mac(ref mac) => mac.node.stream(),\n-            _ => unreachable!(),\n-        };\n-\n         if item.ident.name == \"macro_rules\" {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n-        let mark = Mark::from_placeholder_id(item.id);\n-        let invocation = self.invocations[&mark];\n-        invocation.module.set(self.current_module);\n-\n-        let mut def = ast::MacroDef {\n-            ident: item.ident,\n-            attrs: item.attrs.clone(),\n-            id: ast::DUMMY_NODE_ID,\n-            span: item.span,\n-            body: mark_tts(tts, mark).into(),\n-        };\n+        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n+            module: Cell::new(self.current_module),\n+            // FIXME(jseyfried) the following are irrelevant\n+            def_index: CRATE_DEF_INDEX, const_integer: false,\n+            legacy_scope: Cell::new(LegacyScope::Empty), expansion: Cell::new(LegacyScope::Empty),\n+        });\n+        if let ast::ItemKind::MacroDef(_, mark) = item.node {\n+            self.invocations.insert(mark, invocation);\n+        }\n \n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n             parent: Cell::new(*legacy_scope),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n+            name: item.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, item)),\n+            span: item.span,\n         }));\n-        self.macro_names.insert(def.ident.name);\n+        self.macro_names.insert(item.ident.name);\n \n-        if attr::contains_name(&def.attrs, \"macro_export\") {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n+        if attr::contains_name(&item.attrs, \"macro_export\") {\n             self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id), MacroKind::Bang),\n+                name: item.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(item.id), MacroKind::Bang),\n             });\n-            self.exported_macros.push(def);\n         }\n     }\n "}, {"sha": "35d459422033fb687a07b8d5bb7ff9264c9d3580", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -16,6 +16,7 @@ use std::mem;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::tokenstream::TokenStream;\n use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n@@ -205,14 +206,17 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                     let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n                     let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n-                        LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+                        LoadedMacro::MacroDef(macro_def) => macro_def,\n                         // FIXME(jseyfried): document proc macro reexports\n                         LoadedMacro::ProcMacro(..) => continue,\n                     };\n \n-                    // FIXME(jseyfried) merge with `self.visit_macro()`\n-                    let tts = def.stream().trees().collect::<Vec<_>>();\n-                    let matchers = tts.chunks(4).map(|arm| arm[0].span()).collect();\n+                    let matchers = if let ast::ItemKind::MacroDef(ref tokens, _) = def.node {\n+                        let tts: Vec<_> = TokenStream::from(tokens.clone()).into_trees().collect();\n+                        tts.chunks(4).map(|arm| arm[0].span()).collect()\n+                    } else {\n+                        unreachable!()\n+                    };\n                     om.macros.push(Macro {\n                         def_id: def_id,\n                         attrs: def.attrs.clone().into(),"}, {"sha": "a79cfc2bceb33d467a43841ee47dab7d98f3885e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -20,7 +20,7 @@ pub use util::ThinVec;\n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n-use ext::hygiene::SyntaxContext;\n+use ext::hygiene::{Mark, SyntaxContext};\n use print::pprust;\n use ptr::P;\n use symbol::{Symbol, keywords};\n@@ -414,7 +414,6 @@ pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub span: Span,\n-    pub exported_macros: Vec<MacroDef>,\n }\n \n /// A spanned compile-time attribute list item.\n@@ -1855,10 +1854,13 @@ pub enum ItemKind {\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n              Vec<ImplItem>),\n-    /// A macro invocation (which includes macro definition).\n+    /// A macro invocation.\n     ///\n     /// E.g. `macro_rules! foo { .. }` or `foo!(..)`\n     Mac(Mac),\n+\n+    /// A macro definition.\n+    MacroDef(ThinTokenStream, Mark /* FIXME(jseyfried) remove this */),\n }\n \n impl ItemKind {\n@@ -1877,6 +1879,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::Mac(..) |\n+            ItemKind::MacroDef(..) |\n             ItemKind::Impl(..) |\n             ItemKind::DefaultImpl(..) => \"item\"\n         }\n@@ -1912,24 +1915,6 @@ impl ForeignItemKind {\n     }\n }\n \n-/// A macro definition, in this crate or imported from another.\n-///\n-/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct MacroDef {\n-    pub ident: Ident,\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub body: ThinTokenStream,\n-}\n-\n-impl MacroDef {\n-    pub fn stream(&self) -> TokenStream {\n-        self.body.clone().into()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use serialize;"}, {"sha": "39d919106147dda7e9a8943bf9869af23f19ddc3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -552,8 +552,7 @@ pub trait Resolver {\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n-    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n-    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n@@ -577,8 +576,7 @@ impl Resolver for DummyResolver {\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n-    fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n-    fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n+    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }"}, {"sha": "8451414ec3d8a7b13d3c6796c890451c92af402e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -948,17 +948,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n-                let is_macro_def = if let ItemKind::Mac(ref mac) = item.node {\n-                    mac.node.path.segments[0].identifier.name == \"macro_rules\"\n-                } else {\n-                    unreachable!()\n-                };\n-\n-                item.and_then(|mut item| match item.node {\n-                    ItemKind::Mac(_) if is_macro_def => {\n-                        item.id = Mark::fresh().as_placeholder_id();\n-                        SmallVector::one(P(item))\n-                    }\n+                item.and_then(|item| match item.node {\n                     ItemKind::Mac(mac) => {\n                         self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,\n@@ -1078,7 +1068,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n+        match item {\n+            ast::ItemKind::MacroDef(..) => item,\n+            _ => noop_fold_item_kind(self.cfg.configure_item_kind(item), self),\n+        }\n     }\n \n     fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {"}, {"sha": "83c51bb9d2fcfaf1f42d808da9156bed3e0794d6", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -31,7 +31,7 @@ pub struct SyntaxContextData {\n }\n \n /// A mark is a unique id associated with a macro expansion.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n impl Mark {"}, {"sha": "f60b1d17a5e2f0c3c74058602712b3d172b35148", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -21,7 +21,6 @@ use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n-use std::mem;\n \n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n@@ -174,20 +173,11 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n \n     fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n         noop_fold_block(block, self).map(|mut block| {\n-            let mut macros = Vec::new();\n             let mut remaining_stmts = block.stmts.len();\n \n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                // `macro_rules!` macro definition\n-                if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(_) = item.node {\n-                        macros.push(Mark::from_placeholder_id(item.id));\n-                        return None;\n-                    }\n-                }\n-\n                 match stmt.node {\n                     // Avoid wasting a node id on a trailing expression statement,\n                     // which shares a HIR node with the expression itself.\n@@ -201,11 +191,6 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n                     _ => {}\n                 }\n \n-                if self.monotonic && !macros.is_empty() {\n-                    let macros = mem::replace(&mut macros, Vec::new());\n-                    self.cx.resolver.add_expansions_at_stmt(stmt.id, macros);\n-                }\n-\n                 Some(stmt)\n             });\n "}, {"sha": "8ad679b853e856cfea72177546d97d96fdfb2dd0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -12,7 +12,7 @@ use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n-use ext::expand::{Expansion, ExpansionKind};\n+use ext::expand::{Expansion, ExpansionKind, mark_tts};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -153,7 +153,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -183,7 +183,11 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     ];\n \n     // Parse the macro_rules! invocation\n-    let argument_map = match parse(sess, def.body.clone().into(), &argument_gram, None) {\n+    let body = match def.node {\n+        ast::ItemKind::MacroDef(ref body, mark) => mark_tts(body.clone().into(), mark),\n+        _ => unreachable!(),\n+    };\n+    let argument_map = match parse(sess, body, &argument_gram, None) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);"}, {"sha": "d23f880bc7bac6901623a3bd9f0b9b946302bdae", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -899,6 +899,8 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             items.move_flat_map(|item| folder.fold_trait_item(item)),\n         ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n+        ItemKind::MacroDef(tts, mark) => ItemKind::MacroDef(folder.fold_tts(tts.into()).into(),\n+                                                            mark),\n     }\n }\n \n@@ -959,7 +961,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n                                   folder: &mut T) -> Crate {\n     let mut items = folder.fold_item(P(ast::Item {\n         ident: keywords::Invalid.ident(),\n@@ -987,14 +989,9 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, spa\n         }, vec![], span)\n     };\n \n-    for def in &mut exported_macros {\n-        def.id = folder.new_id(def.id);\n-    }\n-\n     Crate {\n         module: module,\n         attrs: attrs,\n-        exported_macros: exported_macros,\n         span: span,\n     }\n }\n@@ -1387,6 +1384,6 @@ mod tests {\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n-            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n+            \"macro_rules! zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n     }\n }"}, {"sha": "d81732489dd3d68b909e5d199c3d77909a1335bf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -43,6 +43,7 @@ use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n use syntax_pos::{self, Span, Pos, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n+use ext::hygiene::Mark;\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n use parse::lexer::TokenAndSpan;\n@@ -1048,7 +1049,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.clear();\n     }\n \n-    pub fn look_ahead<R, F>(&mut self, dist: usize, f: F) -> R where\n+    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n         F: FnOnce(&token::Token) -> R,\n     {\n         if dist == 0 {\n@@ -3699,11 +3700,41 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn is_union_item(&mut self) -> bool {\n+    fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n     }\n \n+    fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n+                     -> PResult<'a, Option<P<Item>>> {\n+        let lo = self.span.lo;\n+        match self.token {\n+            token::Ident(ident) if ident.name == \"macro_rules\" => {\n+                if self.look_ahead(1, |t| *t == token::Not) {\n+                    let prev_span = self.prev_span;\n+                    self.complain_if_pub_macro(vis, prev_span);\n+                    self.bump();\n+                    self.bump();\n+                }\n+            }\n+            _ => return Ok(None),\n+        };\n+\n+        let id = self.parse_ident()?;\n+        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        if delim != token::Brace {\n+            if !self.eat(&token::Semi) {\n+                let msg = \"macros that expand to items must either be surrounded with braces \\\n+                           or followed by a semicolon\";\n+                self.span_err(self.prev_span, msg);\n+            }\n+        }\n+\n+        let hi = self.prev_span.hi;\n+        let kind = ItemKind::MacroDef(tts, Mark::fresh());\n+        Ok(Some(self.mk_item(lo, hi, id, kind, Visibility::Inherited, attrs.to_owned())))\n+    }\n+\n     fn parse_stmt_without_recovery(&mut self,\n                                    macro_legacy_warnings: bool)\n                                    -> PResult<'a, Option<Stmt>> {\n@@ -3718,6 +3749,12 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.prev_span.hi),\n             }\n+        } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited)? {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Item(macro_def),\n+                span: mk_sp(lo, self.prev_span.hi),\n+            }\n         // Starts like a simple path, but not a union item.\n         } else if self.token.is_path_start() &&\n                   !self.token.is_qpath_start() &&\n@@ -5767,6 +5804,10 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility)? {\n+            return Ok(Some(macro_def));\n+        }\n+\n         self.parse_macro_use_or_failure(attrs,macros_allowed,attributes_allowed,lo,visibility)\n     }\n \n@@ -5948,7 +5989,6 @@ impl<'a> Parser<'a> {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n             span: mk_sp(lo, self.span.lo),\n-            exported_macros: Vec::new(),\n         })\n     }\n "}, {"sha": "78212fb4b447cfec4afd5f5fa4a1a413ce4d3c5c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -1318,7 +1318,6 @@ impl<'a> State<'a> {\n                 self.bclose(item.span)?;\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n-                self.print_visibility(&item.vis)?;\n                 self.print_path(&node.path, false, 0, false)?;\n                 word(&mut self.s, \"! \")?;\n                 self.print_ident(item.ident)?;\n@@ -1329,6 +1328,16 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \";\")?;\n                 self.end()?;\n             }\n+            ast::ItemKind::MacroDef(ref tts, _) => {\n+                word(&mut self.s, \"macro_rules! \")?;\n+                self.print_ident(item.ident)?;\n+                self.cbox(INDENT_UNIT)?;\n+                self.popen()?;\n+                self.print_tts(tts.clone().into())?;\n+                self.pclose()?;\n+                word(&mut self.s, \";\")?;\n+                self.end()?;\n+            }\n         }\n         self.ann.post(self, NodeItem(item))\n     }"}, {"sha": "9d9957a0f45341c06746f44d886b842b1caa0c28", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -148,9 +148,4 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n     fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;\n     }\n-    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n-        self.count += 1;\n-        walk_macro_def(self, macro_def)\n-    }\n-\n }"}, {"sha": "ee7dd18247b213d4b6b6a7c153b8db3c74ca3d60", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -125,9 +125,6 @@ pub trait Visitor<'ast>: Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'ast Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        walk_macro_def(self, macro_def)\n-    }\n     fn visit_vis(&mut self, vis: &'ast Visibility) {\n         walk_vis(self, vis)\n     }\n@@ -176,12 +173,6 @@ pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident)\n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n-    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n-}\n-\n-pub fn walk_macro_def<'a, V: Visitor<'a>>(visitor: &mut V, macro_def: &'a MacroDef) {\n-    visitor.visit_ident(macro_def.span, macro_def.ident);\n-    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n@@ -295,6 +286,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::MacroDef(..) => {},\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }"}, {"sha": "b51591bf89d5e2275724a87d7a41c6d82dcb72c6", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -99,7 +99,7 @@ macro_rules! derive_traits {\n \n         pub fn register_builtin_derives(resolver: &mut Resolver) {\n             $(\n-                resolver.add_ext(\n+                resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n                     Rc::new(SyntaxExtension::BuiltinDerive($func))\n                 );"}, {"sha": "1e9b112b6df564263738be5f058d2e4c1a54bed6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -59,7 +59,7 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     deriving::register_builtin_derives(resolver);\n \n     let mut register = |name, ext| {\n-        resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n+        resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n     macro_rules! register {"}, {"sha": "5adaf470f2374be020e1e2b0330ad3d87cd99762", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -90,12 +90,7 @@ pub fn modify(sess: &ParseSess,\n \n     krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros, &bang_macros));\n \n-    if krate.exported_macros.len() > 0 {\n-        handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n-                     crate type currently\");\n-    }\n-\n-    return krate\n+    krate\n }\n \n fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n@@ -251,6 +246,15 @@ impl<'a> CollectProcMacros<'a> {\n \n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n+        if let ast::ItemKind::MacroDef(..) = item.node {\n+            if self.is_proc_macro_crate &&\n+               item.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+                let msg =\n+                    \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n+                self.handler.span_err(item.span, msg);\n+            }\n+        }\n+\n         // First up, make sure we're checking a bare function. If we're not then\n         // we're just not interested in this item.\n         //"}, {"sha": "3d2dd380e488e76abadd2afed8c68435b56f4909", "filename": "src/test/run-make/pretty-expanded-hygiene/input.pp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212b6c25507b963b60a646a2ff3df7496bd30acf/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs?ref=212b6c25507b963b60a646a2ff3df7496bd30acf", "patch": "@@ -12,6 +12,7 @@\n #![feature(no_core)]\n #![no_core]\n \n+macro_rules! foo /* 60#0 */(( $ x : ident ) => { y + $ x });\n \n fn bar /* 62#0 */() { let x /* 59#2 */ = 1; y /* 61#4 */ + x /* 59#5 */ }\n "}]}