{"sha": "e9ffc409bc7a8a8b11c326136209d720671a8dcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZmZjNDA5YmM3YThhOGIxMWMzMjYxMzYyMDlkNzIwNjcxYThkY2Q=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-12-30T23:35:43Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:54:23Z"}, "message": "Spelling. s/forrest/forest", "tree": {"sha": "68e8c5addf1b050057b968a5fd693fa3eaf13df3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68e8c5addf1b050057b968a5fd693fa3eaf13df3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9ffc409bc7a8a8b11c326136209d720671a8dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9ffc409bc7a8a8b11c326136209d720671a8dcd", "html_url": "https://github.com/rust-lang/rust/commit/e9ffc409bc7a8a8b11c326136209d720671a8dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9ffc409bc7a8a8b11c326136209d720671a8dcd/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "699b25ff3a86213b806387c3806adc3af9858205", "url": "https://api.github.com/repos/rust-lang/rust/commits/699b25ff3a86213b806387c3806adc3af9858205", "html_url": "https://github.com/rust-lang/rust/commit/699b25ff3a86213b806387c3806adc3af9858205"}], "stats": {"total": 130, "additions": 65, "deletions": 65}, "files": [{"sha": "644df8741e8534a472cde67a54e34782352235df", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e9ffc409bc7a8a8b11c326136209d720671a8dcd", "patch": "@@ -33,7 +33,7 @@ use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n-use ty::inhabitedness::DefIdForrest;\n+use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -460,7 +460,7 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n-    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForrest>>,\n+    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, DefIdForest>>,\n \n     pub lang_items: middle::lang_items::LanguageItems,\n "}, {"sha": "762fb11ba05e92932253c28c3bd2020c317a54bd", "filename": "src/librustc/ty/inhabitedness.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness.rs?ref=e9ffc409bc7a8a8b11c326136209d720671a8dcd", "patch": "@@ -21,46 +21,46 @@ use ty::TypeVariants::*;\n /// Represents a set of DefIds closed under the ancestor relation. That is, if\n /// a DefId is in this set then so are all its descendants.\n #[derive(Clone)]\n-pub struct DefIdForrest {\n+pub struct DefIdForest {\n     /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForrest, and A is a desecendant\n+    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n     /// of B, then only B will be in root_ids.\n     /// We use a SmallVec here because (for its use in this module) its rare\n     /// that this will contain even two ids.\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n-impl<'a, 'gcx, 'tcx> DefIdForrest {\n-    /// Create an empty forrest.\n-    pub fn empty() -> DefIdForrest {\n-        DefIdForrest {\n+impl<'a, 'gcx, 'tcx> DefIdForest {\n+    /// Create an empty forest.\n+    pub fn empty() -> DefIdForest {\n+        DefIdForest {\n             root_ids: SmallVec::new(),\n         }\n     }\n \n-    /// Create a forrest consisting of a single tree representing the entire\n+    /// Create a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest {\n+    pub fn full(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest {\n         let crate_id = tcx.map.local_def_id(CRATE_NODE_ID);\n-        DefIdForrest::from_id(crate_id)\n+        DefIdForest::from_id(crate_id)\n     }\n \n-    /// Create a forrest containing a DefId and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForrest {\n+    /// Create a forest containing a DefId and all its descendants.\n+    pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);\n-        DefIdForrest {\n+        DefIdForest {\n             root_ids: root_ids,\n         }\n     }\n \n-    /// Test whether the forrest is empty.\n+    /// Test whether the forest is empty.\n     pub fn is_empty(&self) -> bool {\n         self.root_ids.is_empty()\n     }\n \n-    /// Test whether the forrest conains a given DefId.\n+    /// Test whether the forest conains a given DefId.\n     pub fn contains(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool\n@@ -73,25 +73,25 @@ impl<'a, 'gcx, 'tcx> DefIdForrest {\n         false\n     }\n \n-    /// Calculate the intersection of a collection of forrests.\n+    /// Calculate the intersection of a collection of forests.\n     pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           iter: I) -> DefIdForrest\n-            where I: IntoIterator<Item=DefIdForrest>\n+                           iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n     {\n-        let mut ret = DefIdForrest::full(tcx);\n+        let mut ret = DefIdForest::full(tcx);\n         let mut next_ret = SmallVec::new();\n         let mut old_ret: SmallVec<[DefId; 1]> = SmallVec::new();\n-        for next_forrest in iter {\n+        for next_forest in iter {\n             for id in ret.root_ids.drain(..) {\n-                if next_forrest.contains(tcx, id) {\n+                if next_forest.contains(tcx, id) {\n                     next_ret.push(id);\n                 } else {\n                     old_ret.push(id);\n                 }\n             }\n             ret.root_ids.extend(old_ret.drain(..));\n \n-            for id in next_forrest.root_ids {\n+            for id in next_forest.root_ids {\n                 if ret.contains(tcx, id) {\n                     next_ret.push(id);\n                 }\n@@ -103,21 +103,21 @@ impl<'a, 'gcx, 'tcx> DefIdForrest {\n         ret\n     }\n \n-    /// Calculate the union of a collection of forrests.\n+    /// Calculate the union of a collection of forests.\n     pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    iter: I) -> DefIdForrest\n-            where I: IntoIterator<Item=DefIdForrest>\n+                    iter: I) -> DefIdForest\n+            where I: IntoIterator<Item=DefIdForest>\n     {\n-        let mut ret = DefIdForrest::empty();\n+        let mut ret = DefIdForest::empty();\n         let mut next_ret = SmallVec::new();\n-        for next_forrest in iter {\n+        for next_forest in iter {\n             for id in ret.root_ids.drain(..) {\n-                if !next_forrest.contains(tcx, id) {\n+                if !next_forest.contains(tcx, id) {\n                     next_ret.push(id);\n                 }\n             }\n \n-            for id in next_forrest.root_ids {\n+            for id in next_forest.root_ids {\n                 if !next_ret.contains(&id) {\n                     next_ret.push(id);\n                 }\n@@ -131,18 +131,18 @@ impl<'a, 'gcx, 'tcx> DefIdForrest {\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n-    /// Calculate the forrest of DefIds from which this adt is visibly uninhabited.\n+    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                substs: &'tcx Substs<'tcx>) -> DefIdForrest\n+                substs: &'tcx Substs<'tcx>) -> DefIdForest\n     {\n         if !visited.insert((self.did, substs)) {\n-            return DefIdForrest::empty();\n+            return DefIdForest::empty();\n         }\n \n-        let ret = DefIdForrest::intersection(tcx, self.variants.iter().map(|v| {\n+        let ret = DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n             v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n         }));\n         visited.remove(&(self.did, substs));\n@@ -151,27 +151,27 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n }\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n-    /// Calculate the forrest of DefIds from which this variant is visibly uninhabited.\n+    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n-                adt_kind: AdtKind) -> DefIdForrest\n+                adt_kind: AdtKind) -> DefIdForest\n     {\n         match adt_kind {\n             AdtKind::Union => {\n-                DefIdForrest::intersection(tcx, self.fields.iter().map(|f| {\n+                DefIdForest::intersection(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Struct => {\n-                DefIdForrest::union(tcx, self.fields.iter().map(|f| {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, false)\n                 }))\n             },\n             AdtKind::Enum => {\n-                DefIdForrest::union(tcx, self.fields.iter().map(|f| {\n+                DefIdForest::union(tcx, self.fields.iter().map(|f| {\n                     f.uninhabited_from(visited, tcx, substs, true)\n                 }))\n             },\n@@ -180,24 +180,24 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n-    /// Calculate the forrest of DefIds from which this field is visibly uninhabited.\n+    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                 tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 substs: &'tcx Substs<'tcx>,\n-                is_enum: bool) -> DefIdForrest\n+                is_enum: bool) -> DefIdForest\n     {\n         let mut data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(visited, tcx);\n         if is_enum {\n             data_uninhabitedness()\n         } else {\n             match self.vis {\n-                Visibility::Invisible => DefIdForrest::empty(),\n+                Visibility::Invisible => DefIdForest::empty(),\n                 Visibility::Restricted(from) => {\n-                    let forrest = DefIdForrest::from_id(from);\n-                    let iter = Some(forrest).into_iter().chain(Some(data_uninhabitedness()));\n-                    DefIdForrest::intersection(tcx, iter)\n+                    let forest = DefIdForest::from_id(from);\n+                    let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));\n+                    DefIdForest::intersection(tcx, iter)\n                 },\n                 Visibility::Public => data_uninhabitedness(),\n             }\n@@ -206,58 +206,58 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n }\n \n impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n-    /// Calculate the forrest of DefIds from which this type is visibly uninhabited.\n+    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n     pub fn uninhabited_from(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match tcx.lift_to_global(&self) {\n             Some(global_ty) => {\n                 {\n                     let cache = tcx.inhabitedness_cache.borrow();\n-                    if let Some(forrest) = cache.get(&global_ty) {\n-                        return forrest.clone();\n+                    if let Some(forest) = cache.get(&global_ty) {\n+                        return forest.clone();\n                     }\n                 }\n-                let forrest = global_ty.uninhabited_from_inner(visited, tcx);\n+                let forest = global_ty.uninhabited_from_inner(visited, tcx);\n                 let mut cache = tcx.inhabitedness_cache.borrow_mut();\n-                cache.insert(global_ty, forrest.clone());\n-                forrest\n+                cache.insert(global_ty, forest.clone());\n+                forest\n             },\n             None => {\n-                let forrest = self.uninhabited_from_inner(visited, tcx);\n-                forrest\n+                let forest = self.uninhabited_from_inner(visited, tcx);\n+                forest\n             },\n         }\n     }\n \n     fn uninhabited_from_inner(\n                 &self,\n                 visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForrest\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> DefIdForest\n     {\n         match self.sty {\n             TyAdt(def, substs) => {\n                 def.uninhabited_from(visited, tcx, substs)\n             },\n \n-            TyNever => DefIdForrest::full(tcx),\n+            TyNever => DefIdForest::full(tcx),\n             TyTuple(ref tys) => {\n-                DefIdForrest::union(tcx, tys.iter().map(|ty| {\n+                DefIdForest::union(tcx, tys.iter().map(|ty| {\n                     ty.uninhabited_from(visited, tcx)\n                 }))\n             },\n             TyArray(ty, len) => {\n                 if len == 0 {\n-                    DefIdForrest::empty()\n+                    DefIdForest::empty()\n                 } else {\n                     ty.uninhabited_from(visited, tcx)\n                 }\n             }\n             TyRef(_, ref tm) => tm.ty.uninhabited_from(visited, tcx),\n \n-            _ => DefIdForrest::empty(),\n+            _ => DefIdForest::empty(),\n         }\n     }\n }"}, {"sha": "1890bb4335aac5700801caa239da1d9a59fbf534", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=e9ffc409bc7a8a8b11c326136209d720671a8dcd", "patch": "@@ -982,8 +982,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n     pub fn is_uninhabited_from(&self, module: DefId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        let forrest = self.uninhabited_from(&mut visited, tcx);\n-        forrest.contains(tcx, module)\n+        let forest = self.uninhabited_from(&mut visited, tcx);\n+        forest.contains(tcx, module)\n     }\n \n     /// Checks whether a type is uninhabited."}, {"sha": "90e861c3f57c77f6e79eee3d4d96aa2eb93fc4de", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9ffc409bc7a8a8b11c326136209d720671a8dcd/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=e9ffc409bc7a8a8b11c326136209d720671a8dcd", "patch": "@@ -394,10 +394,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n                 let mut visited = FxHashSet::default();\n-                let forrest = v.uninhabited_from(&mut visited,\n-                                                  cx.tcx, substs,\n-                                                  AdtKind::Enum);\n-                if forrest.contains(cx.tcx, cx.module) {\n+                let forest = v.uninhabited_from(&mut visited,\n+                                                cx.tcx, substs,\n+                                                AdtKind::Enum);\n+                if forest.contains(cx.tcx, cx.module) {\n                     None\n                 } else {\n                     Some(Variant(v.did))"}]}