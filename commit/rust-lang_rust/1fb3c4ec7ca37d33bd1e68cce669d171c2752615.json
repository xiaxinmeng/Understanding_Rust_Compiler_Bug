{"sha": "1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmYjNjNGVjN2NhMzdkMzNiZDFlNjhjY2U2NjlkMTcxYzI3NTI2MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-06T07:37:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-06T07:37:41Z"}, "message": "Auto merge of #64209 - Centril:rollup-x9kvjb7, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #63676 (Use wasi crate for Core API)\n - #64094 (Improve searching in rustdoc and add tests)\n - #64111 (or-patterns: Uniformly use `PatKind::Or` in AST & Fix/Cleanup resolve)\n - #64156 (Assume non-git LLVM is fresh if the stamp file exists)\n - #64161 (Point at variant on pattern field count mismatch)\n - #64174 (Add missing code examples on Iterator trait)\n - #64175 (Fix invalid span generation when it should be div)\n - #64186 (std: Improve downstream codegen in `Command::env`)\n - #64190 (fill metadata in rustc_lexer's Cargo.toml)\n - #64198 (Add Fuchsia to actually_monotonic)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "48ea5150538790309c68b9f515c4e958724a82a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48ea5150538790309c68b9f515c4e958724a82a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "html_url": "https://github.com/rust-lang/rust/commit/1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b5f9b2e973e438fc1726a2d164d046acd80b170", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5f9b2e973e438fc1726a2d164d046acd80b170", "html_url": "https://github.com/rust-lang/rust/commit/6b5f9b2e973e438fc1726a2d164d046acd80b170"}, {"sha": "61fcd057d2524175a21e2eb1d49c1d4aec29a0be", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fcd057d2524175a21e2eb1d49c1d4aec29a0be", "html_url": "https://github.com/rust-lang/rust/commit/61fcd057d2524175a21e2eb1d49c1d4aec29a0be"}], "stats": {"total": 3154, "additions": 1991, "deletions": 1163}, "files": [{"sha": "313fef1c086a871d7542c7c49823bf19fbfb5f68", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -3870,6 +3870,7 @@ dependencies = [\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -4686,6 +4687,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "7bf9ea2688f4c5a872d3f6f0b3f1ac645a9a7811", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -81,26 +81,29 @@ impl Step for Llvm {\n             (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n         };\n \n-        if !llvm_info.is_git() {\n-            println!(\n-                \"git could not determine the LLVM submodule commit hash. \\\n-                Assuming that an LLVM build is necessary.\",\n-            );\n-        }\n-\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            if done_stamp.exists() {\n+        if done_stamp.exists() {\n+            if let Some(llvm_commit) = llvm_info.sha() {\n                 let done_contents = t!(fs::read(&done_stamp));\n \n                 // If LLVM was already built previously and the submodule's commit didn't change\n                 // from the previous build, then no action is required.\n                 if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config\n+                    return build_llvm_config;\n                 }\n+            } else {\n+                builder.info(\n+                    \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+                );\n+                builder.info(&format!(\n+                    \"To force LLVM to rebuild, remove the file `{}`\",\n+                    done_stamp.display()\n+                ));\n+                return build_llvm_config;\n             }\n         }\n \n@@ -303,9 +306,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            t!(fs::write(&done_stamp, llvm_commit));\n-        }\n+        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n \n         build_llvm_config\n     }"}, {"sha": "8fd5fe0653eedcafa4515648e296d8b90956524c", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -2546,6 +2546,16 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);\n+    /// assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);\n+    /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn cmp<I>(mut self, other: I) -> Ordering where\n         I: IntoIterator<Item = Self::Item>,\n@@ -2578,6 +2588,18 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n+    /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n+    /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    ///\n+    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n         I: IntoIterator,\n@@ -2610,6 +2632,13 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are equal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().eq([1].iter()), true);\n+    /// assert_eq!([1].iter().eq([1, 2].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn eq<I>(mut self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2635,6 +2664,13 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ne([1].iter()), false);\n+    /// assert_eq!([1].iter().ne([1, 2].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2646,6 +2682,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().lt([1].iter()), false);\n+    /// assert_eq!([1].iter().lt([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2657,6 +2701,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().le([1].iter()), true);\n+    /// assert_eq!([1].iter().le([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().le([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2671,6 +2723,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().gt([1].iter()), false);\n+    /// assert_eq!([1].iter().gt([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2682,6 +2742,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ge([1].iter()), true);\n+    /// assert_eq!([1].iter().ge([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2730,6 +2798,18 @@ pub trait Iterator {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// ```\n+    ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool"}, {"sha": "190b50b10b281635f4ae2cdee1fc4ee9b1f9b5e4", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n "}, {"sha": "0d8986ddec3c7fe7e0a86d08aecf10dd145878cb", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -227,16 +227,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +241,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -291,13 +286,12 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(then, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +306,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -345,8 +337,8 @@ impl LoweringContext<'_> {\n         // Handle then + scrutinee:\n         let then_blk = self.lower_block(body, false);\n         let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,9 +348,8 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n@@ -383,14 +374,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +429,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +439,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -1255,7 +1254,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1486,7 +1484,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "950771f0a692710021dc7e29c18736fdbbe3ea0b", "filename": "src/librustc_lexer/Cargo.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2FCargo.toml?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -2,8 +2,14 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n+license = \"MIT OR Apache-2.0\"\n edition = \"2018\"\n \n+repository = \"https://github.com/rust-lang/rust/\"\n+description = \"\"\"\n+Rust lexer used by rustc. No stability guarantees are provided.\n+\"\"\"\n+\n # Note: do not remove this blank `[lib]` section.\n # This will be used when publishing this crate as `rustc-ap-rustc_lexer`.\n [lib]"}, {"sha": "aecf5c5b52dba5996deb93661ba54091435b4fb2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -772,7 +772,7 @@ impl EarlyLintPass for UnusedDocComment {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        let arm_span = arm.pats[0].span.with_hi(arm.body.span.hi());\n+        let arm_span = arm.pat.span.with_hi(arm.body.span.hi());\n         self.warn_if_doc(cx, arm_span, \"match arms\", false, &arm.attrs);\n     }\n "}, {"sha": "561bf202dfeff07f7b6813aedd97050a4fcbacf4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -493,10 +493,8 @@ impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n         let (value, msg, followed_by_block, left_pos, right_pos) = match e.node {\n-            Let(ref pats, ..) => {\n-                for p in pats {\n-                    self.check_unused_parens_pat(cx, p, false, false);\n-                }\n+            Let(ref pat, ..) => {\n+                self.check_unused_parens_pat(cx, pat, false, false);\n                 return;\n             }\n \n@@ -594,9 +592,7 @@ impl EarlyLintPass for UnusedParens {\n     }\n \n     fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n-        for p in &arm.pats {\n-            self.check_unused_parens_pat(cx, p, false, false);\n-        }\n+        self.check_unused_parens_pat(cx, &arm.pat, false, false);\n     }\n }\n "}, {"sha": "3ddaf2d94f9c82649e8b56b73c2de3b6b56f8f9c", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 444, "deletions": 368, "changes": 812, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -9,7 +9,7 @@ use GenericParameters::*;\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, NameBindingKind, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use log::debug;\n@@ -18,7 +18,7 @@ use rustc::hir::def::{self, PartialRes, DefKind, CtorKind, PerNS};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::TraitCandidate;\n-use rustc::util::nodemap::FxHashMap;\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use smallvec::{smallvec, SmallVec};\n use syntax::{unwrap_or, walk_list};\n use syntax::ast::*;\n@@ -35,8 +35,10 @@ mod diagnostics;\n \n type Res = def::Res<NodeId>;\n \n+type IdentMap<T> = FxHashMap<Ident, T>;\n+\n /// Map from the name in a pattern to its binding mode.\n-type BindingMap = FxHashMap<Ident, BindingInfo>;\n+type BindingMap = IdentMap<BindingInfo>;\n \n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n@@ -73,6 +75,16 @@ impl PatternSource {\n     }\n }\n \n+/// Denotes whether the context for the set of already bound bindings is a `Product`\n+/// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n+/// See those functions for more information.\n+enum PatBoundCtx {\n+    /// A product pattern context, e.g., `Variant(a, b)`.\n+    Product,\n+    /// An or-pattern context, e.g., `p_0 | ... | p_n`.\n+    Or,\n+}\n+\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -143,7 +155,7 @@ impl RibKind<'_> {\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n crate struct Rib<'a, R = Res> {\n-    pub bindings: FxHashMap<Ident, R>,\n+    pub bindings: IdentMap<R>,\n     pub kind: RibKind<'a>,\n }\n \n@@ -406,50 +418,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n             visit::walk_foreign_item(this, foreign_item);\n         });\n     }\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'tcx>,\n-                declaration: &'tcx FnDecl,\n-                _: Span,\n-                _: NodeId)\n-    {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, declaration: &'tcx FnDecl, _: Span, _: NodeId) {\n         debug!(\"(resolving function) entering function\");\n-        let rib_kind = match function_kind {\n+        let rib_kind = match fn_kind {\n             FnKind::ItemFn(..) => FnItemRibKind,\n             FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n         };\n \n         // Create a value rib for the function.\n-        self.ribs[ValueNS].push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FxHashMap::default();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body, potentially inside the body of an async closure\n-        match function_kind {\n-            FnKind::ItemFn(.., body) |\n-            FnKind::Method(.., body) => {\n-                self.visit_block(body);\n-            }\n-            FnKind::Closure(body) => {\n-                self.visit_expr(body);\n-            }\n-        };\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, rib_kind, |this| {\n+            // Create a label rib for the function.\n+            this.with_label_rib(rib_kind, |this| {\n+                // Add each argument to the rib.\n+                this.resolve_params(&declaration.inputs);\n+\n+                visit::walk_fn_ret_ty(this, &declaration.output);\n+\n+                // Resolve the function body, potentially inside the body of an async closure\n+                match fn_kind {\n+                    FnKind::ItemFn(.., body) |\n+                    FnKind::Method(.., body) => this.visit_block(body),\n+                    FnKind::Closure(body) => this.visit_expr(body),\n+                };\n+\n+                debug!(\"(resolving function) leaving function\");\n+            })\n+        });\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx Generics) {\n@@ -528,13 +522,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // although it may be useful to track other components as well for diagnostics.\n         let graph_root = resolver.graph_root;\n         let parent_scope = ParentScope::module(graph_root);\n+        let start_rib_kind = ModuleRibKind(graph_root);\n         LateResolutionVisitor {\n             r: resolver,\n             parent_scope,\n             ribs: PerNS {\n-                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                value_ns: vec![Rib::new(start_rib_kind)],\n+                type_ns: vec![Rib::new(start_rib_kind)],\n+                macro_ns: vec![Rib::new(start_rib_kind)],\n             },\n             label_ribs: Vec::new(),\n             current_trait_ref: None,\n@@ -588,23 +583,32 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    /// Do some `work` within a new innermost rib of the given `kind` in the given namespace (`ns`).\n+    fn with_rib<T>(\n+        &mut self,\n+        ns: Namespace,\n+        kind: RibKind<'a>,\n+        work: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        self.ribs[ns].push(Rib::new(kind));\n+        let ret = work(self);\n+        self.ribs[ns].pop();\n+        ret\n+    }\n+\n+    fn with_scope<T>(&mut self, id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n         let id = self.r.definitions.local_def_id(id);\n         let module = self.r.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n             let orig_module = replace(&mut self.parent_scope.module, module);\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-\n-            let ret = f(self);\n-\n-            self.parent_scope.module = orig_module;\n-            self.ribs[ValueNS].pop();\n-            self.ribs[TypeNS].pop();\n-            ret\n+            self.with_rib(ValueNS, ModuleRibKind(module), |this| {\n+                this.with_rib(TypeNS, ModuleRibKind(module), |this| {\n+                    let ret = f(this);\n+                    this.parent_scope.module = orig_module;\n+                    ret\n+                })\n+            })\n         } else {\n             f(self)\n         }\n@@ -808,7 +812,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+        where F: FnOnce(&mut Self)\n     {\n         debug!(\"with_generic_param_rib\");\n         match generic_params {\n@@ -894,58 +898,44 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n-    fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.label_ribs.push(Rib::new(NormalRibKind));\n+    fn with_label_rib(&mut self, kind: RibKind<'a>, f: impl FnOnce(&mut Self)) {\n+        self.label_ribs.push(Rib::new(kind));\n         f(self);\n         self.label_ribs.pop();\n     }\n \n-    fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n-        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n-        f(self);\n-        self.ribs[TypeNS].pop();\n-        self.ribs[ValueNS].pop();\n+    fn with_item_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.with_rib(ValueNS, ItemRibKind, |this| this.with_rib(TypeNS, ItemRibKind, f))\n     }\n \n-    fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n         debug!(\"with_constant_rib\");\n-        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n-        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n-        f(self);\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n+        self.with_rib(ValueNS, ConstantItemRibKind, |this| {\n+            this.with_label_rib(ConstantItemRibKind, f);\n+        });\n     }\n \n-    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_type<T>(&mut self, self_type: &Ty, f: impl FnOnce(&mut Self) -> T) -> T {\n         // Handle nested impls (inside fn bodies)\n         let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n         let result = f(self);\n         self.current_self_type = previous_value;\n         result\n     }\n \n-    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_current_self_item<T>(&mut self, self_item: &Item, f: impl FnOnce(&mut Self) -> T) -> T {\n         let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n         let result = f(self);\n         self.current_self_item = previous_value;\n         result\n     }\n \n     /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n-    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n+    fn with_trait_items<T>(\n+        &mut self,\n+        trait_items: &Vec<TraitItem>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n         let trait_assoc_types = replace(\n             &mut self.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.node {\n@@ -959,9 +949,11 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     }\n \n     /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n-    {\n+    fn with_optional_trait_ref<T>(\n+        &mut self,\n+        opt_trait_ref: Option<&TraitRef>,\n+        f: impl FnOnce(&mut Self, Option<DefId>) -> T\n+    ) -> T {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n@@ -996,27 +988,18 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         result\n     }\n \n-    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_self_rib_ns(&mut self, ns: Namespace, self_res: Res, f: impl FnOnce(&mut Self)) {\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n         self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[TypeNS].push(self_type_rib);\n+        self.ribs[ns].push(self_type_rib);\n         f(self);\n-        self.ribs[TypeNS].pop();\n+        self.ribs[ns].pop();\n     }\n \n-    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        let self_res = Res::SelfCtor(impl_id);\n-        let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n-        self.ribs[ValueNS].push(self_type_rib);\n-        f(self);\n-        self.ribs[ValueNS].pop();\n+    fn with_self_rib(&mut self, self_res: Res, f: impl FnOnce(&mut Self)) {\n+        self.with_self_rib_ns(TypeNS, self_res, f)\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -1044,8 +1027,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                         this.visit_generics(generics);\n                         // Resolve the items within the impl.\n                         this.with_current_self_type(self_type, |this| {\n-                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n-                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n+                            this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n+                                debug!(\"resolve_implementation with_self_rib_ns(ValueNS, ...)\");\n                                 for impl_item in impl_items {\n                                     // We also need a new scope for the impl item type parameters.\n                                     let generic_params = HasGenericParams(&impl_item.generics,\n@@ -1135,6 +1118,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         }\n     }\n \n+    fn resolve_params(&mut self, params: &[Param]) {\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        for Param { pat, ty, .. } in params {\n+            self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+            self.visit_ty(ty);\n+            debug!(\"(resolving function / closure) recorded parameter\");\n+        }\n+    }\n+\n     fn resolve_local(&mut self, local: &Local) {\n         // Resolve the type.\n         walk_list!(self, visit_ty, &local.ty);\n@@ -1143,72 +1135,93 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n+        self.resolve_pattern_top(&local.pat, PatternSource::Let);\n     }\n \n-    // build a map from pattern identifiers to binding-info's.\n-    // this is done hygienically. This could arise for a macro\n-    // that expands into an or-pattern where one 'x' was from the\n-    // user and one 'x' came from the macro.\n+    /// build a map from pattern identifiers to binding-info's.\n+    /// this is done hygienically. This could arise for a macro\n+    /// that expands into an or-pattern where one 'x' was from the\n+    /// user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n-            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.r.partial_res_map.get(&pat.id)\n-                                                                  .map(|res| res.base_res()) {\n-                    Some(Res::Local(..)) => true,\n-                    _ => false,\n-                } {\n-                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident, binding_info);\n+            match pat.node {\n+                PatKind::Ident(binding_mode, ident, ref sub_pat)\n+                    if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n+                {\n+                    binding_map.insert(ident, BindingInfo { span: ident.span, binding_mode });\n+                }\n+                PatKind::Or(ref ps) => {\n+                    // Check the consistency of this or-pattern and\n+                    // then add all bindings to the larger map.\n+                    for bm in self.check_consistent_bindings(ps) {\n+                        binding_map.extend(bm);\n+                    }\n+                    return false;\n                 }\n+                _ => {}\n             }\n+\n             true\n         });\n \n         binding_map\n     }\n \n-    // Checks that all of the arms in an or-pattern have exactly the\n-    // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+    fn is_base_res_local(&self, nid: NodeId) -> bool {\n+        match self.r.partial_res_map.get(&nid).map(|res| res.base_res()) {\n+            Some(Res::Local(..)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Checks that all of the arms in an or-pattern have exactly the\n+    /// same set of bindings, with the same binding modes for each.\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<BindingMap> {\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n \n-        for pat_outer in pats.iter() {\n-            let map_outer = self.binding_mode_map(&pat_outer);\n-\n-            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n-                let map_inner = self.binding_mode_map(&pat_inner);\n-\n-                for (&key_inner, &binding_inner) in map_inner.iter() {\n-                    match map_outer.get(&key_inner) {\n-                        None => {  // missing binding\n-                            let binding_error = missing_vars\n-                                .entry(key_inner.name)\n-                                .or_insert(BindingError {\n-                                    name: key_inner.name,\n-                                    origin: BTreeSet::new(),\n-                                    target: BTreeSet::new(),\n-                                    could_be_path:\n-                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n-                                });\n-                            binding_error.origin.insert(binding_inner.span);\n-                            binding_error.target.insert(pat_outer.span);\n-                        }\n-                        Some(binding_outer) => {  // check consistent binding\n-                            if binding_outer.binding_mode != binding_inner.binding_mode {\n-                                inconsistent_vars\n-                                    .entry(key_inner.name)\n-                                    .or_insert((binding_inner.span, binding_outer.span));\n-                            }\n+        // 1) Compute the binding maps of all arms.\n+        let maps = pats.iter()\n+            .map(|pat| self.binding_mode_map(pat))\n+            .collect::<Vec<_>>();\n+\n+        // 2) Record any missing bindings or binding mode inconsistencies.\n+        for (map_outer, pat_outer) in pats.iter().enumerate().map(|(idx, pat)| (&maps[idx], pat)) {\n+            // Check against all arms except for the same pattern which is always self-consistent.\n+            let inners = pats.iter().enumerate()\n+                .filter(|(_, pat)| pat.id != pat_outer.id)\n+                .flat_map(|(idx, _)| maps[idx].iter())\n+                .map(|(key, binding)| (key.name, map_outer.get(&key), binding));\n+\n+            for (name, info, &binding_inner) in inners {\n+                match info {\n+                    None => { // The inner binding is missing in the outer.\n+                        let binding_error = missing_vars\n+                            .entry(name)\n+                            .or_insert_with(|| BindingError {\n+                                name,\n+                                origin: BTreeSet::new(),\n+                                target: BTreeSet::new(),\n+                                could_be_path: name.as_str().starts_with(char::is_uppercase),\n+                            });\n+                        binding_error.origin.insert(binding_inner.span);\n+                        binding_error.target.insert(pat_outer.span);\n+                    }\n+                    Some(binding_outer) => {\n+                        if binding_outer.binding_mode != binding_inner.binding_mode {\n+                            // The binding modes in the outer and inner bindings differ.\n+                            inconsistent_vars\n+                                .entry(name)\n+                                .or_insert((binding_inner.span, binding_outer.span));\n                         }\n                     }\n                 }\n             }\n         }\n \n+        // 3) Report all missing variables we found.\n         let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n         for (name, mut v) in missing_vars {\n@@ -1220,212 +1233,245 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 ResolutionError::VariableNotBoundInPattern(v));\n         }\n \n+        // 4) Report all inconsistencies in binding modes we found.\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n             self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n-    }\n \n-    fn resolve_arm(&mut self, arm: &Arm) {\n-        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-\n-        self.resolve_pats(&arm.pats, PatternSource::Match);\n-\n-        if let Some(ref expr) = arm.guard {\n-            self.visit_expr(expr)\n-        }\n-        self.visit_expr(&arm.body);\n-\n-        self.ribs[ValueNS].pop();\n+        // 5) Finally bubble up all the binding maps.\n+        maps\n     }\n \n-    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n-    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n-        let mut bindings_list = FxHashMap::default();\n-        for pat in pats {\n-            self.resolve_pattern(pat, source, &mut bindings_list);\n-        }\n-        // This has to happen *after* we determine which pat_idents are variants\n-        if pats.len() > 1 {\n-            self.check_consistent_bindings(pats);\n-        }\n+    /// Check the consistency of the outermost or-patterns.\n+    fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n+        pat.walk(&mut |pat| match pat.node {\n+            PatKind::Or(ref ps) => {\n+                self.check_consistent_bindings(ps);\n+                false\n+            },\n+            _ => true,\n+        })\n     }\n \n-    fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n-        // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.parent_scope.module;\n-        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n-\n-        let mut num_macro_definition_ribs = 0;\n-        if let Some(anonymous_module) = anonymous_module {\n-            debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.parent_scope.module = anonymous_module;\n-        } else {\n-            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-        }\n-\n-        // Descend into the block.\n-        for stmt in &block.stmts {\n-            if let StmtKind::Item(ref item) = stmt.node {\n-                if let ItemKind::MacroDef(..) = item.node {\n-                    num_macro_definition_ribs += 1;\n-                    let res = self.r.definitions.local_def_id(item.id);\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n-                }\n-            }\n-\n-            self.visit_stmt(stmt);\n-        }\n-\n-        // Move back up.\n-        self.parent_scope.module = orig_module;\n-        for _ in 0 .. num_macro_definition_ribs {\n-            self.ribs[ValueNS].pop();\n-            self.label_ribs.pop();\n-        }\n-        self.ribs[ValueNS].pop();\n-        if anonymous_module.is_some() {\n-            self.ribs[TypeNS].pop();\n-        }\n-        debug!(\"(resolving block) leaving block\");\n+    fn resolve_arm(&mut self, arm: &Arm) {\n+        self.with_rib(ValueNS, NormalRibKind, |this| {\n+            this.resolve_pattern_top(&arm.pat, PatternSource::Match);\n+            walk_list!(this, visit_expr, &arm.guard);\n+            this.visit_expr(&arm.body);\n+        });\n     }\n \n-    fn fresh_binding(&mut self,\n-                     ident: Ident,\n-                     pat_id: NodeId,\n-                     outer_pat_id: NodeId,\n-                     pat_src: PatternSource,\n-                     bindings: &mut FxHashMap<Ident, NodeId>)\n-                     -> Res {\n-        // Add the binding to the local ribs, if it\n-        // doesn't already exist in the bindings map. (We\n-        // must not add it if it's in the bindings map\n-        // because that breaks the assumptions later\n-        // passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n-        let mut res = Res::Local(pat_id);\n-        match bindings.get(&ident).cloned() {\n-            Some(id) if id == outer_pat_id => {\n-                // `Variant(a, a)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::FnParam => {\n-                // `fn f(a: u8, a: u8)`, error\n-                self.r.report_error(\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::Match ||\n-                        pat_src == PatternSource::Let => {\n-                // `Variant1(a) | Variant2(a)`, ok\n-                // Reuse definition from the first `a`.\n-                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n-            }\n-            Some(..) => {\n-                span_bug!(ident.span, \"two bindings with the same name from \\\n-                                       unexpected pattern source {:?}\", pat_src);\n-            }\n-            None => {\n-                // A completely fresh binding, add to the lists if it's valid.\n-                if ident.name != kw::Invalid {\n-                    bindings.insert(ident, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n-                }\n-            }\n-        }\n+    /// Arising from `source`, resolve a top level pattern.\n+    fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n+        let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n+        self.resolve_pattern(pat, pat_src, &mut bindings);\n+    }\n \n-        res\n+    fn resolve_pattern(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) {\n+        self.resolve_pattern_inner(pat, pat_src, bindings);\n+        // This has to happen *after* we determine which pat_idents are variants:\n+        self.check_consistent_bindings_top(pat);\n+        visit::walk_pat(self, pat);\n     }\n \n-    fn resolve_pattern(&mut self,\n-                       pat: &Pat,\n-                       pat_src: PatternSource,\n-                       // Maps idents to the node ID for the\n-                       // outermost pattern that binds them.\n-                       bindings: &mut FxHashMap<Ident, NodeId>) {\n+    /// Resolve bindings in a pattern. This is a helper to `resolve_pattern`.\n+    ///\n+    /// ### `bindings`\n+    ///\n+    /// A stack of sets of bindings accumulated.\n+    ///\n+    /// In each set, `PatBoundCtx::Product` denotes that a found binding in it should\n+    /// be interpreted as re-binding an already bound binding. This results in an error.\n+    /// Meanwhile, `PatBound::Or` denotes that a found binding in the set should result\n+    /// in reusing this binding rather than creating a fresh one.\n+    ///\n+    /// When called at the top level, the stack must have a single element\n+    /// with `PatBound::Product`. Otherwise, pushing to the stack happens as\n+    /// or-patterns (`p_0 | ... | p_n`) are encountered and the context needs\n+    /// to be switched to `PatBoundCtx::Or` and then `PatBoundCtx::Product` for each `p_i`.\n+    /// When each `p_i` has been dealt with, the top set is merged with its parent.\n+    /// When a whole or-pattern has been dealt with, the thing happens.\n+    ///\n+    /// See the implementation and `fresh_binding` for more details.\n+    fn resolve_pattern_inner(\n+        &mut self,\n+        pat: &Pat,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) {\n         // Visit all direct subpatterns of this pattern.\n-        let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n             match pat.node {\n-                PatKind::Ident(bmode, ident, ref opt_pat) => {\n-                    // First try to resolve the identifier as some existing\n-                    // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n-                                                                      None, pat.span)\n-                                      .and_then(LexicalScopeBinding::item);\n-                    let res = binding.map(NameBinding::res).and_then(|res| {\n-                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n-                            bmode == BindingMode::ByValue(Mutability::Immutable);\n-                        match res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n-                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n-                                // Disambiguate in favor of a unit struct/variant\n-                                // or constant pattern.\n-                                self.r.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(res)\n-                            }\n-                            Res::Def(DefKind::Ctor(..), _)\n-                            | Res::Def(DefKind::Const, _)\n-                            | Res::Def(DefKind::Static, _) => {\n-                                // This is unambiguously a fresh binding, either syntactically\n-                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n-                                // to something unusable as a pattern (e.g., constructor function),\n-                                // but we still conservatively report an error, see\n-                                // issues/33118#issuecomment-233962221 for one reason why.\n-                                self.r.report_error(\n-                                    ident.span,\n-                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.name, binding.unwrap())\n-                                );\n-                                None\n-                            }\n-                            Res::Def(DefKind::Fn, _) | Res::Err => {\n-                                // These entities are explicitly allowed\n-                                // to be shadowed by fresh bindings.\n-                                None\n-                            }\n-                            res => {\n-                                span_bug!(ident.span, \"unexpected resolution for an \\\n-                                                       identifier in pattern: {:?}\", res);\n-                            }\n-                        }\n-                    }).unwrap_or_else(|| {\n-                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    });\n-\n+                PatKind::Ident(bmode, ident, ref sub) => {\n+                    // First try to resolve the identifier as some existing entity,\n+                    // then fall back to a fresh binding.\n+                    let has_sub = sub.is_some();\n+                    let res = self.try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n-\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n                 }\n-\n                 PatKind::Path(ref qself, ref path) => {\n                     self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n                 }\n-\n                 PatKind::Struct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n                 }\n-\n+                PatKind::Or(ref ps) => {\n+                    // Add a new set of bindings to the stack. `Or` here records that when a\n+                    // binding already exists in this set, it should not result in an error because\n+                    // `V1(a) | V2(a)` must be allowed and are checked for consistency later.\n+                    bindings.push((PatBoundCtx::Or, Default::default()));\n+                    for p in ps {\n+                        // Now we need to switch back to a product context so that each\n+                        // part of the or-pattern internally rejects already bound names.\n+                        // For example, `V1(a) | V2(a, a)` and `V1(a, a) | V2(a)` are bad.\n+                        bindings.push((PatBoundCtx::Product, Default::default()));\n+                        self.resolve_pattern_inner(p, pat_src, bindings);\n+                        // Move up the non-overlapping bindings to the or-pattern.\n+                        // Existing bindings just get \"merged\".\n+                        let collected = bindings.pop().unwrap().1;\n+                        bindings.last_mut().unwrap().1.extend(collected);\n+                    }\n+                    // This or-pattern itself can itself be part of a product,\n+                    // e.g. `(V1(a) | V2(a), a)` or `(a, V1(a) | V2(a))`.\n+                    // Both cases bind `a` again in a product pattern and must be rejected.\n+                    let collected = bindings.pop().unwrap().1;\n+                    bindings.last_mut().unwrap().1.extend(collected);\n+\n+                    // Prevent visiting `ps` as we've already done so above.\n+                    return false;\n+                }\n                 _ => {}\n             }\n             true\n         });\n+    }\n \n-        visit::walk_pat(self, pat);\n+    fn fresh_binding(\n+        &mut self,\n+        ident: Ident,\n+        pat_id: NodeId,\n+        pat_src: PatternSource,\n+        bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n+    ) -> Res {\n+        // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n+        // (We must not add it if it's in the bindings map because that breaks the assumptions\n+        // later passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n+\n+        // Walk outwards the stack of products / or-patterns and\n+        // find out if the identifier has been bound in any of these.\n+        let mut already_bound_and = false;\n+        let mut already_bound_or = false;\n+        for (is_sum, set) in bindings.iter_mut().rev() {\n+            match (is_sum, set.get(&ident).cloned()) {\n+                // Already bound in a product pattern, e.g. `(a, a)` which is not allowed.\n+                (PatBoundCtx::Product, Some(..)) => already_bound_and = true,\n+                // Already bound in an or-pattern, e.g. `V1(a) | V2(a)`.\n+                // This is *required* for consistency which is checked later.\n+                (PatBoundCtx::Or, Some(..)) => already_bound_or = true,\n+                // Not already bound here.\n+                _ => {}\n+            }\n+        }\n+\n+        if already_bound_and {\n+            // Overlap in a product pattern somewhere; report an error.\n+            use ResolutionError::*;\n+            let error = match pat_src {\n+                // `fn f(a: u8, a: u8)`:\n+                PatternSource::FnParam => IdentifierBoundMoreThanOnceInParameterList,\n+                // `Variant(a, a)`:\n+                _ => IdentifierBoundMoreThanOnceInSamePattern,\n+            };\n+            self.r.report_error(ident.span, error(&ident.as_str()));\n+        }\n+\n+        // Record as bound if it's valid:\n+        let ident_valid = ident.name != kw::Invalid;\n+        if ident_valid {\n+            bindings.last_mut().unwrap().1.insert(ident);\n+        }\n+\n+        if already_bound_or {\n+            // `Variant1(a) | Variant2(a)`, ok\n+            // Reuse definition from the first `a`.\n+            self.innermost_rib_bindings(ValueNS)[&ident]\n+        } else {\n+            let res = Res::Local(pat_id);\n+            if ident_valid {\n+                // A completely fresh binding add to the set if it's valid.\n+                self.innermost_rib_bindings(ValueNS).insert(ident, res);\n+            }\n+            res\n+        }\n+    }\n+\n+    fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut IdentMap<Res> {\n+        &mut self.ribs[ns].last_mut().unwrap().bindings\n+    }\n+\n+    fn try_resolve_as_non_binding(\n+        &mut self,\n+        pat_src: PatternSource,\n+        pat: &Pat,\n+        bm: BindingMode,\n+        ident: Ident,\n+        has_sub: bool,\n+    ) -> Option<Res> {\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?.item()?;\n+        let res = binding.res();\n+\n+        // An immutable (no `mut`) by-value (no `ref`) binding pattern without\n+        // a sub pattern (no `@ $pat`) is syntactically ambiguous as it could\n+        // also be interpreted as a path to e.g. a constant, variant, etc.\n+        let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Immutable);\n+\n+        match res {\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n+                // Disambiguate in favor of a unit struct/variant or constant pattern.\n+                self.r.record_use(ident, ValueNS, binding, false);\n+                Some(res)\n+            }\n+            Res::Def(DefKind::Ctor(..), _)\n+            | Res::Def(DefKind::Const, _)\n+            | Res::Def(DefKind::Static, _) => {\n+                // This is unambiguously a fresh binding, either syntactically\n+                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                // to something unusable as a pattern (e.g., constructor function),\n+                // but we still conservatively report an error, see\n+                // issues/33118#issuecomment-233962221 for one reason why.\n+                self.r.report_error(\n+                    ident.span,\n+                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                        pat_src.descr(),\n+                        ident.name,\n+                        binding,\n+                    ),\n+                );\n+                None\n+            }\n+            Res::Def(DefKind::Fn, _) | Res::Err => {\n+                // These entities are explicitly allowed to be shadowed by fresh bindings.\n+                None\n+            }\n+            res => {\n+                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                        identifier in pattern: {:?}\", res);\n+            }\n+        }\n     }\n \n     // High-level and context dependent path resolution routine.\n@@ -1723,12 +1769,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         Some(result)\n     }\n \n-    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n+    fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {\n         if let Some(label) = label {\n             self.unused_labels.insert(id, label.ident.span);\n-            self.with_label_rib(|this| {\n+            self.with_label_rib(NormalRibKind, |this| {\n                 let ident = label.ident.modern_and_legacy();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n@@ -1742,6 +1786,49 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.with_resolved_label(label, id, |this| this.visit_block(block));\n     }\n \n+    fn resolve_block(&mut self, block: &Block) {\n+        debug!(\"(resolving block) entering block\");\n+        // Move down in the graph, if there's an anonymous module rooted here.\n+        let orig_module = self.parent_scope.module;\n+        let anonymous_module = self.r.block_map.get(&block.id).cloned(); // clones a reference\n+\n+        let mut num_macro_definition_ribs = 0;\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.parent_scope.module = anonymous_module;\n+        } else {\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+        }\n+\n+        // Descend into the block.\n+        for stmt in &block.stmts {\n+            if let StmtKind::Item(ref item) = stmt.node {\n+                if let ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let res = self.r.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n+\n+        // Move back up.\n+        self.parent_scope.module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.ribs[ValueNS].pop();\n+            self.label_ribs.pop();\n+        }\n+        self.ribs[ValueNS].pop();\n+        if anonymous_module.is_some() {\n+            self.ribs[TypeNS].pop();\n+        }\n+        debug!(\"(resolving block) leaving block\");\n+    }\n+\n     fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n         // First, record candidate traits for this expression if it could\n         // result in the invocation of a method call.\n@@ -1796,39 +1883,36 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 self.visit_expr(scrutinee);\n-                self.resolve_pats(pats, PatternSource::Let);\n+                self.resolve_pattern_top(pat, PatternSource::Let);\n             }\n \n             ExprKind::If(ref cond, ref then, ref opt_else) => {\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.visit_expr(cond);\n-                self.visit_block(then);\n-                self.ribs[ValueNS].pop();\n-\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.visit_expr(cond);\n+                    this.visit_block(then);\n+                });\n                 opt_else.as_ref().map(|expr| self.visit_expr(expr));\n             }\n \n             ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n \n-            ExprKind::While(ref subexpression, ref block, label) => {\n+            ExprKind::While(ref cond, ref block, label) => {\n                 self.with_resolved_label(label, expr.id, |this| {\n-                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.visit_expr(subexpression);\n-                    this.visit_block(block);\n-                    this.ribs[ValueNS].pop();\n+                    this.with_rib(ValueNS, NormalRibKind, |this| {\n+                        this.visit_expr(cond);\n+                        this.visit_block(block);\n+                    })\n                 });\n             }\n \n-            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n+            ExprKind::ForLoop(ref pat, ref iter_expr, ref block, label) => {\n+                self.visit_expr(iter_expr);\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    this.resolve_pattern_top(pat, PatternSource::For);\n+                    this.resolve_labeled_block(label, expr.id, block);\n+                });\n             }\n \n             ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n@@ -1860,30 +1944,22 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n             // resolve the arguments within the proper scopes so that usages of them inside the\n             // closure are detected as upvars rather than normal closure arg usages.\n-            ExprKind::Closure(\n-                _, IsAsync::Async { .. }, _,\n-                ref fn_decl, ref body, _span,\n-            ) => {\n-                let rib_kind = NormalRibKind;\n-                self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                // Resolve arguments:\n-                let mut bindings_list = FxHashMap::default();\n-                for argument in &fn_decl.inputs {\n-                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-                    self.visit_ty(&argument.ty);\n-                }\n-                // No need to resolve return type-- the outer closure return type is\n-                // FunctionRetTy::Default\n-\n-                // Now resolve the inner closure\n-                {\n-                    // No need to resolve arguments: the inner closure has none.\n-                    // Resolve the return type:\n-                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n-                    // Resolve the body\n-                    self.visit_expr(body);\n-                }\n-                self.ribs[ValueNS].pop();\n+            ExprKind::Closure(_, IsAsync::Async { .. }, _, ref fn_decl, ref body, _span) => {\n+                self.with_rib(ValueNS, NormalRibKind, |this| {\n+                    // Resolve arguments:\n+                    this.resolve_params(&fn_decl.inputs);\n+                    // No need to resolve return type --\n+                    // the outer closure return type is `FunctionRetTy::Default`.\n+\n+                    // Now resolve the inner closure\n+                    {\n+                        // No need to resolve arguments: the inner closure has none.\n+                        // Resolve the return type:\n+                        visit::walk_fn_ret_ty(this, &fn_decl.output);\n+                        // Resolve the body\n+                        this.visit_expr(body);\n+                    }\n+                });\n             }\n             _ => {\n                 visit::walk_expr(self, expr);"}, {"sha": "9b92bb7698aaa506e5e6a805b4bd4a83c445904d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -9,6 +9,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(inner_deref)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(mem_take)]"}, {"sha": "12c5ce12a0e8bc0dce1da59e2051dde180ab8a4c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 14, "deletions": 83, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -897,32 +897,23 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_var_decl_multi(&mut self, pats: &'l [P<ast::Pat>]) {\n+    fn process_var_decl(&mut self, pat: &'l ast::Pat) {\n+        // The pattern could declare multiple new vars,\n+        // we must walk the pattern and collect them all.\n         let mut collector = PathCollector::new();\n-        for pattern in pats {\n-            // collect paths from the arm's patterns\n-            collector.visit_pat(&pattern);\n-            self.visit_pat(&pattern);\n-        }\n+        collector.visit_pat(&pat);\n+        self.visit_pat(&pat);\n \n-        // process collected paths\n-        for (id, ident, immut) in collector.collected_idents {\n+        // Process collected paths.\n+        for (id, ident, _) in collector.collected_idents {\n             match self.save_ctxt.get_path_res(id) {\n                 Res::Local(hir_id) => {\n-                    let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(ident.span)\n-                    } else {\n-                        \"<mutable>\".to_owned()\n-                    };\n                     let id = self.tcx.hir().hir_to_node_id(hir_id);\n-                    let typ = self.save_ctxt\n-                        .tables\n-                        .node_type_opt(hir_id)\n+                    let typ = self.save_ctxt.tables.node_type_opt(hir_id)\n                         .map(|t| t.to_string())\n                         .unwrap_or_default();\n-                    value.push_str(\": \");\n-                    value.push_str(&typ);\n \n+                    // Rust uses the id of the pattern for var lookups, so we'll use it too.\n                     if !self.span.filter_generated(ident.span) {\n                         let qualname = format!(\"{}${}\", ident.to_string(), id);\n                         let id = id_from_node_id(id, &self.save_ctxt);\n@@ -972,61 +963,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn process_var_decl(&mut self, p: &'l ast::Pat, value: String) {\n-        // The local could declare multiple new vars, we must walk the\n-        // pattern and collect them all.\n-        let mut collector = PathCollector::new();\n-        collector.visit_pat(&p);\n-        self.visit_pat(&p);\n-\n-        for (id, ident, immut) in collector.collected_idents {\n-            let mut value = match immut {\n-                ast::Mutability::Immutable => value.to_string(),\n-                _ => String::new(),\n-            };\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n-            let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n-                Some(typ) => {\n-                    let typ = typ.to_string();\n-                    if !value.is_empty() {\n-                        value.push_str(\": \");\n-                    }\n-                    value.push_str(&typ);\n-                    typ\n-                }\n-                None => String::new(),\n-            };\n-\n-            // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(ident.span) {\n-                let qualname = format!(\"{}${}\", ident.to_string(), id);\n-                let id = id_from_node_id(id, &self.save_ctxt);\n-                let span = self.span_from_span(ident.span);\n-\n-                self.dumper.dump_def(\n-                    &Access {\n-                        public: false,\n-                        reachable: false,\n-                    },\n-                    Def {\n-                        kind: DefKind::Local,\n-                        id,\n-                        span,\n-                        name: ident.to_string(),\n-                        qualname,\n-                        value: typ,\n-                        parent: None,\n-                        children: vec![],\n-                        decl_id: None,\n-                        docs: String::new(),\n-                        sig: None,\n-                        attributes: vec![],\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n     /// Extracts macro use and definition information from the AST node defined\n     /// by the given NodeId, using the expansion information from the node's\n     /// span.\n@@ -1565,14 +1501,13 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 });\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) => {\n-                let value = self.span.snippet(subexpression.span);\n-                self.process_var_decl(pattern, value);\n+                self.process_var_decl(pattern);\n                 debug!(\"for loop, walk sub-expr: {:?}\", subexpression.node);\n                 self.visit_expr(subexpression);\n                 visit::walk_block(self, block);\n             }\n-            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n-                self.process_var_decl_multi(pats);\n+            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n+                self.process_var_decl(pat);\n                 self.visit_expr(scrutinee);\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n@@ -1599,7 +1534,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &'l ast::Arm) {\n-        self.process_var_decl_multi(&arm.pats);\n+        self.process_var_decl(&arm.pat);\n         if let Some(expr) = &arm.guard {\n             self.visit_expr(expr);\n         }\n@@ -1617,11 +1552,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n \n     fn visit_local(&mut self, l: &'l ast::Local) {\n         self.process_macro_use(l.span);\n-        let value = l.init\n-            .as_ref()\n-            .map(|i| self.span.snippet(i.span))\n-            .unwrap_or_default();\n-        self.process_var_decl(&l.pat, value);\n+        self.process_var_decl(&l.pat);\n \n         // Just walk the initialiser and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);"}, {"sha": "4bc098db68611b87ac8677031d100c599dcf50de", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,5 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n+#![feature(inner_deref)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "24d0659391b040146b17adaae5e67f9a3671f267", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -675,21 +675,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n         } else {\n-            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n-            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n-            struct_span_err!(tcx.sess, pat.span, E0023,\n-                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, res.descr(),\n-                             variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                              variant.fields.len(), fields_ending, subpats.len()))\n-                .emit();\n+            // Pattern has wrong number of fields.\n+            self.e0023(pat.span, res, &subpats, &variant.fields);\n             on_error();\n             return tcx.types.err;\n         }\n         pat_ty\n     }\n \n+    fn e0023(&self, pat_span: Span, res: Res, subpats: &'tcx [P<Pat>], fields: &[ty::FieldDef]) {\n+        let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n+        let fields_ending = if fields.len() == 1 { \"\" } else { \"s\" };\n+        let res_span = self.tcx.def_span(res.def_id());\n+        struct_span_err!(\n+            self.tcx.sess,\n+            pat_span,\n+            E0023,\n+            \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+            subpats.len(),\n+            subpats_ending,\n+            res.descr(),\n+            fields.len(),\n+            fields_ending,\n+        )\n+            .span_label(pat_span, format!(\n+                \"expected {} field{}, found {}\",\n+                fields.len(),\n+                fields_ending,\n+                subpats.len(),\n+            ))\n+            .span_label(res_span, format!(\"{} defined here\", res.descr()))\n+            .emit();\n+    }\n+\n     fn check_pat_tuple(\n         &self,\n         span: Span,"}, {"sha": "0e046b8cd44563bec0cb189bc02d52421745d59f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -3554,7 +3554,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n             let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                           variant.name.as_ref().unwrap(),\n                                           ItemType::Variant.name_space()));\n-            write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+            write!(w, \"<div id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n                        <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                        <code id='{ns_id}'>{name}\",\n                    id = id,\n@@ -3572,7 +3572,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                     write!(w, \")\")?;\n                 }\n             }\n-            write!(w, \"</code></span>\")?;\n+            write!(w, \"</code></div>\")?;\n             document(w, cx, variant)?;\n             document_non_exhaustive(w, variant)?;\n \n@@ -3583,7 +3583,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                 let variant_id = cx.derive_id(format!(\"{}.{}.fields\",\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n-                write!(w, \"<span class='autohide sub-variant' id='{id}'>\",\n+                write!(w, \"<div class='autohide sub-variant' id='{id}'>\",\n                        id = variant_id)?;\n                 write!(w, \"<h3>Fields of <b>{name}</b></h3><div>\",\n                        name = variant.name.as_ref().unwrap())?;\n@@ -3609,7 +3609,7 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                         document(w, cx, field)?;\n                     }\n                 }\n-                write!(w, \"</div></span>\")?;\n+                write!(w, \"</div></div>\")?;\n             }\n             render_stability_since(w, variant, it)?;\n         }"}, {"sha": "83b0b78a0ce365e22d1eb31e4e39753e6bf684a4", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -547,6 +547,11 @@ if (!DOMTokenList.prototype.remove) {\n                 results.sort(function(aaa, bbb) {\n                     var a, b;\n \n+                    // sort by exact match with regard to the last word (mismatch goes later)\n+                    a = (aaa.word !== val);\n+                    b = (bbb.word !== val);\n+                    if (a !== b) { return a - b; }\n+\n                     // Sort by non levenshtein results and then levenshtein results by the distance\n                     // (less changes required to match means higher rankings)\n                     a = (aaa.lev);\n@@ -558,11 +563,6 @@ if (!DOMTokenList.prototype.remove) {\n                     b = (bbb.item.crate !== window.currentCrate);\n                     if (a !== b) { return a - b; }\n \n-                    // sort by exact match (mismatch goes later)\n-                    a = (aaa.word !== valLower);\n-                    b = (bbb.word !== valLower);\n-                    if (a !== b) { return a - b; }\n-\n                     // sort by item name length (longer goes later)\n                     a = aaa.word.length;\n                     b = bbb.word.length;\n@@ -1028,7 +1028,7 @@ if (!DOMTokenList.prototype.remove) {\n                         if (lev > MAX_LEV_DISTANCE) {\n                             continue;\n                         } else if (lev > 0) {\n-                            lev_add = 1;\n+                            lev_add = lev / 10;\n                         }\n                     }\n \n@@ -1099,10 +1099,6 @@ if (!DOMTokenList.prototype.remove) {\n                     if (index !== -1 || lev <= MAX_LEV_DISTANCE) {\n                         if (index !== -1 && paths.length < 2) {\n                             lev = 0;\n-                        } else if (searchWords[j] === val) {\n-                            // Small trick to fix when you're looking for a one letter type\n-                            // and there are other short named types.\n-                            lev = -1;\n                         }\n                         if (results[fullId] === undefined) {\n                             results[fullId] = {"}, {"sha": "18a46cf0b5257e5a2692b98f0450197148830ac6", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -56,6 +56,9 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n [target.x86_64-fortanix-unknown-sgx.dependencies]\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n+[target.wasm32-wasi.dependencies]\n+wasi = { version = \"0.7.0\", features = ['rustc-dep-of-std', 'alloc'] }\n+\n [build-dependencies]\n cc = \"1.0\"\n "}, {"sha": "03a59d6d7c83205262773822e6ba650b08a729bf", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -4,14 +4,16 @@ use crate::io;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv<DefaultEnvKey>,\n+    env: CommandEnv,\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -37,7 +39,7 @@ impl Command {\n \n     pub fn arg(&mut self, _arg: &OsStr) {}\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n "}, {"sha": "edf933d10e07433f52f9ae280b89b1b7d16e5658", "filename": "src/libstd/sys/sgx/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -4,14 +4,16 @@ use crate::io;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv<DefaultEnvKey>\n+    env: CommandEnv,\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -38,7 +40,7 @@ impl Command {\n     pub fn arg(&mut self, _arg: &OsStr) {\n     }\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n "}, {"sha": "056a20345f404013977ff836c6e51eabfa91652f", "filename": "src/libstd/sys/unix/process/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,5 +1,6 @@\n pub use self::process_common::{Command, ExitStatus, ExitCode, Stdio, StdioPipes};\n pub use self::process_inner::Process;\n+pub use crate::ffi::OsString as EnvKey;\n \n mod process_common;\n #[cfg(not(target_os = \"fuchsia\"))]"}, {"sha": "72e66cc8e724000d335f41c3e24fba4ae89800ad", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -7,7 +7,7 @@ use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::pipe::{self, AnonPipe};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n use crate::collections::BTreeMap;\n \n use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n@@ -69,7 +69,7 @@ pub struct Command {\n     program: CString,\n     args: Vec<CString>,\n     argv: Argv,\n-    env: CommandEnv<DefaultEnvKey>,\n+    env: CommandEnv,\n \n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n@@ -201,7 +201,7 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n@@ -271,7 +271,7 @@ impl CStringArray {\n     }\n }\n \n-fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {\n+fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n     let mut result = CStringArray::with_capacity(env.len());\n     for (k, v) in env {\n         let mut k: OsString = k.into();"}, {"sha": "fd6796ad22c12e5c43d339a4773bf3f05586e274", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -311,6 +311,7 @@ mod inner {\n         pub fn actually_monotonic() -> bool {\n             (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86_64\")) ||\n             (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86\")) ||\n+            cfg!(target_os = \"fuchsia\") ||\n             false // last clause, used so `||` is always trailing above\n         }\n "}, {"sha": "509140229fd3a846394fe1282f3057d863e4cbdf", "filename": "src/libstd/sys/vxworks/process/process_common.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -7,11 +7,13 @@ use crate::ptr;\n use crate::sys::fd::FileDesc;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::pipe::{self, AnonPipe};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n use crate::collections::BTreeMap;\n \n use libc::{c_int, gid_t, uid_t, c_char, EXIT_SUCCESS, EXIT_FAILURE};\n \n+pub use crate::ffi::OsString as EnvKey;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n@@ -37,7 +39,7 @@ pub struct Command {\n     program: CString,\n     args: Vec<CString>,\n     argv: Argv,\n-    env: CommandEnv<DefaultEnvKey>,\n+    env: CommandEnv,\n \n     cwd: Option<CString>,\n     uid: Option<uid_t>,\n@@ -170,7 +172,7 @@ impl Command {\n         self.stderr = Some(stderr);\n     }\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n \n@@ -240,7 +242,7 @@ impl CStringArray {\n     }\n }\n \n-fn construct_envp(env: BTreeMap<DefaultEnvKey, OsString>, saw_nul: &mut bool) -> CStringArray {\n+fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n     let mut result = CStringArray::with_capacity(env.len());\n     for (k, v) in env {\n         let mut k: OsString = k.into();"}, {"sha": "3280c4990dc66cf0444332095bf4a7574cb4526e", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,11 +1,10 @@\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::sys::cvt_wasi;\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::os::wasi::ffi::OsStringExt;\n use crate::vec;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n }\n \n@@ -19,31 +18,17 @@ pub struct Args {\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n-    maybe_args().unwrap_or_else(|_| {\n-        Args {\n-            iter: Vec::new().into_iter(),\n-            _dont_send_or_sync_me: PhantomData\n-        }\n-    })\n-}\n-\n-fn maybe_args() -> io::Result<Args> {\n-    unsafe {\n-        let (mut argc, mut argv_buf_size) = (0, 0);\n-        cvt_wasi(libc::__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n-\n-        let mut argc = vec![core::ptr::null_mut::<libc::c_char>(); argc];\n-        let mut argv_buf = vec![0; argv_buf_size];\n-        cvt_wasi(libc::__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n-\n-        let args = argc.into_iter()\n-            .map(|ptr| CStr::from_ptr(ptr).to_bytes().to_vec())\n-            .map(|bytes| OsString::from_vec(bytes))\n-            .collect::<Vec<_>>();\n-        Ok(Args {\n-            iter: args.into_iter(),\n-            _dont_send_or_sync_me: PhantomData,\n-        })\n+    let buf = wasi::args_sizes_get().and_then(|args_sizes| {\n+        let mut buf = Vec::with_capacity(args_sizes.get_count());\n+        wasi::args_get(args_sizes, |arg| {\n+            let arg = OsString::from_vec(arg.to_vec());\n+            buf.push(arg);\n+        })?;\n+        Ok(buf)\n+    }).unwrap_or(vec![]);\n+    Args {\n+        iter: buf.into_iter(),\n+        _dont_send_or_sync_me: PhantomData\n     }\n }\n "}, {"sha": "9fa4abfd171b5e61ac97c50283f49988bf3b76ef", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -8,6 +8,8 @@ use crate::os::wasi::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n+use ::wasi::wasi_unstable as wasi;\n+\n /// WASI-specific extensions to [`File`].\n ///\n /// [`File`]: ../../../../std/fs/struct.File.html\n@@ -336,16 +338,16 @@ pub trait FileTypeExt {\n \n impl FileTypeExt for fs::FileType {\n     fn is_block_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_BLOCK_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_BLOCK_DEVICE\n     }\n     fn is_character_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_CHARACTER_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_CHARACTER_DEVICE\n     }\n     fn is_socket_dgram(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_DGRAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_DGRAM\n     }\n     fn is_socket_stream(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_STREAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_STREAM\n     }\n }\n "}, {"sha": "f1839df380112d5403e7c7ddd46a424b91c84fb0", "filename": "src/libstd/sys/wasi/ext/io.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -8,6 +8,8 @@ use crate::sys;\n use crate::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n+use ::wasi::wasi_unstable as wasi;\n+\n /// Raw file descriptors.\n pub type RawFd = u32;\n \n@@ -125,18 +127,18 @@ impl IntoRawFd for fs::File {\n \n impl AsRawFd for io::Stdin {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO as u32\n+        wasi::STDIN_FD\n     }\n }\n \n impl AsRawFd for io::Stdout {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO as u32\n+        wasi::STDOUT_FD\n     }\n }\n \n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO as u32\n+        wasi::STDERR_FD\n     }\n }"}, {"sha": "5b7a8678b66eab724465219e46c4dd1f830acd10", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 90, "deletions": 190, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -3,348 +3,248 @@\n use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n-use crate::sys::cvt_wasi;\n-use libc::{self, c_char, c_void};\n+use super::err2io;\n+use ::wasi::wasi_unstable as wasi;\n \n #[derive(Debug)]\n pub struct WasiFd {\n-    fd: libc::__wasi_fd_t,\n+    fd: wasi::Fd,\n }\n \n-// FIXME: these should probably all be fancier structs, builders, enums, etc\n-pub type LookupFlags = u32;\n-pub type FdFlags = u16;\n-pub type Advice = u8;\n-pub type Rights = u64;\n-pub type Oflags = u16;\n-pub type DirCookie = u64;\n-pub type Timestamp = u64;\n-pub type FstFlags = u16;\n-pub type RiFlags = u16;\n-pub type RoFlags = u16;\n-pub type SiFlags = u16;\n-\n-fn iovec(a: &mut [IoSliceMut<'_>]) -> (*const libc::__wasi_iovec_t, usize) {\n+fn iovec<'a>(a: &'a mut [IoSliceMut<'_>]) -> &'a [wasi::IoVec] {\n     assert_eq!(\n         mem::size_of::<IoSliceMut<'_>>(),\n-        mem::size_of::<libc::__wasi_iovec_t>()\n+        mem::size_of::<wasi::IoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSliceMut<'_>>(),\n-        mem::align_of::<libc::__wasi_iovec_t>()\n+        mem::align_of::<wasi::IoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_iovec_t, a.len())\n+    /// SAFETY: `IoSliceMut` and `IoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n-fn ciovec(a: &[IoSlice<'_>]) -> (*const libc::__wasi_ciovec_t, usize) {\n+fn ciovec<'a>(a: &'a [IoSlice<'_>]) -> &'a [wasi::CIoVec] {\n     assert_eq!(\n         mem::size_of::<IoSlice<'_>>(),\n-        mem::size_of::<libc::__wasi_ciovec_t>()\n+        mem::size_of::<wasi::CIoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSlice<'_>>(),\n-        mem::align_of::<libc::__wasi_ciovec_t>()\n+        mem::align_of::<wasi::CIoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_ciovec_t, a.len())\n+    /// SAFETY: `IoSlice` and `CIoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n impl WasiFd {\n-    pub unsafe fn from_raw(fd: libc::__wasi_fd_t) -> WasiFd {\n+    pub unsafe fn from_raw(fd: wasi::Fd) -> WasiFd {\n         WasiFd { fd }\n     }\n \n-    pub fn into_raw(self) -> libc::__wasi_fd_t {\n+    pub fn into_raw(self) -> wasi::Fd {\n         let ret = self.fd;\n         mem::forget(self);\n         ret\n     }\n \n-    pub fn as_raw(&self) -> libc::__wasi_fd_t {\n+    pub fn as_raw(&self) -> wasi::Fd {\n         self.fd\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_datasync(self.fd) })\n+        unsafe { wasi::fd_datasync(self.fd).map_err(err2io) }\n     }\n \n     pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pread(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_pread(self.fd, iovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pwrite(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_pwrite(self.fd, ciovec(bufs), offset).map_err(err2io) }\n     }\n \n     pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_read(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_read(self.fd, iovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_write(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        unsafe { wasi::fd_write(self.fd, ciovec(bufs)).map_err(err2io) }\n     }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, offset) = match pos {\n-            SeekFrom::Start(pos) => (libc::__WASI_WHENCE_SET, pos as i64),\n-            SeekFrom::End(pos) => (libc::__WASI_WHENCE_END, pos),\n-            SeekFrom::Current(pos) => (libc::__WASI_WHENCE_CUR, pos),\n+            SeekFrom::Start(pos) => (wasi::WHENCE_SET, pos as i64),\n+            SeekFrom::End(pos) => (wasi::WHENCE_END, pos),\n+            SeekFrom::Current(pos) => (wasi::WHENCE_CUR, pos),\n         };\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_seek(self.fd, offset, whence, &mut pos) })?;\n-        Ok(pos)\n+        unsafe { wasi::fd_seek(self.fd, offset, whence).map_err(err2io) }\n     }\n \n     pub fn tell(&self) -> io::Result<u64> {\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_tell(self.fd, &mut pos) })?;\n-        Ok(pos)\n+        unsafe { wasi::fd_tell(self.fd).map_err(err2io) }\n     }\n \n     // FIXME: __wasi_fd_fdstat_get\n \n-    pub fn set_flags(&self, flags: FdFlags) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_flags(self.fd, flags) })\n+    pub fn set_flags(&self, flags: wasi::FdFlags) -> io::Result<()> {\n+        unsafe { wasi::fd_fdstat_set_flags(self.fd, flags).map_err(err2io) }\n     }\n \n-    pub fn set_rights(&self, base: Rights, inheriting: Rights) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_rights(self.fd, base, inheriting) })\n+    pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {\n+        unsafe { wasi::fd_fdstat_set_rights(self.fd, base, inheriting).map_err(err2io) }\n     }\n \n     pub fn sync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_sync(self.fd) })\n+        unsafe { wasi::fd_sync(self.fd).map_err(err2io) }\n     }\n \n-    pub fn advise(&self, offset: u64, len: u64, advice: Advice) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_advise(self.fd, offset, len, advice as u8) })\n+    pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n+        unsafe { wasi::fd_advise(self.fd, offset, len, advice).map_err(err2io) }\n     }\n \n     pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_allocate(self.fd, offset, len) })\n+        unsafe { wasi::fd_allocate(self.fd, offset, len).map_err(err2io) }\n     }\n \n     pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_create_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_create_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn link(\n         &self,\n-        old_flags: LookupFlags,\n+        old_flags: wasi::LookupFlags,\n         old_path: &[u8],\n         new_fd: &WasiFd,\n         new_path: &[u8],\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_link(\n-                self.fd,\n-                old_flags,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe {\n+            wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n+                .map_err(err2io)\n+        }\n     }\n \n     pub fn open(\n         &self,\n-        dirflags: LookupFlags,\n+        dirflags: wasi::LookupFlags,\n         path: &[u8],\n-        oflags: Oflags,\n-        fs_rights_base: Rights,\n-        fs_rights_inheriting: Rights,\n-        fs_flags: FdFlags,\n+        oflags: wasi::OFlags,\n+        fs_rights_base: wasi::Rights,\n+        fs_rights_inheriting: wasi::Rights,\n+        fs_flags: wasi::FdFlags,\n     ) -> io::Result<WasiFd> {\n         unsafe {\n-            let mut fd = 0;\n-            cvt_wasi(libc::__wasi_path_open(\n+            wasi::path_open(\n                 self.fd,\n                 dirflags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n+                path,\n                 oflags,\n                 fs_rights_base,\n                 fs_rights_inheriting,\n                 fs_flags,\n-                &mut fd,\n-            ))?;\n-            Ok(WasiFd::from_raw(fd))\n+            ).map(|fd| WasiFd::from_raw(fd)).map_err(err2io)\n         }\n     }\n \n-    pub fn readdir(&self, buf: &mut [u8], cookie: DirCookie) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_fd_readdir(\n-                self.fd,\n-                buf.as_mut_ptr() as *mut c_void,\n-                buf.len(),\n-                cookie,\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::DirCookie) -> io::Result<usize> {\n+        unsafe { wasi::fd_readdir(self.fd, buf, cookie).map_err(err2io) }\n     }\n \n     pub fn readlink(&self, path: &[u8], buf: &mut [u8]) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_readlink(\n-                self.fd,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf.as_mut_ptr() as *mut c_char,\n-                buf.len(),\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+        unsafe { wasi::path_readlink(self.fd, path, buf).map_err(err2io) }\n     }\n \n     pub fn rename(&self, old_path: &[u8], new_fd: &WasiFd, new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_rename(\n-                self.fd,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe {\n+            wasi::path_rename(self.fd, old_path, new_fd.fd, new_path).map_err(err2io)\n+        }\n     }\n \n-    pub fn filestat_get(&self, buf: *mut libc::__wasi_filestat_t) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_get(self.fd, buf) })\n+    pub fn filestat_get(&self) -> io::Result<wasi::FileStat> {\n+        unsafe { wasi::fd_filestat_get(self.fd).map_err(err2io) }\n     }\n \n     pub fn filestat_set_times(\n         &self,\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_times(self.fd, atim, mtim, fstflags) })\n+        unsafe {\n+            wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags).map_err(err2io)\n+        }\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_size(self.fd, size) })\n+        unsafe { wasi::fd_filestat_set_size(self.fd, size).map_err(err2io) }\n     }\n \n     pub fn path_filestat_get(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        buf: *mut libc::__wasi_filestat_t,\n-    ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_get(\n-                self.fd,\n-                flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf,\n-            )\n-        })\n+    ) -> io::Result<wasi::FileStat> {\n+        unsafe { wasi::path_filestat_get(self.fd, flags, path).map_err(err2io) }\n     }\n \n     pub fn path_filestat_set_times(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_set_times(\n+        unsafe {\n+            wasi::path_filestat_set_times(\n                 self.fd,\n                 flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n+                path,\n                 atim,\n                 mtim,\n                 fstflags,\n-            )\n-        })\n+            ).map_err(err2io)\n+        }\n     }\n \n     pub fn symlink(&self, old_path: &[u8], new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_symlink(\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                self.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        unsafe { wasi::path_symlink(old_path, self.fd, new_path).map_err(err2io) }\n     }\n \n     pub fn unlink_file(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_unlink_file(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_unlink_file(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn remove_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_remove_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        unsafe { wasi::path_remove_directory(self.fd, path).map_err(err2io) }\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n-        ri_flags: RiFlags,\n-    ) -> io::Result<(usize, RoFlags)> {\n-        let mut ro_datalen = 0;\n-        let mut ro_flags = 0;\n-        let (ptr, len) = iovec(ri_data);\n-        cvt_wasi(unsafe {\n-            libc::__wasi_sock_recv(self.fd, ptr, len, ri_flags, &mut ro_datalen, &mut ro_flags)\n-        })?;\n-        Ok((ro_datalen, ro_flags))\n+        ri_flags: wasi::RiFlags,\n+    ) -> io::Result<(usize, wasi::RoFlags)> {\n+        unsafe { wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(err2io) }\n     }\n \n-    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: SiFlags) -> io::Result<usize> {\n-        let mut so_datalen = 0;\n-        let (ptr, len) = ciovec(si_data);\n-        cvt_wasi(unsafe { libc::__wasi_sock_send(self.fd, ptr, len, si_flags, &mut so_datalen) })?;\n-        Ok(so_datalen)\n+    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::SiFlags) -> io::Result<usize> {\n+        unsafe { wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(err2io) }\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n-            Shutdown::Read => libc::__WASI_SHUT_RD,\n-            Shutdown::Write => libc::__WASI_SHUT_WR,\n-            Shutdown::Both => libc::__WASI_SHUT_WR | libc::__WASI_SHUT_RD,\n+            Shutdown::Read => wasi::SHUT_RD,\n+            Shutdown::Write => wasi::SHUT_WR,\n+            Shutdown::Both => wasi::SHUT_WR | wasi::SHUT_RD,\n         };\n-        cvt_wasi(unsafe { libc::__wasi_sock_shutdown(self.fd, how) })?;\n-        Ok(())\n+        unsafe { wasi::sock_shutdown(self.fd, how).map_err(err2io) }\n     }\n }\n \n impl Drop for WasiFd {\n     fn drop(&mut self) {\n-        unsafe {\n-            // FIXME: can we handle the return code here even though we can't on\n-            // unix?\n-            libc::__wasi_fd_close(self.fd);\n-        }\n+        // FIXME: can we handle the return code here even though we can't on\n+        // unix?\n+        let _ = unsafe { wasi::fd_close(self.fd) };\n     }\n }"}, {"sha": "4113f6a2e09c0e21e7080102df326095182957af", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 84, "deletions": 102, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -7,26 +7,28 @@ use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sync::Arc;\n-use crate::sys::fd::{DirCookie, WasiFd};\n+use crate::sys::fd::WasiFd;\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n use crate::sys_common::FromInner;\n \n pub use crate::sys_common::fs::copy;\n pub use crate::sys_common::fs::remove_dir_all;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub struct File {\n     fd: WasiFd,\n }\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    meta: libc::__wasi_filestat_t,\n+    meta: wasi::FileStat,\n }\n \n pub struct ReadDir {\n     inner: Arc<ReadDirInner>,\n-    cookie: Option<DirCookie>,\n+    cookie: Option<wasi::DirCookie>,\n     buf: Vec<u8>,\n     offset: usize,\n     cap: usize,\n@@ -38,7 +40,7 @@ struct ReadDirInner {\n }\n \n pub struct DirEntry {\n-    meta: libc::__wasi_dirent_t,\n+    meta: wasi::Dirent,\n     name: Vec<u8>,\n     inner: Arc<ReadDirInner>,\n }\n@@ -47,11 +49,11 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n-    dirflags: libc::__wasi_lookupflags_t,\n-    fdflags: libc::__wasi_fdflags_t,\n-    oflags: libc::__wasi_oflags_t,\n-    rights_base: Option<libc::__wasi_rights_t>,\n-    rights_inheriting: Option<libc::__wasi_rights_t>,\n+    dirflags: wasi::LookupFlags,\n+    fdflags: wasi::FdFlags,\n+    oflags: wasi::OFlags,\n+    rights_base: Option<wasi::Rights>,\n+    rights_inheriting: Option<wasi::Rights>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -61,19 +63,13 @@ pub struct FilePermissions {\n \n #[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]\n pub struct FileType {\n-    bits: libc::__wasi_filetype_t,\n+    bits: wasi::FileType,\n }\n \n #[derive(Debug)]\n pub struct DirBuilder {}\n \n impl FileAttr {\n-    fn zero() -> FileAttr {\n-        FileAttr {\n-            meta: unsafe { mem::zeroed() },\n-        }\n-    }\n-\n     pub fn size(&self) -> u64 {\n         self.meta.st_size\n     }\n@@ -101,7 +97,7 @@ impl FileAttr {\n         Ok(SystemTime::from_wasi_timestamp(self.meta.st_ctim))\n     }\n \n-    pub fn as_wasi(&self) -> &libc::__wasi_filestat_t {\n+    pub fn as_wasi(&self) -> &wasi::FileStat {\n         &self.meta\n     }\n }\n@@ -118,18 +114,18 @@ impl FilePermissions {\n \n impl FileType {\n     pub fn is_dir(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_DIRECTORY\n+        self.bits == wasi::FILETYPE_DIRECTORY\n     }\n \n     pub fn is_file(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_REGULAR_FILE\n+        self.bits == wasi::FILETYPE_REGULAR_FILE\n     }\n \n     pub fn is_symlink(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_SYMBOLIC_LINK\n+        self.bits == wasi::FILETYPE_SYMBOLIC_LINK\n     }\n \n-    pub fn bits(&self) -> libc::__wasi_filetype_t {\n+    pub fn bits(&self) -> wasi::FileType {\n         self.bits\n     }\n }\n@@ -173,7 +169,7 @@ impl Iterator for ReadDir {\n             // must have been truncated at the end of the buffer, so reset our\n             // offset so we can go back and reread into the buffer, picking up\n             // where we last left off.\n-            let dirent_size = mem::size_of::<libc::__wasi_dirent_t>();\n+            let dirent_size = mem::size_of::<wasi::Dirent>();\n             if data.len() < dirent_size {\n                 assert!(self.cookie.is_some());\n                 assert!(self.buf.len() >= dirent_size);\n@@ -182,7 +178,7 @@ impl Iterator for ReadDir {\n             }\n             let (dirent, data) = data.split_at(dirent_size);\n             let dirent =\n-                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const libc::__wasi_dirent_t) };\n+                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const wasi::Dirent) };\n \n             // If the file name was truncated, then we need to reinvoke\n             // `readdir` so we truncate our buffer to start over and reread this\n@@ -241,15 +237,15 @@ impl DirEntry {\n         })\n     }\n \n-    pub fn ino(&self) -> libc::__wasi_inode_t {\n+    pub fn ino(&self) -> wasi::Inode {\n         self.meta.d_ino\n     }\n }\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         let mut base = OpenOptions::default();\n-        base.dirflags = libc::__WASI_LOOKUP_SYMLINK_FOLLOW;\n+        base.dirflags = wasi::LOOKUP_SYMLINK_FOLLOW;\n         return base;\n     }\n \n@@ -262,23 +258,23 @@ impl OpenOptions {\n     }\n \n     pub fn truncate(&mut self, truncate: bool) {\n-        self.oflag(libc::__WASI_O_TRUNC, truncate);\n+        self.oflag(wasi::O_TRUNC, truncate);\n     }\n \n     pub fn create(&mut self, create: bool) {\n-        self.oflag(libc::__WASI_O_CREAT, create);\n+        self.oflag(wasi::O_CREAT, create);\n     }\n \n     pub fn create_new(&mut self, create_new: bool) {\n-        self.oflag(libc::__WASI_O_EXCL, create_new);\n-        self.oflag(libc::__WASI_O_CREAT, create_new);\n+        self.oflag(wasi::O_EXCL, create_new);\n+        self.oflag(wasi::O_CREAT, create_new);\n     }\n \n     pub fn directory(&mut self, directory: bool) {\n-        self.oflag(libc::__WASI_O_DIRECTORY, directory);\n+        self.oflag(wasi::O_DIRECTORY, directory);\n     }\n \n-    fn oflag(&mut self, bit: libc::__wasi_oflags_t, set: bool) {\n+    fn oflag(&mut self, bit: wasi::OFlags, set: bool) {\n         if set {\n             self.oflags |= bit;\n         } else {\n@@ -287,42 +283,42 @@ impl OpenOptions {\n     }\n \n     pub fn append(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_APPEND, set);\n+        self.fdflag(wasi::FDFLAG_APPEND, set);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_DSYNC, set);\n+        self.fdflag(wasi::FDFLAG_DSYNC, set);\n     }\n \n     pub fn nonblock(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_NONBLOCK, set);\n+        self.fdflag(wasi::FDFLAG_NONBLOCK, set);\n     }\n \n     pub fn rsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_RSYNC, set);\n+        self.fdflag(wasi::FDFLAG_RSYNC, set);\n     }\n \n     pub fn sync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_SYNC, set);\n+        self.fdflag(wasi::FDFLAG_SYNC, set);\n     }\n \n-    fn fdflag(&mut self, bit: libc::__wasi_fdflags_t, set: bool) {\n+    fn fdflag(&mut self, bit: wasi::FdFlags, set: bool) {\n         if set {\n             self.fdflags |= bit;\n         } else {\n             self.fdflags &= !bit;\n         }\n     }\n \n-    pub fn fs_rights_base(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_base(&mut self, rights: wasi::Rights) {\n         self.rights_base = Some(rights);\n     }\n \n-    pub fn fs_rights_inheriting(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_inheriting(&mut self, rights: wasi::Rights) {\n         self.rights_inheriting = Some(rights);\n     }\n \n-    fn rights_base(&self) -> libc::__wasi_rights_t {\n+    fn rights_base(&self) -> wasi::Rights {\n         if let Some(rights) = self.rights_base {\n             return rights;\n         }\n@@ -334,52 +330,52 @@ impl OpenOptions {\n         // based on that.\n         let mut base = 0;\n         if self.read {\n-            base |= libc::__WASI_RIGHT_FD_READ;\n-            base |= libc::__WASI_RIGHT_FD_READDIR;\n+            base |= wasi::RIGHT_FD_READ;\n+            base |= wasi::RIGHT_FD_READDIR;\n         }\n         if self.write {\n-            base |= libc::__WASI_RIGHT_FD_WRITE;\n-            base |= libc::__WASI_RIGHT_FD_DATASYNC;\n-            base |= libc::__WASI_RIGHT_FD_ALLOCATE;\n-            base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_SIZE;\n+            base |= wasi::RIGHT_FD_WRITE;\n+            base |= wasi::RIGHT_FD_DATASYNC;\n+            base |= wasi::RIGHT_FD_ALLOCATE;\n+            base |= wasi::RIGHT_FD_FILESTAT_SET_SIZE;\n         }\n \n         // FIXME: some of these should probably be read-only or write-only...\n-        base |= libc::__WASI_RIGHT_FD_ADVISE;\n-        base |= libc::__WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n-        base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_TIMES;\n-        base |= libc::__WASI_RIGHT_FD_SEEK;\n-        base |= libc::__WASI_RIGHT_FD_SYNC;\n-        base |= libc::__WASI_RIGHT_FD_TELL;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_FILE;\n-        base |= libc::__WASI_RIGHT_PATH_FILESTAT_GET;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_OPEN;\n-        base |= libc::__WASI_RIGHT_PATH_READLINK;\n-        base |= libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_SYMLINK;\n-        base |= libc::__WASI_RIGHT_PATH_UNLINK_FILE;\n-        base |= libc::__WASI_RIGHT_POLL_FD_READWRITE;\n+        base |= wasi::RIGHT_FD_ADVISE;\n+        base |= wasi::RIGHT_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHT_FD_FILESTAT_SET_TIMES;\n+        base |= wasi::RIGHT_FD_SEEK;\n+        base |= wasi::RIGHT_FD_SYNC;\n+        base |= wasi::RIGHT_FD_TELL;\n+        base |= wasi::RIGHT_PATH_CREATE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_CREATE_FILE;\n+        base |= wasi::RIGHT_PATH_FILESTAT_GET;\n+        base |= wasi::RIGHT_PATH_LINK_SOURCE;\n+        base |= wasi::RIGHT_PATH_LINK_TARGET;\n+        base |= wasi::RIGHT_PATH_OPEN;\n+        base |= wasi::RIGHT_PATH_READLINK;\n+        base |= wasi::RIGHT_PATH_REMOVE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_RENAME_SOURCE;\n+        base |= wasi::RIGHT_PATH_RENAME_TARGET;\n+        base |= wasi::RIGHT_PATH_SYMLINK;\n+        base |= wasi::RIGHT_PATH_UNLINK_FILE;\n+        base |= wasi::RIGHT_POLL_FD_READWRITE;\n \n         return base;\n     }\n \n-    fn rights_inheriting(&self) -> libc::__wasi_rights_t {\n+    fn rights_inheriting(&self) -> wasi::Rights {\n         self.rights_inheriting.unwrap_or_else(|| self.rights_base())\n     }\n \n-    pub fn lookup_flags(&mut self, flags: libc::__wasi_lookupflags_t) {\n+    pub fn lookup_flags(&mut self, flags: wasi::LookupFlags) {\n         self.dirflags = flags;\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path, libc::__WASI_RIGHT_PATH_OPEN)?;\n+        let (dir, file) = open_parent(path, wasi::RIGHT_PATH_OPEN)?;\n         open_at(&dir, &file, opts)\n     }\n \n@@ -388,14 +384,12 @@ impl File {\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut ret = FileAttr::zero();\n-        self.fd.filestat_get(&mut ret.meta)?;\n-        Ok(ret)\n+        self.fd.filestat_get().map(|meta| FileAttr { meta })\n     }\n \n     pub fn metadata_at(\n         &self,\n-        flags: libc::__wasi_lookupflags_t,\n+        flags: wasi::LookupFlags,\n         path: &Path,\n     ) -> io::Result<FileAttr> {\n         metadata_at(&self.fd, flags, path)\n@@ -477,7 +471,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY)?;\n+        let (dir, file) = open_parent(p, wasi::RIGHT_PATH_CREATE_DIRECTORY)?;\n         dir.create_directory(file.as_os_str().as_bytes())\n     }\n }\n@@ -508,13 +502,13 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_UNLINK_FILE)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_UNLINK_FILE)?;\n     dir.unlink_file(file.as_os_str().as_bytes())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old, libc::__WASI_RIGHT_PATH_RENAME_SOURCE)?;\n-    let (new, new_file) = open_parent(new, libc::__WASI_RIGHT_PATH_RENAME_TARGET)?;\n+    let (old, old_file) = open_parent(old, wasi::RIGHT_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, wasi::RIGHT_PATH_RENAME_TARGET)?;\n     old.rename(\n         old_file.as_os_str().as_bytes(),\n         &new,\n@@ -529,12 +523,12 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_REMOVE_DIRECTORY)?;\n     dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_READLINK)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_READLINK)?;\n     read_link(&dir, &file)\n }\n \n@@ -570,39 +564,38 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_SYMLINK)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_SYMLINK)?;\n     dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src, libc::__WASI_RIGHT_PATH_LINK_SOURCE)?;\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_LINK_TARGET)?;\n+    let (src, src_file) = open_parent(src, wasi::RIGHT_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_LINK_TARGET)?;\n     src.link(\n-        libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n+        wasi::LOOKUP_SYMLINK_FOLLOW,\n         src_file.as_os_str().as_bytes(),\n         &dst,\n         dst_file.as_os_str().as_bytes(),\n     )\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n-    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, &file)\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, wasi::LOOKUP_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n     metadata_at(&dir, 0, &file)\n }\n \n fn metadata_at(\n     fd: &WasiFd,\n-    flags: libc::__wasi_lookupflags_t,\n+    flags: wasi::LookupFlags,\n     path: &Path,\n ) -> io::Result<FileAttr> {\n-    let mut ret = FileAttr::zero();\n-    fd.path_filestat_get(flags, path.as_os_str().as_bytes(), &mut ret.meta)?;\n-    Ok(ret)\n+    fd.path_filestat_get(flags, path.as_os_str().as_bytes())\n+        .map(|meta| FileAttr { meta })\n }\n \n pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n@@ -652,12 +645,12 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// to any preopened file descriptor.\n fn open_parent(\n     p: &Path,\n-    rights: libc::__wasi_rights_t,\n+    rights: wasi::Rights,\n ) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n-        let fd = __wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n+        let fd = libc::__wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n         if fd == -1 {\n             let msg = format!(\n                 \"failed to find a preopened file descriptor \\\n@@ -677,15 +670,4 @@ fn open_parent(\n \n         return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n     }\n-\n-    // FIXME(rust-lang/libc#1314) use the `libc` crate for this when the API\n-    // there is published\n-    extern \"C\" {\n-        pub fn __wasilibc_find_relpath(\n-            path: *const libc::c_char,\n-            rights_base: libc::__wasi_rights_t,\n-            rights_inheriting: libc::__wasi_rights_t,\n-            relative_path: *mut *const libc::c_char,\n-        ) -> libc::c_int;\n-    }\n }"}, {"sha": "4be92faed308fe91632a5e2588234202d1a338d9", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,19 +1,20 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{__wasi_ciovec_t, __wasi_iovec_t, c_void};\n+use ::wasi::wasi_unstable as wasi;\n+use core::ffi::c_void;\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n-    vec: __wasi_ciovec_t,\n+    vec: wasi::CIoVec,\n     _p: PhantomData<&'a [u8]>,\n }\n \n impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: __wasi_ciovec_t {\n+            vec: wasi::CIoVec {\n                 buf: buf.as_ptr() as *const c_void,\n                 buf_len: buf.len(),\n             },\n@@ -43,15 +44,15 @@ impl<'a> IoSlice<'a> {\n \n #[repr(transparent)]\n pub struct IoSliceMut<'a> {\n-    vec: __wasi_iovec_t,\n+    vec: wasi::IoVec,\n     _p: PhantomData<&'a mut [u8]>,\n }\n \n impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: __wasi_iovec_t {\n+            vec: wasi::IoVec {\n                 buf: buf.as_mut_ptr() as *mut c_void,\n                 buf_len: buf.len()\n             },"}, {"sha": "517e3be9cb58c14273f3eb2c0e8526e29f70dbd4", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -14,10 +14,10 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use libc;\n-use crate::io::{Error, ErrorKind};\n+use crate::io as std_io;\n use crate::mem;\n use crate::os::raw::c_char;\n+use ::wasi::wasi_unstable as wasi;\n \n pub mod alloc;\n pub mod args;\n@@ -56,31 +56,42 @@ pub mod ext;\n pub fn init() {\n }\n \n-pub fn unsupported<T>() -> crate::io::Result<T> {\n+pub fn unsupported<T>() -> std_io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> Error {\n-    Error::new(ErrorKind::Other, \"operation not supported on wasm yet\")\n+pub fn unsupported_err() -> std_io::Error {\n+    std_io::Error::new(\n+        std_io::ErrorKind::Other,\n+        \"operation not supported on wasm yet\",\n+    )\n }\n \n-pub fn decode_error_kind(errno: i32) -> ErrorKind {\n-    match errno as libc::c_int {\n-        libc::ECONNREFUSED => ErrorKind::ConnectionRefused,\n-        libc::ECONNRESET => ErrorKind::ConnectionReset,\n-        libc::EPERM | libc::EACCES => ErrorKind::PermissionDenied,\n-        libc::EPIPE => ErrorKind::BrokenPipe,\n-        libc::ENOTCONN => ErrorKind::NotConnected,\n-        libc::ECONNABORTED => ErrorKind::ConnectionAborted,\n-        libc::EADDRNOTAVAIL => ErrorKind::AddrNotAvailable,\n-        libc::EADDRINUSE => ErrorKind::AddrInUse,\n-        libc::ENOENT => ErrorKind::NotFound,\n-        libc::EINTR => ErrorKind::Interrupted,\n-        libc::EINVAL => ErrorKind::InvalidInput,\n-        libc::ETIMEDOUT => ErrorKind::TimedOut,\n-        libc::EEXIST => ErrorKind::AlreadyExists,\n-        libc::EAGAIN => ErrorKind::WouldBlock,\n-        _ => ErrorKind::Other,\n+pub fn decode_error_kind(errno: i32) -> std_io::ErrorKind {\n+    use std_io::ErrorKind::*;\n+    if errno > u16::max_value() as i32 || errno < 0 {\n+        return Other;\n+    }\n+    let code = match wasi::Error::new(errno as u16) {\n+        Some(code) => code,\n+        None => return Other,\n+    };\n+    match code {\n+        wasi::ECONNREFUSED => ConnectionRefused,\n+        wasi::ECONNRESET => ConnectionReset,\n+        wasi::EPERM | wasi::EACCES => PermissionDenied,\n+        wasi::EPIPE => BrokenPipe,\n+        wasi::ENOTCONN => NotConnected,\n+        wasi::ECONNABORTED => ConnectionAborted,\n+        wasi::EADDRNOTAVAIL => AddrNotAvailable,\n+        wasi::EADDRINUSE => AddrInUse,\n+        wasi::ENOENT => NotFound,\n+        wasi::EINTR => Interrupted,\n+        wasi::EINVAL => InvalidInput,\n+        wasi::ETIMEDOUT => TimedOut,\n+        wasi::EEXIST => AlreadyExists,\n+        wasi::EAGAIN => WouldBlock,\n+        _ => Other,\n     }\n }\n \n@@ -105,40 +116,16 @@ pub unsafe fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut ret = (0u64, 0u64);\n     unsafe {\n-        let base = &mut ret as *mut (u64, u64) as *mut libc::c_void;\n+        let base = &mut ret as *mut (u64, u64) as *mut core::ffi::c_void;\n         let len = mem::size_of_val(&ret);\n-        cvt_wasi(libc::__wasi_random_get(base, len)).unwrap();\n-    }\n-    return ret\n-}\n-\n-#[doc(hidden)]\n-pub trait IsMinusOne {\n-    fn is_minus_one(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_minus_one {\n-    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n-        fn is_minus_one(&self) -> bool {\n-            *self == -1\n+        let ret = wasi::raw::__wasi_random_get(base, len);\n+        if ret != 0 {\n+            panic!(\"__wasi_random_get failure\")\n         }\n-    })*)\n-}\n-\n-impl_is_minus_one! { i8 i16 i32 i64 isize }\n-\n-pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(Error::last_os_error())\n-    } else {\n-        Ok(t)\n     }\n+    return ret\n }\n \n-pub fn cvt_wasi(r: u16) -> crate::io::Result<()> {\n-    if r != libc::__WASI_ESUCCESS {\n-        Err(Error::from_raw_os_error(r as i32))\n-    } else {\n-        Ok(())\n-    }\n+fn err2io(err: wasi::Error) -> std_io::Error {\n+    std_io::Error::from_raw_os_error(err.get() as i32)\n }"}, {"sha": "feee840782550cd81dff8d1050124b7d7e9d6dab", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -9,7 +9,7 @@ use crate::path::{self, PathBuf};\n use crate::ptr;\n use crate::str;\n use crate::sys::memchr;\n-use crate::sys::{cvt, unsupported, Void};\n+use crate::sys::{unsupported, Void};\n use crate::vec;\n \n #[cfg(not(target_feature = \"atomics\"))]\n@@ -28,16 +28,11 @@ pub fn errno() -> i32 {\n }\n \n pub fn error_string(errno: i32) -> String {\n-    extern {\n-        fn strerror_r(errnum: libc::c_int, buf: *mut libc::c_char,\n-                      buflen: libc::size_t) -> libc::c_int;\n-    }\n-\n     let mut buf = [0 as libc::c_char; 1024];\n \n     let p = buf.as_mut_ptr();\n     unsafe {\n-        if strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n+        if libc::strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n             panic!(\"strerror_r failure\");\n         }\n         str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n@@ -89,7 +84,6 @@ impl StdError for JoinPathsError {\n pub fn current_exe() -> io::Result<PathBuf> {\n     unsupported()\n }\n-\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -182,3 +176,26 @@ pub fn exit(code: i32) -> ! {\n pub fn getpid() -> u32 {\n     panic!(\"unsupported\");\n }\n+\n+#[doc(hidden)]\n+pub trait IsMinusOne {\n+    fn is_minus_one(&self) -> bool;\n+}\n+\n+macro_rules! impl_is_minus_one {\n+    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n+        fn is_minus_one(&self) -> bool {\n+            *self == -1\n+        }\n+    })*)\n+}\n+\n+impl_is_minus_one! { i8 i16 i32 i64 isize }\n+\n+fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n+    if t.is_minus_one() {\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(t)\n+    }\n+}"}, {"sha": "1c4d028b7618bf6230a73d9c5ac8eb7892196b29", "filename": "src/libstd/sys/wasi/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -4,14 +4,16 @@ use crate::io;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv<DefaultEnvKey>\n+    env: CommandEnv\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -38,7 +40,7 @@ impl Command {\n     pub fn arg(&mut self, _arg: &OsStr) {\n     }\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n "}, {"sha": "1d57b9922e5993770c828484e6d28916515164d4", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,8 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::libc;\n use crate::mem::ManuallyDrop;\n use crate::sys::fd::WasiFd;\n \n+use ::wasi::wasi_unstable as wasi;\n+\n pub struct Stdin;\n pub struct Stdout;\n pub struct Stderr;\n@@ -17,7 +18,7 @@ impl Stdin {\n     }\n \n     pub fn read_vectored(&self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDIN_FD) })\n             .read(data)\n     }\n }\n@@ -32,7 +33,7 @@ impl Stdout {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDOUT_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDOUT_FD) })\n             .write(data)\n     }\n \n@@ -51,7 +52,7 @@ impl Stderr {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDERR_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDERR_FD) })\n             .write(data)\n     }\n \n@@ -73,7 +74,7 @@ impl io::Write for Stderr {\n pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(libc::__WASI_EBADF as i32)\n+    err.raw_os_error() == Some(wasi::EBADF.get() as i32)\n }\n \n pub fn panic_output() -> Option<impl io::Write> {"}, {"sha": "28a504f19797496e8d30b9d43d700b2d19a5b724", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,10 +1,10 @@\n-use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n-use crate::sys::cvt;\n+use crate::mem;\n use crate::sys::{unsupported, Void};\n use crate::time::Duration;\n-use libc;\n+\n+use ::wasi::wasi_unstable as wasi;\n \n pub struct Thread(Void);\n \n@@ -19,28 +19,46 @@ impl Thread {\n     }\n \n     pub fn yield_now() {\n-        let ret = unsafe { libc::__wasi_sched_yield() };\n-        debug_assert_eq!(ret, 0);\n+        let ret = wasi::sched_yield();\n+        debug_assert_eq!(ret, Ok(()));\n     }\n \n     pub fn set_name(_name: &CStr) {\n         // nope\n     }\n \n     pub fn sleep(dur: Duration) {\n-        let mut secs = dur.as_secs();\n-        let mut nsecs = dur.subsec_nanos() as i32;\n-\n-        unsafe {\n-            while secs > 0 || nsecs > 0 {\n-                let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n-                    tv_nsec: nsecs,\n-                };\n-                secs -= ts.tv_sec as u64;\n-                cvt(libc::nanosleep(&ts, &mut ts)).unwrap();\n-                nsecs = 0;\n-            }\n+        let nanos = dur.as_nanos();\n+        assert!(nanos <= u64::max_value() as u128);\n+\n+        const CLOCK_ID: wasi::Userdata = 0x0123_45678;\n+\n+        let clock = wasi::raw::__wasi_subscription_u_clock_t {\n+            identifier: CLOCK_ID,\n+            clock_id: wasi::CLOCK_MONOTONIC,\n+            timeout: nanos as u64,\n+            precision: 0,\n+            flags: 0,\n+        };\n+\n+        let in_ = [wasi::Subscription {\n+            userdata: 0,\n+            type_: wasi::EVENTTYPE_CLOCK,\n+            u: wasi::raw::__wasi_subscription_u { clock: clock },\n+        }];\n+        let (res, event) = unsafe {\n+            let mut out: [wasi::Event; 1] = mem::zeroed();\n+            let res = wasi::poll_oneoff(&in_, &mut out);\n+            (res, out[0])\n+        };\n+        match (res, event) {\n+            (Ok(1), wasi::Event {\n+                userdata: CLOCK_ID,\n+                error: 0,\n+                type_: wasi::EVENTTYPE_CLOCK,\n+                ..\n+            }) => {}\n+            _ => panic!(\"thread::sleep(): unexpected result of poll_oneoff\"),\n         }\n     }\n "}, {"sha": "4394a22f9c233253cbcb8f8a323ecaeacf8b6f91", "filename": "src/libstd/sys/wasi/time.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,7 +1,5 @@\n use crate::time::Duration;\n-use crate::mem;\n-use crate::sys::cvt_wasi;\n-use libc;\n+use ::wasi::wasi_unstable as wasi;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -12,23 +10,19 @@ pub struct SystemTime(Duration);\n pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n fn current_time(clock: u32) -> Duration {\n-    unsafe {\n-        let mut ts = mem::zeroed();\n-        cvt_wasi(libc::__wasi_clock_time_get(\n-            clock,\n-            1, // precision... seems ignored though?\n-            &mut ts,\n-        )).unwrap();\n-        Duration::new(\n-            (ts / 1_000_000_000) as u64,\n-            (ts % 1_000_000_000) as u32,\n-        )\n-    }\n+    let ts = wasi::clock_time_get(\n+        clock,\n+        1, // precision... seems ignored though?\n+    ).unwrap();\n+    Duration::new(\n+        (ts / 1_000_000_000) as u64,\n+        (ts % 1_000_000_000) as u32,\n+    )\n }\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(current_time(libc::__WASI_CLOCK_MONOTONIC))\n+        Instant(current_time(wasi::CLOCK_MONOTONIC))\n     }\n \n     pub const fn zero() -> Instant {\n@@ -54,10 +48,10 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(current_time(libc::__WASI_CLOCK_REALTIME))\n+        SystemTime(current_time(wasi::CLOCK_REALTIME))\n     }\n \n-    pub fn from_wasi_timestamp(ts: libc::__wasi_timestamp_t) -> SystemTime {\n+    pub fn from_wasi_timestamp(ts: wasi::Timestamp) -> SystemTime {\n         SystemTime(Duration::from_nanos(ts))\n     }\n "}, {"sha": "edf933d10e07433f52f9ae280b89b1b7d16e5658", "filename": "src/libstd/sys/wasm/process.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -4,14 +4,16 @@ use crate::io;\n use crate::sys::fs::File;\n use crate::sys::pipe::AnonPipe;\n use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::{CommandEnv, DefaultEnvKey};\n+use crate::sys_common::process::CommandEnv;\n+\n+pub use crate::ffi::OsString as EnvKey;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    env: CommandEnv<DefaultEnvKey>\n+    env: CommandEnv,\n }\n \n // passed back to std::process with the pipes connected to the child, if any\n@@ -38,7 +40,7 @@ impl Command {\n     pub fn arg(&mut self, _arg: &OsStr) {\n     }\n \n-    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n "}, {"sha": "8658deb854635405a8d8665b6f7958e8b8885bdf", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -19,7 +19,7 @@ use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n-use crate::sys_common::process::{CommandEnv, EnvKey};\n+use crate::sys_common::process::CommandEnv;\n use crate::borrow::Borrow;\n \n use libc::{c_void, EXIT_SUCCESS, EXIT_FAILURE};\n@@ -30,30 +30,28 @@ use libc::{c_void, EXIT_SUCCESS, EXIT_FAILURE};\n \n #[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n #[doc(hidden)]\n-pub struct WindowsEnvKey(OsString);\n+pub struct EnvKey(OsString);\n \n-impl From<OsString> for WindowsEnvKey {\n+impl From<OsString> for EnvKey {\n     fn from(k: OsString) -> Self {\n         let mut buf = k.into_inner().into_inner();\n         buf.make_ascii_uppercase();\n-        WindowsEnvKey(FromInner::from_inner(FromInner::from_inner(buf)))\n+        EnvKey(FromInner::from_inner(FromInner::from_inner(buf)))\n     }\n }\n \n-impl From<WindowsEnvKey> for OsString {\n-    fn from(k: WindowsEnvKey) -> Self { k.0 }\n+impl From<EnvKey> for OsString {\n+    fn from(k: EnvKey) -> Self { k.0 }\n }\n \n-impl Borrow<OsStr> for WindowsEnvKey {\n+impl Borrow<OsStr> for EnvKey {\n     fn borrow(&self) -> &OsStr { &self.0 }\n }\n \n-impl AsRef<OsStr> for WindowsEnvKey {\n+impl AsRef<OsStr> for EnvKey {\n     fn as_ref(&self) -> &OsStr { &self.0 }\n }\n \n-impl EnvKey for WindowsEnvKey {}\n-\n \n fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n@@ -66,7 +64,7 @@ fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n pub struct Command {\n     program: OsString,\n     args: Vec<OsString>,\n-    env: CommandEnv<WindowsEnvKey>,\n+    env: CommandEnv,\n     cwd: Option<OsString>,\n     flags: u32,\n     detach: bool, // not currently exposed in std::process\n@@ -110,7 +108,7 @@ impl Command {\n     pub fn arg(&mut self, arg: &OsStr) {\n         self.args.push(arg.to_os_string())\n     }\n-    pub fn env_mut(&mut self) -> &mut CommandEnv<WindowsEnvKey> {\n+    pub fn env_mut(&mut self) -> &mut CommandEnv {\n         &mut self.env\n     }\n     pub fn cwd(&mut self, dir: &OsStr) {\n@@ -498,7 +496,7 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n     }\n }\n \n-fn make_envp(maybe_env: Option<BTreeMap<WindowsEnvKey, OsString>>)\n+fn make_envp(maybe_env: Option<BTreeMap<EnvKey, OsString>>)\n              -> io::Result<(*mut c_void, Vec<u16>)> {\n     // On Windows we pass an \"environment block\" which is not a char**, but\n     // rather a concatenation of null-terminated k=v\\0 sequences, with a final"}, {"sha": "bdf66fca35970bcc2da56803380f8c5a5f33d25f", "filename": "src/libstd/sys_common/process.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibstd%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fprocess.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,47 +1,20 @@\n #![allow(dead_code)]\n #![unstable(feature = \"process_internals\", issue = \"0\")]\n \n-use crate::ffi::{OsStr, OsString};\n-use crate::env;\n use crate::collections::BTreeMap;\n-use crate::borrow::Borrow;\n-\n-pub trait EnvKey:\n-    From<OsString> + Into<OsString> +\n-    Borrow<OsStr> + Borrow<Self> + AsRef<OsStr> +\n-    Ord + Clone {}\n-\n-// Implement a case-sensitive environment variable key\n-#[derive(Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]\n-pub struct DefaultEnvKey(OsString);\n-\n-impl From<OsString> for DefaultEnvKey {\n-    fn from(k: OsString) -> Self { DefaultEnvKey(k) }\n-}\n-\n-impl From<DefaultEnvKey> for OsString {\n-    fn from(k: DefaultEnvKey) -> Self { k.0 }\n-}\n-\n-impl Borrow<OsStr> for DefaultEnvKey {\n-    fn borrow(&self) -> &OsStr { &self.0 }\n-}\n-\n-impl AsRef<OsStr> for DefaultEnvKey {\n-    fn as_ref(&self) -> &OsStr { &self.0 }\n-}\n-\n-impl EnvKey for DefaultEnvKey {}\n+use crate::env;\n+use crate::ffi::{OsStr, OsString};\n+use crate::sys::process::EnvKey;\n \n // Stores a set of changes to an environment\n #[derive(Clone, Debug)]\n-pub struct CommandEnv<K> {\n+pub struct CommandEnv {\n     clear: bool,\n     saw_path: bool,\n-    vars: BTreeMap<K, Option<OsString>>\n+    vars: BTreeMap<EnvKey, Option<OsString>>\n }\n \n-impl<K: EnvKey> Default for CommandEnv<K> {\n+impl Default for CommandEnv {\n     fn default() -> Self {\n         CommandEnv {\n             clear: false,\n@@ -51,10 +24,10 @@ impl<K: EnvKey> Default for CommandEnv<K> {\n     }\n }\n \n-impl<K: EnvKey> CommandEnv<K> {\n+impl CommandEnv {\n     // Capture the current environment with these changes applied\n-    pub fn capture(&self) -> BTreeMap<K, OsString> {\n-        let mut result = BTreeMap::<K, OsString>::new();\n+    pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {\n+        let mut result = BTreeMap::<EnvKey, OsString>::new();\n         if !self.clear {\n             for (k, v) in env::vars_os() {\n                 result.insert(k.into(), v);\n@@ -90,7 +63,7 @@ impl<K: EnvKey> CommandEnv<K> {\n         !self.clear && self.vars.is_empty()\n     }\n \n-    pub fn capture_if_changed(&self) -> Option<BTreeMap<K, OsString>> {\n+    pub fn capture_if_changed(&self) -> Option<BTreeMap<EnvKey, OsString>> {\n         if self.is_unchanged() {\n             None\n         } else {\n@@ -103,6 +76,7 @@ impl<K: EnvKey> CommandEnv<K> {\n         self.maybe_saw_path(&key);\n         self.vars.insert(key.to_owned().into(), Some(value.to_owned()));\n     }\n+\n     pub fn remove(&mut self, key: &OsStr) {\n         self.maybe_saw_path(&key);\n         if self.clear {\n@@ -111,13 +85,16 @@ impl<K: EnvKey> CommandEnv<K> {\n             self.vars.insert(key.to_owned().into(), None);\n         }\n     }\n+\n     pub fn clear(&mut self) {\n         self.clear = true;\n         self.vars.clear();\n     }\n+\n     pub fn have_changed_path(&self) -> bool {\n         self.saw_path || self.clear\n     }\n+\n     fn maybe_saw_path(&mut self, key: &OsStr) {\n         if !self.saw_path && key == \"PATH\" {\n             self.saw_path = true;"}, {"sha": "c93e6d11ce711235829704edae3ca43d656db4bf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -561,29 +561,31 @@ impl Pat {\n         }))\n     }\n \n-    pub fn walk<F>(&self, it: &mut F) -> bool\n-    where\n-        F: FnMut(&Pat) -> bool,\n-    {\n+    /// Walk top-down and call `it` in each place where a pattern occurs\n+    /// starting with the root pattern `walk` is called on. If `it` returns\n+    /// false then we will descend no further but siblings will be processed.\n+    pub fn walk(&self, it: &mut impl FnMut(&Pat) -> bool) {\n         if !it(self) {\n-            return false;\n+            return;\n         }\n \n         match &self.node {\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n-            PatKind::Struct(_, fields, _) => fields.iter().all(|field| field.pat.walk(it)),\n+            PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n             PatKind::TupleStruct(_, s)\n             | PatKind::Tuple(s)\n             | PatKind::Slice(s)\n-            | PatKind::Or(s) => s.iter().all(|p| p.walk(it)),\n-            PatKind::Box(s) | PatKind::Ref(s, _) | PatKind::Paren(s) => s.walk(it),\n+            | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n+            PatKind::Box(s)\n+            | PatKind::Ref(s, _)\n+            | PatKind::Paren(s) => s.walk(it),\n             PatKind::Wild\n             | PatKind::Rest\n             | PatKind::Lit(_)\n             | PatKind::Range(..)\n             | PatKind::Ident(..)\n             | PatKind::Path(..)\n-            | PatKind::Mac(_) => true,\n+            | PatKind::Mac(_) => {},\n         }\n     }\n \n@@ -928,7 +930,7 @@ pub struct Local {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n-    pub pats: Vec<P<Pat>>,\n+    pub pat: P<Pat>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n     pub span: Span,\n@@ -1146,12 +1148,9 @@ pub enum ExprKind {\n     Cast(P<Expr>, P<Ty>),\n     /// A type ascription (e.g., `42: usize`).\n     Type(P<Expr>, P<Ty>),\n-    /// A `let pats = expr` expression that is only semantically allowed in the condition\n+    /// A `let pat = expr` expression that is only semantically allowed in the condition\n     /// of `if` / `while` expressions. (e.g., `if let 0 = x { .. }`).\n-    ///\n-    /// The `Vec<P<Pat>>` is for or-patterns at the top level.\n-    /// FIXME(54883): Change this to just `P<Pat>`.\n-    Let(Vec<P<Pat>>, P<Expr>),\n+    Let(P<Pat>, P<Expr>),\n     /// An `if` block, with an optional `else` block.\n     ///\n     /// `if expr { block } else { expr }`"}, {"sha": "dc6cbfcf6ad5c56f6c22eaa46f04b6a935013830", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -537,9 +537,9 @@ impl<'a> ExtCtxt<'a> {\n         let err_expr = self.expr(sp, ast::ExprKind::Ret(Some(err_inner_expr)));\n \n         // `Ok(__try_var) => __try_var`\n-        let ok_arm = self.arm(sp, vec![ok_pat], binding_expr);\n+        let ok_arm = self.arm(sp, ok_pat, binding_expr);\n         // `Err(__try_var) => return Err(__try_var)`\n-        let err_arm = self.arm(sp, vec![err_pat], err_expr);\n+        let err_arm = self.arm(sp, err_pat, err_expr);\n \n         // `match head { Ok() => ..., Err() => ... }`\n         self.expr_match(sp, head, vec![ok_arm, err_arm])\n@@ -606,10 +606,10 @@ impl<'a> ExtCtxt<'a> {\n         self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n-    pub fn arm(&self, span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {\n+    pub fn arm(&self, span: Span, pat: P<ast::Pat>, expr: P<ast::Expr>) -> ast::Arm {\n         ast::Arm {\n             attrs: vec![],\n-            pats,\n+            pat,\n             guard: None,\n             body: expr,\n             span,\n@@ -618,7 +618,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn arm_unreachable(&self, span: Span) -> ast::Arm {\n-        self.arm(span, vec![self.pat_wild(span)], self.expr_unreachable(span))\n+        self.arm(span, self.pat_wild(span), self.expr_unreachable(span))\n     }\n \n     pub fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {"}, {"sha": "6023c5149d05b5e6b53569f89a25bd02bec3a050", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -402,14 +402,11 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_flat_map_arm<T: MutVisitor>(\n-    mut arm: Arm,\n-    vis: &mut T,\n-) -> SmallVec<[Arm; 1]> {\n-    let Arm { attrs, pats, guard, body, span, id } = &mut arm;\n+pub fn noop_flat_map_arm<T: MutVisitor>(mut arm: Arm, vis: &mut T) -> SmallVec<[Arm; 1]> {\n+    let Arm { attrs, pat, guard, body, span, id } = &mut arm;\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n-    visit_vec(pats, |pat| vis.visit_pat(pat));\n+    vis.visit_pat(pat);\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n     vis.visit_span(span);\n@@ -1132,8 +1129,8 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n             vis.visit_ty(ty);\n         }\n         ExprKind::AddrOf(_m, ohs) => vis.visit_expr(ohs),\n-        ExprKind::Let(pats, scrutinee) => {\n-            visit_vec(pats, |pat| vis.visit_pat(pat));\n+        ExprKind::Let(pat, scrutinee) => {\n+            vis.visit_pat(pat);\n             vis.visit_expr(scrutinee);\n         }\n         ExprKind::If(cond, tr, fl) => {"}, {"sha": "3db9c899dba40f12696cf01649ad28721d55d17d", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1250,8 +1250,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_span;\n-        // FIXME(or_patterns, Centril | dlrobertson): use `parse_top_pat` instead.\n-        let pat = self.parse_top_pat_unpack(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(\n             Restrictions::NO_STRUCT_LITERAL,\n@@ -1393,8 +1392,7 @@ impl<'a> Parser<'a> {\n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        // FIXME(or_patterns, Centril | dlrobertson): use `parse_top_pat` instead.\n-        let pat = self.parse_top_pat_unpack(GateOr::No)?;\n+        let pat = self.parse_top_pat(GateOr::No)?;\n         let guard = if self.eat_keyword(kw::If) {\n             Some(self.parse_expr()?)\n         } else {\n@@ -1455,7 +1453,7 @@ impl<'a> Parser<'a> {\n \n         Ok(ast::Arm {\n             attrs,\n-            pats: pat, // FIXME(or_patterns, Centril | dlrobertson): this should just be `pat,`.\n+            pat,\n             guard,\n             body: expr,\n             span: lo.to(hi),"}, {"sha": "669f657160b3e75c8fef3297f23d2da0ff2e7ec4", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -36,16 +36,6 @@ impl<'a> Parser<'a> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n-    // FIXME(or_patterns, Centril | dlrobertson):\n-    // remove this and use `parse_top_pat` everywhere it is used instead.\n-    pub(super) fn parse_top_pat_unpack(&mut self, gate_or: GateOr) -> PResult<'a, Vec<P<Pat>>> {\n-        self.parse_top_pat(gate_or)\n-            .map(|pat| pat.and_then(|pat| match pat.node {\n-                PatKind::Or(pats) => pats,\n-                node => vec![self.mk_pat(pat.span, node)],\n-            }))\n-    }\n-\n     /// Entry point to the main pattern parser.\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n     pub(super) fn parse_top_pat(&mut self, gate_or: GateOr) -> PResult<'a, P<Pat>> {"}, {"sha": "6772bbce21b5039710c8298fc810dd0e3421d730", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1710,11 +1710,11 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Block(blk))\n     }\n \n-    /// Print a `let pats = scrutinee` expression.\n-    crate fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) {\n+    /// Print a `let pat = scrutinee` expression.\n+    crate fn print_let(&mut self, pat: &ast::Pat, scrutinee: &ast::Expr) {\n         self.s.word(\"let \");\n \n-        self.print_pats(pats);\n+        self.print_pat(pat);\n         self.s.space();\n \n         self.word_space(\"=\");\n@@ -2040,8 +2040,8 @@ impl<'a> State<'a> {\n                 self.word_space(\":\");\n                 self.print_type(ty);\n             }\n-            ast::ExprKind::Let(ref pats, ref scrutinee) => {\n-                self.print_let(pats, scrutinee);\n+            ast::ExprKind::Let(ref pat, ref scrutinee) => {\n+                self.print_let(pat, scrutinee);\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(test, blk, elseopt.as_ref().map(|e| &**e));\n@@ -2451,21 +2451,16 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    fn print_pats(&mut self, pats: &[P<ast::Pat>]) {\n-        self.strsep(\"|\", true, Inconsistent, pats, |s, p| s.print_pat(p));\n-    }\n-\n     fn print_arm(&mut self, arm: &ast::Arm) {\n-        // I have no idea why this check is necessary, but here it\n-        // is :(\n+        // I have no idea why this check is necessary, but here it is :(\n         if arm.attrs.is_empty() {\n             self.s.space();\n         }\n         self.cbox(INDENT_UNIT);\n         self.ibox(0);\n-        self.maybe_print_comment(arm.pats[0].span.lo());\n+        self.maybe_print_comment(arm.pat.span.lo());\n         self.print_outer_attributes(&arm.attrs);\n-        self.print_pats(&arm.pats);\n+        self.print_pat(&arm.pat);\n         self.s.space();\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\");"}, {"sha": "421c327aa414dc5b49556424b435b5f7b0bc3ee4", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -678,9 +678,8 @@ pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonCo\n }\n \n pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n-    for attr in expression.attrs.iter() {\n-        visitor.visit_attribute(attr);\n-    }\n+    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n+\n     match expression.node {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n@@ -719,8 +718,8 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ty(typ)\n         }\n-        ExprKind::Let(ref pats, ref scrutinee) => {\n-            walk_list!(visitor, visit_pat, pats);\n+        ExprKind::Let(ref pat, ref scrutinee) => {\n+            visitor.visit_pat(pat);\n             visitor.visit_expr(scrutinee);\n         }\n         ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n@@ -831,10 +830,10 @@ pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n }\n \n pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n-    walk_list!(visitor, visit_pat, &arm.pats);\n-    if let Some(ref e) = &arm.guard {\n-        visitor.visit_expr(e);\n-    }\n+    visitor.visit_pat(&arm.pat);\n+    // NOTE(or_patterns; Centril | dlrobertson):\n+    // If you change this, also change the hack in `lowering.rs`.\n+    walk_list!(visitor, visit_expr, &arm.guard);\n     visitor.visit_expr(&arm.body);\n     walk_list!(visitor, visit_attribute, &arm.attrs);\n }"}, {"sha": "1f4f5aa37099fb364ee7b694b180490590765b0d", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -95,11 +95,9 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n                     cx.expr_call_global(span, cmp_path.clone(), args)\n                 };\n \n-                let eq_arm = cx.arm(span,\n-                                    vec![cx.pat_path(span, equals_path.clone())],\n-                                    old);\n+                let eq_arm = cx.arm(span, cx.pat_path(span, equals_path.clone()), old);\n                 let neq_arm = cx.arm(span,\n-                                     vec![cx.pat_ident(span, test_id)],\n+                                     cx.pat_ident(span, test_id),\n                                      cx.expr_ident(span, test_id));\n \n                 cx.expr_match(span, new, vec![eq_arm, neq_arm])"}, {"sha": "debdc300e64955ebebf81864553cddd9d1a1759c", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -160,10 +160,10 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 };\n \n                 let eq_arm = cx.arm(span,\n-                                    vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n+                                    cx.pat_some(span, cx.pat_path(span, ordering.clone())),\n                                     old);\n                 let neq_arm = cx.arm(span,\n-                                    vec![cx.pat_ident(span, test_id)],\n+                                    cx.pat_ident(span, test_id),\n                                     cx.expr_ident(span, test_id));\n \n                 cx.expr_match(span, new, vec![eq_arm, neq_arm])"}, {"sha": "d3d604b72521d40112f1fa5370a3cd2face7fab9", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -119,9 +119,7 @@ fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                                                     vec![idx, exprdecode.clone()]))\n                 });\n \n-                arms.push(cx.arm(v_span,\n-                                 vec![cx.pat_lit(v_span, cx.expr_usize(v_span, i))],\n-                                 decoded));\n+                arms.push(cx.arm(v_span, cx.pat_lit(v_span, cx.expr_usize(v_span, i)), decoded));\n             }\n \n             arms.push(cx.arm_unreachable(trait_span));"}, {"sha": "893d89f06a16830859ce57631837e9bf51996b61", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1071,7 +1071,7 @@ impl<'a> MethodDef<'a> {\n         for (arg_expr, pat) in self_args.iter().zip(patterns) {\n             body = cx.expr_match(trait_.span,\n                                  arg_expr.clone(),\n-                                 vec![cx.arm(trait_.span, vec![pat.clone()], body)])\n+                                 vec![cx.arm(trait_.span, pat.clone(), body)])\n         }\n \n         body\n@@ -1311,7 +1311,7 @@ impl<'a> MethodDef<'a> {\n                                                              nonself_args,\n                                                              &substructure);\n \n-                cx.arm(sp, vec![single_pat], arm_expr)\n+                cx.arm(sp, single_pat, arm_expr)\n             })\n             .collect();\n \n@@ -1337,7 +1337,7 @@ impl<'a> MethodDef<'a> {\n             _ => None,\n         };\n         if let Some(arm) = default {\n-            match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], arm));\n+            match_arms.push(cx.arm(sp, cx.pat_wild(sp), arm));\n         }\n \n         // We will usually need the catch-all after matching the"}, {"sha": "e29f12c50c5263560a58671554096373273379b4", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec![pat], args_array);\n+        let arm = self.ecx.arm(self.fmtsp, pat, args_array);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n         let result = self.ecx.expr_match(self.fmtsp, head, vec![arm]);\n "}, {"sha": "e1a3256876bde15af94274c65d1ab29a71c6ce62", "filename": "src/test/rustdoc-js-std/vec-new.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -4,5 +4,6 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n         { 'path': 'std::vec::Vec', 'name': 'ne' },\n+        { 'path': 'std::rc::Rc', 'name': 'ne' },\n     ],\n };"}, {"sha": "b0a411bee5829921b8f1f57d11c9668a15f108f0", "filename": "src/test/rustdoc-js/exact-match.js", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fexact-match.js", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fexact-match.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fexact-match.js?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,9 @@\n+const QUERY = 'si::pc';\n+\n+const EXPECTED = {\n+    'others': [\n+        { 'path': 'exact_match::Si', 'name': 'pc' },\n+        { 'path': 'exact_match::Psi', 'name': 'pc' },\n+        { 'path': 'exact_match::Si', 'name': 'pa' },\n+    ],\n+};"}, {"sha": "2eacc0a358284f07a4dd63f0ddb9be58f6a8bbbe", "filename": "src/test/rustdoc-js/exact-match.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fexact-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fexact-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fexact-match.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,68 @@\n+macro_rules! imp {\n+    ($name:ident) => {\n+        pub struct $name {\n+            pub op: usize,\n+        }\n+        impl $name {\n+            pub fn op() {}\n+            pub fn cmp() {}\n+            pub fn map() {}\n+            pub fn pop() {}\n+            pub fn ptr() {}\n+            pub fn rpo() {}\n+            pub fn drop() {}\n+            pub fn copy() {}\n+            pub fn zip() {}\n+            pub fn sup() {}\n+            pub fn pa() {}\n+            pub fn pb() {}\n+            pub fn pc() {}\n+            pub fn pd() {}\n+            pub fn pe() {}\n+            pub fn pf() {}\n+            pub fn pg() {}\n+            pub fn ph() {}\n+            pub fn pi() {}\n+            pub fn pj() {}\n+            pub fn pk() {}\n+            pub fn pl() {}\n+            pub fn pm() {}\n+            pub fn pn() {}\n+            pub fn po() {}\n+        }\n+    };\n+    ($name:ident, $($names:ident),*) => {\n+        imp!($name);\n+        imp!($($names),*);\n+    };\n+}\n+macro_rules! en {\n+    ($name:ident) => {\n+        pub enum $name {\n+            Ptr,\n+            Rp,\n+            Rpo,\n+            Pt,\n+            Drop,\n+            Dr,\n+            Dro,\n+            Sup,\n+            Op,\n+            Cmp,\n+            Map,\n+            Mp,\n+        }\n+    };\n+    ($name:ident, $($names:ident),*) => {\n+        en!($name);\n+        en!($($names),*);\n+    };\n+}\n+\n+imp!(Ot, Foo, Cmp, Map, Loc, Lac, Toc, Si, Sig, Sip, Psy, Psi, Py, Pi, Pa, Pb, Pc, Pd);\n+imp!(Pe, Pf, Pg, Ph, Pj, Pk, Pl, Pm, Pn, Po, Pq, Pr, Ps, Pt, Pu, Pv, Pw, Px, Pz, Ap, Bp, Cp);\n+imp!(Dp, Ep, Fp, Gp, Hp, Ip, Jp, Kp, Lp, Mp, Np, Op, Pp, Qp, Rp, Sp, Tp, Up, Vp, Wp, Xp, Yp, Zp);\n+\n+en!(Place, Plac, Plae, Plce, Pace, Scalar, Scalr, Scaar, Sclar, Salar);\n+\n+pub struct P;"}, {"sha": "a446c39ebad57cdc05bb311e2f8614d32c672c90", "filename": "src/test/rustdoc-js/module-substring.js", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fmodule-substring.js", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fmodule-substring.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fmodule-substring.js?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,9 @@\n+const QUERY = 'ig::pc';\n+\n+const EXPECTED = {\n+    'others': [\n+        { 'path': 'module_substring::Sig', 'name': 'pc' },\n+        { 'path': 'module_substring::Si', 'name': 'pc' },\n+        { 'path': 'module_substring::Si', 'name': 'pa' },\n+    ],\n+};"}, {"sha": "2eacc0a358284f07a4dd63f0ddb9be58f6a8bbbe", "filename": "src/test/rustdoc-js/module-substring.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fmodule-substring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fmodule-substring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fmodule-substring.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,68 @@\n+macro_rules! imp {\n+    ($name:ident) => {\n+        pub struct $name {\n+            pub op: usize,\n+        }\n+        impl $name {\n+            pub fn op() {}\n+            pub fn cmp() {}\n+            pub fn map() {}\n+            pub fn pop() {}\n+            pub fn ptr() {}\n+            pub fn rpo() {}\n+            pub fn drop() {}\n+            pub fn copy() {}\n+            pub fn zip() {}\n+            pub fn sup() {}\n+            pub fn pa() {}\n+            pub fn pb() {}\n+            pub fn pc() {}\n+            pub fn pd() {}\n+            pub fn pe() {}\n+            pub fn pf() {}\n+            pub fn pg() {}\n+            pub fn ph() {}\n+            pub fn pi() {}\n+            pub fn pj() {}\n+            pub fn pk() {}\n+            pub fn pl() {}\n+            pub fn pm() {}\n+            pub fn pn() {}\n+            pub fn po() {}\n+        }\n+    };\n+    ($name:ident, $($names:ident),*) => {\n+        imp!($name);\n+        imp!($($names),*);\n+    };\n+}\n+macro_rules! en {\n+    ($name:ident) => {\n+        pub enum $name {\n+            Ptr,\n+            Rp,\n+            Rpo,\n+            Pt,\n+            Drop,\n+            Dr,\n+            Dro,\n+            Sup,\n+            Op,\n+            Cmp,\n+            Map,\n+            Mp,\n+        }\n+    };\n+    ($name:ident, $($names:ident),*) => {\n+        en!($name);\n+        en!($($names),*);\n+    };\n+}\n+\n+imp!(Ot, Foo, Cmp, Map, Loc, Lac, Toc, Si, Sig, Sip, Psy, Psi, Py, Pi, Pa, Pb, Pc, Pd);\n+imp!(Pe, Pf, Pg, Ph, Pj, Pk, Pl, Pm, Pn, Po, Pq, Pr, Ps, Pt, Pu, Pv, Pw, Px, Pz, Ap, Bp, Cp);\n+imp!(Dp, Ep, Fp, Gp, Hp, Ip, Jp, Kp, Lp, Mp, Np, Op, Pp, Qp, Rp, Sp, Tp, Up, Vp, Wp, Xp, Yp, Zp);\n+\n+en!(Place, Plac, Plae, Plce, Pace, Scalar, Scalr, Scaar, Sclar, Salar);\n+\n+pub struct P;"}, {"sha": "d14672af71fd6b714d3107b68c04ee16bd130d71", "filename": "src/test/rustdoc-js/search-short-types.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.js", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.js?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -3,6 +3,8 @@ const QUERY = 'P';\n const EXPECTED = {\n     'others': [\n         { 'path': 'search_short_types', 'name': 'P' },\n+        { 'path': 'search_short_types::VeryLongTypeName', 'name': 'p' },\n         { 'path': 'search_short_types', 'name': 'Ap' },\n+        { 'path': 'search_short_types::VeryLongTypeName', 'name': 'ap' },\n     ],\n };"}, {"sha": "a4083f9a76401897190efbe3c0086954d5b9622d", "filename": "src/test/rustdoc-js/search-short-types.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fsearch-short-types.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -66,3 +66,9 @@ imp!(Dp, Ep, Fp, Gp, Hp, Ip, Jp, Kp, Lp, Mp, Np, Op, Pp, Qp, Rp, Sp, Tp, Up, Vp,\n en!(Place, Plac, Plae, Plce, Pace, Scalar, Scalr, Scaar, Sclar, Salar);\n \n pub struct P;\n+\n+pub struct VeryLongTypeName;\n+impl VeryLongTypeName {\n+    pub fn p() {}\n+    pub fn ap() {}\n+}"}, {"sha": "b4c154e5d95f7d6d1f033fc792162ae058d32181", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -150,12 +150,12 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n             },\n             19 => {\n-                let ps = vec![P(Pat {\n+                let pat = P(Pat {\n                     id: DUMMY_NODE_ID,\n                     node: PatKind::Wild,\n                     span: DUMMY_SP,\n-                })];\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(ps.clone(), e)))\n+                });\n+                iter_exprs(depth - 1, &mut |e| g(ExprKind::Let(pat.clone(), e)))\n             },\n             _ => panic!(\"bad counter value in iter_exprs\"),\n         }"}, {"sha": "d04e494c2585c0e8b342b1d5cea5b1e364bd61d9", "filename": "src/test/ui/error-codes/E0023.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0023.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,18 +1,27 @@\n error[E0023]: this pattern has 1 field, but the corresponding tuple variant has 2 fields\n   --> $DIR/E0023.rs:10:9\n    |\n+LL |     Apple(String, String),\n+   |     --------------------- tuple variant defined here\n+...\n LL |         Fruit::Apple(a) => {},\n    |         ^^^^^^^^^^^^^^^ expected 2 fields, found 1\n \n error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n   --> $DIR/E0023.rs:11:9\n    |\n+LL |     Apple(String, String),\n+   |     --------------------- tuple variant defined here\n+...\n LL |         Fruit::Apple(a, b, c) => {},\n    |         ^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n \n error[E0023]: this pattern has 2 fields, but the corresponding tuple variant has 1 field\n   --> $DIR/E0023.rs:12:9\n    |\n+LL |     Pear(u32),\n+   |     --------- tuple variant defined here\n+...\n LL |         Fruit::Pear(1, 2) => {},\n    |         ^^^^^^^^^^^^^^^^^ expected 1 field, found 2\n "}, {"sha": "1d8cce522811682ac264b712c2d275ac288db584", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -33,10 +33,8 @@ fn or_patterns_no_lint() {\n     if let &mut (0 | 1) = &mut 0 {} // Same.\n \n     fn foo((Ok(a) | Err(a)): Result<u8, u8>) {} // Doesn't parse if we remove parens for now.\n-    //~^ ERROR identifier `a` is bound more than once\n \n     let _ = |(Ok(a) | Err(a)): Result<u8, u8>| 1; // `|Ok(a) | Err(a)| 1` parses as bit-or.\n-    //~^ ERROR identifier `a` is bound more than once\n }\n \n fn or_patterns_will_lint() {"}, {"sha": "7d5e286416fe262b58f01617aab248c7a4b0cba0", "filename": "src/test/ui/lint/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-54538-unused-parens-lint.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,15 +1,3 @@\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:35:25\n-   |\n-LL |     fn foo((Ok(a) | Err(a)): Result<u8, u8>) {} // Doesn't parse if we remove parens for now.\n-   |                         ^ used in a pattern more than once\n-\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:38:27\n-   |\n-LL |     let _ = |(Ok(a) | Err(a)): Result<u8, u8>| 1; // `|Ok(a) | Err(a)| 1` parses as bit-or.\n-   |                           ^ used in a pattern more than once\n-\n warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n   --> $DIR/issue-54538-unused-parens-lint.rs:3:12\n    |\n@@ -61,113 +49,112 @@ LL |     let _ = |(a): u8| 0;\n    |              ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:43:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:41:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:44:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:42:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:45:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:43:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:46:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:44:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:48:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:46:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:50:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:48:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:60:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:58:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:59:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:62:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:60:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:63:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:61:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:69:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:67:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:70:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:68:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:81:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:79:9\n    |\n LL |         (_) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:80:9\n    |\n LL |         (y) => {}\n    |         ^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:83:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:81:9\n    |\n LL |         (ref r) => {}\n    |         ^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:84:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:90:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:88:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^^^^^^^^^^^^^^ help: remove these parentheses\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:91:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:89:10\n    |\n LL |         &(_) => {}\n    |          ^^^ help: remove these parentheses\n \n-error: aborting due to 26 previous errors\n+error: aborting due to 24 previous errors\n \n-For more information about this error, try `rustc --explain E0416`."}, {"sha": "c2298d6fbbf02a34dc50bc17df8b46781a5f3669", "filename": "src/test/ui/match/match-pattern-field-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-pattern-field-mismatch.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,6 +1,9 @@\n error[E0023]: this pattern has 2 fields, but the corresponding tuple variant has 3 fields\n   --> $DIR/match-pattern-field-mismatch.rs:10:11\n    |\n+LL |         Rgb(usize, usize, usize),\n+   |         ------------------------ tuple variant defined here\n+...\n LL |           Color::Rgb(_, _) => { }\n    |           ^^^^^^^^^^^^^^^^ expected 3 fields, found 2\n "}, {"sha": "3ebf59c643735f9dd6570dc56b208d8690f2c31d", "filename": "src/test/ui/or-patterns/already-bound-name.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,46 @@\n+// This test ensures that the \"already bound identifier in a product pattern\"\n+// correctly accounts for or-patterns.\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+enum E<T> { A(T, T), B(T) }\n+\n+use E::*;\n+\n+fn main() {\n+    let (a, a) = (0, 1); // Standard duplication without an or-pattern.\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let (A(a, _) | B(a), a) = (A(0, 1), 2);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let A(a, a) | B(a) = A(0, 1);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    let B(a) | A(a, a) = A(0, 1);\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+\n+    match A(0, 1) {\n+        B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n+        //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    }\n+\n+    let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR mismatched types\n+\n+    let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR variable `a` is not bound in all patterns\n+\n+    let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+    //~^ ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR identifier `a` is bound more than once in the same pattern\n+}"}, {"sha": "360699a8739384661db650427a08400aea2f9d8c", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,105 @@\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:12:13\n+   |\n+LL |     let (a, a) = (0, 1); // Standard duplication without an or-pattern.\n+   |             ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:15:15\n+   |\n+LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+   |               ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:15:25\n+   |\n+LL |     let (a, A(a, _) | B(a)) = (0, A(1, 2));\n+   |                         ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:19:26\n+   |\n+LL |     let (A(a, _) | B(a), a) = (A(0, 1), 2);\n+   |                          ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:22:14\n+   |\n+LL |     let A(a, a) | B(a) = A(0, 1);\n+   |              ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:25:21\n+   |\n+LL |     let B(a) | A(a, a) = A(0, 1);\n+   |                     ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:29:21\n+   |\n+LL |         B(a) | A(a, a) => {} // Let's ensure `match` has no funny business.\n+   |                     ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:33:36\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                                    ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:33:46\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                                              ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:38:36\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                    ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:38:46\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                              ^ used in a pattern more than once\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/already-bound-name.rs:38:9\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |         ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:43:49\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                                 ^ used in a pattern more than once\n+\n+error[E0416]: identifier `a` is bound more than once in the same pattern\n+  --> $DIR/already-bound-name.rs:43:59\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |                                                           ^ used in a pattern more than once\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/already-bound-name.rs:4:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/already-bound-name.rs:33:31\n+   |\n+LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n+   |                               ^ expected integer, found enum `E`\n+   |\n+   = note: expected type `{integer}`\n+              found type `E<{integer}>`\n+\n+error: aborting due to 15 previous errors\n+\n+Some errors have detailed explanations: E0308, E0408, E0416.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "0eb539dca4cba86540957d90630c98df19d92b9a", "filename": "src/test/ui/or-patterns/consistent-bindings.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,46 @@\n+// Check that or-patterns with consistent bindings across arms are allowed.\n+\n+// edition:2018\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+fn main() {\n+    // One level:\n+    let Ok(a) | Err(a) = Ok(0);\n+    let Ok(ref a) | Err(ref a) = Ok(0);\n+    let Ok(ref mut a) | Err(ref mut a) = Ok(0);\n+\n+    // Two levels:\n+    enum Tri<S, T, U> { V1(S), V2(T), V3(U) }\n+    use Tri::*;\n+\n+    let Ok((V1(a) | V2(a) | V3(a), b)) | Err(Ok((a, b)) | Err((a, b)))\n+        : Result<_, Result<_, _>>\n+        = Ok((V1(1), 1));\n+\n+    let Ok((V1(a) | V2(a) | V3(a), ref b)) | Err(Ok((a, ref b)) | Err((a, ref b)))\n+        : Result<_, Result<_, _>>\n+        = Ok((V1(1), 1));\n+\n+    // Three levels:\n+    let (\n+            a,\n+            Err((ref mut b, ref c, d)) |\n+            Ok((\n+                Ok(\n+                    V1((ref c, d)) |\n+                    V2((d, ref c)) |\n+                    V3((ref c, Ok((_, d)) | Err((d, _))))\n+                ) |\n+                Err((ref c, d)),\n+                ref mut b\n+            ))\n+        ) =\n+        (1, Ok((Ok(V3((1, Ok((1, 1))))), 1)));\n+\n+    // FIXME(or_patterns; Centril | dlrobertson): remove this line below and\n+    // change this test to check-pass once MIR can handle or-patterns with bindings.\n+    let () = 0;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "7f5e670c257ce1673d60e04b7d7d7f63ef2376db", "filename": "src/test/ui/or-patterns/consistent-bindings.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fconsistent-bindings.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/consistent-bindings.rs:5:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/consistent-bindings.rs:44:9\n+   |\n+LL |     let () = 0;\n+   |         ^^ expected integer, found ()\n+   |\n+   = note: expected type `{integer}`\n+              found type `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "44836893ea2b2b19b2054d16254eda01eec53a26", "filename": "src/test/ui/or-patterns/inconsistent-modes.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,28 @@\n+// This test ensures that or patterns require binding mode consistency across arms.\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+#![allow(non_camel_case_types)]\n+fn main() {\n+    // One level:\n+    let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    //~| ERROR mismatched types\n+    let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+    //~| ERROR variable `b` is bound in inconsistent ways\n+    //~| ERROR mismatched types\n+\n+    // Two levels:\n+    let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+\n+    // Three levels:\n+    let Ok([ Ok((Ok(ref a) | Err(a),)) | Err(a) ]) | Err(a) = Err(&1);\n+    //~^ ERROR variable `a` is bound in inconsistent ways\n+}"}, {"sha": "0a36ed5548e5b7f6e3a04d5a4960fa5944ce938e", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,80 @@\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:9:25\n+   |\n+LL |     let Ok(a) | Err(ref a): Result<&u8, u8> = Ok(&0);\n+   |            -            ^ bound in different ways\n+   |            |\n+   |            first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:11:29\n+   |\n+LL |     let Ok(ref mut a) | Err(a): Result<u8, &mut u8> = Ok(0);\n+   |                    -        ^ bound in different ways\n+   |                    |\n+   |                    first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:13:33\n+   |\n+LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+   |                - first binding  ^ bound in different ways\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:16:39\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                 - first binding       ^ bound in different ways\n+\n+error[E0409]: variable `b` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:16:46\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                    - first binding           ^ bound in different ways\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:22:38\n+   |\n+LL |     let Ok(Ok(a) | Err(a)) | Err(ref a) = Err(0);\n+   |                        -             ^ bound in different ways\n+   |                        |\n+   |                        first binding\n+\n+error[E0409]: variable `a` is bound in inconsistent ways within the same match arm\n+  --> $DIR/inconsistent-modes.rs:26:34\n+   |\n+LL |     let Ok([ Ok((Ok(ref a) | Err(a),)) | Err(a) ]) | Err(a) = Err(&1);\n+   |                         -        ^ bound in different ways\n+   |                         |\n+   |                         first binding\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/inconsistent-modes.rs:3:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/inconsistent-modes.rs:13:25\n+   |\n+LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n+   |                         ^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected type `&&u8`\n+              found type `&mut &mut u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/inconsistent-modes.rs:16:31\n+   |\n+LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n+   |                               ^^^^^^^^^ types differ in mutability\n+   |\n+   = note: expected type `&{integer}`\n+              found type `&mut _`\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0308, E0409.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "b065028e7a5a4521011c90a84d95b4d469301d9c", "filename": "src/test/ui/or-patterns/missing-bindings.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,84 @@\n+// This test ensures that or patterns do not allow missing bindings in any of the arms.\n+\n+// edition:2018\n+\n+#![feature(or_patterns)]\n+//~^ WARN the feature `or_patterns` is incomplete\n+\n+#![allow(non_camel_case_types)]\n+\n+fn main() {}\n+\n+fn check_handling_of_paths() {\n+    mod bar {\n+        pub enum foo {\n+            alpha,\n+            beta,\n+            charlie\n+        }\n+    }\n+\n+    use bar::foo::{alpha, charlie};\n+    let alpha | beta | charlie = alpha; //~  ERROR variable `beta` is not bound in all patterns\n+    match Some(alpha) {\n+        Some(alpha | beta) => {} //~ ERROR variable `beta` is not bound in all patterns\n+    }\n+}\n+\n+fn check_misc_nesting() {\n+    enum E<T> { A(T, T), B(T) }\n+    use E::*;\n+    enum Vars3<S, T, U> { V1(S), V2(T), V3(U) }\n+    use Vars3::*;\n+\n+    // One level:\n+    const X: E<u8> = B(0);\n+    let A(a, _) | _ = X; //~ ERROR variable `a` is not bound in all patterns\n+    let _ | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(..) | B(a) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(a, _) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(_, a) | B(_) = X; //~ ERROR variable `a` is not bound in all patterns\n+    let A(a, b) | B(a) = X; //~ ERROR variable `b` is not bound in all patterns\n+\n+    // Two levels:\n+    const Y: E<E<u8>> = B(B(0));\n+    let A(A(..) | B(_), _) | B(a) = Y; //~ ERROR variable `a` is not bound in all patterns\n+    let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n+    //~^ ERROR variable `a` is not bound in all patterns\n+    let A(A(a, b) | B(c), d) | B(e) = Y;\n+    //~^ ERROR variable `a` is not bound in all patterns\n+    //~| ERROR variable `a` is not bound in all patterns\n+    //~| ERROR variable `b` is not bound in all patterns\n+    //~| ERROR variable `b` is not bound in all patterns\n+    //~| ERROR variable `c` is not bound in all patterns\n+    //~| ERROR variable `c` is not bound in all patterns\n+    //~| ERROR variable `d` is not bound in all patterns\n+    //~| ERROR variable `e` is not bound in all patterns\n+\n+    // Three levels:\n+    let (\n+            V1(\n+            //~^ ERROR variable `b` is not bound in all patterns\n+            //~| ERROR variable `c` is not bound in all patterns\n+                A(\n+                    Ok(a) | Err(_), //~ ERROR variable `a` is not bound in all patterns\n+                    _\n+                ) |\n+                B(Ok(a) | Err(a))\n+            ) |\n+            V2(\n+                A(\n+                    A(_, a) | //~ ERROR variable `b` is not bound in all patterns\n+                    B(b), //~ ERROR variable `a` is not bound in all patterns\n+                    _\n+                ) |\n+                B(_)\n+                //~^ ERROR variable `a` is not bound in all patterns\n+                //~| ERROR variable `b` is not bound in all patterns\n+            ) |\n+            V3(c),\n+            //~^ ERROR variable `a` is not bound in all patterns\n+        )\n+        : (Vars3<E<Result<u8, u8>>, E<E<u8>>, u8>,)\n+        = (V3(0),);\n+}"}, {"sha": "c73af7a42eec0c8a11030beaa1bade5476dd49a3", "filename": "src/test/ui/or-patterns/missing-bindings.stderr", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -0,0 +1,250 @@\n+error[E0408]: variable `beta` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:22:9\n+   |\n+LL |     let alpha | beta | charlie = alpha;\n+   |         ^^^^^   ----   ^^^^^^^ pattern doesn't bind `beta`\n+   |         |       |\n+   |         |       variable not in all patterns\n+   |         pattern doesn't bind `beta`\n+\n+error[E0408]: variable `beta` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:24:14\n+   |\n+LL |         Some(alpha | beta) => {}\n+   |              ^^^^^   ---- variable not in all patterns\n+   |              |\n+   |              pattern doesn't bind `beta`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:36:19\n+   |\n+LL |     let A(a, _) | _ = X;\n+   |           -       ^ pattern doesn't bind `a`\n+   |           |\n+   |           variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:37:9\n+   |\n+LL |     let _ | B(a) = X;\n+   |         ^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:38:9\n+   |\n+LL |     let A(..) | B(a) = X;\n+   |         ^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:39:19\n+   |\n+LL |     let A(a, _) | B(_) = X;\n+   |           -       ^^^^ pattern doesn't bind `a`\n+   |           |\n+   |           variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:40:19\n+   |\n+LL |     let A(_, a) | B(_) = X;\n+   |              -    ^^^^ pattern doesn't bind `a`\n+   |              |\n+   |              variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:41:19\n+   |\n+LL |     let A(a, b) | B(a) = X;\n+   |              -    ^^^^ pattern doesn't bind `b`\n+   |              |\n+   |              variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:45:9\n+   |\n+LL |     let A(A(..) | B(_), _) | B(a) = Y;\n+   |         ^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:46:11\n+   |\n+LL |     let A(A(..) | B(a), _) | B(A(a, _) | B(a)) = Y;\n+   |           ^^^^^     - variable not in all patterns\n+   |           |\n+   |           pattern doesn't bind `a`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:21\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |             -       ^^^^ pattern doesn't bind `a`\n+   |             |\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:21\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                -    ^^^^ pattern doesn't bind `b`\n+   |                |\n+   |                variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:11\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |           ^^^^^^^     - variable not in all patterns\n+   |           |\n+   |           pattern doesn't bind `c`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |             -                  ^^^^ pattern doesn't bind `a`\n+   |             |\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                -               ^^^^ pattern doesn't bind `b`\n+   |                |\n+   |                variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                       -        ^^^^ pattern doesn't bind `c`\n+   |                       |\n+   |                       variable not in all patterns\n+\n+error[E0408]: variable `d` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:32\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |                           -    ^^^^ pattern doesn't bind `d`\n+   |                           |\n+   |                           variable not in all patterns\n+\n+error[E0408]: variable `e` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:48:9\n+   |\n+LL |     let A(A(a, b) | B(c), d) | B(e) = Y;\n+   |         ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `e`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:64:29\n+   |\n+LL |                     Ok(a) | Err(_),\n+   |                        -    ^^^^^^ pattern doesn't bind `a`\n+   |                        |\n+   |                        variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:72:21\n+   |\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+LL |                     B(b),\n+   |                     ^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:71:21\n+   |\n+LL |                     A(_, a) |\n+   |                     ^^^^^^^ pattern doesn't bind `b`\n+LL |                     B(b),\n+   |                       - variable not in all patterns\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:75:17\n+   |\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+...\n+LL |                 B(_)\n+   |                 ^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:75:17\n+   |\n+LL |                     B(b),\n+   |                       - variable not in all patterns\n+...\n+LL |                 B(_)\n+   |                 ^^^^ pattern doesn't bind `b`\n+\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:79:13\n+   |\n+LL |                 B(Ok(a) | Err(a))\n+   |                               - variable not in all patterns\n+...\n+LL |                     A(_, a) |\n+   |                          - variable not in all patterns\n+...\n+LL |             V3(c),\n+   |             ^^^^^ pattern doesn't bind `a`\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:60:13\n+   |\n+LL | /             V1(\n+LL | |\n+LL | |\n+LL | |                 A(\n+...  |\n+LL | |                 B(Ok(a) | Err(a))\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `b`\n+...\n+LL |                       B(b),\n+   |                         - variable not in all patterns\n+...\n+LL |               V3(c),\n+   |               ^^^^^ pattern doesn't bind `b`\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:60:13\n+   |\n+LL | /             V1(\n+LL | |\n+LL | |\n+LL | |                 A(\n+...  |\n+LL | |                 B(Ok(a) | Err(a))\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `c`\n+LL | /             V2(\n+LL | |                 A(\n+LL | |                     A(_, a) |\n+LL | |                     B(b),\n+...  |\n+LL | |\n+LL | |             ) |\n+   | |_____________^ pattern doesn't bind `c`\n+LL |               V3(c),\n+   |                  - variable not in all patterns\n+\n+warning: the feature `or_patterns` is incomplete and may cause the compiler to crash\n+  --> $DIR/missing-bindings.rs:5:12\n+   |\n+LL | #![feature(or_patterns)]\n+   |            ^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error: aborting due to 26 previous errors\n+\n+For more information about this error, try `rustc --explain E0408`."}, {"sha": "e64b6efb08da8fabcdd34ae064e9d05608b8faef", "filename": "src/test/ui/pattern/pat-tuple-overfield.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-tuple-overfield.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -19,12 +19,18 @@ LL |         (1, 2, .., 3, 4) => {}\n error[E0023]: this pattern has 4 fields, but the corresponding tuple struct has 3 fields\n   --> $DIR/pat-tuple-overfield.rs:10:9\n    |\n+LL | struct S(u8, u8, u8);\n+   | --------------------- tuple struct defined here\n+...\n LL |         S(1, 2, 3, 4) => {}\n    |         ^^^^^^^^^^^^^ expected 3 fields, found 4\n \n error[E0023]: this pattern has 4 fields, but the corresponding tuple struct has 3 fields\n   --> $DIR/pat-tuple-overfield.rs:12:9\n    |\n+LL | struct S(u8, u8, u8);\n+   | --------------------- tuple struct defined here\n+...\n LL |         S(1, 2, .., 3, 4) => {}\n    |         ^^^^^^^^^^^^^^^^^ expected 3 fields, found 4\n "}, {"sha": "4fbc630644baa5854bee04812f7fb6c39acc1b23", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -15,6 +15,9 @@ LL |         A::D(_) => (),\n error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n   --> $DIR/pattern-error-continue.rs:17:9\n    |\n+LL |     B(isize, isize),\n+   |     --------------- tuple variant defined here\n+...\n LL |         A::B(_, _, _) => (),\n    |         ^^^^^^^^^^^^^ expected 2 fields, found 3\n "}, {"sha": "1c51653db6abfeaec21385424ae7186e6011522f", "filename": "src/test/ui/shadowed/shadowing-in-the-same-pattern.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowing-in-the-same-pattern.stderr?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -1,8 +1,8 @@\n-error[E0416]: identifier `a` is bound more than once in the same pattern\n+error[E0415]: identifier `a` is bound more than once in this parameter list\n   --> $DIR/shadowing-in-the-same-pattern.rs:3:10\n    |\n LL | fn f((a, a): (isize, isize)) {}\n-   |          ^ used in a pattern more than once\n+   |          ^ used as parameter more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n   --> $DIR/shadowing-in-the-same-pattern.rs:6:13\n@@ -12,4 +12,5 @@ LL |     let (a, a) = (1, 1);\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0416`.\n+Some errors have detailed explanations: E0415, E0416.\n+For more information about an error, try `rustc --explain E0415`."}, {"sha": "1ed39f45d3e701ab7f97a72444dbb62557428532", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fb3c4ec7ca37d33bd1e68cce669d171c2752615/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=1fb3c4ec7ca37d33bd1e68cce669d171c2752615", "patch": "@@ -15,6 +15,7 @@ const LICENSES: &[&str] = &[\n     \"Apache-2.0 / MIT\",\n     \"MIT OR Apache-2.0\",\n     \"Apache-2.0 OR MIT\",\n+    \"Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT\", // wasi license\n     \"MIT\",\n     \"Unlicense/MIT\",\n     \"Unlicense OR MIT\",\n@@ -172,6 +173,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"vcpkg\"),\n     Crate(\"version_check\"),\n     Crate(\"void\"),\n+    Crate(\"wasi\"),\n     Crate(\"winapi\"),\n     Crate(\"winapi-build\"),\n     Crate(\"winapi-i686-pc-windows-gnu\"),"}]}