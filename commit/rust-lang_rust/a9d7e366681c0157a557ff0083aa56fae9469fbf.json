{"sha": "a9d7e366681c0157a557ff0083aa56fae9469fbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZDdlMzY2NjgxYzAxNTdhNTU3ZmYwMDgzYWE1NmZhZTk0NjlmYmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T14:19:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-06T14:19:19Z"}, "message": "Fix numerous typos, renamings, and minor nits raised by mw.", "tree": {"sha": "93cbc04f48446c8f6ccb54ffea834537cdf60cdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93cbc04f48446c8f6ccb54ffea834537cdf60cdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9d7e366681c0157a557ff0083aa56fae9469fbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d7e366681c0157a557ff0083aa56fae9469fbf", "html_url": "https://github.com/rust-lang/rust/commit/a9d7e366681c0157a557ff0083aa56fae9469fbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9d7e366681c0157a557ff0083aa56fae9469fbf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11c671b59ce0161be5835b5195729f0df5e024f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c671b59ce0161be5835b5195729f0df5e024f5", "html_url": "https://github.com/rust-lang/rust/commit/11c671b59ce0161be5835b5195729f0df5e024f5"}], "stats": {"total": 64, "additions": 35, "deletions": 29}, "files": [{"sha": "21742d9935dc2d8b3ff2f937db958b46fd247218", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -123,7 +123,7 @@ However, you should rarely need to invoke those methods directly.\n Instead, the idea is to *encapsulate* shared state into some API that\n will invoke `read` and `write` automatically. The most common way to\n do this is to use a `DepTrackingMap`, described in the next section,\n-but any sort of abstraction brarier will do. In general, the strategy\n+but any sort of abstraction barrier will do. In general, the strategy\n is that getting access to information implicitly adds an appropriate\n `read`. So, for example, when you use the\n `dep_graph::visit_all_items_in_krate` helper method, it will visit\n@@ -197,7 +197,7 @@ from/to the node `DepNode::Variant(K)` (for some variant specific to\n the map).\n \n Each `DepTrackingMap` is parameterized by a special type `M` that\n-implements `DepTrackingMapId`; this trait defines the key and value\n+implements `DepTrackingMapConfig`; this trait defines the key and value\n types of the map, and also defines a fn for converting from the key to\n a `DepNode` label. You don't usually have to muck about with this by\n hand, there is a macro for creating it. You can see the complete set\n@@ -221,7 +221,13 @@ of the map will be a `DefId` and value will be\n `DepNode::ItemSignature(K)` for a given key.\n \n Once that is done, you can just use the `DepTrackingMap` like any\n-other map.\n+other map:\n+\n+```rust\n+let mut map: DepTrackingMap<M> = DepTrackingMap::new(dep_graph);\n+map.insert(key, value); // registers dep_graph.write\n+map.get(key; // registers dep_graph.read\n+```\n \n #### Memoization\n \n@@ -305,7 +311,7 @@ distinguish which fns used which fn sigs.\n \n There are various ways to write tests against the dependency graph.\n The simplest mechanism are the\n-`#[rustc_if_this_changed` and `#[rustc_then_this_would_need]`\n+`#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n annotations. These are used in compile-fail tests to test whether the\n expected set of paths exist in the dependency graph. As an example,\n see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n@@ -354,7 +360,7 @@ source_filter     // nodes originating from source_filter\n source_filter -> target_filter // nodes in between source_filter and target_filter\n ```\n \n-`source_filter` and `target_filter` are a comma-separated list of strings.\n+`source_filter` and `target_filter` are a `&`-separated list of strings.\n A node is considered to match a filter if all of those strings appear in its\n label. So, for example:\n \n@@ -363,10 +369,10 @@ RUST_DEP_GRAPH_FILTER='-> TypeckItemBody'\n ```\n \n would select the predecessors of all `TypeckItemBody` nodes. Usually though you\n-want the `TypeckItemBody` nod for some particular fn, so you might write:\n+want the `TypeckItemBody` node for some particular fn, so you might write:\n \n ```\n-RUST_DEP_GRAPH_FILTER='-> TypeckItemBody,bar'\n+RUST_DEP_GRAPH_FILTER='-> TypeckItemBody & bar'\n ```\n \n This will select only the `TypeckItemBody` nodes for fns with `bar` in their name.\n@@ -375,7 +381,7 @@ Perhaps you are finding that when you change `foo` you need to re-type-check `ba\n but you don't think you should have to. In that case, you might do:\n \n ```\n-RUST_DEP_GRAPH_FILTER='Hir,foo -> TypeckItemBody,bar'\n+RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n ```\n \n This will dump out all the nodes that lead from `Hir(foo)` to"}, {"sha": "c49e64f0f543b593ec551ae181cecb5dae395653", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -20,19 +20,19 @@ use super::{DepNode, DepGraph};\n /// A DepTrackingMap offers a subset of the `Map` API and ensures that\n /// we make calls to `read` and `write` as appropriate. We key the\n /// maps with a unique type for brevity.\n-pub struct DepTrackingMap<M: DepTrackingMapId> {\n+pub struct DepTrackingMap<M: DepTrackingMapConfig> {\n     phantom: PhantomData<M>,\n     graph: DepGraph,\n     map: FnvHashMap<M::Key, M::Value>,\n }\n \n-pub trait DepTrackingMapId {\n+pub trait DepTrackingMapConfig {\n     type Key: Eq + Hash + Clone;\n     type Value: Clone;\n     fn to_dep_node(key: &Self::Key) -> DepNode;\n }\n \n-impl<M: DepTrackingMapId> DepTrackingMap<M> {\n+impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn new(graph: DepGraph) -> DepTrackingMap<M> {\n         DepTrackingMap {\n             phantom: PhantomData,\n@@ -71,7 +71,7 @@ impl<M: DepTrackingMapId> DepTrackingMap<M> {\n     }\n }\n \n-impl<M: DepTrackingMapId> MemoizationMap for RefCell<DepTrackingMap<M>> {\n+impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     type Key = M::Key;\n     type Value = M::Value;\n \n@@ -89,9 +89,9 @@ impl<M: DepTrackingMapId> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     /// **Important:* when `op` is invoked, the current task will be\n     /// switched to `Map(key)`. Therefore, if `op` makes use of any\n     /// HIR nodes or shared state accessed through its closure\n-    /// environment, it must explicitly read that state. As an\n-    /// example, see `type_scheme_of_item` in `collect`, which looks\n-    /// something like this:\n+    /// environment, it must explicitly register a read of that\n+    /// state. As an example, see `type_scheme_of_item` in `collect`,\n+    /// which looks something like this:\n     ///\n     /// ```\n     /// fn type_scheme_of_item(..., item: &hir::Item) -> ty::TypeScheme<'tcx> {\n@@ -126,7 +126,7 @@ impl<M: DepTrackingMapId> MemoizationMap for RefCell<DepTrackingMap<M>> {\n     }\n }\n \n-impl<'k, M: DepTrackingMapId> Index<&'k M::Key> for DepTrackingMap<M> {\n+impl<'k, M: DepTrackingMapConfig> Index<&'k M::Key> for DepTrackingMap<M> {\n     type Output = M::Value;\n \n     #[inline]"}, {"sha": "4b25285c476c463e9c9de8e38418570e181e74f5", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n use super::{DepGraphQuery, DepNode};\n \n pub struct DepGraphEdges {\n-    ids: Vec<DepNode>,\n+    nodes: Vec<DepNode>,\n     indices: FnvHashMap<DepNode, IdIndex>,\n     edges: FnvHashSet<(IdIndex, IdIndex)>,\n     open_nodes: Vec<OpenNode>,\n@@ -43,15 +43,15 @@ enum OpenNode {\n impl DepGraphEdges {\n     pub fn new() -> DepGraphEdges {\n         DepGraphEdges {\n-            ids: vec![],\n+            nodes: vec![],\n             indices: FnvHashMap(),\n             edges: FnvHashSet(),\n             open_nodes: Vec::new()\n         }\n     }\n \n-    fn id(&self, index: IdIndex) -> &DepNode {\n-        &self.ids[index.index()]\n+    fn id(&self, index: IdIndex) -> DepNode {\n+        self.nodes[index.index()]\n     }\n \n     /// Creates a node for `id` in the graph.\n@@ -60,8 +60,8 @@ impl DepGraphEdges {\n             return i;\n         }\n \n-        let index = IdIndex::new(self.ids.len());\n-        self.ids.push(id.clone());\n+        let index = IdIndex::new(self.nodes.len());\n+        self.nodes.push(id.clone());\n         self.indices.insert(id, index);\n         index\n     }\n@@ -83,7 +83,7 @@ impl DepGraphEdges {\n     pub fn push_task(&mut self, key: DepNode) {\n         let top_node = self.current_node();\n \n-        let new_node = self.make_node(key.clone());\n+        let new_node = self.make_node(key);\n         self.open_nodes.push(OpenNode::Node(new_node));\n \n         // if we are in the midst of doing task T, then this new task\n@@ -155,8 +155,8 @@ impl DepGraphEdges {\n \n     pub fn query(&self) -> DepGraphQuery {\n         let edges: Vec<_> = self.edges.iter()\n-                                      .map(|&(i, j)| (self.id(i).clone(), self.id(j).clone()))\n+                                      .map(|&(i, j)| (self.id(i), self.id(j)))\n                                       .collect();\n-        DepGraphQuery::new(&self.ids, &edges)\n+        DepGraphQuery::new(&self.nodes, &edges)\n     }\n }"}, {"sha": "9bf0a79115e78f4ebe8cd388ca272c209064ae1d", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -152,7 +152,7 @@ impl DepGraph {\n     }\n }\n \n-pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapId};\n+pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n \n pub use self::query::DepGraphQuery;\n "}, {"sha": "dbc57605d71aef52cc5265fbd19882965503c4e0", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -48,7 +48,7 @@ pub struct DepGraphThreadData {\n     // where to send buffer when full\n     swap_out: Sender<Vec<DepMessage>>,\n \n-    // where to receiver query results\n+    // where to receive query results\n     query_in: Receiver<DepGraphQuery>,\n }\n "}, {"sha": "924d420613ce71b5494e623992d18c0bdcb9849c", "filename": "src/librustc/middle/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d7e366681c0157a557ff0083aa56fae9469fbf/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmaps.rs?ref=a9d7e366681c0157a557ff0083aa56fae9469fbf", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepNode, DepTrackingMapId};\n+use dep_graph::{DepNode, DepTrackingMapConfig};\n use middle::def_id::DefId;\n use middle::ty;\n use std::marker::PhantomData;\n@@ -20,7 +20,7 @@ macro_rules! dep_map_ty {\n             data: PhantomData<&'tcx ()>\n         }\n \n-        impl<'tcx> DepTrackingMapId for $ty_name<'tcx> {\n+        impl<'tcx> DepTrackingMapConfig for $ty_name<'tcx> {\n             type Key = $key;\n             type Value = $value;\n             fn to_dep_node(key: &$key) -> DepNode { DepNode::$node_name(*key) }"}]}