{"sha": "53ead1b8c960a63a9422725d54d405c65756a1bb", "node_id": "C_kwDOAAsO6NoAKDUzZWFkMWI4Yzk2MGE2M2E5NDIyNzI1ZDU0ZDQwNWM2NTc1NmExYmI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-18T12:00:36Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-18T12:03:58Z"}, "message": "move simd intrinsics to their own file", "tree": {"sha": "ddcd2d80b7b7d31c86005266e57e8cb30705aafb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddcd2d80b7b7d31c86005266e57e8cb30705aafb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ead1b8c960a63a9422725d54d405c65756a1bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ead1b8c960a63a9422725d54d405c65756a1bb", "html_url": "https://github.com/rust-lang/rust/commit/53ead1b8c960a63a9422725d54d405c65756a1bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ead1b8c960a63a9422725d54d405c65756a1bb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52a6ac96b0a2a270400d75ba9ed3aa829826b5db", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a6ac96b0a2a270400d75ba9ed3aa829826b5db", "html_url": "https://github.com/rust-lang/rust/commit/52a6ac96b0a2a270400d75ba9ed3aa829826b5db"}], "stats": {"total": 1213, "additions": 620, "deletions": 593}, "files": [{"sha": "e51fd98c5522d3275d8a1b13fcccfddd086095e6", "filename": "src/shims/intrinsics/atomic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=53ead1b8c960a63a9422725d54d405c65756a1bb", "patch": "@@ -21,7 +21,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         match intrinsic_name {\n-            // Atomic operations\n             \"load_seqcst\" => this.atomic_load(args, dest, AtomicReadOrd::SeqCst)?,\n             \"load_relaxed\" => this.atomic_load(args, dest, AtomicReadOrd::Relaxed)?,\n             \"load_acquire\" => this.atomic_load(args, dest, AtomicReadOrd::Acquire)?,"}, {"sha": "a8b8b807bd8282f0ffaf3267521c1ef696440a2f", "filename": "src/shims/intrinsics/mod.rs", "status": "modified", "additions": 7, "deletions": 592, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=53ead1b8c960a63a9422725d54d405c65756a1bb", "patch": "@@ -1,16 +1,18 @@\n pub mod atomic;\n+mod simd;\n \n use std::iter;\n \n use log::trace;\n \n use rustc_apfloat::{Float, Round};\n-use rustc_middle::ty::layout::{HasParamEnv, IntegerExt, LayoutOf};\n+use rustc_middle::ty::layout::{IntegerExt, LayoutOf};\n use rustc_middle::{mir, ty, ty::FloatTy};\n-use rustc_target::abi::{Endian, HasDataLayout, Integer, Size};\n+use rustc_target::abi::Integer;\n \n use crate::*;\n use helpers::check_arg_count;\n+use simd::EvalContextExt as _;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -63,6 +65,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some(name) = intrinsic_name.strip_prefix(\"atomic_\") {\n             return this.emulate_atomic_intrinsic(name, args, dest);\n         }\n+        if let Some(name) = intrinsic_name.strip_prefix(\"simd_\") {\n+            return this.emulate_simd_intrinsic(name, args, dest);\n+        }\n \n         match intrinsic_name {\n             // Miri overwriting CTFE intrinsics.\n@@ -347,541 +352,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n \n-            // SIMD operations\n-            #[rustfmt::skip]\n-            | \"simd_neg\"\n-            | \"simd_fabs\"\n-            | \"simd_ceil\"\n-            | \"simd_floor\"\n-            | \"simd_round\"\n-            | \"simd_trunc\"\n-            | \"simd_fsqrt\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, op_len);\n-\n-                #[derive(Copy, Clone)]\n-                enum HostFloatOp {\n-                    Ceil,\n-                    Floor,\n-                    Round,\n-                    Trunc,\n-                    Sqrt,\n-                }\n-                #[derive(Copy, Clone)]\n-                enum Op {\n-                    MirOp(mir::UnOp),\n-                    Abs,\n-                    HostOp(HostFloatOp),\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_neg\" => Op::MirOp(mir::UnOp::Neg),\n-                    \"simd_fabs\" => Op::Abs,\n-                    \"simd_ceil\" => Op::HostOp(HostFloatOp::Ceil),\n-                    \"simd_floor\" => Op::HostOp(HostFloatOp::Floor),\n-                    \"simd_round\" => Op::HostOp(HostFloatOp::Round),\n-                    \"simd_trunc\" => Op::HostOp(HostFloatOp::Trunc),\n-                    \"simd_fsqrt\" => Op::HostOp(HostFloatOp::Sqrt),\n-                    _ => unreachable!(),\n-                };\n-\n-                for i in 0..dest_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-                    let val = match which {\n-                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar()?,\n-                        Op::Abs => {\n-                            // Works for f32 and f64.\n-                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                            };\n-                            let op = op.to_scalar()?;\n-                            match float_ty {\n-                                FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n-                                FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n-                            }\n-                        }\n-                        Op::HostOp(host_op) => {\n-                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n-                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                            };\n-                            // FIXME using host floats\n-                            match float_ty {\n-                                FloatTy::F32 => {\n-                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n-                                    let res = match host_op {\n-                                        HostFloatOp::Ceil => f.ceil(),\n-                                        HostFloatOp::Floor => f.floor(),\n-                                        HostFloatOp::Round => f.round(),\n-                                        HostFloatOp::Trunc => f.trunc(),\n-                                        HostFloatOp::Sqrt => f.sqrt(),\n-                                    };\n-                                    Scalar::from_u32(res.to_bits())\n-                                }\n-                                FloatTy::F64 => {\n-                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n-                                    let res = match host_op {\n-                                        HostFloatOp::Ceil => f.ceil(),\n-                                        HostFloatOp::Floor => f.floor(),\n-                                        HostFloatOp::Round => f.round(),\n-                                        HostFloatOp::Trunc => f.trunc(),\n-                                        HostFloatOp::Sqrt => f.sqrt(),\n-                                    };\n-                                    Scalar::from_u64(res.to_bits())\n-                                }\n-                            }\n-\n-                        }\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_add\"\n-            | \"simd_sub\"\n-            | \"simd_mul\"\n-            | \"simd_div\"\n-            | \"simd_rem\"\n-            | \"simd_shl\"\n-            | \"simd_shr\"\n-            | \"simd_and\"\n-            | \"simd_or\"\n-            | \"simd_xor\"\n-            | \"simd_eq\"\n-            | \"simd_ne\"\n-            | \"simd_lt\"\n-            | \"simd_le\"\n-            | \"simd_gt\"\n-            | \"simd_ge\"\n-            | \"simd_fmax\"\n-            | \"simd_fmin\"\n-            | \"simd_saturating_add\"\n-            | \"simd_saturating_sub\"\n-            | \"simd_arith_offset\" => {\n-                use mir::BinOp;\n-\n-                let [left, right] = check_arg_count(args)?;\n-                let (left, left_len) = this.operand_to_simd(left)?;\n-                let (right, right_len) = this.operand_to_simd(right)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, left_len);\n-                assert_eq!(dest_len, right_len);\n-\n-                enum Op {\n-                    MirOp(BinOp),\n-                    SaturatingOp(BinOp),\n-                    FMax,\n-                    FMin,\n-                    WrappingOffset,\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_add\" => Op::MirOp(BinOp::Add),\n-                    \"simd_sub\" => Op::MirOp(BinOp::Sub),\n-                    \"simd_mul\" => Op::MirOp(BinOp::Mul),\n-                    \"simd_div\" => Op::MirOp(BinOp::Div),\n-                    \"simd_rem\" => Op::MirOp(BinOp::Rem),\n-                    \"simd_shl\" => Op::MirOp(BinOp::Shl),\n-                    \"simd_shr\" => Op::MirOp(BinOp::Shr),\n-                    \"simd_and\" => Op::MirOp(BinOp::BitAnd),\n-                    \"simd_or\" => Op::MirOp(BinOp::BitOr),\n-                    \"simd_xor\" => Op::MirOp(BinOp::BitXor),\n-                    \"simd_eq\" => Op::MirOp(BinOp::Eq),\n-                    \"simd_ne\" => Op::MirOp(BinOp::Ne),\n-                    \"simd_lt\" => Op::MirOp(BinOp::Lt),\n-                    \"simd_le\" => Op::MirOp(BinOp::Le),\n-                    \"simd_gt\" => Op::MirOp(BinOp::Gt),\n-                    \"simd_ge\" => Op::MirOp(BinOp::Ge),\n-                    \"simd_fmax\" => Op::FMax,\n-                    \"simd_fmin\" => Op::FMin,\n-                    \"simd_saturating_add\" => Op::SaturatingOp(BinOp::Add),\n-                    \"simd_saturating_sub\" => Op::SaturatingOp(BinOp::Sub),\n-                    \"simd_arith_offset\" => Op::WrappingOffset,\n-                    _ => unreachable!(),\n-                };\n-\n-                for i in 0..dest_len {\n-                    let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n-                    let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-                    let val = match which {\n-                        Op::MirOp(mir_op) => {\n-                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n-                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n-                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n-                                // See <https://github.com/rust-lang/rust/issues/91237>.\n-                                if overflowed {\n-                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n-                                    throw_ub_format!(\"overflowing shift by {r_val} in `{intrinsic_name}` in SIMD lane {i}\");\n-                                }\n-                            }\n-                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n-                                // Special handling for boolean-returning operations\n-                                assert_eq!(ty, this.tcx.types.bool);\n-                                let val = val.to_bool().unwrap();\n-                                bool_to_simd_element(val, dest.layout.size)\n-                            } else {\n-                                assert_ne!(ty, this.tcx.types.bool);\n-                                assert_eq!(ty, dest.layout.ty);\n-                                val\n-                            }\n-                        }\n-                        Op::SaturatingOp(mir_op) => {\n-                            this.saturating_arith(mir_op, &left, &right)?\n-                        }\n-                        Op::WrappingOffset => {\n-                            let ptr = this.scalar_to_ptr(left.to_scalar()?)?;\n-                            let offset_count = right.to_scalar()?.to_machine_isize(this)?;\n-                            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n-\n-                            let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n-                            let offset_bytes = offset_count.wrapping_mul(pointee_size);\n-                            let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, this);\n-                            Scalar::from_maybe_pointer(offset_ptr, this)\n-                        }\n-                        Op::FMax => {\n-                            fmax_op(&left, &right)?\n-                        }\n-                        Op::FMin => {\n-                            fmin_op(&left, &right)?\n-                        }\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            \"simd_fma\" => {\n-                let [a, b, c] = check_arg_count(args)?;\n-                let (a, a_len) = this.operand_to_simd(a)?;\n-                let (b, b_len) = this.operand_to_simd(b)?;\n-                let (c, c_len) = this.operand_to_simd(c)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, a_len);\n-                assert_eq!(dest_len, b_len);\n-                assert_eq!(dest_len, c_len);\n-\n-                for i in 0..dest_len {\n-                    let a = this.read_immediate(&this.mplace_index(&a, i)?.into())?.to_scalar()?;\n-                    let b = this.read_immediate(&this.mplace_index(&b, i)?.into())?.to_scalar()?;\n-                    let c = this.read_immediate(&this.mplace_index(&c, i)?.into())?.to_scalar()?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    // Works for f32 and f64.\n-                    let ty::Float(float_ty) = dest.layout.ty.kind() else {\n-                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n-                    };\n-                    let val = match float_ty {\n-                        FloatTy::F32 =>\n-                            Scalar::from_f32(a.to_f32()?.mul_add(b.to_f32()?, c.to_f32()?).value),\n-                        FloatTy::F64 =>\n-                            Scalar::from_f64(a.to_f64()?.mul_add(b.to_f64()?, c.to_f64()?).value),\n-                    };\n-                    this.write_scalar(val, &dest.into())?;\n-                }\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_reduce_and\"\n-            | \"simd_reduce_or\"\n-            | \"simd_reduce_xor\"\n-            | \"simd_reduce_any\"\n-            | \"simd_reduce_all\"\n-            | \"simd_reduce_max\"\n-            | \"simd_reduce_min\" => {\n-                use mir::BinOp;\n-\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-\n-                let imm_from_bool =\n-                    |b| ImmTy::from_scalar(Scalar::from_bool(b), this.machine.layouts.bool);\n-\n-                enum Op {\n-                    MirOp(BinOp),\n-                    MirOpBool(BinOp),\n-                    Max,\n-                    Min,\n-                }\n-                let which = match intrinsic_name {\n-                    \"simd_reduce_and\" => Op::MirOp(BinOp::BitAnd),\n-                    \"simd_reduce_or\" => Op::MirOp(BinOp::BitOr),\n-                    \"simd_reduce_xor\" => Op::MirOp(BinOp::BitXor),\n-                    \"simd_reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n-                    \"simd_reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n-                    \"simd_reduce_max\" => Op::Max,\n-                    \"simd_reduce_min\" => Op::Min,\n-                    _ => unreachable!(),\n-                };\n-\n-                // Initialize with first lane, then proceed with the rest.\n-                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n-                if matches!(which, Op::MirOpBool(_)) {\n-                    // Convert to `bool` scalar.\n-                    res = imm_from_bool(simd_element_to_bool(res)?);\n-                }\n-                for i in 1..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    res = match which {\n-                        Op::MirOp(mir_op) => {\n-                            this.binary_op(mir_op, &res, &op)?\n-                        }\n-                        Op::MirOpBool(mir_op) => {\n-                            let op = imm_from_bool(simd_element_to_bool(op)?);\n-                            this.binary_op(mir_op, &res, &op)?\n-                        }\n-                        Op::Max => {\n-                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n-                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n-                            } else {\n-                                // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n-                                    res\n-                                } else {\n-                                    op\n-                                }\n-                            }\n-                        }\n-                        Op::Min => {\n-                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n-                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n-                            } else {\n-                                // Just boring integers, so NaNs to worry about\n-                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n-                                    res\n-                                } else {\n-                                    op\n-                                }\n-                            }\n-                        }\n-                    };\n-                }\n-                this.write_immediate(*res, dest)?;\n-            }\n-            #[rustfmt::skip]\n-            | \"simd_reduce_add_ordered\"\n-            | \"simd_reduce_mul_ordered\" => {\n-                use mir::BinOp;\n-\n-                let [op, init] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let init = this.read_immediate(init)?;\n-\n-                let mir_op = match intrinsic_name {\n-                    \"simd_reduce_add_ordered\" => BinOp::Add,\n-                    \"simd_reduce_mul_ordered\" => BinOp::Mul,\n-                    _ => unreachable!(),\n-                };\n-\n-                let mut res = init;\n-                for i in 0..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    res = this.binary_op(mir_op, &res, &op)?;\n-                }\n-                this.write_immediate(*res, dest)?;\n-            }\n-            \"simd_select\" => {\n-                let [mask, yes, no] = check_arg_count(args)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-                let (yes, yes_len) = this.operand_to_simd(yes)?;\n-                let (no, no_len) = this.operand_to_simd(no)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, mask_len);\n-                assert_eq!(dest_len, yes_len);\n-                assert_eq!(dest_len, no_len);\n-\n-                for i in 0..dest_len {\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n-                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if simd_element_to_bool(mask)? { yes } else { no };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_select_bitmask\" => {\n-                let [mask, yes, no] = check_arg_count(args)?;\n-                let (yes, yes_len) = this.operand_to_simd(yes)?;\n-                let (no, no_len) = this.operand_to_simd(no)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-                let bitmask_len = dest_len.max(8);\n-\n-                assert!(mask.layout.ty.is_integral());\n-                assert!(bitmask_len <= 64);\n-                assert_eq!(bitmask_len, mask.layout.size.bits());\n-                assert_eq!(dest_len, yes_len);\n-                assert_eq!(dest_len, no_len);\n-\n-                let mask: u64 = this\n-                    .read_scalar(mask)?\n-                    .check_init()?\n-                    .to_bits(mask.layout.size)?\n-                    .try_into()\n-                    .unwrap();\n-                for i in 0..dest_len {\n-                    let mask =\n-                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n-                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n-                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if mask != 0 { yes } else { no };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-                for i in dest_len..bitmask_len {\n-                    // If the mask is \"padded\", ensure that padding is all-zero.\n-                    let mask = mask & (1 << i);\n-                    if mask != 0 {\n-                        throw_ub_format!(\n-                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n-                        );\n-                    }\n-                }\n-            }\n-            #[rustfmt::skip]\n-            \"simd_cast\" | \"simd_as\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, op_len);\n-\n-                let safe_cast = intrinsic_name == \"simd_as\";\n-\n-                for i in 0..dest_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n-                        // Int-to-(int|float): always safe\n-                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-float: always safe\n-                        (ty::Float(_), ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-int in safe mode\n-                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n-                        // Float-to-int in unchecked mode\n-                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n-                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n-                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n-                        _ =>\n-                            throw_unsup_format!(\n-                                \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n-                                from_ty = op.layout.ty,\n-                                to_ty = dest.layout.ty,\n-                            ),\n-                    };\n-                    this.write_immediate(val, &dest.into())?;\n-                }\n-            }\n-            \"simd_shuffle\" => {\n-                let [left, right, index] = check_arg_count(args)?;\n-                let (left, left_len) = this.operand_to_simd(left)?;\n-                let (right, right_len) = this.operand_to_simd(right)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                // `index` is an array, not a SIMD type\n-                let ty::Array(_, index_len) = index.layout.ty.kind() else {\n-                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n-                };\n-                let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n-\n-                assert_eq!(left_len, right_len);\n-                assert_eq!(index_len, dest_len);\n-\n-                for i in 0..dest_len {\n-                    let src_index: u64 = this\n-                        .read_immediate(&this.operand_index(index, i)?)?\n-                        .to_scalar()?\n-                        .to_u32()?\n-                        .into();\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if src_index < left_len {\n-                        this.read_immediate(&this.mplace_index(&left, src_index)?.into())?\n-                    } else if src_index < left_len.checked_add(right_len).unwrap() {\n-                        this.read_immediate(\n-                            &this.mplace_index(&right, src_index - left_len)?.into(),\n-                        )?\n-                    } else {\n-                        span_bug!(\n-                            this.cur_span(),\n-                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n-                        );\n-                    };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_gather\" => {\n-                let [passthru, ptrs, mask] = check_arg_count(args)?;\n-                let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n-                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-                let (dest, dest_len) = this.place_to_simd(dest)?;\n-\n-                assert_eq!(dest_len, passthru_len);\n-                assert_eq!(dest_len, ptrs_len);\n-                assert_eq!(dest_len, mask_len);\n-\n-                for i in 0..dest_len {\n-                    let passthru = this.read_immediate(&this.mplace_index(&passthru, i)?.into())?;\n-                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-                    let dest = this.mplace_index(&dest, i)?;\n-\n-                    let val = if simd_element_to_bool(mask)? {\n-                        let place = this.deref_operand(&ptr.into())?;\n-                        this.read_immediate(&place.into())?\n-                    } else {\n-                        passthru\n-                    };\n-                    this.write_immediate(*val, &dest.into())?;\n-                }\n-            }\n-            \"simd_scatter\" => {\n-                let [value, ptrs, mask] = check_arg_count(args)?;\n-                let (value, value_len) = this.operand_to_simd(value)?;\n-                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n-                let (mask, mask_len) = this.operand_to_simd(mask)?;\n-\n-                assert_eq!(ptrs_len, value_len);\n-                assert_eq!(ptrs_len, mask_len);\n-\n-                for i in 0..ptrs_len {\n-                    let value = this.read_immediate(&this.mplace_index(&value, i)?.into())?;\n-                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n-                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n-\n-                    if simd_element_to_bool(mask)? {\n-                        let place = this.deref_operand(&ptr.into())?;\n-                        this.write_immediate(*value, &place.into())?;\n-                    }\n-                }\n-            }\n-            \"simd_bitmask\" => {\n-                let [op] = check_arg_count(args)?;\n-                let (op, op_len) = this.operand_to_simd(op)?;\n-                let bitmask_len = op_len.max(8);\n-\n-                assert!(dest.layout.ty.is_integral());\n-                assert!(bitmask_len <= 64);\n-                assert_eq!(bitmask_len, dest.layout.size.bits());\n-\n-                let mut res = 0u64;\n-                for i in 0..op_len {\n-                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n-                    if simd_element_to_bool(op)? {\n-                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n-                    }\n-                }\n-                this.write_int(res, dest)?;\n-            }\n-\n             // Other\n             \"exact_div\" => {\n                 let [num, denom] = check_arg_count(args)?;\n@@ -953,58 +423,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n }\n-\n-fn fmax_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n-    assert_eq!(left.layout.ty, right.layout.ty);\n-    let ty::Float(float_ty) = left.layout.ty.kind() else {\n-        bug!(\"fmax operand is not a float\")\n-    };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n-    Ok(match float_ty {\n-        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n-        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n-    })\n-}\n-\n-fn fmin_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n-    assert_eq!(left.layout.ty, right.layout.ty);\n-    let ty::Float(float_ty) = left.layout.ty.kind() else {\n-        bug!(\"fmin operand is not a float\")\n-    };\n-    let left = left.to_scalar()?;\n-    let right = right.to_scalar()?;\n-    Ok(match float_ty {\n-        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n-        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n-    })\n-}\n-\n-fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n-    // SIMD uses all-1 as pattern for \"true\"\n-    let val = if b { -1 } else { 0 };\n-    Scalar::from_int(val, size)\n-}\n-\n-fn simd_element_to_bool(elem: ImmTy<'_, Tag>) -> InterpResult<'_, bool> {\n-    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n-    Ok(match val {\n-        0 => false,\n-        -1 => true,\n-        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n-    })\n-}\n-\n-fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n-    assert!(idx < vec_len);\n-    match endianess {\n-        Endian::Little => idx,\n-        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n-    }\n-}"}, {"sha": "fe5250ed08434bfc363b3ff7cc0fb03e486c8a75", "filename": "src/shims/intrinsics/simd.rs", "status": "added", "additions": 613, "deletions": 0, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ead1b8c960a63a9422725d54d405c65756a1bb/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=53ead1b8c960a63a9422725d54d405c65756a1bb", "patch": "@@ -0,0 +1,613 @@\n+use rustc_apfloat::Float;\n+use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n+use rustc_middle::{mir, ty, ty::FloatTy};\n+use rustc_target::abi::{Endian, HasDataLayout, Size};\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Calls the simd intrinsic `intrinsic`; the `simd_` prefix has already been removed.\n+    fn emulate_simd_intrinsic(\n+        &mut self,\n+        intrinsic_name: &str,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: &PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        match intrinsic_name {\n+            #[rustfmt::skip]\n+            | \"neg\"\n+            | \"fabs\"\n+            | \"ceil\"\n+            | \"floor\"\n+            | \"round\"\n+            | \"trunc\"\n+            | \"fsqrt\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                #[derive(Copy, Clone)]\n+                enum HostFloatOp {\n+                    Ceil,\n+                    Floor,\n+                    Round,\n+                    Trunc,\n+                    Sqrt,\n+                }\n+                #[derive(Copy, Clone)]\n+                enum Op {\n+                    MirOp(mir::UnOp),\n+                    Abs,\n+                    HostOp(HostFloatOp),\n+                }\n+                let which = match intrinsic_name {\n+                    \"neg\" => Op::MirOp(mir::UnOp::Neg),\n+                    \"fabs\" => Op::Abs,\n+                    \"ceil\" => Op::HostOp(HostFloatOp::Ceil),\n+                    \"floor\" => Op::HostOp(HostFloatOp::Floor),\n+                    \"round\" => Op::HostOp(HostFloatOp::Round),\n+                    \"trunc\" => Op::HostOp(HostFloatOp::Trunc),\n+                    \"fsqrt\" => Op::HostOp(HostFloatOp::Sqrt),\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => this.unary_op(mir_op, &op)?.to_scalar()?,\n+                        Op::Abs => {\n+                            // Works for f32 and f64.\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            let op = op.to_scalar()?;\n+                            match float_ty {\n+                                FloatTy::F32 => Scalar::from_f32(op.to_f32()?.abs()),\n+                                FloatTy::F64 => Scalar::from_f64(op.to_f64()?.abs()),\n+                            }\n+                        }\n+                        Op::HostOp(host_op) => {\n+                            let ty::Float(float_ty) = op.layout.ty.kind() else {\n+                                span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                            };\n+                            // FIXME using host floats\n+                            match float_ty {\n+                                FloatTy::F32 => {\n+                                    let f = f32::from_bits(op.to_scalar()?.to_u32()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u32(res.to_bits())\n+                                }\n+                                FloatTy::F64 => {\n+                                    let f = f64::from_bits(op.to_scalar()?.to_u64()?);\n+                                    let res = match host_op {\n+                                        HostFloatOp::Ceil => f.ceil(),\n+                                        HostFloatOp::Floor => f.floor(),\n+                                        HostFloatOp::Round => f.round(),\n+                                        HostFloatOp::Trunc => f.trunc(),\n+                                        HostFloatOp::Sqrt => f.sqrt(),\n+                                    };\n+                                    Scalar::from_u64(res.to_bits())\n+                                }\n+                            }\n+\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"add\"\n+            | \"sub\"\n+            | \"mul\"\n+            | \"div\"\n+            | \"rem\"\n+            | \"shl\"\n+            | \"shr\"\n+            | \"and\"\n+            | \"or\"\n+            | \"xor\"\n+            | \"eq\"\n+            | \"ne\"\n+            | \"lt\"\n+            | \"le\"\n+            | \"gt\"\n+            | \"ge\"\n+            | \"fmax\"\n+            | \"fmin\"\n+            | \"saturating_add\"\n+            | \"saturating_sub\"\n+            | \"arith_offset\" => {\n+                use mir::BinOp;\n+\n+                let [left, right] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, left_len);\n+                assert_eq!(dest_len, right_len);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    SaturatingOp(BinOp),\n+                    FMax,\n+                    FMin,\n+                    WrappingOffset,\n+                }\n+                let which = match intrinsic_name {\n+                    \"add\" => Op::MirOp(BinOp::Add),\n+                    \"sub\" => Op::MirOp(BinOp::Sub),\n+                    \"mul\" => Op::MirOp(BinOp::Mul),\n+                    \"div\" => Op::MirOp(BinOp::Div),\n+                    \"rem\" => Op::MirOp(BinOp::Rem),\n+                    \"shl\" => Op::MirOp(BinOp::Shl),\n+                    \"shr\" => Op::MirOp(BinOp::Shr),\n+                    \"and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"or\" => Op::MirOp(BinOp::BitOr),\n+                    \"xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"eq\" => Op::MirOp(BinOp::Eq),\n+                    \"ne\" => Op::MirOp(BinOp::Ne),\n+                    \"lt\" => Op::MirOp(BinOp::Lt),\n+                    \"le\" => Op::MirOp(BinOp::Le),\n+                    \"gt\" => Op::MirOp(BinOp::Gt),\n+                    \"ge\" => Op::MirOp(BinOp::Ge),\n+                    \"fmax\" => Op::FMax,\n+                    \"fmin\" => Op::FMin,\n+                    \"saturating_add\" => Op::SaturatingOp(BinOp::Add),\n+                    \"saturating_sub\" => Op::SaturatingOp(BinOp::Sub),\n+                    \"arith_offset\" => Op::WrappingOffset,\n+                    _ => unreachable!(),\n+                };\n+\n+                for i in 0..dest_len {\n+                    let left = this.read_immediate(&this.mplace_index(&left, i)?.into())?;\n+                    let right = this.read_immediate(&this.mplace_index(&right, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+                    let val = match which {\n+                        Op::MirOp(mir_op) => {\n+                            let (val, overflowed, ty) = this.overflowing_binary_op(mir_op, &left, &right)?;\n+                            if matches!(mir_op, BinOp::Shl | BinOp::Shr) {\n+                                // Shifts have extra UB as SIMD operations that the MIR binop does not have.\n+                                // See <https://github.com/rust-lang/rust/issues/91237>.\n+                                if overflowed {\n+                                    let r_val = right.to_scalar()?.to_bits(right.layout.size)?;\n+                                    throw_ub_format!(\"overflowing shift by {r_val} in `simd_{intrinsic_name}` in SIMD lane {i}\");\n+                                }\n+                            }\n+                            if matches!(mir_op, BinOp::Eq | BinOp::Ne | BinOp::Lt | BinOp::Le | BinOp::Gt | BinOp::Ge) {\n+                                // Special handling for boolean-returning operations\n+                                assert_eq!(ty, this.tcx.types.bool);\n+                                let val = val.to_bool().unwrap();\n+                                bool_to_simd_element(val, dest.layout.size)\n+                            } else {\n+                                assert_ne!(ty, this.tcx.types.bool);\n+                                assert_eq!(ty, dest.layout.ty);\n+                                val\n+                            }\n+                        }\n+                        Op::SaturatingOp(mir_op) => {\n+                            this.saturating_arith(mir_op, &left, &right)?\n+                        }\n+                        Op::WrappingOffset => {\n+                            let ptr = this.scalar_to_ptr(left.to_scalar()?)?;\n+                            let offset_count = right.to_scalar()?.to_machine_isize(this)?;\n+                            let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n+\n+                            let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+                            let offset_bytes = offset_count.wrapping_mul(pointee_size);\n+                            let offset_ptr = ptr.wrapping_signed_offset(offset_bytes, this);\n+                            Scalar::from_maybe_pointer(offset_ptr, this)\n+                        }\n+                        Op::FMax => {\n+                            fmax_op(&left, &right)?\n+                        }\n+                        Op::FMin => {\n+                            fmin_op(&left, &right)?\n+                        }\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            \"fma\" => {\n+                let [a, b, c] = check_arg_count(args)?;\n+                let (a, a_len) = this.operand_to_simd(a)?;\n+                let (b, b_len) = this.operand_to_simd(b)?;\n+                let (c, c_len) = this.operand_to_simd(c)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, a_len);\n+                assert_eq!(dest_len, b_len);\n+                assert_eq!(dest_len, c_len);\n+\n+                for i in 0..dest_len {\n+                    let a = this.read_immediate(&this.mplace_index(&a, i)?.into())?.to_scalar()?;\n+                    let b = this.read_immediate(&this.mplace_index(&b, i)?.into())?.to_scalar()?;\n+                    let c = this.read_immediate(&this.mplace_index(&c, i)?.into())?.to_scalar()?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    // Works for f32 and f64.\n+                    let ty::Float(float_ty) = dest.layout.ty.kind() else {\n+                        span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n+                    };\n+                    let val = match float_ty {\n+                        FloatTy::F32 =>\n+                            Scalar::from_f32(a.to_f32()?.mul_add(b.to_f32()?, c.to_f32()?).value),\n+                        FloatTy::F64 =>\n+                            Scalar::from_f64(a.to_f64()?.mul_add(b.to_f64()?, c.to_f64()?).value),\n+                    };\n+                    this.write_scalar(val, &dest.into())?;\n+                }\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_and\"\n+            | \"reduce_or\"\n+            | \"reduce_xor\"\n+            | \"reduce_any\"\n+            | \"reduce_all\"\n+            | \"reduce_max\"\n+            | \"reduce_min\" => {\n+                use mir::BinOp;\n+\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+\n+                let imm_from_bool =\n+                    |b| ImmTy::from_scalar(Scalar::from_bool(b), this.machine.layouts.bool);\n+\n+                enum Op {\n+                    MirOp(BinOp),\n+                    MirOpBool(BinOp),\n+                    Max,\n+                    Min,\n+                }\n+                let which = match intrinsic_name {\n+                    \"reduce_and\" => Op::MirOp(BinOp::BitAnd),\n+                    \"reduce_or\" => Op::MirOp(BinOp::BitOr),\n+                    \"reduce_xor\" => Op::MirOp(BinOp::BitXor),\n+                    \"reduce_any\" => Op::MirOpBool(BinOp::BitOr),\n+                    \"reduce_all\" => Op::MirOpBool(BinOp::BitAnd),\n+                    \"reduce_max\" => Op::Max,\n+                    \"reduce_min\" => Op::Min,\n+                    _ => unreachable!(),\n+                };\n+\n+                // Initialize with first lane, then proceed with the rest.\n+                let mut res = this.read_immediate(&this.mplace_index(&op, 0)?.into())?;\n+                if matches!(which, Op::MirOpBool(_)) {\n+                    // Convert to `bool` scalar.\n+                    res = imm_from_bool(simd_element_to_bool(res)?);\n+                }\n+                for i in 1..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = match which {\n+                        Op::MirOp(mir_op) => {\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::MirOpBool(mir_op) => {\n+                            let op = imm_from_bool(simd_element_to_bool(op)?);\n+                            this.binary_op(mir_op, &res, &op)?\n+                        }\n+                        Op::Max => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmax_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Ge, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                        Op::Min => {\n+                            if matches!(res.layout.ty.kind(), ty::Float(_)) {\n+                                ImmTy::from_scalar(fmin_op(&res, &op)?, res.layout)\n+                            } else {\n+                                // Just boring integers, so NaNs to worry about\n+                                if this.binary_op(BinOp::Le, &res, &op)?.to_scalar()?.to_bool()? {\n+                                    res\n+                                } else {\n+                                    op\n+                                }\n+                            }\n+                        }\n+                    };\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            #[rustfmt::skip]\n+            | \"reduce_add_ordered\"\n+            | \"reduce_mul_ordered\" => {\n+                use mir::BinOp;\n+\n+                let [op, init] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let init = this.read_immediate(init)?;\n+\n+                let mir_op = match intrinsic_name {\n+                    \"reduce_add_ordered\" => BinOp::Add,\n+                    \"reduce_mul_ordered\" => BinOp::Mul,\n+                    _ => unreachable!(),\n+                };\n+\n+                let mut res = init;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    res = this.binary_op(mir_op, &res, &op)?;\n+                }\n+                this.write_immediate(*res, dest)?;\n+            }\n+            \"select\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, mask_len);\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                for i in 0..dest_len {\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"select_bitmask\" => {\n+                let [mask, yes, no] = check_arg_count(args)?;\n+                let (yes, yes_len) = this.operand_to_simd(yes)?;\n+                let (no, no_len) = this.operand_to_simd(no)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+                let bitmask_len = dest_len.max(8);\n+\n+                assert!(mask.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, mask.layout.size.bits());\n+                assert_eq!(dest_len, yes_len);\n+                assert_eq!(dest_len, no_len);\n+\n+                let mask: u64 = this\n+                    .read_scalar(mask)?\n+                    .check_init()?\n+                    .to_bits(mask.layout.size)?\n+                    .try_into()\n+                    .unwrap();\n+                for i in 0..dest_len {\n+                    let mask =\n+                        mask & (1 << simd_bitmask_index(i, dest_len, this.data_layout().endian));\n+                    let yes = this.read_immediate(&this.mplace_index(&yes, i)?.into())?;\n+                    let no = this.read_immediate(&this.mplace_index(&no, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if mask != 0 { yes } else { no };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+                for i in dest_len..bitmask_len {\n+                    // If the mask is \"padded\", ensure that padding is all-zero.\n+                    let mask = mask & (1 << i);\n+                    if mask != 0 {\n+                        throw_ub_format!(\n+                            \"a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\"\n+                        );\n+                    }\n+                }\n+            }\n+            #[rustfmt::skip]\n+            \"cast\" | \"as\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, op_len);\n+\n+                let safe_cast = intrinsic_name == \"as\";\n+\n+                for i in 0..dest_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n+                        // Int-to-(int|float): always safe\n+                        (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-float: always safe\n+                        (ty::Float(_), ty::Float(_)) =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in safe mode\n+                        (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n+                            this.misc_cast(&op, dest.layout.ty)?,\n+                        // Float-to-int in unchecked mode\n+                        (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f32()?, dest.layout.ty)?.into(),\n+                        (ty::Float(FloatTy::F64), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n+                            this.float_to_int_unchecked(op.to_scalar()?.to_f64()?, dest.layout.ty)?.into(),\n+                        _ =>\n+                            throw_unsup_format!(\n+                                \"Unsupported SIMD cast from element type {from_ty} to {to_ty}\",\n+                                from_ty = op.layout.ty,\n+                                to_ty = dest.layout.ty,\n+                            ),\n+                    };\n+                    this.write_immediate(val, &dest.into())?;\n+                }\n+            }\n+            \"shuffle\" => {\n+                let [left, right, index] = check_arg_count(args)?;\n+                let (left, left_len) = this.operand_to_simd(left)?;\n+                let (right, right_len) = this.operand_to_simd(right)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                // `index` is an array, not a SIMD type\n+                let ty::Array(_, index_len) = index.layout.ty.kind() else {\n+                    span_bug!(this.cur_span(), \"simd_shuffle index argument has non-array type {}\", index.layout.ty)\n+                };\n+                let index_len = index_len.eval_usize(*this.tcx, this.param_env());\n+\n+                assert_eq!(left_len, right_len);\n+                assert_eq!(index_len, dest_len);\n+\n+                for i in 0..dest_len {\n+                    let src_index: u64 = this\n+                        .read_immediate(&this.operand_index(index, i)?)?\n+                        .to_scalar()?\n+                        .to_u32()?\n+                        .into();\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if src_index < left_len {\n+                        this.read_immediate(&this.mplace_index(&left, src_index)?.into())?\n+                    } else if src_index < left_len.checked_add(right_len).unwrap() {\n+                        this.read_immediate(\n+                            &this.mplace_index(&right, src_index - left_len)?.into(),\n+                        )?\n+                    } else {\n+                        span_bug!(\n+                            this.cur_span(),\n+                            \"simd_shuffle index {src_index} is out of bounds for 2 vectors of size {left_len}\",\n+                        );\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"gather\" => {\n+                let [passthru, ptrs, mask] = check_arg_count(args)?;\n+                let (passthru, passthru_len) = this.operand_to_simd(passthru)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+                let (dest, dest_len) = this.place_to_simd(dest)?;\n+\n+                assert_eq!(dest_len, passthru_len);\n+                assert_eq!(dest_len, ptrs_len);\n+                assert_eq!(dest_len, mask_len);\n+\n+                for i in 0..dest_len {\n+                    let passthru = this.read_immediate(&this.mplace_index(&passthru, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+                    let dest = this.mplace_index(&dest, i)?;\n+\n+                    let val = if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.read_immediate(&place.into())?\n+                    } else {\n+                        passthru\n+                    };\n+                    this.write_immediate(*val, &dest.into())?;\n+                }\n+            }\n+            \"scatter\" => {\n+                let [value, ptrs, mask] = check_arg_count(args)?;\n+                let (value, value_len) = this.operand_to_simd(value)?;\n+                let (ptrs, ptrs_len) = this.operand_to_simd(ptrs)?;\n+                let (mask, mask_len) = this.operand_to_simd(mask)?;\n+\n+                assert_eq!(ptrs_len, value_len);\n+                assert_eq!(ptrs_len, mask_len);\n+\n+                for i in 0..ptrs_len {\n+                    let value = this.read_immediate(&this.mplace_index(&value, i)?.into())?;\n+                    let ptr = this.read_immediate(&this.mplace_index(&ptrs, i)?.into())?;\n+                    let mask = this.read_immediate(&this.mplace_index(&mask, i)?.into())?;\n+\n+                    if simd_element_to_bool(mask)? {\n+                        let place = this.deref_operand(&ptr.into())?;\n+                        this.write_immediate(*value, &place.into())?;\n+                    }\n+                }\n+            }\n+            \"bitmask\" => {\n+                let [op] = check_arg_count(args)?;\n+                let (op, op_len) = this.operand_to_simd(op)?;\n+                let bitmask_len = op_len.max(8);\n+\n+                assert!(dest.layout.ty.is_integral());\n+                assert!(bitmask_len <= 64);\n+                assert_eq!(bitmask_len, dest.layout.size.bits());\n+\n+                let mut res = 0u64;\n+                for i in 0..op_len {\n+                    let op = this.read_immediate(&this.mplace_index(&op, i)?.into())?;\n+                    if simd_element_to_bool(op)? {\n+                        res |= 1 << simd_bitmask_index(i, op_len, this.data_layout().endian);\n+                    }\n+                }\n+                this.write_int(res, dest)?;\n+            }\n+\n+            name => throw_unsup_format!(\"unimplemented intrinsic: `simd_{name}`\"),\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+    // SIMD uses all-1 as pattern for \"true\"\n+    let val = if b { -1 } else { 0 };\n+    Scalar::from_int(val, size)\n+}\n+\n+fn simd_element_to_bool(elem: ImmTy<'_, Tag>) -> InterpResult<'_, bool> {\n+    let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n+    Ok(match val {\n+        0 => false,\n+        -1 => true,\n+        _ => throw_ub_format!(\"each element of a SIMD mask must be all-0-bits or all-1-bits\"),\n+    })\n+}\n+\n+fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n+    assert!(idx < vec_len);\n+    match endianess {\n+        Endian::Little => idx,\n+        Endian::Big => vec_len - 1 - idx, // reverse order of bits\n+    }\n+}\n+\n+fn fmax_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmax operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.max(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.max(right.to_f64()?)),\n+    })\n+}\n+\n+fn fmin_op<'tcx>(\n+    left: &ImmTy<'tcx, Tag>,\n+    right: &ImmTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, Scalar<Tag>> {\n+    assert_eq!(left.layout.ty, right.layout.ty);\n+    let ty::Float(float_ty) = left.layout.ty.kind() else {\n+        bug!(\"fmin operand is not a float\")\n+    };\n+    let left = left.to_scalar()?;\n+    let right = right.to_scalar()?;\n+    Ok(match float_ty {\n+        FloatTy::F32 => Scalar::from_f32(left.to_f32()?.min(right.to_f32()?)),\n+        FloatTy::F64 => Scalar::from_f64(left.to_f64()?.min(right.to_f64()?)),\n+    })\n+}"}]}