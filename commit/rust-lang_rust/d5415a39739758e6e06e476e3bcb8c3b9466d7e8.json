{"sha": "d5415a39739758e6e06e476e3bcb8c3b9466d7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NDE1YTM5NzM5NzU4ZTZlMDZlNDc2ZTNiY2I4YzNiOTQ2NmQ3ZTg=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2011-10-29T03:33:56Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2011-10-29T03:33:58Z"}, "message": "Remove iter and 'for each' from the documentation", "tree": {"sha": "8df8eae3006617ca72a983df3398d35b9acfdf58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8df8eae3006617ca72a983df3398d35b9acfdf58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5415a39739758e6e06e476e3bcb8c3b9466d7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5415a39739758e6e06e476e3bcb8c3b9466d7e8", "html_url": "https://github.com/rust-lang/rust/commit/d5415a39739758e6e06e476e3bcb8c3b9466d7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5415a39739758e6e06e476e3bcb8c3b9466d7e8/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6864070b24d231237ee3ec5f05afd95dfee10cbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6864070b24d231237ee3ec5f05afd95dfee10cbb", "html_url": "https://github.com/rust-lang/rust/commit/6864070b24d231237ee3ec5f05afd95dfee10cbb"}], "stats": {"total": 104, "additions": 7, "deletions": 97}, "files": [{"sha": "2a5a7c89249115e4fe17cb888789a48b4a5c0fd6", "filename": "doc/rust.texi", "status": "modified", "additions": 7, "deletions": 97, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d5415a39739758e6e06e476e3bcb8c3b9466d7e8/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/d5415a39739758e6e06e476e3bcb8c3b9466d7e8/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=d5415a39739758e6e06e476e3bcb8c3b9466d7e8", "patch": "@@ -656,16 +656,16 @@ The keywords are:\n @tab @code{str}\n @tab @code{with}\n @tab @code{fn}\n-@item @code{iter}\n-@tab @code{pure}\n+@item @code{pure}\n @tab @code{obj}\n @tab @code{resource}\n @tab @code{if}\n-@item @code{else}\n-@tab @code{alt}\n+@tab @code{else}\n+@item @code{alt}\n @tab @code{in}\n @tab @code{do}\n @tab @code{while}\n+@tab @code{for}\n @item @code{break}\n @tab @code{cont}\n @tab @code{note}\n@@ -674,10 +674,7 @@ The keywords are:\n @item @code{check}\n @tab @code{prove}\n @tab @code{fail}\n-@tab @code{for}\n-@tab @code{each}\n-@item @code{ret}\n-@tab @code{put}\n+@tab @code{ret}\n @tab @code{be}\n @end multitable\n \n@@ -1688,7 +1685,6 @@ context. There are no general parametric types.\n * Ref.Item.Mod::                Items defining modules.\n * Ref.Item.Fn::                 Items defining functions.\n * Ref.Item.Pred::               Items defining predicates for typestates.\n-* Ref.Item.Iter::               Items defining iterators.\n * Ref.Item.Obj::                Items defining objects.\n * Ref.Item.Type::               Items defining the types of values and slots.\n * Ref.Item.Tag::                Items defining the constructors of a tag type.\n@@ -1970,48 +1966,6 @@ argument @code{f} is a pure function. So, to use @code{foldl} in a pure list\n length function that a predicate could then use, we must use an\n @code{unchecked} block wrapped around the call to @code{pure_foldl} in the\n definition of @code{pure_length}.\n- \n-@node          Ref.Item.Iter\n-@subsection    Ref.Item.Iter\n-@c * Ref.Item.Iter::          Items defining iterators.\n-\n-@cindex Iterators\n-@cindex Put expression\n-@cindex Put each expression\n-@cindex Foreach expression\n-\n-Iterators are function-like items that can @code{put} multiple values during\n-their execution before returning.\n-\n-Putting a value is similar to returning a value -- the argument to @code{put}\n-is copied into the caller's frame and control transfers back to the caller --\n-but the iterator frame is only @emph{suspended} during the put, and will be\n-@emph{resumed} at the point after the @code{put}, on the next iteration of\n-the caller's loop.\n-\n-The output type of an iterator is the type of value that the function will\n-@code{put}, before it eventually evaluates a @code{ret} or @code{be} expression\n-of type @code{()} and completes its execution.\n-\n-An iterator can be called only in the loop header of a matching @code{for\n-each} loop or as the argument in a @code{put each} expression.\n-@xref{Ref.Expr.Foreach}.\n-\n-An example of an iterator:\n-@example\n-iter range(lo: int, hi: int) -> int @{\n-    let i: int = lo;\n-    while (i < hi) @{\n-        put i;\n-        i = i + 1;\n-    @}\n-@}\n-\n-let sum: int = 0;\n-for each x: int in range(0,100) @{\n-    sum += x;\n-@}\n-@end example\n \n \n @node       Ref.Item.Obj\n@@ -2165,7 +2119,6 @@ Rust; they cannot be used as user-defined identifiers in any context.\n * Ref.Type.Vec::                Open products of homogeneous types.\n * Ref.Type.Tag::                Disjoint unions of heterogeneous types.\n * Ref.Type.Fn::                 Subroutine types.\n-* Ref.Type.Iter::               Scoped coroutine types.\n * Ref.Type.Obj::                Abstract types.\n * Ref.Type.Constr::             Constrained types.\n * Ref.Type.Type::               Types describing types.\n@@ -2447,28 +2400,6 @@ let bo: binop = add;\n x = bo(5,7);\n @end example\n \n-@node       Ref.Type.Iter\n-@subsection Ref.Type.Iter\n-@cindex Iterator types\n-\n-The iterator type-constructor @code{iter} forms new iterator types. An\n-iterator type consists a sequence of input slots, an optional set of input\n-constraints and an output slot. @xref{Ref.Item.Iter}.\n-\n-An example of an @code{iter} type:\n-@example\n-iter range(x: int, y: int) -> int @{\n-  while (x < y) @{\n-    put x;\n-    x += 1;\n-  @}\n-@}\n-\n-for each i: int in range(5,7) @{\n-  @dots{};\n-@}\n-@end example\n-\n @node       Ref.Type.Obj\n @subsection Ref.Type.Obj\n @c * Ref.Type.Obj::                Object types.\n@@ -2938,7 +2869,6 @@ effects of the expression's evaluation.\n * Ref.Expr.Break::              Expression for terminating a loop.\n * Ref.Expr.Cont::               Expression for terminating a single loop iteration.\n * Ref.Expr.For::                Expression for looping over strings and vectors.\n-* Ref.Expr.Foreach::            Expression for looping via an iterator.\n * Ref.Expr.If::                 Expression for simple conditional branching.\n * Ref.Expr.Alt::                Expression for complex conditional branching.\n * Ref.Expr.Prove::              Expression for static assertion of typestate.\n@@ -3197,8 +3127,8 @@ fn read_file_lines(path: str) -> [str] @{\n     note path;\n     let r: [str];\n     let f: file = open_read(path);\n-    for each s: str in lines(f) @{\n-        vec::append(r,s);\n+    lines(f) @{|s|\n+        r += [s];\n     @}\n     ret r;\n @}\n@@ -3301,26 +3231,6 @@ for e: foo in v @{\n @}\n @end example\n \n-@node          Ref.Expr.Foreach\n-@subsection    Ref.Expr.Foreach\n-@c * Ref.Expr.Foreach::           Expression for general conditional looping.\n-@cindex Foreach expression\n-@cindex Loops\n-@cindex Control-flow\n-\n-An @dfn{foreach loop} is denoted by the @code{for each} keywords, and is\n-controlled by an iterator. The loop executes once for each value @code{put} by\n-the iterator.  When the iterator returns or fails, the loop terminates.\n-\n-Example of a foreach loop:\n-@example\n-let txt: str;\n-let lines: [str];\n-for each s: str in str::split(txt, \"\\n\") @{\n-    vec::push(lines, s);\n-@}\n-@end example\n-\n \n @node       Ref.Expr.If\n @subsection Ref.Expr.If"}]}