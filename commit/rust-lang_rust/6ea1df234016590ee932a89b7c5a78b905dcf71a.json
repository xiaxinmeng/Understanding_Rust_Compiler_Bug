{"sha": "6ea1df234016590ee932a89b7c5a78b905dcf71a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYTFkZjIzNDAxNjU5MGVlOTMyYTg5YjdjNWE3OGI5MDVkY2Y3MWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-29T21:57:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-29T21:57:34Z"}, "message": "Rollup merge of #66791 - cjgillot:arena, r=Mark-Simulacrum\n\nHandle GlobalCtxt directly from librustc_interface query system\n\nThis PR constructs the `GlobalCtxt` as a member of the `Queries` in librustc_interface.\nThis simplifies the code to construct it, at the expense of added complexity in the query control flow.\nThis allows to handle the arenas directly from librustc_interface.\n\nBased on #66707\n\nr? @Zoxc", "tree": {"sha": "47bedbd9aec458db1e8d5a3007fe503f8dede277", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47bedbd9aec458db1e8d5a3007fe503f8dede277"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ea1df234016590ee932a89b7c5a78b905dcf71a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd4ZRPCRBK7hj4Ov3rIwAAdHIIAFgCI4k3WN1X9m73JFDtnOeW\n6K9gXGl8T/6hBiYgS0dRDqnhSEGTf/4C2s3jLPt1o5rzZVTrpdd0MXwcaLSKoRyG\nN4vkff4546osBlRfPiuershlfO96BNQEjuK5UNp7PwAqk+Z8XcA8aNo5Ok90XAG8\nB5DiKw4IBwrZ9Mdq0A+sOTskPE1INaTuCvR6Vj5/i13fk2GNiELK7+uahmXgIpSK\nCR3tnge3cyCF8j5juzRDPB0kU/GTi5BUBLZ/9dZdZB7NwzFk5A6TWtjJ9DTWQaD1\noBPzewiPqz6myuDhkQTZlSVVhrNyMLbLKwLiVVpXOJM0YL8O2GZ2MMCaedKQ0qw=\n=fve0\n-----END PGP SIGNATURE-----\n", "payload": "tree 47bedbd9aec458db1e8d5a3007fe503f8dede277\nparent 56203be06f3671ce73d5634bf5c098eb3b8b1c1c\nparent 1e12f39d83eeddd523e384e20ab4f1fa56eb8888\nauthor Ralf Jung <post@ralfj.de> 1575064654 +0100\ncommitter GitHub <noreply@github.com> 1575064654 +0100\n\nRollup merge of #66791 - cjgillot:arena, r=Mark-Simulacrum\n\nHandle GlobalCtxt directly from librustc_interface query system\n\nThis PR constructs the `GlobalCtxt` as a member of the `Queries` in librustc_interface.\nThis simplifies the code to construct it, at the expense of added complexity in the query control flow.\nThis allows to handle the arenas directly from librustc_interface.\n\nBased on #66707\n\nr? @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea1df234016590ee932a89b7c5a78b905dcf71a", "html_url": "https://github.com/rust-lang/rust/commit/6ea1df234016590ee932a89b7c5a78b905dcf71a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ea1df234016590ee932a89b7c5a78b905dcf71a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56203be06f3671ce73d5634bf5c098eb3b8b1c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/56203be06f3671ce73d5634bf5c098eb3b8b1c1c", "html_url": "https://github.com/rust-lang/rust/commit/56203be06f3671ce73d5634bf5c098eb3b8b1c1c"}, {"sha": "1e12f39d83eeddd523e384e20ab4f1fa56eb8888", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e12f39d83eeddd523e384e20ab4f1fa56eb8888", "html_url": "https://github.com/rust-lang/rust/commit/1e12f39d83eeddd523e384e20ab4f1fa56eb8888"}], "stats": {"total": 584, "additions": 328, "deletions": 256}, "files": [{"sha": "193b04eabb3fb77ed56be2e586fccd61f763e48b", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -93,6 +93,7 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] hir_forest: rustc::hir::map::Forest,\n             [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n                 syntax::symbol::Symbol,\n                 rustc::hir::def_id::DefId,"}, {"sha": "5bf5a93ad010271833671248ea41dbb6916ef412", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -200,7 +200,7 @@ pub struct Map<'hir> {\n \n     map: HirEntryMap<'hir>,\n \n-    definitions: &'hir Definitions,\n+    definitions: Definitions,\n \n     /// The reverse mapping of `node_to_hir_id`.\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n@@ -267,8 +267,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn definitions(&self) -> &'hir Definitions {\n-        self.definitions\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n@@ -1251,7 +1251,7 @@ impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n                        forest: &'hir Forest,\n-                       definitions: &'hir Definitions)\n+                       definitions: Definitions)\n                        -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n \n@@ -1260,7 +1260,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,"}, {"sha": "0b6937975aae1462c64eecb4c52f2811b227312d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> Deref for TyCtxt<'tcx> {\n }\n \n pub struct GlobalCtxt<'tcx> {\n-    pub arena: WorkerLocal<Arena<'tcx>>,\n+    pub arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n     interners: CtxtInterners<'tcx>,\n \n@@ -1170,6 +1170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n+        arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n@@ -1225,7 +1226,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             sess: s,\n             lint_store,\n             cstore,\n-            arena: WorkerLocal::new(|_| Arena::default()),\n+            arena,\n             interners,\n             dep_graph,\n             prof: s.prof.clone(),"}, {"sha": "c945de8f1e1dc56020a9449523fa0cd1f0fe1c56", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 99, "deletions": 92, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -283,120 +283,127 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        compiler.parse()?;\n-\n-        if let Some(ppm) = &sess.opts.pretty {\n-            if ppm.needs_ast_map() {\n-                compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                    let expanded_crate = compiler.expansion()?.take().0;\n-                    pretty::print_after_hir_lowering(\n-                        tcx,\n-                        compiler.input(),\n-                        &expanded_crate,\n+        let linker = compiler.enter(|queries| {\n+            let early_exit = || sess.compile_status().map(|_| None);\n+            queries.parse()?;\n+\n+            if let Some(ppm) = &sess.opts.pretty {\n+                if ppm.needs_ast_map() {\n+                    queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                        let expanded_crate = queries.expansion()?.take().0;\n+                        pretty::print_after_hir_lowering(\n+                            tcx,\n+                            compiler.input(),\n+                            &expanded_crate,\n+                            *ppm,\n+                            compiler.output_file().as_ref().map(|p| &**p),\n+                        );\n+                        Ok(())\n+                    })?;\n+                } else {\n+                    let krate = queries.parse()?.take();\n+                    pretty::print_after_parsing(\n+                        sess,\n+                        &compiler.input(),\n+                        &krate,\n                         *ppm,\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n-                    Ok(())\n-                })?;\n-            } else {\n-                let krate = compiler.parse()?.take();\n-                pretty::print_after_parsing(\n-                    sess,\n-                    &compiler.input(),\n-                    &krate,\n-                    *ppm,\n-                    compiler.output_file().as_ref().map(|p| &**p),\n-                );\n+                }\n+                return early_exit();\n             }\n-            return sess.compile_status();\n-        }\n \n-        if callbacks.after_parsing(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            if callbacks.after_parsing(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        if sess.opts.debugging_opts.parse_only ||\n-           sess.opts.debugging_opts.show_span.is_some() ||\n-           sess.opts.debugging_opts.ast_json_noexpand {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.parse_only ||\n+               sess.opts.debugging_opts.show_span.is_some() ||\n+               sess.opts.debugging_opts.ast_json_noexpand {\n+               return early_exit();\n+            }\n \n-        {\n-            let (_, lint_store) = &*compiler.register_plugins()?.peek();\n+            {\n+                let (_, lint_store) = &*queries.register_plugins()?.peek();\n \n-            // Lint plugins are registered; now we can process command line flags.\n-            if sess.opts.describe_lints {\n-                describe_lints(&sess, &lint_store, true);\n-                return sess.compile_status();\n+                // Lint plugins are registered; now we can process command line flags.\n+                if sess.opts.describe_lints {\n+                    describe_lints(&sess, &lint_store, true);\n+                    return early_exit();\n+                }\n             }\n-        }\n \n-        compiler.expansion()?;\n-        if callbacks.after_expansion(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            queries.expansion()?;\n+            if callbacks.after_expansion(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        compiler.prepare_outputs()?;\n+            queries.prepare_outputs()?;\n \n-        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-            && sess.opts.output_types.len() == 1\n-        {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+                && sess.opts.output_types.len() == 1\n+            {\n+                return early_exit();\n+            }\n \n-        compiler.global_ctxt()?;\n+            queries.global_ctxt()?;\n \n-        if sess.opts.debugging_opts.no_analysis ||\n-           sess.opts.debugging_opts.ast_json {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.no_analysis ||\n+               sess.opts.debugging_opts.ast_json {\n+                   return early_exit();\n+            }\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            let expanded_crate = &compiler.expansion()?.peek().0;\n-            let crate_name = compiler.crate_name()?.peek().clone();\n-            compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                let result = tcx.analysis(LOCAL_CRATE);\n-\n-                time(sess, \"save analysis\", || {\n-                    save::process_crate(\n-                        tcx,\n-                        &expanded_crate,\n-                        &crate_name,\n-                        &compiler.input(),\n-                        None,\n-                        DumpHandler::new(compiler.output_dir().as_ref().map(|p| &**p), &crate_name)\n-                    )\n-                });\n-\n-                result\n-                // AST will be dropped *after* the `after_analysis` callback\n-                // (needed by the RLS)\n-            })?;\n-        } else {\n-            // Drop AST after creating GlobalCtxt to free memory\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            if sess.opts.debugging_opts.save_analysis {\n+                let expanded_crate = &queries.expansion()?.peek().0;\n+                let crate_name = queries.crate_name()?.peek().clone();\n+                queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let result = tcx.analysis(LOCAL_CRATE);\n+\n+                    time(sess, \"save analysis\", || {\n+                        save::process_crate(\n+                            tcx,\n+                            &expanded_crate,\n+                            &crate_name,\n+                            &compiler.input(),\n+                            None,\n+                            DumpHandler::new(\n+                                compiler.output_dir().as_ref().map(|p| &**p), &crate_name\n+                            )\n+                        )\n+                    });\n \n-        compiler.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+                    result\n+                    // AST will be dropped *after* the `after_analysis` callback\n+                    // (needed by the RLS)\n+                })?;\n+            } else {\n+                // Drop AST after creating GlobalCtxt to free memory\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        if callbacks.after_analysis(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            if callbacks.after_analysis(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        compiler.ongoing_codegen()?;\n+            if sess.opts.debugging_opts.save_analysis {\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        // Drop GlobalCtxt after starting codegen to free memory\n-        mem::drop(compiler.global_ctxt()?.take());\n+            queries.ongoing_codegen()?;\n \n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.print_type_sizes();\n-        }\n+            if sess.opts.debugging_opts.print_type_sizes {\n+                sess.code_stats.print_type_sizes();\n+            }\n \n-        compiler.link()?;\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n+\n+        if let Some(linker) = linker {\n+            linker.link()?\n+        }\n \n         if sess.opts.debugging_opts.perf_stats {\n             sess.print_perf_stats();"}, {"sha": "beb2465bd4a1a2ac5182667b2c8bdd9520f39dde", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -1,4 +1,3 @@\n-use crate::queries::Queries;\n use crate::util;\n pub use crate::passes::BoxedResolver;\n \n@@ -36,7 +35,6 @@ pub struct Compiler {\n     pub(crate) input_path: Option<PathBuf>,\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n-    pub(crate) queries: Queries,\n     pub(crate) crate_name: Option<String>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n@@ -169,7 +167,6 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n         input_path: config.input_path,\n         output_dir: config.output_dir,\n         output_file: config.output_file,\n-        queries: Default::default(),\n         crate_name: config.crate_name,\n         register_lints: config.register_lints,\n         override_queries: config.override_queries,"}, {"sha": "e953a64f1906f952117bd90c1acb50a477b27f28", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -3,6 +3,7 @@ use crate::util;\n use crate::proc_macro_decls;\n \n use log::{info, warn, log_enabled};\n+use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::lowering::lower_crate;\n@@ -22,7 +23,7 @@ use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n-use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n+use rustc_data_structures::sync::{Lrc, Once, ParallelIterator, par_iter, WorkerLocal};\n use rustc_errors::PResult;\n use rustc_incremental;\n use rustc_mir as mir;\n@@ -739,93 +740,77 @@ pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n     rustc_codegen_ssa::provide_extern(providers);\n }\n \n-declare_box_region_type!(\n-    pub BoxedGlobalCtxt,\n-    for('tcx),\n-    (&'tcx GlobalCtxt<'tcx>) -> ((), ())\n-);\n+pub struct QueryContext<'tcx>(&'tcx GlobalCtxt<'tcx>);\n \n-impl BoxedGlobalCtxt {\n+impl<'tcx> QueryContext<'tcx> {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+        F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n+        ty::tls::enter_global(self.0, |tcx| f(tcx))\n+    }\n+\n+    pub fn print_stats(&self) {\n+        self.0.queries.print_stats()\n     }\n }\n \n-pub fn create_global_ctxt(\n-    compiler: &Compiler,\n+pub fn create_global_ctxt<'tcx>(\n+    compiler: &'tcx Compiler,\n     lint_store: Lrc<lint::LintStore>,\n-    mut hir_forest: hir::map::Forest,\n+    hir_forest: &'tcx hir::map::Forest,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n-) -> BoxedGlobalCtxt {\n-    let sess = compiler.session().clone();\n-    let codegen_backend = compiler.codegen_backend().clone();\n-    let crate_name = crate_name.to_string();\n+    global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n+    all_arenas: &'tcx AllArenas,\n+    arena: &'tcx WorkerLocal<Arena<'tcx>>,\n+) -> QueryContext<'tcx> {\n+    let sess = &compiler.session();\n     let defs = mem::take(&mut resolver_outputs.definitions);\n-    let override_queries = compiler.override_queries;\n-\n-    let ((), result) = BoxedGlobalCtxt::new(static move || {\n-        let sess = &*sess;\n-\n-        let global_ctxt: Option<GlobalCtxt<'_>>;\n-        let arenas = AllArenas::new();\n-\n-        // Construct the HIR map.\n-        let hir_map = time(sess, \"indexing HIR\", || {\n-            hir::map::map_crate(sess, &*resolver_outputs.cstore, &mut hir_forest, &defs)\n-        });\n-\n-        let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n-            rustc_incremental::load_query_result_cache(sess)\n-        });\n \n-        let mut local_providers = ty::query::Providers::default();\n-        default_provide(&mut local_providers);\n-        codegen_backend.provide(&mut local_providers);\n+    // Construct the HIR map.\n+    let hir_map = time(sess, \"indexing HIR\", || {\n+        hir::map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs)\n+    });\n \n-        let mut extern_providers = local_providers;\n-        default_provide_extern(&mut extern_providers);\n-        codegen_backend.provide_extern(&mut extern_providers);\n+    let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n+        rustc_incremental::load_query_result_cache(sess)\n+    });\n \n-        if let Some(callback) = override_queries {\n-            callback(sess, &mut local_providers, &mut extern_providers);\n-        }\n+    let codegen_backend = compiler.codegen_backend();\n+    let mut local_providers = ty::query::Providers::default();\n+    default_provide(&mut local_providers);\n+    codegen_backend.provide(&mut local_providers);\n \n-        let gcx = TyCtxt::create_global_ctxt(\n-            sess,\n-            lint_store,\n-            local_providers,\n-            extern_providers,\n-            &arenas,\n-            resolver_outputs,\n-            hir_map,\n-            query_result_on_disk_cache,\n-            &crate_name,\n-            &outputs\n-        );\n+    let mut extern_providers = local_providers;\n+    default_provide_extern(&mut extern_providers);\n+    codegen_backend.provide_extern(&mut extern_providers);\n \n-        global_ctxt = Some(gcx);\n-        let gcx = global_ctxt.as_ref().unwrap();\n-\n-        ty::tls::enter_global(gcx, |tcx| {\n-            // Do some initialization of the DepGraph that can only be done with the\n-            // tcx available.\n-            time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n-        });\n+    if let Some(callback) = compiler.override_queries {\n+        callback(sess, &mut local_providers, &mut extern_providers);\n+    }\n \n-        yield BoxedGlobalCtxt::initial_yield(());\n-        box_region_allow_access!(for('tcx), (&'tcx GlobalCtxt<'tcx>), (gcx));\n+    let gcx = global_ctxt.init_locking(|| TyCtxt::create_global_ctxt(\n+        sess,\n+        lint_store,\n+        local_providers,\n+        extern_providers,\n+        &all_arenas,\n+        arena,\n+        resolver_outputs,\n+        hir_map,\n+        query_result_on_disk_cache,\n+        &crate_name,\n+        &outputs\n+    ));\n \n-        if sess.opts.debugging_opts.query_stats {\n-            gcx.queries.print_stats();\n-        }\n+    // Do some initialization of the DepGraph that can only be done with the tcx available.\n+    ty::tls::enter_global(&gcx, |tcx| {\n+        time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n     });\n \n-    result\n+    QueryContext(gcx)\n }\n \n /// Runs the resolution, type-checking, region checking and other"}, {"sha": "6103d42c5dbcbb9e9ffed311f70bb393d2ca318e", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 142, "deletions": 69, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -1,17 +1,19 @@\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt};\n+use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_incremental::DepGraphFuture;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::util::common::{time, ErrorReported};\n+use rustc::arena::Arena;\n use rustc::hir;\n use rustc::lint;\n use rustc::session::Session;\n use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n-use rustc::ty::ResolverOutputs;\n+use rustc::ty::{AllArenas, ResolverOutputs, GlobalCtxt};\n use rustc::dep_graph::DepGraph;\n use std::cell::{Ref, RefMut, RefCell};\n use std::rc::Rc;\n@@ -44,13 +46,6 @@ impl<T> Query<T> {\n             .unwrap()\n     }\n \n-    /// Returns a stolen query result. Panics if there's already a result.\n-    pub fn give(&self, value: T) {\n-        let mut result = self.result.borrow_mut();\n-        assert!(result.is_none(), \"a result already exists\");\n-        *result = Some(Ok(value));\n-    }\n-\n     /// Borrows the query result using the RefCell. Panics if the result is stolen.\n     pub fn peek(&self) -> Ref<'_, T> {\n         Ref::map(self.result.borrow(), |r| {\n@@ -74,24 +69,54 @@ impl<T> Default for Query<T> {\n     }\n }\n \n-#[derive(Default)]\n-pub(crate) struct Queries {\n+pub struct Queries<'tcx> {\n+    compiler: &'tcx Compiler,\n+    gcx: Once<GlobalCtxt<'tcx>>,\n+\n+    all_arenas: AllArenas,\n+    arena: WorkerLocal<Arena<'tcx>>,\n+\n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>,\n+    lower_to_hir: Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n-    global_ctxt: Query<BoxedGlobalCtxt>,\n+    global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n-    link: Query<()>,\n }\n \n-impl Compiler {\n+impl<'tcx> Queries<'tcx> {\n+    pub fn new(compiler: &'tcx Compiler) -> Queries<'tcx> {\n+        Queries {\n+            compiler,\n+            gcx: Once::new(),\n+            all_arenas: AllArenas::new(),\n+            arena: WorkerLocal::new(|_| Arena::default()),\n+            dep_graph_future: Default::default(),\n+            parse: Default::default(),\n+            crate_name: Default::default(),\n+            register_plugins: Default::default(),\n+            expansion: Default::default(),\n+            dep_graph: Default::default(),\n+            lower_to_hir: Default::default(),\n+            prepare_outputs: Default::default(),\n+            global_ctxt: Default::default(),\n+            ongoing_codegen: Default::default(),\n+        }\n+    }\n+\n+    fn session(&self) -> &Lrc<Session> {\n+        &self.compiler.sess\n+    }\n+    fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n+        &self.compiler.codegen_backend()\n+    }\n+\n     pub fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n-        self.queries.dep_graph_future.compute(|| {\n+        self.dep_graph_future.compute(|| {\n             Ok(if self.session().opts.build_dep_graph() {\n                 Some(rustc_incremental::load_dep_graph(self.session()))\n             } else {\n@@ -101,8 +126,8 @@ impl Compiler {\n     }\n \n     pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n-        self.queries.parse.compute(|| {\n-            passes::parse(self.session(), &self.input).map_err(\n+        self.parse.compute(|| {\n+            passes::parse(self.session(), &self.compiler.input).map_err(\n                 |mut parse_error| {\n                     parse_error.emit();\n                     ErrorReported\n@@ -112,15 +137,15 @@ impl Compiler {\n     }\n \n     pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n-        self.queries.register_plugins.compute(|| {\n+        self.register_plugins.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n             let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),\n-                self.register_lints\n+                self.compiler.register_lints\n                     .as_ref()\n                     .map(|p| &**p)\n                     .unwrap_or_else(|| empty),\n@@ -140,16 +165,16 @@ impl Compiler {\n     }\n \n     pub fn crate_name(&self) -> Result<&Query<String>> {\n-        self.queries.crate_name.compute(|| {\n-            Ok(match self.crate_name {\n+        self.crate_name.compute(|| {\n+            Ok(match self.compiler.crate_name {\n                 Some(ref crate_name) => crate_name.clone(),\n                 None => {\n                     let parse_result = self.parse()?;\n                     let krate = parse_result.peek();\n                     rustc_codegen_utils::link::find_crate_name(\n                         Some(self.session()),\n                         &krate.attrs,\n-                        &self.input\n+                        &self.compiler.input\n                     )\n                 }\n             })\n@@ -159,11 +184,11 @@ impl Compiler {\n     pub fn expansion(\n         &self\n     ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n-        self.queries.expansion.compute(|| {\n+        self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             passes::configure_and_expand(\n-                self.sess.clone(),\n+                self.session().clone(),\n                 lint_store.clone(),\n                 self.codegen_backend().metadata_loader(),\n                 krate,\n@@ -175,7 +200,7 @@ impl Compiler {\n     }\n \n     pub fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n-        self.queries.dep_graph.compute(|| {\n+        self.dep_graph.compute(|| {\n             Ok(match self.dep_graph_future()?.take() {\n                 None => DepGraph::new_disabled(),\n                 Some(future) => {\n@@ -192,57 +217,63 @@ impl Compiler {\n     }\n \n     pub fn lower_to_hir(\n-        &self,\n-    ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n-        self.queries.lower_to_hir.compute(|| {\n+        &'tcx self,\n+    ) -> Result<&Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>> {\n+        self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n             let lint_store = &peeked.2;\n-            let hir = Steal::new(resolver.borrow_mut().access(|resolver| {\n+            let hir = resolver.borrow_mut().access(|resolver| {\n                 passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate\n                 )\n-            })?);\n+            })?;\n+            let hir = self.arena.alloc(hir);\n             Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n-        self.queries.prepare_outputs.compute(|| {\n+        self.prepare_outputs.compute(|| {\n             let expansion_result = self.expansion()?;\n             let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n+            passes::prepare_outputs(\n+                self.session(), self.compiler, &krate, &boxed_resolver, &crate_name\n+            )\n         })\n     }\n \n-    pub fn global_ctxt(&self) -> Result<&Query<BoxedGlobalCtxt>> {\n-        self.queries.global_ctxt.compute(|| {\n+    pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n+        self.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n             let lint_store = self.expansion()?.peek().2.clone();\n-            let hir = self.lower_to_hir()?;\n-            let hir = hir.peek();\n-            let (hir_forest, resolver_outputs) = &*hir;\n+            let hir = self.lower_to_hir()?.peek();\n+            let (ref hir_forest, ref resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n-                self,\n+                self.compiler,\n                 lint_store,\n-                hir_forest.steal(),\n+                hir_forest,\n                 resolver_outputs.steal(),\n                 outputs,\n-                &crate_name))\n+                &crate_name,\n+                &self.gcx,\n+                &self.all_arenas,\n+                &self.arena,\n+            ))\n         })\n     }\n \n-    pub fn ongoing_codegen(&self) -> Result<&Query<Box<dyn Any>>> {\n-        self.queries.ongoing_codegen.compute(|| {\n+    pub fn ongoing_codegen(&'tcx self) -> Result<&Query<Box<dyn Any>>> {\n+        self.ongoing_codegen.compute(|| {\n             let outputs = self.prepare_outputs()?;\n             self.global_ctxt()?.peek_mut().enter(|tcx| {\n                 tcx.analysis(LOCAL_CRATE).ok();\n@@ -259,47 +290,89 @@ impl Compiler {\n         })\n     }\n \n-    pub fn link(&self) -> Result<&Query<()>> {\n-        self.queries.link.compute(|| {\n-            let sess = self.session();\n-\n-            let ongoing_codegen = self.ongoing_codegen()?.take();\n+    pub fn linker(&'tcx self) -> Result<Linker> {\n+        let dep_graph = self.dep_graph()?;\n+        let prepare_outputs = self.prepare_outputs()?;\n+        let ongoing_codegen = self.ongoing_codegen()?;\n \n-            self.codegen_backend().join_codegen_and_link(\n-                ongoing_codegen,\n-                sess,\n-                &*self.dep_graph()?.peek(),\n-                &*self.prepare_outputs()?.peek(),\n-            ).map_err(|_| ErrorReported)?;\n+        let sess = self.session().clone();\n+        let codegen_backend = self.codegen_backend().clone();\n \n-            Ok(())\n+        Ok(Linker {\n+            sess,\n+            dep_graph: dep_graph.peek().clone(),\n+            prepare_outputs: prepare_outputs.take(),\n+            ongoing_codegen: ongoing_codegen.take(),\n+            codegen_backend,\n         })\n     }\n+}\n+\n+pub struct Linker {\n+    sess: Lrc<Session>,\n+    dep_graph: DepGraph,\n+    prepare_outputs: OutputFilenames,\n+    ongoing_codegen: Box<dyn Any>,\n+    codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n+}\n+\n+impl Linker {\n+    pub fn link(self) -> Result<()> {\n+        self.codegen_backend.join_codegen_and_link(\n+            self.ongoing_codegen,\n+            &self.sess,\n+            &self.dep_graph,\n+            &self.prepare_outputs,\n+        ).map_err(|_| ErrorReported)\n+    }\n+}\n+\n+impl Compiler {\n+    pub fn enter<F, T>(&self, f: F) -> T\n+        where F: for<'tcx> FnOnce(&'tcx Queries<'tcx>) -> T\n+    {\n+        let queries = Queries::new(&self);\n+        let ret = f(&queries);\n+\n+        if self.session().opts.debugging_opts.query_stats {\n+            if let Ok(gcx) = queries.global_ctxt() {\n+                gcx.peek().print_stats();\n+            }\n+        }\n+\n+        ret\n+    }\n \n     // This method is different to all the other methods in `Compiler` because\n     // it lacks a `Queries` entry. It's also not currently used. It does serve\n     // as an example of how `Compiler` can be used, with additional steps added\n     // between some passes. And see `rustc_driver::run_compiler` for a more\n     // complex example.\n     pub fn compile(&self) -> Result<()> {\n-        self.prepare_outputs()?;\n+        let linker = self.enter(|queries| {\n+            queries.prepare_outputs()?;\n \n-        if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n-            && self.session().opts.output_types.len() == 1\n-        {\n-            return Ok(())\n-        }\n+            if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n+                && self.session().opts.output_types.len() == 1\n+            {\n+                return Ok(None)\n+            }\n+\n+            queries.global_ctxt()?;\n \n-        self.global_ctxt()?;\n+            // Drop AST after creating GlobalCtxt to free memory.\n+            mem::drop(queries.expansion()?.take());\n \n-        // Drop AST after creating GlobalCtxt to free memory.\n-        mem::drop(self.expansion()?.take());\n+            queries.ongoing_codegen()?;\n \n-        self.ongoing_codegen()?;\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n \n-        // Drop GlobalCtxt after starting codegen to free memory.\n-        mem::drop(self.global_ctxt()?.take());\n+        if let Some(linker) = linker {\n+            linker.link()?\n+        }\n \n-        self.link().map(|_| ())\n+        Ok(())\n     }\n }"}, {"sha": "7d1f89079f8081aa85dd0d28255df6d4f3361bd4", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -343,25 +343,26 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         registry: rustc_driver::diagnostics_registry(),\n     };\n \n-    interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n+    interface::run_compiler_in_existing_thread_pool(config, |compiler| compiler.enter(|queries| {\n         let sess = compiler.session();\n \n         // We need to hold on to the complete resolver, so we cause everything to be\n         // cloned for the analysis passes to use. Suboptimal, but necessary in the\n         // current architecture.\n         let resolver = {\n-            let parts = abort_on_err(compiler.expansion(), sess).peek();\n+            let parts = abort_on_err(queries.expansion(), sess).peek();\n             let resolver = parts.1.borrow();\n \n             // Before we actually clone it, let's force all the extern'd crates to\n             // actually be loaded, just in case they're only referred to inside\n             // intra-doc-links\n             resolver.borrow_mut().access(|resolver| {\n                 for extern_name in &extern_names {\n-                    resolver.resolve_str_path_error(DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID)\n-                        .unwrap_or_else(\n-                            |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n-                        );\n+                    resolver.resolve_str_path_error(\n+                        DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID\n+                    ).unwrap_or_else(\n+                        |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n+                    );\n                 }\n             });\n \n@@ -373,7 +374,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let mut global_ctxt = abort_on_err(compiler.global_ctxt(), sess).take();\n+        let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n         global_ctxt.enter(|tcx| {\n             tcx.analysis(LOCAL_CRATE).ok();\n@@ -447,8 +448,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         },\n                         sym::plugins => {\n                             report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` no longer functions; \\\n-                                      see CVE-2018-1000622\");\n+                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                                      no longer functions; see CVE-2018-1000622\");\n                             continue\n                         },\n                         _ => continue,\n@@ -486,7 +487,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             (krate, ctxt.renderinfo.into_inner(), render_options)\n         })\n-    })\n+    }))\n }\n \n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter"}, {"sha": "d09eb0b2fc2639b059eaa6466263c513bb267794", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -85,14 +85,14 @@ pub fn run(options: Options) -> i32 {\n     let mut test_args = options.test_args.clone();\n     let display_warnings = options.display_warnings;\n \n-    let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n-        let lower_to_hir = compiler.lower_to_hir()?;\n+    let tests = interface::run_compiler(config, |compiler| compiler.enter(|queries| {\n+        let lower_to_hir = queries.lower_to_hir()?;\n \n-        let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n+        let mut opts = scrape_test_config(lower_to_hir.peek().0.krate());\n         opts.display_warnings |= options.display_warnings;\n         let enable_per_target_ignores = options.enable_per_target_ignores;\n         let mut collector = Collector::new(\n-            compiler.crate_name()?.peek().to_string(),\n+            queries.crate_name()?.peek().to_string(),\n             options,\n             false,\n             opts,\n@@ -101,7 +101,8 @@ pub fn run(options: Options) -> i32 {\n             enable_per_target_ignores,\n         );\n \n-        let mut global_ctxt = compiler.global_ctxt()?.take();\n+        let mut global_ctxt = queries.global_ctxt()?.take();\n+\n         global_ctxt.enter(|tcx| {\n             let krate = tcx.hir().krate();\n             let mut hir_collector = HirCollector {\n@@ -116,8 +117,9 @@ pub fn run(options: Options) -> i32 {\n             });\n         });\n \n-        Ok(collector.tests)\n-    }).expect(\"compiler aborted in rustdoc!\");\n+        let ret : Result<_, ErrorReported> = Ok(collector.tests);\n+        ret\n+    })).expect(\"compiler aborted in rustdoc!\");\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n "}, {"sha": "62a66aefd2deb2854d052d709b603908b9b1fc5a", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ea1df234016590ee932a89b7c5a78b905dcf71a/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=6ea1df234016590ee932a89b7c5a78b905dcf71a", "patch": "@@ -66,6 +66,11 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n \n     interface::run_compiler(config, |compiler| {\n         // This runs all the passes prior to linking, too.\n-        compiler.link().ok();\n+        let linker = compiler.enter(|queries| {\n+            queries.linker()\n+        });\n+        if let Ok(linker) = linker {\n+            linker.link();\n+        }\n     });\n }"}]}