{"sha": "f3191a450cc08064be6c078773c5135a3b4e83e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMTkxYTQ1MGNjMDgwNjRiZTZjMDc4NzczYzUxMzVhM2I0ZTgzZTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T20:08:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-05T19:50:35Z"}, "message": "Refactor TypeContents to be more scrutable. In particular, create coarser bits\nthan the current ones, which were very fine-grained.  Also, cleanly distinguish\nwhen properties must be found in *owned* types vs *reachable* types.\n\nFixes #10157\nFixes #10278", "tree": {"sha": "f15083b5c6c7448c95b10bfdfdf318b2e47b00b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f15083b5c6c7448c95b10bfdfdf318b2e47b00b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3191a450cc08064be6c078773c5135a3b4e83e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3191a450cc08064be6c078773c5135a3b4e83e5", "html_url": "https://github.com/rust-lang/rust/commit/f3191a450cc08064be6c078773c5135a3b4e83e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3191a450cc08064be6c078773c5135a3b4e83e5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fb583be7b0df80c91df026c6a2bde550bc27a7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb583be7b0df80c91df026c6a2bde550bc27a7c", "html_url": "https://github.com/rust-lang/rust/commit/7fb583be7b0df80c91df026c6a2bde550bc27a7c"}], "stats": {"total": 478, "additions": 234, "deletions": 244}, "files": [{"sha": "6168ecb4506cae2dd763179bf27bb70247b4390d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 222, "deletions": 244, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/f3191a450cc08064be6c078773c5135a3b4e83e5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3191a450cc08064be6c078773c5135a3b4e83e5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f3191a450cc08064be6c078773c5135a3b4e83e5", "patch": "@@ -1854,9 +1854,76 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n  * a type than to think about what is *not* contained within a type.\n  */\n pub struct TypeContents {\n-    bits: u32\n+    bits: u64\n }\n \n+macro_rules! def_type_content_sets(\n+    (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n+        mod $mname {\n+            use middle::ty::TypeContents;\n+            $(pub static $name: TypeContents = TypeContents { bits: $bits };)+\n+        }\n+    }\n+)\n+\n+def_type_content_sets!(\n+    mod TC {\n+        None                                = 0b0000__00000000__0000,\n+\n+        // Things that are interior to the value (first nibble):\n+        InteriorUnsized                     = 0b0000__00000000__0001,\n+        InteriorAll                         = 0b0000__00000000__1111,\n+\n+        // Things that are owned by the value (second and third nibbles):\n+        OwnsOwned                           = 0b0000__00000001__0000,\n+        OwnsDtor                            = 0b0000__00000010__0000,\n+        OwnsManaged /* see [1] below */     = 0b0000__00000100__0000,\n+        OwnsAffine                          = 0b0000__00001000__0000,\n+        OwnsAll                             = 0b0000__11111111__0000,\n+\n+        // Things that are reachable by the value in any way (fourth nibble):\n+        ReachesNonsendAnnot                 = 0b0001__00000000__0000,\n+        ReachesBorrowed                     = 0b0010__00000000__0000,\n+        ReachesManaged /* see [1] below */  = 0b0100__00000000__0000,\n+        ReachesMutable                      = 0b1000__00000000__0000,\n+        ReachesAll                          = 0b1111__00000000__0000,\n+\n+        // Things that cause values to *move* rather than *copy*\n+        Moves                               = 0b0000__00001011__0000,\n+\n+        // Things that mean drop glue is necessary\n+        NeedsDrop                           = 0b0000__00000111__0000,\n+\n+        // Things that prevent values from being sent\n+        //\n+        // Note: For checking whether something is sendable, it'd\n+        //       be sufficient to have ReachesManaged. However, we include\n+        //       both ReachesManaged and OwnsManaged so that when\n+        //       a parameter has a bound T:Send, we are able to deduce\n+        //       that it neither reaches nor owns a managed pointer.\n+        Nonsendable                         = 0b0111__00000100__0000,\n+\n+        // Things that prevent values from being considered freezable\n+        Nonfreezable                        = 0b1000__00000000__0000,\n+\n+        // Things that prevent values from being considered 'static\n+        Nonstatic                           = 0b0010__00000000__0000,\n+\n+        // Things that prevent values from being considered sized\n+        Nonsized                            = 0b0000__00000000__0001,\n+\n+        // Bits to set when a managed value is encountered\n+        //\n+        // [1] Do not set the bits TC::OwnsManaged or\n+        //     TC::ReachesManaged directly, instead reference\n+        //     TC::Managed to set them both at once.\n+        Managed                             = 0b0100__00000100__0000,\n+\n+        // All bits\n+        All                                 = 0b1111__11111111__1111\n+    }\n+)\n+\n impl TypeContents {\n     pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n         bbs.iter().all(|bb| self.meets_bound(cx, bb))\n@@ -1871,84 +1938,81 @@ impl TypeContents {\n         }\n     }\n \n-    pub fn intersects(&self, tc: TypeContents) -> bool {\n-        (self.bits & tc.bits) != 0\n-    }\n-\n-    pub fn noncopyable(_cx: ctxt) -> TypeContents {\n-        TC_DTOR + TC_BORROWED_MUT + TC_ONCE_CLOSURE + TC_NONCOPY_TRAIT +\n-            TC_EMPTY_ENUM\n-    }\n-\n-    pub fn is_static(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonstatic(cx))\n+    pub fn when(&self, cond: bool) -> TypeContents {\n+        if cond {*self} else {TC::None}\n     }\n \n-    pub fn nonstatic(_cx: ctxt) -> TypeContents {\n-        TC_BORROWED_POINTER\n+    pub fn intersects(&self, tc: TypeContents) -> bool {\n+        (self.bits & tc.bits) != 0\n     }\n \n-    pub fn is_sendable(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonsendable(cx))\n+    pub fn is_static(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonstatic)\n     }\n \n-    pub fn nonsendable(_cx: ctxt) -> TypeContents {\n-        TC_MANAGED + TC_BORROWED_POINTER + TC_NON_SENDABLE\n+    pub fn is_sendable(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonsendable)\n     }\n \n     pub fn contains_managed(&self) -> bool {\n-        self.intersects(TC_MANAGED)\n+        self.intersects(TC::OwnsManaged)\n     }\n \n-    pub fn is_freezable(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonfreezable(cx))\n+    pub fn is_freezable(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonfreezable)\n     }\n \n-    pub fn nonfreezable(_cx: ctxt) -> TypeContents {\n-        TC_MUTABLE\n+    pub fn is_sized(&self, _: ctxt) -> bool {\n+        !self.intersects(TC::Nonsized)\n     }\n \n-    pub fn is_sized(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::dynamically_sized(cx))\n+    pub fn moves_by_default(&self, _: ctxt) -> bool {\n+        self.intersects(TC::Moves)\n     }\n \n-    pub fn dynamically_sized(_cx: ctxt) -> TypeContents {\n-        TC_DYNAMIC_SIZE\n+    pub fn needs_drop(&self, _: ctxt) -> bool {\n+        self.intersects(TC::NeedsDrop)\n     }\n \n-    pub fn moves_by_default(&self, cx: ctxt) -> bool {\n-        self.intersects(TypeContents::nonimplicitly_copyable(cx))\n+    pub fn owned_pointer(&self) -> TypeContents {\n+        /*!\n+         * Includes only those bits that still apply\n+         * when indirected through a `~` pointer\n+         */\n+        TC::OwnsOwned | (\n+            *self & (TC::OwnsAll | TC::ReachesAll))\n     }\n \n-    pub fn nonimplicitly_copyable(cx: ctxt) -> TypeContents {\n-        TypeContents::noncopyable(cx) + TC_OWNED_POINTER + TC_OWNED_VEC\n+    pub fn other_pointer(&self, bits: TypeContents) -> TypeContents {\n+        /*!\n+         * Includes only those bits that still apply\n+         * when indirected through a non-owning pointer (`&`, `@`)\n+         */\n+        bits | (\n+            *self & TC::ReachesAll)\n     }\n \n-    pub fn needs_drop(&self, cx: ctxt) -> bool {\n-        if self.intersects(TC_NONCOPY_TRAIT) {\n-            // Currently all noncopyable existentials are 2nd-class types\n-            // behind owned pointers. With dynamically-sized types, remove\n-            // this assertion.\n-            assert!(self.intersects(TC_OWNED_POINTER) ||\n-                    // (...or stack closures without a copy bound.)\n-                    self.intersects(TC_BORROWED_POINTER));\n-        }\n-        let tc = TC_MANAGED + TC_DTOR + TypeContents::sendable(cx);\n-        self.intersects(tc)\n+    pub fn union<T>(v: &[T], f: &fn(&T) -> TypeContents) -> TypeContents {\n+        v.iter().fold(TC::None, |tc, t| tc | f(t))\n     }\n \n-    pub fn sendable(_cx: ctxt) -> TypeContents {\n-        //! Any kind of sendable contents.\n-        TC_OWNED_POINTER + TC_OWNED_VEC\n+    pub fn inverse(&self) -> TypeContents {\n+        TypeContents { bits: !self.bits }\n     }\n }\n \n-impl ops::Add<TypeContents,TypeContents> for TypeContents {\n-    fn add(&self, other: &TypeContents) -> TypeContents {\n+impl ops::BitOr<TypeContents,TypeContents> for TypeContents {\n+    fn bitor(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits | other.bits}\n     }\n }\n \n+impl ops::BitAnd<TypeContents,TypeContents> for TypeContents {\n+    fn bitand(&self, other: &TypeContents) -> TypeContents {\n+        TypeContents {bits: self.bits & other.bits}\n+    }\n+}\n+\n impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n     fn sub(&self, other: &TypeContents) -> TypeContents {\n         TypeContents {bits: self.bits & !other.bits}\n@@ -1961,48 +2025,6 @@ impl ToStr for TypeContents {\n     }\n }\n \n-/// Constant for a type containing nothing of interest.\n-static TC_NONE: TypeContents =             TypeContents{bits: 0b0000_0000_0000};\n-\n-/// Contains a borrowed value with a lifetime other than static\n-static TC_BORROWED_POINTER: TypeContents = TypeContents{bits: 0b0000_0000_0001};\n-\n-/// Contains an owned pointer (~T) but not slice of some kind\n-static TC_OWNED_POINTER: TypeContents =    TypeContents{bits: 0b0000_0000_0010};\n-\n-/// Contains an owned vector ~[] or owned string ~str\n-static TC_OWNED_VEC: TypeContents =        TypeContents{bits: 0b0000_0000_0100};\n-\n-/// Contains a non-copyable ~fn() or a ~Trait (NOT a ~fn:Copy() or ~Trait:Copy).\n-static TC_NONCOPY_TRAIT: TypeContents =    TypeContents{bits: 0b0000_0000_1000};\n-\n-/// Type with a destructor\n-static TC_DTOR: TypeContents =             TypeContents{bits: 0b0000_0001_0000};\n-\n-/// Contains a managed value\n-static TC_MANAGED: TypeContents =          TypeContents{bits: 0b0000_0010_0000};\n-\n-/// &mut with any region\n-static TC_BORROWED_MUT: TypeContents =     TypeContents{bits: 0b0000_0100_0000};\n-\n-/// Mutable content, whether owned or by ref\n-static TC_MUTABLE: TypeContents =          TypeContents{bits: 0b0000_1000_0000};\n-\n-/// One-shot closure\n-static TC_ONCE_CLOSURE: TypeContents =     TypeContents{bits: 0b0001_0000_0000};\n-\n-/// An enum with no variants.\n-static TC_EMPTY_ENUM: TypeContents =       TypeContents{bits: 0b0010_0000_0000};\n-\n-/// Contains a type marked with `#[no_send]`\n-static TC_NON_SENDABLE: TypeContents =     TypeContents{bits: 0b0100_0000_0000};\n-\n-/// Is a bare vector, str, function, trait, etc (only relevant at top level).\n-static TC_DYNAMIC_SIZE: TypeContents =     TypeContents{bits: 0b1000_0000_0000};\n-\n-/// All possible contents.\n-static TC_ALL: TypeContents =              TypeContents{bits: 0b1111_1111_1111};\n-\n pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n@@ -2039,19 +2061,19 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         //\n         // When computing the type contents of such a type, we wind up deeply\n         // recursing as we go.  So when we encounter the recursive reference\n-        // to List, we temporarily use TC_NONE as its contents.  Later we'll\n+        // to List, we temporarily use TC::None as its contents.  Later we'll\n         // patch up the cache with the correct value, once we've computed it\n         // (this is basically a co-inductive process, if that helps).  So in\n-        // the end we'll compute TC_OWNED_POINTER, in this case.\n+        // the end we'll compute TC::OwnsOwned, in this case.\n         //\n         // The problem is, as we are doing the computation, we will also\n         // compute an *intermediate* contents for, e.g., Option<List> of\n-        // TC_NONE.  This is ok during the computation of List itself, but if\n+        // TC::None.  This is ok during the computation of List itself, but if\n         // we stored this intermediate value into cx.tc_cache, then later\n-        // requests for the contents of Option<List> would also yield TC_NONE\n+        // requests for the contents of Option<List> would also yield TC::None\n         // which is incorrect.  This value was computed based on the crutch\n         // value for the type contents of list.  The correct value is\n-        // TC_OWNED_POINTER.  This manifested as issue #4821.\n+        // TC::OwnsOwned.  This manifested as issue #4821.\n         let ty_id = type_id(ty);\n         match cache.find(&ty_id) {\n             Some(tc) => { return *tc; }\n@@ -2061,108 +2083,92 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        cache.insert(ty_id, TC_NONE);\n-\n-        let _i = indenter();\n+        cache.insert(ty_id, TC::None);\n \n         let result = match get(ty).sty {\n             // Scalar and unique types are sendable, freezable, and durable\n-            ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-            ty_bare_fn(_) | ty_ptr(_) => {\n-                TC_NONE\n+            ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_bare_fn(_) | ty_ptr(_) | ty::ty_char => {\n+                TC::None\n             }\n \n             ty_estr(vstore_uniq) => {\n-                TC_OWNED_VEC\n+                TC::OwnsOwned\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(c)\n+                closure_contents(cx, c)\n             }\n \n             ty_box(mt) => {\n-                TC_MANAGED +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+                tc_mt(cx, mt, cache).other_pointer(TC::Managed)\n             }\n \n             ty_trait(_, _, store, mutbl, bounds) => {\n-                trait_contents(store, mutbl, bounds)\n+                object_contents(cx, store, mutbl, bounds)\n             }\n \n-            ty_rptr(r, mt) => {\n-                borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+            ty_rptr(r, ref mt) => {\n+                tc_ty(cx, mt.ty, cache).other_pointer(\n+                    borrowed_contents(r, mt.mutbl))\n             }\n \n             ty_uniq(mt) => {\n-                TC_OWNED_POINTER + statically_sized(tc_mt(cx, mt, cache))\n+                tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n             ty_evec(mt, vstore_uniq) => {\n-                TC_OWNED_VEC + statically_sized(tc_mt(cx, mt, cache))\n+                tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n             ty_evec(mt, vstore_box) => {\n-                TC_MANAGED +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+                tc_mt(cx, mt, cache).other_pointer(TC::Managed)\n             }\n \n-            ty_evec(mt, vstore_slice(r)) => {\n-                borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n+            ty_evec(ref mt, vstore_slice(r)) => {\n+                tc_ty(cx, mt.ty, cache).other_pointer(\n+                    borrowed_contents(r, mt.mutbl))\n             }\n \n             ty_evec(mt, vstore_fixed(_)) => {\n-                let contents = tc_mt(cx, mt, cache);\n-                // FIXME(#6308) Uncomment this when construction of such\n-                // vectors is prevented earlier in compilation.\n-                // if !contents.is_sized(cx) {\n-                //     cx.sess.bug(\"Fixed-length vector of unsized type \\\n-                //                  should be impossible\");\n-                // }\n-                contents\n+                tc_mt(cx, mt, cache)\n             }\n \n             ty_estr(vstore_box) => {\n-                TC_MANAGED\n+                TC::Managed\n             }\n \n             ty_estr(vstore_slice(r)) => {\n-                borrowed_contents(r, MutImmutable)\n+                borrowed_contents(r, ast::MutImmutable)\n             }\n \n             ty_estr(vstore_fixed(_)) => {\n-                TC_NONE\n+                TC::None\n             }\n \n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n-                let mut res = flds.iter().fold(\n-                    TC_NONE,\n-                    |tc, f| tc + tc_mt(cx, f.mt, cache));\n+                let mut res =\n+                    TypeContents::union(flds, |f| tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n-                    res = res + TC_DTOR;\n+                    res = res | TC::OwnsDtor;\n                 }\n-                apply_tc_attr(cx, did, res)\n+                apply_attributes(cx, did, res)\n             }\n \n             ty_tup(ref tys) => {\n-                tys.iter().fold(TC_NONE, |tc, ty| tc + tc_ty(cx, *ty, cache))\n+                TypeContents::union(*tys, |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n-                let res = if variants.is_empty() {\n-                    // we somewhat arbitrary declare that empty enums\n-                    // are non-copyable\n-                    TC_EMPTY_ENUM\n-                } else {\n-                    variants.iter().fold(TC_NONE, |tc, variant| {\n-                        variant.args.iter().fold(tc,\n-                            |tc, arg_ty| tc + tc_ty(cx, *arg_ty, cache))\n-                    })\n-                };\n-                apply_tc_attr(cx, did, res)\n+                let res =\n+                    TypeContents::union(variants, |variant| {\n+                        TypeContents::union(variant.args, |arg_ty| {\n+                            tc_ty(cx, *arg_ty, cache)\n+                        })\n+                    });\n+                apply_attributes(cx, did, res)\n             }\n \n             ty_param(p) => {\n@@ -2175,7 +2181,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 assert_eq!(p.def_id.crate, ast::LOCAL_CRATE);\n \n                 let tp_def = cx.ty_param_defs.get(&p.def_id.node);\n-                kind_bounds_to_contents(cx, &tp_def.bounds.builtin_bounds,\n+                kind_bounds_to_contents(cx,\n+                                        tp_def.bounds.builtin_bounds,\n                                         tp_def.bounds.trait_bounds)\n             }\n \n@@ -2186,31 +2193,29 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // for supertraits. If so we can use those bounds.\n                 let trait_def = lookup_trait_def(cx, def_id);\n                 let traits = [trait_def.trait_ref];\n-                kind_bounds_to_contents(cx, &trait_def.bounds, traits)\n+                kind_bounds_to_contents(cx, trait_def.bounds, traits)\n             }\n \n             ty_infer(_) => {\n                 // This occurs during coherence, but shouldn't occur at other\n                 // times.\n-                TC_ALL\n+                TC::All\n             }\n \n-            ty_opaque_box => TC_MANAGED,\n-            ty_unboxed_vec(mt) => TC_DYNAMIC_SIZE + tc_mt(cx, mt, cache),\n+            ty_opaque_box => TC::Managed,\n+            ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n             ty_opaque_closure_ptr(sigil) => {\n                 match sigil {\n-                    ast::BorrowedSigil => TC_BORROWED_POINTER,\n-                    ast::ManagedSigil => TC_MANAGED,\n-                    // FIXME(#3569): Looks like noncopyability should depend\n-                    // on the bounds, but I don't think this case ever comes up.\n-                    ast::OwnedSigil => TC_NONCOPY_TRAIT + TC_OWNED_POINTER,\n+                    ast::BorrowedSigil => TC::ReachesBorrowed,\n+                    ast::ManagedSigil => TC::Managed,\n+                    ast::OwnedSigil => TC::OwnsOwned,\n                 }\n             }\n \n-            ty_type => TC_NONE,\n+            ty_type => TC::None,\n \n             ty_err => {\n-                cx.sess.bug(\"Asked to compute contents of fictitious type\");\n+                cx.sess.bug(\"Asked to compute contents of error type\");\n             }\n         };\n \n@@ -2222,132 +2227,105 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n              mt: mt,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n-        let mc = if mt.mutbl == MutMutable {TC_MUTABLE} else {TC_NONE};\n-        mc + tc_ty(cx, mt.ty, cache)\n+        let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n+        mc | tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_tc_attr(cx: ctxt, did: DefId, mut tc: TypeContents) -> TypeContents {\n-        if has_attr(cx, did, \"no_freeze\") {\n-            tc = tc + TC_MUTABLE;\n-        }\n-        if has_attr(cx, did, \"no_send\") {\n-            tc = tc + TC_NON_SENDABLE;\n-        }\n-        tc\n+    fn apply_attributes(cx: ctxt,\n+                        did: ast::DefId,\n+                        tc: TypeContents)\n+                        -> TypeContents {\n+        tc |\n+            TC::ReachesMutable.when(has_attr(cx, did, \"no_freeze\")) |\n+            TC::ReachesNonsendAnnot.when(has_attr(cx, did, \"no_send\"))\n     }\n \n     fn borrowed_contents(region: ty::Region,\n-                         mutbl: ast::Mutability) -> TypeContents\n-    {\n-        let mc = if mutbl == MutMutable {\n-            TC_MUTABLE + TC_BORROWED_MUT\n-        } else {\n-            TC_NONE\n-        };\n-        let rc = if region != ty::re_static {\n-            TC_BORROWED_POINTER\n-        } else {\n-            TC_NONE\n-        };\n-        mc + rc\n-    }\n-\n-    fn nonsendable(pointee: TypeContents) -> TypeContents {\n+                         mutbl: ast::Mutability)\n+                         -> TypeContents {\n         /*!\n-         *\n-         * Given a non-owning pointer to some type `T` with\n-         * contents `pointee` (like `@T` or\n-         * `&T`), returns the relevant bits that\n-         * apply to the owner of the pointer.\n+         * Type contents due to containing a borrowed pointer\n+         * with the region `region` and borrow kind `bk`\n          */\n \n-        let mask = TC_MUTABLE.bits | TC_BORROWED_POINTER.bits;\n-        TypeContents {bits: pointee.bits & mask}\n-    }\n-\n-    fn statically_sized(pointee: TypeContents) -> TypeContents {\n-        /*!\n-         * If a dynamically-sized type is found behind a pointer, we should\n-         * restore the 'Sized' kind to the pointer and things that contain it.\n-         */\n-        TypeContents {bits: pointee.bits & !TC_DYNAMIC_SIZE.bits}\n+        let b = match mutbl {\n+            ast::MutMutable => TC::ReachesMutable | TC::OwnsAffine,\n+            ast::MutImmutable => TC::None,\n+        };\n+        b | (TC::ReachesBorrowed).when(region != ty::re_static)\n     }\n \n-    fn closure_contents(cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n         let st = match cty.sigil {\n             ast::BorrowedSigil =>\n-                trait_contents(RegionTraitStore(cty.region), MutImmutable, cty.bounds)\n-                    + TC_BORROWED_POINTER, // might be an env packet even if static\n+                object_contents(cx, RegionTraitStore(cty.region), MutMutable, cty.bounds),\n             ast::ManagedSigil =>\n-                trait_contents(BoxTraitStore, MutImmutable, cty.bounds),\n+                object_contents(cx, BoxTraitStore, MutImmutable, cty.bounds),\n             ast::OwnedSigil =>\n-                trait_contents(UniqTraitStore, MutImmutable, cty.bounds),\n+                object_contents(cx, UniqTraitStore, MutImmutable, cty.bounds),\n         };\n+\n         // FIXME(#3569): This borrowed_contents call should be taken care of in\n-        // trait_contents, after ~Traits and @Traits can have region bounds too.\n+        // object_contents, after ~Traits and @Traits can have region bounds too.\n         // This one here is redundant for &fns but important for ~fns and @fns.\n-        let rt = borrowed_contents(cty.region, MutImmutable);\n+        let rt = borrowed_contents(cty.region, ast::MutImmutable);\n+\n         // This also prohibits \"@once fn\" from being copied, which allows it to\n         // be called. Neither way really makes much sense.\n         let ot = match cty.onceness {\n-            ast::Once => TC_ONCE_CLOSURE,\n-            ast::Many => TC_NONE\n+            ast::Once => TC::OwnsAffine,\n+            ast::Many => TC::None,\n         };\n-        // Prevent noncopyable types captured in the environment from being copied.\n-        st + rt + ot + TC_NONCOPY_TRAIT\n+\n+        st | rt | ot\n     }\n \n-    fn trait_contents(store: TraitStore, mutbl: ast::Mutability,\n-                      bounds: BuiltinBounds) -> TypeContents {\n-        let st = match store {\n-            UniqTraitStore      => TC_OWNED_POINTER,\n-            BoxTraitStore       => TC_MANAGED,\n-            RegionTraitStore(r) => borrowed_contents(r, mutbl),\n-        };\n-        let mt = match mutbl { ast::MutMutable => TC_MUTABLE, _ => TC_NONE };\n-        // We get additional \"special type contents\" for each bound that *isn't*\n-        // on the trait. So iterate over the inverse of the bounds that are set.\n-        // This is like with typarams below, but less \"pessimistic\" and also\n-        // dependent on the trait store.\n-        let mut bt = TC_NONE;\n-        for bound in (AllBuiltinBounds() - bounds).iter() {\n-            bt = bt + match bound {\n-                BoundStatic if bounds.contains_elem(BoundSend)\n-                            => TC_NONE, // Send bound implies static bound.\n-                BoundStatic => TC_BORROWED_POINTER, // Useful for \"@Trait:'static\"\n-                BoundSend   => TC_NON_SENDABLE,\n-                BoundFreeze => TC_MUTABLE,\n-                BoundSized  => TC_NONE, // don't care if interior is sized\n-            };\n+    fn object_contents(cx: ctxt,\n+                       store: TraitStore,\n+                       mutbl: ast::Mutability,\n+                       bounds: BuiltinBounds)\n+                       -> TypeContents {\n+        // These are the type contents of the (opaque) interior\n+        let contents = (TC::ReachesMutable.when(mutbl == ast::MutMutable) |\n+                        kind_bounds_to_contents(cx, bounds, []));\n+\n+        match store {\n+            UniqTraitStore => {\n+                contents.owned_pointer()\n+            }\n+            BoxTraitStore => {\n+                contents.other_pointer(TC::Managed)\n+            }\n+            RegionTraitStore(r) => {\n+                contents.other_pointer(borrowed_contents(r, mutbl))\n+            }\n         }\n-        st + mt + bt\n     }\n \n-    fn kind_bounds_to_contents(cx: ctxt, bounds: &BuiltinBounds, traits: &[@TraitRef])\n-            -> TypeContents {\n+    fn kind_bounds_to_contents(cx: ctxt,\n+                               bounds: BuiltinBounds,\n+                               traits: &[@TraitRef])\n+                               -> TypeContents {\n         let _i = indenter();\n-\n-        let mut tc = TC_ALL;\n+        let mut tc = TC::All;\n         do each_inherited_builtin_bound(cx, bounds, traits) |bound| {\n-            debug!(\"tc = {}, bound = {:?}\", tc.to_str(), bound);\n             tc = tc - match bound {\n-                BoundStatic => TypeContents::nonstatic(cx),\n-                BoundSend => TypeContents::nonsendable(cx),\n-                BoundFreeze => TypeContents::nonfreezable(cx),\n-                // The dynamic-size bit can be removed at pointer-level, etc.\n-                BoundSized => TypeContents::dynamically_sized(cx),\n+                BoundStatic => TC::Nonstatic,\n+                BoundSend => TC::Nonsendable,\n+                BoundFreeze => TC::Nonfreezable,\n+                BoundSized => TC::Nonsized,\n             };\n         }\n-\n-        debug!(\"result = {}\", tc.to_str());\n         return tc;\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound(cx: ctxt, bounds: &BuiltinBounds,\n-                                        traits: &[@TraitRef], f: &fn(BuiltinBound)) {\n+        fn each_inherited_builtin_bound(cx: ctxt,\n+                                        bounds: BuiltinBounds,\n+                                        traits: &[@TraitRef],\n+                                        f: &fn(BuiltinBound)) {\n             for bound in bounds.iter() {\n                 f(bound);\n             }"}, {"sha": "9fad05387c6b45c0e857b545f08055c3ba1fde3c", "filename": "src/test/compile-fail/mutable-enum-indirect.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3191a450cc08064be6c078773c5135a3b4e83e5/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3191a450cc08064be6c078773c5135a3b4e83e5/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum-indirect.rs?ref=f3191a450cc08064be6c078773c5135a3b4e83e5", "patch": "@@ -0,0 +1,12 @@\n+// Tests that an `&` pointer to something inherently mutable is itself\n+// to be considered mutable.\n+\n+#[no_freeze]\n+enum Foo { A }\n+\n+fn bar<T: Freeze>(_: T) {}\n+\n+fn main() {\n+    let x = A;\n+    bar(&x); //~ ERROR type parameter with an incompatible type\n+}"}]}