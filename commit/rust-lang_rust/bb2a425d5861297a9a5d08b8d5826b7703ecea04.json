{"sha": "bb2a425d5861297a9a5d08b8d5826b7703ecea04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMmE0MjVkNTg2MTI5N2E5YTVkMDhiOGQ1ODI2Yjc3MDNlY2VhMDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-02T02:10:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-02T02:10:36Z"}, "message": "introduce the notion of revisions, currently unused\n\na test file may specify `// revisions: foo bar baz`\n\nheaders and expected errors may be made specific to a revision\nby writing `//[foo] header` or `//[foo]~ ERROR`", "tree": {"sha": "804b482f58173ed38f45754dc509c9aedecafb34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/804b482f58173ed38f45754dc509c9aedecafb34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb2a425d5861297a9a5d08b8d5826b7703ecea04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb2a425d5861297a9a5d08b8d5826b7703ecea04", "html_url": "https://github.com/rust-lang/rust/commit/bb2a425d5861297a9a5d08b8d5826b7703ecea04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb2a425d5861297a9a5d08b8d5826b7703ecea04/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d78b4a93509174bed2080b627d74c956d2654366", "url": "https://api.github.com/repos/rust-lang/rust/commits/d78b4a93509174bed2080b627d74c956d2654366", "html_url": "https://github.com/rust-lang/rust/commit/d78b4a93509174bed2080b627d74c956d2654366"}], "stats": {"total": 115, "additions": 88, "deletions": 27}, "files": [{"sha": "63bc657baa428d0c0830afc3f4182d13799c488c", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=bb2a425d5861297a9a5d08b8d5826b7703ecea04", "patch": "@@ -30,8 +30,10 @@ enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n /// Goal is to enable tests both like: //~^^^ ERROR go up three\n /// and also //~^ ERROR message one for the preceding line, and\n ///          //~| ERROR message two for that same line.\n-// Load any test directives embedded in the file\n-pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n+///\n+/// If cfg is not None (i.e., in an incremental test), then we look\n+/// for `//[X]~` instead, where `X` is the current `cfg`.\n+pub fn load_errors(testfile: &Path, cfg: &Option<String>) -> Vec<ExpectedError> {\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n \n     // `last_nonfollow_error` tracks the most recently seen\n@@ -44,30 +46,41 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     // updating it in the map callback below.)\n     let mut last_nonfollow_error = None;\n \n-    rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(last_nonfollow_error,\n-                       line_no + 1,\n-                       &ln.unwrap())\n-            .map(|(which, error)| {\n-                match which {\n-                    FollowPrevious(_) => {}\n-                    _ => last_nonfollow_error = Some(error.line),\n-                }\n-                error\n-            })\n-    }).collect()\n+    let tag = match *cfg {\n+        Some(ref rev) => format!(\"//[{}]~\", rev),\n+        None => format!(\"//~\")\n+    };\n+\n+    rdr.lines()\n+       .enumerate()\n+       .filter_map(|(line_no, ln)| {\n+           parse_expected(last_nonfollow_error,\n+                          line_no + 1,\n+                          &ln.unwrap(),\n+                          &tag)\n+               .map(|(which, error)| {\n+                   match which {\n+                       FollowPrevious(_) => {}\n+                       _ => last_nonfollow_error = Some(error.line),\n+                   }\n+                   error\n+               })\n+       })\n+       .collect()\n }\n \n fn parse_expected(last_nonfollow_error: Option<usize>,\n                   line_num: usize,\n-                  line: &str) -> Option<(WhichLine, ExpectedError)> {\n-    let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n-    let (follow, adjusts) = if line.char_at(start + 3) == '|' {\n+                  line: &str,\n+                  tag: &str)\n+                  -> Option<(WhichLine, ExpectedError)> {\n+    let start = match line.find(tag) { Some(i) => i, None => return None };\n+    let (follow, adjusts) = if line.char_at(start + tag.len()) == '|' {\n         (true, 0)\n     } else {\n-        (false, line[start + 3..].chars().take_while(|c| *c == '^').count())\n+        (false, line[start + tag.len()..].chars().take_while(|c| *c == '^').count())\n     };\n-    let kind_start = start + 3 + adjusts + (follow as usize);\n+    let kind_start = start + tag.len() + adjusts + (follow as usize);\n     let letters = line[kind_start..].chars();\n     let kind = letters.skip_while(|c| c.is_whitespace())\n                       .take_while(|c| !c.is_whitespace())\n@@ -91,7 +104,9 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n         (which, line)\n     };\n \n-    debug!(\"line={} which={:?} kind={:?} msg={:?}\", line_num, which, kind, msg);\n+    debug!(\"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n+           line_num, tag, which, kind, msg);\n+\n     Some((which, ExpectedError { line: line,\n                                  kind: kind,\n                                  msg: msg, }))"}, {"sha": "c9dfc0bf1a49743a8668ba1108416192871c12bb", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=bb2a425d5861297a9a5d08b8d5826b7703ecea04", "patch": "@@ -18,7 +18,18 @@ use common::Config;\n use common;\n use util;\n \n+#[derive(Clone, Debug)]\n pub struct TestProps {\n+    // For the main test file, this is initialized to `None`. But\n+    // when running tests that test multiple revisions, such as\n+    // incremental tests, we will set this to `Some(foo)` where `foo`\n+    // is the current revision identifier.\n+    //\n+    // Note that, unlike the other options here, this value is never\n+    // loaded from the input file (though it is always set to one of\n+    // the values listed in the vec `self.revisions`, which is loaded\n+    // from the file).\n+    pub revision: Option<String>,\n     // Lines that should be expected, in order, on standard out\n     pub error_patterns: Vec<String> ,\n     // Extra flags to pass to the compiler\n@@ -50,6 +61,8 @@ pub struct TestProps {\n     pub pretty_compare_only: bool,\n     // Patterns which must not appear in the output of a cfail test.\n     pub forbid_output: Vec<String>,\n+    // Revisions to test for incremental compilation.\n+    pub revisions: Vec<String>,\n }\n \n // Load any test directives embedded in the file\n@@ -68,11 +81,13 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     let pretty_compare_only = false;\n     let forbid_output = Vec::new();\n     let mut props = TestProps {\n+        revision: None,\n         error_patterns: error_patterns,\n         compile_flags: vec![],\n         run_flags: run_flags,\n         pp_exact: pp_exact,\n         aux_builds: aux_builds,\n+        revisions: vec![],\n         exec_env: exec_env,\n         check_lines: check_lines,\n         build_aux_docs: build_aux_docs,\n@@ -84,12 +99,16 @@ pub fn load_props(testfile: &Path) -> TestProps {\n         pretty_compare_only: pretty_compare_only,\n         forbid_output: forbid_output,\n     };\n-    load_props_into(&mut props, testfile);\n+    load_props_into(&mut props, testfile, None);\n     props\n }\n \n-pub fn load_props_into(props: &mut TestProps, testfile: &Path) {\n-    iter_header(testfile, &mut |ln| {\n+/// Load properties from `testfile` into `props`. If a property is\n+/// tied to a particular revision `foo` (indicated by writing\n+/// `//[foo]`), then the property is ignored unless `cfg` is\n+/// `Some(\"foo\")`.\n+pub fn load_props_into(props: &mut TestProps, testfile: &Path, cfg: Option<&str>)  {\n+    iter_header(testfile, cfg, &mut |ln| {\n         if let Some(ep) = parse_error_pattern(ln) {\n             props.error_patterns.push(ep);\n         }\n@@ -101,6 +120,10 @@ pub fn load_props_into(props: &mut TestProps, testfile: &Path) {\n                     .map(|s| s.to_owned()));\n         }\n \n+        if let Some(r) = parse_revisions(ln) {\n+            props.revisions.extend(r);\n+        }\n+\n         if props.run_flags.is_none() {\n             props.run_flags = parse_run_flags(ln);\n         }\n@@ -235,7 +258,7 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n         }\n     }\n \n-    let val = iter_header(testfile, &mut |ln| {\n+    let val = iter_header(testfile, None, &mut |ln| {\n         !parse_name_directive(ln, \"ignore-test\") &&\n         !parse_name_directive(ln, &ignore_target(config)) &&\n         !parse_name_directive(ln, &ignore_architecture(config)) &&\n@@ -250,7 +273,10 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n     !val\n }\n \n-fn iter_header(testfile: &Path, it: &mut FnMut(&str) -> bool) -> bool {\n+fn iter_header(testfile: &Path,\n+               cfg: Option<&str>,\n+               it: &mut FnMut(&str) -> bool)\n+               -> bool {\n     let rdr = BufReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {\n         // Assume that any directives will be found before the first\n@@ -260,6 +286,21 @@ fn iter_header(testfile: &Path, it: &mut FnMut(&str) -> bool) -> bool {\n         let ln = ln.trim();\n         if ln.starts_with(\"fn\") || ln.starts_with(\"mod\") {\n             return true;\n+        } else if ln.starts_with(\"//[\") {\n+            // A comment like `//[foo]` is specific to revision `foo`\n+            if let Some(close_brace) = ln.find(\"]\") {\n+                let lncfg = &ln[3..close_brace];\n+                let matches = match cfg {\n+                    Some(s) => s == &lncfg[..],\n+                    None => false,\n+                };\n+                if matches && !it(&ln[close_brace+1..]) {\n+                    return false;\n+                }\n+            } else {\n+                panic!(\"malformed condition directive: expected `//[foo]`, found `{}`\",\n+                       ln)\n+            }\n         } else if ln.starts_with(\"//\") {\n             if !it(&ln[2..]) {\n                 return false;\n@@ -285,6 +326,11 @@ fn parse_compile_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"compile-flags\")\n }\n \n+fn parse_revisions(line: &str) -> Option<Vec<String>> {\n+    parse_name_value_directive(line, \"revisions\")\n+        .map(|r| r.split_whitespace().map(|t| t.to_string()).collect())\n+}\n+\n fn parse_run_flags(line: &str) -> Option<String> {\n     parse_name_value_directive(line, \"run-flags\")\n }"}, {"sha": "ab766eecd9dfe6767c7bc630c89e6f911b84b96c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb2a425d5861297a9a5d08b8d5826b7703ecea04/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=bb2a425d5861297a9a5d08b8d5826b7703ecea04", "patch": "@@ -85,7 +85,7 @@ fn run_cfail_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n     }\n \n     let output_to_check = get_output(props, &proc_res);\n-    let expected_errors = errors::load_errors(&testpaths.file);\n+    let expected_errors = errors::load_errors(&testpaths.file, &props.revision);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(\"both error pattern and expected errors specified\");\n@@ -1821,7 +1821,7 @@ fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPa\n         .map(|s| (&s[prefix.len()..]).to_string())\n         .collect();\n \n-    let expected: HashSet<String> = errors::load_errors(&testpaths.file)\n+    let expected: HashSet<String> = errors::load_errors(&testpaths.file, &props.revision)\n         .iter()\n         .map(|e| e.msg.trim().to_string())\n         .collect();"}]}