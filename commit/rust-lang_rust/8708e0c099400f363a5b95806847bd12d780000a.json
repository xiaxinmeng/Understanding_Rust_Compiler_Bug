{"sha": "8708e0c099400f363a5b95806847bd12d780000a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MDhlMGMwOTk0MDBmMzYzYTViOTU4MDY4NDdiZDEyZDc4MDAwMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-23T21:12:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-23T21:12:48Z"}, "message": "auto merge of #6010 : Dretch/rust/run-windows, r=brson\n\nThis fixes #5976.\r\n\r\nIt also removes `os::waitpid` in favour of (the existing) `run::waitpid`. I included this change because I figured it is kind of related.\r\n\r\nr?", "tree": {"sha": "602cb7043fc9936c1aad3e6226f32e68941af5f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/602cb7043fc9936c1aad3e6226f32e68941af5f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8708e0c099400f363a5b95806847bd12d780000a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8708e0c099400f363a5b95806847bd12d780000a", "html_url": "https://github.com/rust-lang/rust/commit/8708e0c099400f363a5b95806847bd12d780000a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8708e0c099400f363a5b95806847bd12d780000a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b90493f7e49cd575dfeddd6c0a7a27911cd4ed3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b90493f7e49cd575dfeddd6c0a7a27911cd4ed3", "html_url": "https://github.com/rust-lang/rust/commit/0b90493f7e49cd575dfeddd6c0a7a27911cd4ed3"}, {"sha": "62befac51fadbdd64050d84c796e3952789870a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/62befac51fadbdd64050d84c796e3952789870a1", "html_url": "https://github.com/rust-lang/rust/commit/62befac51fadbdd64050d84c796e3952789870a1"}], "stats": {"total": 198, "additions": 133, "deletions": 65}, "files": [{"sha": "44864630f9873856ddf2f1676efedb6744b806ed", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=8708e0c099400f363a5b95806847bd12d780000a", "patch": "@@ -1725,6 +1725,7 @@ pub mod funcs {\n                                        findFileData: HANDLE)\n                     -> BOOL;\n                 unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n+                unsafe fn CloseHandle(hObject: HANDLE) -> BOOL;\n                 unsafe fn TerminateProcess(hProcess: HANDLE, uExitCode: c_uint) -> BOOL;\n             }\n         }"}, {"sha": "fa3ca4577c6d129a6421d26827bc79596df5324d", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=8708e0c099400f363a5b95806847bd12d780000a", "patch": "@@ -30,7 +30,7 @@ use cast;\n use io;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n-use libc::{mode_t, pid_t, FILE};\n+use libc::{mode_t, FILE};\n use option;\n use option::{Some, None};\n use prelude::*;\n@@ -60,7 +60,6 @@ pub mod rustrt {\n         unsafe fn rust_get_argv() -> **c_char;\n         unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n         unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n-        unsafe fn rust_process_wait(handle: c_int) -> c_int;\n         unsafe fn rust_set_exit_status(code: libc::intptr_t);\n     }\n }\n@@ -352,27 +351,6 @@ pub fn fsync_fd(fd: c_int, _l: io::fsync::Level) -> c_int {\n     }\n }\n \n-\n-#[cfg(windows)]\n-pub fn waitpid(pid: pid_t) -> c_int {\n-    unsafe {\n-        return rustrt::rust_process_wait(pid);\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub fn waitpid(pid: pid_t) -> c_int {\n-    unsafe {\n-        use libc::funcs::posix01::wait::*;\n-        let mut status = 0 as c_int;\n-\n-        assert!((waitpid(pid, &mut status, 0 as c_int) !=\n-                     (-1 as c_int)));\n-        return status;\n-    }\n-}\n-\n-\n pub struct Pipe { mut in: c_int, mut out: c_int }\n \n #[cfg(unix)]"}, {"sha": "2455954ebe128361dc7bd4298543dd78efe1ee61", "filename": "src/libcore/run.rs", "status": "modified", "additions": 86, "deletions": 28, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8708e0c099400f363a5b95806847bd12d780000a/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=8708e0c099400f363a5b95806847bd12d780000a", "patch": "@@ -18,14 +18,14 @@ use option::{Some, None};\n use os;\n use prelude::*;\n use ptr;\n-use run;\n use str;\n use task;\n use vec;\n \n pub mod rustrt {\n-    use libc::{c_int, c_void, pid_t};\n+    use libc::{c_int, c_void};\n     use libc;\n+    use run;\n \n     #[abi = \"cdecl\"]\n     pub extern {\n@@ -34,11 +34,19 @@ pub mod rustrt {\n                                    dir: *libc::c_char,\n                                    in_fd: c_int,\n                                    out_fd: c_int,\n-                                   err_fd: c_int)\n-                                -> pid_t;\n+                                   err_fd: c_int) -> run::RunProgramResult;\n+        unsafe fn rust_process_wait(pid: c_int) -> c_int;\n     }\n }\n \n+pub struct RunProgramResult {\n+    // the process id of the program, or -1 if in case of errors\n+    pid: pid_t,\n+    // a handle to the process - on unix this will always be NULL, but on windows it will be a\n+    // HANDLE to the process, which will prevent the pid being re-used until the handle is closed.\n+    handle: *(),\n+}\n+\n /// A value representing a child process\n pub trait Program {\n     /// Returns the process id of the program\n@@ -100,16 +108,24 @@ pub trait Program {\n  * The process id of the spawned process\n  */\n pub fn spawn_process(prog: &str, args: &[~str],\n-                 env: &Option<~[(~str,~str)]>,\n-                 dir: &Option<~str>,\n-                 in_fd: c_int, out_fd: c_int, err_fd: c_int)\n-              -> pid_t {\n+                     env: &Option<~[(~str,~str)]>,\n+                     dir: &Option<~str>,\n+                     in_fd: c_int, out_fd: c_int, err_fd: c_int) -> pid_t {\n+\n+    let res = spawn_process_internal(prog, args, env, dir, in_fd, out_fd, err_fd);\n+    free_handle(res.handle);\n+    return res.pid;\n+}\n+\n+fn spawn_process_internal(prog: &str, args: &[~str],\n+                          env: &Option<~[(~str,~str)]>,\n+                          dir: &Option<~str>,\n+                          in_fd: c_int, out_fd: c_int, err_fd: c_int) -> RunProgramResult {\n     unsafe {\n         do with_argv(prog, args) |argv| {\n             do with_envp(env) |envp| {\n                 do with_dirp(dir) |dirp| {\n-                    rustrt::rust_run_program(argv, envp, dirp,\n-                                             in_fd, out_fd, err_fd)\n+                    rustrt::rust_run_program(argv, envp, dirp, in_fd, out_fd, err_fd)\n                 }\n             }\n         }\n@@ -195,6 +211,18 @@ priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n     }\n }\n \n+#[cfg(windows)]\n+priv fn free_handle(handle: *()) {\n+    unsafe {\n+        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n+    }\n+}\n+\n+#[cfg(unix)]\n+priv fn free_handle(_handle: *()) {\n+    // unix has no process handle object, just a pid\n+}\n+\n /**\n  * Spawns a process and waits for it to terminate\n  *\n@@ -208,10 +236,13 @@ priv unsafe fn fclose_and_null(f: &mut *libc::FILE) {\n  * The process's exit code\n  */\n pub fn run_program(prog: &str, args: &[~str]) -> int {\n-    let pid = spawn_process(prog, args, &None, &None,\n-                            0i32, 0i32, 0i32);\n-    if pid == -1 as pid_t { fail!(); }\n-    return waitpid(pid);\n+    let res = spawn_process_internal(prog, args, &None, &None,\n+                                     0i32, 0i32, 0i32);\n+    if res.pid == -1 as pid_t { fail!(); }\n+\n+    let code = waitpid(res.pid);\n+    free_handle(res.handle);\n+    return code;\n }\n \n /**\n@@ -234,20 +265,21 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid =\n-        spawn_process(prog, args, &None, &None,\n-                      pipe_input.in, pipe_output.out,\n-                      pipe_err.out);\n+    let res =\n+        spawn_process_internal(prog, args, &None, &None,\n+                               pipe_input.in, pipe_output.out,\n+                               pipe_err.out);\n \n     unsafe {\n-        if pid == -1 as pid_t { fail!(); }\n+        if res.pid == -1 as pid_t { fail!(); }\n         libc::close(pipe_input.in);\n         libc::close(pipe_output.out);\n         libc::close(pipe_err.out);\n     }\n \n     struct ProgRepr {\n         pid: pid_t,\n+        handle: *(),\n         in_fd: c_int,\n         out_file: *libc::FILE,\n         err_file: *libc::FILE,\n@@ -317,6 +349,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n                 finish_repr(cast::transmute(&self.r));\n                 close_repr_outputs(cast::transmute(&self.r));\n             }\n+            free_handle(self.r.handle);\n         }\n     }\n \n@@ -344,7 +377,8 @@ pub fn start_program(prog: &str, args: &[~str]) -> @Program {\n     }\n \n     let repr = ProgRepr {\n-        pid: pid,\n+        pid: res.pid,\n+        handle: res.handle,\n         in_fd: pipe_input.out,\n         out_file: os::fdopen(pipe_output.in),\n         err_file: os::fdopen(pipe_err.in),\n@@ -385,13 +419,13 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n     let pipe_in = os::pipe();\n     let pipe_out = os::pipe();\n     let pipe_err = os::pipe();\n-    let pid = spawn_process(prog, args, &None, &None,\n-                            pipe_in.in, pipe_out.out, pipe_err.out);\n+    let res = spawn_process_internal(prog, args, &None, &None,\n+                                     pipe_in.in, pipe_out.out, pipe_err.out);\n \n     os::close(pipe_in.in);\n     os::close(pipe_out.out);\n     os::close(pipe_err.out);\n-    if pid == -1i32 {\n+    if res.pid == -1i32 {\n         os::close(pipe_in.out);\n         os::close(pipe_out.in);\n         os::close(pipe_err.in);\n@@ -415,7 +449,10 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n         let output = readclose(pipe_out.in);\n         ch_clone.send((1, output));\n     };\n-    let status = run::waitpid(pid);\n+\n+    let status = waitpid(res.pid);\n+    free_handle(res.handle);\n+\n     let mut errs = ~\"\";\n     let mut outs = ~\"\";\n     let mut count = 2;\n@@ -466,17 +503,27 @@ pub fn readclose(fd: c_int) -> ~str {\n     }\n }\n \n-/// Waits for a process to exit and returns the exit code\n+/**\n+ * Waits for a process to exit and returns the exit code, failing\n+ * if there is no process with the specified id.\n+ */\n pub fn waitpid(pid: pid_t) -> int {\n     return waitpid_os(pid);\n \n     #[cfg(windows)]\n     fn waitpid_os(pid: pid_t) -> int {\n-        os::waitpid(pid) as int\n+        let status = unsafe { rustrt::rust_process_wait(pid) };\n+        if status < 0 {\n+            fail!(fmt!(\"failure in rust_process_wait: %s\", os::last_os_error()));\n+        }\n+        return status as int;\n     }\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> int {\n+\n+        use libc::funcs::posix01::wait::*;\n+\n         #[cfg(target_os = \"linux\")]\n         #[cfg(target_os = \"android\")]\n         fn WIFEXITED(status: i32) -> bool {\n@@ -501,7 +548,11 @@ pub fn waitpid(pid: pid_t) -> int {\n             status >> 8i32\n         }\n \n-        let status = os::waitpid(pid);\n+        let mut status = 0 as c_int;\n+        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n+            fail!(fmt!(\"failure in waitpid: %s\", os::last_os_error()));\n+        }\n+\n         return if WIFEXITED(status) {\n             WEXITSTATUS(status) as int\n         } else {\n@@ -547,7 +598,7 @@ mod tests {\n         writeclose(pipe_in.out, copy expected);\n         let actual = readclose(pipe_out.in);\n         readclose(pipe_err.in);\n-        os::waitpid(pid);\n+        run::waitpid(pid);\n \n         debug!(copy expected);\n         debug!(copy actual);\n@@ -563,6 +614,13 @@ mod tests {\n         assert!(status == 1);\n     }\n \n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    fn waitpid_non_existant_pid() {\n+        run::waitpid(123456789); // assume that this pid doesn't exist\n+    }\n+\n     #[test]\n     fn test_destroy_once() {\n         let mut p = run::start_program(\"echo\", []);"}, {"sha": "cf4beed1a00c6fea11b258f4c40202b83c0d3f78", "filename": "src/rt/rust_run_program.cpp", "status": "modified", "additions": 45, "deletions": 14, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8708e0c099400f363a5b95806847bd12d780000a/src%2Frt%2Frust_run_program.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8708e0c099400f363a5b95806847bd12d780000a/src%2Frt%2Frust_run_program.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_run_program.cpp?ref=8708e0c099400f363a5b95806847bd12d780000a", "patch": "@@ -15,6 +15,11 @@\n #include <crt_externs.h>\n #endif\n \n+struct RunProgramResult {\n+    pid_t pid;\n+    void* handle;\n+};\n+\n #if defined(__WIN32__)\n \n #include <process.h>\n@@ -78,7 +83,7 @@ void append_arg(char *& buf, char const *arg, bool last) {\n     }\n }\n \n-extern \"C\" CDECL int\n+extern \"C\" CDECL RunProgramResult\n rust_run_program(const char* argv[],\n                  void* envp,\n                  const char* dir,\n@@ -88,19 +93,21 @@ rust_run_program(const char* argv[],\n     si.cb = sizeof(STARTUPINFO);\n     si.dwFlags = STARTF_USESTDHANDLES;\n \n+    RunProgramResult result = {-1, NULL};\n+\n     HANDLE curproc = GetCurrentProcess();\n     HANDLE origStdin = (HANDLE)_get_osfhandle(in_fd ? in_fd : 0);\n     if (!DuplicateHandle(curproc, origStdin,\n         curproc, &si.hStdInput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n     HANDLE origStdout = (HANDLE)_get_osfhandle(out_fd ? out_fd : 1);\n     if (!DuplicateHandle(curproc, origStdout,\n         curproc, &si.hStdOutput, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n     HANDLE origStderr = (HANDLE)_get_osfhandle(err_fd ? err_fd : 2);\n     if (!DuplicateHandle(curproc, origStderr,\n         curproc, &si.hStdError, 0, 1, DUPLICATE_SAME_ACCESS))\n-        return -1;\n+        return result;\n \n     size_t cmd_len = 0;\n     for (const char** arg = argv; *arg; arg++) {\n@@ -124,18 +131,39 @@ rust_run_program(const char* argv[],\n     CloseHandle(si.hStdError);\n     free(cmd);\n \n-    if (!created) return -1;\n-    return (int)pi.hProcess;\n+    if (!created) {\n+        return result;\n+    }\n+\n+    // We close the thread handle because we don't care about keeping the thread id valid,\n+    // and we aren't keeping the thread handle around to be able to close it later. We don't\n+    // close the process handle however because we want the process id to stay valid at least\n+    // until the calling rust code closes the process handle.\n+    CloseHandle(pi.hThread);\n+    result.pid = pi.dwProcessId;\n+    result.handle = pi.hProcess;\n+    return result;\n }\n \n extern \"C\" CDECL int\n-rust_process_wait(int proc) {\n+rust_process_wait(int pid) {\n+\n+    HANDLE proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid);\n+    if (proc == NULL) {\n+        return -1;\n+    }\n+\n     DWORD status;\n     while (true) {\n-        if (GetExitCodeProcess((HANDLE)proc, &status) &&\n-            status != STILL_ACTIVE)\n-            return (int)status;\n-        WaitForSingleObject((HANDLE)proc, INFINITE);\n+        if (!GetExitCodeProcess(proc, &status)) {\n+            CloseHandle(proc);\n+            return -1;\n+        }\n+        if (status != STILL_ACTIVE) {\n+            CloseHandle(proc);\n+            return (int) status;\n+        }\n+        WaitForSingleObject(proc, INFINITE);\n     }\n }\n \n@@ -151,13 +179,16 @@ rust_process_wait(int proc) {\n extern char **environ;\n #endif\n \n-extern \"C\" CDECL int\n+extern \"C\" CDECL RunProgramResult\n rust_run_program(const char* argv[],\n                  void* envp,\n                  const char* dir,\n                  int in_fd, int out_fd, int err_fd) {\n     int pid = fork();\n-    if (pid != 0) return pid;\n+    if (pid != 0) {\n+        RunProgramResult result = {pid, NULL};\n+        return result;\n+    }\n \n     sigset_t sset;\n     sigemptyset(&sset);\n@@ -187,7 +218,7 @@ rust_run_program(const char* argv[],\n }\n \n extern \"C\" CDECL int\n-rust_process_wait(int proc) {\n+rust_process_wait(int pid) {\n     // FIXME: stub; exists to placate linker. (#2692)\n     return 0;\n }"}]}