{"sha": "f05b22efb5e739b92b47527d29c5fa903f7e64b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNWIyMmVmYjVlNzM5YjkyYjQ3NTI3ZDI5YzVmYTkwM2Y3ZTY0YjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-15T19:10:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-15T19:10:40Z"}, "message": "Auto merge of #27845 - dylanmckay:abstract-pointer-size-away, r=alexcrichton\n\nThis patch rewrites code in several places which assume that the current target has either 32-bit or 64-bit pointers so that it can support arbitrary-width pointers.\r\n\r\nIt does not completely remove all assumptions of pointer width, but it does reduce them significantly. There is a discussion [here](https://internals.rust-lang.org/t/adding-16-bit-pointer-support/2484/10) about the change.", "tree": {"sha": "8195c04753eb184726a2733d8a32d4cb84f5e71b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8195c04753eb184726a2733d8a32d4cb84f5e71b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f05b22efb5e739b92b47527d29c5fa903f7e64b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f05b22efb5e739b92b47527d29c5fa903f7e64b6", "html_url": "https://github.com/rust-lang/rust/commit/f05b22efb5e739b92b47527d29c5fa903f7e64b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f05b22efb5e739b92b47527d29c5fa903f7e64b6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "753a6a9e29d4c8b4ee92345051fef61908c276b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/753a6a9e29d4c8b4ee92345051fef61908c276b6", "html_url": "https://github.com/rust-lang/rust/commit/753a6a9e29d4c8b4ee92345051fef61908c276b6"}, {"sha": "ea7768c2dd8089cc3c3dc1e27158cf1bed277308", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7768c2dd8089cc3c3dc1e27158cf1bed277308", "html_url": "https://github.com/rust-lang/rust/commit/ea7768c2dd8089cc3c3dc1e27158cf1bed277308"}], "stats": {"total": 107, "additions": 47, "deletions": 60}, "files": [{"sha": "2db9cc7c4d8deb9e1342ace2e14d6b351a57ccb8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -83,6 +83,7 @@\n #![feature(lang_items)]\n #![feature(no_std)]\n #![feature(nonzero)]\n+#![feature(num_bits_bytes)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]"}, {"sha": "97acd0db52478348da758770ee7e4a4b4ddf39d7", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -15,6 +15,7 @@ use heap;\n use super::oom;\n use super::boxed::Box;\n use core::ops::Drop;\n+use core;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating a\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -443,11 +444,8 @@ impl<T> Drop for RawVec<T> {\n // user-space. e.g. PAE or x32\n \n #[inline]\n-#[cfg(target_pointer_width = \"64\")]\n-fn alloc_guard(_alloc_size: usize) { }\n-\n-#[inline]\n-#[cfg(target_pointer_width = \"32\")]\n fn alloc_guard(alloc_size: usize) {\n-    assert!(alloc_size <= ::core::isize::MAX as usize, \"capacity overflow\");\n+    if core::usize::BITS < 64 {\n+        assert!(alloc_size <= ::core::isize::MAX as usize, \"capacity overflow\");\n+    }\n }"}, {"sha": "86700583f2dc68e9e2690b0f129272ba61881157", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -1340,12 +1340,7 @@ impl<T> Pointer for *const T {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n             if let None = f.width {\n-                // The formats need two extra bytes, for the 0x\n-                if cfg!(target_pointer_width = \"32\") {\n-                    f.width = Some(10);\n-                } else {\n-                    f.width = Some(18);\n-                }\n+                f.width = Some((::usize::BITS/4) + 2);\n             }\n         }\n         f.flags |= 1 << (FlagV1::Alternate as u32);"}, {"sha": "2a4c909d6384c5b877ade8e2970e2a2e0d4dd245", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -144,11 +144,11 @@ pub trait Hasher {\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n-        if cfg!(target_pointer_width = \"32\") {\n-            self.write_u32(i as u32)\n-        } else {\n-            self.write_u64(i as u64)\n-        }\n+        let bytes = unsafe {\n+            ::slice::from_raw_parts(&i as *const usize as *const u8,\n+                                    mem::size_of::<usize>())\n+        };\n+        self.write(bytes);\n     }\n \n     /// Write a single `i8` into this hasher."}, {"sha": "ed4053f35be6b1fe430aee58b6c91fe58ea75c62", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -2236,7 +2236,9 @@ step_impl_signed!(isize i8 i16 i32);\n step_impl_unsigned!(u64);\n #[cfg(target_pointer_width = \"64\")]\n step_impl_signed!(i64);\n-#[cfg(target_pointer_width = \"32\")]\n+// If the target pointer width is not 64-bits, we\n+// assume here that it is less than 64-bits.\n+#[cfg(not(target_pointer_width = \"64\"))]\n step_impl_no_between!(u64 i64);\n \n /// An adapter for stepping range iterators by a custom amount."}, {"sha": "1982f04195f0b3739dbad3fbcef7c8848669bfdc", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -943,11 +943,8 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match &ccx.sess().target.target.target_pointer_width[..] {\n-        \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n-        \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n-        tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n-    };\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let key = format!(\"llvm.memcpy.p0i8.p0i8.i{}\", ptr_width);\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n     let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n@@ -996,12 +993,8 @@ fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte:\n     let ccx = b.ccx;\n \n     let llty = type_of::type_of(ccx, ty);\n-\n-    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[..] {\n-        \"32\" => \"llvm.memset.p0i8.i32\",\n-        \"64\" => \"llvm.memset.p0i8.i64\",\n-        tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n-    };\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n \n     let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());"}, {"sha": "5707566b047277705c3dd12ac3a8de3361769490", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -833,10 +833,11 @@ pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_i64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<31) && v >= -(1<<31)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    if bit_size < 64 {\n+        // make sure it doesn't overflow\n+        assert!(v < (1<<(bit_size-1)) && v >= -(1<<(bit_size-1)));\n     }\n \n     C_integral(ccx.int_type(), v as u64, true)\n@@ -845,10 +846,11 @@ pub fn C_int<I: AsI64>(ccx: &CrateContext, i: I) -> ValueRef {\n pub fn C_uint<I: AsU64>(ccx: &CrateContext, i: I) -> ValueRef {\n     let v = i.as_u64();\n \n-    match machine::llbitsize_of_real(ccx, ccx.int_type()) {\n-        32 => assert!(v < (1<<32)),\n-        64 => {},\n-        n => panic!(\"unsupported target size: {}\", n)\n+    let bit_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    if bit_size < 64 {\n+        // make sure it doesn't overflow\n+        assert!(v < (1<<bit_size));\n     }\n \n     C_integral(ccx.int_type(), v, false)"}, {"sha": "7f383f568a08781db8281dc92e5fc0b5fafa0bd0", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -560,13 +560,13 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.builder.b\n     }\n \n-    pub fn get_intrinsic(&self, key: & &'static str) -> ValueRef {\n+    pub fn get_intrinsic(&self, key: &str) -> ValueRef {\n         if let Some(v) = self.intrinsics().borrow().get(key).cloned() {\n             return v;\n         }\n         match declare_intrinsic(self, key) {\n             Some(v) => return v,\n-            None => panic!()\n+            None => panic!(\"unknown intrinsic '{}'\", key)\n         }\n     }\n \n@@ -791,18 +791,18 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n }\n \n /// Declare any llvm intrinsics that you might need\n-fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n+fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {\n         ($name:expr, fn() -> $ret:expr) => (\n-            if *key == $name {\n+            if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[], &$ret),\n                                              ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n-            if *key == $name {\n+            if key == $name {\n                 let f = declare::declare_cfn(ccx, $name, Type::func(&[$($arg),*], &$ret),\n                                              ccx.tcx().mk_nil());\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n@@ -824,10 +824,13 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n \n@@ -942,7 +945,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             if unsafe { llvm::LLVMVersionMinor() >= $llvm_version } {\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> void);\n-            } else if *key == $name {\n+            } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &void),\n                                              ccx.tcx().mk_nil());\n@@ -965,7 +968,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             if unsafe { llvm::LLVMVersionMinor() >= $llvm_version } {\n                 // The `if key == $name` is already in ifn!\n                 ifn!($name, fn($($arg),*) -> $ret);\n-            } else if *key == $name {\n+            } else if key == $name {\n                 let f = declare::declare_cfn(ccx, stringify!($cname),\n                                              Type::func(&[$($arg),*], &$ret),\n                                              ccx.tcx().mk_nil());"}, {"sha": "33e5d814eb186a12787eb1b8c548bad8605a3d5d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f05b22efb5e739b92b47527d29c5fa903f7e64b6/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=f05b22efb5e739b92b47527d29c5fa903f7e64b6", "patch": "@@ -932,20 +932,15 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n-    let name = if allow_overlap {\n-        if int_size == 32 {\n-            \"llvm.memmove.p0i8.p0i8.i32\"\n-        } else {\n-            \"llvm.memmove.p0i8.p0i8.i64\"\n-        }\n+\n+    let operation = if allow_overlap {\n+        \"memmove\"\n     } else {\n-        if int_size == 32 {\n-            \"llvm.memcpy.p0i8.p0i8.i32\"\n-        } else {\n-            \"llvm.memcpy.p0i8.p0i8.i64\"\n-        }\n+        \"memcpy\"\n     };\n \n+    let name = format!(\"llvm.{}.p0i8.p0i8.i{}\", operation, int_size);\n+\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n@@ -973,11 +968,9 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n-    let name = if machine::llbitsize_of_real(ccx, ccx.int_type()) == 32 {\n-        \"llvm.memset.p0i8.i32\"\n-    } else {\n-        \"llvm.memset.p0i8.i64\"\n-    };\n+    let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n+\n+    let name = format!(\"llvm.memset.p0i8.i{}\", int_size);\n \n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);"}]}